[
  {
    "oid": "684eee3d24d7958ed2562401c34b89dc627bcd66",
    "message": "Allow caching to be disabled",
    "date": "2014-11-15T08:23:40Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/684eee3d24d7958ed2562401c34b89dc627bcd66",
    "details": {
      "sha": "57b5b41ebfd456d9454139508c1d8b8674e84ccd",
      "filename": "vertx-core/src/main/java/io/vertx/core/impl/FileResolver.java",
      "status": "modified",
      "additions": 20,
      "deletions": 16,
      "changes": 36,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/684eee3d24d7958ed2562401c34b89dc627bcd66/vertx-core%2Fsrc%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fimpl%2FFileResolver.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/684eee3d24d7958ed2562401c34b89dc627bcd66/vertx-core%2Fsrc%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fimpl%2FFileResolver.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/vertx-core%2Fsrc%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fimpl%2FFileResolver.java?ref=684eee3d24d7958ed2562401c34b89dc627bcd66",
      "patch": "@@ -44,22 +44,9 @@\n public class FileResolver {\n \n   private final Vertx vertx;\n+  private final boolean enableCaching = System.getProperty(\"vertx.disableFileCaching\") == null;\n   private File cacheDir;\n \n-  private void setupCacheDir() {\n-    if (cacheDir == null) {\n-      String cacheDirName = \".vertx/file-cache-\" + UUID.randomUUID().toString();\n-      cacheDir = new File(cacheDirName);\n-      if (cacheDir.exists()) {\n-        vertx.fileSystem().deleteSyncRecursive(cacheDir.getAbsolutePath(), true);\n-      } else {\n-        if (!cacheDir.mkdirs()) {\n-          throw new IllegalStateException(\"Failed to create cache dir\");\n-        }\n-      }\n-    }\n-  }\n-\n   public FileResolver(Vertx vertx) {\n     this.vertx = vertx;\n   }\n@@ -78,7 +65,7 @@ public File resolveFile(String fileName) {\n     if (!file.exists()) {\n       // Look for it in local file cache\n       File cacheFile = null;\n-      if (cacheDir != null) {\n+      if (enableCaching && cacheDir != null) {\n         cacheFile = new File(cacheDir, fileName);\n         if (cacheFile.exists()) {\n           return cacheFile;\n@@ -92,6 +79,9 @@ public File resolveFile(String fileName) {\n         if (cacheFile == null) {\n           setupCacheDir();\n           cacheFile = new File(cacheDir, fileName);\n+          if (!enableCaching && cacheFile.exists()) {\n+            cacheFile.delete();\n+          }\n           cacheFile.getParentFile().mkdirs();\n         }\n         try {\n@@ -101,7 +91,6 @@ public File resolveFile(String fileName) {\n         }\n         return cacheFile;\n       }\n-\n     }\n     return file;\n   }\n@@ -114,4 +103,19 @@ private ClassLoader getClassLoader() {\n     return cl;\n   }\n \n+  private void setupCacheDir() {\n+    if (cacheDir == null) {\n+      String cacheDirName = \".vertx/file-cache-\" + UUID.randomUUID().toString();\n+      cacheDir = new File(cacheDirName);\n+      if (cacheDir.exists()) {\n+        vertx.fileSystem().deleteSyncRecursive(cacheDir.getAbsolutePath(), true);\n+      } else {\n+        if (!cacheDir.mkdirs()) {\n+          throw new IllegalStateException(\"Failed to create cache dir\");\n+        }\n+      }\n+    }\n+  }\n+\n+\n }",
      "parent_sha": "f97f00bbd20da525cddab915e78af55abd880ea9"
    }
  },
  {
    "oid": "fb5ef766d36f692ed6bac4172ee5742dce1f97d8",
    "message": "Avoid deploying a verticle, not useful in this example\n\nSigned-off-by: Thomas Segismont <tsegismont@gmail.com>",
    "date": "2017-02-09T07:51:34Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/fb5ef766d36f692ed6bac4172ee5742dce1f97d8",
    "details": {
      "sha": "7865e03a96075d8201bb3678b539cebc3fccc03b",
      "filename": "src/test/java/io/vertx/test/core/EventBusTestBase.java",
      "status": "modified",
      "additions": 14,
      "deletions": 19,
      "changes": 33,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/fb5ef766d36f692ed6bac4172ee5742dce1f97d8/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FEventBusTestBase.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/fb5ef766d36f692ed6bac4172ee5742dce1f97d8/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FEventBusTestBase.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FEventBusTestBase.java?ref=fb5ef766d36f692ed6bac4172ee5742dce1f97d8",
      "patch": "@@ -393,25 +393,20 @@ public void testSendFromExecuteBlocking() throws Exception {\n       receivedLatch.countDown();\n     }).completionHandler(ar -> {\n       assertTrue(ar.succeeded());\n-      vertices[0].deployVerticle(new AbstractVerticle() {\n-        @Override\n-        public void start() throws Exception {\n-          vertx().executeBlocking(fut -> {\n-            vertices[0].eventBus().send(ADDRESS1, expectedBody);\n-            try {\n-              awaitLatch(receivedLatch); // Make sure message is sent even if we're busy\n-            } catch (InterruptedException e) {\n-              Thread.interrupted();\n-              fut.fail(e);\n-            }\n-            fut.complete();\n-          }, ar -> {\n-            if (ar.succeeded()) {\n-              testComplete();\n-            } else {\n-              fail(ar.cause());\n-            }\n-          });\n+      vertices[0].executeBlocking(fut -> {\n+        vertices[0].eventBus().send(ADDRESS1, expectedBody);\n+        try {\n+          awaitLatch(receivedLatch); // Make sure message is sent even if we're busy\n+        } catch (InterruptedException e) {\n+          Thread.interrupted();\n+          fut.fail(e);\n+        }\n+        fut.complete();\n+      }, ar2 -> {\n+        if (ar2.succeeded()) {\n+          testComplete();\n+        } else {\n+          fail(ar2.cause());\n         }\n       });\n     });",
      "parent_sha": "dcee9a41ea9704c30fb3fb4f18c25a7cf327402a"
    }
  },
  {
    "oid": "9970408876cabf81c21e150bc89ece7046044a1f",
    "message": "Minor improvement",
    "date": "2016-03-13T22:21:34Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/9970408876cabf81c21e150bc89ece7046044a1f",
    "details": {
      "sha": "06196b9f8a4b674d8008748acdc2c20844a053ae",
      "filename": "src/main/java/io/vertx/core/http/impl/Http2Pool.java",
      "status": "modified",
      "additions": 3,
      "deletions": 7,
      "changes": 10,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/9970408876cabf81c21e150bc89ece7046044a1f/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FHttp2Pool.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/9970408876cabf81c21e150bc89ece7046044a1f/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FHttp2Pool.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FHttp2Pool.java?ref=9970408876cabf81c21e150bc89ece7046044a1f",
      "patch": "@@ -98,7 +98,9 @@ public VertxClientHandlerBuilder(ChannelHandlerContext handlerCtx, ContextImpl c\n \n     @Override\n     protected VertxHttp2ClientHandler build(Http2ConnectionDecoder decoder, Http2ConnectionEncoder encoder, Http2Settings initialSettings) throws Exception {\n-      return new VertxHttp2ClientHandler(Http2Pool.this, handlerCtx, context, channel, decoder, encoder, initialSettings);\n+      VertxHttp2ClientHandler handler = new VertxHttp2ClientHandler(Http2Pool.this, handlerCtx, context, channel, decoder, encoder, initialSettings);\n+      frameListener(handler);\n+      return handler;\n     }\n \n     public VertxHttp2ClientHandler build(Http2Connection conn) {\n@@ -124,12 +126,6 @@ public VertxHttp2ClientHandler build(Http2Connection conn) {\n           initialSettings().pushEnabled(initialSettings.getEnablePush());\n         }\n       }\n-      frameListener(new Http2EventAdapter() {\n-        @Override\n-        public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding, boolean endOfStream) throws Http2Exception {\n-          return super.onDataRead(ctx, streamId, data, padding, endOfStream);\n-        }\n-      });\n       return super.build();\n     }\n   }",
      "parent_sha": "33e7a98b37a78d1a5b1a487643e0137fcac97306"
    }
  },
  {
    "oid": "48e62ae5268005a7e4cdb3d11dd7085c8feb7663",
    "message": "Modified Javadoc of ws.closeWithReason()\n\nSigned-off-by: francesco <francescoguard@gmail.com>",
    "date": "2018-01-17T21:23:03Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/48e62ae5268005a7e4cdb3d11dd7085c8feb7663",
    "details": {
      "sha": "48d1832904c97b3ae874c92d2962f7ef30371ea9",
      "filename": "src/main/java/io/vertx/core/http/WebSocketBase.java",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/48e62ae5268005a7e4cdb3d11dd7085c8feb7663/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FWebSocketBase.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/48e62ae5268005a7e4cdb3d11dd7085c8feb7663/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FWebSocketBase.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FWebSocketBase.java?ref=48e62ae5268005a7e4cdb3d11dd7085c8feb7663",
      "patch": "@@ -240,9 +240,13 @@ public interface WebSocketBase extends ReadStream<Buffer>, WriteStream<Buffer> {\n   void close();\n \n   /*\n-   * Close sending a close frame with specified status code and reason\n+   * Close sending a close frame with specified status code and reason. You can give a look at various close payloads\n+   * here: <a href=\"https://tools.ietf.org/html/rfc6455#section-7.4.1\">RFC6455 Section 7.4.1</a>\n+   *\n+   * @param statusCode Status code\n+   * @param reason reason of closure\n    */\n-  void closeWithReason(short statusCode, String reason);\n+  void closeWithReason(short statusCode, @Nullable String reason);\n \n   /**\n    * @return the remote address for this socket",
      "parent_sha": "dc1ab187c2f5b1906b4b19bff2b8c740a768bfb6"
    }
  },
  {
    "oid": "f6791108246d54599d9a04c9ce27673fadab0de5",
    "message": "Minor refactor in MessageImpl",
    "date": "2019-03-02T17:14:10Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/f6791108246d54599d9a04c9ce27673fadab0de5",
    "details": {
      "sha": "621efc924897533681465ecb3b18b370518e71ae",
      "filename": "src/main/java/io/vertx/core/eventbus/impl/MessageImpl.java",
      "status": "modified",
      "additions": 3,
      "deletions": 9,
      "changes": 12,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/f6791108246d54599d9a04c9ce27673fadab0de5/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2Fimpl%2FMessageImpl.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/f6791108246d54599d9a04c9ce27673fadab0de5/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2Fimpl%2FMessageImpl.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2Fimpl%2FMessageImpl.java?ref=f6791108246d54599d9a04c9ce27673fadab0de5",
      "patch": "@@ -106,10 +106,7 @@ public String replyAddress() {\n \n   @Override\n   public void fail(int failureCode, String message) {\n-    if (replyAddress != null) {\n-      sendReply(bus.createMessage(true, replyAddress, null,\n-        new ReplyException(ReplyFailure.RECIPIENT_FAILURE, failureCode, message), null), null, null);\n-    }\n+    reply(new ReplyException(ReplyFailure.RECIPIENT_FAILURE, failureCode, message));\n   }\n \n   @Override\n@@ -130,7 +127,8 @@ public void reply(Object message, DeliveryOptions options) {\n   @Override\n   public <R> void reply(Object message, DeliveryOptions options, Handler<AsyncResult<Message<R>>> replyHandler) {\n     if (replyAddress != null) {\n-      sendReply(bus.createMessage(true, replyAddress, options.getHeaders(), message, options.getCodecName()), options, replyHandler);\n+      MessageImpl reply = bus.createMessage(true, replyAddress, options.getHeaders(), message, options.getCodecName());\n+      bus.sendReply(reply, this, options, replyHandler);\n     }\n   }\n \n@@ -147,10 +145,6 @@ public MessageCodec<U, V> codec() {\n     return messageCodec;\n   }\n \n-  protected <R> void sendReply(MessageImpl msg, DeliveryOptions options, Handler<AsyncResult<Message<R>>> replyHandler) {\n-    bus.sendReply(msg, this, options, replyHandler);\n-  }\n-\n   protected boolean isLocal() {\n     return true;\n   }",
      "parent_sha": "53f7c8d953cf5edd719b1e15d9ea1b1e8f9c70dd"
    }
  },
  {
    "oid": "3803e473fb1db2e0163650385109c0ffbcf1f017",
    "message": "Fixed indentation so example is shown properly",
    "date": "2023-12-06T17:13:05Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/3803e473fb1db2e0163650385109c0ffbcf1f017",
    "details": {
      "sha": "40ff2cdbaa58f8a40555db8d13c01c8720328e44",
      "filename": "src/main/java/examples/NetExamples.java",
      "status": "modified",
      "additions": 11,
      "deletions": 10,
      "changes": 21,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/3803e473fb1db2e0163650385109c0ffbcf1f017/src%2Fmain%2Fjava%2Fexamples%2FNetExamples.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/3803e473fb1db2e0163650385109c0ffbcf1f017/src%2Fmain%2Fjava%2Fexamples%2FNetExamples.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fexamples%2FNetExamples.java?ref=3803e473fb1db2e0163650385109c0ffbcf1f017",
      "patch": "@@ -726,21 +726,22 @@ public void useSNIInClient(Vertx vertx, JksOptions trustOptions) {\n \n   public void configureTrafficShapingForNetServer(Vertx vertx) {\n     NetServerOptions options = new NetServerOptions()\n-                                 .setHost(\"localhost\")\n-                                 .setPort(1234)\n-                                 .setTrafficShapingOptions(new TrafficShapingOptions()\n-                                                             .setInboundGlobalBandwidth(64 * 1024)\n-                                                             .setOutboundGlobalBandwidth(128 * 1024));\n+      .setHost(\"localhost\")\n+      .setPort(1234)\n+      .setTrafficShapingOptions(new TrafficShapingOptions()\n+        .setInboundGlobalBandwidth(64 * 1024)\n+        .setOutboundGlobalBandwidth(128 * 1024));\n+\n     NetServer server = vertx.createNetServer(options);\n   }\n \n   public void configureTrafficShapingForHttpServer(Vertx vertx) {\n     HttpServerOptions options = new HttpServerOptions()\n-                                  .setHost(\"localhost\")\n-                                  .setPort(1234)\n-                                  .setTrafficShapingOptions(new TrafficShapingOptions()\n-                                                              .setInboundGlobalBandwidth(64 * 1024)\n-                                                              .setOutboundGlobalBandwidth(128 * 1024));\n+      .setHost(\"localhost\")\n+      .setPort(1234)\n+      .setTrafficShapingOptions(new TrafficShapingOptions()\n+        .setInboundGlobalBandwidth(64 * 1024)\n+        .setOutboundGlobalBandwidth(128 * 1024));\n \n     HttpServer server = vertx.createHttpServer(options);\n   }",
      "parent_sha": "e9a1c48372fa800f8118ea2f5a47cbbd68437bbe"
    }
  },
  {
    "oid": "d811d9cdb8a5727b8e481a3f4dbf929f32f43ec1",
    "message": "Fix incorrect WebsocketTest that don't assume that now a close frame can be received",
    "date": "2018-06-20T09:18:52Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/d811d9cdb8a5727b8e481a3f4dbf929f32f43ec1",
    "details": {
      "sha": "56154e1229ac973e625550491b13127c4729e9de",
      "filename": "src/test/java/io/vertx/test/core/WebsocketTest.java",
      "status": "modified",
      "additions": 39,
      "deletions": 28,
      "changes": 67,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/d811d9cdb8a5727b8e481a3f4dbf929f32f43ec1/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FWebsocketTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/d811d9cdb8a5727b8e481a3f4dbf929f32f43ec1/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FWebsocketTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FWebsocketTest.java?ref=d811d9cdb8a5727b8e481a3f4dbf929f32f43ec1",
      "patch": "@@ -504,7 +504,6 @@ public void testHandleWSManually() throws Exception {\n     server.listen(ar -> {\n       assertTrue(ar.succeeded());\n       client.websocketStream(DEFAULT_HTTP_PORT, HttpTestBase.DEFAULT_HTTP_HOST, path).\n-          exceptionHandler(t -> fail(t.getMessage())).\n           handler(ws -> {\n             ws.handler(buff -> {\n               assertEquals(message, buff.toString(\"UTF-8\"));\n@@ -713,28 +712,32 @@ private void testWSFrames(boolean binary, WebsocketVersion version) throws Excep\n       assertEquals(\"upgrade\", ws.headers().get(\"Connection\"));\n       AtomicInteger count = new AtomicInteger();\n       ws.frameHandler(frame -> {\n-        if (count.get() == 0) {\n-          if (binary) {\n-            assertTrue(frame.isBinary());\n-            assertFalse(frame.isText());\n+        if (frame.isClose()) {\n+          testComplete();\n+        } else {\n+          if (count.get() == 0) {\n+            if (binary) {\n+              assertTrue(frame.isBinary());\n+              assertFalse(frame.isText());\n+            } else {\n+              assertFalse(frame.isBinary());\n+              assertTrue(frame.isText());\n+            }\n+            assertFalse(frame.isContinuation());\n           } else {\n             assertFalse(frame.isBinary());\n-            assertTrue(frame.isText());\n+            assertFalse(frame.isText());\n+            assertTrue(frame.isContinuation());\n+          }\n+          if (count.get() == frames - 1) {\n+            assertTrue(frame.isFinal());\n+          } else {\n+            assertFalse(frame.isFinal());\n+          }\n+          ws.writeFrame(frame);\n+          if (count.incrementAndGet() == frames) {\n+            count.set(0);\n           }\n-          assertFalse(frame.isContinuation());\n-        } else {\n-          assertFalse(frame.isBinary());\n-          assertFalse(frame.isText());\n-          assertTrue(frame.isContinuation());\n-        }\n-        if (count.get() == frames - 1) {\n-          assertTrue(frame.isFinal());\n-        } else {\n-          assertFalse(frame.isFinal());\n-        }\n-        ws.writeFrame(frame);\n-        if (count.incrementAndGet() == frames) {\n-          count.set(0);\n         }\n       });\n     });\n@@ -763,7 +766,7 @@ private void testWSFrames(boolean binary, WebsocketVersion version) throws Excep\n               for (Buffer rec : received) {\n                 assertEquals(rec, sent.get(pos++));\n               }\n-              testComplete();\n+              ws.close();\n             }\n           });\n \n@@ -813,6 +816,7 @@ public void testWriteFinalBinaryFrame() throws Exception {\n \n   private void testWriteFinalFrame(boolean binary) throws Exception {\n \n+    waitFor(2);\n     String text = TestUtils.randomUnicodeString(100);\n     Buffer data = TestUtils.randomBuffer(100);\n \n@@ -831,22 +835,29 @@ private void testWriteFinalFrame(boolean binary) throws Exception {\n \n     server = vertx.createHttpServer(new HttpServerOptions().setPort(DEFAULT_HTTP_PORT)).websocketHandler(ws ->\n       ws.frameHandler(frame -> {\n-        frameConsumer.accept(frame);\n-        if (binary) {\n-          ws.writeFinalBinaryFrame(frame.binaryData());\n+        if (frame.isClose()) {\n+          complete();\n         } else {\n-          ws.writeFinalTextFrame(frame.textData());\n+          frameConsumer.accept(frame);\n+          if (binary) {\n+            ws.writeFinalBinaryFrame(frame.binaryData());\n+          } else {\n+            ws.writeFinalTextFrame(frame.textData());\n+          }\n         }\n       })\n     );\n \n     server.listen(onSuccess(s ->\n       client.websocket(DEFAULT_HTTP_PORT, HttpTestBase.DEFAULT_HTTP_HOST, \"/\", ws -> {\n         ws.frameHandler(frame -> {\n-          frameConsumer.accept(frame);\n-          testComplete();\n+          if (frame.isClose()) {\n+            complete();\n+          } else {\n+            frameConsumer.accept(frame);\n+            ws.close();\n+          }\n         });\n-\n         if (binary) {\n           ws.writeFinalBinaryFrame(data);\n         } else {",
      "parent_sha": "a6114607b00cf584fc149e9f687019f4af182925"
    }
  },
  {
    "oid": "5cbc77998c910a48a63cdb20ec12a29458e96a9c",
    "message": "Fix incorrect test",
    "date": "2020-07-22T10:40:23Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/5cbc77998c910a48a63cdb20ec12a29458e96a9c",
    "details": {
      "sha": "2aca0a60d61a86153ac69aefa9495d9594384968",
      "filename": "src/test/java/io/vertx/core/http/HttpTest.java",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/5cbc77998c910a48a63cdb20ec12a29458e96a9c/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttpTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/5cbc77998c910a48a63cdb20ec12a29458e96a9c/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttpTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttpTest.java?ref=5cbc77998c910a48a63cdb20ec12a29458e96a9c",
      "patch": "@@ -3874,7 +3874,11 @@ private void testFollowRedirect(\n         assertEquals(expectedRequests, numRequests.get());\n         assertEquals(expectedStatus, resp.statusCode());\n         resp.bodyHandler(body -> {\n-          assertEquals(expectedBody, body);\n+          if (resp.statusCode() == 200) {\n+            assertEquals(expectedBody, body);\n+          } else {\n+            assertEquals(Buffer.buffer(), body);\n+          }\n           testComplete();\n         });\n       }));",
      "parent_sha": "895dcc05ea8a014e970222f7fcb97f6c71135ed6"
    }
  },
  {
    "oid": "f939c47b690611c91f71f802c3e31cd3db4d2286",
    "message": "The ContextTest#testInternalExecuteBlockingWithQueue is subject to races. In order to be correct and assume that the thread will always be the same, the first task should wait until all blocking tasks are queued. Therefore we should wait until all blocking tasks are submitted during the first task execution to continue the execution.",
    "date": "2020-09-06T21:16:33Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/f939c47b690611c91f71f802c3e31cd3db4d2286",
    "details": {
      "sha": "2c6e1537e6b2cc1a89fe74059d8a8e5d5ec27099",
      "filename": "src/test/java/io/vertx/core/ContextTest.java",
      "status": "modified",
      "additions": 14,
      "deletions": 6,
      "changes": 20,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/f939c47b690611c91f71f802c3e31cd3db4d2286/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2FContextTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/f939c47b690611c91f71f802c3e31cd3db4d2286/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2FContextTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2FContextTest.java?ref=f939c47b690611c91f71f802c3e31cd3db4d2286",
      "patch": "@@ -363,7 +363,8 @@ public void testInternalExecuteBlockingWithQueue() {\n     for (int i = 0;i < queues.length;i++) {\n       current[i] = new AtomicReference<>();\n     }\n-    CyclicBarrier barrier = new CyclicBarrier(queues.length);\n+    CyclicBarrier barrier = new CyclicBarrier(2);\n+    CountDownLatch latch = new CountDownLatch(3);\n     int numTasks = 10;\n     for (int i = 0;i < numTasks;i++) {\n       int ival = i;\n@@ -372,20 +373,27 @@ public void testInternalExecuteBlockingWithQueue() {\n         context.executeBlocking(fut -> {\n           if (ival == 0) {\n             current[jval].set(Thread.currentThread());\n+            latch.countDown();\n+            try {\n+              latch.await(20, TimeUnit.SECONDS);\n+            } catch (InterruptedException e) {\n+              fail(e);\n+            }\n           } else {\n             assertSame(Thread.currentThread(), current[jval].get());\n-          }\n-          try {\n-            barrier.await();\n-          } catch (Exception e) {\n-            fail(e);\n+            try {\n+              barrier.await();\n+            } catch (Exception e) {\n+              fail(e);\n+            }\n           }\n           if (ival == numTasks - 1) {\n             complete();\n           }\n         }, queues[j], ar -> {});\n       }\n     }\n+    latch.countDown();\n     await();\n   }\n ",
      "parent_sha": "23159c399eb2b5dae806cb92ed62c600b8b75835"
    }
  },
  {
    "oid": "3cd005e4bb7182abd7d92cc5b0afca12d26cd75a",
    "message": "add http2 client executeBlocking test\n\nSigned-off-by: Josef Pfleger <green-carrot@orange-cactus.org>",
    "date": "2016-11-08T09:55:44Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/3cd005e4bb7182abd7d92cc5b0afca12d26cd75a",
    "details": {
      "sha": "d289884cb90ebaf24e7479747963375d8a07c873",
      "filename": "src/test/java/io/vertx/test/core/Http2ClientTest.java",
      "status": "modified",
      "additions": 22,
      "deletions": 1,
      "changes": 23,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/3cd005e4bb7182abd7d92cc5b0afca12d26cd75a/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttp2ClientTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/3cd005e4bb7182abd7d92cc5b0afca12d26cd75a/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttp2ClientTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttp2ClientTest.java?ref=3cd005e4bb7182abd7d92cc5b0afca12d26cd75a",
      "patch": "@@ -1815,7 +1815,7 @@ public void testFillsSingleConnection() throws Exception {\n   }\n */\n   @Test\n-  public void testHttp2ClientInWorkerVerticle() throws Exception {\n+  public void testWorkerVerticleException() throws Exception {\n     Verticle workerVerticle = new AbstractVerticle() {\n       @Override\n       public void start() throws Exception {\n@@ -1831,4 +1831,25 @@ public void start() throws Exception {\n     vertx.deployVerticle(workerVerticle, new DeploymentOptions().setWorker(true));\n     await();\n   }\n+\n+  @Test\n+  public void testExecuteBlocking() throws Exception {\n+\n+    String expected = TestUtils.randomAlphaString(27);\n+    server.requestHandler(req -> req.response().end(expected));\n+    startServer();\n+\n+    vertx.executeBlocking(fut -> {\n+      client = vertx.createHttpClient(createHttp2ClientOptions());\n+      client.getNow(DEFAULT_HTTPS_PORT, DEFAULT_HTTPS_HOST, \"/\", resp -> {\n+        resp.bodyHandler(body -> fut.complete(body.toString()));\n+      });\n+    }, res -> {\n+      assertTrue(res.succeeded());\n+      assertEquals(expected, res.result());\n+      complete();\n+    });\n+\n+    await();\n+  }\n }",
      "parent_sha": "fa6652cf905b808a5e3647e4898bda44e805b485"
    }
  },
  {
    "oid": "a4d13b6e25d51de3b73df9cee6bf47f6ac66fdf9",
    "message": "Extract the ConnectionListener creation in a separate method in Pool",
    "date": "2018-05-25T07:21:53Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/a4d13b6e25d51de3b73df9cee6bf47f6ac66fdf9",
    "details": {
      "sha": "d7af13fe9fd9b827589324526b794fad52eb8ad4",
      "filename": "src/main/java/io/vertx/core/http/impl/pool/Pool.java",
      "status": "modified",
      "additions": 9,
      "deletions": 3,
      "changes": 12,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/a4d13b6e25d51de3b73df9cee6bf47f6ac66fdf9/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2Fpool%2FPool.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/a4d13b6e25d51de3b73df9cee6bf47f6ac66fdf9/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2Fpool%2FPool.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2Fpool%2FPool.java?ref=a4d13b6e25d51de3b73df9cee6bf47f6ac66fdf9",
      "patch": "@@ -237,9 +237,8 @@ private void checkPending() {\n     }\n   }\n \n-  private void createConnection(Waiter<C> waiter) {\n-    Holder<C> holder  = new Holder<>();\n-    ConnectionListener<C> listener = new ConnectionListener<C>() {\n+  private ConnectionListener<C> createListener(Holder<C> holder) {\n+    return new ConnectionListener<C>() {\n       @Override\n       public void onConcurrencyChange(long concurrency) {\n         synchronized (Pool.this) {\n@@ -259,6 +258,7 @@ public void onConcurrencyChange(long concurrency) {\n           }\n         }\n       }\n+\n       @Override\n       public void onRecycle(long expirationTimestamp) {\n         if (expirationTimestamp < 0L) {\n@@ -271,6 +271,7 @@ public void onRecycle(long expirationTimestamp) {\n           recycle(holder, 1, expirationTimestamp);\n         }\n       }\n+\n       @Override\n       public void onDiscard() {\n         synchronized (Pool.this) {\n@@ -281,6 +282,11 @@ public void onDiscard() {\n         }\n       }\n     };\n+  }\n+\n+  private void createConnection(Waiter<C> waiter) {\n+    Holder<C> holder  = new Holder<>();\n+    ConnectionListener<C> listener = createListener(holder);\n     connector.connect(listener, waiter.context, ar -> {\n       if (ar.succeeded()) {\n         ConnectResult<C> result = ar.result();",
      "parent_sha": "1bb6445226c39a95e7d07ce3caaf56828e8aab72"
    }
  },
  {
    "oid": "8d688d357d126a4ba96e59e66727c18a58424c13",
    "message": "Improve Http1xTest#testHttpServerWithIdleTimeoutSendChunkedFile that needs to probe the actual time to send a chunked file to pass reliably independantly of the test env.",
    "date": "2024-09-22T18:39:36Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/8d688d357d126a4ba96e59e66727c18a58424c13",
    "details": {
      "sha": "221fe376409ae9aa617fe74329bcd283b9105677",
      "filename": "vertx-core/src/test/java/io/vertx/tests/http/Http1xTest.java",
      "status": "modified",
      "additions": 28,
      "deletions": 18,
      "changes": 46,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/8d688d357d126a4ba96e59e66727c18a58424c13/vertx-core%2Fsrc%2Ftest%2Fjava%2Fio%2Fvertx%2Ftests%2Fhttp%2FHttp1xTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/8d688d357d126a4ba96e59e66727c18a58424c13/vertx-core%2Fsrc%2Ftest%2Fjava%2Fio%2Fvertx%2Ftests%2Fhttp%2FHttp1xTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/vertx-core%2Fsrc%2Ftest%2Fjava%2Fio%2Fvertx%2Ftests%2Fhttp%2FHttp1xTest.java?ref=8d688d357d126a4ba96e59e66727c18a58424c13",
      "patch": "@@ -4859,21 +4859,36 @@ public void start(Promise<Void> startFuture) {\n   public void testHttpServerWithIdleTimeoutSendChunkedFile() throws Exception {\n     // Does not pass reliably in CI (timeout)\n     Assume.assumeTrue(!vertx.isNativeTransportEnabled() && !Utils.isWindows());\n-    int expected = 64 * 1024 * 1024; // We estimate this will take more than 200ms to transfer with a 1ms pause in chunks\n-    File sent = TestUtils.tmpFile(\".dat\", expected);\n-    server.close();\n+    int expected = 32 * 1024 * 1024;\n+    File file = TestUtils.tmpFile(\".dat\", expected);\n+    // Estimate the delay to transfer a file with a 1ms pause in chunks\n+    int delay = retrieveFileFromServer(file, createBaseServerOptions());\n+    // Now test with timeout relative to this delay\n+    int timeout = delay / 2;\n+    delay = retrieveFileFromServer(file, createBaseServerOptions().setIdleTimeout(timeout).setIdleTimeoutUnit(TimeUnit.MILLISECONDS));\n+    assertTrue(delay > timeout);\n+  }\n+\n+  private int retrieveFileFromServer(File file, HttpServerOptions options) throws Exception {\n+    server.close().await();\n     server = vertx\n-      .createHttpServer(createBaseServerOptions().setIdleTimeout(1000).setIdleTimeoutUnit(TimeUnit.MILLISECONDS))\n+      .createHttpServer(options)\n       .requestHandler(\n         req -> {\n-          req.response().sendFile(sent.getAbsolutePath());\n+          req.response().sendFile(file.getAbsolutePath());\n         });\n     startServer(testAddress);\n-    client.request(requestOptions)\n-      .onComplete(onSuccess(req -> {\n-        req.send().onComplete(onSuccess(resp -> {\n-          long now = System.currentTimeMillis();\n-          int[] length = {0};\n+    long now = System.currentTimeMillis();\n+    Integer len = getFile().await();\n+    assertEquals((int)len, file.length());\n+    return (int) (System.currentTimeMillis() - now);\n+  }\n+\n+  private Future<Integer> getFile() {\n+    int[] length = {0};\n+    return client.request(requestOptions)\n+      .compose(req -> req.send()\n+        .compose(resp -> {\n           resp.handler(buff -> {\n             length[0] += buff.length();\n             resp.pause();\n@@ -4882,14 +4897,9 @@ public void testHttpServerWithIdleTimeoutSendChunkedFile() throws Exception {\n             });\n           });\n           resp.exceptionHandler(this::fail);\n-          resp.endHandler(v -> {\n-            assertEquals(expected, length[0]);\n-            assertTrue(System.currentTimeMillis() - now > 1000);\n-            testComplete();\n-          });\n-        }));\n-      }));\n-    await();\n+          return resp.end();\n+        }))\n+      .map(v -> length[0]);\n   }\n \n   @Test",
      "parent_sha": "49d2754b2b2e89c84463b4c912e58d58fda5e6ef"
    }
  },
  {
    "oid": "2c54573dc48d24f4739b191c7e5ec351e10ea006",
    "message": "Updated todo",
    "date": "2016-03-13T22:21:34Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/2c54573dc48d24f4739b191c7e5ec351e10ea006",
    "details": {
      "sha": "e44dc245bbebb785ba19eb9411b1ef16a16f1e39",
      "filename": "src/main/java/io/vertx/core/http/HttpConnection.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/2c54573dc48d24f4739b191c7e5ec351e10ea006/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttpConnection.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/2c54573dc48d24f4739b191c7e5ec351e10ea006/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttpConnection.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttpConnection.java?ref=2c54573dc48d24f4739b191c7e5ec351e10ea006",
      "patch": "@@ -41,15 +41,15 @@\n  * - HttpConnection test\n  *\n  * Both:\n+ * - CONNECT support / check\n  * - byte distribution algorithm configurability (options ? connection ?)\n- * - h2c\n- * - http upgrade\n+ * - h2c / http upgrade\n  * - metrics\n  * - close connection when service closes\n  *\n  * not yet in scope:\n  * - stream priority\n- * - unknown frames (send / receive)\n+ * - unknown frames (send / receive) / could be as it is interesting for building extension on top of HTTP2 and it seems quite easy to do\n  *\n  * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n  */",
      "parent_sha": "f2835d70d44318cf1547bd1474fd1bf7ea9cc6aa"
    }
  },
  {
    "oid": "c3e651abdcad74faad3d6e9dea9b8b60680fd87c",
    "message": "bug: second part of the test was always true\n\nSigned-off-by: Paulo Lopes <pmlopes@gmail.com>",
    "date": "2017-09-11T07:54:42Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/c3e651abdcad74faad3d6e9dea9b8b60680fd87c",
    "details": {
      "sha": "cd243cc4a17b8154b56d62bee874e11ba186d627",
      "filename": "src/main/java/io/vertx/core/http/Http2Settings.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/c3e651abdcad74faad3d6e9dea9b8b60680fd87c/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttp2Settings.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/c3e651abdcad74faad3d6e9dea9b8b60680fd87c/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttp2Settings.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttp2Settings.java?ref=c3e651abdcad74faad3d6e9dea9b8b60680fd87c",
      "patch": "@@ -295,8 +295,8 @@ public Long get(int id) {\n    * @return a reference to this, so the API can be used fluently\n    */\n   public Http2Settings set(int id, long value) {\n-    Arguments.require(id >= 0 || id <= 0xFFFF, \"Setting id must me an unsigned 16-bit value\");\n-    Arguments.require(value >= 0 || value <= 0xFFFFFFFF, \"Setting value must me an unsigned 32-bit value\");\n+    Arguments.require(id >= 0 && id <= 0xFFFF, \"Setting id must me an unsigned 16-bit value\");\n+    Arguments.require(value >= 0L && value <= 0xFFFFFFFFL, \"Setting value must me an unsigned 32-bit value\");\n     switch (id) {\n       case 1:\n         setHeaderTableSize(value);",
      "parent_sha": "9472a1d29bca2268e5cdf95024cd75ca3a9383da"
    }
  },
  {
    "oid": "5700b170e7e8c01f6404b672386b80e6394f514b",
    "message": "Fix incorrect HTTP/2 testing stream priority change",
    "date": "2019-12-04T09:24:24Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/5700b170e7e8c01f6404b672386b80e6394f514b",
    "details": {
      "sha": "db2e02a08d5b3b5bbfcb6c384d5f4652d6655134",
      "filename": "src/test/java/io/vertx/core/http/Http2Test.java",
      "status": "modified",
      "additions": 58,
      "deletions": 34,
      "changes": 92,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/5700b170e7e8c01f6404b672386b80e6394f514b/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttp2Test.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/5700b170e7e8c01f6404b672386b80e6394f514b/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttp2Test.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttp2Test.java?ref=5700b170e7e8c01f6404b672386b80e6394f514b",
      "patch": "@@ -542,56 +542,80 @@ public void testStreamWeightAndDependencyChange() throws Exception {\n   }\n \n   @Test\n-  public void testStreamWeightAndDependencyNoChange() throws Exception {\n-    int requestStreamDependency = 56;\n-    short requestStreamWeight = 43;\n-    int responseStreamDependency = 98;\n-    short responseStreamWeight = 55;\n+  public void testServerStreamPriorityNoChange() throws Exception {\n+    int dependency = 56;\n+    short weight = 43;\n+    boolean exclusive = true;\n     waitFor(2);\n     server.requestHandler(req -> {\n-      req.streamPriorityHandler( sp -> {\n-          fail(\"Stream priority handler shoudl not be called\");\n+      req.streamPriorityHandler(sp -> {\n+        fail(\"Stream priority handler should not be called \" + sp);\n+      });\n+      assertEquals(weight, req.streamPriority().getWeight());\n+      assertEquals(dependency, req.streamPriority().getDependency());\n+      assertEquals(exclusive, req.streamPriority().isExclusive());\n+      req.response().end();\n+      req.endHandler(v -> {\n+        complete();\n       });\n-      assertEquals(requestStreamWeight, req.streamPriority().getWeight());\n-      assertEquals(requestStreamDependency, req.streamPriority().getDependency());\n-      req.response().setStreamPriority(new StreamPriority()\n-        .setDependency(responseStreamDependency)\n-        .setWeight(responseStreamWeight)\n-        .setExclusive(false));\n-      req.response().write(\"hello\");\n-      req.response().setStreamPriority(new StreamPriority()\n-        .setDependency(responseStreamDependency)\n-        .setWeight(responseStreamWeight)\n-        .setExclusive(false));\n-      req.response().drainHandler(h -> {});\n-      req.response().end(\"world\");\n-      complete();\n     });\n     startServer(testAddress);\n     client = vertx.createHttpClient(createBaseClientOptions().setHttp2KeepAliveTimeout(3).setPoolCleanerPeriod(1));\n     HttpClientRequest request = client.request(HttpMethod.GET, testAddress, DEFAULT_HTTP_PORT, DEFAULT_HTTP_HOST, DEFAULT_TEST_URI, onSuccess(resp -> {\n-      assertEquals(responseStreamWeight, resp.request().getStreamPriority().getWeight());\n-      assertEquals(responseStreamDependency, resp.request().getStreamPriority().getDependency());\n-      resp.streamPriorityHandler( sp -> {\n-          fail(\"Stream priority handler shoudl not be called\");\n-          complete();\n-        });\n-      complete();\n+      resp.endHandler(v -> {\n+        complete();\n+      });\n     }));\n     request.setStreamPriority(new StreamPriority()\n-      .setDependency(requestStreamDependency)\n-      .setWeight(requestStreamWeight)\n-      .setExclusive(false));\n+      .setDependency(dependency)\n+      .setWeight(weight)\n+      .setExclusive(exclusive));\n     request.sendHead(h -> {\n       request.setStreamPriority(new StreamPriority()\n-        .setDependency(requestStreamDependency)\n-        .setWeight(requestStreamWeight)\n-        .setExclusive(false));\n+        .setDependency(dependency)\n+        .setWeight(weight)\n+        .setExclusive(exclusive));\n       request.end();\n     });\n     await();\n   }\n \n+  @Test\n+  public void testClientStreamPriorityNoChange() throws Exception {\n+    int dependency = 98;\n+    short weight = 55;\n+    boolean exclusive = false;\n+    waitFor(2);\n+    server.requestHandler(req -> {\n+      req.response().setStreamPriority(new StreamPriority()\n+        .setDependency(dependency)\n+        .setWeight(weight)\n+        .setExclusive(exclusive));\n+      req.response().write(\"hello\");\n+      req.response().setStreamPriority(new StreamPriority()\n+        .setDependency(dependency)\n+        .setWeight(weight)\n+        .setExclusive(exclusive));\n+      req.response().end(\"world\");\n+      req.endHandler(v -> {\n+        complete();\n+      });\n+    });\n+    startServer(testAddress);\n+    client = vertx.createHttpClient(createBaseClientOptions().setHttp2KeepAliveTimeout(3).setPoolCleanerPeriod(1));\n+    client.request(HttpMethod.GET, testAddress, DEFAULT_HTTP_PORT, DEFAULT_HTTP_HOST, DEFAULT_TEST_URI, onSuccess(resp -> {\n+      assertEquals(weight, resp.request().getStreamPriority().getWeight());\n+      assertEquals(dependency, resp.request().getStreamPriority().getDependency());\n+      assertEquals(exclusive, resp.request().getStreamPriority().isExclusive());\n+      resp.streamPriorityHandler(sp -> {\n+        fail(\"Stream priority handler should not be called\");\n+      });\n+      resp.endHandler(v -> {\n+        complete();\n+      });\n+    })).end();\n+    await();\n+  }\n \n   @Test\n   public void testStreamWeightAndDependencyInheritance() throws Exception {",
      "parent_sha": "2c4cc5324697822b47a49402ed2a32090c88dd7d"
    }
  },
  {
    "oid": "fbbd44b16fc463c68998911550d48f8debb5a65e",
    "message": "FileResolver shutdown hook improvements",
    "date": "2018-11-01T09:09:51Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/fbbd44b16fc463c68998911550d48f8debb5a65e",
    "details": {
      "sha": "5d099e65e821cb656dde7518de224d74e15d7efa",
      "filename": "src/main/java/io/vertx/core/file/impl/FileResolver.java",
      "status": "modified",
      "additions": 10,
      "deletions": 3,
      "changes": 13,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/fbbd44b16fc463c68998911550d48f8debb5a65e/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Ffile%2Fimpl%2FFileResolver.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/fbbd44b16fc463c68998911550d48f8debb5a65e/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Ffile%2Fimpl%2FFileResolver.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Ffile%2Fimpl%2FFileResolver.java?ref=fbbd44b16fc463c68998911550d48f8debb5a65e",
      "patch": "@@ -21,6 +21,7 @@\n import java.net.URL;\n import java.nio.file.FileAlreadyExistsException;\n import java.nio.file.Files;\n+import java.nio.file.Path;\n import java.nio.file.StandardCopyOption;\n import java.util.Enumeration;\n import java.util.UUID;\n@@ -92,7 +93,6 @@ public FileResolver(FileSystemOptions fileSystemOptions) {\n    * Close this file resolver, this is a blocking operation.\n    */\n   public void close() throws IOException {\n-    deleteCacheDir();\n     synchronized (this) {\n       if (shutdownHook != null) {\n         // May throw IllegalStateException if called from other shutdown hook so ignore that\n@@ -102,6 +102,7 @@ public void close() throws IOException {\n         }\n       }\n     }\n+    deleteCacheDir();\n   }\n \n   public File resolveFile(String fileName) {\n@@ -353,9 +354,15 @@ private void setupCacheDir() {\n   }\n \n   private void deleteCacheDir() throws IOException {\n-    if (cacheDir != null && cacheDir.exists()) {\n-      FileSystemImpl.delete(cacheDir.toPath(), true);\n+    Path path;\n+    synchronized (this) {\n+      if (cacheDir == null || !cacheDir.exists()) {\n+        return;\n+      }\n+      path = cacheDir.toPath();\n+      cacheDir = null;\n     }\n+    FileSystemImpl.delete(path, true);\n   }\n }\n ",
      "parent_sha": "8557e27be590e2637254343c12bb3a103e43ed8e"
    }
  },
  {
    "oid": "43fce94cfea0df10543dd3454320a499cdf49f88",
    "message": "Updated todo",
    "date": "2016-03-13T22:21:34Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/43fce94cfea0df10543dd3454320a499cdf49f88",
    "details": {
      "sha": "c3bdaeef0b6689c2e32ca12e19d0ad9ffd55db34",
      "filename": "src/main/java/io/vertx/core/http/HttpConnection.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/43fce94cfea0df10543dd3454320a499cdf49f88/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttpConnection.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/43fce94cfea0df10543dd3454320a499cdf49f88/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttpConnection.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttpConnection.java?ref=43fce94cfea0df10543dd3454320a499cdf49f88",
      "patch": "@@ -30,7 +30,6 @@\n  * todo:\n  *\n  * HttpServer:\n- * - add a HttpServer.connectionHandler(Handler<HttpServerConnection>) to allow to set the connection initial settings\n  * - server synchronization + executeFromIO\n  * - HttpServerRequest#remoteAddress\n  * - HttpServerRequest#localAddress\n@@ -40,7 +39,7 @@\n  * - test executeFromIO\n  * - metrics\n  * - push notifications\n- * - HttpConnection implementation\n+ * - HttpConnection test\n  * - reset stream\n  * - compression\n  *",
      "parent_sha": "529f166657714644313044df7b4abb70b8f84185"
    }
  },
  {
    "oid": "5882dffb5057adff52f20a671a756665b5c4de5d",
    "message": "Minor fix",
    "date": "2016-03-13T22:21:34Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/5882dffb5057adff52f20a671a756665b5c4de5d",
    "details": {
      "sha": "78e9b9b306a53f46ad7182c47e1b188390a1523b",
      "filename": "src/main/java/io/vertx/core/http/impl/Http2Pool.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/5882dffb5057adff52f20a671a756665b5c4de5d/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FHttp2Pool.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/5882dffb5057adff52f20a671a756665b5c4de5d/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FHttp2Pool.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FHttp2Pool.java?ref=5882dffb5057adff52f20a671a756665b5c4de5d",
      "patch": "@@ -172,9 +172,10 @@ public void writeHeadWithContent(HttpMethod method, String uri, MultiMap headers\n       h.scheme(\"https\");\n       encoder.writeHeaders(handlerCtx, stream.id(), h, 0, end && buf == null, handlerCtx.newPromise());\n       if (buf != null) {\n-        encoder.writeData(handlerCtx, stream.id(), buf, 0, end, handlerCtx.newPromise());\n+        writeBuffer(buf, end);\n+      } else {\n+        handlerCtx.flush();\n       }\n-      handlerCtx.flush();\n     }\n     @Override\n     public void writeBuffer(ByteBuf buf, boolean end) {",
      "parent_sha": "a4c16fd18b3f48575dc18d417c80acafc4dca090"
    }
  },
  {
    "oid": "2e737c49b1afbe59bd2f5cd983b1a2672e1c0898",
    "message": "Make TrustAllOptions publicly available",
    "date": "2024-03-12T18:55:34Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/2e737c49b1afbe59bd2f5cd983b1a2672e1c0898",
    "details": {
      "sha": "9c33c2ac79d027000a2ba73e937fadb485e363be",
      "filename": "src/main/java/io/vertx/core/net/impl/TrustAllOptions.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/2e737c49b1afbe59bd2f5cd983b1a2672e1c0898/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2Fimpl%2FTrustAllOptions.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/2e737c49b1afbe59bd2f5cd983b1a2672e1c0898/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2Fimpl%2FTrustAllOptions.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2Fimpl%2FTrustAllOptions.java?ref=2e737c49b1afbe59bd2f5cd983b1a2672e1c0898",
      "patch": "@@ -23,7 +23,7 @@\n /**\n  * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n  */\n-class TrustAllOptions implements TrustOptions {\n+public class TrustAllOptions implements TrustOptions {\n \n   public static TrustAllOptions INSTANCE = new TrustAllOptions();\n ",
      "parent_sha": "c5db8384d173389863798e8bdba434a5ea3a58a7"
    }
  },
  {
    "oid": "70c9eb2205c98c2e8f357a02d6473d0f6f049bc8",
    "message": "don't die if fatjar doesn't contain platform_lib dir",
    "date": "2014-01-30T08:21:58Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/70c9eb2205c98c2e8f357a02d6473d0f6f049bc8",
    "details": {
      "sha": "7463d7411288e8c31404b674ca4084cf9a4e710d",
      "filename": "vertx-platform/src/main/java/org/vertx/java/platform/impl/FatJarStarter.java",
      "status": "modified",
      "additions": 8,
      "deletions": 4,
      "changes": 12,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/70c9eb2205c98c2e8f357a02d6473d0f6f049bc8/vertx-platform%2Fsrc%2Fmain%2Fjava%2Forg%2Fvertx%2Fjava%2Fplatform%2Fimpl%2FFatJarStarter.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/70c9eb2205c98c2e8f357a02d6473d0f6f049bc8/vertx-platform%2Fsrc%2Fmain%2Fjava%2Forg%2Fvertx%2Fjava%2Fplatform%2Fimpl%2FFatJarStarter.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/vertx-platform%2Fsrc%2Fmain%2Fjava%2Forg%2Fvertx%2Fjava%2Fplatform%2Fimpl%2FFatJarStarter.java?ref=70c9eb2205c98c2e8f357a02d6473d0f6f049bc8",
      "patch": "@@ -130,10 +130,14 @@ private void go(String[] args) throws Exception {\n     File platformLibDir = new File(new File(modsDir, moduleID), \"platform_lib\");\n \n     urls.add(platformLibDir.toURI().toURL());\n-    files = platformLibDir.listFiles();\n-    for (File file: files) {\n-      if (file.getName().endsWith(\".jar\") || file.getName().endsWith(\".zip\")) {\n-        urls.add(file.toURI().toURL());\n+    if (platformLibDir.exists()) {\n+      files = platformLibDir.listFiles();\n+      if (files != null) {\n+        for (File file: files) {\n+          if (file.getName().endsWith(\".jar\") || file.getName().endsWith(\".zip\")) {\n+            urls.add(file.toURI().toURL());\n+          }\n+        }\n       }\n     }\n ",
      "parent_sha": "8e9cf2d2e1795b432e45cebdd72894847ea00b23"
    }
  },
  {
    "oid": "47d29071fb04c83e94198a467ba09885a3b37ff5",
    "message": "HttpTracerTestBase should use now the correct types for client request/response",
    "date": "2020-07-21T07:37:26Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/47d29071fb04c83e94198a467ba09885a3b37ff5",
    "details": {
      "sha": "3cd79b5298c2e06ebf1fab8cd0164d146d5bd9e0",
      "filename": "src/test/java/io/vertx/core/spi/tracing/HttpTracerTestBase.java",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/47d29071fb04c83e94198a467ba09885a3b37ff5/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fspi%2Ftracing%2FHttpTracerTestBase.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/47d29071fb04c83e94198a467ba09885a3b37ff5/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fspi%2Ftracing%2FHttpTracerTestBase.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fspi%2Ftracing%2FHttpTracerTestBase.java?ref=47d29071fb04c83e94198a467ba09885a3b37ff5",
      "patch": "@@ -14,6 +14,8 @@\n import io.vertx.core.Vertx;\n import io.vertx.core.http.*;\n import io.vertx.core.impl.ContextInternal;\n+import io.vertx.core.spi.observability.HttpRequest;\n+import io.vertx.core.spi.observability.HttpResponse;\n import io.vertx.test.core.TestUtils;\n import org.junit.Test;\n \n@@ -154,14 +156,16 @@ public Object sendRequest(Context context, Object request, String operation, BiC\n         assertSame(val, context.getLocal(key));\n         assertTrue(seq.compareAndSet(0, 1));\n         headers.accept(\"header-key\",\"header-value\");\n+        assertNotNull(request);\n+        assertTrue(request instanceof HttpRequest);\n         return request;\n       }\n       @Override\n       public void receiveResponse(Context context, Object response, Object payload, Throwable failure, TagExtractor tagExtractor) {\n         assertSame(val, context.getLocal(key));\n         assertTrue(context.removeLocal(key));\n-//        assertNotNull(response);\n-//        assertTrue(response instanceof HttpClientResponse);\n+        assertNotNull(response);\n+        assertTrue(response instanceof HttpResponse);\n         assertNull(failure);\n         assertTrue(seq.compareAndSet(1, 2));\n       }",
      "parent_sha": "0d4ba8b834d5fdd798a403e53cf13a74f3a98931"
    }
  },
  {
    "oid": "bf2f65ca308b8f3e768d4e75e319d4919e14094c",
    "message": "Javadoc for fatjar",
    "date": "2013-09-25T12:16:57Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/bf2f65ca308b8f3e768d4e75e319d4919e14094c",
    "details": {
      "sha": "124008d79410061f4afff10fe01983f9f27237c6",
      "filename": "vertx-platform/src/main/java/org/vertx/java/platform/PlatformManager.java",
      "status": "modified",
      "additions": 9,
      "deletions": 1,
      "changes": 10,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/bf2f65ca308b8f3e768d4e75e319d4919e14094c/vertx-platform%2Fsrc%2Fmain%2Fjava%2Forg%2Fvertx%2Fjava%2Fplatform%2FPlatformManager.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/bf2f65ca308b8f3e768d4e75e319d4919e14094c/vertx-platform%2Fsrc%2Fmain%2Fjava%2Forg%2Fvertx%2Fjava%2Fplatform%2FPlatformManager.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/vertx-platform%2Fsrc%2Fmain%2Fjava%2Forg%2Fvertx%2Fjava%2Fplatform%2FPlatformManager.java?ref=bf2f65ca308b8f3e768d4e75e319d4919e14094c",
      "patch": "@@ -159,7 +159,15 @@ void deployModuleFromClasspath(String moduleName, JsonObject config,\n   void pullInDependencies(String moduleName, Handler<AsyncResult<Void>> doneHandler);\n \n \n-  void makeFatJar(String moduleName, String directory, Handler<AsyncResult<Void>> doneHandler);\n+  /**\n+   * Create a fat executable jar which includes the Vert.x binaries and the module so it can be run\n+   * directly with java without having to pre-install Vert.x. e.g.:\n+   * java -jar mymod~1.0-fat.jar\n+   * @param moduleName The name of the module to create the fat jar for\n+   * @param outputDirectory Directory in which to place the jar\n+   * @param doneHandler Handler that will be called on completion\n+   */\n+  void makeFatJar(String moduleName, String outputDirectory, Handler<AsyncResult<Void>> doneHandler);\n \n   /**\n    * Register a handler that will be called when the platform exits because of a verticle calling container.exit()",
      "parent_sha": "430e934b6c5caacc1ef412a9e7e38316acb54bbd"
    }
  },
  {
    "oid": "44c2ba6882a58375490fd3306448e60007636597",
    "message": "use containsKey instead of get in tests\n\nSigned-off-by: Sammers21 <titantins@gmail.com>",
    "date": "2018-01-16T12:32:41Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/44c2ba6882a58375490fd3306448e60007636597",
    "details": {
      "sha": "10efdd58d18e3da5547c75bdc32eb4fce4eba9d2",
      "filename": "src/test/java/io/vertx/test/core/LocalSharedDataTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/44c2ba6882a58375490fd3306448e60007636597/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FLocalSharedDataTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/44c2ba6882a58375490fd3306448e60007636597/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FLocalSharedDataTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FLocalSharedDataTest.java?ref=44c2ba6882a58375490fd3306448e60007636597",
      "patch": "@@ -44,19 +44,19 @@ public void deleteElementOnComputeFunctionReturningNull() {\n \n     // retuning null we should remove the entry\n     map.computeIfPresent(\"hello\", (key, oldValue) -> null);\n-    assertNull(map.get(\"hello\"));\n+    assertFalse(map.containsKey(\"hello\"));\n \n     // Same for LocalMap#compute and LocalMap#compute\n     map.compute(\"hello\", (key, oldValue) -> null);\n-    assertNull(map.get(\"hello\"));\n+    assertFalse(map.containsKey(\"hello\"));\n \n     // put a value one more time\n     map.put(\"hello\", \"world\");\n     map.merge(\"hello\", \"world!!!!!!\", (key, oldValue) -> null);\n-    assertNull(map.get(\"hello\"));\n+    assertFalse(map.containsKey(\"hello\"));\n \n     map.computeIfAbsent(\"hello\", key -> null);\n-    assertNull(map.get(\"hello\"));\n+    assertFalse(map.containsKey(\"hello\"));\n   }\n \n   @Test",
      "parent_sha": "87ac8efc52674f446f0b10989c9be913cbeb987f"
    }
  },
  {
    "oid": "a0a3c0727d359561a013797c1db878d3c3ea374f",
    "message": "fix the comment about ConnectHttpProxy since it supports GET now\n\nSigned-off-by: alexlehm <alexlehm@gmail.com>",
    "date": "2016-07-31T15:28:09Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/a0a3c0727d359561a013797c1db878d3c3ea374f",
    "details": {
      "sha": "4c0aeab00c7de6d5fafe36e10f6a17e8a726e951",
      "filename": "src/test/java/io/vertx/test/core/ConnectHttpProxy.java",
      "status": "modified",
      "additions": 16,
      "deletions": 15,
      "changes": 31,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/a0a3c0727d359561a013797c1db878d3c3ea374f/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FConnectHttpProxy.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/a0a3c0727d359561a013797c1db878d3c3ea374f/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FConnectHttpProxy.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FConnectHttpProxy.java?ref=a0a3c0727d359561a013797c1db878d3c3ea374f",
      "patch": "@@ -19,17 +19,21 @@\n import io.vertx.core.streams.Pump;\n \n /**\n- * Http Connect Proxy\n+ * Http Proxy for testing\n  *\n  * <p>\n- * A simple Http CONNECT proxy for testing https proxy functionality. HTTP server running on localhost allowing CONNECT\n- * requests only. This is basically a socket forwarding protocol allowing to use the proxy server to connect to the\n- * internet.\n- *\n+ * A simple Http proxy for testing http proxy functionality. HTTP server running on localhost allowing CONNECT and GET\n+ * requests only.\n+ * CONNECT is basically a socket forwarding protocol allowing to use the proxy server to connect to the internet,\n+ * e.g. CONNECT www.google.com:443 HTTP/1.1.\n+ * GET accepts an absolute url and gets the url from the origin server, e.g. GET http://www.google.de/ HTTP/1.1.\n  * <p>\n  * Usually the server will be started in @Before and stopped in @After for a unit test using HttpClient with the\n  * setProxyXXX methods.\n- *\n+ * <p>\n+ * The proxy is not useful for anything except testing, since it lacks most security checks like client acls, however in a\n+ * test scenario it will bind to localhost only.\n+ * <p>\n  * @author <a href=\"http://oss.lehmann.cx/\">Alexander Lehmann</a>\n  */\n public class ConnectHttpProxy extends TestProxyBase {\n@@ -44,14 +48,6 @@ public class ConnectHttpProxy extends TestProxyBase {\n \n   private MultiMap lastRequestHeaders = null;\n \n-  /**\n-   * @return the lastRequestHeaders\n-   */\n-  @Override\n-  public MultiMap getLastRequestHeaders() {\n-    return lastRequestHeaders;\n-  }\n-\n   public ConnectHttpProxy(String username) {\n     super(username);\n   }\n@@ -145,7 +141,7 @@ public void start(Vertx vertx, Handler<Void> finishedHandler) {\n           } else {\n             status = 400;\n           }\n-          request.response().setStatusCode(status).end(e.toString()+\" on client request\");\n+          request.response().setStatusCode(status).end(e.toString() + \" on client request\");\n         });\n         clientRequest.end();\n       } else {\n@@ -175,6 +171,11 @@ public int getPort() {\n     return PORT;\n   }\n \n+  @Override\n+  public MultiMap getLastRequestHeaders() {\n+    return lastRequestHeaders;\n+  }\n+\n   public ConnectHttpProxy setError(int error) {\n     this.error = error;\n     return this;",
      "parent_sha": "8a108b89c19a4f0881bc66c0e7412ccb74d3c954"
    }
  },
  {
    "oid": "0a28dcef5ac5ee38ea51447800e94f92da7c7469",
    "message": "Minor typo\n\nSigned-off-by: Julien Viet <julien@julienviet.com>",
    "date": "2021-02-11T08:40:03Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/0a28dcef5ac5ee38ea51447800e94f92da7c7469",
    "details": {
      "sha": "347131e4b2fb48643a862009ed51105521996eda",
      "filename": "src/test/java/io/vertx/core/ContextTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/0a28dcef5ac5ee38ea51447800e94f92da7c7469/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2FContextTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/0a28dcef5ac5ee38ea51447800e94f92da7c7469/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2FContextTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2FContextTest.java?ref=0a28dcef5ac5ee38ea51447800e94f92da7c7469",
      "patch": "@@ -865,7 +865,7 @@ public void testFailedFutureContextPropagation1() {\n   public void testFailedFutureContextPropagation2() {\n     ContextInternal context = (ContextInternal) vertx.getOrCreateContext();\n     Future<String> future = context.failedFuture(\"error\");\n-    future = future.recover(\u03c0err -> {\n+    future = future.recover(err -> {\n       assertSame(context, Vertx.currentContext());\n       return Future.succeededFuture(\"value-2\");\n     });",
      "parent_sha": "fc823eafffd1eaff77ca17e9cb1f5c18b9d4c5e7"
    }
  },
  {
    "oid": "ed3da6a86c38a70794a68d4d4be6005ba3c57406",
    "message": "Rename TestClient.Request -> TestClient.Connection in Http2ServerTest",
    "date": "2016-04-04T15:45:48Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/ed3da6a86c38a70794a68d4d4be6005ba3c57406",
    "details": {
      "sha": "0bfc870b913cb4487df57e4cbe66626c3ebeb7d9",
      "filename": "src/test/java/io/vertx/test/core/Http2ServerTest.java",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/ed3da6a86c38a70794a68d4d4be6005ba3c57406/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttp2ServerTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/ed3da6a86c38a70794a68d4d4be6005ba3c57406/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttp2ServerTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttp2ServerTest.java?ref=ed3da6a86c38a70794a68d4d4be6005ba3c57406",
      "patch": "@@ -125,14 +125,14 @@ class TestClient {\n \n     public final Http2Settings settings = new Http2Settings();\n \n-    public class Request {\n+    public class Connection {\n       public final Channel channel;\n       public final ChannelHandlerContext context;\n       public final Http2Connection connection;\n       public final Http2ConnectionEncoder encoder;\n       public final Http2ConnectionDecoder decoder;\n \n-      public Request(ChannelHandlerContext context, Http2Connection connection, Http2ConnectionEncoder encoder, Http2ConnectionDecoder decoder) {\n+      public Connection(ChannelHandlerContext context, Http2Connection connection, Http2ConnectionEncoder encoder, Http2ConnectionDecoder decoder) {\n         this.channel = context.channel();\n         this.context = context;\n         this.connection = connection;\n@@ -147,11 +147,11 @@ public int nextStreamId() {\n \n     class TestClientHandler extends Http2ConnectionHandler {\n \n-      private final Consumer<Request> requestHandler;\n+      private final Consumer<Connection> requestHandler;\n       private boolean handled;\n \n       public TestClientHandler(\n-          Consumer<Request> requestHandler,\n+          Consumer<Connection> requestHandler,\n           Http2ConnectionDecoder decoder,\n           Http2ConnectionEncoder encoder,\n           Http2Settings initialSettings) {\n@@ -176,17 +176,17 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {\n       private void checkHandle(ChannelHandlerContext ctx) {\n         if (!handled) {\n           handled = true;\n-          Request request = new Request(ctx, connection(), encoder(), decoder());\n-          requestHandler.accept(request);\n+          Connection conn = new Connection(ctx, connection(), encoder(), decoder());\n+          requestHandler.accept(conn);\n         }\n       }\n     }\n \n     class TestClientHandlerBuilder extends AbstractHttp2ConnectionHandlerBuilder<TestClientHandler, TestClientHandlerBuilder> {\n \n-      private final Consumer<Request> requestHandler;\n+      private final Consumer<Connection> requestHandler;\n \n-      public TestClientHandlerBuilder(Consumer<Request> requestHandler) {\n+      public TestClientHandlerBuilder(Consumer<Connection> requestHandler) {\n         this.requestHandler = requestHandler;\n       }\n \n@@ -208,7 +208,7 @@ public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int\n       }\n     }\n \n-    protected ChannelInitializer channelInitializer(int port, String host, Consumer<Request> handler) {\n+    protected ChannelInitializer channelInitializer(int port, String host, Consumer<Connection> handler) {\n       return new ChannelInitializer<Channel>() {\n         @Override\n         protected void initChannel(Channel ch) throws Exception {\n@@ -234,7 +234,7 @@ protected void configurePipeline(ChannelHandlerContext ctx, String protocol) {\n       };\n     }\n \n-    public ChannelFuture connect(int port, String host, Consumer<Request> handler) {\n+    public ChannelFuture connect(int port, String host, Consumer<Connection> handler) {\n       Bootstrap bootstrap = new Bootstrap();\n       bootstrap.channel(NioSocketChannel.class);\n       bootstrap.group(new NioEventLoopGroup());\n@@ -2652,7 +2652,7 @@ public void testPriorKnowledge() throws Exception {\n     startServer();\n     TestClient client = new TestClient() {\n       @Override\n-      protected ChannelInitializer channelInitializer(int port, String host, Consumer<Request> handler) {\n+      protected ChannelInitializer channelInitializer(int port, String host, Consumer<Connection> handler) {\n         return new ChannelInitializer() {\n           @Override\n           protected void initChannel(Channel ch) throws Exception {",
      "parent_sha": "aa196322a2834b2cf48709727c6e4a9a2a36502a"
    }
  },
  {
    "oid": "cf49c9ceacf351617c673d58060aead189544854",
    "message": "Make test jar dependency onto codec haproxy soft",
    "date": "2024-09-23T20:35:47Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/cf49c9ceacf351617c673d58060aead189544854",
    "details": {
      "sha": "cb110ce3d13896286332a095a2cea74c6e800a80",
      "filename": "vertx-core/src/test/java/module-info.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/cf49c9ceacf351617c673d58060aead189544854/vertx-core%2Fsrc%2Ftest%2Fjava%2Fmodule-info.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/cf49c9ceacf351617c673d58060aead189544854/vertx-core%2Fsrc%2Ftest%2Fjava%2Fmodule-info.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/vertx-core%2Fsrc%2Ftest%2Fjava%2Fmodule-info.java?ref=cf49c9ceacf351617c673d58060aead189544854",
      "patch": "@@ -36,7 +36,7 @@\n   requires io.netty.codec;\n   requires io.netty.codec.compression;\n   requires io.netty.codec.http;\n-  requires io.netty.codec.haproxy;\n+  requires static io.netty.codec.haproxy;\n   requires io.netty.codec.http2;\n   requires io.netty.resolver.dns;\n ",
      "parent_sha": "027699949021d846a099105693d62a7e721db60e"
    }
  },
  {
    "oid": "c1cafe9d12f0c6d22ca8d8da0aaeac5c95fcd2a5",
    "message": "Remove callbacks in ClusteredAsynchronousLockTest",
    "date": "2023-03-09T14:52:53Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/c1cafe9d12f0c6d22ca8d8da0aaeac5c95fcd2a5",
    "details": {
      "sha": "22fc609b132bbf3d59270aa603b273d29f6c7073",
      "filename": "src/test/java/io/vertx/core/shareddata/ClusteredAsynchronousLockTest.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/c1cafe9d12f0c6d22ca8d8da0aaeac5c95fcd2a5/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fshareddata%2FClusteredAsynchronousLockTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/c1cafe9d12f0c6d22ca8d8da0aaeac5c95fcd2a5/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fshareddata%2FClusteredAsynchronousLockTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fshareddata%2FClusteredAsynchronousLockTest.java?ref=c1cafe9d12f0c6d22ca8d8da0aaeac5c95fcd2a5",
      "patch": "@@ -93,7 +93,7 @@ public void testGetLocalLock() {\n   @Ignore\n   public void testLockReleasedForClosedNode() throws Exception {\n     testLockReleased(latch -> {\n-      vertices[0].close(onSuccess(v -> {\n+      vertices[0].close().onComplete(onSuccess(v -> {\n         latch.countDown();\n       }));\n     });\n@@ -119,8 +119,8 @@ public void testLockReleasedForKilledNode() throws Exception {\n   private void testLockReleased(Consumer<CountDownLatch> action) throws Exception {\n     CountDownLatch lockAquiredLatch = new CountDownLatch(1);\n \n-    vertices[0].sharedData().getLockWithTimeout(\"pimpo\", getLockTimeout(), onSuccess(lock -> {\n-      vertices[1].sharedData().getLockWithTimeout(\"pimpo\", getLockTimeout(), onSuccess(lock2 -> {\n+    vertices[0].sharedData().getLockWithTimeout(\"pimpo\", getLockTimeout()).onComplete(onSuccess(lock -> {\n+      vertices[1].sharedData().getLockWithTimeout(\"pimpo\", getLockTimeout()).onComplete(onSuccess(lock2 -> {\n         // Eventually acquired after node1 goes down\n         testComplete();\n       }));",
      "parent_sha": "162acca2c75c988423d1bfc2ef6ed3168e8a8353"
    }
  },
  {
    "oid": "7c6ae7c329f3b89f2bd8d2826735daafed8797c0",
    "message": "Fix racy test",
    "date": "2024-10-16T13:27:38Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/7c6ae7c329f3b89f2bd8d2826735daafed8797c0",
    "details": {
      "sha": "4f5bbf3576c7b1f3ca6f933f4bb917502b9fd8d0",
      "filename": "vertx-core/src/test/java/io/vertx/tests/eventbus/EventBusTestBase.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/7c6ae7c329f3b89f2bd8d2826735daafed8797c0/vertx-core%2Fsrc%2Ftest%2Fjava%2Fio%2Fvertx%2Ftests%2Feventbus%2FEventBusTestBase.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/7c6ae7c329f3b89f2bd8d2826735daafed8797c0/vertx-core%2Fsrc%2Ftest%2Fjava%2Fio%2Fvertx%2Ftests%2Feventbus%2FEventBusTestBase.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/vertx-core%2Fsrc%2Ftest%2Fjava%2Fio%2Fvertx%2Ftests%2Feventbus%2FEventBusTestBase.java?ref=7c6ae7c329f3b89f2bd8d2826735daafed8797c0",
      "patch": "@@ -517,7 +517,7 @@ public void testNoHandlersCallbackContext() {\n       }\n       assertTrue(\"Not an EL thread\", Context.isOnEventLoopThread());\n       complete();\n-    })).await();\n+    }));\n \n     // On a EL context\n     vertices[0].runOnContext(v -> {",
      "parent_sha": "b3fb6cf32d8b1e204f4e86991f581c8309b5326a"
    }
  },
  {
    "oid": "f42b5d22c5c738cae1db925a06029212b198c398",
    "message": "Remove DeploymentTest#testUndeployNoHandler that does not make anymore sense",
    "date": "2024-09-01T07:10:51Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/f42b5d22c5c738cae1db925a06029212b198c398",
    "details": {
      "sha": "1c4ac5955782d28ee6f5dec596a48e54fbb76f7e",
      "filename": "vertx-core/src/test/java/io/vertx/tests/deployment/DeploymentTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 11,
      "changes": 13,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/f42b5d22c5c738cae1db925a06029212b198c398/vertx-core%2Fsrc%2Ftest%2Fjava%2Fio%2Fvertx%2Ftests%2Fdeployment%2FDeploymentTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/f42b5d22c5c738cae1db925a06029212b198c398/vertx-core%2Fsrc%2Ftest%2Fjava%2Fio%2Fvertx%2Ftests%2Fdeployment%2FDeploymentTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/vertx-core%2Fsrc%2Ftest%2Fjava%2Fio%2Fvertx%2Ftests%2Fdeployment%2FDeploymentTest.java?ref=f42b5d22c5c738cae1db925a06029212b198c398",
      "patch": "@@ -389,16 +389,7 @@ public void testUndeploy() throws Exception {\n   }\n \n   @Test\n-  public void testUndeployNoHandler() throws Exception {\n-    MyVerticle verticle = new MyVerticle();\n-    vertx.deployVerticle(verticle).onComplete(onSuccess(id -> {\n-      vertx.undeploy(id);\n-    }));\n-    assertWaitUntil(() -> vertx.deploymentIDs().isEmpty());\n-  }\n-\n-  @Test\n-  public void testUndeployTwice() throws Exception {\n+  public void testUndeployTwice() {\n     MyVerticle verticle = new MyVerticle();\n     vertx.deployVerticle(verticle).onComplete(onSuccess(id -> {\n       vertx.undeploy(id).onComplete(onSuccess(v -> {\n@@ -412,7 +403,7 @@ public void testUndeployTwice() throws Exception {\n   }\n \n   @Test\n-  public void testUndeployInvalidID() throws Exception {\n+  public void testUndeployInvalidID() {\n     vertx\n       .undeploy(\"uqhwdiuhqwd\")\n       .onComplete(onFailure(err -> {",
      "parent_sha": "597274faeb11377373b33694a61f0ceca4f23352"
    }
  },
  {
    "oid": "037bcc03d948a979a22b99cb8249d7438aa86515",
    "message": "Make HttpTest#testSetHandlersOnEnd log the failure of the server bind",
    "date": "2017-09-20T08:15:33Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/037bcc03d948a979a22b99cb8249d7438aa86515",
    "details": {
      "sha": "4593a629303e5eee8a6ae09a4276f82ab81ae936",
      "filename": "src/test/java/io/vertx/test/core/HttpTest.java",
      "status": "modified",
      "additions": 26,
      "deletions": 29,
      "changes": 55,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/037bcc03d948a979a22b99cb8249d7438aa86515/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttpTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/037bcc03d948a979a22b99cb8249d7438aa86515/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttpTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttpTest.java?ref=037bcc03d948a979a22b99cb8249d7438aa86515",
      "patch": "@@ -2905,38 +2905,35 @@ public void testClearHandlersOnEnd() {\n   }\n \n   @Test\n-  public void testSetHandlersOnEnd() {\n+  public void testSetHandlersOnEnd() throws Exception {\n     String path = \"/some/path\";\n     server.requestHandler(req -> req.response().setStatusCode(200).end());\n-    server.listen(ar -> {\n-      assertTrue(ar.succeeded());\n-      HttpClientRequest req = client.request(HttpMethod.GET, HttpTestBase.DEFAULT_HTTP_PORT, HttpTestBase.DEFAULT_HTTP_HOST, path);\n-      req.handler(resp -> {\n-      });\n-      req.endHandler(done -> {\n-        try {\n-          req.handler(arg -> {\n-          });\n-          fail();\n-        } catch (Exception ignore) {\n-        }\n-        try {\n-          req.exceptionHandler(arg -> {\n-          });\n-          fail();\n-        } catch (Exception ignore) {\n-        }\n-        try {\n-          req.endHandler(arg -> {\n-          });\n-          fail();\n-        } catch (Exception ignore) {\n-        }\n-        testComplete();\n-      });\n-      req.end();\n-\n+    startServer();\n+    HttpClientRequest req = client.request(HttpMethod.GET, HttpTestBase.DEFAULT_HTTP_PORT, HttpTestBase.DEFAULT_HTTP_HOST, path);\n+    req.handler(resp -> {\n     });\n+    req.endHandler(done -> {\n+      try {\n+        req.handler(arg -> {\n+        });\n+        fail();\n+      } catch (Exception ignore) {\n+      }\n+      try {\n+        req.exceptionHandler(arg -> {\n+        });\n+        fail();\n+      } catch (Exception ignore) {\n+      }\n+      try {\n+        req.endHandler(arg -> {\n+        });\n+        fail();\n+      } catch (Exception ignore) {\n+      }\n+      testComplete();\n+    });\n+    req.end();\n     await();\n   }\n ",
      "parent_sha": "1303c1c7a5e046d4e519a86103167c53c8b17325"
    }
  },
  {
    "oid": "e8d7fd6b2b25ee1f386ec297e71a052765667915",
    "message": "When setting the queue max size, add the difference with the max size to the credits and the drain handler should be called when credits are greater than maxSize/2",
    "date": "2016-05-29T20:19:12Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/e8d7fd6b2b25ee1f386ec297e71a052765667915",
    "details": {
      "sha": "f06a2ee920bf037e385c86a22f291fb8393c07d7",
      "filename": "src/main/java/io/vertx/core/eventbus/impl/MessageProducerImpl.java",
      "status": "modified",
      "additions": 8,
      "deletions": 6,
      "changes": 14,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/e8d7fd6b2b25ee1f386ec297e71a052765667915/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2Fimpl%2FMessageProducerImpl.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/e8d7fd6b2b25ee1f386ec297e71a052765667915/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2Fimpl%2FMessageProducerImpl.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2Fimpl%2FMessageProducerImpl.java?ref=e8d7fd6b2b25ee1f386ec297e71a052765667915",
      "patch": "@@ -39,6 +39,7 @@ public class MessageProducerImpl<T> implements MessageProducer<T> {\n   private final Queue<T> pending = new ArrayDeque<>();\n   private final MessageConsumer<Integer> creditConsumer;\n   private DeliveryOptions options;\n+  private int maxSize = DEFAULT_WRITE_QUEUE_MAX_SIZE;\n   private int credits = DEFAULT_WRITE_QUEUE_MAX_SIZE;\n   private Handler<Void> drainHandler;\n \n@@ -83,8 +84,10 @@ public MessageProducer<T> exceptionHandler(Handler<Throwable> handler) {\n   }\n \n   @Override\n-  public synchronized MessageProducer<T> setWriteQueueMaxSize(int maxSize) {\n-    this.credits = maxSize;\n+  public synchronized MessageProducer<T> setWriteQueueMaxSize(int s) {\n+    int delta = s - maxSize;\n+    maxSize = s;\n+    credits += delta;\n     return this;\n   }\n \n@@ -99,8 +102,8 @@ public synchronized MessageProducer<T> write(T data) {\n   }\n \n   @Override\n-  public boolean writeQueueFull() {\n-    return pending.size() > 0;\n+  public synchronized boolean writeQueueFull() {\n+    return credits == 0;\n   }\n \n   @Override\n@@ -158,10 +161,9 @@ private synchronized void doReceiveCredit(int credit) {\n       }\n     }\n     final Handler<Void> theDrainHandler = drainHandler;\n-    if (theDrainHandler != null && pending.isEmpty()) {\n+    if (theDrainHandler != null && credits >= maxSize / 2) {\n       this.drainHandler = null;\n       vertx.runOnContext(v -> theDrainHandler.handle(null));\n     }\n   }\n-\n }",
      "parent_sha": "1799951789f2904fdf0d6049e4c48349349cdd90"
    }
  },
  {
    "oid": "8a9449e9cd66e41ae8ec17785df425311d94ec6f",
    "message": "Fixed Javadoc: can't reply a message directly with reply address\n\nIn clustered mode, reply address is only registered locally, and reply is sent to sender using the server ID\n\nSigned-off-by: Thomas Segismont <tsegismont@gmail.com>",
    "date": "2018-07-30T15:56:19Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/8a9449e9cd66e41ae8ec17785df425311d94ec6f",
    "details": {
      "sha": "e3094a2abefe6081d9edd6cda344ac50ba92f7f9",
      "filename": "src/main/java/io/vertx/core/eventbus/Message.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/8a9449e9cd66e41ae8ec17785df425311d94ec6f/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2FMessage.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/8a9449e9cd66e41ae8ec17785df425311d94ec6f/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2FMessage.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2FMessage.java?ref=8a9449e9cd66e41ae8ec17785df425311d94ec6f",
      "patch": "@@ -23,8 +23,7 @@\n  * <p>\n  * Messages have a {@link #body}, which can be null, and also {@link #headers}, which can be empty.\n  * <p>\n- * If the message was sent specifying a reply handler it will also have a {@link #replyAddress}. In that case the message\n- * can be replied to using that reply address, or, more simply by just using {@link #reply}.\n+ * If the message was sent specifying a reply handler, it can be replied to using {@link #reply}.\n  * <p>\n  * If you want to notify the sender that processing failed, then {@link #fail} can be called.\n  *",
      "parent_sha": "3297c01ddbce74fd83c4f129096a737d35f6702f"
    }
  },
  {
    "oid": "efbae34dba50c56f0ef88c620d0af820ead6c296",
    "message": "Use onComplete instead of onSuccess+onFailure\n\nSigned-off-by: Thomas Segismont <tsegismont@gmail.com>",
    "date": "2020-05-05T12:56:37Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/efbae34dba50c56f0ef88c620d0af820ead6c296",
    "details": {
      "sha": "fb4469d4fc348cb4b195a65bc0bd28b8e3d0fd5e",
      "filename": "src/main/java/io/vertx/core/spi/cluster/impl/DefaultDeliveryStrategy.java",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/efbae34dba50c56f0ef88c620d0af820ead6c296/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fspi%2Fcluster%2Fimpl%2FDefaultDeliveryStrategy.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/efbae34dba50c56f0ef88c620d0af820ead6c296/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fspi%2Fcluster%2Fimpl%2FDefaultDeliveryStrategy.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fspi%2Fcluster%2Fimpl%2FDefaultDeliveryStrategy.java?ref=efbae34dba50c56f0ef88c620d0af820ead6c296",
      "patch": "@@ -126,12 +126,14 @@ private void dequeueWaiters(ContextInternal context, String address) {\n       }\n     }\n \n-    clusterManager.registrationListener(address)\n-      .onFailure(t -> {\n-        waiter.fail(t);\n+    clusterManager.registrationListener(address).onComplete(ar -> {\n+      if (ar.succeeded()) {\n+        registrationListenerCreated(context, address, ar.result());\n+      } else {\n+        waiter.fail(ar.cause());\n         removeFirstAndDequeueWaiters(context, address);\n-      })\n-      .onSuccess(stream -> registrationListenerCreated(context, address, stream));\n+      }\n+    });\n   }\n \n   private void registrationListenerCreated(ContextInternal context, String address, RegistrationListener listener) {",
      "parent_sha": "6c0a91cf8f4ac7e33a18cb48f38d3a18481ab642"
    }
  },
  {
    "oid": "8275b498c241ff6c1ab9ff0581820f6c2ddf95d6",
    "message": "improving inlinability due to recursive calls and big methods",
    "date": "2023-11-29T08:27:35Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/8275b498c241ff6c1ab9ff0581820f6c2ddf95d6",
    "details": {
      "sha": "049892178f2b044461b596175a7337486ba70aaa",
      "filename": "src/main/java/io/vertx/core/json/jackson/JacksonCodec.java",
      "status": "modified",
      "additions": 85,
      "deletions": 40,
      "changes": 125,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/8275b498c241ff6c1ab9ff0581820f6c2ddf95d6/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fjson%2Fjackson%2FJacksonCodec.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/8275b498c241ff6c1ab9ff0581820f6c2ddf95d6/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fjson%2Fjackson%2FJacksonCodec.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fjson%2Fjackson%2FJacksonCodec.java?ref=8275b498c241ff6c1ab9ff0581820f6c2ddf95d6",
      "patch": "@@ -282,61 +282,106 @@ private static void encodeJson(Object json, JsonGenerator generator) throws Enco\n         generator.writeStartObject();\n         for (Map.Entry<String, ?> e : ((Map<String, ?>)json).entrySet()) {\n           generator.writeFieldName(e.getKey());\n-          encodeJson(e.getValue(), generator);\n+          Object value = e.getValue();\n+          encodeJson0(value, generator);\n         }\n         generator.writeEndObject();\n       } else if (json instanceof List) {\n         generator.writeStartArray();\n         for (Object item : (List<?>) json) {\n-          encodeJson(item, generator);\n+          encodeJson0(item, generator);\n         }\n         generator.writeEndArray();\n-      } else if (json instanceof String) {\n-        generator.writeString((String) json);\n-      } else if (json instanceof Number) {\n-        if (json instanceof Short) {\n-          generator.writeNumber((Short) json);\n-        } else if (json instanceof Integer) {\n-          generator.writeNumber((Integer) json);\n-        } else if (json instanceof Long) {\n-          generator.writeNumber((Long) json);\n-        } else if (json instanceof Float) {\n-          generator.writeNumber((Float) json);\n-        } else if (json instanceof Double) {\n-          generator.writeNumber((Double) json);\n-        } else if (json instanceof Byte) {\n-          generator.writeNumber((Byte) json);\n-        } else if (json instanceof BigInteger) {\n-          generator.writeNumber((BigInteger) json);\n-        } else if (json instanceof BigDecimal) {\n-          generator.writeNumber((BigDecimal) json);\n-        } else {\n-          generator.writeNumber(((Number) json).doubleValue());\n+      } else if (!encodeSingleType(generator, json)) {\n+        throw new EncodeException(\"Mapping \" + json.getClass().getName() + \"  is not available without Jackson Databind on the classpath\");\n+      }\n+    } catch (IOException e) {\n+      throw new EncodeException(e.getMessage(), e);\n+    }\n+  }\n+\n+  /**\n+   * This is a way to overcome a limit of OpenJDK on MaxRecursiveInlineLevel:\n+   * avoiding the \"direct\" recursive calls allow the JIT to have a better inlining budget for the recursive calls.\n+   */\n+  private static void encodeJson0(Object json, JsonGenerator generator) throws EncodeException {\n+    try {\n+      if (json instanceof JsonObject) {\n+        json = ((JsonObject)json).getMap();\n+      } else if (json instanceof JsonArray) {\n+        json = ((JsonArray)json).getList();\n+      }\n+      if (json instanceof Map) {\n+        generator.writeStartObject();\n+        for (Map.Entry<String, ?> e : ((Map<String, ?>)json).entrySet()) {\n+          generator.writeFieldName(e.getKey());\n+          Object value = e.getValue();\n+          encodeJson(value, generator);\n         }\n-      } else if (json instanceof Boolean) {\n-        generator.writeBoolean((Boolean)json);\n-      } else if (json instanceof Instant) {\n-        // RFC-7493\n-        generator.writeString((ISO_INSTANT.format((Instant)json)));\n-      } else if (json instanceof byte[]) {\n-        // RFC-7493\n-        generator.writeString(BASE64_ENCODER.encodeToString((byte[]) json));\n-      } else if (json instanceof Buffer) {\n-        // RFC-7493\n-        generator.writeString(BASE64_ENCODER.encodeToString(((Buffer) json).getBytes()));\n-      } else if (json instanceof Enum) {\n-        // vert.x extra (non standard but allowed conversion)\n-        generator.writeString(((Enum<?>) json).name());\n-      } else if (json == null) {\n-        generator.writeNull();\n-      } else {\n+        generator.writeEndObject();\n+      } else if (json instanceof List) {\n+        generator.writeStartArray();\n+        for (Object item : (List<?>) json) {\n+          encodeJson(item, generator);\n+        }\n+        generator.writeEndArray();\n+      } else if (!encodeSingleType(generator, json)) {\n         throw new EncodeException(\"Mapping \" + json.getClass().getName() + \"  is not available without Jackson Databind on the classpath\");\n       }\n     } catch (IOException e) {\n       throw new EncodeException(e.getMessage(), e);\n     }\n   }\n \n+  private static boolean encodeSingleType(JsonGenerator generator, Object json) throws IOException {\n+    if (json == null) {\n+      generator.writeNull();\n+    } else if (json instanceof String) {\n+      generator.writeString((String) json);\n+    } else if (json instanceof Number) {\n+      encodeNumber(generator, json);\n+    } else if (json instanceof Boolean) {\n+      generator.writeBoolean((Boolean)json);\n+    } else if (json instanceof Instant) {\n+      // RFC-7493\n+      generator.writeString((ISO_INSTANT.format((Instant)json)));\n+    } else if (json instanceof byte[]) {\n+      // RFC-7493\n+      generator.writeString(BASE64_ENCODER.encodeToString((byte[]) json));\n+    } else if (json instanceof Buffer) {\n+      // RFC-7493\n+      generator.writeString(BASE64_ENCODER.encodeToString(((Buffer) json).getBytes()));\n+    } else if (json instanceof Enum) {\n+      // vert.x extra (non standard but allowed conversion)\n+      generator.writeString(((Enum<?>) json).name());\n+    } else {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static void encodeNumber(JsonGenerator generator, Object json) throws IOException {\n+    if (json instanceof Short) {\n+      generator.writeNumber((Short) json);\n+    } else if (json instanceof Integer) {\n+      generator.writeNumber((Integer) json);\n+    } else if (json instanceof Long) {\n+      generator.writeNumber((Long) json);\n+    } else if (json instanceof Float) {\n+      generator.writeNumber((Float) json);\n+    } else if (json instanceof Double) {\n+      generator.writeNumber((Double) json);\n+    } else if (json instanceof Byte) {\n+      generator.writeNumber((Byte) json);\n+    } else if (json instanceof BigInteger) {\n+      generator.writeNumber((BigInteger) json);\n+    } else if (json instanceof BigDecimal) {\n+      generator.writeNumber((BigDecimal) json);\n+    } else {\n+      generator.writeNumber(((Number) json).doubleValue());\n+    }\n+  }\n+\n   private static <T> Class<T> classTypeOf(TypeReference<T> typeRef) {\n     Type type = typeRef.getType();\n     if (type instanceof Class) {",
      "parent_sha": "0bed7c8e6273b18bbfbfa0a7a9d45044ca33d0b9"
    }
  },
  {
    "oid": "bed6b2c7c704f6cb6a47e55463ed45bfc852a92c",
    "message": "Add tests to check that custom launchers can customize the configuration and set whether or not vert.x should be clustered.\n\nSigned-off-by: Clement Escoffier <clement.escoffier@gmail.com>",
    "date": "2016-07-20T12:52:46Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/bed6b2c7c704f6cb6a47e55463ed45bfc852a92c",
    "details": {
      "sha": "09fa7895200fd7b5d5cfab8a59847f2c1a194a73",
      "filename": "src/test/java/io/vertx/core/impl/launcher/LauncherExtensibilityTest.java",
      "status": "modified",
      "additions": 98,
      "deletions": 1,
      "changes": 99,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/bed6b2c7c704f6cb6a47e55463ed45bfc852a92c/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fimpl%2Flauncher%2FLauncherExtensibilityTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/bed6b2c7c704f6cb6a47e55463ed45bfc852a92c/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fimpl%2Flauncher%2FLauncherExtensibilityTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fimpl%2Flauncher%2FLauncherExtensibilityTest.java?ref=bed6b2c7c704f6cb6a47e55463ed45bfc852a92c",
      "patch": "@@ -18,11 +18,13 @@\n \n import io.vertx.core.Launcher;\n import io.vertx.core.Vertx;\n+import io.vertx.core.VertxOptions;\n import io.vertx.core.cli.CLIException;\n import io.vertx.core.cli.annotations.Name;\n import io.vertx.core.impl.launcher.commands.CommandTestBase;\n import io.vertx.core.impl.launcher.commands.HttpTestVerticle;\n import io.vertx.core.impl.launcher.commands.RunCommandTest;\n+import io.vertx.core.json.JsonObject;\n import io.vertx.core.spi.launcher.CommandFactory;\n import io.vertx.core.spi.launcher.DefaultCommand;\n import io.vertx.core.spi.launcher.DefaultCommandFactory;\n@@ -39,7 +41,7 @@\n  */\n public class LauncherExtensibilityTest extends CommandTestBase {\n \n-  static AtomicReference<Boolean> spy = new AtomicReference<>();\n+  private static AtomicReference<Boolean> spy = new AtomicReference<>();\n \n   private Vertx vertx;\n \n@@ -108,6 +110,101 @@ protected void load() {\n     assertThat(myLauncher.getCommandNames()).doesNotContain(\"start\");\n   }\n \n+  @Test\n+  public void testThatCustomLauncherCanCustomizeTheClusteredOption() {\n+    Launcher myLauncher = new Launcher() {\n+      @Override\n+      protected String getMainVerticle() {\n+        return HttpTestVerticle.class.getName();\n+      }\n+\n+      @Override\n+      public void afterStartingVertx(Vertx vertx) {\n+        LauncherExtensibilityTest.this.vertx = vertx;\n+      }\n+\n+      @Override\n+      public void beforeStartingVertx(VertxOptions options) {\n+        options.setClustered(true);\n+      }\n+    };\n+\n+    myLauncher.dispatch(new String[0]);\n+    waitUntil(() -> {\n+      try {\n+        return RunCommandTest.getHttpCode() == 200;\n+      } catch (IOException e) {\n+        return false;\n+      }\n+    });\n+\n+    assertThat(this.vertx.isClustered()).isTrue();\n+  }\n+\n+  @Test\n+  public void testThatCustomLauncherCanUpdateConfigurationWhenNoneArePassed() throws IOException {\n+    long time = System.nanoTime();\n+    Launcher myLauncher = new Launcher() {\n+      @Override\n+      protected String getMainVerticle() {\n+        return HttpTestVerticle.class.getName();\n+      }\n+\n+      @Override\n+      public void afterStartingVertx(Vertx vertx) {\n+        LauncherExtensibilityTest.this.vertx = vertx;\n+      }\n+\n+      @Override\n+      public void afterConfigParsed(JsonObject config) {\n+        config.put(\"time\", time);\n+      }\n+    };\n+\n+    myLauncher.dispatch(new String[0]);\n+    waitUntil(() -> {\n+      try {\n+        return RunCommandTest.getHttpCode() == 200;\n+      } catch (IOException e) {\n+        return false;\n+      }\n+    });\n+\n+    assertThat(RunCommandTest.getContent().getJsonObject(\"conf\").getLong(\"time\")).isEqualTo(time);\n+  }\n+\n+  @Test\n+  public void testThatCustomLauncherCanUpdateConfiguration() throws IOException {\n+    long time = System.nanoTime();\n+    Launcher myLauncher = new Launcher() {\n+      @Override\n+      protected String getMainVerticle() {\n+        return HttpTestVerticle.class.getName();\n+      }\n+\n+      @Override\n+      public void afterStartingVertx(Vertx vertx) {\n+        LauncherExtensibilityTest.this.vertx = vertx;\n+      }\n+\n+      @Override\n+      public void afterConfigParsed(JsonObject config) {\n+        config.put(\"time\", time);\n+      }\n+    };\n+\n+    myLauncher.dispatch(new String[] {\"-conf=\\\"{\\\"time\\\":345667}\"});\n+    waitUntil(() -> {\n+      try {\n+        return RunCommandTest.getHttpCode() == 200;\n+      } catch (IOException e) {\n+        return false;\n+      }\n+    });\n+\n+    assertThat(RunCommandTest.getContent().getJsonObject(\"conf\").getLong(\"time\")).isEqualTo(time);\n+  }\n+\n   @Name(\"foo\")\n   public static class FooCommand extends DefaultCommand {\n ",
      "parent_sha": "e6e48df837aea51e0d7efd6e529cb6853172dcb3"
    }
  },
  {
    "oid": "2740b358070106387fbf8e16e7bbae7172351262",
    "message": "Properly show the failure cause\n\nSigned-off-by: Thomas Segismont <tsegismont@gmail.com>",
    "date": "2016-10-11T10:22:53Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/2740b358070106387fbf8e16e7bbae7172351262",
    "details": {
      "sha": "984e355189435b8fea4417c527b5a2426106d4cc",
      "filename": "src/test/java/io/vertx/test/core/HATest.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/2740b358070106387fbf8e16e7bbae7172351262/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHATest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/2740b358070106387fbf8e16e7bbae7172351262/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHATest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHATest.java?ref=2740b358070106387fbf8e16e7bbae7172351262",
      "patch": "@@ -425,7 +425,9 @@ protected void kill(int pos) {\n         fut.fail(e);\n       }\n     }, ar -> {\n-      assertTrue(ar.succeeded());\n+      if (!ar.succeeded()) {\n+        fail(ar.cause());\n+      }\n     });\n   }\n ",
      "parent_sha": "da3d98ea0ab7cf83109726f65965492826b42880"
    }
  },
  {
    "oid": "589e8109b72b391816441bf4df833c0dca08633d",
    "message": "Use removeLocal instead of putLocal with null",
    "date": "2024-01-09T09:18:15Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/589e8109b72b391816441bf4df833c0dca08633d",
    "details": {
      "sha": "be61dd8d71522da265c4291f0d1f8df49808dce0",
      "filename": "src/test/java/io/vertx/core/spi/tracing/HttpTracerTestBase.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/589e8109b72b391816441bf4df833c0dca08633d/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fspi%2Ftracing%2FHttpTracerTestBase.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/589e8109b72b391816441bf4df833c0dca08633d/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fspi%2Ftracing%2FHttpTracerTestBase.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fspi%2Ftracing%2FHttpTracerTestBase.java?ref=589e8109b72b391816441bf4df833c0dca08633d",
      "patch": "@@ -70,7 +70,7 @@ public void sendResponse(Context context, Object response, Object payload, Throw\n         assertTrue(response instanceof HttpServerResponse);\n         assertNull(failure);\n         assertSame(val, context.getLocal(key));\n-        context.putLocal(key, null);\n+        context.removeLocal(key);\n       }\n     });\n     CountDownLatch latch = new CountDownLatch(1);\n@@ -174,7 +174,7 @@ public Object sendRequest(Context context, SpanKind kind, TracingPolicy policy,\n       @Override\n       public void receiveResponse(Context context, Object response, Object payload, Throwable failure, TagExtractor tagExtractor) {\n         assertSame(val, context.getLocal(key));\n-        context.putLocal(key, null);\n+        context.removeLocal(key);\n         assertNotNull(response);\n         assertTrue(response instanceof HttpResponse);\n         assertNull(failure);\n@@ -225,7 +225,7 @@ public Object sendRequest(Context context, SpanKind kind, TracingPolicy policy,\n       @Override\n       public void receiveResponse(Context context, Object response, Object payload, Throwable failure, TagExtractor tagExtractor) {\n         assertSame(val, context.getLocal(key));\n-        context.putLocal(key, null);\n+        context.removeLocal(key);\n         assertNull(response);\n         assertNotNull(failure);\n         assertTrue(seq.compareAndSet(1, 2));",
      "parent_sha": "cdc45dd683140c5074aeb1381b7a000f0ee96ea7"
    }
  },
  {
    "oid": "3a14a6aa1b1422a4176c84ca47762315619667cd",
    "message": "Rewrote failing test",
    "date": "2014-11-01T13:32:06Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/3a14a6aa1b1422a4176c84ca47762315619667cd",
    "details": {
      "sha": "db5de6deaee1cf7252f9e05b597f4f6a878e85dd",
      "filename": "vertx-core/src/test/java/io/vertx/test/core/TimerTest.java",
      "status": "modified",
      "additions": 11,
      "deletions": 16,
      "changes": 27,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/3a14a6aa1b1422a4176c84ca47762315619667cd/vertx-core%2Fsrc%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FTimerTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/3a14a6aa1b1422a4176c84ca47762315619667cd/vertx-core%2Fsrc%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FTimerTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/vertx-core%2Fsrc%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FTimerTest.java?ref=3a14a6aa1b1422a4176c84ca47762315619667cd",
      "patch": "@@ -22,8 +22,6 @@\n import io.vertx.core.streams.ReadStream;\n import org.junit.Test;\n \n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n@@ -255,23 +253,20 @@ public void testPeriodicSetHandlerTwice() throws Exception {\n \n   @Test\n   public void testPeriodicPauseResume() throws Exception {\n-    ReadStream<Long> timer1 = vertx.periodicStream(10);\n-    ReadStream<Long> timer2 = vertx.periodicStream(10);\n-    AtomicInteger count1 = new AtomicInteger();\n-    AtomicInteger count2 = new AtomicInteger();\n-    timer1.handler(l -> count1.incrementAndGet());\n-    timer2.handler(l -> {\n-      int value2 = count2.incrementAndGet();\n-      if (value2 == 3) {\n-        timer1.resume();\n-      } else if (value2 == 5) {\n-        int value1 = count1.get();\n-        assertTrue(\"Was expecting \" + value1 + \" to be > 0\", value1 > 0);\n-        assertTrue(\"Was expecting \" + value1 + \" to be < 2\", value1 < 3);\n+    ReadStream<Long> timer = vertx.periodicStream(10);\n+    AtomicInteger count = new AtomicInteger();\n+    timer.handler(id -> {\n+      int cnt = count.incrementAndGet();\n+      if (cnt == 2) {\n+        timer.pause();\n+        vertx.setTimer(500, id2 -> {\n+          assertEquals(2, count.get());\n+          timer.resume();\n+        });\n+      } else if (cnt == 3) {\n         testComplete();\n       }\n     });\n-    timer1.pause();\n     await();\n   }\n }",
      "parent_sha": "cbe9fe6599fb35fadbbcff0f702c4ef5d6e35fed"
    }
  },
  {
    "oid": "c098956fd16276a2630f42af46318446703ff526",
    "message": "Improve HttpClient javadoc",
    "date": "2023-04-25T15:43:27Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/c098956fd16276a2630f42af46318446703ff526",
    "details": {
      "sha": "ad7dee49d96f3dac99d07c07eb590bff24910150",
      "filename": "src/main/java/io/vertx/core/http/HttpClient.java",
      "status": "modified",
      "additions": 10,
      "deletions": 11,
      "changes": 21,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/c098956fd16276a2630f42af46318446703ff526/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttpClient.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/c098956fd16276a2630f42af46318446703ff526/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttpClient.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttpClient.java?ref=c098956fd16276a2630f42af46318446703ff526",
      "patch": "@@ -56,17 +56,15 @@\n public interface HttpClient extends Measured {\n \n   /**\n-   * Create an HTTP request to send to the server. The {@code handler}\n-   * is called when the request is ready to be sent.\n+   * Create an HTTP request to send to the server.\n    *\n    * @param options    the request options\n    * @return a future notified when the request is ready to be sent\n    */\n   Future<HttpClientRequest> request(RequestOptions options);\n \n   /**\n-   * Create an HTTP request to send to the server at the {@code host} and {@code port}. The {@code handler}\n-   * is called when the request is ready to be sent.\n+   * Create an HTTP request to send to the server at the {@code host} and {@code port}.\n    *\n    * @param method     the HTTP method\n    * @param port       the port\n@@ -77,8 +75,7 @@ public interface HttpClient extends Measured {\n   Future<HttpClientRequest> request(HttpMethod method, int port, String host, String requestURI);\n \n   /**\n-   * Create an HTTP request to send to the server at the {@code host} and default port. The {@code handler}\n-   * is called when the request is ready to be sent.\n+   * Create an HTTP request to send to the server at the {@code host} and default port.\n    *\n    * @param method     the HTTP method\n    * @param host       the host\n@@ -88,8 +85,7 @@ public interface HttpClient extends Measured {\n   Future<HttpClientRequest> request(HttpMethod method, String host, String requestURI);\n \n   /**\n-   * Create an HTTP request to send to the server at the default host and port. The {@code handler}\n-   * is called when the request is ready to be sent.\n+   * Create an HTTP request to send to the server at the default host and port.\n    *\n    * @param method     the HTTP method\n    * @param requestURI the relative URI\n@@ -98,7 +94,8 @@ public interface HttpClient extends Measured {\n   Future<HttpClientRequest> request(HttpMethod method, String requestURI);\n \n   /**\n-   * Connect a WebSocket to the specified port, host and relative request URI\n+   * Connect a WebSocket to the specified port, host and relative request URI.\n+   *\n    * @param port  the port\n    * @param host  the host\n    * @param requestURI  the relative URI\n@@ -107,15 +104,17 @@ public interface HttpClient extends Measured {\n   Future<WebSocket> webSocket(int port, String host, String requestURI);\n \n   /**\n-   * Connect a WebSocket to the host and relative request URI and default port\n+   * Connect a WebSocket to the host and relative request URI and default port.\n+   *\n    * @param host  the host\n    * @param requestURI  the relative URI\n    * @return a future notified when the WebSocket when connected\n    */\n   Future<WebSocket> webSocket(String host, String requestURI);\n \n   /**\n-   * Connect a WebSocket at the relative request URI using the default host and port\n+   * Connect a WebSocket at the relative request URI using the default host and port.\n+   *\n    * @param requestURI  the relative URI\n    * @return a future notified when the WebSocket when connected\n    */",
      "parent_sha": "6377f4b807180ed8a8e5f60dfa95c57896218671"
    }
  },
  {
    "oid": "809b50b4212824410ba627071a282ae6c03d494e",
    "message": "Fix sockjs message matching. Also allow deep matching.",
    "date": "2013-10-17T23:44:01Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/809b50b4212824410ba627071a282ae6c03d494e",
    "details": {
      "sha": "cc8e4d02fb3ad686bd3f53b74fcfd8bd8589ee36",
      "filename": "vertx-core/src/main/java/org/vertx/java/core/sockjs/EventBusBridge.java",
      "status": "modified",
      "additions": 25,
      "deletions": 13,
      "changes": 38,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/809b50b4212824410ba627071a282ae6c03d494e/vertx-core%2Fsrc%2Fmain%2Fjava%2Forg%2Fvertx%2Fjava%2Fcore%2Fsockjs%2FEventBusBridge.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/809b50b4212824410ba627071a282ae6c03d494e/vertx-core%2Fsrc%2Fmain%2Fjava%2Forg%2Fvertx%2Fjava%2Fcore%2Fsockjs%2FEventBusBridge.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/vertx-core%2Fsrc%2Fmain%2Fjava%2Forg%2Fvertx%2Fjava%2Fcore%2Fsockjs%2FEventBusBridge.java?ref=809b50b4212824410ba627071a282ae6c03d494e",
      "patch": "@@ -414,19 +414,7 @@ private Match checkMatches(boolean inbound, String address, Object body) {\n       }\n \n       if (addressOK) {\n-        boolean matched = true;\n-        // Can send message other than JSON too - in which case we can't do deep matching on structure of message\n-        if (body instanceof JsonObject) {\n-          JsonObject match = matchHolder.getObject(\"match\");\n-          if (match != null) {\n-            for (String fieldName: match.getFieldNames()) {\n-              if (!match.getField(fieldName).equals(((JsonObject)body).getField(fieldName))) {\n-                matched = false;\n-                break;\n-              }\n-            }\n-          }\n-        }\n+        boolean matched = structureMatches(matchHolder.getObject(\"match\"), body);\n         if (matched) {\n           Boolean b = matchHolder.getBoolean(\"requires_auth\");\n           return new Match(true, b != null && b);\n@@ -446,6 +434,30 @@ private boolean regexMatches(String matchRegex, String address) {\n     return m.matches();\n   }\n \n+  private static boolean structureMatches(JsonObject match, Object bodyObject) {\n+    if (match == null) return true;\n+    if (bodyObject == null) return false;\n+\n+    // Can send message other than JSON too - in which case we can't do deep matching on structure of message\n+    if (bodyObject instanceof JsonObject) {\n+      JsonObject body = (JsonObject) bodyObject;\n+      for (String fieldName : match.getFieldNames()) {\n+        Object mv = match.getField(fieldName);\n+        Object bv = body.getField(fieldName);\n+        // Support deep matching\n+        if (mv instanceof JsonObject) {\n+          if (!structureMatches((JsonObject) mv, bv)) {\n+            return false;\n+          }\n+        } else if (!match.getField(fieldName).equals(body.getField(fieldName))) {\n+          return false;\n+        }\n+      }\n+      return true;\n+    }\n+\n+    return false;\n+  }\n \n   private void cacheAuthorisation(String sessionID, SockJSSocket sock) {\n     authCache.put(sessionID, new Auth(sessionID, sock));",
      "parent_sha": "48a601d63fd3003c9a9dd8323614b9fcaba45eeb"
    }
  },
  {
    "oid": "c9e4d83f7ae1c9d114463a3682c4b26176888695",
    "message": "Get the list of enabled cipher suite for testing from the JDK",
    "date": "2018-09-02T13:03:32Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/c9e4d83f7ae1c9d114463a3682c4b26176888695",
    "details": {
      "sha": "27902a967027f6b0f0ad07de79a7f90bdf7b2efd",
      "filename": "src/test/java/io/vertx/test/core/VertxTestBase.java",
      "status": "modified",
      "additions": 14,
      "deletions": 74,
      "changes": 88,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/c9e4d83f7ae1c9d114463a3682c4b26176888695/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FVertxTestBase.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/c9e4d83f7ae1c9d114463a3682c4b26176888695/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FVertxTestBase.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FVertxTestBase.java?ref=c9e4d83f7ae1c9d114463a3682c4b26176888695",
      "patch": "@@ -29,6 +29,9 @@\n import io.vertx.test.fakecluster.FakeClusterManager;\n import org.junit.Rule;\n \n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import java.security.NoSuchAlgorithmException;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n@@ -185,80 +188,17 @@ protected static void setOptions(TCPSSLOptions sslOptions, KeyCertOptions option\n     }\n   }\n \n-  protected static final String[] ENABLED_CIPHER_SUITES =\n-    new String[] {\n-      \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\",\n-      \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\",\n-      \"TLS_RSA_WITH_AES_128_CBC_SHA256\",\n-      \"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256\",\n-      \"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256\",\n-      \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\",\n-      \"TLS_DHE_DSS_WITH_AES_128_CBC_SHA256\",\n-      \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\",\n-      \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\",\n-      \"TLS_RSA_WITH_AES_128_CBC_SHA\",\n-      \"TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA\",\n-      \"TLS_ECDH_RSA_WITH_AES_128_CBC_SHA\",\n-      \"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\",\n-      \"TLS_DHE_DSS_WITH_AES_128_CBC_SHA\",\n-      \"TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\",\n-      \"TLS_ECDHE_RSA_WITH_RC4_128_SHA\",\n-      \"SSL_RSA_WITH_RC4_128_SHA\",\n-      \"TLS_ECDH_ECDSA_WITH_RC4_128_SHA\",\n-      \"TLS_ECDH_RSA_WITH_RC4_128_SHA\",\n-      \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\",\n-      \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\",\n-      \"TLS_RSA_WITH_AES_128_GCM_SHA256\",\n-      \"TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256\",\n-      \"TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256\",\n-      \"TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\",\n-      \"TLS_DHE_DSS_WITH_AES_128_GCM_SHA256\",\n-      \"TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA\",\n-      \"TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\",\n-      \"SSL_RSA_WITH_3DES_EDE_CBC_SHA\",\n-      \"TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA\",\n-      \"TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA\",\n-      \"SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA\",\n-      \"SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA\",\n-      \"SSL_RSA_WITH_RC4_128_MD5\",\n-      \"TLS_EMPTY_RENEGOTIATION_INFO_SCSV\",\n-      \"TLS_DH_anon_WITH_AES_128_GCM_SHA256\",\n-      \"TLS_DH_anon_WITH_AES_128_CBC_SHA256\",\n-      \"TLS_ECDH_anon_WITH_AES_128_CBC_SHA\",\n-      \"TLS_DH_anon_WITH_AES_128_CBC_SHA\",\n-      \"TLS_ECDH_anon_WITH_RC4_128_SHA\",\n-      \"SSL_DH_anon_WITH_RC4_128_MD5\",\n-      \"TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA\",\n-      \"SSL_DH_anon_WITH_3DES_EDE_CBC_SHA\",\n-      \"TLS_RSA_WITH_NULL_SHA256\",\n-      \"TLS_ECDHE_ECDSA_WITH_NULL_SHA\",\n-      \"TLS_ECDHE_RSA_WITH_NULL_SHA\",\n-      \"SSL_RSA_WITH_NULL_SHA\",\n-      \"TLS_ECDH_ECDSA_WITH_NULL_SHA\",\n-      \"TLS_ECDH_RSA_WITH_NULL_SHA\",\n-      \"TLS_ECDH_anon_WITH_NULL_SHA\",\n-      \"SSL_RSA_WITH_NULL_MD5\",\n-      \"SSL_RSA_WITH_DES_CBC_SHA\",\n-      \"SSL_DHE_RSA_WITH_DES_CBC_SHA\",\n-      \"SSL_DHE_DSS_WITH_DES_CBC_SHA\",\n-      \"SSL_DH_anon_WITH_DES_CBC_SHA\",\n-      \"SSL_RSA_EXPORT_WITH_RC4_40_MD5\",\n-      \"SSL_DH_anon_EXPORT_WITH_RC4_40_MD5\",\n-      \"SSL_RSA_EXPORT_WITH_DES40_CBC_SHA\",\n-      \"SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA\",\n-      \"SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA\",\n-      \"SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA\",\n-      \"TLS_KRB5_WITH_RC4_128_SHA\",\n-      \"TLS_KRB5_WITH_RC4_128_MD5\",\n-      \"TLS_KRB5_WITH_3DES_EDE_CBC_SHA\",\n-      \"TLS_KRB5_WITH_3DES_EDE_CBC_MD5\",\n-      \"TLS_KRB5_WITH_DES_CBC_SHA\",\n-      \"TLS_KRB5_WITH_DES_CBC_MD5\",\n-      \"TLS_KRB5_EXPORT_WITH_RC4_40_SHA\",\n-      \"TLS_KRB5_EXPORT_WITH_RC4_40_MD5\",\n-      \"TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA\",\n-      \"TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5\"\n-    };\n+  protected static final String[] ENABLED_CIPHER_SUITES;\n+\n+  static {\n+    String[] suites = new String[0];\n+    try {\n+      suites = SSLContext.getDefault().getSocketFactory().getSupportedCipherSuites();\n+    } catch (NoSuchAlgorithmException e) {\n+      e.printStackTrace();\n+    }\n+    ENABLED_CIPHER_SUITES = suites;\n+  }\n \n   /**\n    * Create a worker verticle for the current Vert.x and return its context.",
      "parent_sha": "7a41b112c839c326897f6c4a7bb3da63873ab5df"
    }
  },
  {
    "oid": "824ed9c7bf97cf8c6e0d95ee5c86712be8e8ca15",
    "message": "minor javadoc improvements\n\nSigned-off-by: Paulo Lopes <pmlopes@gmail.com>",
    "date": "2020-04-22T09:23:28Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/824ed9c7bf97cf8c6e0d95ee5c86712be8e8ca15",
    "details": {
      "sha": "07eaaee9c15f0e3f38929673c97d7f897cd8447d",
      "filename": "src/main/java/io/vertx/core/json/JsonObject.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/824ed9c7bf97cf8c6e0d95ee5c86712be8e8ca15/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fjson%2FJsonObject.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/824ed9c7bf97cf8c6e0d95ee5c86712be8e8ca15/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fjson%2FJsonObject.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fjson%2FJsonObject.java?ref=824ed9c7bf97cf8c6e0d95ee5c86712be8e8ca15",
      "patch": "@@ -298,15 +298,15 @@ public byte[] getBinary(String key) {\n   }\n \n   /**\n-   * Get the Buffer value with the specified key.\n+   * Get the {@code Buffer} value with the specified key.\n    *\n    * JSON itself has no notion of a binary, this extension complies to the RFC-7493, so this method assumes there is a\n    * String value with the key and it contains a Base64 encoded binary, which it decodes if found and returns.\n    *\n-   * @param key the key to return the value for\n+   * @param key the string to return the value for\n    * @return the value or null if no value for that key\n    * @throws java.lang.ClassCastException       if the value is not a String\n-   * @throws java.lang.IllegalArgumentException if the String value is not a legal Base64 encoded value\n+   * @throws java.lang.IllegalArgumentException if the String is not a legal Base64 encoded value\n    */\n   public Buffer getBuffer(String key) {\n     Objects.requireNonNull(key);",
      "parent_sha": "035a2cf24ebdb1135793d1ab2a123e826d7facf1"
    }
  },
  {
    "oid": "81f35814da87938c4681399214a3365b4ba73d19",
    "message": "CompletionStage trampolining test\n\nSigned-off-by: Julien Ponge <julien.ponge@gmail.com>",
    "date": "2019-12-12T10:18:34Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/81f35814da87938c4681399214a3365b4ba73d19",
    "details": {
      "sha": "79bd817c662c76b57d6a6521a346eeaed9df5b39",
      "filename": "src/test/java/io/vertx/core/FutureTest.java",
      "status": "modified",
      "additions": 142,
      "deletions": 41,
      "changes": 183,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/81f35814da87938c4681399214a3365b4ba73d19/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2FFutureTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/81f35814da87938c4681399214a3365b4ba73d19/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2FFutureTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2FFutureTest.java?ref=81f35814da87938c4681399214a3365b4ba73d19",
      "patch": "@@ -22,6 +22,7 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n@@ -31,6 +32,8 @@\n import java.util.function.Consumer;\n import java.util.function.Function;\n \n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n /**\n  * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n  */\n@@ -197,7 +200,7 @@ public void testFailFutureToHandler() {\n \n   @Test\n   public void testCreateFailedWithNullFailure() {\n-    Future<String> future = Future.failedFuture((Throwable)null);\n+    Future<String> future = Future.failedFuture((Throwable) null);\n     Checker<String> checker = new Checker<>(future);\n     NoStackTraceThrowable failure = (NoStackTraceThrowable) checker.assertFailed();\n     assertNull(failure.getMessage());\n@@ -206,7 +209,7 @@ public void testCreateFailedWithNullFailure() {\n   @Test\n   public void testFailureFutureWithNullFailure() {\n     Promise<String> promise = Promise.promise();\n-    promise.fail((Throwable)null);\n+    promise.fail((Throwable) null);\n     Checker<String> checker = new Checker<>(promise.future());\n     NoStackTraceThrowable failure = (NoStackTraceThrowable) checker.assertFailed();\n     assertNull(failure.getMessage());\n@@ -239,7 +242,7 @@ private void testAllSucceeded(BiFunction<Future<String>, Future<Integer>, Compos\n     p2.complete(3);\n     checker.assertSucceeded(composite);\n     assertEquals(\"something\", composite.resultAt(0));\n-    assertEquals(3, (int)composite.resultAt(1));\n+    assertEquals(3, (int) composite.resultAt(1));\n   }\n \n   @Test\n@@ -283,22 +286,22 @@ public void testAllLargeList() {\n \n   private void testAllLargeList(int size) {\n     List<Future> list = new ArrayList<>();\n-    for (int i = 0;i < size;i++) {\n+    for (int i = 0; i < size; i++) {\n       list.add(Future.succeededFuture());\n     }\n     CompositeFuture composite = CompositeFuture.all(list);\n     Checker<CompositeFuture> checker = new Checker<>(composite);\n     checker.assertSucceeded(composite);\n-    for (int i = 0;i < size;i++) {\n+    for (int i = 0; i < size; i++) {\n       list.clear();\n       Throwable cause = new Exception();\n-      for (int j = 0;j < size;j++) {\n+      for (int j = 0; j < size; j++) {\n         list.add(i == j ? Future.failedFuture(cause) : Future.succeededFuture());\n       }\n       composite = CompositeFuture.all(list);\n       checker = new Checker<>(composite);\n       checker.assertFailed(cause);\n-      for (int j = 0;j < size;j++) {\n+      for (int j = 0; j < size; j++) {\n         if (i == j) {\n           assertTrue(composite.failed(j));\n         } else {\n@@ -397,21 +400,21 @@ public void testAnyLargeList() {\n \n   private void testAnyLargeList(int size) {\n     List<Future> list = new ArrayList<>();\n-    for (int i = 0;i < size;i++) {\n+    for (int i = 0; i < size; i++) {\n       list.add(Future.failedFuture(new Exception()));\n     }\n     CompositeFuture composite = CompositeFuture.any(list);\n     Checker<CompositeFuture> checker = new Checker<>(composite);\n     assertNotNull(checker.assertFailed());\n-    for (int i = 0;i < size;i++) {\n+    for (int i = 0; i < size; i++) {\n       list.clear();\n-      for (int j = 0;j < size;j++) {\n+      for (int j = 0; j < size; j++) {\n         list.add(i == j ? Future.succeededFuture() : Future.failedFuture(new RuntimeException()));\n       }\n       composite = CompositeFuture.any(list);\n       checker = new Checker<>(composite);\n       checker.assertSucceeded(composite);\n-      for (int j = 0;j < size;j++) {\n+      for (int j = 0; j < size; j++) {\n         if (i == j) {\n           assertTrue(composite.succeeded(j));\n         } else {\n@@ -552,7 +555,7 @@ public void testComposeSuccessToSuccess() {\n       ref.set(string);\n       return c;\n     });\n-    Checker<Integer>  checker = new Checker<>(f4);\n+    Checker<Integer> checker = new Checker<>(f4);\n     p3.complete(\"abcdef\");\n     checker.assertNotCompleted();\n     assertEquals(\"abcdef\", ref.get());\n@@ -595,7 +598,9 @@ public void testComposeFails() {\n     RuntimeException cause = new RuntimeException();\n     Promise<String> p3 = Promise.promise();\n     Future<String> f3 = p3.future();\n-    Future<Integer> f4 = f3.compose(string -> { throw cause; });\n+    Future<Integer> f4 = f3.compose(string -> {\n+      throw cause;\n+    });\n     Checker<Integer> checker = new Checker<>(f4);\n     p3.complete(\"foo\");\n     checker.assertFailed(cause);\n@@ -786,53 +791,102 @@ public void testOtherwiseFails() {\n   public void testDefaultCompleter() {\n     AsyncResult<Object> succeededAsyncResult = new AsyncResult<Object>() {\n       Object result = new Object();\n-      public Object result() { return result; }\n-      public Throwable cause() { throw new UnsupportedOperationException(); }\n-      public boolean succeeded() { return true; }\n-      public boolean failed() { throw new UnsupportedOperationException(); }\n-      public <U> AsyncResult<U> map(Function<Object, U> mapper) { throw new UnsupportedOperationException(); }\n-      public <V> AsyncResult<V> map(V value) { throw new UnsupportedOperationException(); }\n+\n+      public Object result() {\n+        return result;\n+      }\n+\n+      public Throwable cause() {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      public boolean succeeded() {\n+        return true;\n+      }\n+\n+      public boolean failed() {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      public <U> AsyncResult<U> map(Function<Object, U> mapper) {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      public <V> AsyncResult<V> map(V value) {\n+        throw new UnsupportedOperationException();\n+      }\n     };\n \n     AsyncResult<Object> failedAsyncResult = new AsyncResult<Object>() {\n       Throwable cause = new Throwable();\n-      public Object result() { throw new UnsupportedOperationException(); }\n-      public Throwable cause() { return cause; }\n-      public boolean succeeded() { return false; }\n-      public boolean failed() { throw new UnsupportedOperationException(); }\n-      public <U> AsyncResult<U> map(Function<Object, U> mapper) { throw new UnsupportedOperationException(); }\n-      public <V> AsyncResult<V> map(V value) { throw new UnsupportedOperationException(); }\n+\n+      public Object result() {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      public Throwable cause() {\n+        return cause;\n+      }\n+\n+      public boolean succeeded() {\n+        return false;\n+      }\n+\n+      public boolean failed() {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      public <U> AsyncResult<U> map(Function<Object, U> mapper) {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      public <V> AsyncResult<V> map(V value) {\n+        throw new UnsupportedOperationException();\n+      }\n     };\n \n     class DefaultCompleterTestFuture<T> implements Future<T> {\n       boolean succeeded;\n       boolean failed;\n       T result;\n       Throwable cause;\n-      public boolean isComplete() { throw new UnsupportedOperationException(); }\n-      public Future<T> onComplete(Handler<AsyncResult<T>> handler) { throw new UnsupportedOperationException(); }\n-      public Handler<AsyncResult<T>> getHandler() { throw new UnsupportedOperationException(); }\n+\n+      public boolean isComplete() {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      public Future<T> onComplete(Handler<AsyncResult<T>> handler) {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      public Handler<AsyncResult<T>> getHandler() {\n+        throw new UnsupportedOperationException();\n+      }\n \n       public void complete(T result) {\n         if (!tryComplete(result)) {\n           throw new IllegalStateException();\n         }\n       }\n+\n       public void complete() {\n         if (!tryComplete()) {\n           throw new IllegalStateException();\n         }\n       }\n+\n       public void fail(Throwable cause) {\n         if (!tryFail(cause)) {\n           throw new IllegalStateException();\n         }\n       }\n+\n       public void fail(String failureMessage) {\n         if (!tryFail(failureMessage)) {\n           throw new IllegalStateException();\n         }\n       }\n+\n       public boolean tryComplete(T result) {\n         if (succeeded || failed) {\n           return false;\n@@ -841,7 +895,11 @@ public boolean tryComplete(T result) {\n         this.result = result;\n         return true;\n       }\n-      public boolean tryComplete() { throw new UnsupportedOperationException(); }\n+\n+      public boolean tryComplete() {\n+        throw new UnsupportedOperationException();\n+      }\n+\n       public boolean tryFail(Throwable cause) {\n         if (succeeded || failed) {\n           return false;\n@@ -850,11 +908,27 @@ public boolean tryFail(Throwable cause) {\n         this.cause = cause;\n         return true;\n       }\n-      public boolean tryFail(String failureMessage) { throw new UnsupportedOperationException(); }\n-      public T result() { throw new UnsupportedOperationException(); }\n-      public Throwable cause() { throw new UnsupportedOperationException(); }\n-      public boolean succeeded() { throw new UnsupportedOperationException(); }\n-      public boolean failed() { throw new UnsupportedOperationException(); }\n+\n+      public boolean tryFail(String failureMessage) {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      public T result() {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      public Throwable cause() {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      public boolean succeeded() {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      public boolean failed() {\n+        throw new UnsupportedOperationException();\n+      }\n+\n       public void handle(AsyncResult<T> asyncResult) {\n         if (asyncResult.succeeded()) {\n           complete(asyncResult.result());\n@@ -954,9 +1028,9 @@ public void testSucceededAsyncResultMap() {\n     AsyncResult<Integer> map1 = res.map(String::length);\n     AsyncResult<Integer> map2 = res.map(17);\n     p.complete(\"foobar\");\n-    assertEquals(6, (int)map1.result());\n+    assertEquals(6, (int) map1.result());\n     assertNull(map1.cause());\n-    assertEquals(17, (int)map2.result());\n+    assertEquals(17, (int) map2.result());\n     assertNull(map2.cause());\n   }\n \n@@ -1216,17 +1290,21 @@ public void testReleaseHandlerAfterCompletion() throws Exception {\n     Future<String> f = promise.future();\n     Field handlerField = f.getClass().getDeclaredField(\"handler\");\n     handlerField.setAccessible(true);\n-    f.setHandler(ar -> {});\n+    f.setHandler(ar -> {\n+    });\n     promise.complete();\n     assertNull(handlerField.get(f));\n-    f.setHandler(ar -> {});\n+    f.setHandler(ar -> {\n+    });\n     assertNull(handlerField.get(f));\n     promise = Promise.promise();\n     f = promise.future();\n-    f.setHandler(ar -> {});\n+    f.setHandler(ar -> {\n+    });\n     promise.fail(\"abc\");\n     assertNull(handlerField.get(f));\n-    f.setHandler(ar -> {});\n+    f.setHandler(ar -> {\n+    });\n     assertNull(handlerField.get(f));\n   }\n \n@@ -1255,7 +1333,7 @@ public void testSucceedOnContext() throws Exception {\n     ctx.runOnContext(v -> {\n       latch.complete(Thread.currentThread());\n     });\n-    Thread elThread = latch.get(10, TimeUnit.SECONDS);\n+    Thread elThread = latch.get(10, SECONDS);\n \n     //\n     CountDownLatch latch1 = new CountDownLatch(1);\n@@ -1424,4 +1502,27 @@ public void testFailureNotification() {\n     promise.fail(failure);\n     await();\n   }\n+\n+  @Test\n+  public void testToCompletionStageTrampolining() {\n+    waitFor(2);\n+    Thread thread = Thread.currentThread();\n+    Future<String> success = Future.succeededFuture(\"Yo\");\n+    success.toCompletionStage()\n+      .thenAccept(s -> {\n+        assertEquals(\"Yo\", s);\n+        assertSame(thread, Thread.currentThread());\n+        complete();\n+      });\n+    Future<String> failed = Future.failedFuture(new RuntimeException(\"Woops\"));\n+    failed.toCompletionStage()\n+      .whenComplete((s, err) -> {\n+        assertNull(s);\n+        assertTrue(err instanceof RuntimeException);\n+        assertEquals(\"Woops\", err.getMessage());\n+        assertSame(thread, Thread.currentThread());\n+        complete();\n+      });\n+    await(5, SECONDS);\n+  }\n }",
      "parent_sha": "48561de730ae4d4b0d2b6d7f2e6f007417b38081"
    }
  },
  {
    "oid": "50adff0f881bd1dcdb00881a2f29428ffc3233d7",
    "message": "Http1xServerRequest should lazy create the inbound queue.\n\nMotivation:\n\nHttp1xServerRequest should not create an inbound queue for request that do not need it (e.g. GET).\n\nChanges:\n\nLazy create the inbound queue which avoids instantiating the queue and using it for delivering the request end event.",
    "date": "2025-04-01T17:12:37Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/50adff0f881bd1dcdb00881a2f29428ffc3233d7",
    "details": {
      "sha": "38922c925bc4c9e032d16f19f2d1158492340f5c",
      "filename": "vertx-core/src/main/java/io/vertx/core/http/impl/Http1xServerRequest.java",
      "status": "modified",
      "additions": 46,
      "deletions": 19,
      "changes": 65,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/50adff0f881bd1dcdb00881a2f29428ffc3233d7/vertx-core%2Fsrc%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FHttp1xServerRequest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/50adff0f881bd1dcdb00881a2f29428ffc3233d7/vertx-core%2Fsrc%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FHttp1xServerRequest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/vertx-core%2Fsrc%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FHttp1xServerRequest.java?ref=50adff0f881bd1dcdb00881a2f29428ffc3233d7",
      "patch": "@@ -86,30 +86,47 @@ public class Http1xServerRequest extends HttpServerRequestInternal implements io\n   private HttpPostRequestDecoder decoder;\n   private boolean ended;\n   private long bytesRead;\n-  private final InboundMessageQueue<Object> queue;\n+  private volatile InboundMessageQueue<Object> queue;\n \n   Http1xServerRequest(Http1xServerConnection conn, HttpRequest request, ContextInternal context) {\n     this.conn = conn;\n     this.context = context;\n     this.request = request;\n-    this.queue = new InboundMessageQueue<>(context.eventLoop(), context.executor()) {\n-      @Override\n-      protected void handleMessage(Object elt) {\n-        if (elt == InboundBuffer.END_SENTINEL) {\n-          onEnd();\n-        } else {\n-          onData((Buffer) elt);\n+  }\n+\n+  private InboundMessageQueue<Object> queue() {\n+    return queue(true);\n+  }\n+\n+  private InboundMessageQueue<Object> queue(boolean create) {\n+    InboundMessageQueue<Object> ref = queue;\n+    if (create && ref == null) {\n+      synchronized (this) {\n+        ref = queue;\n+        if (ref == null) {\n+          ref = new InboundMessageQueue<>(context.eventLoop(), context.executor()) {\n+            @Override\n+            protected void handleMessage(Object elt) {\n+              if (elt == InboundBuffer.END_SENTINEL) {\n+                onEnd();\n+              } else {\n+                onData((Buffer) elt);\n+              }\n+            }\n+            @Override\n+            protected void handleResume() {\n+              conn.doResume();\n+            }\n+            @Override\n+            protected void handlePause() {\n+              conn.doPause();\n+            }\n+          };\n+          queue = ref;\n         }\n       }\n-      @Override\n-      protected void handleResume() {\n-        conn.doResume();\n-      }\n-      @Override\n-      protected void handlePause() {\n-        conn.doPause();\n-      }\n-    };\n+    }\n+    return ref;\n   }\n \n   private HttpEventHandler eventHandler(boolean create) {\n@@ -136,13 +153,23 @@ void handleBegin(boolean keepAlive) {\n   }\n \n   void handleContent(Buffer buffer) {\n+    InboundMessageQueue<Object> queue = queue();\n     boolean drain = queue.add(buffer);\n     if (drain) {\n       queue.drain();\n     }\n   }\n \n   void handleEnd() {\n+    InboundMessageQueue<Object> queue = queue(false);\n+    if (queue != null) {\n+      handleEnd(queue);\n+    } else {\n+      context.execute(this, Http1xServerRequest::onEnd);\n+    }\n+  }\n+\n+  private void handleEnd(InboundMessageQueue<Object> queue) {\n     boolean drain = queue.add(InboundBuffer.END_SENTINEL);\n     if (drain) {\n       queue.drain();\n@@ -334,13 +361,13 @@ public HttpServerRequest exceptionHandler(Handler<Throwable> handler) {\n \n   @Override\n   public HttpServerRequest pause() {\n-    queue.pause();\n+    queue().pause();\n     return this;\n   }\n \n   @Override\n   public HttpServerRequest fetch(long amount) {\n-    queue.fetch(amount);\n+    queue().fetch(amount);\n     return this;\n   }\n ",
      "parent_sha": "56cac9a482dc5b62c405330ad868cf363574b67f"
    }
  },
  {
    "oid": "a09eb630474b1642e4daf0469edb28a636236949",
    "message": "Fix improperly named arguments in chownSync().",
    "date": "2013-12-16T06:39:12Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/a09eb630474b1642e4daf0469edb28a636236949",
    "details": {
      "sha": "b37f667c9ac0c513b8d2a476413d6511f706781e",
      "filename": "vertx-core/src/main/java/org/vertx/java/core/file/FileSystem.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/a09eb630474b1642e4daf0469edb28a636236949/vertx-core%2Fsrc%2Fmain%2Fjava%2Forg%2Fvertx%2Fjava%2Fcore%2Ffile%2FFileSystem.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/a09eb630474b1642e4daf0469edb28a636236949/vertx-core%2Fsrc%2Fmain%2Fjava%2Forg%2Fvertx%2Fjava%2Fcore%2Ffile%2FFileSystem.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/vertx-core%2Fsrc%2Fmain%2Fjava%2Forg%2Fvertx%2Fjava%2Fcore%2Ffile%2FFileSystem.java?ref=a09eb630474b1642e4daf0469edb28a636236949",
      "patch": "@@ -115,7 +115,7 @@ public interface FileSystem {\n    * Synchronous version of {@link #chown(String, String, String, Handler)}\n    *\n    */\n-  FileSystem chownSync(String user, String group, String perms) ;\n+  FileSystem chownSync(String path, String user, String group) ;\n \n   /**\n    * Obtain properties for the file represented by {@code path}, asynchronously.",
      "parent_sha": "b57290a4420dc78df021002d45dfdff632342db4"
    }
  },
  {
    "oid": "12221be1fd8f83441bcb40786337f6c83e5657d4",
    "message": "Fix issue in Http2ClientTest#testClientResetServerStreamDuringResponse",
    "date": "2017-09-25T07:49:45Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/12221be1fd8f83441bcb40786337f6c83e5657d4",
    "details": {
      "sha": "6ca1260590a80c70f27e4fee710dcdea5a015a08",
      "filename": "src/test/java/io/vertx/test/core/Http2ClientTest.java",
      "status": "modified",
      "additions": 8,
      "deletions": 2,
      "changes": 10,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/12221be1fd8f83441bcb40786337f6c83e5657d4/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttp2ClientTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/12221be1fd8f83441bcb40786337f6c83e5657d4/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttp2ClientTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttp2ClientTest.java?ref=12221be1fd8f83441bcb40786337f6c83e5657d4",
      "patch": "@@ -760,9 +760,15 @@ public void testClientResetServerStreamDuringResponse() throws Exception {\n       req.exceptionHandler(err -> {\n         assertTrue(err instanceof StreamResetException);\n       });\n+      AtomicReference<StreamResetException> reset = new AtomicReference<>();\n       req.response().exceptionHandler(err -> {\n-        assertTrue(err instanceof StreamResetException);\n-        assertEquals(10L, ((StreamResetException) err).getCode());\n+        if (err instanceof StreamResetException) {\n+          assertTrue(reset.compareAndSet(null, (StreamResetException) err));\n+        }\n+      });\n+      req.response().closeHandler(v -> {\n+        assertNotNull(reset.get());\n+        assertEquals(10L, reset.get().getCode());\n         testComplete();\n       });\n       req.response().setChunked(true).write(Buffer.buffer(\"some-data\"));",
      "parent_sha": "0990f2bfd3a770da59271ac1f6b3a33a39b9fc36"
    }
  },
  {
    "oid": "11926e407ac52faea891fc143b47c0021794c32a",
    "message": "Added some inner comments to clarify the algorithm\n\nSigned-off-by: Paulo Lopes <pmlopes@gmail.com>",
    "date": "2021-12-08T14:22:07Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/11926e407ac52faea891fc143b47c0021794c32a",
    "details": {
      "sha": "dfdf25d7ca89624bdc24c26271e3faddada5e43f",
      "filename": "src/main/java/io/vertx/core/http/impl/CookieJar.java",
      "status": "modified",
      "additions": 31,
      "deletions": 24,
      "changes": 55,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/11926e407ac52faea891fc143b47c0021794c32a/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FCookieJar.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/11926e407ac52faea891fc143b47c0021794c32a/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FCookieJar.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FCookieJar.java?ref=11926e407ac52faea891fc143b47c0021794c32a",
      "patch": "@@ -143,40 +143,47 @@ private static int cookieUniqueIdComparator(ServerCookie cookie, String name, St\n     Objects.requireNonNull(name);\n \n     int v = cookie.getName().compareTo(name);\n-    if (v != 0) {\n-      return v;\n-    }\n \n     if (cookie.isFromUserAgent()) {\n       // user-agent cookies never include a path or domain, so we must assume equality\n-      return 0;\n-    }\n-\n-    if (cookie.getPath() == null) {\n-      if (path != null) {\n-        return -1;\n-      }\n-    } else if (path == null) {\n-      return 1;\n+      // just by comparing the name\n+      return v;\n     } else {\n-      v = cookie.getPath().compareTo(path);\n+      // perform the tuple check:\n+\n+      // 1. name comparison (on equals check the next parameter)\n       if (v != 0) {\n         return v;\n       }\n-    }\n \n-    if (cookie.getDomain() == null) {\n-      if (domain != null) {\n-        return -1;\n+      // 2. path comparison (on equals check the next parameter)\n+      if (cookie.getPath() == null) {\n+        if (path != null) {\n+          return -1;\n+        }\n+      } else if (path == null) {\n+        return 1;\n+      } else {\n+        v = cookie.getPath().compareTo(path);\n+        if (v != 0) {\n+          return v;\n+        }\n+      }\n+\n+      // 3. domain comparison (on equals terminate with 0)\n+      if (cookie.getDomain() == null) {\n+        if (domain != null) {\n+          return -1;\n+        }\n+      } else if (domain == null) {\n+        return 1;\n+      } else {\n+        v = cookie.getDomain().compareToIgnoreCase(domain);\n+        return v;\n       }\n-    } else if (domain == null) {\n-      return 1;\n-    } else {\n-      v = cookie.getDomain().compareToIgnoreCase(domain);\n-      return v;\n-    }\n \n-    return 0;\n+      return 0;\n+    }\n   }\n \n ",
      "parent_sha": "8e7a53925d479104d63f299e9cc07c9fe8809dee"
    }
  },
  {
    "oid": "ac0e205d409a2e29557fcf4044df04e83bc46622",
    "message": "Review feedback",
    "date": "2016-04-18T09:10:31Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/ac0e205d409a2e29557fcf4044df04e83bc46622",
    "details": {
      "sha": "1c4002391e4db13e9ebfb90117f20774bcbb5306",
      "filename": "src/main/java/io/vertx/core/dns/HostnameResolverOptions.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/ac0e205d409a2e29557fcf4044df04e83bc46622/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fdns%2FHostnameResolverOptions.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/ac0e205d409a2e29557fcf4044df04e83bc46622/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fdns%2FHostnameResolverOptions.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fdns%2FHostnameResolverOptions.java?ref=ac0e205d409a2e29557fcf4044df04e83bc46622",
      "patch": "@@ -23,7 +23,8 @@\n import java.util.List;\n \n /**\n- * Configuration options for Vert.x hostname resolver.\n+ * Configuration options for Vert.x hostname resolver. The resolver uses the local <i>hosts</i> file and performs\n+ * DNS <i>A</i> and <i>AAAA</i> queries.\n  *\n  * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n  */",
      "parent_sha": "73ff5eadcedae1230031e2a1a523c449e1e3d227"
    }
  },
  {
    "oid": "530ec73c04f40881496e4ba51db846707295940b",
    "message": "Improve Http1xTest#testTimedOutWaiterDoesntConnect",
    "date": "2018-09-02T09:15:20Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/530ec73c04f40881496e4ba51db846707295940b",
    "details": {
      "sha": "dde4908ea4d4d1b428b3a58973b6faf60cbee3f4",
      "filename": "src/test/java/io/vertx/test/core/Http1xTest.java",
      "status": "modified",
      "additions": 33,
      "deletions": 14,
      "changes": 47,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/530ec73c04f40881496e4ba51db846707295940b/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttp1xTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/530ec73c04f40881496e4ba51db846707295940b/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttp1xTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttp1xTest.java?ref=530ec73c04f40881496e4ba51db846707295940b",
      "patch": "@@ -1110,29 +1110,48 @@ public void testTimedOutWaiterDoesntConnect() throws Exception {\n     awaitLatch(firstCloseLatch);\n \n     client = vertx.createHttpClient(new HttpClientOptions().setKeepAlive(false).setMaxPoolSize(1));\n-    AtomicInteger connectCount = new AtomicInteger(0);\n+    AtomicInteger requestCount = new AtomicInteger(0);\n     // We need a net server because we need to intercept the socket connection, not just full http requests\n     NetServer server = vertx.createNetServer(new NetServerOptions().setHost(DEFAULT_HTTP_HOST).setPort(DEFAULT_HTTP_PORT));\n     server.connectHandler(socket -> {\n-      connectCount.incrementAndGet();\n-      // Delay and write a proper http response\n-      vertx.setTimer(responseDelay, time -> socket.write(\"HTTP/1.1 200 OK\\r\\nContent-Length: 2\\r\\n\\r\\nOK\"));\n+      Buffer content = Buffer.buffer();\n+      AtomicBoolean closed = new AtomicBoolean();\n+      socket.closeHandler(v -> closed.set(true));\n+      socket.handler(buff -> {\n+        content.appendBuffer(buff);\n+        if (buff.toString().endsWith(\"\\r\\n\\r\\n\")) {\n+          // Delay and write a proper http response\n+          vertx.setTimer(responseDelay, time -> {\n+            if (!closed.get()) {\n+              requestCount.incrementAndGet();\n+              socket.write(\"HTTP/1.1 200 OK\\r\\nContent-Length: 2\\r\\n\\r\\nOK\");\n+            }\n+          });\n+        }\n+      });\n     });\n \n     CountDownLatch latch = new CountDownLatch(requests);\n \n     server.listen(onSuccess(s -> {\n       for(int count = 0; count < requests; count++) {\n-        HttpClientRequest req = client.request(HttpMethod.GET, DEFAULT_HTTP_PORT, DEFAULT_HTTP_HOST, DEFAULT_TEST_URI, resp -> {\n-          resp.bodyHandler(buff -> {\n-            assertEquals(\"OK\", buff.toString());\n-            latch.countDown();\n+\n+        HttpClientRequest req = client.request(HttpMethod.GET, DEFAULT_HTTP_PORT, DEFAULT_HTTP_HOST, DEFAULT_TEST_URI);\n+        if (count % 2 == 0) {\n+          req.handler(resp -> {\n+            resp.bodyHandler(buff -> {\n+              assertEquals(\"OK\", buff.toString());\n+              latch.countDown();\n+            });\n+          });\n+          req.exceptionHandler(this::fail);\n+        } else {\n+          // Odd requests get a timeout less than the responseDelay, since we have a pool size of one and a delay all but\n+          // the first request should end up in the wait queue, the odd numbered requests should time out so we should get\n+          // (requests + 1 / 2) connect attempts\n+          req.handler(resp -> {\n+            fail(\"Was not expecting a response\");\n           });\n-        });\n-        // Odd requests get a timeout less than the responseDelay, since we have a pool size of one and a delay all but\n-        // the first request should end up in the wait queue, the odd numbered requests should time out so we should get\n-        // (requests + 1 / 2) connect attempts\n-        if (count % 2 == 1) {\n           req.setTimeout(responseDelay / 2);\n           req.exceptionHandler(ex -> {\n             latch.countDown();\n@@ -1144,7 +1163,7 @@ public void testTimedOutWaiterDoesntConnect() throws Exception {\n \n     awaitLatch(latch);\n \n-    assertEquals(\"Incorrect number of connect attempts.\", (requests + 1) / 2, connectCount.get());\n+    assertEquals(\"Incorrect number of connect attempts.\", (requests + 1) / 2, requestCount.get());\n     server.close();\n   }\n ",
      "parent_sha": "8d0db4e74cc38dec13b52b861efc34fd6da1d7ac"
    }
  },
  {
    "oid": "5d96839834fec719b2bce268bf396aa4bae6c8a3",
    "message": "Remove callback usage in VertxTest",
    "date": "2023-03-09T14:52:53Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/5d96839834fec719b2bce268bf396aa4bae6c8a3",
    "details": {
      "sha": "ecf31e4acafea70fdba417d7d83169c9b1175631",
      "filename": "src/test/java/io/vertx/core/VertxTest.java",
      "status": "modified",
      "additions": 37,
      "deletions": 35,
      "changes": 72,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/5d96839834fec719b2bce268bf396aa4bae6c8a3/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2FVertxTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/5d96839834fec719b2bce268bf396aa4bae6c8a3/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2FVertxTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2FVertxTest.java?ref=5d96839834fec719b2bce268bf396aa4bae6c8a3",
      "patch": "@@ -67,11 +67,12 @@ public void testCloseHooksCalled() {\n     vertx.addCloseHook(myCloseable1);\n     vertx.addCloseHook(myCloseable2);\n     // Now undeploy\n-    vertx.close(ar -> {\n-      assertTrue(ar.succeeded());\n-      assertEquals(2, closedCount.get());\n-      testComplete();\n-    });\n+    vertx\n+      .close()\n+      .onComplete(onSuccess(v -> {\n+        assertEquals(2, closedCount.get());\n+        testComplete();\n+      }));\n     await();\n   }\n \n@@ -82,7 +83,7 @@ class Hook implements Closeable {\n       @Override\n       public void close(Promise<Void> completion) {\n         if (closedCount.incrementAndGet() == 1) {\n-          throw new RuntimeException();\n+          throw new RuntimeException(\"Don't be afraid\");\n         } else {\n           completion.handle(Future.succeededFuture());\n         }\n@@ -92,11 +93,12 @@ public void close(Promise<Void> completion) {\n     vertx.addCloseHook(new Hook());\n     vertx.addCloseHook(new Hook());\n     // Now undeploy\n-    vertx.close(ar -> {\n-      assertTrue(ar.succeeded());\n-      assertEquals(2, closedCount.get());\n-      testComplete();\n-    });\n+    vertx\n+      .close()\n+      .onComplete(onSuccess(v -> {\n+        assertEquals(2, closedCount.get());\n+        testComplete();\n+      }));\n     await();\n   }\n \n@@ -118,11 +120,12 @@ public void close(Promise<Void> completion) {\n     vertx.addCloseHook(new Hook());\n     vertx.addCloseHook(new Hook());\n     // Now undeploy\n-    vertx.close(ar -> {\n-      assertTrue(ar.succeeded());\n-      assertEquals(2, closedCount.get());\n-      testComplete();\n-    });\n+    vertx\n+      .close()\n+      .onComplete(onSuccess(v -> {\n+        assertEquals(2, closedCount.get());\n+        testComplete();\n+      }));\n     await();\n   }\n \n@@ -178,9 +181,9 @@ public void testFinalizeHttpClient() throws Exception {\n         }\n       }\n     } finally {\n-      vertx.close(ar -> {\n-        testComplete();\n-      });\n+      vertx\n+        .close()\n+        .onComplete(onSuccess(v -> testComplete()));\n     }\n     await();\n   }\n@@ -202,7 +205,7 @@ public void testFinalizeNetClient() throws Exception {\n       vertx.addCloseHook(closeFuture);\n       closeFuture.future().onComplete(ar -> closed.set(true));\n       closeFuture = null;\n-      client.connect(1234, \"localhost\", onSuccess(so -> {}));\n+      client.connect(1234, \"localhost\");\n       WeakReference<NetClient> ref = new WeakReference<>(client);\n       client = null;\n       assertWaitUntil(() -> socketRef.get() != null);\n@@ -223,9 +226,9 @@ public void testFinalizeNetClient() throws Exception {\n         }\n       }\n     } finally {\n-      vertx.close(ar -> {\n-        testComplete();\n-      });\n+      vertx\n+        .close()\n+        .onComplete(onSuccess(v -> testComplete()));\n     }\n     await();\n   }\n@@ -247,9 +250,10 @@ public void testFinalizeSharedWorkerExecutor() throws Exception {\n       assertFalse(threads[0].isAlive());\n       assertFalse(threads[1].isAlive());\n     } finally {\n-      vertx.close(ar -> {\n-        testComplete();\n-      });\n+      vertx\n+        .close()\n+        .toCompletionStage().toCompletableFuture()\n+        .get(20, TimeUnit.SECONDS);\n     }\n   }\n \n@@ -283,9 +287,9 @@ public void testStickContextFinalization() throws Exception {\n         }\n       }\n     } finally {\n-      vertx.close(ar -> {\n-        testComplete();\n-      });\n+      vertx\n+        .close()\n+        .onComplete(onSuccess(v -> testComplete()));\n     }\n     await();\n   }\n@@ -300,9 +304,7 @@ public void testCloseVertxShouldWaitConcurrentCloseHook() throws Exception {\n     Promise<Void> p = Promise.promise();\n     fut.close(p);\n     AtomicBoolean closed = new AtomicBoolean();\n-    vertx.close(ar -> {\n-      closed.set(true);\n-    });\n+    vertx.close().onComplete(ar -> closed.set(true));\n     Thread.sleep(500);\n     assertFalse(closed.get());\n     ref.get().complete();\n@@ -370,9 +372,9 @@ public void testThreadLeak() throws Exception {\n         }\n       }\n     } finally {\n-      vertx.close(ar -> {\n-        testComplete();\n-      });\n+      vertx\n+        .close()\n+        .onComplete(onSuccess(v -> testComplete()));\n     }\n     await();\n   }",
      "parent_sha": "10432e408dd0a5fe89dbce3622f6c70c646cf1b2"
    }
  },
  {
    "oid": "55a7499eb64c5580a025edc7616f9ea1a2244461",
    "message": "ContextTest#testReentrantDispatch should restore the old classloader otherwise it might fail other tests that rely on this classloader",
    "date": "2020-11-10T20:31:30Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/55a7499eb64c5580a025edc7616f9ea1a2244461",
    "details": {
      "sha": "375cf3e6179f2de6305bf4393a0ea3a15ce8ecf7",
      "filename": "src/test/java/io/vertx/core/ContextTest.java",
      "status": "modified",
      "additions": 28,
      "deletions": 23,
      "changes": 51,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/55a7499eb64c5580a025edc7616f9ea1a2244461/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2FContextTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/55a7499eb64c5580a025edc7616f9ea1a2244461/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2FContextTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2FContextTest.java?ref=55a7499eb64c5580a025edc7616f9ea1a2244461",
      "patch": "@@ -595,31 +595,36 @@ private void testDuplicateExecuteBlockingOrdering(ContextInternal context) {\n \n   @Test\n   public void testReentrantDispatch() {\n-    ClassLoader cl = new URLClassLoader(new URL[0]);\n-    Thread.currentThread().setContextClassLoader(cl);\n-    ContextInternal ctx = (ContextInternal) vertx.getOrCreateContext();\n-    ctx.runOnContext(v1 -> {\n-      assertSame(ctx, Vertx.currentContext());\n-      assertSame(cl, Thread.currentThread().getContextClassLoader());\n-      int[] called = new int[1];\n-      BlockedThreadChecker.Task thread = (BlockedThreadChecker.Task) Thread.currentThread();\n-      long start = thread.startTime();\n-      ctx.dispatch(v2 -> {\n-        called[0]++;\n+    ClassLoader prev = Thread.currentThread().getContextClassLoader();\n+    try {\n+      ClassLoader cl = new URLClassLoader(new URL[0]);\n+      Thread.currentThread().setContextClassLoader(cl);\n+      ContextInternal ctx = (ContextInternal) vertx.getOrCreateContext();\n+      ctx.runOnContext(v1 -> {\n+        assertSame(ctx, Vertx.currentContext());\n         assertSame(cl, Thread.currentThread().getContextClassLoader());\n-        try {\n-          Thread.sleep(2);\n-        } catch (InterruptedException e) {\n-          fail(e);\n-        }\n+        int[] called = new int[1];\n+        BlockedThreadChecker.Task thread = (BlockedThreadChecker.Task) Thread.currentThread();\n+        long start = thread.startTime();\n+        ctx.dispatch(v2 -> {\n+          called[0]++;\n+          assertSame(cl, Thread.currentThread().getContextClassLoader());\n+          try {\n+            Thread.sleep(2);\n+          } catch (InterruptedException e) {\n+            fail(e);\n+          }\n+        });\n+        assertEquals(start, thread.startTime());\n+        assertEquals(1, called[0]);\n+        assertSame(ctx, Vertx.currentContext());\n+        assertSame(cl, Thread.currentThread().getContextClassLoader());\n+        testComplete();\n       });\n-      assertEquals(start, thread.startTime());\n-      assertEquals(1, called[0]);\n-      assertSame(ctx, Vertx.currentContext());\n-      assertSame(cl, Thread.currentThread().getContextClassLoader());\n-      testComplete();\n-    });\n-    await();\n+      await();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(prev);\n+    }\n   }\n \n   @Test",
      "parent_sha": "f3866ef9d1656f1f2cf579e15c059f43121f3ba1"
    }
  },
  {
    "oid": "6a56185ce15e3409b82ecc44f1940647bb624ad0",
    "message": "Head should alway be written when we get the stream",
    "date": "2017-11-05T12:51:05Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/6a56185ce15e3409b82ecc44f1940647bb624ad0",
    "details": {
      "sha": "47aab31d4021585f79b4945fb2d73902cb5b7bf9",
      "filename": "src/main/java/io/vertx/core/http/impl/HttpClientRequestImpl.java",
      "status": "modified",
      "additions": 6,
      "deletions": 31,
      "changes": 37,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/6a56185ce15e3409b82ecc44f1940647bb624ad0/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FHttpClientRequestImpl.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/6a56185ce15e3409b82ecc44f1940647bb624ad0/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FHttpClientRequestImpl.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FHttpClientRequestImpl.java?ref=6a56185ce15e3409b82ecc44f1940647bb624ad0",
      "patch": "@@ -62,7 +62,6 @@ public class HttpClientRequestImpl extends HttpClientRequestBase implements Http\n   private Handler<Void> drainHandler;\n   private Handler<HttpClientRequest> pushHandler;\n   private Handler<HttpConnection> connectionHandler;\n-  private boolean headWritten;\n   private boolean completed;\n   private Handler<Void> completionHandler;\n   private Long reset;\n@@ -286,12 +285,7 @@ public HttpClientRequest sendHead(Handler<HttpVersion> completionHandler) {\n       checkComplete();\n       checkResponseHandler();\n       if (stream != null) {\n-        if (!headWritten) {\n-          writeHead();\n-          if (completionHandler != null) {\n-            completionHandler.handle(stream.version());\n-          }\n-        }\n+        throw new IllegalStateException(\"Head already written\");\n       } else {\n         connect(completionHandler);\n       }\n@@ -716,31 +710,27 @@ private void connected(HttpClientStream stream, Handler<HttpVersion> headersComp\n \n         if (completed) {\n           // we also need to write the head so optimize this and write all out in once\n-          writeHeadWithContent(pending, true);\n-\n+          stream.writeHeadWithContent(method, rawMethod, uri, headers, hostHeader(), chunked, pending, true);\n           conn.reportBytesWritten(written);\n-\n           if (respHandler != null) {\n             this.stream.endRequest();\n           }\n         } else {\n-          writeHeadWithContent(pending, false);\n+          stream.writeHeadWithContent(method, rawMethod, uri, headers, hostHeader(), chunked, pending, false);\n           if (headersCompletionHandler != null) {\n             headersCompletionHandler.handle(stream.version());\n           }\n         }\n       } else {\n         if (completed) {\n           // we also need to write the head so optimize this and write all out in once\n-          writeHeadWithContent(null, true);\n-\n+          stream.writeHeadWithContent(method, rawMethod, uri, headers, hostHeader(), chunked, null, true);\n           conn.reportBytesWritten(written);\n-\n           if (respHandler != null) {\n             this.stream.endRequest();\n           }\n         } else {\n-          writeHead();\n+          stream.writeHead(method, rawMethod, uri, headers, hostHeader(), chunked);\n           if (headersCompletionHandler != null) {\n             headersCompletionHandler.handle(stream.version());\n           }\n@@ -757,17 +747,6 @@ private boolean contentLengthSet() {\n     return headers != null && headers().contains(CONTENT_LENGTH);\n   }\n \n-  private void writeHead() {\n-    stream.writeHead(method, rawMethod, uri, headers, hostHeader(), chunked);\n-    headWritten = true;\n-  }\n-\n-  private void writeHeadWithContent(ByteBuf buf, boolean end) {\n-    stream.writeHeadWithContent(method, rawMethod, uri, headers, hostHeader(), chunked, buf, end);\n-    headWritten = true;\n-  }\n-\n-\n   @Override\n   public void end(String chunk) {\n     end(Buffer.buffer(chunk));\n@@ -860,11 +839,7 @@ private void _write(ByteBuf buff, boolean end) {\n       }\n       connect(null);\n     } else {\n-      if (!headWritten) {\n-        writeHeadWithContent(buff, end);\n-      } else {\n-        stream.writeBuffer(buff, end);\n-      }\n+      stream.writeBuffer(buff, end);\n       if (end) {\n         stream.connection().reportBytesWritten(written);\n         if (respHandler != null) {",
      "parent_sha": "237eaa7510e23e92b6049f4e344c8487b39e5277"
    }
  },
  {
    "oid": "901db7495db25b89e6031aa2e0095dae1756d322",
    "message": "Fix possible NPE in FakeClusterManager\n\nSigned-off-by: Thomas Segismont <tsegismont@gmail.com>",
    "date": "2020-05-05T12:56:37Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/901db7495db25b89e6031aa2e0095dae1756d322",
    "details": {
      "sha": "76d971ef5982d68c59f2657a7fd17b08bbea5084",
      "filename": "src/test/java/io/vertx/test/fakecluster/FakeClusterManager.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/901db7495db25b89e6031aa2e0095dae1756d322/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Ffakecluster%2FFakeClusterManager.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/901db7495db25b89e6031aa2e0095dae1756d322/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Ffakecluster%2FFakeClusterManager.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Ffakecluster%2FFakeClusterManager.java?ref=901db7495db25b89e6031aa2e0095dae1756d322",
      "patch": "@@ -206,7 +206,8 @@ public void register(RegistrationInfo registrationInfo, Handler<AsyncResult<Void\n   @Override\n   public void unregister(RegistrationInfo registrationInfo, Handler<AsyncResult<Void>> completionHandler) {\n     Future<Void> result;\n-    if (registrations.get(registrationInfo.getAddress()).remove(registrationInfo)) {\n+    List<RegistrationInfo> infos = registrations.get(registrationInfo.getAddress());\n+    if (infos != null && infos.remove(registrationInfo)) {\n       result = Future.succeededFuture();\n     } else {\n       result = Future.failedFuture(\"Registration not found\");",
      "parent_sha": "c1b2d9ff32c4ae54b5eb6ab805f11cc716b9e2aa"
    }
  },
  {
    "oid": "9d3fc43adc185d3de257165d14c1c6c5c43066d2",
    "message": "Improve VertxOptions constants",
    "date": "2019-07-31T07:12:34Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/9d3fc43adc185d3de257165d14c1c6c5c43066d2",
    "details": {
      "sha": "f67c70ff37dea2bb1ab9cff8eb72c4f1f0794120",
      "filename": "src/main/java/io/vertx/core/VertxOptions.java",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/9d3fc43adc185d3de257165d14c1c6c5c43066d2/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2FVertxOptions.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/9d3fc43adc185d3de257165d14c1c6c5c43066d2/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2FVertxOptions.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2FVertxOptions.java?ref=9d3fc43adc185d3de257165d14c1c6c5c43066d2",
      "patch": "@@ -95,43 +95,43 @@ public class VertxOptions {\n    * @deprecated as of 3.7, use {@link EventBusOptions#DEFAULT_CLUSTER_PING_INTERVAL} instead\n    */\n   @Deprecated\n-  public static final long DEFAULT_CLUSTER_PING_INTERVAL = 20000;\n+  public static final long DEFAULT_CLUSTER_PING_INTERVAL = TimeUnit.SECONDS.toMillis(20);\n \n   /**\n    * The default value of cluster ping reply interval = 20000 ms.\n    *\n    * @deprecated as of 3.7, use {@link EventBusOptions#DEFAULT_CLUSTER_PING_REPLY_INTERVAL} instead\n    */\n   @Deprecated\n-  public static final long DEFAULT_CLUSTER_PING_REPLY_INTERVAL = 20000;\n+  public static final long DEFAULT_CLUSTER_PING_REPLY_INTERVAL = TimeUnit.SECONDS.toMillis(20);\n \n   /**\n    * The default value of blocked thread check interval = 1000 ms.\n    */\n-  public static final long DEFAULT_BLOCKED_THREAD_CHECK_INTERVAL = 1000;\n+  public static final long DEFAULT_BLOCKED_THREAD_CHECK_INTERVAL = TimeUnit.SECONDS.toMillis(1);;\n \n   /**\n-   * The default value of blocked thread check interval unit = TimeUnit.NANOSECONDS\n+   * The default value of blocked thread check interval unit = {@link TimeUnit#MILLISECONDS}\n    */\n   public static final TimeUnit DEFAULT_BLOCKED_THREAD_CHECK_INTERVAL_UNIT = TimeUnit.MILLISECONDS;\n \n   /**\n    * The default value of max event loop execute time = 2000000000 ns (2 seconds)\n    */\n-  public static final long DEFAULT_MAX_EVENT_LOOP_EXECUTE_TIME = 2L * 1000 * 1000000;\n+  public static final long DEFAULT_MAX_EVENT_LOOP_EXECUTE_TIME = TimeUnit.SECONDS.toNanos(2);\n \n   /**\n-   * The default value of max event loop execute time unit = TimeUnit.NANOSECONDS\n+   * The default value of max event loop execute time unit = {@link TimeUnit#NANOSECONDS}\n    */\n   public static final TimeUnit DEFAULT_MAX_EVENT_LOOP_EXECUTE_TIME_UNIT = TimeUnit.NANOSECONDS;\n \n   /**\n    * The default value of max worker execute time = 60000000000 ns (60 seconds)\n    */\n-  public static final long DEFAULT_MAX_WORKER_EXECUTE_TIME = 60L * 1000 * 1000000;\n+  public static final long DEFAULT_MAX_WORKER_EXECUTE_TIME = TimeUnit.SECONDS.toNanos(60);\n \n   /**\n-   * The default value of max worker execute time unit = TimeUnit.NANOSECONDS\n+   * The default value of max worker execute time unit = {@link TimeUnit#NANOSECONDS}\n    */\n   public static final TimeUnit DEFAULT_MAX_WORKER_EXECUTE_TIME_UNIT = TimeUnit.NANOSECONDS;\n \n@@ -163,7 +163,7 @@ public class VertxOptions {\n   private static final long DEFAULT_WARNING_EXCEPTION_TIME = TimeUnit.SECONDS.toNanos(5);\n \n   /**\n-   * The default value of warning exception time unit = TimeUnit.NANOSECONDS\n+   * The default value of warning exception time unit = {@link TimeUnit#NANOSECONDS}\n    */\n   public static final TimeUnit DEFAULT_WARNING_EXCEPTION_TIME_UNIT = TimeUnit.NANOSECONDS;\n ",
      "parent_sha": "8524edce817e587d87f94d3a63101929bd476db7"
    }
  },
  {
    "oid": "06fbf2aace008749c7546543d6d60847f07c86e9",
    "message": "Fixed io.vertx.test.core.Http1xTest.testPauseResumeClientResponse\n\n      io.netty.channel.AbstractChannel$AnnotatedConnectException: Connection refused: localhost/127.0.0.1:10000\n\nSigned-off-by: Thomas Segismont <tsegismont@gmail.com>",
    "date": "2017-03-16T15:56:12Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/06fbf2aace008749c7546543d6d60847f07c86e9",
    "details": {
      "sha": "f1ba44090c87cb3c5486ba8e3fbdcc849753dcd7",
      "filename": "src/test/java/io/vertx/test/core/Http1xTest.java",
      "status": "modified",
      "additions": 69,
      "deletions": 27,
      "changes": 96,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/06fbf2aace008749c7546543d6d60847f07c86e9/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttp1xTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/06fbf2aace008749c7546543d6d60847f07c86e9/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttp1xTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttp1xTest.java?ref=06fbf2aace008749c7546543d6d60847f07c86e9",
      "patch": "@@ -17,19 +17,60 @@\n package io.vertx.test.core;\n \n import io.netty.handler.codec.TooLongFrameException;\n-import io.vertx.core.*;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Context;\n+import io.vertx.core.DeploymentOptions;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.VertxException;\n import io.vertx.core.buffer.Buffer;\n-import io.vertx.core.http.*;\n+import io.vertx.core.http.ConnectionPoolTooBusyException;\n+import io.vertx.core.http.Http2Settings;\n+import io.vertx.core.http.HttpClient;\n+import io.vertx.core.http.HttpClientOptions;\n+import io.vertx.core.http.HttpClientRequest;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpServer;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.http.HttpServerRequest;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.http.HttpVersion;\n import io.vertx.core.http.impl.HttpClientRequestImpl;\n-import io.vertx.core.impl.*;\n+import io.vertx.core.impl.ConcurrentHashSet;\n+import io.vertx.core.impl.ContextImpl;\n+import io.vertx.core.impl.VertxInternal;\n import io.vertx.core.json.JsonArray;\n import io.vertx.core.json.JsonObject;\n-import io.vertx.core.net.*;\n+import io.vertx.core.net.JdkSSLEngineOptions;\n+import io.vertx.core.net.JksOptions;\n+import io.vertx.core.net.KeyCertOptions;\n+import io.vertx.core.net.NetClient;\n+import io.vertx.core.net.NetClientOptions;\n+import io.vertx.core.net.NetServer;\n+import io.vertx.core.net.NetServerOptions;\n+import io.vertx.core.net.NetSocket;\n+import io.vertx.core.net.NetworkOptions;\n+import io.vertx.core.net.OpenSSLEngineOptions;\n+import io.vertx.core.net.PemKeyCertOptions;\n+import io.vertx.core.net.PemTrustOptions;\n+import io.vertx.core.net.PfxOptions;\n+import io.vertx.core.net.ProxyOptions;\n+import io.vertx.core.net.ProxyType;\n+import io.vertx.core.net.SSLEngineOptions;\n+import io.vertx.core.net.TrustOptions;\n import io.vertx.core.parsetools.RecordParser;\n import io.vertx.core.streams.Pump;\n import org.junit.Test;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.CountDownLatch;\n@@ -2025,31 +2066,32 @@ public void testPauseResumeClientResponse() {\n       }\n       request.response().end();\n     });\n-    server.listen(10000);\n-    HttpClient httpClient = vertx.createHttpClient();\n-    HttpClientRequest clientRequest = httpClient.get(10000, \"localhost\", \"/\");\n-    clientRequest.handler(resp -> {\n-      resp.handler(b -> {\n-        readBuffer.appendBuffer(b);\n-        for (int i = 0; i < 64; i++) {\n-          vertx.setTimer(1, n -> {\n-            try {\n-              Thread.sleep(0);\n-            } catch (InterruptedException e) {\n-              e.printStackTrace();\n-            }\n+    server.listen(10000, onSuccess(hs -> {\n+      HttpClient httpClient = vertx.createHttpClient();\n+      HttpClientRequest clientRequest = httpClient.get(10000, \"localhost\", \"/\");\n+      clientRequest.handler(resp -> {\n+        resp.handler(b -> {\n+          readBuffer.appendBuffer(b);\n+          for (int i = 0; i < 64; i++) {\n+            vertx.setTimer(1, n -> {\n+              try {\n+                Thread.sleep(0);\n+              } catch (InterruptedException e) {\n+                e.printStackTrace();\n+              }\n+            });\n+          }\n+          ;\n+          resp.endHandler(v -> {\n+            byte[] expectedData = buffer.getBytes();\n+            byte[] actualData = readBuffer.getBytes();\n+            assertTrue(Arrays.equals(expectedData, actualData));\n+            testComplete();\n           });\n-        }\n-        ;\n-        resp.endHandler(v -> {\n-          byte[] expectedData = buffer.getBytes();\n-          byte[] actualData = readBuffer.getBytes();\n-          assertTrue(Arrays.equals(expectedData, actualData));\n-          testComplete();\n         });\n       });\n-    });\n-    clientRequest.end();\n+      clientRequest.end();\n+    }));\n     await();\n   }\n ",
      "parent_sha": "09d67be9cb022136d5b6912adbbe9869e3514a8e"
    }
  },
  {
    "oid": "0673e674077d29397a4c0712401634628f63a707",
    "message": "Add a setter TCPSSLOptions#setEnabledSecureTransportProtocols",
    "date": "2018-01-24T12:07:39Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/0673e674077d29397a4c0712401634628f63a707",
    "details": {
      "sha": "73aa5e0135627bef0842a9a200a6e1c5ff2d09c2",
      "filename": "src/main/java/io/vertx/core/net/TCPSSLOptions.java",
      "status": "modified",
      "additions": 11,
      "deletions": 1,
      "changes": 12,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/0673e674077d29397a4c0712401634628f63a707/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2FTCPSSLOptions.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/0673e674077d29397a4c0712401634628f63a707/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2FTCPSSLOptions.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2FTCPSSLOptions.java?ref=0673e674077d29397a4c0712401634628f63a707",
      "patch": "@@ -150,7 +150,6 @@ public TCPSSLOptions(TCPSSLOptions other) {\n   public TCPSSLOptions(JsonObject json) {\n     super(json);\n     init();\n-    enabledSecureTransportProtocols.clear();\n     TCPSSLOptionsConverter.fromJson(json ,this);\n   }\n \n@@ -564,6 +563,17 @@ public TCPSSLOptions setOpenSslEngineOptions(OpenSSLEngineOptions sslEngineOptio\n     return setSslEngineOptions(sslEngineOptions);\n   }\n \n+  /**\n+   * Sets the list of enabled SSL/TLS protocols.\n+   *\n+   * @param enabledSecureTransportProtocols  the SSL/TLS protocols to enable\n+   * @return a reference to this, so the API can be used fluently\n+   */\n+  public TCPSSLOptions setEnabledSecureTransportProtocols(Set<String> enabledSecureTransportProtocols) {\n+    this.enabledSecureTransportProtocols = enabledSecureTransportProtocols;\n+    return this;\n+  }\n+\n   /**\n    * Add an enabled SSL/TLS protocols, appended to the ordered protocols.\n    *",
      "parent_sha": "d10129f0ec25009e40b84fa13bfd23d58ead3d9c"
    }
  },
  {
    "oid": "762c58c8fa05b95ea0dada28438670650af06cc9",
    "message": "Missing synchronized on creating new connection",
    "date": "2015-08-27T07:54:56Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/762c58c8fa05b95ea0dada28438670650af06cc9",
    "details": {
      "sha": "072332aa266b8d60675260df4e5343632f3b1eb2",
      "filename": "src/main/java/io/vertx/core/http/impl/ConnectionManager.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/762c58c8fa05b95ea0dada28438670650af06cc9/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FConnectionManager.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/762c58c8fa05b95ea0dada28438670650af06cc9/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FConnectionManager.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FConnectionManager.java?ref=762c58c8fa05b95ea0dada28438670650af06cc9",
      "patch": "@@ -152,7 +152,9 @@ private void checkReuseConnection(ClientConnection conn) {\n     private void createNewConnection(Handler<ClientConnection> handler, Handler<Throwable> connectionExceptionHandler, ContextImpl context) {\n       connCount++;\n       connect(address.host, address.port, conn -> {\n-        allConnections.add(conn);\n+        synchronized (ConnectionManager.this) {\n+          allConnections.add(conn);\n+        }\n         handler.handle(conn);\n       }, connectionExceptionHandler, context, this);\n     }",
      "parent_sha": "66d72cae01181e0fafdda3f87bd297364adaff8b"
    }
  },
  {
    "oid": "0ffb8e147368010c0c047e89c0fe88d6d5d41005",
    "message": "Fix wrong NetSocket StartTLS test",
    "date": "2016-03-08T21:28:28Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/0ffb8e147368010c0c047e89c0fe88d6d5d41005",
    "details": {
      "sha": "9afcb1af0f51419d80cef5a5047ccbaef803b356",
      "filename": "src/test/java/io/vertx/test/core/NetTest.java",
      "status": "modified",
      "additions": 28,
      "deletions": 24,
      "changes": 52,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/0ffb8e147368010c0c047e89c0fe88d6d5d41005/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FNetTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/0ffb8e147368010c0c047e89c0fe88d6d5d41005/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FNetTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FNetTest.java?ref=0ffb8e147368010c0c047e89c0fe88d6d5d41005",
      "patch": "@@ -1111,7 +1111,9 @@ void testTLS(boolean clientCert, boolean clientTrust,\n         socket.write(buff); // echo the data\n         if (startTLS && !upgradedServer.get()) {\n           assertFalse(socket.isSsl());\n-          socket.upgradeToSsl(v -> assertTrue(socket.isSsl()));\n+          socket.upgradeToSsl(v -> {\n+            assertTrue(socket.isSsl());\n+          });\n           upgradedServer.set(true);\n         } else {\n           assertTrue(socket.isSsl());\n@@ -1123,18 +1125,18 @@ void testTLS(boolean clientCert, boolean clientTrust,\n       NetClientOptions clientOptions = new NetClientOptions();\n       if (!startTLS) {\n         clientOptions.setSsl(true);\n-        if (clientTrustAll) {\n-          clientOptions.setTrustAll(true);\n-        }\n-        if (clientTrust) {\n-          clientOptions.setTrustStoreOptions(new JksOptions().setPath(findFileOnClasspath(\"tls/client-truststore.jks\")).setPassword(\"wibble\"));\n-        }\n-        if (clientCert) {\n-          clientOptions.setKeyStoreOptions(new JksOptions().setPath(findFileOnClasspath(\"tls/client-keystore.jks\")).setPassword(\"wibble\"));\n-        }\n-        for (String suite: enabledCipherSuites) {\n-          clientOptions.addEnabledCipherSuite(suite);\n-        }\n+      }\n+      if (clientTrustAll) {\n+        clientOptions.setTrustAll(true);\n+      }\n+      if (clientTrust) {\n+        clientOptions.setTrustStoreOptions(new JksOptions().setPath(findFileOnClasspath(\"tls/client-truststore.jks\")).setPassword(\"wibble\"));\n+      }\n+      if (clientCert) {\n+        clientOptions.setKeyStoreOptions(new JksOptions().setPath(findFileOnClasspath(\"tls/client-keystore.jks\")).setPassword(\"wibble\"));\n+      }\n+      for (String suite: enabledCipherSuites) {\n+        clientOptions.addEnabledCipherSuite(suite);\n       }\n       client = vertx.createNetClient(clientOptions);\n       client.connect(4043, \"localhost\", ar2 -> {\n@@ -1145,24 +1147,32 @@ void testTLS(boolean clientCert, boolean clientTrust,\n           }\n           final int numChunks = 100;\n           final int chunkSize = 100;\n+          final List<Buffer> toSend = new ArrayList<>();\n+          final Buffer expected = Buffer.buffer();\n+          for (int i = 0; i< numChunks;i++) {\n+            Buffer chunk = TestUtils.randomBuffer(chunkSize);\n+            toSend.add(chunk);\n+            expected.appendBuffer(chunk);\n+          }\n           final Buffer received = Buffer.buffer();\n-          final Buffer sent = Buffer.buffer();\n           final NetSocket socket = ar2.result();\n \n           final AtomicBoolean upgradedClient = new AtomicBoolean();\n           socket.handler(buffer -> {\n+            System.out.println(\"got echo \" + buffer.length());\n             received.appendBuffer(buffer);\n-            if (received.length() == sent.length()) {\n-              assertEquals(sent, received);\n+            if (received.length() == expected.length()) {\n+              assertEquals(expected, received);\n               testComplete();\n             }\n             if (startTLS && !upgradedClient.get()) {\n+              upgradedClient.set(true);\n               assertFalse(socket.isSsl());\n               socket.upgradeToSsl(v -> {\n                 assertTrue(socket.isSsl());\n                 // Now send the rest\n                 for (int i = 1; i < numChunks; i++) {\n-                  sendBuffer(socket, sent, chunkSize);\n+                  socket.write(toSend.get(i));\n                 }\n               });\n             } else {\n@@ -1173,7 +1183,7 @@ void testTLS(boolean clientCert, boolean clientTrust,\n           //Now send some data\n           int numToSend = startTLS ? 1 : numChunks;\n           for (int i = 0; i < numToSend; i++) {\n-            sendBuffer(socket, sent, chunkSize);\n+            socket.write(toSend.get(i));\n           }\n         } else {\n           if (shouldPass) {\n@@ -1187,12 +1197,6 @@ void testTLS(boolean clientCert, boolean clientTrust,\n     await();\n   }\n \n-  void sendBuffer(NetSocket socket, Buffer sent, int chunkSize) {\n-    Buffer buff = TestUtils.randomBuffer(chunkSize);\n-    sent.appendBuffer(buff);\n-    socket.write(buff);\n-  }\n-\n   @Test\n   // Need to:\n   // sudo sysctl -w net.core.somaxconn=10000",
      "parent_sha": "7e391ea6a76ed1ad96e58229bfdb8e44a1c62783"
    }
  },
  {
    "oid": "940f187773fdac4c7771bac8226bffe530a5d9cf",
    "message": "Incorrect VertxHttp2Stream checkNextTick implementation - fixes #2457",
    "date": "2018-05-19T14:40:29Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/940f187773fdac4c7771bac8226bffe530a5d9cf",
    "details": {
      "sha": "a55fd20d3a45af6e0103b62252f1ff46f0e9eeeb",
      "filename": "src/main/java/io/vertx/core/http/impl/VertxHttp2Stream.java",
      "status": "modified",
      "additions": 22,
      "deletions": 13,
      "changes": 35,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/940f187773fdac4c7771bac8226bffe530a5d9cf/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FVertxHttp2Stream.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/940f187773fdac4c7771bac8226bffe530a5d9cf/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FVertxHttp2Stream.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FVertxHttp2Stream.java?ref=940f187773fdac4c7771bac8226bffe530a5d9cf",
      "patch": "@@ -36,6 +36,7 @@ abstract class VertxHttp2Stream<C extends Http2ConnectionBase> {\n   private final ArrayDeque<Buffer> pending = new ArrayDeque<>(8);\n   private boolean paused;\n   private boolean ended;\n+  private boolean sentCheck;\n   private MultiMap trailers;\n   private boolean writable;\n \n@@ -64,7 +65,7 @@ boolean onDataRead(Buffer data) {\n           return true;\n         } else {\n           pending.add(data);\n-          checkNextTick(null);\n+          checkNextTick();\n         }\n       } else {\n         pending.add(data);\n@@ -97,18 +98,26 @@ void onEnd(MultiMap map) {\n   /**\n    * Check if paused buffers must be handled to the reader, this must be called from event loop.\n    */\n-  private void checkNextTick(Void v) {\n-    synchronized (conn) {\n-      if (!paused) {\n-        Buffer buf = pending.poll();\n-        conn.handler.consume(stream, buf.length());\n-        handleData(buf);\n-        if (pending.size() > 0) {\n-          vertx.runOnContext(this::checkNextTick);\n-        } else if (ended) {\n-          handleEnd(trailers);\n+  private void checkNextTick() {\n+    if (!paused && pending.size() > 0 && !sentCheck) {\n+      sentCheck = true;\n+      context.runOnContext(v1 -> {\n+        synchronized (conn) {\n+          sentCheck = false;\n+          if (!paused) {\n+            Buffer buf = pending.poll();\n+            conn.handler.consume(stream, buf.length());\n+            handleData(buf);\n+            if (pending.isEmpty()) {\n+              if (ended) {\n+                handleEnd(trailers);\n+              }\n+            } else {\n+              checkNextTick();\n+            }\n+          }\n         }\n-      }\n+      });\n     }\n   }\n \n@@ -122,7 +131,7 @@ public void doPause() {\n \n   public void doResume() {\n     paused = false;\n-    context.runOnContext(this::checkNextTick);\n+    checkNextTick();\n   }\n \n   boolean isNotWritable() {",
      "parent_sha": "a7f115b6cad5a1bf5203b406f31cfb06cfe17ec5"
    }
  },
  {
    "oid": "6886e9389095a03df31c9e6bf7b9e1f095824b9e",
    "message": "Remove callbacks from ClusteredEventBusTestBase",
    "date": "2023-03-12T15:15:07Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/6886e9389095a03df31c9e6bf7b9e1f095824b9e",
    "details": {
      "sha": "f6eb821326ddc09fe678c18af2834978f81ebf09",
      "filename": "src/test/java/io/vertx/core/eventbus/ClusteredEventBusTestBase.java",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/6886e9389095a03df31c9e6bf7b9e1f095824b9e/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2FClusteredEventBusTestBase.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/6886e9389095a03df31c9e6bf7b9e1f095824b9e/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2FClusteredEventBusTestBase.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2FClusteredEventBusTestBase.java?ref=6886e9389095a03df31c9e6bf7b9e1f095824b9e",
      "patch": "@@ -129,7 +129,7 @@ protected <T, R> void testReply(T val, R received, Consumer<R> consumer, Deliver\n     });\n     reg.completionHandler(ar -> {\n       assertTrue(ar.succeeded());\n-      vertices[0].eventBus().request(ADDRESS1, str, onSuccess((Message<R> reply) -> {\n+      vertices[0].eventBus().<R>request(ADDRESS1, str).onComplete(onSuccess((Message<R> reply) -> {\n         if (consumer == null) {\n           assertTrue(reply.isSend());\n           assertEquals(received, reply.body());\n@@ -256,21 +256,21 @@ public void registrationsUpdated(RegistrationUpdateEvent event) {\n     startNodes(options.get(), options.get());\n     MessageConsumer<Object> consumer = vertices[0].eventBus().consumer(\"foo\", msg -> msg.reply(msg.body()));\n     consumer.completionHandler(onSuccess(reg -> {\n-      vertices[0].eventBus().request(\"foo\", \"echo\", onSuccess(reply1 -> {\n+      vertices[0].eventBus().request(\"foo\", \"echo\").onComplete(onSuccess(reply1 -> {\n         assertEquals(\"echo\", reply1.body());\n-        vertices[1].eventBus().request(\"foo\", \"echo\", onSuccess(reply2 -> {\n+        vertices[1].eventBus().request(\"foo\", \"echo\").onComplete(onSuccess(reply2 -> {\n           assertEquals(\"echo\", reply1.body());\n-          consumer.unregister(onSuccess(unreg -> {\n+          consumer.unregister().onComplete(onSuccess(unreg -> {\n             updateLatch.countDown();\n           }));\n         }));\n       }));\n     }));\n     awaitLatch(updateLatch);\n-    vertices[1].eventBus().request(\"foo\", \"echo\", onFailure(fail1 -> {\n+    vertices[1].eventBus().request(\"foo\", \"echo\").onComplete(onFailure(fail1 -> {\n       assertThat(fail1, is(instanceOf(ReplyException.class)));\n       assertEquals(ReplyFailure.NO_HANDLERS, ((ReplyException) fail1).failureType());\n-      vertices[0].eventBus().request(\"foo\", \"echo\", onFailure(fail2 -> {\n+      vertices[0].eventBus().request(\"foo\", \"echo\").onComplete(onFailure(fail2 -> {\n         assertThat(fail2, is(instanceOf(ReplyException.class)));\n         assertEquals(ReplyFailure.NO_HANDLERS, ((ReplyException) fail2).failureType());\n         testComplete();\n@@ -302,7 +302,7 @@ public void start(Promise<Void> startPromise) throws Exception {\n \n       @Override\n       public void stop(Promise<Void> stopPromise) throws Exception {\n-        vertx.eventBus().<String>request(pingClientAddress, \"ping\", onSuccess(msg -> {\n+        vertx.eventBus().<String>request(pingClientAddress, \"ping\").onComplete(onSuccess(msg -> {\n           assertEquals(\"pong\", msg.body());\n           count.incrementAndGet();\n           vertx.setPeriodic(10, l -> {\n@@ -316,10 +316,10 @@ public void stop(Promise<Void> stopPromise) throws Exception {\n \n     waitFor(2);\n \n-    vertices[0].deployVerticle(new MyVerticle(\"foo\", \"bar\"), onSuccess(id1 -> {\n-      vertices[1].deployVerticle(new MyVerticle(\"bar\", \"foo\"), onSuccess(id2 -> {\n-        vertices[0].close(onSuccess(v -> complete()));\n-        vertices[1].close(onSuccess(v -> complete()));\n+    vertices[0].deployVerticle(new MyVerticle(\"foo\", \"bar\")).onComplete(onSuccess(id1 -> {\n+      vertices[1].deployVerticle(new MyVerticle(\"bar\", \"foo\")).onComplete(onSuccess(id2 -> {\n+        vertices[0].close().onComplete(onSuccess(v -> complete()));\n+        vertices[1].close().onComplete(onSuccess(v -> complete()));\n       }));\n     }));\n ",
      "parent_sha": "8d23638d1238716418ea9cd0e03bd94c6dbde382"
    }
  },
  {
    "oid": "bddb72634c5ecb266c27f810ccd51b3baa98f00f",
    "message": "Set wire protocol version = 2\n\nThis is the second part of #3406\n\nSigned-off-by: Thomas Segismont <tsegismont@gmail.com>",
    "date": "2020-10-07T11:24:08Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/bddb72634c5ecb266c27f810ccd51b3baa98f00f",
    "details": {
      "sha": "29e3d4d800d992a8908ef30de2079ba2481196e9",
      "filename": "src/main/java/io/vertx/core/eventbus/impl/clustered/ClusteredMessage.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/bddb72634c5ecb266c27f810ccd51b3baa98f00f/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2Fimpl%2Fclustered%2FClusteredMessage.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/bddb72634c5ecb266c27f810ccd51b3baa98f00f/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2Fimpl%2Fclustered%2FClusteredMessage.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2Fimpl%2Fclustered%2FClusteredMessage.java?ref=bddb72634c5ecb266c27f810ccd51b3baa98f00f",
      "patch": "@@ -34,7 +34,7 @@ public class ClusteredMessage<U, V> extends MessageImpl<U, V> {\n \n   private static final Logger log = LoggerFactory.getLogger(ClusteredMessage.class);\n \n-  private static final byte WIRE_PROTOCOL_VERSION = 1;\n+  private static final byte WIRE_PROTOCOL_VERSION = 2;\n \n   private String sender;\n   private String repliedTo;",
      "parent_sha": "9b6ce88fa2e8490da09c2602406673e6e6b9b264"
    }
  },
  {
    "oid": "aaa9aac56b688c3d8f2cd9d6d3d07d907b6bc0b7",
    "message": "Improve NetBandwidthLimitedTest which seems to have issues with CI",
    "date": "2024-12-10T09:42:59Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/aaa9aac56b688c3d8f2cd9d6d3d07d907b6bc0b7",
    "details": {
      "sha": "8d71312233cc4116a8b014ff334bcb78db23032d",
      "filename": "vertx-core/src/test/java/io/vertx/tests/net/NetBandwidthLimitingTest.java",
      "status": "modified",
      "additions": 59,
      "deletions": 48,
      "changes": 107,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/aaa9aac56b688c3d8f2cd9d6d3d07d907b6bc0b7/vertx-core%2Fsrc%2Ftest%2Fjava%2Fio%2Fvertx%2Ftests%2Fnet%2FNetBandwidthLimitingTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/aaa9aac56b688c3d8f2cd9d6d3d07d907b6bc0b7/vertx-core%2Fsrc%2Ftest%2Fjava%2Fio%2Fvertx%2Ftests%2Fnet%2FNetBandwidthLimitingTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/vertx-core%2Fsrc%2Ftest%2Fjava%2Fio%2Fvertx%2Ftests%2Fnet%2FNetBandwidthLimitingTest.java?ref=aaa9aac56b688c3d8f2cd9d6d3d07d907b6bc0b7",
      "patch": "@@ -15,12 +15,15 @@\n import java.io.File;\n import java.io.FileOutputStream;\n import java.io.OutputStreamWriter;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n \n import io.vertx.core.net.*;\n-import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Rule;\n@@ -31,7 +34,6 @@\n import io.vertx.core.DeploymentOptions;\n import io.vertx.core.Future;\n import io.vertx.core.Promise;\n-import io.vertx.core.Vertx;\n import io.vertx.core.buffer.Buffer;\n import io.vertx.test.core.TestUtils;\n import io.vertx.test.core.VertxTestBase;\n@@ -49,6 +51,7 @@ public class NetBandwidthLimitingTest extends VertxTestBase {\n \n   private SocketAddress testAddress;\n   private NetClient client = null;\n+  private final List<NetServer> servers = Collections.synchronizedList(new ArrayList<>());\n \n   @Before\n   public void setUp() throws Exception {\n@@ -63,12 +66,22 @@ public void setUp() throws Exception {\n     client = vertx.createNetClient();\n   }\n \n-  @After\n-  public void after() throws InterruptedException {\n-    CountDownLatch countDownLatch = new CountDownLatch(2);\n-    client.close().onComplete(v -> countDownLatch.countDown());\n-    vertx.close().onComplete(v -> countDownLatch.countDown());\n-    awaitLatch(countDownLatch);\n+  @Override\n+  protected void tearDown() throws Exception {\n+    if (client != null) {\n+      try {\n+        client.close().await();\n+      } finally {\n+        client = null;\n+      }\n+    }\n+    while (!servers.isEmpty()) {\n+      Iterator<NetServer> it = servers.iterator();\n+      NetServer server = it.next();\n+      it.remove();\n+      server.close().await();\n+    }\n+    super.tearDown();\n   }\n \n   @Test\n@@ -77,7 +90,7 @@ public void sendBufferThrottled() {\n \n     Buffer expected = TestUtils.randomBuffer(64 * 1024 * 4);\n     Buffer received = Buffer.buffer();\n-    NetServer server = netServer(vertx);\n+    NetServer server = netServer();\n     server.connectHandler(sock -> {\n       sock.handler(buf -> {\n         sock.write(expected);\n@@ -112,7 +125,7 @@ public void sendFileIsThrottled() throws Exception {\n     File file = setupFile(fDir.toString(), \"some-file.txt\", content);\n     Buffer expected = Buffer.buffer(content);\n     Buffer received = Buffer.buffer();\n-    NetServer server = netServer(vertx);\n+    NetServer server = netServer();\n     server.connectHandler(sock -> {\n       sock.handler(buf -> {\n         sock.sendFile(file.getAbsolutePath());\n@@ -144,7 +157,7 @@ public void dataUploadIsThrottled() {\n \n     Buffer expected = TestUtils.randomBuffer(64 * 1024 * 4);\n     Buffer received = Buffer.buffer();\n-    NetServer server = netServer(vertx);\n+    NetServer server = netServer();\n     server.connectHandler(sock -> {\n       sock.handler(buff -> {\n         received.appendBuffer(buff);\n@@ -159,14 +172,12 @@ public void dataUploadIsThrottled() {\n       // Send some data to the client to trigger the buffer write\n       sock.write(\"foo\");\n     });\n-    Future<NetServer> result = server.listen(testAddress);\n-    result.onComplete(onSuccess(resp -> {\n-      Future<NetSocket> clientConnect = client.connect(testAddress);\n-      clientConnect.onComplete(onSuccess(sock -> {\n-        sock.handler(buf -> {\n-          sock.write(expected);\n-        });\n-      }));\n+    server.listen(testAddress).await();\n+    Future<NetSocket> clientConnect = client.connect(testAddress);\n+    clientConnect.onComplete(onSuccess(sock -> {\n+      sock.handler(buf -> {\n+        sock.write(expected);\n+      });\n     }));\n     await();\n   }\n@@ -180,7 +191,7 @@ public void fileUploadIsThrottled() throws Exception {\n     File file = setupFile(fDir.toString(), \"some-file.txt\", content);\n     Buffer expected = Buffer.buffer(content);\n     Buffer received = Buffer.buffer();\n-    NetServer server = netServer(vertx);\n+    NetServer server = netServer();\n     server.connectHandler(sock -> {\n       sock.handler(buff -> {\n         received.appendBuffer(buff);\n@@ -195,14 +206,12 @@ public void fileUploadIsThrottled() throws Exception {\n       // Send some data to the client to trigger the sendfile\n       sock.write(\"foo\");\n     });\n-    Future<NetServer> result = server.listen(testAddress);\n-    result.onComplete(onSuccess(resp -> {\n-      Future<NetSocket> clientConnect = client.connect(testAddress);\n-      clientConnect.onComplete(onSuccess(sock -> {\n-        sock.handler(buf -> {\n-          sock.sendFile(file.getAbsolutePath());\n-        });\n-      }));\n+    server.listen(testAddress).await();\n+    Future<NetSocket> clientConnect = client.connect(testAddress);\n+    clientConnect.onComplete(onSuccess(sock -> {\n+      sock.handler(buf -> {\n+        sock.sendFile(file.getAbsolutePath());\n+      });\n     }));\n     await();\n   }\n@@ -215,7 +224,7 @@ public void testSendBufferIsTrafficShapedWithSharedServers() throws Exception {\n     Future<String> listenLatch = vertx.deployVerticle(() -> new AbstractVerticle() {\n       @Override\n       public void start(Promise<Void> startPromise) {\n-        NetServer testServer = netServer(vertx);\n+        NetServer testServer = netServer();\n         testServer.connectHandler(sock -> {\n           sock.handler(buf -> {\n             sock.write(expected);\n@@ -256,7 +265,7 @@ public void testDynamicInboundRateUpdate() {\n \n     Buffer expected = TestUtils.randomBuffer(64 * 1024 * 4);\n     Buffer received = Buffer.buffer();\n-    NetServer server = netServer(vertx);\n+    NetServer server = netServer();\n \n     server.connectHandler(sock -> {\n       sock.handler(buff -> {\n@@ -271,21 +280,19 @@ public void testDynamicInboundRateUpdate() {\n       // Send some data to the client to trigger the buffer write\n       sock.write(\"foo\");\n     });\n-    Future<NetServer> result = server.listen(testAddress);\n+    server.listen(testAddress).await();\n \n     // update rate\n     TrafficShapingOptions trafficOptions = new TrafficShapingOptions()\n                                              .setOutboundGlobalBandwidth(OUTBOUND_LIMIT) // unchanged\n                                              .setInboundGlobalBandwidth(2 * INBOUND_LIMIT);\n     server.updateTrafficShapingOptions(trafficOptions);\n \n-    result.onComplete(onSuccess(resp -> {\n-      Future<NetSocket> clientConnect = client.connect(testAddress);\n-      clientConnect.onComplete(onSuccess(sock -> {\n-        sock.handler(buf -> {\n-          sock.write(expected);\n-        });\n-      }));\n+    Future<NetSocket> clientConnect = client.connect(testAddress);\n+    clientConnect.onComplete(onSuccess(sock -> {\n+      sock.handler(buf -> {\n+        sock.write(expected);\n+      });\n     }));\n     await();\n   }\n@@ -296,7 +303,7 @@ public void testDynamicOutboundRateUpdate() {\n \n     Buffer expected = TestUtils.randomBuffer(64 * 1024 * 4);\n     Buffer received = Buffer.buffer();\n-    NetServer server = netServer(vertx);\n+    NetServer server = netServer();\n     server.connectHandler(sock -> {\n       sock.handler(buf -> {\n         sock.write(expected);\n@@ -331,7 +338,7 @@ public void testDynamicOutboundRateUpdate() {\n   @Test(expected = IllegalStateException.class)\n   public void testRateUpdateWhenServerStartedWithoutTrafficShaping() {\n     NetServerOptions options = new NetServerOptions().setHost(DEFAULT_HOST).setPort(DEFAULT_PORT);\n-    NetServer testServer = vertx.createNetServer(options);\n+    NetServer testServer = netServer(options);\n \n     // update inbound rate to twice the limit\n     TrafficShapingOptions trafficOptions = new TrafficShapingOptions()\n@@ -368,15 +375,19 @@ private void assertTimeTakenFallsInRange(long expectedTimeInMillis, long actualT\n     Assert.assertTrue(actualTimeInMillis <= expectedTimeInMillis + 2000); // +/- 2000 millis considered to be tolerant of time pauses during CI runs\n   }\n \n-  private NetServer netServer(Vertx vertx) {\n-    NetServerOptions options = new NetServerOptions()\n-                                  .setHost(DEFAULT_HOST)\n-                                  .setPort(DEFAULT_PORT)\n-                                  .setTrafficShapingOptions(new TrafficShapingOptions()\n-                                                              .setInboundGlobalBandwidth(NetBandwidthLimitingTest.INBOUND_LIMIT)\n-                                                              .setOutboundGlobalBandwidth(NetBandwidthLimitingTest.OUTBOUND_LIMIT));\n+  private NetServer netServer() {\n+    return netServer(new NetServerOptions()\n+      .setHost(DEFAULT_HOST)\n+      .setPort(DEFAULT_PORT)\n+      .setTrafficShapingOptions(new TrafficShapingOptions()\n+        .setInboundGlobalBandwidth(NetBandwidthLimitingTest.INBOUND_LIMIT)\n+        .setOutboundGlobalBandwidth(NetBandwidthLimitingTest.OUTBOUND_LIMIT)));\n+  }\n \n-    return vertx.createNetServer(options);\n+  private NetServer netServer(NetServerOptions options) {\n+    NetServer server = vertx.createNetServer(options);\n+    servers.add(server);\n+    return server;\n   }\n \n   private File setupFile(String testDir, String fileName, String content) throws Exception {",
      "parent_sha": "27cb9611cd2e7eb34bed6486ca0131d661acb585"
    }
  },
  {
    "oid": "6d3d7c90a0253a87b5a1ef5d3ed9663d5ca4fb52",
    "message": "Remove callback usage in AsyncMapTest",
    "date": "2023-03-09T14:52:53Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/6d3d7c90a0253a87b5a1ef5d3ed9663d5ca4fb52",
    "details": {
      "sha": "a5e3757145658c00d69012b32e4c2124484c4717",
      "filename": "src/test/java/io/vertx/core/shareddata/AsyncMapTest.java",
      "status": "modified",
      "additions": 214,
      "deletions": 270,
      "changes": 484,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/6d3d7c90a0253a87b5a1ef5d3ed9663d5ca4fb52/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fshareddata%2FAsyncMapTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/6d3d7c90a0253a87b5a1ef5d3ed9663d5ca4fb52/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fshareddata%2FAsyncMapTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fshareddata%2FAsyncMapTest.java?ref=6d3d7c90a0253a87b5a1ef5d3ed9663d5ca4fb52",
      "patch": "@@ -112,53 +112,56 @@ public void testMapPutGetClusterSerializableImplObject() {\n \n   @Test\n   public void testMapPutTtl() {\n-    getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map -> {\n-      map.put(\"pipo\", \"molo\", 10, onSuccess(vd -> {\n-        getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map2 -> {\n-          assertWaitUntil(map2, \"pipo\", 15, Objects::isNull);\n-        }));\n-      }));\n-    }));\n+    SharedData sharedData = getVertx().sharedData();\n+    sharedData\n+      .<String, String>getAsyncMap(\"foo\").compose(map -> map.put(\"pipo\", \"molo\", 10))\n+      .compose(v -> assertWaitUntilMapContains(sharedData, \"foo\", \"pipo\", 15, Objects::isNull))\n+      .onComplete(onSuccess(v -> testComplete()));\n     await();\n   }\n \n-  private void assertWaitUntil(AsyncMap<String, String> map, String key, long delay, Function<String, Boolean> checks) {\n+  private Future<Void> assertWaitUntilMapContains(SharedData sharedData, String name, String key, long delay, Function<String, Boolean> checks) {\n+    return sharedData.<String, String>getAsyncMap(name).compose(map -> assertWaitUntil(map, key, delay, checks));\n+  }\n+\n+  private Future<Void> assertWaitUntil(AsyncMap<String, String> map, String key, long delay, Function<String, Boolean> checks) {\n+    return Future.future(p -> assertWaitUntil(map, key, delay, checks, p));\n+  }\n+\n+  private void assertWaitUntil(AsyncMap<String, String> map, String key, long delay, Function<String, Boolean> checks, Promise<Void> promise) {\n     vertx.setTimer(delay, l -> {\n-      map.get(key, onSuccess(value -> {\n-        if (checks.apply(value)) {\n-          testComplete();\n-        } else {\n-          assertWaitUntil(map, key, delay, checks);\n-        }\n-      }));\n+      map.get(key)\n+        .onComplete(onSuccess(value -> {\n+          if (checks.apply(value)) {\n+            promise.complete();\n+          } else {\n+            assertWaitUntil(map, key, delay, checks, promise);\n+          }\n+        }));\n     });\n   }\n \n   @Test\n   public void testMapPutTtlThenPut() {\n-    getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map -> {\n-      map.put(\"pipo\", \"molo\", 10, onSuccess(vd -> {\n-        map.put(\"pipo\", \"mili\", onSuccess(vd2 -> {\n-          getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map2 -> {\n-            assertWaitUntil(map2, \"pipo\", 20, s -> \"mili\".equals(s));\n-          }));\n-        }));\n-      }));\n-    }));\n+    SharedData sharedData = getVertx().sharedData();\n+    sharedData.<String, String>getAsyncMap(\"foo\")\n+      .compose(map -> map\n+        .put(\"pipo\", \"molo\", 10)\n+        .compose(v -> map.put(\"pipo\", \"mili\")))\n+      .compose(v -> assertWaitUntilMapContains(sharedData, \"foo\", \"pipo\", 20, s -> \"mili\".equals(s)))\n+      .onComplete(onSuccess(v -> testComplete()));\n     await();\n   }\n \n   @Test\n   public void testMapPutThenPutTtl() {\n-    getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map -> {\n-      map.put(\"pipo\", \"molo\", onSuccess(vd -> {\n-        map.put(\"pipo\", \"mili\", 10, onSuccess(vd2 -> {\n-          getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map2 -> {\n-            assertWaitUntil(map2, \"pipo\", 15, Objects::isNull);\n-          }));\n-        }));\n-      }));\n-    }));\n+    SharedData sharedData = getVertx().sharedData();\n+    sharedData.<String, String>getAsyncMap(\"foo\")\n+      .compose(map -> map\n+        .put(\"pipo\", \"molo\")\n+        .compose(v -> map.put(\"pipo\", \"mili\", 10)))\n+      .compose(v -> assertWaitUntilMapContains(sharedData, \"foo\", \"pipo\", 15, Objects::isNull))\n+      .onComplete(onSuccess(v -> testComplete()));\n     await();\n   }\n \n@@ -239,29 +242,24 @@ public void testMapPutIfAbsentGetClusterSerializableImplObject() {\n \n   @Test\n   public void testMapPutIfAbsentTtl() {\n-    getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map -> {\n-      map.putIfAbsent(\"pipo\", \"molo\", 10, onSuccess(vd -> {\n-        assertNull(vd);\n-        getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map2 -> {\n-          assertWaitUntil(map2, \"pipo\", 15, Objects::isNull);\n-        }));\n-      }));\n-    }));\n+    SharedData sharedData = getVertx().sharedData();\n+    sharedData.<String, String>getAsyncMap(\"foo\")\n+      .compose(map -> map.putIfAbsent(\"pipo\", \"molo\", 10).andThen(onSuccess(this::assertNull)))\n+      .compose(v -> assertWaitUntilMapContains(sharedData, \"foo\", \"pipo\", 15, Objects::isNull))\n+      .onComplete(onSuccess(v -> testComplete()));\n     await();\n   }\n \n   @Test\n   public void testMapPutIfAbsentTtlWithExistingNotGettingDeleted() {\n-    getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map -> {\n-      map.put(\"pipo\", \"molo\", onSuccess(vd -> {\n-        map.putIfAbsent(\"pipo\", \"mili\", 10, onSuccess(vd2 -> {\n-          assertEquals(\"molo\", vd2);\n-          getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map2 -> {\n-            assertWaitUntil(map2, \"pipo\", 15, \"molo\"::equals);\n-          }));\n-        }));\n-      }));\n-    }));\n+    SharedData sharedData = getVertx().sharedData();\n+    sharedData.<String, String>getAsyncMap(\"foo\")\n+      .compose(map -> map\n+        .put(\"pipo\", \"molo\")\n+        .compose(v -> map\n+          .putIfAbsent(\"pipo\", \"mili\", 10)\n+          .andThen(onSuccess(vd -> assertEquals(\"molo\", vd)))))\n+      .compose(v -> assertWaitUntilMapContains(sharedData, \"foo\", \"pipo\", 15, \"molo\"::equals)).onComplete(onSuccess(v -> testComplete()));\n     await();\n   }\n \n@@ -498,30 +496,25 @@ public void testMapReplaceClusterSerializableImplObject() {\n \n   @Test\n   public void testMapReplaceTtl() {\n-    getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map -> {\n-      map.replace(\"pipo\", \"molo\", 10, onSuccess(vd -> {\n-        assertNull(vd);\n-        getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map2 -> {\n-          assertWaitUntil(map2, \"pipo\", 15, Objects::isNull);\n-        }));\n-      }));\n-    }));\n+    SharedData sharedData = getVertx().sharedData();\n+    sharedData.<String, String>getAsyncMap(\"foo\")\n+      .compose(map -> map\n+        .replace(\"pipo\", \"molo\", 10)\n+        .andThen(onSuccess(this::assertNull)))\n+      .compose(v -> assertWaitUntilMapContains(sharedData, \"foo\", \"pipo\", 15, Objects::isNull))\n+      .onComplete(onSuccess(v -> testComplete()));\n     await();\n   }\n \n   @Test\n   public void testMapReplaceTtlWithPreviousValue() {\n-    getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map -> {\n-      map.put(\"pipo\", \"molo\",  onSuccess(vd -> {\n-        assertNull(vd);\n-        map.replace(\"pipo\", \"mili\", 10, onSuccess(vd2 -> {\n-          assertEquals(\"molo\", vd2);\n-          getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map2 -> {\n-            assertWaitUntil(map2, \"pipo\", 15, Objects::isNull);\n-          }));\n-        }));\n-      }));\n-    }));\n+    SharedData sharedData = getVertx().sharedData();\n+    sharedData.<String, String>getAsyncMap(\"foo\")\n+      .compose(map -> map\n+        .put(\"pipo\", \"molo\").andThen(onSuccess(this::assertNull))\n+        .compose(vd -> map.replace(\"pipo\", \"mili\", 10)))\n+      .compose(v -> assertWaitUntilMapContains(sharedData, \"foo\", \"pipo\", 15, Objects::isNull))\n+      .onComplete(onSuccess(v -> testComplete()));\n     await();\n   }\n \n@@ -604,156 +597,142 @@ public void testMapReplaceIfPresentClusterSerializableImplObject() {\n \n   @Test\n   public void testMapReplaceIfPresentTtl() {\n-    getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map -> {\n-      map.put(\"pipo\", \"molo\", onSuccess(vd -> {\n-        assertNull(vd);\n-        map.replaceIfPresent(\"pipo\", \"molo\", \"mili\", 10, onSuccess(vd2 -> {\n-          assertTrue(vd2);\n-          getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map2 -> {\n-            assertWaitUntil(map2, \"pipo\", 15, Objects::isNull);\n-          }));\n-        }));\n-      }));\n-    }));\n+    SharedData sharedData = getVertx().sharedData();\n+    sharedData.<String, String>getAsyncMap(\"foo\")\n+      .compose(map -> map\n+        .put(\"pipo\", \"molo\").andThen(onSuccess(this::assertNull))\n+        .compose(v -> map.replaceIfPresent(\"pipo\", \"molo\", \"mili\", 10).andThen(onSuccess(this::assertTrue))))\n+      .compose(v -> assertWaitUntilMapContains(sharedData, \"foo\", \"pipo\", 15, Objects::isNull))\n+      .onComplete(onSuccess(v -> testComplete()));\n     await();\n   }\n \n   @Test\n   public void testMapReplaceIfPresentTtlWhenNotPresent() {\n-    getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map -> {\n-      map.replaceIfPresent(\"pipo\", \"molo\", \"mili\",10, onSuccess(vd -> {\n-        assertFalse(vd);\n-        testComplete();\n-      }));\n-    }));\n+    getVertx().sharedData().<String, String>getAsyncMap(\"foo\")\n+      .compose(map -> map\n+        .replaceIfPresent(\"pipo\", \"molo\", \"mili\",10)\n+        .andThen(onSuccess(this::assertFalse)))\n+      .onComplete(onSuccess(vd -> testComplete()));\n     await();\n   }\n \n   @Test\n   public void testGetMapWithNullName() throws Exception {\n-    assertNullPointerException(() -> getVertx().sharedData().<String, String>getAsyncMap(null, ar -> {}));\n-  }\n-\n-  @Test\n-  public void testGetMapWithNullResultHandler() throws Exception {\n-    assertNullPointerException(() -> getVertx().sharedData().<String, String>getAsyncMap(\"foo\", null));\n+    assertNullPointerException(() -> getVertx().sharedData().<String, String>getAsyncMap(null));\n   }\n \n   @Test\n   public void testPutNullKey() {\n-    getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map -> {\n-      assertIllegalArgumentException(() -> map.put(null, \"foo\", ar2 -> {}));\n-      testComplete();\n-    }));\n+    getVertx().sharedData().<String, String>getAsyncMap(\"foo\")\n+      .onComplete(onSuccess(map -> {\n+        assertIllegalArgumentException(() -> map.put(null, \"foo\"));\n+        testComplete();\n+      }));\n     await();\n   }\n \n   @Test\n   public void testPutNullValue() {\n-    getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map -> {\n-      assertIllegalArgumentException(() -> map.put(\"foo\", null, ar2 -> {}));\n-      testComplete();\n-    }));\n+    getVertx().sharedData().<String, String>getAsyncMap(\"foo\")\n+      .onComplete(onSuccess(map -> {\n+        assertIllegalArgumentException(() -> map.put(\"foo\", null));\n+        testComplete();\n+      }));\n     await();\n   }\n \n   @Test\n   public void testPutInvalidKey() {\n-    getVertx().sharedData().<SomeObject, String>getAsyncMap(\"foo\", onSuccess(map -> {\n-      assertIllegalArgumentException(() -> map.put(new SomeObject(), \"foo\", ar2 -> {}));\n-      testComplete();\n-    }));\n+    getVertx().sharedData().<SomeObject, String>getAsyncMap(\"foo\")\n+      .onComplete(onSuccess(map -> {\n+        assertIllegalArgumentException(() -> map.put(new SomeObject(), \"foo\"));\n+        testComplete();\n+      }));\n     await();\n   }\n \n   @Test\n   public void testPutInvalidValue() {\n-    getVertx().sharedData().<String, SomeObject>getAsyncMap(\"foo\", onSuccess(map -> {\n-      assertIllegalArgumentException(() -> map.put(\"foo\", new SomeObject(), ar2 -> {}));\n-      testComplete();\n-    }));\n+    getVertx().sharedData().<String, SomeObject>getAsyncMap(\"foo\")\n+      .onComplete(onSuccess(map -> {\n+        assertIllegalArgumentException(() -> map.put(\"foo\", new SomeObject()));\n+        testComplete();\n+      }));\n     await();\n   }\n \n   @Test\n   public void testPutIfAbsentInvalidKey() {\n-    getVertx().sharedData().<SomeObject, String>getAsyncMap(\"foo\", onSuccess(map -> {\n-      assertIllegalArgumentException(() -> map.putIfAbsent(new SomeObject(), \"foo\", ar2 -> {}));\n-      testComplete();\n-    }));\n+    getVertx().sharedData().<SomeObject, String>getAsyncMap(\"foo\")\n+      .onComplete(onSuccess(map -> {\n+        assertIllegalArgumentException(() -> map.putIfAbsent(new SomeObject(), \"foo\"));\n+        testComplete();\n+      }));\n     await();\n   }\n \n   @Test\n   public void testPutIfAbsentInvalidValue() {\n-    getVertx().sharedData().<String, SomeObject>getAsyncMap(\"foo\", onSuccess(map -> {\n-      assertIllegalArgumentException(() -> map.putIfAbsent(\"foo\", new SomeObject(), ar2 -> {}));\n-      testComplete();\n-    }));\n+    getVertx().sharedData().<String, SomeObject>getAsyncMap(\"foo\")\n+      .onComplete(onSuccess(map -> {\n+        assertIllegalArgumentException(() -> map.putIfAbsent(\"foo\", new SomeObject()));\n+        testComplete();\n+      }));\n     await();\n   }\n \n   @Test\n   public void testMultipleMaps() {\n-    getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map -> {\n-      map.put(\"foo\", \"bar\", onSuccess(v -> {\n-        getVertx().sharedData().<String, String>getAsyncMap(\"bar\", onSuccess(map2 -> {\n-          map2.get(\"foo\", onSuccess(res -> {\n-            assertNull(res);\n-            testComplete();\n-          }));\n-        }));\n-      }));\n-    }));\n+    SharedData sharedData = getVertx().sharedData();\n+    sharedData.<String, String>getAsyncMap(\"foo\")\n+      .compose(map -> map.put(\"foo\", \"bar\"))\n+      .compose(v -> sharedData\n+        .<String, String>getAsyncMap(\"bar\")\n+        .compose(map -> map.get(\"foo\"))\n+        .andThen(onSuccess(this::assertNull)))\n+      .onComplete(onSuccess(res -> testComplete()));\n     await();\n   }\n \n   @Test\n   public void testClear() {\n-    getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map -> {\n-      map.put(\"foo\", \"bar\", onSuccess(v -> {\n-        getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map2 -> {\n-          map2.clear(onSuccess(v2 -> {\n-            map.get(\"foo\", onSuccess(res -> {\n-              assertNull(res);\n-              testComplete();\n-            }));\n-          }));\n-        }));\n-      }));\n-    }));\n+    SharedData sharedData = getVertx().sharedData();\n+    sharedData.<String, String>getAsyncMap(\"foo\")\n+      .compose(map -> map.put(\"foo\", \"bar\"))\n+      .compose(v -> sharedData\n+        .<String, String>getAsyncMap(\"foo\")\n+        .compose(map -> map\n+          .clear()\n+          .compose(v2 -> map.get(\"foo\"))))\n+      .onComplete(onSuccess(v -> testComplete()));\n     await();\n   }\n \n   @Test\n   public void testSize() {\n-    getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map -> {\n-      map.size(onSuccess(size -> {\n-        assertEquals(0, size.intValue());\n-        map.put(\"foo\", \"bar\", onSuccess(v -> {\n-          map.size(onSuccess(size2 -> {\n-            assertEquals(1, size2.intValue());\n-            getVertx().sharedData().<String, String>getAsyncMap(\"foo\", onSuccess(map2 -> {\n-              map2.size(onSuccess(size3 -> {\n-                assertEquals(1, size3.intValue());\n-                testComplete();\n-              }));\n-            }));\n-          }));\n-        }));\n-      }));\n-    }));\n+    SharedData sharedData = getVertx().sharedData();\n+    sharedData.<String, String>getAsyncMap(\"foo\")\n+      .compose(map -> map\n+        .size().andThen(onSuccess(size -> assertEquals(0, size.intValue())))\n+        .compose(v -> map.put(\"foo\", \"bar\"))\n+        .compose(v -> map.size().andThen(onSuccess(size -> assertEquals(1, size.intValue())))))\n+      .compose(v -> sharedData.\n+          <String, String>getAsyncMap(\"foo\")\n+          .compose(map -> map.size().andThen(onSuccess(size -> assertEquals(1, size.intValue())))))\n+      .onComplete(onSuccess(v -> testComplete()));\n     await();\n   }\n \n   @Test\n   public void testKeys() {\n     Map<JsonObject, Buffer> map = genJsonToBuffer(100);\n     loadData(map, (vertx, asyncMap) -> {\n-      asyncMap.keys(onSuccess(keys -> {\n-        assertEquals(map.keySet(), keys);\n-        testComplete();\n-      }));\n+      asyncMap.keys()\n+        .onComplete(onSuccess(keys -> {\n+          assertEquals(map.keySet(), keys);\n+          testComplete();\n+        }));\n     });\n     await();\n   }\n@@ -762,12 +741,14 @@ public void testKeys() {\n   public void testValues() {\n     Map<JsonObject, Buffer> map = genJsonToBuffer(100);\n     loadData(map, (vertx, asyncMap) -> {\n-      asyncMap.values(onSuccess(values -> {\n-        assertEquals(map.values().size(), values.size());\n-        assertTrue(map.values().containsAll(values));\n-        assertTrue(values.containsAll(map.values()));\n-        testComplete();\n-      }));\n+      asyncMap\n+        .values()\n+        .andThen(onSuccess(values -> {\n+          assertEquals(map.values().size(), values.size());\n+          assertTrue(map.values().containsAll(values));\n+          assertTrue(values.containsAll(map.values()));\n+        }))\n+        .onComplete(onSuccess(values -> testComplete()));\n     });\n     await();\n   }\n@@ -776,10 +757,9 @@ public void testValues() {\n   public void testEntries() {\n     Map<JsonObject, Buffer> map = genJsonToBuffer(100);\n     loadData(map, (vertx, asyncMap) -> {\n-      asyncMap.entries(onSuccess(res -> {\n-        assertEquals(map.entrySet(), res.entrySet());\n-        testComplete();\n-      }));\n+      asyncMap\n+        .entries().andThen(onSuccess(res -> assertEquals(map.entrySet(), res.entrySet())))\n+        .onSuccess(res -> testComplete());\n     });\n     await();\n   }\n@@ -794,133 +774,97 @@ protected Map<JsonObject, Buffer> genJsonToBuffer(int size) {\n   }\n \n   protected void loadData(Map<JsonObject, Buffer> map, BiConsumer<Vertx, AsyncMap<JsonObject, Buffer>> test) {\n+    SharedData sharedData = getVertx().sharedData();\n     List<Future> futures = new ArrayList<>(map.size());\n     map.forEach((key, value) -> {\n-      Promise future = Promise.promise();\n-      getVertx().sharedData().getAsyncMap(\"foo\", onSuccess(asyncMap -> {\n-        asyncMap.put(key, value, future);\n-      }));\n-      futures.add(future.future());\n+      futures.add(sharedData.getAsyncMap(\"foo\").compose(asyncMap -> asyncMap.put(key, value)));\n     });\n-    CompositeFuture.all(futures).onComplete(onSuccess(cf -> {\n-      Vertx v = getVertx();\n-      v.sharedData().<JsonObject, Buffer>getAsyncMap(\"foo\", onSuccess(asyncMap -> {\n-        test.accept(v, asyncMap);\n-      }));\n-    }));\n+    CompositeFuture.all(futures).compose(cf -> sharedData.<JsonObject, Buffer>getAsyncMap(\"foo\"))\n+      .onComplete(onSuccess(asyncMap -> test.accept(getVertx(), asyncMap)));\n   }\n \n   private <K, V> void testMapPutGet(K k, V v) {\n-    getVertx().sharedData().<K, V>getAsyncMap(\"foo\", onSuccess(map -> {\n-      map.put(k, v, onSuccess(vd -> {\n-        getVertx().sharedData().<K, V>getAsyncMap(\"foo\", onSuccess(map2 -> {\n-          map2.get(k, onSuccess(res -> {\n-            assertEquals(v, res);\n-            testComplete();\n-          }));\n-        }));\n-      }));\n-    }));\n+    SharedData sharedData = getVertx().sharedData();\n+    sharedData.<K, V>getAsyncMap(\"foo\")\n+      .compose(map -> map.put(k, v))\n+      .compose(v_ -> sharedData\n+        .<K, V>getAsyncMap(\"foo\")\n+        .compose(map -> map\n+          .get(k))\n+        .andThen(onSuccess(res -> assertEquals(v, res))))\n+      .onComplete(onSuccess(res -> testComplete()));\n     await();\n   }\n \n   private <K, V> void testMapPutIfAbsentGet(K k, V v) {\n-    getVertx().sharedData().<K, V>getAsyncMap(\"foo\", onSuccess(map -> {\n-      map.putIfAbsent(k, v, onSuccess(res -> {\n-        assertNull(res);\n-        getVertx().sharedData().<K, V>getAsyncMap(\"foo\", onSuccess(map2 -> {\n-          map2.get(k, onSuccess(res2 -> {\n-            assertEquals(v, res2);\n-            map.putIfAbsent(k, v, onSuccess(res3 -> {\n-              assertEquals(v, res3);\n-              testComplete();\n-            }));\n-          }));\n-        }));\n-      }));\n-    }));\n+    SharedData sharedData = getVertx().sharedData();\n+    sharedData.<K, V>getAsyncMap(\"foo\")\n+      .compose(map -> map.putIfAbsent(k, v))\n+      .andThen(onSuccess(this::assertNull))\n+      .compose(v_ -> sharedData.<K, V>getAsyncMap(\"foo\"))\n+      .compose(map -> map\n+        .get(k)\n+        .andThen(onSuccess(res -> assertEquals(v, res)))\n+        .compose(res2 -> map.putIfAbsent(k, v))\n+        .andThen(onSuccess(res -> assertEquals(v, res))))\n+      .onComplete(onSuccess(res -> testComplete()));\n     await();\n   }\n \n   private <K, V> void testMapRemove(K k, V v) {\n-    getVertx().sharedData().<K, V>getAsyncMap(\"foo\", onSuccess(map -> {\n-      map.put(k, v, onSuccess(res -> {\n-        assertNull(res);\n-        getVertx().sharedData().<K, V>getAsyncMap(\"foo\", onSuccess(map2 -> {\n-          map2.remove(k, onSuccess(res2 -> {\n-            assertEquals(v, res2);\n-            testComplete();\n-          }));\n-        }));\n-      }));\n-    }));\n+    SharedData sharedData = getVertx().sharedData();\n+    sharedData.<K, V>getAsyncMap(\"foo\")\n+      .compose(map -> map.put(k, v).andThen(onSuccess(this::assertNull)))\n+      .compose(v_ -> sharedData\n+        .<K, V>getAsyncMap(\"foo\")\n+        .compose(map -> map.remove(k))\n+        .andThen(onSuccess(res -> assertEquals(v, res))))\n+      .onComplete(onSuccess(res -> testComplete()));\n     await();\n   }\n \n   private <K, V> void testMapRemoveIfPresent(K k, K otherKey, V v, V otherValue) {\n-    getVertx().sharedData().<K, V>getAsyncMap(\"foo\", onSuccess(map -> {\n-      map.put(k, v, onSuccess(res -> {\n-        assertNull(res);\n-        getVertx().sharedData().<K, V>getAsyncMap(\"foo\", onSuccess(map2 -> {\n-          map2.removeIfPresent(otherKey, v, onSuccess(res2 -> {\n-            assertFalse(res2);\n-            map2.removeIfPresent(k, otherValue, onSuccess(res3 -> {\n-              assertFalse(res3);\n-              map2.removeIfPresent(k, v, onSuccess(res4 -> {\n-                assertTrue(res4);\n-                testComplete();\n-              }));\n-            }));\n-          }));\n-        }));\n-      }));\n-    }));\n+    SharedData sharedData = getVertx().sharedData();\n+    sharedData\n+      .<K, V>getAsyncMap(\"foo\")\n+      .compose(map -> map.put(k, v).andThen(onSuccess(this::assertNull)))\n+      .compose(v_ -> sharedData.<K, V>getAsyncMap(\"foo\"))\n+      .compose(map -> map\n+        .removeIfPresent(otherKey, v)\n+        .andThen(onSuccess(this::assertFalse))\n+        .compose(res -> map.removeIfPresent(k, otherValue).andThen(onSuccess(this::assertFalse)))\n+        .compose(res -> map.removeIfPresent(k, v).andThen(onSuccess(this::assertTrue))))\n+      .onComplete(onSuccess(v_ -> testComplete()));\n     await();\n   }\n \n   private <K, V> void testMapReplace(K k, V v, V other) {\n-    getVertx().sharedData().<K, V>getAsyncMap(\"foo\", onSuccess(map -> {\n-      map.put(k, v, onSuccess(res -> {\n-        assertNull(res);\n-        getVertx().sharedData().<K, V>getAsyncMap(\"foo\", onSuccess(map2 -> {\n-          map2.replace(k, other, onSuccess(res2 -> {\n-            assertEquals(v, res2);\n-            map2.get(k, onSuccess(res3 -> {\n-              assertEquals(other, res3);\n-              map2.remove(k, onSuccess(res4 -> {\n-                map2.replace(k, other, onSuccess(res5 -> {\n-                  assertNull(res5);\n-                  map2.get(k, onSuccess(res6 -> {\n-                    assertNull(res6);\n-                    testComplete();\n-                  }));\n-                }));\n-              }));\n-            }));\n-          }));\n-        }));\n-      }));\n-    }));\n+    SharedData sharedData = getVertx().sharedData();\n+    sharedData\n+      .<K, V>getAsyncMap(\"foo\")\n+      .compose(map -> map.put(k, v).andThen(onSuccess(this::assertNull)))\n+      .compose(v_ -> sharedData\n+        .<K, V>getAsyncMap(\"foo\")\n+        .compose(map -> map.replace(k, other).andThen(onSuccess(res -> assertEquals(v, res)))\n+          .compose(v__ -> map.get(k).andThen(onSuccess(res -> assertEquals(other, res))))\n+          .compose(v__ -> map.remove(k)).compose(v__ -> map.replace(k, other).andThen(onSuccess(this::assertNull)))\n+          .compose(v__ -> map.get(k).andThen(onSuccess(this::assertNull)))))\n+      .onComplete(onSuccess(v_ -> testComplete()));\n+\n     await();\n   }\n \n   private <K, V> void testMapReplaceIfPresent(K k, V v, V other) {\n-    getVertx().sharedData().<K, V>getAsyncMap(\"foo\", onSuccess(map -> {\n-      map.put(k, v, onSuccess(res -> {\n-        assertNull(res);\n-        getVertx().sharedData().<K, V>getAsyncMap(\"foo\", onSuccess(map2 -> {\n-          map2.replaceIfPresent(k, v, other, onSuccess(res2 -> {\n-            map2.replaceIfPresent(k, v, other, onSuccess(res3 -> {\n-              assertFalse(res3);\n-              map2.get(k, onSuccess(res4 -> {\n-                assertEquals(other, res4);\n-                testComplete();\n-              }));\n-            }));\n-          }));\n-        }));\n-      }));\n-    }));\n+    SharedData sharedData = getVertx().sharedData();\n+    sharedData.<K, V>getAsyncMap(\"foo\")\n+      .compose(map -> map.put(k, v)\n+      .andThen(onSuccess(this::assertNull)))\n+      .compose(v_ -> sharedData.<K, V>getAsyncMap(\"foo\"))\n+      .compose(map -> map\n+        .replaceIfPresent(k, v, other)\n+        .compose(res2 -> map.replaceIfPresent(k, v, other).andThen(onSuccess(this::assertFalse)))\n+        .compose(v_ -> map.get(k).andThen(onSuccess(res4 -> assertEquals(other, res4)))))\n+      .onComplete(onSuccess(v_ -> testComplete()));\n     await();\n   }\n ",
      "parent_sha": "c1cafe9d12f0c6d22ca8d8da0aaeac5c95fcd2a5"
    }
  },
  {
    "oid": "b0fce69aea0d1c1e211bb2c228b172c59e9fc418",
    "message": "Fix some tests with missing \"/\" when testing requestAbs",
    "date": "2017-02-06T11:35:31Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/b0fce69aea0d1c1e211bb2c228b172c59e9fc418",
    "details": {
      "sha": "8ee2e73dac1cfd6c386038a4c4ef7ea4c3a88a68",
      "filename": "src/test/java/io/vertx/test/core/Http1xTLSTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/b0fce69aea0d1c1e211bb2c228b172c59e9fc418/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttp1xTLSTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/b0fce69aea0d1c1e211bb2c228b172c59e9fc418/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttp1xTLSTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttp1xTLSTest.java?ref=b0fce69aea0d1c1e211bb2c228b172c59e9fc418",
      "patch": "@@ -85,28 +85,28 @@ public void testSSLClientRequestOptionsSetClear() throws Exception {\n   @Test\n   // Client trusts all server certs\n   public void testClearClientRequestAbsSetSSL() throws Exception {\n-    String absoluteURI = \"https://\" + DEFAULT_HTTP_HOST + \":4043\" + DEFAULT_TEST_URI;\n+    String absoluteURI = \"https://\" + DEFAULT_HTTP_HOST + \":4043/\" + DEFAULT_TEST_URI;\n     testTLS(Cert.NONE, Trust.SERVER_JKS, Cert.SERVER_JKS, Trust.NONE).clientSSL(false).requestProvider(c -> c.requestAbs(HttpMethod.POST, absoluteURI)).pass();\n   }\n \n   @Test\n   // Client trusts all server certs\n   public void testSSLClientRequestAbsSetSSL() throws Exception {\n-    String absoluteURI = \"https://\" + DEFAULT_HTTP_HOST + \":4043\" + DEFAULT_TEST_URI;\n+    String absoluteURI = \"https://\" + DEFAULT_HTTP_HOST + \":4043/\" + DEFAULT_TEST_URI;\n     testTLS(Cert.NONE, Trust.SERVER_JKS, Cert.SERVER_JKS, Trust.NONE).clientSSL(true).requestProvider(c -> c.requestAbs(HttpMethod.POST, absoluteURI)).pass();\n   }\n \n   @Test\n   // Client trusts all server certs\n   public void testClearClientRequestAbsSetClear() throws Exception {\n-    String absoluteURI = \"http://\" + DEFAULT_HTTP_HOST + \":4043\" + DEFAULT_TEST_URI;\n+    String absoluteURI = \"http://\" + DEFAULT_HTTP_HOST + \":4043/\" + DEFAULT_TEST_URI;\n     testTLS(Cert.NONE, Trust.SERVER_JKS, Cert.SERVER_JKS, Trust.NONE).clientSSL(false).serverSSL(false).requestProvider(c -> c.requestAbs(HttpMethod.POST, absoluteURI)).pass();\n   }\n \n   @Test\n   // Client trusts all server certs\n   public void testSSLClientRequestAbsSetClear() throws Exception {\n-    String absoluteURI = \"http://\" + DEFAULT_HTTP_HOST + \":4043\" + DEFAULT_TEST_URI;\n+    String absoluteURI = \"http://\" + DEFAULT_HTTP_HOST + \":4043/\" + DEFAULT_TEST_URI;\n     testTLS(Cert.NONE, Trust.SERVER_JKS, Cert.SERVER_JKS, Trust.NONE).clientSSL(true).serverSSL(false).requestProvider(c -> c.requestAbs(HttpMethod.POST, absoluteURI)).pass();\n   }\n ",
      "parent_sha": "e57e42c656e41c6de867f1513d273fe92ce0d05a"
    }
  },
  {
    "oid": "277ffee21a5b1f7e8920f2d5eda4866e6b42ffce",
    "message": "Improve NetTest#testIdleTimeoutSendChunkedFile that fails sometimes with native transports due to connection reset",
    "date": "2019-05-02T16:09:28Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/277ffee21a5b1f7e8920f2d5eda4866e6b42ffce",
    "details": {
      "sha": "e363107458bbcbac0d14aaa0b70e1025caf14b86",
      "filename": "src/test/java/io/vertx/core/net/NetTest.java",
      "status": "modified",
      "additions": 27,
      "deletions": 9,
      "changes": 36,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/277ffee21a5b1f7e8920f2d5eda4866e6b42ffce/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2FNetTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/277ffee21a5b1f7e8920f2d5eda4866e6b42ffce/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2FNetTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2FNetTest.java?ref=277ffee21a5b1f7e8920f2d5eda4866e6b42ffce",
      "patch": "@@ -42,7 +42,6 @@\n import io.vertx.test.proxy.SocksProxy;\n import io.vertx.test.proxy.TestProxyBase;\n import org.junit.Assume;\n-import org.junit.Ignore;\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.TemporaryFolder;\n@@ -56,6 +55,7 @@\n import java.util.concurrent.*;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.AtomicReference;\n import java.util.function.Consumer;\n \n@@ -3285,24 +3285,43 @@ public void testServerNetSocketShouldBeClosedWhenTheClosedHandlerIsCalled() thro\n \n   @Test\n   public void testServerWithIdleTimeoutSendChunkedFile() throws Exception {\n-    testdleTimeoutSendChunkedFile(true);\n+    testIdleTimeoutSendChunkedFile(true);\n   }\n \n   @Test\n   public void testClientWithIdleTimeoutSendChunkedFile() throws Exception {\n-    testdleTimeoutSendChunkedFile(false);\n+    testIdleTimeoutSendChunkedFile(false);\n   }\n \n-  private void testdleTimeoutSendChunkedFile(boolean idleOnServer) throws Exception {\n+  private void testIdleTimeoutSendChunkedFile(boolean idleOnServer) throws Exception {\n     int expected = 16 * 1024 * 1024; // We estimate this will take more than 200ms to transfer with a 1ms pause in chunks\n     File sent = TestUtils.tmpFile(\".dat\", expected);\n     server.close();\n+    AtomicReference<AsyncResult<Void>> sendResult = new AtomicReference<>();\n+    AtomicReference<Integer> remaining = new AtomicReference<>();\n+    AtomicLong now = new AtomicLong();\n+    Runnable testChecker = () -> {\n+      if (sendResult.get() != null && remaining.get() != null) {\n+        if (remaining.get() > 0) {\n+          // It might fail sometimes\n+          assertTrue(sendResult.get().failed());\n+        } else {\n+          assertTrue(sendResult.get().succeeded());\n+          assertTrue(System.currentTimeMillis() - now.get() > 200);\n+        }\n+        testComplete();\n+      }\n+    };\n     Consumer<NetSocket> sender = so -> {\n-      so.sendFile(sent.getAbsolutePath());\n+      so.sendFile(sent.getAbsolutePath(), ar -> {\n+        sendResult.set(ar);\n+        testChecker.run();\n+      });\n     };\n     Consumer<NetSocket> receiver = so -> {\n+      now.set(System.currentTimeMillis());\n+      remaining.set(expected);\n       int[] len = { 0 };\n-      long now = System.currentTimeMillis();\n       so.handler(buff -> {\n         len[0] += buff.length();\n         so.pause();\n@@ -3312,9 +3331,8 @@ private void testdleTimeoutSendChunkedFile(boolean idleOnServer) throws Exceptio\n       });\n       so.exceptionHandler(this::fail);\n       so.endHandler(v -> {\n-        assertEquals(0, expected - len[0]);\n-        assertTrue(System.currentTimeMillis() - now > 200);\n-        testComplete();\n+        remaining.set(expected - len[0]);\n+        testChecker.run();\n       });\n     };\n     server = vertx",
      "parent_sha": "1e8c42723a642c8ef454aa86f4bcc63bbdb9f645"
    }
  },
  {
    "oid": "1b9c1647307dfa34f8ce0c5b477796299aeaf2fc",
    "message": "Added context thread checks\n\nSigned-off-by: Thomas Segismont <tsegismont@gmail.com>",
    "date": "2020-02-08T06:21:41Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/1b9c1647307dfa34f8ce0c5b477796299aeaf2fc",
    "details": {
      "sha": "e77f8228a6cefc18b352f2b585fc370180826437",
      "filename": "src/test/java/io/vertx/core/FutureTest.java",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/1b9c1647307dfa34f8ce0c5b477796299aeaf2fc/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2FFutureTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/1b9c1647307dfa34f8ce0c5b477796299aeaf2fc/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2FFutureTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2FFutureTest.java?ref=1b9c1647307dfa34f8ce0c5b477796299aeaf2fc",
      "patch": "@@ -1575,12 +1575,17 @@ public void testFromCompletionStageWithContext() {\n   }\n \n   @Test\n-  public void testCompletedFuturesContext() {\n+  public void testCompletedFuturesContext() throws Exception {\n     waitFor(4);\n \n     Thread testThread = Thread.currentThread();\n     ContextInternal context = (ContextInternal) vertx.getOrCreateContext();\n \n+\n+    CompletableFuture<Thread> cf = new CompletableFuture<>();\n+    context.runOnContext(v -> cf.complete(Thread.currentThread()));\n+    Thread contextThread = cf.get();\n+\n     Future.succeededFuture().onSuccess(v -> {\n       assertSame(testThread, Thread.currentThread());\n       assertNull(Vertx.currentContext());\n@@ -1590,6 +1595,7 @@ public void testCompletedFuturesContext() {\n     context.succeededFuture().onSuccess(v -> {\n       assertNotSame(testThread, Thread.currentThread());\n       assertSame(context, Vertx.currentContext());\n+      assertSame(contextThread, Thread.currentThread());\n       complete();\n     });\n \n@@ -1602,6 +1608,7 @@ public void testCompletedFuturesContext() {\n     context.failedFuture(new Exception()).onFailure(v -> {\n       assertNotSame(testThread, Thread.currentThread());\n       assertSame(context, Vertx.currentContext());\n+      assertSame(contextThread, Thread.currentThread());\n       complete();\n     });\n ",
      "parent_sha": "52cb285d46c44e0290db825d1221b6b05f4998df"
    }
  },
  {
    "oid": "e999fa5b24c8d9a127ab54d4437628095c6a98b5",
    "message": "Typo",
    "date": "2022-04-19T12:23:41Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/e999fa5b24c8d9a127ab54d4437628095c6a98b5",
    "details": {
      "sha": "56c620922ef1577f00c24ff5548a6c46405df5d0",
      "filename": "src/main/java/io/vertx/core/shareddata/SharedData.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/e999fa5b24c8d9a127ab54d4437628095c6a98b5/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fshareddata%2FSharedData.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/e999fa5b24c8d9a127ab54d4437628095c6a98b5/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fshareddata%2FSharedData.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fshareddata%2FSharedData.java?ref=e999fa5b24c8d9a127ab54d4437628095c6a98b5",
      "patch": "@@ -189,7 +189,7 @@ public interface SharedData {\n    * Return a {@code LocalMap} with the specific {@code name}.\n    *\n    * @param name  the name of the map\n-   * @return the msp\n+   * @return the map\n    */\n   <K, V> LocalMap<K, V> getLocalMap(String name);\n ",
      "parent_sha": "0cd6af9e9b3e5787533b38a193726bd5b4912ee9"
    }
  },
  {
    "oid": "035a2cf24ebdb1135793d1ab2a123e826d7facf1",
    "message": "Added codec tests for buffer\n\nSigned-off-by: Paulo Lopes <pmlopes@gmail.com>",
    "date": "2020-04-03T10:29:14Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/035a2cf24ebdb1135793d1ab2a123e826d7facf1",
    "details": {
      "sha": "df5a7200e9fe61cbe95e1a7dd42661daa7e9679c",
      "filename": "src/test/java/io/vertx/core/json/JsonCodecTest.java",
      "status": "modified",
      "additions": 23,
      "deletions": 12,
      "changes": 35,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/035a2cf24ebdb1135793d1ab2a123e826d7facf1/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fjson%2FJsonCodecTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/035a2cf24ebdb1135793d1ab2a123e826d7facf1/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fjson%2FJsonCodecTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fjson%2FJsonCodecTest.java?ref=035a2cf24ebdb1135793d1ab2a123e826d7facf1",
      "patch": "@@ -80,14 +80,15 @@ public void testEncodeJsonObject() {\n     jsonObject.put(\"mybyte\", 255);\n     byte[] bytes = TestUtils.randomByteArray(10);\n     jsonObject.put(\"mybinary\", bytes);\n+    jsonObject.put(\"mybuffer\", Buffer.buffer(bytes));\n     Instant now = Instant.now();\n     jsonObject.put(\"myinstant\", now);\n     jsonObject.putNull(\"mynull\");\n     jsonObject.put(\"myobj\", new JsonObject().put(\"foo\", \"bar\"));\n     jsonObject.put(\"myarr\", new JsonArray().add(\"foo\").add(123));\n     String strBytes = BASE64_ENCODER.encodeToString(bytes);\n     String expected = \"{\\\"mystr\\\":\\\"foo\\\",\\\"mycharsequence\\\":\\\"oob\\\",\\\"myint\\\":123,\\\"mylong\\\":1234,\\\"myfloat\\\":1.23,\\\"mydouble\\\":2.34,\\\"\" +\n-      \"myboolean\\\":true,\\\"mybyte\\\":255,\\\"mybinary\\\":\\\"\" + strBytes + \"\\\",\\\"myinstant\\\":\\\"\" + ISO_INSTANT.format(now) + \"\\\",\\\"mynull\\\":null,\\\"myobj\\\":{\\\"foo\\\":\\\"bar\\\"},\\\"myarr\\\":[\\\"foo\\\",123]}\";\n+      \"myboolean\\\":true,\\\"mybyte\\\":255,\\\"mybinary\\\":\\\"\" + strBytes + \"\\\",\\\"mybuffer\\\":\\\"\" + strBytes + \"\\\",\\\"myinstant\\\":\\\"\" + ISO_INSTANT.format(now) + \"\\\",\\\"mynull\\\":null,\\\"myobj\\\":{\\\"foo\\\":\\\"bar\\\"},\\\"myarr\\\":[\\\"foo\\\",123]}\";\n     String json = mapper.toString(jsonObject);\n     assertEquals(expected, json);\n   }\n@@ -104,11 +105,12 @@ public void testEncodeJsonArray() {\n     jsonArray.add((byte)124);\n     byte[] bytes = TestUtils.randomByteArray(10);\n     jsonArray.add(bytes);\n+    jsonArray.add(Buffer.buffer(bytes));\n     jsonArray.addNull();\n     jsonArray.add(new JsonObject().put(\"foo\", \"bar\"));\n     jsonArray.add(new JsonArray().add(\"foo\").add(123));\n     String strBytes = BASE64_ENCODER.encodeToString(bytes);\n-    String expected = \"[\\\"foo\\\",123,1234,1.23,2.34,true,124,\\\"\" + strBytes + \"\\\",null,{\\\"foo\\\":\\\"bar\\\"},[\\\"foo\\\",123]]\";\n+    String expected = \"[\\\"foo\\\",123,1234,1.23,2.34,true,124,\\\"\" + strBytes + \"\\\",\\\"\" + strBytes + \"\\\",null,{\\\"foo\\\":\\\"bar\\\"},[\\\"foo\\\",123]]\";\n     String json = mapper.toString(jsonArray);\n     assertEquals(expected, json);\n   }\n@@ -125,6 +127,7 @@ public void testEncodeJsonObjectToBuffer() {\n     jsonObject.put(\"myboolean\", true);\n     byte[] bytes = TestUtils.randomByteArray(10);\n     jsonObject.put(\"mybinary\", bytes);\n+    jsonObject.put(\"mybuffer\", Buffer.buffer(bytes));\n     Instant now = Instant.now();\n     jsonObject.put(\"myinstant\", now);\n     jsonObject.putNull(\"mynull\");\n@@ -133,7 +136,7 @@ public void testEncodeJsonObjectToBuffer() {\n     String strBytes = BASE64_ENCODER.encodeToString(bytes);\n \n     Buffer expected = Buffer.buffer(\"{\\\"mystr\\\":\\\"foo\\\",\\\"mycharsequence\\\":\\\"oob\\\",\\\"myint\\\":123,\\\"mylong\\\":1234,\\\"myfloat\\\":1.23,\\\"mydouble\\\":2.34,\\\"\" +\n-      \"myboolean\\\":true,\\\"mybinary\\\":\\\"\" + strBytes + \"\\\",\\\"myinstant\\\":\\\"\" + ISO_INSTANT.format(now) + \"\\\",\\\"mynull\\\":null,\\\"myobj\\\":{\\\"foo\\\":\\\"bar\\\"},\\\"myarr\\\":[\\\"foo\\\",123]}\", \"UTF-8\");\n+      \"myboolean\\\":true,\\\"mybinary\\\":\\\"\" + strBytes + \"\\\",\\\"mybuffer\\\":\\\"\" + strBytes + \"\\\",\\\"myinstant\\\":\\\"\" + ISO_INSTANT.format(now) + \"\\\",\\\"mynull\\\":null,\\\"myobj\\\":{\\\"foo\\\":\\\"bar\\\"},\\\"myarr\\\":[\\\"foo\\\",123]}\", \"UTF-8\");\n \n     Buffer json = mapper.toBuffer(jsonObject);\n     assertArrayEquals(expected.getBytes(), json.getBytes());\n@@ -150,11 +153,12 @@ public void testEncodeJsonArrayToBuffer() {\n     jsonArray.add(true);\n     byte[] bytes = TestUtils.randomByteArray(10);\n     jsonArray.add(bytes);\n+    jsonArray.add(Buffer.buffer(bytes));\n     jsonArray.addNull();\n     jsonArray.add(new JsonObject().put(\"foo\", \"bar\"));\n     jsonArray.add(new JsonArray().add(\"foo\").add(123));\n     String strBytes = BASE64_ENCODER.encodeToString(bytes);\n-    Buffer expected = Buffer.buffer(\"[\\\"foo\\\",123,1234,1.23,2.34,true,\\\"\" + strBytes + \"\\\",null,{\\\"foo\\\":\\\"bar\\\"},[\\\"foo\\\",123]]\", \"UTF-8\");\n+    Buffer expected = Buffer.buffer(\"[\\\"foo\\\",123,1234,1.23,2.34,true,\\\"\" + strBytes + \"\\\",\\\"\" + strBytes + \"\\\",null,{\\\"foo\\\":\\\"bar\\\"},[\\\"foo\\\",123]]\", \"UTF-8\");\n     Buffer json = mapper.toBuffer(jsonArray);\n     assertArrayEquals(expected.getBytes(), json.getBytes());\n   }\n@@ -171,6 +175,7 @@ public void testEncodeJsonObjectPrettily() {\n     jsonObject.put(\"myboolean\", true);\n     byte[] bytes = TestUtils.randomByteArray(10);\n     jsonObject.put(\"mybinary\", bytes);\n+    jsonObject.put(\"mybuffer\", Buffer.buffer(bytes));\n     Instant now = Instant.now();\n     jsonObject.put(\"myinstant\", now);\n     jsonObject.put(\"myobj\", new JsonObject().put(\"foo\", \"bar\"));\n@@ -185,6 +190,7 @@ public void testEncodeJsonObjectPrettily() {\n       \"  \\\"mydouble\\\" : 2.34,\" + Utils.LINE_SEPARATOR +\n       \"  \\\"myboolean\\\" : true,\" + Utils.LINE_SEPARATOR +\n       \"  \\\"mybinary\\\" : \\\"\" + strBytes + \"\\\",\" + Utils.LINE_SEPARATOR +\n+      \"  \\\"mybuffer\\\" : \\\"\" + strBytes + \"\\\",\" + Utils.LINE_SEPARATOR +\n       \"  \\\"myinstant\\\" : \\\"\" + strInstant + \"\\\",\" + Utils.LINE_SEPARATOR +\n       \"  \\\"myobj\\\" : {\" + Utils.LINE_SEPARATOR +\n       \"    \\\"foo\\\" : \\\"bar\\\"\" + Utils.LINE_SEPARATOR +\n@@ -206,11 +212,12 @@ public void testEncodeJsonArrayPrettily() {\n     jsonArray.add(true);\n     byte[] bytes = TestUtils.randomByteArray(10);\n     jsonArray.add(bytes);\n+    jsonArray.add(Buffer.buffer(bytes));\n     jsonArray.addNull();\n     jsonArray.add(new JsonObject().put(\"foo\", \"bar\"));\n     jsonArray.add(new JsonArray().add(\"foo\").add(123));\n     String strBytes = BASE64_ENCODER.encodeToString(bytes);\n-    String expected = \"[ \\\"foo\\\", 123, 1234, 1.23, 2.34, true, \\\"\" + strBytes + \"\\\", null, {\" + Utils.LINE_SEPARATOR +\n+    String expected = \"[ \\\"foo\\\", 123, 1234, 1.23, 2.34, true, \\\"\" + strBytes + \"\\\", \\\"\" + strBytes + \"\\\", null, {\" + Utils.LINE_SEPARATOR +\n       \"  \\\"foo\\\" : \\\"bar\\\"\" + Utils.LINE_SEPARATOR +\n       \"}, [ \\\"foo\\\", 123 ] ]\";\n     String json = mapper.toString(jsonArray, true);\n@@ -224,7 +231,7 @@ public void testDecodeJsonObject() {\n     Instant now = Instant.now();\n     String strInstant = ISO_INSTANT.format(now);\n     String json = \"{\\\"mystr\\\":\\\"foo\\\",\\\"myint\\\":123,\\\"mylong\\\":1234,\\\"myfloat\\\":1.23,\\\"mydouble\\\":2.34,\\\"\" +\n-      \"myboolean\\\":true,\\\"mybyte\\\":124,\\\"mybinary\\\":\\\"\" + strBytes + \"\\\",\\\"myinstant\\\":\\\"\" + strInstant + \"\\\",\\\"mynull\\\":null,\\\"myobj\\\":{\\\"foo\\\":\\\"bar\\\"},\\\"myarr\\\":[\\\"foo\\\",123]}\";\n+      \"myboolean\\\":true,\\\"mybyte\\\":124,\\\"mybinary\\\":\\\"\" + strBytes + \"\\\",\\\"mybuffer\\\":\\\"\" + strBytes + \"\\\",\\\"myinstant\\\":\\\"\" + strInstant + \"\\\",\\\"mynull\\\":null,\\\"myobj\\\":{\\\"foo\\\":\\\"bar\\\"},\\\"myarr\\\":[\\\"foo\\\",123]}\";\n     JsonObject obj = new JsonObject(mapper.fromString(json, Map.class));\n     assertEquals(json, mapper.toString(obj));\n     assertEquals(\"foo\", obj.getString(\"mystr\"));\n@@ -235,7 +242,9 @@ public void testDecodeJsonObject() {\n     assertTrue(obj.getBoolean(\"myboolean\"));\n     assertEquals(124, obj.getValue(\"mybyte\"));\n     assertArrayEquals(bytes, obj.getBinary(\"mybinary\"));\n+    assertEquals(Buffer.buffer(bytes), obj.getBuffer(\"mybuffer\"));\n     assertEquals(BASE64_ENCODER.encodeToString(bytes), obj.getValue(\"mybinary\"));\n+    assertEquals(BASE64_ENCODER.encodeToString(bytes), obj.getValue(\"mybuffer\"));\n     assertEquals(now, obj.getInstant(\"myinstant\"));\n     assertEquals(now.toString(), obj.getValue(\"myinstant\"));\n     assertTrue(obj.containsKey(\"mynull\"));\n@@ -252,7 +261,7 @@ public void testDecodeJsonArray() {\n     String strBytes = BASE64_ENCODER.encodeToString(bytes);\n     Instant now = Instant.now();\n     String strInstant = ISO_INSTANT.format(now);\n-    String json = \"[\\\"foo\\\",123,1234,1.23,2.34,true,124,\\\"\" + strBytes + \"\\\",\\\"\" + strInstant + \"\\\",null,{\\\"foo\\\":\\\"bar\\\"},[\\\"foo\\\",123]]\";\n+    String json = \"[\\\"foo\\\",123,1234,1.23,2.34,true,124,\\\"\" + strBytes + \"\\\",\\\"\" + strBytes + \"\\\",\\\"\" + strInstant + \"\\\",null,{\\\"foo\\\":\\\"bar\\\"},[\\\"foo\\\",123]]\";\n     JsonArray arr = new JsonArray(mapper.fromString(json, List.class));\n     assertEquals(\"foo\", arr.getString(0));\n     assertEquals(Integer.valueOf(123), arr.getInteger(1));\n@@ -263,12 +272,14 @@ public void testDecodeJsonArray() {\n     assertEquals(124, arr.getValue(6));\n     assertArrayEquals(bytes, arr.getBinary(7));\n     assertEquals(BASE64_ENCODER.encodeToString(bytes), arr.getValue(7));\n-    assertEquals(now, arr.getInstant(8));\n-    assertEquals(now.toString(), arr.getValue(8));\n-    assertTrue(arr.hasNull(9));\n-    JsonObject obj = arr.getJsonObject(10);\n+    assertEquals(Buffer.buffer(bytes), arr.getBuffer(8));\n+    assertEquals(BASE64_ENCODER.encodeToString(bytes), arr.getValue(8));\n+    assertEquals(now, arr.getInstant(9));\n+    assertEquals(now.toString(), arr.getValue(9));\n+    assertTrue(arr.hasNull(10));\n+    JsonObject obj = arr.getJsonObject(11);\n     assertEquals(\"bar\", obj.getString(\"foo\"));\n-    JsonArray arr2 = arr.getJsonArray(11);\n+    JsonArray arr2 = arr.getJsonArray(12);\n     assertEquals(\"foo\", arr2.getString(0));\n     assertEquals(Integer.valueOf(123), arr2.getInteger(1));\n   }",
      "parent_sha": "33c495ff7b487d465426d116c7516004544cf980"
    }
  },
  {
    "oid": "1b78b606bd5e8010af752c84bafc1c6e346b1979",
    "message": "FileSystemTest#testCopyNoFollowLinks should be ignored on Windows\n\nSigned-off-by: Thomas Segismont <tsegismont@gmail.com>",
    "date": "2018-07-31T13:31:21Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/1b78b606bd5e8010af752c84bafc1c6e346b1979",
    "details": {
      "sha": "019e24d9ff43a58db21f710f389b819ec56f2660",
      "filename": "src/test/java/io/vertx/test/core/FileSystemTest.java",
      "status": "modified",
      "additions": 7,
      "deletions": 19,
      "changes": 26,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/1b78b606bd5e8010af752c84bafc1c6e346b1979/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FFileSystemTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/1b78b606bd5e8010af752c84bafc1c6e346b1979/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FFileSystemTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FFileSystemTest.java?ref=1b78b606bd5e8010af752c84bafc1c6e346b1979",
      "patch": "@@ -17,13 +17,9 @@\n import io.vertx.core.Handler;\n import io.vertx.core.Vertx;\n import io.vertx.core.buffer.Buffer;\n-import io.vertx.core.file.AsyncFile;\n-import io.vertx.core.file.CopyOptions;\n-import io.vertx.core.file.FileProps;\n+import io.vertx.core.file.*;\n import io.vertx.core.file.FileSystem;\n import io.vertx.core.file.FileSystemException;\n-import io.vertx.core.file.FileSystemProps;\n-import io.vertx.core.file.OpenOptions;\n import io.vertx.core.file.impl.AsyncFileImpl;\n import io.vertx.core.impl.Utils;\n import io.vertx.core.json.JsonObject;\n@@ -38,19 +34,8 @@\n \n import java.io.File;\n import java.io.IOException;\n-import java.nio.file.AtomicMoveNotSupportedException;\n-import java.nio.file.FileAlreadyExistsException;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Files;\n-import java.nio.file.LinkOption;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.attribute.GroupPrincipal;\n-import java.nio.file.attribute.PosixFileAttributes;\n-import java.nio.file.attribute.PosixFilePermission;\n-import java.nio.file.attribute.PosixFilePermissions;\n-import java.nio.file.attribute.UserPrincipal;\n+import java.nio.file.*;\n+import java.nio.file.attribute.*;\n import java.util.EnumSet;\n import java.util.HashSet;\n import java.util.List;\n@@ -61,7 +46,7 @@\n import java.util.concurrent.atomic.AtomicReference;\n \n import static io.vertx.test.core.TestUtils.*;\n-import static org.hamcrest.CoreMatchers.*;\n+import static org.hamcrest.CoreMatchers.instanceOf;\n \n /**\n  * @author <a href=\"http://tfox.org\">Tim Fox</a>\n@@ -1824,6 +1809,9 @@ public void testCopyFileAttributes() throws Exception {\n \n   @Test\n   public void testCopyNoFollowLinks() throws Exception {\n+    // Symlinks require a modified security policy in Windows. -- See http://stackoverflow.com/questions/23217460/how-to-create-soft-symbolic-link-using-java-nio-files\n+    Assume.assumeFalse(Utils.isWindows());\n+\n     String source = \"foo.txt\";\n     String link = \"link.txt\";\n     String target = \"bar.txt\";",
      "parent_sha": "8a9449e9cd66e41ae8ec17785df425311d94ec6f"
    }
  },
  {
    "oid": "7a38002d8e8385ef76ee8936c4c8d9feb06d6be0",
    "message": "Remove callback usage in DatagramTest",
    "date": "2023-03-09T14:52:53Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/7a38002d8e8385ef76ee8936c4c8d9feb06d6be0",
    "details": {
      "sha": "88766b48a57a41e3b1c6342311be590ff7e22cbd",
      "filename": "src/test/java/io/vertx/core/datagram/DatagramTest.java",
      "status": "modified",
      "additions": 120,
      "deletions": 149,
      "changes": 269,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/7a38002d8e8385ef76ee8936c4c8d9feb06d6be0/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fdatagram%2FDatagramTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/7a38002d8e8385ef76ee8936c4c8d9feb06d6be0/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fdatagram%2FDatagramTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fdatagram%2FDatagramTest.java?ref=7a38002d8e8385ef76ee8936c4c8d9feb06d6be0",
      "patch": "@@ -35,7 +35,6 @@\n import java.net.NetworkInterface;\n import java.util.Random;\n import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.function.BiConsumer;\n@@ -54,50 +53,43 @@ public class DatagramTest extends VertxTestBase {\n   protected void tearDown() throws Exception {\n     CountDownLatch latch = new CountDownLatch(2);\n     if (peer1 != null) {\n-      peer1.close(ar -> {\n-        assertTrue(ar.succeeded());\n-        latch.countDown();\n-      });\n+      peer1.close().onComplete(onSuccess(v -> latch.countDown()));\n     } else {\n       latch.countDown();\n     }\n     if (peer2 != null) {\n-      peer2.close(ar2 -> {\n-        assertTrue(ar2.succeeded());\n-        latch.countDown();\n-      });\n+      peer2.close().onComplete(onSuccess(v -> latch.countDown()));\n     } else {\n       latch.countDown();\n     }\n-    latch.await(10L, TimeUnit.SECONDS);\n+    awaitLatch(latch);\n     super.tearDown();\n   }\n \n   @Test\n   public void testDatagramSocket() throws Exception {\n     peer1 = vertx.createDatagramSocket(new DatagramSocketOptions());\n \n-    assertNullPointerException(() -> peer1.send((Buffer) null, 1, \"127.0.0.1\", ar -> {}));\n-    assertIllegalArgumentException(() -> peer1.send(Buffer.buffer(), -1, \"127.0.0.1\", ar -> {}));\n-    assertIllegalArgumentException(() -> peer1.send(Buffer.buffer(), 65536, \"127.0.0.1\", ar -> {}));\n+    assertNullPointerException(() -> peer1.send((Buffer) null, 1, \"127.0.0.1\"));\n+    assertIllegalArgumentException(() -> peer1.send(Buffer.buffer(), -1, \"127.0.0.1\"));\n+    assertIllegalArgumentException(() -> peer1.send(Buffer.buffer(), 65536, \"127.0.0.1\"));\n \n-    assertNullPointerException(() -> peer1.send((String) null, 1, \"127.0.0.1\", ar -> {}));\n-    assertIllegalArgumentException(() -> peer1.send(\"\", -1, \"127.0.0.1\", ar -> {}));\n-    assertIllegalArgumentException(() -> peer1.send(\"\", 65536, \"127.0.0.1\", ar -> {}));\n+    assertNullPointerException(() -> peer1.send((String) null, 1, \"127.0.0.1\"));\n+    assertIllegalArgumentException(() -> peer1.send(\"\", -1, \"127.0.0.1\"));\n+    assertIllegalArgumentException(() -> peer1.send(\"\", 65536, \"127.0.0.1\"));\n \n-    assertNullPointerException(() -> peer1.send((String) null, \"UTF-8\", 1, \"127.0.0.1\", ar -> {}));\n-    assertIllegalArgumentException(() -> peer1.send(\"\", \"UTF-8\", -1, \"127.0.0.1\", ar -> {}));\n-    assertIllegalArgumentException(() -> peer1.send(\"\", \"UTF-8\", 65536, \"127.0.0.1\", ar -> {}));\n-    assertNullPointerException(() -> peer1.send(\"\", null, 1, \"127.0.0.1\", ar -> {}));\n+    assertNullPointerException(() -> peer1.send((String) null, \"UTF-8\", 1, \"127.0.0.1\"));\n+    assertIllegalArgumentException(() -> peer1.send(\"\", \"UTF-8\", -1, \"127.0.0.1\"));\n+    assertIllegalArgumentException(() -> peer1.send(\"\", \"UTF-8\", 65536, \"127.0.0.1\"));\n+    assertNullPointerException(() -> peer1.send(\"\", null, 1, \"127.0.0.1\"));\n \n     assertIllegalArgumentException(() -> peer1.sender(-1, \"127.0.0.1\"));\n     assertIllegalArgumentException(() -> peer1.sender(65536, \"127.0.0.1\"));\n     assertNullPointerException(() -> peer1.sender(1, null));\n \n-    assertIllegalArgumentException(() -> peer1.listen(-1, \"127.0.0.1\", ar -> {}));\n-    assertIllegalArgumentException(() -> peer1.listen(65536, \"127.0.0.1\", ar -> {}));\n-    assertNullPointerException(() -> peer1.listen(1, null, ar -> {}));\n-    assertNullPointerException(() -> peer1.listen(1, \"127.0.0.1\", null));\n+    assertIllegalArgumentException(() -> peer1.listen(-1, \"127.0.0.1\"));\n+    assertIllegalArgumentException(() -> peer1.listen(65536, \"127.0.0.1\"));\n+    assertNullPointerException(() -> peer1.listen(1, null));\n   }\n \n   @Test\n@@ -122,13 +114,16 @@ public void testSendReceive() throws Exception {\n         assertEquals(expected, data);\n         complete();\n       });\n-      peer2.listen(1234, \"127.0.0.1\", onSuccess(so -> latch.countDown()));\n+      peer2\n+        .listen(1234, \"127.0.0.1\")\n+        .onComplete(onSuccess(so -> latch.countDown()));\n     });\n     awaitLatch(latch);\n     Context clientContext = vertx.getOrCreateContext();\n     clientContext.runOnContext(v -> {\n       peer1 = vertx.createDatagramSocket(new DatagramSocketOptions());\n-      peer1.send(expected, 1234, \"127.0.0.1\", onSuccess(s -> {\n+      peer1.send(expected, 1234, \"127.0.0.1\")\n+        .onComplete(onSuccess(s -> {\n         assertSame(clientContext, Vertx.currentContext());\n         assertFalse(Thread.holdsLock(peer1));\n         complete();\n@@ -143,15 +138,14 @@ public void testSendReceiveLargePacket() {\n     peer1 = vertx.createDatagramSocket(new DatagramSocketOptions().setSendBufferSize(packetSize));\n     peer2 = vertx.createDatagramSocket(new DatagramSocketOptions().setReceiveBufferSize(packetSize + 16)); // OSX needs 16 more\n     peer2.exceptionHandler(t -> fail(t.getMessage()));\n-    peer2.listen(1234, \"127.0.0.1\", ar -> {\n-      assertTrue(ar.succeeded());\n+    peer2.listen(1234, \"127.0.0.1\").onComplete(onSuccess(v -> {\n       Buffer buffer = TestUtils.randomBuffer(packetSize);\n       peer2.handler(packet -> {\n         assertEquals(buffer, packet.data());\n         testComplete();\n       });\n-      peer1.send(buffer, 1234, \"127.0.0.1\", ar2 -> assertTrue(ar2.succeeded()));\n-    });\n+      peer1.send(buffer, 1234, \"127.0.0.1\").onComplete(onSuccess(ar2 -> {}));\n+    }));\n     await();\n   }\n \n@@ -160,15 +154,16 @@ public void testEndHandler() {\n     ThreadLocal<Object> stack = new ThreadLocal<>();\n     stack.set(true);\n     peer2 = vertx.createDatagramSocket(new DatagramSocketOptions());\n-    peer2.listen(1234, \"127.0.0.1\", ar -> {\n-      assertTrue(ar.succeeded());\n-      peer2.endHandler(v -> {\n-        assertTrue(Vertx.currentContext().isEventLoopContext());\n-        assertNull(stack.get());\n-        testComplete();\n-      });\n-      peer2.close();\n-    });\n+    peer2\n+      .listen(1234, \"127.0.0.1\")\n+      .onComplete(onSuccess(v1 -> {\n+        peer2.endHandler(v2 -> {\n+          assertTrue(Vertx.currentContext().isEventLoopContext());\n+          assertNull(stack.get());\n+          testComplete();\n+        });\n+        peer2.close();\n+      }));\n     await();\n   }\n \n@@ -177,14 +172,14 @@ public void testPauseResume() {\n     peer1 = vertx.createDatagramSocket(new DatagramSocketOptions());\n     peer2 = vertx.createDatagramSocket(new DatagramSocketOptions());\n     peer2.exceptionHandler(t -> fail(t.getMessage()));\n-    peer2.listen(1234, \"127.0.0.1\", ar -> {\n+    peer2\n+      .listen(1234, \"127.0.0.1\")\n+      .onComplete(onSuccess(v -> {\n       final AtomicBoolean suspendedReceive = new AtomicBoolean();\n       peer2.handler(packet -> suspendedReceive.set(true));\n       peer2.pause();\n       Buffer buffer = TestUtils.randomBuffer(128);\n-      peer1.send(buffer, 1234, \"127.0.0.1\", ar2 -> {\n-        assertTrue(ar2.succeeded());\n-      });\n+      peer1.send(buffer, 1234, \"127.0.0.1\").onComplete(onSuccess(v2 -> {}));\n       final int MAX_FAILED_ATTEMPTS = 10;\n       vertx.setTimer(1000, ignore -> {\n         Assert.assertFalse(suspendedReceive.get());\n@@ -196,9 +191,7 @@ public void testPauseResume() {\n           }\n         });\n         peer2.resume();\n-        peer1.send(buffer, 1234, \"127.0.0.1\", ar2 -> {\n-          assertTrue(ar2.succeeded());\n-        });\n+        peer1.send(buffer, 1234, \"127.0.0.1\").onComplete(onSuccess(v2 -> {}));\n         AtomicInteger failedAttempts = new AtomicInteger();\n         vertx.setPeriodic(1000, l -> {\n           if (resumedReceive.get()) {\n@@ -210,12 +203,10 @@ public void testPauseResume() {\n             fail(\"failed to receive any packet while resumed: retried \" + MAX_FAILED_ATTEMPTS + \" times\");\n             return;\n           }\n-          peer1.send(buffer, 1234, \"127.0.0.1\", ar2 -> {\n-            assertTrue(ar2.succeeded());\n-          });\n+          peer1.send(buffer, 1234, \"127.0.0.1\").onComplete(onSuccess(v2 -> {}));\n         });\n       });\n-    });\n+    }));\n     await();\n   }\n \n@@ -224,60 +215,56 @@ public void testSender() {\n     peer1 = vertx.createDatagramSocket(new DatagramSocketOptions());\n     peer2 = vertx.createDatagramSocket(new DatagramSocketOptions());\n     peer2.exceptionHandler(t -> fail(t.getMessage()));\n-    peer2.listen(1234, \"127.0.0.1\", ar -> {\n-      Buffer buffer = TestUtils.randomBuffer(128);\n-      peer2.handler(packet -> {\n-        assertEquals(buffer, packet.data());\n-        testComplete();\n-      });\n+    peer2\n+      .listen(1234, \"127.0.0.1\")\n+      .onComplete(onSuccess(ar -> {\n+        Buffer buffer = TestUtils.randomBuffer(128);\n+        peer2.handler(packet -> {\n+          assertEquals(buffer, packet.data());\n+          testComplete();\n+        });\n \n-      WriteStream<Buffer> sender1 = peer1.sender(1234, \"127.0.0.1\");\n-      sender1.write(buffer);\n-    });\n+        WriteStream<Buffer> sender1 = peer1.sender(1234, \"127.0.0.1\");\n+        sender1.write(buffer);\n+      }));\n     await();\n   }\n \n   @Test\n   public void testListenHostPort() {\n     peer2 = vertx.createDatagramSocket(new DatagramSocketOptions());\n-    peer2.listen(1234, \"127.0.0.1\", ar -> {\n-      assertTrue(ar.succeeded());\n-      testComplete();\n-    });\n+    peer2\n+      .listen(1234, \"127.0.0.1\")\n+      .onComplete(onSuccess(v -> testComplete()));\n     await();\n   }\n \n   @Test\n   public void testListenPort() {\n     peer2 = vertx.createDatagramSocket(new DatagramSocketOptions());\n-    peer2.listen(1234, \"localhost\", ar -> {\n-      assertTrue(ar.succeeded());\n-      testComplete();\n-    });\n+    peer2\n+      .listen(1234, \"localhost\")\n+      .onComplete(onSuccess(v -> testComplete()));\n     await();\n   }\n \n   @Test\n   public void testListenInetSocketAddress() {\n     peer2 = vertx.createDatagramSocket(new DatagramSocketOptions());\n-    peer2.listen(1234, \"127.0.0.1\", ar -> {\n-      assertTrue(ar.succeeded());\n-      testComplete();\n-    });\n+    peer2\n+      .listen(1234, \"127.0.0.1\")\n+      .onComplete(onSuccess(v -> testComplete()));\n     await();\n   }\n \n   @Test\n   public void testListenSamePortMultipleTimes() {\n     peer2 = vertx.createDatagramSocket(new DatagramSocketOptions());\n     peer1 = vertx.createDatagramSocket(new DatagramSocketOptions());\n-    peer2.listen(1234, \"127.0.0.1\", ar1 -> {\n-      assertTrue(ar1.succeeded());\n-      peer1.listen(1234, \"127.0.0.1\", ar2 -> {\n-        assertTrue(ar2.failed());\n-        testComplete();\n-      });\n-    });\n+    peer2.listen(1234, \"127.0.0.1\")\n+      .onComplete(onSuccess(v -> peer1\n+        .listen(1234, \"127.0.0.1\")\n+        .onComplete(onFailure(err -> testComplete()))));\n     await();\n   }\n \n@@ -287,47 +274,42 @@ public void testEcho() {\n     peer2 = vertx.createDatagramSocket(new DatagramSocketOptions());\n     peer1.exceptionHandler(t -> fail(t.getMessage()));\n     peer2.exceptionHandler(t -> fail(t.getMessage()));\n-    peer2.listen(1234, \"127.0.0.1\", ar -> {\n-      assertTrue(ar.succeeded());\n+    peer2.listen(1234, \"127.0.0.1\").onComplete(onSuccess(v -> {\n       Buffer buffer = TestUtils.randomBuffer(128);\n       peer2.handler(packet -> {\n         assertEquals(\"127.0.0.1\", packet.sender().host());\n         assertEquals(1235, packet.sender().port());\n         assertEquals(buffer, packet.data());\n-        peer2.send(packet.data(), 1235, \"127.0.0.1\", ar2 -> assertTrue(ar2.succeeded()));\n+        peer2.send(packet.data(), 1235, \"127.0.0.1\").onComplete(onSuccess(v2 -> {}));\n       });\n-      peer1.listen(1235, \"127.0.0.1\", ar2 -> {\n+      peer1.listen(1235, \"127.0.0.1\").onComplete(onSuccess(v2 -> {\n         peer1.handler(packet -> {\n           assertEquals(buffer, packet.data());\n           assertEquals(\"127.0.0.1\", packet.sender().host());\n           assertEquals(1234, packet.sender().port());\n           testComplete();\n         });\n-        peer1.send(buffer, 1234, \"127.0.0.1\", ar3 -> assertTrue(ar3.succeeded()));\n-      });\n-    });\n+        peer1.send(buffer, 1234, \"127.0.0.1\").onComplete(onSuccess(v3 -> {}));\n+      }));\n+    }));\n     await();\n   }\n \n   @Test\n   public void testSendAfterCloseFails() {\n     peer1 = vertx.createDatagramSocket(new DatagramSocketOptions());\n     peer2 = vertx.createDatagramSocket(new DatagramSocketOptions());\n-    peer1.close(ar -> {\n-      assertTrue(ar.succeeded());\n-      peer1.send(\"Test\", 1234, \"127.0.0.1\", ar2 -> {\n-        assertTrue(ar2.failed());\n+    peer1.close().onComplete(onSuccess(v1 -> {\n+      peer1.send(\"Test\", 1234, \"127.0.0.1\").onComplete(onFailure(err1 -> {\n         peer1 = null;\n-        peer2.close(ar3 -> {\n-          assertTrue(ar3.succeeded());\n-          peer2.send(\"Test\", 1234, \"127.0.0.1\", ar4 -> {\n-            assertTrue(ar4.failed());\n+        peer2.close().onComplete(onSuccess(v2 -> {\n+          peer2.send(\"Test\", 1234, \"127.0.0.1\").onComplete(onFailure(err2 -> {\n             peer2 = null;\n             testComplete();\n-          });\n-        });\n-      });\n-    });\n+          }));\n+        }));\n+      }));\n+    }));\n     await();\n   }\n \n@@ -339,27 +321,21 @@ public void testBroadcast() {\n     peer1 = vertx.createDatagramSocket(new DatagramSocketOptions().setBroadcast(true));\n     peer2 = vertx.createDatagramSocket(new DatagramSocketOptions().setBroadcast(true));\n     peer2.exceptionHandler(t -> fail(t.getMessage()));\n-    peer2.listen(1234, \"0.0.0.0\", ar1 -> {\n-      assertTrue(ar1.succeeded());\n+    peer2.listen(1234, \"0.0.0.0\").onComplete(onSuccess(v -> {\n       Buffer buffer = TestUtils.randomBuffer(128);\n       peer2.handler(packet -> {\n         assertEquals(buffer, packet.data());\n         testComplete();\n       });\n-      peer1.send(buffer, 1234, \"255.255.255.255\", ar2 -> {\n-        assertTrue(ar2.succeeded());\n-      });\n-    });\n+      peer1.send(buffer, 1234, \"255.255.255.255\").onComplete(onSuccess(v2 -> {}));\n+    }));\n     await();\n   }\n \n   @Test\n   public void testBroadcastFailsIfNotConfigured() {\n     peer1 = vertx.createDatagramSocket(new DatagramSocketOptions());\n-    peer1.send(\"test\", 1234, \"255.255.255.255\", ar -> {\n-      assertTrue(ar.failed());\n-      testComplete();\n-    });\n+    peer1.send(\"test\", 1234, \"255.255.255.255\").onComplete(onFailure(err -> testComplete()));\n     await();\n   }\n \n@@ -372,9 +348,9 @@ public void testPause() {\n   public void testMulticastJoinLeave() throws Exception {\n     String iface = NetworkInterface.getByInetAddress(InetAddress.getByName(\"127.0.0.1\")).getName();\n     testMulticastJoinLeave(\"0.0.0.0\", new DatagramSocketOptions(), new DatagramSocketOptions().setMulticastNetworkInterface(iface), (groupAddress, handler) -> {\n-      peer1.listenMulticastGroup(groupAddress, iface, null, handler);\n+      peer1.listenMulticastGroup(groupAddress, iface, null).onComplete(handler);\n     }, (groupAddress, handler) -> {\n-      peer1.unlistenMulticastGroup(groupAddress, iface, null, handler);\n+      peer1.unlistenMulticastGroup(groupAddress, iface, null).onComplete(handler);\n     });\n   }\n \n@@ -383,9 +359,9 @@ public void testMulticastJoinLeaveReuseMulticastNetworkInterface() throws Except\n     String iface = NetworkInterface.getByInetAddress(InetAddress.getByName(\"127.0.0.1\")).getName();\n     DatagramSocketOptions options = new DatagramSocketOptions().setMulticastNetworkInterface(iface);\n     testMulticastJoinLeave(\"0.0.0.0\", options, options, (groupAddress, handler) -> {\n-      peer1.listenMulticastGroup(groupAddress, handler);\n+      peer1.listenMulticastGroup(groupAddress).onComplete(handler);\n     }, (groupAddress, handler) -> {\n-      peer1.unlistenMulticastGroup(groupAddress, handler);\n+      peer1.unlistenMulticastGroup(groupAddress).onComplete(handler);\n     });\n   }\n \n@@ -395,9 +371,9 @@ public void testMulticastJoinLeaveBindOnMulticastGroup() throws Exception {\n     String iface = NetworkInterface.getByInetAddress(InetAddress.getByName(\"127.0.0.1\")).getName();\n     DatagramSocketOptions options = new DatagramSocketOptions().setMulticastNetworkInterface(iface);\n     testMulticastJoinLeave(\"230.0.0.1\", options, options, (groupAddress, handler) -> {\n-      peer1.listenMulticastGroup(groupAddress, handler);\n+      peer1.listenMulticastGroup(groupAddress).onComplete(handler);\n     }, (groupAddress, handler) -> {\n-      peer1.unlistenMulticastGroup(groupAddress, handler);\n+      peer1.unlistenMulticastGroup(groupAddress).onComplete(handler);\n     });\n   }\n \n@@ -420,9 +396,9 @@ private void testMulticastJoinLeave(String bindAddress,\n       received.set(true);\n     });\n \n-    peer1.listen(1234, bindAddress, onSuccess(v1 -> {\n+    peer1.listen(1234, bindAddress).onComplete(onSuccess(v1 -> {\n       join.accept(groupAddress, onSuccess(v2 -> {\n-        peer2.send(buffer, 1234, groupAddress, onSuccess(ar3 -> {\n+        peer2.send(buffer, 1234, groupAddress).onComplete(onSuccess(ar3 -> {\n           // leave group in 1 second so give it enough time to really receive the packet first\n           vertx.setTimer(1000, id -> {\n             leave.accept(groupAddress, onSuccess(ar4 -> {\n@@ -431,7 +407,7 @@ private void testMulticastJoinLeave(String bindAddress,\n                 // Should not receive any more event as it left the group\n                 receivedAfter.set(true);\n               });\n-              peer2.send(buffer, 1234, groupAddress, onSuccess(v5 -> {\n+              peer2.send(buffer, 1234, groupAddress).onComplete(onSuccess(v5 -> {\n                 // schedule a timer which will check in 1 second if we received a message after the group\n                 // was left before\n                 vertx.setTimer(1000, id2 -> {\n@@ -451,18 +427,14 @@ private void testMulticastJoinLeave(String bindAddress,\n   @Test\n   public void testMulticastJoinWithoutNetworkInterface() {\n     peer1 = vertx.createDatagramSocket(new DatagramSocketOptions());\n-    peer1.listenMulticastGroup(\"230.0.0.1\", onFailure(err -> {\n-      testComplete();\n-    }));\n+    peer1.listenMulticastGroup(\"230.0.0.1\").onComplete(onFailure(err -> testComplete()));\n     await();\n   }\n \n   @Test\n   public void testMulticastLeaveWithoutNetworkInterface() {\n     peer1 = vertx.createDatagramSocket(new DatagramSocketOptions());\n-    peer1.unlistenMulticastGroup(\"230.0.0.1\", onFailure(err -> {\n-      testComplete();\n-    }));\n+    peer1.unlistenMulticastGroup(\"230.0.0.1\").onComplete(onFailure(err -> testComplete()));\n     await();\n   }\n \n@@ -593,11 +565,10 @@ public void testOptionsCopied() {\n     // Listening on same address:port so will only work if reuseAddress = true\n     // Set to false, but because options are copied internally should still work\n     options.setReuseAddress(false);\n-    peer1.listen(1234, \"127.0.0.1\", onSuccess(v1 -> {\n-      peer2.listen(1234, \"127.0.0.1\", onSuccess(v2 -> {\n-        testComplete();\n-      }));\n-    }));\n+    peer1.listen(1234, \"127.0.0.1\")\n+      .compose(v -> peer2\n+        .listen(1234, \"127.0.0.1\"))\n+      .onComplete(onSuccess(v -> testComplete()));\n     await();\n   }\n \n@@ -624,15 +595,14 @@ private TestLoggerFactory testLogging(DatagramSocketOptions sendOptions, Datagra\n       peer1 = vertx.createDatagramSocket(sendOptions);\n       peer2 = vertx.createDatagramSocket(listenOptions);\n       peer2.exceptionHandler(t -> fail(t.getMessage()));\n-      peer2.listen(1234, \"127.0.0.1\", ar -> {\n-        assertTrue(ar.succeeded());\n+      peer2.listen(1234, \"127.0.0.1\").onComplete(onSuccess(ar -> {\n         Buffer buffer = TestUtils.randomBuffer(128);\n         peer2.handler(packet -> {\n           assertEquals(buffer, packet.data());\n           testComplete();\n         });\n-        peer1.send(buffer, 1234, \"127.0.0.1\", ar2 -> assertTrue(ar2.succeeded()));\n-      });\n+        peer1.send(buffer, 1234, \"127.0.0.1\").onComplete(onSuccess(v -> {}));\n+      }));\n       await();\n     });\n   }\n@@ -642,25 +612,26 @@ public void testWorker() {\n     waitFor(2);\n     Buffer expected = TestUtils.randomBuffer(128);\n     vertx.deployVerticle(new AbstractVerticle() {\n-      @Override\n-      public void start(Promise<Void> startPromise) {\n-        peer2 = vertx.createDatagramSocket(new DatagramSocketOptions());\n-        peer2.exceptionHandler(t -> fail(t.getMessage()));\n-        peer2.handler(packet -> {\n-          assertTrue(Context.isOnWorkerThread());\n-          assertSame(context, Vertx.currentContext());\n-          complete();\n-        });\n-        peer2.listen(1234, \"127.0.0.1\")\n-          .<Void>mapEmpty()\n-          .onComplete(startPromise);\n-      }\n-    }, new DeploymentOptions().setWorker(true), onSuccess(id -> {\n-      peer1 = vertx.createDatagramSocket(new DatagramSocketOptions());\n-      peer1.send(expected, 1234, \"127.0.0.1\", onSuccess(s -> {\n-        complete();\n+        @Override\n+        public void start(Promise<Void> startPromise) {\n+          peer2 = vertx.createDatagramSocket(new DatagramSocketOptions());\n+          peer2.exceptionHandler(t -> fail(t.getMessage()));\n+          peer2.handler(packet -> {\n+            assertTrue(Context.isOnWorkerThread());\n+            assertSame(context, Vertx.currentContext());\n+            complete();\n+          });\n+          peer2.listen(1234, \"127.0.0.1\")\n+            .<Void>mapEmpty()\n+            .onComplete(startPromise);\n+        }\n+      }, new DeploymentOptions().setWorker(true))\n+      .onComplete(onSuccess(id -> {\n+        peer1 = vertx.createDatagramSocket(new DatagramSocketOptions());\n+        peer1\n+          .send(expected, 1234, \"127.0.0.1\")\n+          .onComplete(onSuccess(s -> complete()));\n       }));\n-    }));\n     await();\n   }\n }",
      "parent_sha": "5d96839834fec719b2bce268bf396aa4bae6c8a3"
    }
  },
  {
    "oid": "a8b7ccf1ec6e2653d607b135a88496aae71fb00e",
    "message": "Improve MetricsTest",
    "date": "2020-11-19T07:25:22Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/a8b7ccf1ec6e2653d607b135a88496aae71fb00e",
    "details": {
      "sha": "862dd6ca44bb1b5f42b3cfa3dcf4f028725d9ace",
      "filename": "src/test/java/io/vertx/core/spi/metrics/MetricsTest.java",
      "status": "modified",
      "additions": 17,
      "deletions": 22,
      "changes": 39,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/a8b7ccf1ec6e2653d607b135a88496aae71fb00e/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fspi%2Fmetrics%2FMetricsTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/a8b7ccf1ec6e2653d607b135a88496aae71fb00e/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fspi%2Fmetrics%2FMetricsTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fspi%2Fmetrics%2FMetricsTest.java?ref=a8b7ccf1ec6e2653d607b135a88496aae71fb00e",
      "patch": "@@ -900,7 +900,7 @@ private void testDatagram(String host, Consumer<PacketMetric> checker) throws Ex\n   }\n \n   @Test\n-  public void testThreadPoolMetricsWithExecuteBlocking() {\n+  public void testThreadPoolMetricsWithExecuteBlocking() throws Exception {\n     Map<String, PoolMetrics> all = FakePoolMetrics.getPoolMetrics();\n \n     FakePoolMetrics metrics = (FakePoolMetrics) all.get(\"vert.x-worker-thread\");\n@@ -910,7 +910,7 @@ public void testThreadPoolMetricsWithExecuteBlocking() {\n \n     Handler<Promise<Void>> job = getSomeDumbTask();\n \n-    AtomicInteger counter = new AtomicInteger();\n+    CountDownLatch counter = new CountDownLatch(100);\n     AtomicBoolean hadWaitingQueue = new AtomicBoolean();\n     AtomicBoolean hadIdle = new AtomicBoolean();\n     AtomicBoolean hadRunning = new AtomicBoolean();\n@@ -927,17 +927,15 @@ public void testThreadPoolMetricsWithExecuteBlocking() {\n             if (metrics.numberOfRunningTasks() > 0) {\n               hadRunning.set(true);\n             }\n-            if (counter.incrementAndGet() == 100) {\n-              testComplete();\n-            }\n+            counter.countDown();\n           }\n       );\n     }\n \n-    await();\n+    awaitLatch(counter);\n \n-    assertEquals(metrics.numberOfSubmittedTask(), 100);\n-    assertEquals(metrics.numberOfCompletedTasks(), 100);\n+    assertWaitUntil(() -> metrics.numberOfSubmittedTask() == 100);\n+    assertWaitUntil(() -> metrics.numberOfCompletedTasks() == 100);\n     assertTrue(hadIdle.get());\n     assertTrue(hadWaitingQueue.get());\n     assertTrue(hadRunning.get());\n@@ -948,22 +946,23 @@ public void testThreadPoolMetricsWithExecuteBlocking() {\n   }\n \n   @Test\n-  public void testThreadPoolMetricsWithInternalExecuteBlocking() {\n+  public void testThreadPoolMetricsWithInternalExecuteBlocking() throws InterruptedException {\n     Map<String, PoolMetrics> all = FakePoolMetrics.getPoolMetrics();\n     FakePoolMetrics metrics = (FakePoolMetrics) all.get(\"vert.x-internal-blocking\");\n \n     assertThat(metrics.getPoolSize(), is(getOptions().getInternalBlockingPoolSize()));\n     assertThat(metrics.numberOfIdleThreads(), is(getOptions().getInternalBlockingPoolSize()));\n \n-    AtomicInteger counter = new AtomicInteger();\n+    int num = VertxOptions.DEFAULT_INTERNAL_BLOCKING_POOL_SIZE;\n+    int count = num * 5;\n+\n+    CountDownLatch counter = new CountDownLatch(count);\n     AtomicBoolean hadWaitingQueue = new AtomicBoolean();\n     AtomicBoolean hadIdle = new AtomicBoolean();\n     AtomicBoolean hadRunning = new AtomicBoolean();\n \n     VertxInternal v = (VertxInternal) vertx;\n     Map<Integer, CountDownLatch> latches = new HashMap<>();\n-    int num = VertxOptions.DEFAULT_INTERNAL_BLOCKING_POOL_SIZE;\n-    int count = num * 5;\n     for (int i = 0; i < count; i++) {\n       CountDownLatch latch = latches.computeIfAbsent(i / num, k -> new CountDownLatch(num));\n       v.executeBlockingInternal(fut -> {\n@@ -986,13 +985,11 @@ public void testThreadPoolMetricsWithInternalExecuteBlocking() {\n         if (metrics.numberOfIdleThreads() > 0) {\n           hadIdle.set(true);\n         }\n-        if (counter.incrementAndGet() == count) {\n-          testComplete();\n-        }\n+        counter.countDown();\n       });\n     }\n \n-    await();\n+    awaitLatch(counter);\n \n     assertEquals(metrics.numberOfSubmittedTask(), 100);\n     assertEquals(metrics.numberOfCompletedTasks(), 100);\n@@ -1075,7 +1072,7 @@ public void testThreadPoolMetricsWithWorkerVerticle() throws Exception {\n   }\n \n   @Test\n-  public void testThreadPoolMetricsWithNamedExecuteBlocking() {\n+  public void testThreadPoolMetricsWithNamedExecuteBlocking() throws InterruptedException {\n     vertx.close(); // Close the instance automatically created\n     vertx = Vertx.vertx(new VertxOptions().setMetricsOptions(new MetricsOptions().setEnabled(true).setFactory(new FakeMetricsFactory())));\n \n@@ -1090,7 +1087,7 @@ public void testThreadPoolMetricsWithNamedExecuteBlocking() {\n \n     Handler<Promise<Void>> job = getSomeDumbTask();\n \n-    AtomicInteger counter = new AtomicInteger();\n+    CountDownLatch counter = new CountDownLatch(100);\n     AtomicBoolean hadWaitingQueue = new AtomicBoolean();\n     AtomicBoolean hadIdle = new AtomicBoolean();\n     AtomicBoolean hadRunning = new AtomicBoolean();\n@@ -1108,13 +1105,11 @@ public void testThreadPoolMetricsWithNamedExecuteBlocking() {\n             if (metrics.numberOfRunningTasks() > 0) {\n               hadRunning.set(true);\n             }\n-            if (counter.incrementAndGet() == 100) {\n-              testComplete();\n-            }\n+            counter.countDown();\n           });\n     }\n \n-    await();\n+    awaitLatch(counter);\n \n     assertEquals(metrics.numberOfSubmittedTask(), 100);\n     assertEquals(metrics.numberOfCompletedTasks(), 100);",
      "parent_sha": "2ab62caaa9434b465b0109d40dcfac2a42921777"
    }
  },
  {
    "oid": "f30414c5cbafd13812b5730fa7ae4472d58a52f0",
    "message": "Update Http1xTest#testUnsolicitedHttpResponse to latest changes\n\nSigned-off-by: Julien Viet <julien@julienviet.com>",
    "date": "2021-03-02T16:07:42Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/f30414c5cbafd13812b5730fa7ae4472d58a52f0",
    "details": {
      "sha": "2ca1b952fa6d9e0782dc7b3048bcbe7688033e1c",
      "filename": "src/test/java/io/vertx/core/http/Http1xTest.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/f30414c5cbafd13812b5730fa7ae4472d58a52f0/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttp1xTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/f30414c5cbafd13812b5730fa7ae4472d58a52f0/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttp1xTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttp1xTest.java?ref=f30414c5cbafd13812b5730fa7ae4472d58a52f0",
      "patch": "@@ -4901,8 +4901,10 @@ public void testUnsolicitedHttpResponse() throws Exception {\n     server.listen(testAddress, onSuccess(s -> latch.countDown()));\n     awaitLatch(latch);\n     client.connectionHandler(conn -> {\n-      conn.exceptionHandler(this::fail);\n+      AtomicBoolean failed = new AtomicBoolean();\n+      conn.exceptionHandler(err -> failed.set(true));\n       conn.closeHandler(v -> {\n+        assertTrue(failed.get());\n         complete();\n       });\n     });",
      "parent_sha": "cced36c9346dca653f948939f93d9707dd091676"
    }
  },
  {
    "oid": "42d0985ff65caddf12dd77866bb67ef5700d187c",
    "message": "Minor javadoc fix",
    "date": "2016-01-18T22:00:25Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/42d0985ff65caddf12dd77866bb67ef5700d187c",
    "details": {
      "sha": "f40d8337c0f697bd77ee8267a755f2e21ede8a7a",
      "filename": "src/main/java/io/vertx/core/CompositeFuture.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/42d0985ff65caddf12dd77866bb67ef5700d187c/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2FCompositeFuture.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/42d0985ff65caddf12dd77866bb67ef5700d187c/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2FCompositeFuture.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2FCompositeFuture.java?ref=42d0985ff65caddf12dd77866bb67ef5700d187c",
      "patch": "@@ -70,7 +70,7 @@ static <T1, T2, T3, T4, T5, T6> CompositeFuture all(Future<T1> f1, Future<T2> f2\n   }\n \n   /**\n-   * Like {@link #all(Future, Future)} but with list of futures.\n+   * Like {@link #all(Future, Future)} but with a list of futures.\n    */\n   static CompositeFuture all(List<Future> futures) {\n     return CompositeFutureImpl.all(futures.toArray(new Future[futures.size()]));\n@@ -116,7 +116,7 @@ static <T1, T2, T3, T4, T5, T6> CompositeFuture any(Future<T1> f1, Future<T2> f2\n   }\n \n   /**\n-   * Like {@link #any(Future, Future)} but with 6 futures.\n+   * Like {@link #any(Future, Future)} but with a list of futures.\n    */\n   static CompositeFuture any(List<Future> futures) {\n     return CompositeFutureImpl.any(futures.toArray(new Future[futures.size()]));",
      "parent_sha": "080cad9c158012b38e88a6cc73e7f6fbed93b0a5"
    }
  },
  {
    "oid": "020af3f300d9f11e59db866f4359e6de5d78cc9e",
    "message": "removed replyAddress from sendAsyncresultFailure message",
    "date": "2016-04-06T15:38:26Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/020af3f300d9f11e59db866f4359e6de5d78cc9e",
    "details": {
      "sha": "2e6926ed065840c5534bba6014a294aa580c84dc",
      "filename": "src/main/java/io/vertx/core/eventbus/impl/HandlerRegistration.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/020af3f300d9f11e59db866f4359e6de5d78cc9e/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2Fimpl%2FHandlerRegistration.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/020af3f300d9f11e59db866f4359e6de5d78cc9e/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2Fimpl%2FHandlerRegistration.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2Fimpl%2FHandlerRegistration.java?ref=020af3f300d9f11e59db866f4359e6de5d78cc9e",
      "patch": "@@ -61,7 +61,7 @@ public HandlerRegistration(Vertx vertx, EventBusMetrics metrics, EventBusImpl ev\n     if (timeout != -1) {\n       timeoutID = vertx.setTimer(timeout, tid -> {\n         metrics.replyFailure(address, ReplyFailure.TIMEOUT);\n-        sendAsyncResultFailure(ReplyFailure.TIMEOUT, \"Timed out after waiting \" + timeout + \"(ms) for a reply. address: \" + address + \" repliedAddress: \" + repliedAddress);\n+        sendAsyncResultFailure(ReplyFailure.TIMEOUT, \"Timed out after waiting \" + timeout + \"(ms) for a reply. address: \" + address);\n       });\n     }\n   }",
      "parent_sha": "034ac460621c2d05c2981fb3ac092367392950b4"
    }
  },
  {
    "oid": "39df9cf9a455f35d2d6a2d335c9c51992a8f27f0",
    "message": "Minor improvements to SSLHelper so it can be used in a more flexible manner from gRPC",
    "date": "2018-01-12T14:37:10Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/39df9cf9a455f35d2d6a2d335c9c51992a8f27f0",
    "details": {
      "sha": "42cf751e5fbcf6bd4ccb3fe47c3ab65a96282710",
      "filename": "src/main/java/io/vertx/core/net/impl/SSLHelper.java",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/39df9cf9a455f35d2d6a2d335c9c51992a8f27f0/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2Fimpl%2FSSLHelper.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/39df9cf9a455f35d2d6a2d335c9c51992a8f27f0/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2Fimpl%2FSSLHelper.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2Fimpl%2FSSLHelper.java?ref=39df9cf9a455f35d2d6a2d335c9c51992a8f27f0",
      "patch": "@@ -405,7 +405,7 @@ public X509Certificate[] getAcceptedIssuers() {\n     };\n   }\n \n-  private void configureEngine(SSLEngine engine, boolean client, String serverName) {\n+  public void configureEngine(SSLEngine engine, String serverName) {\n     if (enabledCipherSuites != null && !enabledCipherSuites.isEmpty()) {\n       String[] toUse = enabledCipherSuites.toArray(new String[enabledCipherSuites.size()]);\n       engine.setEnabledCipherSuites(toUse);\n@@ -491,7 +491,7 @@ public synchronized void validate(VertxInternal vertx) {\n \n   public SSLEngine createEngine(SslContext sslContext) {\n     SSLEngine engine = sslContext.newEngine(ByteBufAllocator.DEFAULT);\n-    configureEngine(engine, false, null);\n+    configureEngine(engine, null);\n     return engine;\n   }\n \n@@ -503,25 +503,25 @@ public SSLEngine createEngine(VertxInternal vertx, SocketAddress socketAddress,\n     } else {\n       engine = context.newEngine(ByteBufAllocator.DEFAULT, socketAddress.host(), socketAddress.port());\n     }\n-    configureEngine(engine, client, serverName);\n+    configureEngine(engine, serverName);\n     return engine;\n   }\n \n   public SSLEngine createEngine(VertxInternal vertx, String host, int port, String serverName) {\n     SSLEngine engine = getContext(vertx, null).newEngine(ByteBufAllocator.DEFAULT, host, port);\n-    configureEngine(engine, client, serverName);\n+    configureEngine(engine, serverName);\n     return engine;\n   }\n \n   public SSLEngine createEngine(VertxInternal vertx, String host, int port) {\n     SSLEngine engine = getContext(vertx, null).newEngine(ByteBufAllocator.DEFAULT, host, port);\n-    configureEngine(engine, client, null);\n+    configureEngine(engine, null);\n     return engine;\n   }\n \n   public SSLEngine createEngine(VertxInternal vertx) {\n     SSLEngine engine = getContext(vertx, null).newEngine(ByteBufAllocator.DEFAULT);\n-    configureEngine(engine, client, null);\n+    configureEngine(engine, null);\n     return engine;\n   }\n }",
      "parent_sha": "0e5a31aad7e5038200a81a08abf822b128fa71c2"
    }
  },
  {
    "oid": "a76f0e33af6f7fdf013d5703e100c43fb6296ffe",
    "message": "in AddressResolver uses the class instead of a lambda ref to the constructor as it confuses some version of javac",
    "date": "2016-06-01T10:17:23Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/a76f0e33af6f7fdf013d5703e100c43fb6296ffe",
    "details": {
      "sha": "57c851d43b058212853aa62b06ec94d6aea38da5",
      "filename": "src/main/java/io/vertx/core/impl/AddressResolver.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/a76f0e33af6f7fdf013d5703e100c43fb6296ffe/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fimpl%2FAddressResolver.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/a76f0e33af6f7fdf013d5703e100c43fb6296ffe/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fimpl%2FAddressResolver.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fimpl%2FAddressResolver.java?ref=a76f0e33af6f7fdf013d5703e100c43fb6296ffe",
      "patch": "@@ -53,7 +53,7 @@ public class AddressResolver {\n \n   public AddressResolver(VertxImpl vertx, AddressResolverOptions options) {\n     DnsNameResolverBuilder builder = new DnsNameResolverBuilder(vertx.createEventLoopContext(null, null, new JsonObject(), Thread.currentThread().getContextClassLoader()).nettyEventLoop());\n-    builder.channelFactory(NioDatagramChannel::new);\n+    builder.channelType(NioDatagramChannel.class);\n     if (options != null) {\n       List<String> dnsServers = options.getServers();\n       if (dnsServers != null && dnsServers.size() > 0) {",
      "parent_sha": "9563ef2341c70c110dac82260b4dfb5f4233f4f4"
    }
  },
  {
    "oid": "c1b2d9ff32c4ae54b5eb6ab805f11cc716b9e2aa",
    "message": "Fixed MessageConsumerImpl failure message\n\nSigned-off-by: Thomas Segismont <tsegismont@gmail.com>",
    "date": "2020-05-05T12:56:36Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/c1b2d9ff32c4ae54b5eb6ab805f11cc716b9e2aa",
    "details": {
      "sha": "228ce837ce385f2654285b7a973618b2a4bf3310",
      "filename": "src/main/java/io/vertx/core/eventbus/impl/MessageConsumerImpl.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/c1b2d9ff32c4ae54b5eb6ab805f11cc716b9e2aa/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2Fimpl%2FMessageConsumerImpl.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/c1b2d9ff32c4ae54b5eb6ab805f11cc716b9e2aa/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2Fimpl%2FMessageConsumerImpl.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2Fimpl%2FMessageConsumerImpl.java?ref=c1b2d9ff32c4ae54b5eb6ab805f11cc716b9e2aa",
      "patch": "@@ -129,7 +129,7 @@ public synchronized Future<Void> unregister() {\n \n     Promise<Void> res = result; // Alias reference because result can become null when the onComplete callback executes\n     if (res != null) {\n-      fut.onComplete(ar -> res.tryFail(\"blah\"));\n+      fut.onComplete(ar -> res.tryFail(\"Consumer unregistered before registration completed\"));\n       result = null;\n     }\n     return fut;",
      "parent_sha": "635fdd055814ebc78c202289ecab2ccc94861c5a"
    }
  },
  {
    "oid": "c5851481a6e1a55256642b7b6443bcb152958e41",
    "message": "Call early hints handler",
    "date": "2022-11-24T21:45:42Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/c5851481a6e1a55256642b7b6443bcb152958e41",
    "details": {
      "sha": "fff20fe276082dd88c9edca64fb52925f79f55bb",
      "filename": "src/main/java/io/vertx/core/http/impl/Http1xClientConnection.java",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/c5851481a6e1a55256642b7b6443bcb152958e41/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FHttp1xClientConnection.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/c5851481a6e1a55256642b7b6443bcb152958e41/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FHttp1xClientConnection.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FHttp1xClientConnection.java?ref=c5851481a6e1a55256642b7b6443bcb152958e41",
      "patch": "@@ -358,6 +358,7 @@ Object metric() {\n     }\n \n     abstract void handleContinue();\n+    abstract void handleEarlyHints(MultiMap headers);\n     abstract void handleHead(HttpResponseHead response);\n     abstract void handleChunk(Buffer buff);\n     abstract void handleEnd(LastHttpContent trailer);\n@@ -780,8 +781,11 @@ private void handleChunk(ByteBuf chunk) {\n   }\n \n   private void handleResponseBegin(Stream stream, HttpResponseHead response) {\n-    if (response.statusCode == 100) {\n+    // How can we handle future undefined 1xx informational response codes?\n+    if (response.statusCode == HttpResponseStatus.CONTINUE.code()) {\n       stream.context.execute(null, v -> stream.handleContinue());\n+    } else if (response.statusCode == HttpResponseStatus.EARLY_HINTS.code()) {\n+      stream.context.execute(null, v -> stream.handleEarlyHints(response.headers));\n     } else {\n       HttpRequestHead request;\n       synchronized (this) {",
      "parent_sha": "62528b4fa6ac3725e5bc8daf7ed075714273b953"
    }
  },
  {
    "oid": "22606bf08650276e291308466d47f74879ec31ba",
    "message": "Add IPv4 addressType support\n\nSigned-off-by: Philipp Lehmann <github@phil.to>",
    "date": "2017-10-27T19:46:12Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/22606bf08650276e291308466d47f74879ec31ba",
    "details": {
      "sha": "a1afd7230a9a23b2def847080ed5f0e77857bbcc",
      "filename": "src/test/java/io/vertx/test/core/SocksProxy.java",
      "status": "modified",
      "additions": 23,
      "deletions": 7,
      "changes": 30,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/22606bf08650276e291308466d47f74879ec31ba/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FSocksProxy.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/22606bf08650276e291308466d47f74879ec31ba/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FSocksProxy.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FSocksProxy.java?ref=22606bf08650276e291308466d47f74879ec31ba",
      "patch": "@@ -30,7 +30,7 @@ public class SocksProxy extends TestProxyBase {\n \n   private static final Buffer clientInit = Buffer.buffer(new byte[] { 5, 1, 0 });\n   private static final Buffer serverReply = Buffer.buffer(new byte[] { 5, 0 });\n-  private static final Buffer clientRequest = Buffer.buffer(new byte[] { 5, 1, 0, 3 });\n+  private static final Buffer clientRequest = Buffer.buffer(new byte[] { 5, 1, 0 });\n   private static final Buffer connectResponse = Buffer.buffer(new byte[] { 5, 0, 0, 1, 0x7f, 0, 0, 1, 0x27, 0x10 });\n   private static final Buffer errorResponse = Buffer.buffer(new byte[] { 5, 4, 0, 1, 0, 0, 0, 0, 0, 0 });\n \n@@ -73,13 +73,29 @@ public void start(Vertx vertx, Handler<Void> finishedHandler) {\n           if (!buffer2.getBuffer(0, clientRequest.length()).equals(clientRequest)) {\n             throw new IllegalStateException(\"expected \" + toHex(clientRequest) + \", got \" + toHex(buffer2));\n           }\n-          int stringLen = buffer2.getUnsignedByte(4);\n-          log.debug(\"string len \" + stringLen);\n-          if (buffer2.length() != 7 + stringLen) {\n-            throw new IllegalStateException(\"format error in client request, got \" + toHex(buffer2));\n+          int addressType = buffer2.getUnsignedByte(3);\n+          String host;\n+          int port;\n+          if(addressType == 1) {\n+            if (buffer2.length() != 10) {\n+              throw new IllegalStateException(\"format error in client request (attribute type ipv4), got \" + toHex(buffer2));\n+            }\n+            host = buffer2.getUnsignedByte(4) + \".\" +\n+              buffer2.getUnsignedByte(5) + \".\" + \n+              buffer2.getUnsignedByte(6) + \".\" + \n+              buffer2.getUnsignedByte(7);\n+            port = buffer2.getUnsignedShort(8);  \n+          } else if(addressType == 3) {\n+            int stringLen = buffer2.getUnsignedByte(4);\n+            log.debug(\"string len \" + stringLen);\n+            if (buffer2.length() != 7 + stringLen) {\n+              throw new IllegalStateException(\"format error in client request (attribute type domain name), got \" + toHex(buffer2));\n+            }\n+            host = buffer2.getString(5, 5 + stringLen);\n+            port = buffer2.getUnsignedShort(5 + stringLen);  \n+          } else {\n+            throw new IllegalStateException(\"expected address type ip (v4) or name, got \" + addressType);\n           }\n-          String host = buffer2.getString(5, 5 + stringLen);\n-          int port = buffer2.getUnsignedShort(5 + stringLen);\n           log.debug(\"got request: \" + toHex(buffer2));\n           log.debug(\"connect: \" + host + \":\" + port);\n           socket.handler(null);",
      "parent_sha": "56a6c133d59a721a7e79a21ed7b6a499c624e9db"
    }
  },
  {
    "oid": "1b4e461e437976266ad24177a866ece157e88fa8",
    "message": "Improve test that does not pass reliably on Windows",
    "date": "2022-03-24T10:07:34Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/1b4e461e437976266ad24177a866ece157e88fa8",
    "details": {
      "sha": "c02f759910f0740f261e95e6fa04026dd5168afb",
      "filename": "src/test/java/io/vertx/core/http/Http1xTest.java",
      "status": "modified",
      "additions": 9,
      "deletions": 3,
      "changes": 12,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/1b4e461e437976266ad24177a866ece157e88fa8/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttp1xTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/1b4e461e437976266ad24177a866ece157e88fa8/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttp1xTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2FHttp1xTest.java?ref=1b4e461e437976266ad24177a866ece157e88fa8",
      "patch": "@@ -5296,12 +5296,18 @@ private void testNetSocketUpgradeSuccess(Buffer payload) {\n   @Test\n   public void testClientEventLoopSize() throws Exception {\n     Assume.assumeTrue(\"Domain socket don't pass this test\", testAddress.isInetSocket());\n+    int size = 4;\n+    int maxPoolSize = size + 2;\n+    List<HttpServerRequest> requests = new ArrayList<>();\n     server.requestHandler(req -> {\n-      req.response().end();\n+      requests.add(req);\n+      if (requests.size() == maxPoolSize) {\n+        requests.forEach(_req -> _req.response().end());\n+      } else if (requests.size() > maxPoolSize) {\n+        req.response().end();\n+      }\n     });\n     startServer();\n-    int size = 4;\n-    int maxPoolSize = size + 2;\n     client.close();\n     client = vertx.createHttpClient(new HttpClientOptions()\n       .setMaxPoolSize(maxPoolSize)",
      "parent_sha": "14551ebf842ca74cd423665402a0d80347b917e1"
    }
  },
  {
    "oid": "57bdd5d76bd383dc9a19dcc22a3f2295ba4222f7",
    "message": "Remove callbacks from ClusteredEventBusTest",
    "date": "2023-03-12T15:15:07Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/57bdd5d76bd383dc9a19dcc22a3f2295ba4222f7",
    "details": {
      "sha": "e72b66dfe50044b869bbd51727ceff6325e12e83",
      "filename": "src/test/java/io/vertx/core/eventbus/ClusteredEventBusTest.java",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/57bdd5d76bd383dc9a19dcc22a3f2295ba4222f7/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2FClusteredEventBusTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/57bdd5d76bd383dc9a19dcc22a3f2295ba4222f7/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2FClusteredEventBusTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Feventbus%2FClusteredEventBusTest.java?ref=57bdd5d76bd383dc9a19dcc22a3f2295ba4222f7",
      "patch": "@@ -244,7 +244,7 @@ public void testConsumerHandlesCompletionAsynchronously2() {\n   @Test\n   public void testSubsRemovedForClosedNode() throws Exception {\n     testSubsRemoved(latch -> {\n-      vertices[1].close(onSuccess(v -> {\n+      vertices[1].close().onComplete(onSuccess(v -> {\n         latch.countDown();\n       }));\n     });\n@@ -369,7 +369,7 @@ public void testLocalOnlyDoesNotApplyToReplies() {\n     vertices[1].eventBus().consumer(ADDRESS1).handler(msg -> {\n       msg.reply(\"pong\", new DeliveryOptions().setLocalOnly(true));\n     }).completionHandler(onSuccess(v -> {\n-      vertices[0].eventBus().request(ADDRESS1, \"ping\", new DeliveryOptions().setSendTimeout(500), onSuccess(msg -> testComplete()));\n+      vertices[0].eventBus().request(ADDRESS1, \"ping\", new DeliveryOptions().setSendTimeout(500)).onComplete(onSuccess(msg -> testComplete()));\n     }));\n     await();\n   }\n@@ -386,7 +386,7 @@ public void testImmediateUnregistration() {\n       assertEquals(0, val);\n     });\n     consumer.handler(msg -> {});\n-    consumer.unregister(onSuccess(v -> {\n+    consumer.unregister().onComplete(onSuccess(v -> {\n       int val = completionCount.getAndIncrement();\n       assertEquals(1, val);\n       testComplete();\n@@ -424,15 +424,15 @@ public boolean wantsUpdatesFor(String address) {\n       .completionHandler(onSuccess(v1 -> updateLatch.countDown()));\n     awaitLatch(updateLatch);\n     MessageProducer<String> producer = vertices[0].eventBus().sender(ADDRESS1);\n-    producer.write(\"body\", onSuccess(v2 -> complete()));\n+    producer.write(\"body\").onComplete(onSuccess(v2 -> complete()));\n     await();\n   }\n \n   @Test\n   public void testSendWriteHandlerNoConsumer() {\n     startNodes(2);\n     MessageProducer<String> producer = vertices[0].eventBus().sender(ADDRESS1);\n-    producer.write(\"body\", onFailure(err -> {\n+    producer.write(\"body\").onComplete(onFailure(err -> {\n       assertTrue(err instanceof ReplyException);\n       ReplyException replyException = (ReplyException) err;\n       assertEquals(-1, replyException.failureCode());\n@@ -450,7 +450,7 @@ public void testPublishWriteHandler() {\n       .consumer(ADDRESS1, msg -> complete())\n       .completionHandler(onSuccess(v1 -> {\n         MessageProducer<String> producer = vertices[0].eventBus().publisher(ADDRESS1);\n-        producer.write(\"body\", onSuccess(v -> complete()));\n+        producer.write(\"body\").onComplete(onSuccess(v -> complete()));\n       }));\n     await();\n   }\n@@ -459,7 +459,7 @@ public void testPublishWriteHandler() {\n   public void testPublishWriteHandlerNoConsumer() {\n     startNodes(2);\n     MessageProducer<String> producer = vertices[0].eventBus().publisher(ADDRESS1);\n-    producer.write(\"body\", onFailure(err -> {\n+    producer.write(\"body\").onComplete(onFailure(err -> {\n       assertTrue(err instanceof ReplyException);\n       ReplyException replyException = (ReplyException) err;\n       assertEquals(-1, replyException.failureCode());\n@@ -481,7 +481,7 @@ public void testWriteHandlerConnectFailure() {\n       .consumer(ADDRESS1, msg -> {})\n       .completionHandler(onSuccess(v1 -> {\n         MessageProducer<String> producer = vertices[0].eventBus().sender(ADDRESS1);\n-        producer.write(\"body\", onFailure(err -> {\n+        producer.write(\"body\").onComplete(onFailure(err -> {\n           testComplete();\n         }));\n       }));",
      "parent_sha": "c2cce4476e9f72e1869560d54804aefd820ce906"
    }
  },
  {
    "oid": "991296401a3cce71da37b70324367acd51d15f30",
    "message": "Fixed non deterministic test",
    "date": "2015-05-27T14:46:22Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/991296401a3cce71da37b70324367acd51d15f30",
    "details": {
      "sha": "91c9aa3f0ff607055b12ca3a0ed5974ba88d4839",
      "filename": "src/test/java/io/vertx/test/core/MetricsTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/991296401a3cce71da37b70324367acd51d15f30/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FMetricsTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/991296401a3cce71da37b70324367acd51d15f30/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FMetricsTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FMetricsTest.java?ref=991296401a3cce71da37b70324367acd51d15f30",
      "patch": "@@ -270,7 +270,8 @@ private void testHandlerProcessMessage(Vertx from, Vertx to, int expectedLocalCo\n         assertEquals(ADDRESS1, registration.address);\n         assertEquals(false, registration.replyHandler);\n         assertEquals(1, registration.beginCount.get());\n-        assertEquals(1, registration.endCount.get());\n+        // This might take a little time\n+        waitUntil(() -> 1 == registration.endCount.get());\n         assertEquals(0, registration.failureCount.get());\n         assertEquals(expectedLocalCoult, registration.localCount.get());\n         testComplete();",
      "parent_sha": "347325f1ae8433458aff198756976217f70fe5f8"
    }
  },
  {
    "oid": "087d9f48420ff657ca67cd6a36ce76c845abcac2",
    "message": "Use a stack-less TimeoutException when timing out an HttpClientRequest - fixes #2419",
    "date": "2018-04-25T08:36:20Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/087d9f48420ff657ca67cd6a36ce76c845abcac2",
    "details": {
      "sha": "0e12dc581eeea5ae71aeb058600ff30fb05b67e8",
      "filename": "src/main/java/io/vertx/core/http/impl/HttpClientRequestBase.java",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/087d9f48420ff657ca67cd6a36ce76c845abcac2/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FHttpClientRequestBase.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/087d9f48420ff657ca67cd6a36ce76c845abcac2/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FHttpClientRequestBase.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2FHttpClientRequestBase.java?ref=087d9f48420ff657ca67cd6a36ce76c845abcac2",
      "patch": "@@ -178,7 +178,14 @@ private void handleTimeout(long timeoutMs) {\n   }\n \n   private void timeout(long timeoutMs) {\n-    handleException(new TimeoutException(\"The timeout period of \" + timeoutMs + \"ms has been exceeded while executing \" + method + \" \" + uri + \" for host \" + host));\n+    String msg = \"The timeout period of \" + timeoutMs + \"ms has been exceeded while executing \" + method + \" \" + uri + \" for host \" + host;\n+    // Use a stack-less exception\n+    handleException(new TimeoutException(msg) {\n+      @Override\n+      public synchronized Throwable fillInStackTrace() {\n+        return this;\n+      }\n+    });\n   }\n \n   synchronized void dataReceived() {",
      "parent_sha": "b3a9401a67cb710d2c633ccfb1637a78e83d41c4"
    }
  },
  {
    "oid": "26709f3286224a12e7ff37c416cd6af9dabcb021",
    "message": "Change from Object-param constructor to static factory method\n\nSigned-off-by: Luke Hutchison <luke.hutch@gmail.com>",
    "date": "2017-02-02T12:02:52Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/26709f3286224a12e7ff37c416cd6af9dabcb021",
    "details": {
      "sha": "518f073b097a97f1eafff8a4529f969d0e687eed",
      "filename": "src/main/java/io/vertx/core/json/JsonObject.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/26709f3286224a12e7ff37c416cd6af9dabcb021/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fjson%2FJsonObject.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/26709f3286224a12e7ff37c416cd6af9dabcb021/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fjson%2FJsonObject.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fjson%2FJsonObject.java?ref=26709f3286224a12e7ff37c416cd6af9dabcb021",
      "patch": "@@ -79,8 +79,8 @@ public JsonObject(Map<String, Object> map) {\n    *          if conversion fails due to an incompatible type.\n    */\n   @SuppressWarnings(\"unchecked\")\n-  public JsonObject(Object obj) {\n-    this((Map<String, Object>) Json.mapper.convertValue(obj, Map.class));\n+  public static JsonObject fromInstance(Object obj) {\n+    return new JsonObject((Map<String, Object>) Json.mapper.convertValue(obj, Map.class));\n   }\n \n   /**",
      "parent_sha": "2acb3b6a0706b8fb74b3c7c369b2fc7a83879fa5"
    }
  },
  {
    "oid": "b93ebfda83d2ee6e94ba1406f6754fdd0ec55974",
    "message": "Remove unused code\n\nSigned-off-by: Ken Finnigan <ken@kenfinnigan.me>",
    "date": "2021-03-30T12:38:05Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/b93ebfda83d2ee6e94ba1406f6754fdd0ec55974",
    "details": {
      "sha": "a1de60ec6a33d0d534e9ed99b899d78e46c93c38",
      "filename": "src/main/java/io/vertx/core/spi/VertxTracerFactory.java",
      "status": "modified",
      "additions": 1,
      "deletions": 8,
      "changes": 9,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/b93ebfda83d2ee6e94ba1406f6754fdd0ec55974/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fspi%2FVertxTracerFactory.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/b93ebfda83d2ee6e94ba1406f6754fdd0ec55974/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fspi%2FVertxTracerFactory.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fspi%2FVertxTracerFactory.java?ref=b93ebfda83d2ee6e94ba1406f6754fdd0ec55974",
      "patch": "@@ -11,7 +11,6 @@\n \n package io.vertx.core.spi;\n \n-import io.vertx.core.VertxOptions;\n import io.vertx.core.impl.VertxBuilder;\n import io.vertx.core.json.JsonObject;\n import io.vertx.core.spi.tracing.VertxTracer;\n@@ -33,13 +32,7 @@ public interface VertxTracerFactory extends VertxServiceProvider {\n   @Override\n   default void init(VertxBuilder builder) {\n     if (builder.tracer() == null) {\n-      VertxOptions options = builder.options();\n-      TracingOptions tracingOptions = options.getTracingOptions();\n-      if (tracingOptions == null) {\n-        tracingOptions = newOptions();\n-        builder.options().setTracingOptions(tracingOptions);\n-      }\n-      builder.tracer(tracer(tracingOptions));\n+      builder.tracer(tracer(builder.options().getTracingOptions()));\n     }\n   }\n ",
      "parent_sha": "0e3e157eeb0a3376a0e1a52334635a72a2e544fc"
    }
  },
  {
    "oid": "111b9aa03a2fb6cda449f4a6c07fbec548a0593f",
    "message": "Minor: covariant override of copy() in JdkSSLEngineOptions",
    "date": "2019-02-18T18:18:25Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/111b9aa03a2fb6cda449f4a6c07fbec548a0593f",
    "details": {
      "sha": "4e68ae97467f0afca7814ae06b6928507041a1e4",
      "filename": "src/main/java/io/vertx/core/net/JdkSSLEngineOptions.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/111b9aa03a2fb6cda449f4a6c07fbec548a0593f/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2FJdkSSLEngineOptions.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/111b9aa03a2fb6cda449f4a6c07fbec548a0593f/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2FJdkSSLEngineOptions.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2FJdkSSLEngineOptions.java?ref=111b9aa03a2fb6cda449f4a6c07fbec548a0593f",
      "patch": "@@ -79,7 +79,7 @@ public boolean equals(Object o) {\n   }\n \n   @Override\n-  public SSLEngineOptions copy() {\n+  public JdkSSLEngineOptions copy() {\n     return new JdkSSLEngineOptions();\n   }\n }",
      "parent_sha": "10c6f90d8282b90f4a14a4b9907bc82104a2df24"
    }
  },
  {
    "oid": "e613135226e95c804c7eae86ebfe49ec29ee5d6f",
    "message": "Minor",
    "date": "2017-08-01T08:17:42Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/e613135226e95c804c7eae86ebfe49ec29ee5d6f",
    "details": {
      "sha": "ad8b9f93926f8825681db4885865c354bb020a45",
      "filename": "src/main/java/io/vertx/core/net/TCPSSLOptions.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/e613135226e95c804c7eae86ebfe49ec29ee5d6f/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2FTCPSSLOptions.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/e613135226e95c804c7eae86ebfe49ec29ee5d6f/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2FTCPSSLOptions.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2FTCPSSLOptions.java?ref=e613135226e95c804c7eae86ebfe49ec29ee5d6f",
      "patch": "@@ -149,7 +149,7 @@ private void init() {\n     crlPaths = new ArrayList<>();\n     crlValues = new ArrayList<>();\n     useAlpn = DEFAULT_USE_ALPN;\n-    sslEngineOptions = null;\n+    sslEngineOptions = DEFAULT_SSL_ENGINE;\n   }\n \n   /**",
      "parent_sha": "fc0baaf193bc03375b326f04ca0b62ff1c2ba831"
    }
  },
  {
    "oid": "70333e35f54f8684fa2c173b6a33b02dad0cf19e",
    "message": "Remove a bit of test verbosity",
    "date": "2016-03-13T22:21:34Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/70333e35f54f8684fa2c173b6a33b02dad0cf19e",
    "details": {
      "sha": "b98deda2a747a31f44cb581e4cbb542c7b414e90",
      "filename": "src/test/java/io/vertx/test/core/Http2Test.java",
      "status": "modified",
      "additions": 67,
      "deletions": 137,
      "changes": 204,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/70333e35f54f8684fa2c173b6a33b02dad0cf19e/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttp2Test.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/70333e35f54f8684fa2c173b6a33b02dad0cf19e/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttp2Test.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FHttp2Test.java?ref=70333e35f54f8684fa2c173b6a33b02dad0cf19e",
      "patch": "@@ -81,7 +81,6 @@\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n@@ -98,6 +97,18 @@\n  */\n public class Http2Test extends HttpTestBase {\n \n+  private static Http2Headers headers(String method, String scheme, String path) {\n+    return new DefaultHttp2Headers().method(method).scheme(scheme).path(path);\n+  }\n+\n+  private static Http2Headers GET(String scheme, String path) {\n+    return headers(\"GET\", scheme, path);\n+  }\n+\n+  private static Http2Headers GET(String path) {\n+    return headers(\"GET\", \"https\", path);\n+  }\n+\n   private HttpServerOptions serverOptions;\n \n   @Override\n@@ -160,6 +171,10 @@ public Request(ChannelHandlerContext context, Http2Connection connection, Http2C\n         this.encoder = encoder;\n         this.decoder = decoder;\n       }\n+\n+      public int nextStreamId() {\n+        return connection.local().incrementAndGetNextStreamId();\n+      }\n     }\n \n     public ChannelFuture connect(int port, String host, Consumer<Request> handler) {\n@@ -227,10 +242,9 @@ public void testServerInitialSettings() throws Exception {\n     CountDownLatch latch = new CountDownLatch(1);\n     server.close();\n     server = vertx.createHttpServer(serverOptions.setHttp2Settings(VertxHttp2Handler.toVertxSettings(settings)));\n-    server.requestHandler(req -> fail()).listen(ar -> {\n-      assertTrue(ar.succeeded());\n+    server.requestHandler(req -> fail()).listen(onSuccess(s -> {\n       latch.countDown();\n-    });\n+    }));\n     awaitLatch(latch);\n     TestClient client = new TestClient();\n     client.settings.maxConcurrentStreams(0);\n@@ -270,10 +284,7 @@ public void testServerSettings() throws Exception {\n         assertEquals((long) expectedSettings.headerTableSize(), (long) ackedSettings.getHeaderTableSize());\n         complete();\n       });\n-    }).listen(ar -> {\n-      assertTrue(ar.succeeded());\n-      latch.countDown();\n-    });\n+    }).listen(onSuccess(s -> latch.countDown()));\n     awaitLatch(latch);\n     TestClient client = new TestClient();\n     client.settings.maxConcurrentStreams(0);\n@@ -303,8 +314,8 @@ public void onSettingsRead(ChannelHandlerContext ctx, Http2Settings newSettings)\n           });\n         }\n       });\n-      int id = request.connection.local().incrementAndGetNextStreamId();\n-      request.encoder.writeHeaders(request.context, id, new DefaultHttp2Headers().method(\"GET\").scheme(\"https\").path(\"/\"), 0, false, request.context.newPromise());\n+      int id = request.nextStreamId();\n+      request.encoder.writeHeaders(request.context, id, GET(\"/\"), 0, false, request.context.newPromise());\n     });\n     fut.sync();\n     await();\n@@ -332,16 +343,13 @@ public void testClientSettings() throws Exception {\n         testComplete();\n       });\n       settingsRead.complete(null);\n-    }).listen(ar -> {\n-      assertTrue(ar.succeeded());\n-      latch.countDown();\n-    });\n+    }).listen(onSuccess(s -> latch.countDown()));\n     awaitLatch(latch);\n     TestClient client = new TestClient();\n     client.settings.putAll(initialSettings);\n     ChannelFuture fut = client.connect(4043, \"localhost\", request -> {\n-      int id = request.connection.local().incrementAndGetNextStreamId();\n-      request.encoder.writeHeaders(request.context, id, new DefaultHttp2Headers().method(\"GET\").scheme(\"https\").path(\"/\"), 0, false, request.context.newPromise());\n+      int id = request.nextStreamId();\n+      request.encoder.writeHeaders(request.context, id, GET(\"/\"), 0, false, request.context.newPromise());\n       request.context.flush();\n       settingsRead.thenAccept(v -> {\n         request.encoder.writeSettings(request.context, updatedSettings, request.context.newPromise());\n@@ -391,11 +399,7 @@ public void testGet() throws Exception {\n       resp.putHeader(\"bar\", \"bar_value\");\n       resp.putHeader(\"juu\", (List<String>)Arrays.asList(\"juu_value_1\", \"juu_value_2\"));\n       resp.end(content);\n-    })\n-        .listen(ar -> {\n-          assertTrue(ar.succeeded());\n-          latch.countDown();\n-        });\n+    }).listen(onSuccess(s -> latch.countDown()));\n     awaitLatch(latch);\n     OkHttpClient client = createHttp2Client();\n     Request request = new Request.Builder().url(\"https://localhost:4043/\").build();\n@@ -428,15 +432,11 @@ public void testURI() throws Exception {\n       assertEquals(\"bar_value_2\", params.get(\"bar\"));\n       assertEquals(Arrays.asList(\"bar_value_1\", \"bar_value_2\"), params.getAll(\"bar\"));\n       testComplete();\n-    })\n-        .listen(ar -> {\n-          assertTrue(ar.succeeded());\n-          latch.countDown();\n-        });\n+    }).listen(onSuccess(s -> latch.countDown()));\n     awaitLatch(latch);\n     TestClient client = new TestClient();\n     ChannelFuture fut = client.connect(4043, \"localhost\", request -> {\n-      int id = request.connection.local().incrementAndGetNextStreamId();\n+      int id = request.nextStreamId();\n       Http2Headers headers = new DefaultHttp2Headers().\n           method(\"GET\").\n           scheme(\"http\").\n@@ -459,11 +459,7 @@ public void testPost() throws Exception {\n       req.endHandler(v -> {\n         req.response().putHeader(\"content-type\", \"text/plain\").end(\"\");\n       });\n-    })\n-        .listen(ar -> {\n-          assertTrue(ar.succeeded());\n-          latch.countDown();\n-        });\n+    }).listen(onSuccess(s -> latch.countDown()));\n     awaitLatch(latch);\n     OkHttpClient client = createHttp2Client();\n     Request request = new Request.Builder()\n@@ -494,11 +490,7 @@ public void testPostFileUpload() throws Exception {\n         assertEquals(0, req.formAttributes().size());\n         req.response().putHeader(\"content-type\", \"text/plain\").end(\"done\");\n       });\n-    })\n-        .listen(ar -> {\n-          assertTrue(ar.succeeded());\n-          latch.countDown();\n-        });\n+    }).listen(onSuccess(s -> latch.countDown()));\n     awaitLatch(latch);\n     OkHttpClient client = createHttp2Client();\n     Request request = new Request.Builder()\n@@ -526,15 +518,11 @@ public void testConnect() throws Exception {\n       assertNull(req.uri());\n       assertNull(req.absoluteURI());\n       testComplete();\n-    })\n-        .listen(ar -> {\n-          assertTrue(ar.succeeded());\n-          latch.countDown();\n-        });\n+    }).listen(onSuccess(s -> latch.countDown()));\n     awaitLatch(latch);\n     TestClient client = new TestClient();\n     ChannelFuture fut = client.connect(4043, \"localhost\", request -> {\n-      int id = request.connection.local().incrementAndGetNextStreamId();\n+      int id = request.nextStreamId();\n       Http2Headers headers = new DefaultHttp2Headers().method(\"CONNECT\").authority(\"whatever.com\");\n       request.encoder.writeHeaders(request.context, id, headers, 0, true, request.context.newPromise());\n       request.context.flush();\n@@ -566,11 +554,7 @@ public void testServerRequestPause() throws Exception {\n         req.response().end(\"hello\");\n       });\n       req.pause();\n-    })\n-        .listen(ar -> {\n-          assertTrue(ar.succeeded());\n-          latch.countDown();\n-        });\n+    }).listen(onSuccess(s -> latch.countDown()));\n     awaitLatch(latch);\n     OkHttpClient client = createHttp2Client();\n     Buffer sent = Buffer.buffer();\n@@ -625,19 +609,15 @@ public void testServerResponseWritability() throws Exception {\n           resp.write(buf);\n         }\n       });\n-    })\n-        .listen(ar -> {\n-          assertTrue(ar.succeeded());\n-          latch.countDown();\n-        });\n+    }).listen(onSuccess(s -> latch.countDown()));\n     awaitLatch(latch);\n \n     TestClient client = new TestClient();\n     ChannelFuture fut = client.connect(4043, \"localhost\", request -> {\n       AtomicInteger toAck = new AtomicInteger();\n-      int id = request.connection.local().incrementAndGetNextStreamId();\n+      int id = request.nextStreamId();\n       Http2ConnectionEncoder encoder = request.encoder;\n-      encoder.writeHeaders(request.context, id, new DefaultHttp2Headers().method(\"GET\").scheme(\"https\").path(\"/\"), 0, true, request.context.newPromise());\n+      encoder.writeHeaders(request.context, id, GET(\"/\"), 0, true, request.context.newPromise());\n       request.decoder.frameListener(new Http2FrameAdapter() {\n \n         StringBuilder received = new StringBuilder();\n@@ -691,11 +671,7 @@ public void testTrailers() throws Exception {\n       resp.putTrailer(\"bar\", \"bar_value\");\n       resp.putTrailer(\"juu\", (List<String>)Arrays.asList(\"juu_value_1\", \"juu_value_2\"));\n       resp.end();\n-    })\n-        .listen(ar -> {\n-          assertTrue(ar.succeeded());\n-          latch.countDown();\n-        });\n+    }).listen(onSuccess(s -> latch.countDown()));\n     awaitLatch(latch);\n     TestClient client = new TestClient();\n     ChannelFuture fut = client.connect(4043, \"localhost\", request -> {\n@@ -730,12 +706,8 @@ public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers\n           }\n         }\n       });\n-      int id = request.connection.local().incrementAndGetNextStreamId();\n-      Http2Headers headers = new DefaultHttp2Headers().\n-          method(\"GET\").\n-          scheme(\"http\").\n-          path(\"/\");\n-      request.encoder.writeHeaders(request.context, id, headers, 0, true, request.context.newPromise());\n+      int id = request.nextStreamId();\n+      request.encoder.writeHeaders(request.context, id, GET(\"/\"), 0, true, request.context.newPromise());\n       request.context.flush();\n     });\n     fut.sync();\n@@ -749,15 +721,12 @@ public void testServerResetClientStream() throws Exception {\n       req.handler(buf -> {\n         req.response().reset(8);\n       });\n-    }).listen(ar -> {\n-      assertTrue(ar.succeeded());\n-      latch.countDown();\n-    });\n+    }).listen(onSuccess(s -> latch.countDown()));\n     awaitLatch(latch);\n \n     TestClient client = new TestClient();\n     ChannelFuture fut = client.connect(4043, \"localhost\", request -> {\n-      int id = request.connection.local().incrementAndGetNextStreamId();\n+      int id = request.nextStreamId();\n       request.decoder.frameListener(new Http2EventAdapter() {\n         @Override\n         public void onRstStreamRead(ChannelHandlerContext ctx, int streamId, long errorCode) throws Http2Exception {\n@@ -768,7 +737,7 @@ public void onRstStreamRead(ChannelHandlerContext ctx, int streamId, long errorC\n         }\n       });\n       Http2ConnectionEncoder encoder = request.encoder;\n-      encoder.writeHeaders(request.context, id, new DefaultHttp2Headers().method(\"GET\").scheme(\"https\").path(\"/\"), 0, false, request.context.newPromise());\n+      encoder.writeHeaders(request.context, id, GET(\"/\"), 0, false, request.context.newPromise());\n       encoder.writeData(request.context, id, Buffer.buffer(\"hello\").getByteBuf(), 0, false, request.context.newPromise());\n     });\n \n@@ -801,18 +770,14 @@ public void testClientResetServerStream() throws Exception {\n         assertEquals(2, resetCount.get());\n         testComplete();\n       });\n-    })\n-        .listen(ar -> {\n-          assertTrue(ar.succeeded());\n-          latch.countDown();\n-        });\n+    }).listen(onSuccess(s -> latch.countDown()));\n     awaitLatch(latch);\n \n     TestClient client = new TestClient();\n     ChannelFuture fut = client.connect(4043, \"localhost\", request -> {\n-      int id = request.connection.local().incrementAndGetNextStreamId();\n+      int id = request.nextStreamId();\n       Http2ConnectionEncoder encoder = request.encoder;\n-      encoder.writeHeaders(request.context, id, new DefaultHttp2Headers().method(\"GET\").scheme(\"https\").path(\"/\"), 0, false, request.context.newPromise());\n+      encoder.writeHeaders(request.context, id, GET(\"/\"), 0, false, request.context.newPromise());\n       encoder.writeData(request.context, id, Buffer.buffer(\"hello\").getByteBuf(), 0, false, request.context.newPromise());\n       bufReceived.thenAccept(v -> {\n         encoder.writeRstStream(request.context, id, 10, request.context.newPromise());\n@@ -834,18 +799,14 @@ public void testConnectionClose() throws Exception {\n         testComplete();\n       });\n       req.response().putHeader(\"Content-Type\", \"text/plain\").end();\n-    })\n-        .listen(ar -> {\n-          assertTrue(ar.succeeded());\n-          latch.countDown();\n-        });\n+    }).listen(onSuccess(s -> latch.countDown()));\n     awaitLatch(latch);\n \n     TestClient client = new TestClient();\n     ChannelFuture fut = client.connect(4043, \"localhost\", request -> {\n-      int id = request.connection.local().incrementAndGetNextStreamId();\n+      int id = request.nextStreamId();\n       Http2ConnectionEncoder encoder = request.encoder;\n-      encoder.writeHeaders(request.context, id, new DefaultHttp2Headers().method(\"GET\").scheme(\"https\").path(\"/\"), 0, true, request.context.newPromise());\n+      encoder.writeHeaders(request.context, id, GET(\"/\"), 0, true, request.context.newPromise());\n       request.decoder.frameListener(new Http2FrameAdapter() {\n         @Override\n         public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int streamDependency, short weight, boolean exclusive, int padding, boolean endStream) throws Http2Exception {\n@@ -870,17 +831,13 @@ public void testPushPromise() throws Exception {\n           e.printStackTrace();\n         }\n       });\n-    })\n-        .listen(ar -> {\n-          assertTrue(ar.succeeded());\n-          latch.countDown();\n-        });\n+    }).listen(onSuccess(s -> latch.countDown()));\n     awaitLatch(latch);\n     TestClient client = new TestClient();\n     ChannelFuture fut = client.connect(4043, \"localhost\", request -> {\n-      int id = request.connection.local().incrementAndGetNextStreamId();\n+      int id = request.nextStreamId();\n       Http2ConnectionEncoder encoder = request.encoder;\n-      encoder.writeHeaders(request.context, id, new DefaultHttp2Headers().method(\"GET\").scheme(\"https\").path(\"/\"), 0, true, request.context.newPromise());\n+      encoder.writeHeaders(request.context, id, GET(\"/\"), 0, true, request.context.newPromise());\n       Map<Integer, Http2Headers> pushed = new HashMap<>();\n       request.decoder.frameListener(new Http2FrameAdapter() {\n         @Override\n@@ -921,17 +878,13 @@ public void testResetActivePushPromise() throws Exception {\n         });\n         response.setChunked(true).write(\"some_content\");\n       });\n-    })\n-        .listen(ar -> {\n-          assertTrue(ar.succeeded());\n-          latch.countDown();\n-        });\n+    }).listen(onSuccess(s -> latch.countDown()));\n     awaitLatch(latch);\n     TestClient client = new TestClient();\n     ChannelFuture fut = client.connect(4043, \"localhost\", request -> {\n-      int id = request.connection.local().incrementAndGetNextStreamId();\n+      int id = request.nextStreamId();\n       Http2ConnectionEncoder encoder = request.encoder;\n-      encoder.writeHeaders(request.context, id, new DefaultHttp2Headers().method(\"GET\").scheme(\"https\").path(\"/\"), 0, true, request.context.newPromise());\n+      encoder.writeHeaders(request.context, id, GET(\"/\"), 0, true, request.context.newPromise());\n       request.decoder.frameListener(new Http2FrameAdapter() {\n         @Override\n         public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding, boolean endOfStream) throws Http2Exception {\n@@ -963,18 +916,14 @@ public void testQueuePushPromise() throws Exception {\n           });\n         });\n       }\n-    })\n-        .listen(ar -> {\n-          assertTrue(ar.succeeded());\n-          latch.countDown();\n-        });\n+    }).listen(onSuccess(s -> latch.countDown()));\n     awaitLatch(latch);\n     TestClient client = new TestClient();\n     client.settings.maxConcurrentStreams(3);\n     ChannelFuture fut = client.connect(4043, \"localhost\", request -> {\n-      int id = request.connection.local().incrementAndGetNextStreamId();\n+      int id = request.nextStreamId();\n       Http2ConnectionEncoder encoder = request.encoder;\n-      encoder.writeHeaders(request.context, id, new DefaultHttp2Headers().method(\"GET\").scheme(\"https\").path(\"/\"), 0, true, request.context.newPromise());\n+      encoder.writeHeaders(request.context, id, GET(\"/\"), 0, true, request.context.newPromise());\n       request.decoder.frameListener(new Http2FrameAdapter() {\n         int count = numPushes;\n         Set<String> pushReceived = new HashSet<>();\n@@ -1009,18 +958,14 @@ public void testResetPendingPushPromise() throws Exception {\n         assertFalse(ar.succeeded());\n         testComplete();\n       });\n-    })\n-        .listen(ar -> {\n-          assertTrue(ar.succeeded());\n-          latch.countDown();\n-        });\n+    }).listen(onSuccess(s -> latch.countDown()));\n     awaitLatch(latch);\n     TestClient client = new TestClient();\n     client.settings.maxConcurrentStreams(0);\n     ChannelFuture fut = client.connect(4043, \"localhost\", request -> {\n-      int id = request.connection.local().incrementAndGetNextStreamId();\n+      int id = request.nextStreamId();\n       Http2ConnectionEncoder encoder = request.encoder;\n-      encoder.writeHeaders(request.context, id, new DefaultHttp2Headers().method(\"GET\").scheme(\"https\").path(\"/\"), 0, true, request.context.newPromise());\n+      encoder.writeHeaders(request.context, id, GET(\"/\"), 0, true, request.context.newPromise());\n       request.decoder.frameListener(new Http2FrameAdapter() {\n         @Override\n         public void onPushPromiseRead(ChannelHandlerContext ctx, int streamId, int promisedStreamId, Http2Headers headers, int padding) throws Http2Exception {\n@@ -1070,16 +1015,12 @@ public void testConnectInvalidAuthority() throws Exception {\n \n   private void testMalformedRequest(Http2Headers headers) throws Exception {\n     CountDownLatch latch = new CountDownLatch(1);\n-    server.requestHandler(req -> fail())\n-        .listen(ar -> {\n-          assertTrue(ar.succeeded());\n-          latch.countDown();\n-        });\n+    server.requestHandler(req -> fail()).listen(onSuccess(s -> latch.countDown()));\n     awaitLatch(latch);\n     TestClient client = new TestClient();\n     client.settings.maxConcurrentStreams(0);\n     ChannelFuture fut = client.connect(4043, \"localhost\", request -> {\n-      int id = request.connection.local().incrementAndGetNextStreamId();\n+      int id = request.nextStreamId();\n       Http2ConnectionEncoder encoder = request.encoder;\n       encoder.writeHeaders(request.context, id, headers, 0, true, request.context.newPromise());\n       request.decoder.frameListener(new Http2FrameAdapter() {\n@@ -1151,17 +1092,14 @@ private void testHandlerFailure(boolean data, BiConsumer<RuntimeException, HttpS\n       testComplete();\n     });\n     ctx.runOnContext(v -> {\n-      server.listen(ar -> {\n-        assertTrue(ar.succeeded());\n-        latch.countDown();\n-      });\n+      server.listen(onSuccess(s -> latch.countDown()));\n     });\n     awaitLatch(latch);\n     TestClient client = new TestClient();\n     client.settings.maxConcurrentStreams(0);\n     ChannelFuture fut = client.connect(4043, \"localhost\", request -> {\n-      int id = request.connection.local().incrementAndGetNextStreamId();\n-      request.encoder.writeHeaders(request.context, id, new DefaultHttp2Headers().method(\"GET\").scheme(\"https\").path(\"/\"), 0, !data, request.context.newPromise());\n+      int id = request.nextStreamId();\n+      request.encoder.writeHeaders(request.context, id, GET(\"/\"), 0, !data, request.context.newPromise());\n       if (data) {\n         request.encoder.writeData(request.context, id, Buffer.buffer(\"hello\").getByteBuf(), 0, true, request.context.newPromise());\n       }\n@@ -1184,11 +1122,7 @@ public void testSendFile() throws Exception {\n     CountDownLatch latch = new CountDownLatch(1);\n     server.requestHandler(req -> {\n       req.response().sendFile(f.getAbsolutePath());\n-    })\n-        .listen(ar -> {\n-          assertTrue(ar.succeeded());\n-          latch.countDown();\n-        });\n+    }).listen(onSuccess(s -> latch.countDown()));\n     awaitLatch(latch);\n     TestClient client = new TestClient();\n     ChannelFuture fut = client.connect(4043, \"localhost\", request -> {\n@@ -1212,12 +1146,8 @@ public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int\n           return data.readableBytes() + padding;\n         }\n       });\n-      int id = request.connection.local().incrementAndGetNextStreamId();\n-      Http2Headers headers = new DefaultHttp2Headers().\n-          method(\"GET\").\n-          scheme(\"http\").\n-          path(\"/\");\n-      request.encoder.writeHeaders(request.context, id, headers, 0, true, request.context.newPromise());\n+      int id = request.nextStreamId();\n+      request.encoder.writeHeaders(request.context, id, GET(\"/\"), 0, true, request.context.newPromise());\n       request.context.flush();\n     });\n     fut.sync();",
      "parent_sha": "fe663ed6ff2b79ff17956ef7766f2ad1f5193e8f"
    }
  },
  {
    "oid": "4cb1947efea4fcee08783582868f7d51c2d1df0f",
    "message": "Display more details about SSL connection issue.\n\nSigned-off-by: Clement Escoffier <clement.escoffier@gmail.com>",
    "date": "2016-02-29T13:55:40Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/4cb1947efea4fcee08783582868f7d51c2d1df0f",
    "details": {
      "sha": "941077da75d8960e3f92c40cd7475a92144a749d",
      "filename": "src/main/java/io/vertx/core/net/impl/NetServerImpl.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/4cb1947efea4fcee08783582868f7d51c2d1df0f/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2Fimpl%2FNetServerImpl.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/4cb1947efea4fcee08783582868f7d51c2d1df0f/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2Fimpl%2FNetServerImpl.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2Fimpl%2FNetServerImpl.java?ref=4cb1947efea4fcee08783582868f7d51c2d1df0f",
      "patch": "@@ -427,7 +427,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {\n           if (future.isSuccess()) {\n             connected(ch, handler);\n           } else {\n-            log.error(\"Client from origin \" + ch.remoteAddress() + \" failed to connect over ssl\");\n+            log.error(\"Client from origin \" + ch.remoteAddress() + \" failed to connect over ssl: \" + future.cause());\n           }\n         });\n       } else {",
      "parent_sha": "e0f3501d6d1b45b724800f4746e864fda55e08f4"
    }
  },
  {
    "oid": "4d19725a7fb0697595fb86c20ca9bb1a4bf80f54",
    "message": "#1757: Rename test methods\n\nSigned-off-by: Jonas Berlin <jonas.berlin@nitorcreations.com>",
    "date": "2017-02-02T07:56:07Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/4d19725a7fb0697595fb86c20ca9bb1a4bf80f54",
    "details": {
      "sha": "eee876e27d6054b472a604a2d9e3685161adbb06",
      "filename": "src/test/java/io/vertx/test/core/WebsocketTest.java",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/4d19725a7fb0697595fb86c20ca9bb1a4bf80f54/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FWebsocketTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/4d19725a7fb0697595fb86c20ca9bb1a4bf80f54/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FWebsocketTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FWebsocketTest.java?ref=4d19725a7fb0697595fb86c20ca9bb1a4bf80f54",
      "patch": "@@ -1359,13 +1359,14 @@ public void testClientWebsocketWithHttp2Client() throws Exception {\n   }\n \n   @Test\n-  public void testIssue1757_1() throws Throwable {\n-    doTestIssue1757(true);\n+  public void testClientWebsocketConnectionCloseOnBadResponseWithKeepalive() throws Throwable {\n+    // issue #1757\n+    doTestClientWebsocketConnectionCloseOnBadResponse(true);\n   }\n \n   @Test\n-  public void testIssue1757_2() throws Throwable {\n-    doTestIssue1757(false);\n+  public void testClientWebsocketConnectionCloseOnBadResponseWithoutKeepalive() throws Throwable {\n+    doTestClientWebsocketConnectionCloseOnBadResponse(false);\n   }\n \n   final BlockingQueue<Throwable> resultQueue = new ArrayBlockingQueue<Throwable>(10);\n@@ -1378,7 +1379,7 @@ void addResult(Throwable result) {\n     }\n   }\n \n-  private void doTestIssue1757(boolean keepAliveInOptions) throws Throwable {\n+  private void doTestClientWebsocketConnectionCloseOnBadResponse(boolean keepAliveInOptions) throws Throwable {\n     final Exception serverGotCloseException = new Exception();\n \n     netServer = vertx.createNetServer().connectHandler(sock -> {",
      "parent_sha": "5dc880b64b8ef3ee71c5c3a120c527e8fe739e46"
    }
  },
  {
    "oid": "48a601d63fd3003c9a9dd8323614b9fcaba45eeb",
    "message": "Add debug flag to prevent string concat in EventBusBridge",
    "date": "2013-10-17T23:22:58Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/48a601d63fd3003c9a9dd8323614b9fcaba45eeb",
    "details": {
      "sha": "cc93caaff3eb8a6bf63d5e15c931055a95ecaee2",
      "filename": "vertx-core/src/main/java/org/vertx/java/core/sockjs/EventBusBridge.java",
      "status": "modified",
      "additions": 26,
      "deletions": 7,
      "changes": 33,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/48a601d63fd3003c9a9dd8323614b9fcaba45eeb/vertx-core%2Fsrc%2Fmain%2Fjava%2Forg%2Fvertx%2Fjava%2Fcore%2Fsockjs%2FEventBusBridge.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/48a601d63fd3003c9a9dd8323614b9fcaba45eeb/vertx-core%2Fsrc%2Fmain%2Fjava%2Forg%2Fvertx%2Fjava%2Fcore%2Fsockjs%2FEventBusBridge.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/vertx-core%2Fsrc%2Fmain%2Fjava%2Forg%2Fvertx%2Fjava%2Fcore%2Fsockjs%2FEventBusBridge.java?ref=48a601d63fd3003c9a9dd8323614b9fcaba45eeb",
      "patch": "@@ -158,28 +158,37 @@ private void internalHandleSendOrPub(SockJSSocket sock, boolean send, JsonObject\n \n   private void internalHandleRegister(final SockJSSocket sock, JsonObject message, final String address, Map<String, Handler<Message>> handlers) {\n     if (handlePreRegister(sock, address)) {\n+      final boolean debug = log.isDebugEnabled();\n       Match match = checkMatches(false, address, message);\n       if (match.doesMatch) {\n         Handler<Message> handler = new Handler<Message>() {\n           public void handle(final Message msg) {\n             Match curMatch = checkMatches(false, address, msg.body());\n             if (curMatch.doesMatch) {\n               if (curMatch.requiresAuth && sockAuths.get(sock) == null) {\n-                log.debug(\"Outbound message for address \" + address + \" rejected because auth is required and socket is not authed\");\n+                if (debug) {\n+                  log.debug(\"Outbound message for address \" + address + \" rejected because auth is required and socket is not authed\");\n+                }\n               } else {\n                 checkAddAccceptedReplyAddress(msg.replyAddress());\n                 deliverMessage(sock, address, msg);\n               }\n             } else {\n-              log.debug(\"Outbound message for address \" + address + \" rejected because there is no inbound match\");\n+              // outbound match failed\n+              if (debug) {\n+                log.debug(\"Outbound message for address \" + address + \" rejected because there is no inbound match\");\n+              }\n             }\n           }\n         };\n         handlers.put(address, handler);\n         eb.registerHandler(address, handler);\n         handlePostRegister(sock, address);\n       } else {\n-        log.debug(\"Cannot register handler for address \" + address + \" because there is no inbound match\");\n+        // inbound match failed\n+        if (debug) {\n+          log.debug(\"Cannot register handler for address \" + address + \" because there is no inbound match\");\n+        }\n       }\n     }\n   }\n@@ -283,7 +292,8 @@ private void doSendOrPub(final boolean send, final SockJSSocket sock, final Stri\n                            final JsonObject message) {\n     final Object body = getMandatoryValue(message, \"body\");\n     final String replyAddress = message.getString(\"replyAddress\");\n-    if (log.isDebugEnabled()) {\n+    final boolean debug = log.isDebugEnabled();\n+    if (debug) {\n       log.debug(\"Received msg from client in bridge. address:\"  + address + \" message:\" + body);\n     }\n     Match curMatch = checkMatches(true, address, body);\n@@ -298,21 +308,30 @@ public void handle(AsyncResult<Boolean> res) {\n                   cacheAuthorisation(sessionID, sock);\n                   checkAndSend(send, address, body, sock, replyAddress);\n                 } else {\n-                  log.debug(\"Inbound message for address \" + address + \" rejected because sessionID is not authorised\");\n+                  // invalid session id\n+                  if (debug) {\n+                    log.debug(\"Inbound message for address \" + address + \" rejected because sessionID is not authorised\");\n+                  }\n                 }\n               } else {\n                 log.error(\"Error in performing authorisation\", res.cause());\n               }\n             }\n           });\n         } else {\n-          log.debug(\"Inbound message for address \" + address + \" rejected because it requires auth and sessionID is missing\");\n+          // session id null\n+          if (debug) {\n+            log.debug(\"Inbound message for address \" + address + \" rejected because it requires auth and sessionID is missing\");\n+          }\n         }\n       } else {\n         checkAndSend(send, address, body, sock, replyAddress);\n       }\n     } else {\n-      log.debug(\"Inbound message for address \" + address + \" rejected because there is no match\");\n+      // inbound match failed\n+      if (debug) {\n+        log.debug(\"Inbound message for address \" + address + \" rejected because there is no match\");\n+      }\n     }\n   }\n ",
      "parent_sha": "2c76abf488ae5c004e10a4c4a4eac5bb2d3235ca"
    }
  },
  {
    "oid": "b98c0531df5eb2dbdacfd5ca971a331fa08231fe",
    "message": "Move some code",
    "date": "2020-11-19T07:25:22Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/b98c0531df5eb2dbdacfd5ca971a331fa08231fe",
    "details": {
      "sha": "26416a28da2dcd1ebc09a3c7cb926d50723d4157",
      "filename": "src/main/java/io/vertx/core/file/impl/FileResolver.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/b98c0531df5eb2dbdacfd5ca971a331fa08231fe/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Ffile%2Fimpl%2FFileResolver.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/b98c0531df5eb2dbdacfd5ca971a331fa08231fe/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Ffile%2Fimpl%2FFileResolver.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Ffile%2Fimpl%2FFileResolver.java?ref=b98c0531df5eb2dbdacfd5ca971a331fa08231fe",
      "patch": "@@ -138,9 +138,6 @@ public File resolveFile(String fileName) {\n         }\n         // Look for file on classpath\n         ClassLoader cl = getClassLoader();\n-        if (NON_UNIX_FILE_SEP) {\n-          fileName = fileName.replace(FILE_SEP, \"/\");\n-        }\n \n         //https://github.com/eclipse/vert.x/issues/2126\n         //Cache all elements in the parent directory if it exists\n@@ -157,6 +154,9 @@ public File resolveFile(String fileName) {\n           }\n         }\n \n+        if (NON_UNIX_FILE_SEP) {\n+          fileName = fileName.replace(FILE_SEP, \"/\");\n+        }\n         URL url = getValidClassLoaderResource(cl, fileName);\n         if (url != null) {\n           return unpackUrlResource(url, fileName, cl, false);",
      "parent_sha": "afb4770cc9c655fe689a52d34bfd071d3ecd62c5"
    }
  },
  {
    "oid": "b6d6aaed8c6cd4f37fd579ad406cb25ba30e20d0",
    "message": "Favour inlining without metrics reporting",
    "date": "2023-02-27T17:26:00Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/b6d6aaed8c6cd4f37fd579ad406cb25ba30e20d0",
    "details": {
      "sha": "7c76b266250361bcd18aa8cf3b0c57dfc05471aa",
      "filename": "src/main/java/io/vertx/core/net/impl/ConnectionBase.java",
      "status": "modified",
      "additions": 13,
      "deletions": 9,
      "changes": 22,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/b6d6aaed8c6cd4f37fd579ad406cb25ba30e20d0/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2Fimpl%2FConnectionBase.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/b6d6aaed8c6cd4f37fd579ad406cb25ba30e20d0/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2Fimpl%2FConnectionBase.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2Fimpl%2FConnectionBase.java?ref=b6d6aaed8c6cd4f37fd579ad406cb25ba30e20d0",
      "patch": "@@ -416,16 +416,20 @@ protected boolean supportsFileRegion() {\n   public final void reportBytesRead(Object msg) {\n     NetworkMetrics metrics = metrics();\n     if (metrics != null) {\n-      long bytes = remainingBytesRead;\n-      long numberOfBytes = sizeof(msg);\n-      bytes += numberOfBytes;\n-      long val = bytes & METRICS_REPORTED_BYTES_HIGH_MASK;\n-      if (val > 0) {\n-        bytes &= METRICS_REPORTED_BYTES_LOW_MASK;\n-        metrics.bytesRead(metric(), remoteAddress(), val);\n-      }\n-      remainingBytesRead = bytes;\n+      doReportBytesRead(msg, metrics);\n+    }\n+  }\n+\n+  private void doReportBytesRead(Object msg, NetworkMetrics metrics) {\n+    long bytes = remainingBytesRead;\n+    long numberOfBytes = sizeof(msg);\n+    bytes += numberOfBytes;\n+    long val = bytes & METRICS_REPORTED_BYTES_HIGH_MASK;\n+    if (val > 0) {\n+      bytes &= METRICS_REPORTED_BYTES_LOW_MASK;\n+      metrics.bytesRead(metric(), remoteAddress(), val);\n     }\n+    remainingBytesRead = bytes;\n   }\n \n   protected long sizeof(Object msg) {",
      "parent_sha": "1f73ce8c11d09bf3c81026dc9dc26fc37f885a46"
    }
  },
  {
    "oid": "3db21cdf5bdc122c960e71d755cee6be8956301d",
    "message": "create proxy InetSocketAddress with vertx.resolveHostname\n\nSigned-off-by: alexlehm <alexlehm@gmail.com>",
    "date": "2016-05-04T23:00:57Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/3db21cdf5bdc122c960e71d755cee6be8956301d",
    "details": {
      "sha": "9163b03ba3405579141c5ec640e8c91c682e38ae",
      "filename": "src/main/java/io/vertx/core/http/impl/proxy/ProxyChannelProvider.java",
      "status": "modified",
      "additions": 36,
      "deletions": 28,
      "changes": 64,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/3db21cdf5bdc122c960e71d755cee6be8956301d/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2Fproxy%2FProxyChannelProvider.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/3db21cdf5bdc122c960e71d755cee6be8956301d/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2Fproxy%2FProxyChannelProvider.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Fhttp%2Fimpl%2Fproxy%2FProxyChannelProvider.java?ref=3db21cdf5bdc122c960e71d755cee6be8956301d",
      "patch": "@@ -18,6 +18,7 @@\n import io.vertx.core.impl.VertxInternal;\n import io.vertx.core.net.impl.AsyncResolveBindConnectHelper;\n \n+import java.net.InetAddress;\n import java.net.InetSocketAddress;\n \n /**\n@@ -31,37 +32,44 @@ public void connect(VertxInternal vertx, Bootstrap bootstrap, HttpClientOptions\n     int proxyPort = options.getProxyPort();\n     String proxyUsername = options.getProxyUsername();\n     String proxyPassword = options.getProxyPassword();\n-    InetSocketAddress proxyAddr = new InetSocketAddress(proxyHost, proxyPort);\n-    HttpProxyHandler proxy;\n-    if (proxyUsername != null && proxyPassword != null) {\n-      proxy = new HttpProxyHandler(proxyAddr, proxyUsername, proxyPassword);\n-    } else {\n-      proxy = new HttpProxyHandler(proxyAddr);\n-    }\n-    HttpClientCodec codec = new HttpClientCodec(4096, 8192, options.getMaxChunkSize(), false, false);\n-    bootstrap.handler(new ChannelInitializer<Channel>() {\n-      @Override\n-      protected void initChannel(Channel ch) throws Exception {\n-        ChannelPipeline pipeline = ch.pipeline();\n-        pipeline.addLast(\"proxy\", proxy);\n-        pipeline.addLast(\"codec\", codec);\n-        pipeline.addLast(new ChannelInboundHandlerAdapter() {\n+    vertx.resolveHostname(proxyHost, dnsRes -> {\n+      if (dnsRes.succeeded()) {\n+        InetAddress address = dnsRes.result();\n+        InetSocketAddress proxyAddr = new InetSocketAddress(address, proxyPort);\n+        HttpProxyHandler proxy;\n+        if (proxyUsername != null && proxyPassword != null) {\n+          proxy = new HttpProxyHandler(proxyAddr, proxyUsername, proxyPassword);\n+        } else {\n+          proxy = new HttpProxyHandler(proxyAddr);\n+        }\n+        HttpClientCodec codec = new HttpClientCodec(4096, 8192, options.getMaxChunkSize(), false, false);\n+        bootstrap.handler(new ChannelInitializer<Channel>() {\n           @Override\n-          public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n-            if (evt instanceof ProxyConnectionEvent) {\n-              pipeline.remove(proxy);\n-              pipeline.remove(codec);\n-              pipeline.remove(this);\n-              channelHandler.handle(Future.succeededFuture(ch));\n-            }\n+          protected void initChannel(Channel ch) throws Exception {\n+            ChannelPipeline pipeline = ch.pipeline();\n+            pipeline.addLast(\"proxy\", proxy);\n+            pipeline.addLast(\"codec\", codec);\n+            pipeline.addLast(new ChannelInboundHandlerAdapter() {\n+              @Override\n+              public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+                if (evt instanceof ProxyConnectionEvent) {\n+                  pipeline.remove(proxy);\n+                  pipeline.remove(codec);\n+                  pipeline.remove(this);\n+                  channelHandler.handle(Future.succeededFuture(ch));\n+                }\n+              }\n+            });\n           }\n         });\n-      }\n-    });\n-    AsyncResolveBindConnectHelper<ChannelFuture> future = AsyncResolveBindConnectHelper.doConnect(vertx, port, host, bootstrap);\n-    future.addListener(res -> {\n-      if (res.failed()) {\n-        channelHandler.handle(Future.failedFuture(res.cause()));\n+        AsyncResolveBindConnectHelper<ChannelFuture> future = AsyncResolveBindConnectHelper.doConnect(vertx, port, host, bootstrap);\n+        future.addListener(res -> {\n+          if (res.failed()) {\n+            channelHandler.handle(Future.failedFuture(res.cause()));\n+          }\n+        });\n+      } else {\n+        channelHandler.handle(Future.failedFuture(dnsRes.cause()));\n       }\n     });\n   }",
      "parent_sha": "5093f86d2bd3f7ebe02eff685e3aa9f837154859"
    }
  },
  {
    "oid": "ff2c06ebaba2acf000bfa20b1c24f925abfeaaa3",
    "message": "Move HostAndPortBenchmark to the benchmarks package\n\nSigned-off-by: Thomas Segismont <tsegismont@gmail.com>",
    "date": "2025-01-06T10:24:09Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/ff2c06ebaba2acf000bfa20b1c24f925abfeaaa3",
    "details": {
      "sha": "05a97896fa25ef75f24ba82a104c5a9f499e730f",
      "filename": "vertx-core/src/test/java/io/vertx/benchmarks/HostAndPortBenchmark.java",
      "status": "renamed",
      "additions": 4,
      "deletions": 13,
      "changes": 17,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/ff2c06ebaba2acf000bfa20b1c24f925abfeaaa3/vertx-core%2Fsrc%2Ftest%2Fjava%2Fio%2Fvertx%2Fbenchmarks%2FHostAndPortBenchmark.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/ff2c06ebaba2acf000bfa20b1c24f925abfeaaa3/vertx-core%2Fsrc%2Ftest%2Fjava%2Fio%2Fvertx%2Fbenchmarks%2FHostAndPortBenchmark.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/vertx-core%2Fsrc%2Ftest%2Fjava%2Fio%2Fvertx%2Fbenchmarks%2FHostAndPortBenchmark.java?ref=ff2c06ebaba2acf000bfa20b1c24f925abfeaaa3",
      "patch": "@@ -9,21 +9,12 @@\n  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0\n  */\n \n-package io.vertx.core.net.impl;\n+package io.vertx.benchmarks;\n \n-import java.util.concurrent.TimeUnit;\n+import io.vertx.core.net.impl.HostAndPortImpl;\n+import org.openjdk.jmh.annotations.*;\n \n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n+import java.util.concurrent.TimeUnit;\n \n @State(Scope.Thread)\n @BenchmarkMode(Mode.AverageTime)",
      "previous_filename": "src/test/benchmarks/io/vertx/core/net/impl/HostAndPortBenchmark.java",
      "parent_sha": "3eb4248c88f501facd555f2cf3e7bc59a737b5b9"
    }
  },
  {
    "oid": "fa447f2f64342f6c8f9532a9da26733dff0acb72",
    "message": "Fix possible vertx leak in our test suite",
    "date": "2023-01-26T10:56:50Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/fa447f2f64342f6c8f9532a9da26733dff0acb72",
    "details": {
      "sha": "0d14b5bd884d23c6d9f555476c36af5c4159ff63",
      "filename": "src/test/java/io/vertx/test/core/VertxTestBase.java",
      "status": "modified",
      "additions": 1,
      "deletions": 4,
      "changes": 5,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/fa447f2f64342f6c8f9532a9da26733dff0acb72/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FVertxTestBase.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/fa447f2f64342f6c8f9532a9da26733dff0acb72/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FVertxTestBase.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Ftest%2Fcore%2FVertxTestBase.java?ref=fa447f2f64342f6c8f9532a9da26733dff0acb72",
      "patch": "@@ -83,9 +83,6 @@ protected VertxOptions getOptions() {\n   }\n \n   protected void tearDown() throws Exception {\n-    if (vertx != null) {\n-      close(vertx);\n-    }\n     if (created != null) {\n       closeClustered(created);\n     }\n@@ -118,7 +115,7 @@ protected Vertx vertx() {\n    */\n   protected Vertx vertx(VertxOptions options) {\n     if (created == null) {\n-      created = new ArrayList<>();\n+      created = Collections.synchronizedList(new ArrayList<>());\n     }\n     Vertx vertx = Vertx.vertx(options);\n     created.add(vertx);",
      "parent_sha": "5e57d00ddc724e0da688d3ca43d59ddbba0af94c"
    }
  },
  {
    "oid": "4dab934b3e9981891b9e5c1c87f4373fb59f4434",
    "message": "Remove callback usages from NetTest",
    "date": "2023-03-12T15:15:07Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/4dab934b3e9981891b9e5c1c87f4373fb59f4434",
    "details": {
      "sha": "21cd2f41b8f8768e240d721a081606fd93b406fe",
      "filename": "src/test/java/io/vertx/core/net/NetTest.java",
      "status": "modified",
      "additions": 245,
      "deletions": 391,
      "changes": 636,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/4dab934b3e9981891b9e5c1c87f4373fb59f4434/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2FNetTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/4dab934b3e9981891b9e5c1c87f4373fb59f4434/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2FNetTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fnet%2FNetTest.java?ref=4dab934b3e9981891b9e5c1c87f4373fb59f4434",
      "patch": "@@ -46,11 +46,7 @@\n import io.vertx.core.buffer.Buffer;\n import io.vertx.core.eventbus.Message;\n import io.vertx.core.eventbus.MessageConsumer;\n-import io.vertx.core.http.ClientAuth;\n-import io.vertx.core.http.HttpClient;\n-import io.vertx.core.http.HttpClientOptions;\n-import io.vertx.core.http.HttpServer;\n-import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.http.*;\n import io.vertx.core.impl.ConcurrentHashSet;\n import io.vertx.core.impl.Utils;\n import io.vertx.core.impl.VertxInternal;\n@@ -151,14 +147,6 @@ protected VertxOptions getOptions() {\n     return options;\n   }\n \n-  protected void awaitClose(NetServer server) throws InterruptedException {\n-    CountDownLatch latch = new CountDownLatch(1);\n-    server.close((asyncResult) -> {\n-      latch.countDown();\n-    });\n-    awaitLatch(latch);\n-  }\n-\n   protected void tearDown() throws Exception {\n     if (tmp != null) {\n       tmp.delete();\n@@ -826,9 +814,9 @@ public void testWriteHandlerSuccess() throws Exception {\n       });\n     });\n     startServer();\n-    client.connect(testAddress, onSuccess(so -> {\n+    client.connect(testAddress).onComplete(onSuccess(so -> {\n       writeUntilFull(so, v -> {\n-        so.write(Buffer.buffer(\"lost buffer\"), onSuccess(ack -> testComplete()));\n+        so.write(Buffer.buffer(\"lost buffer\")).onComplete(onSuccess(ack -> testComplete()));\n         close.complete(null);\n       });\n     }));\n@@ -845,11 +833,9 @@ public void testWriteHandlerFailure() throws Exception {\n       });\n     });\n     startServer();\n-    client.connect(testAddress, onSuccess(so -> {\n+    client.connect(testAddress).onComplete(onSuccess(so -> {\n       writeUntilFull(so, v -> {\n-        so.write(Buffer.buffer(\"lost buffer\"), onFailure(err -> {\n-          testComplete();\n-        }));\n+        so.write(Buffer.buffer(\"lost buffer\")).onComplete(onFailure(err -> testComplete()));\n         close.complete(null);\n       });\n     }));\n@@ -915,13 +901,13 @@ void testEcho(Consumer<NetSocket> writer, Consumer<Buffer> dataChecker, int leng\n         fail(\"failed to connect\");\n       }\n     };\n-    startEchoServer(testAddress, s -> client.connect(testAddress, clientHandler));\n+    startEchoServer(testAddress, s -> client.connect(testAddress).onComplete(clientHandler));\n     await();\n   }\n \n   void startEchoServer(SocketAddress address, Handler<AsyncResult<NetServer>> listenHandler) {\n     Handler<NetSocket> serverHandler = socket -> socket.handler(socket::write);\n-    server.connectHandler(serverHandler).listen(address, listenHandler);\n+    server.connectHandler(serverHandler).listen(address).onComplete(listenHandler);\n   }\n \n   @Test\n@@ -942,52 +928,37 @@ void connect(SocketAddress address) {\n             }\n           }\n         };\n-        client.connect(address, handler);\n+        client.connect(address).onComplete(handler);\n       }\n     });\n     await();\n   }\n \n   @Test\n   public void testConnectInvalidPort() {\n-    assertIllegalArgumentException(() -> client.connect(-1, \"localhost\", res -> {}));\n-    assertIllegalArgumentException(() -> client.connect(65536, \"localhost\", res -> {}));\n-    client.connect(9998, \"localhost\", res -> {\n-      assertTrue(res.failed());\n-      assertFalse(res.succeeded());\n-      assertNotNull(res.cause());\n-      testComplete();\n-    });\n+    assertIllegalArgumentException(() -> client.connect(-1, \"localhost\"));\n+    assertIllegalArgumentException(() -> client.connect(65536, \"localhost\"));\n+    client.connect(9998, \"localhost\").onComplete(onFailure((err -> testComplete())));\n     await();\n   }\n \n   @Test\n   public void testConnectInvalidHost() {\n-    assertNullPointerException(() -> client.connect(80, null, res -> {}));\n-    client.connect(1234, \"127.0.0.2\", res -> {\n-      assertTrue(res.failed());\n-      assertFalse(res.succeeded());\n-      assertNotNull(res.cause());\n-      testComplete();\n-    });\n+    assertNullPointerException(() -> client.connect(80, null));\n+    client.connect(1234, \"127.0.0.2\").onComplete(onFailure(err -> testComplete()));\n     await();\n   }\n \n-  @Test\n-  public void testConnectInvalidConnectHandler() throws Exception {\n-    assertNullPointerException(() -> client.connect(80, \"localhost\", (Handler<AsyncResult<NetSocket>>) null));\n-  }\n-\n   @Test\n   public void testListenInvalidPort() {\n     final int port = 9090;\n     final HttpServer httpServer = vertx.createHttpServer();\n     try {\n       httpServer.requestHandler(ignore -> {})\n-        .listen(port, onSuccess(s ->\n+        .listen(port).onComplete(onSuccess(s ->\n           vertx.createNetServer()\n             .connectHandler(ignore -> {})\n-            .listen(port, onFailure(error -> {\n+            .listen(port).onComplete(onFailure(error -> {\n               assertNotNull(error);\n               testComplete();\n             }))));\n@@ -1002,12 +973,7 @@ public void testListenInvalidHost() {\n     server.close();\n     server = vertx.createNetServer(new NetServerOptions().setPort(1234).setHost(\"uhqwduhqwudhqwuidhqwiudhqwudqwiuhd\"));\n     server.connectHandler(netSocket -> {\n-    }).listen(ar -> {\n-      assertTrue(ar.failed());\n-      assertFalse(ar.succeeded());\n-      assertNotNull(ar.cause());\n-      testComplete();\n-    });\n+    }).listen().onComplete(onFailure(err -> testComplete()));\n     await();\n   }\n \n@@ -1016,14 +982,11 @@ public void testListenOnWildcardPort() {\n     server.close();\n     server = vertx.createNetServer(new NetServerOptions().setPort(0));\n     server.connectHandler((netSocket) -> {\n-    }).listen(ar -> {\n-      assertFalse(ar.failed());\n-      assertTrue(ar.succeeded());\n-      assertNull(ar.cause());\n+    }).listen().onComplete(onSuccess(s -> {\n       assertTrue(server.actualPort() > 1024);\n-      assertEquals(server, ar.result());\n+      assertEquals(server, s);\n       testComplete();\n-    });\n+    }));\n     await();\n   }\n \n@@ -1035,12 +998,12 @@ public void testClientCloseHandlersCloseFromClient() {\n \n   @Test\n   public void testClientCloseHandlersCloseFromServer() {\n-    server.connectHandler(NetSocket::close).listen(testAddress, (s) -> clientCloseHandlers(false));\n+    server.connectHandler(NetSocket::close).listen(testAddress).onComplete((s) -> clientCloseHandlers(false));\n     await();\n   }\n \n   void clientCloseHandlers(boolean closeFromClient) {\n-    client.connect(testAddress, onSuccess(so -> {\n+    client.connect(testAddress).onComplete(onSuccess(so -> {\n       AtomicInteger counter = new AtomicInteger(0);\n       so.endHandler(v -> assertEquals(1, counter.incrementAndGet()));\n       so.closeHandler(v -> {\n@@ -1055,13 +1018,13 @@ void clientCloseHandlers(boolean closeFromClient) {\n \n   @Test\n   public void testServerCloseHandlersCloseFromClient() {\n-    serverCloseHandlers(false, s -> client.connect(testAddress, ar -> ar.result().close()));\n+    serverCloseHandlers(false, s -> client.connect(testAddress).onComplete(ar -> ar.result().close()));\n     await();\n   }\n \n   @Test\n   public void testServerCloseHandlersCloseFromServer() {\n-    serverCloseHandlers(true, s -> client.connect(testAddress, ar -> {}));\n+    serverCloseHandlers(true, s -> client.connect(testAddress));\n     await();\n   }\n \n@@ -1076,7 +1039,7 @@ void serverCloseHandlers(boolean closeFromServer, Handler<NetServer> listenHandl\n       if (closeFromServer) {\n         sock.close();\n       }\n-    }).listen(testAddress, onSuccess(listenHandler::handle));\n+    }).listen(testAddress).onComplete(onSuccess(listenHandler::handle));\n   }\n \n   @Test\n@@ -1095,7 +1058,7 @@ public void testClientClose() throws Exception {\n       NetClient client = vertx.createNetClient();\n       AtomicInteger inflight = new AtomicInteger();\n       for (int i = 0;i < num;i++) {\n-        client.connect(1234 + i, \"localhost\", onSuccess(so -> {\n+        client.connect(1234 + i, \"localhost\").onComplete(onSuccess(so -> {\n           inflight.incrementAndGet();\n           so.closeHandler(v -> {\n             inflight.decrementAndGet();\n@@ -1104,7 +1067,7 @@ public void testClientClose() throws Exception {\n       }\n       assertWaitUntil(() -> inflight.get() == 3);\n       CountDownLatch latch = new CountDownLatch(1);\n-      client.close(onSuccess(v -> latch.countDown()));\n+      client.close().onComplete(onSuccess(v -> latch.countDown()));\n       awaitLatch(latch);\n       assertWaitUntil(() -> inflight.get() == 0);\n     } finally {\n@@ -1118,7 +1081,7 @@ public void testReceiveMessageAfterExplicitClose() throws Exception {\n       so.write(\"Hello World\");\n     });\n     startServer();\n-    client.connect(testAddress, onSuccess(so -> {\n+    client.connect(testAddress).onComplete(onSuccess(so -> {\n       NetSocketInternal soi = (NetSocketInternal) so;\n       soi.channelHandlerContext().pipeline().addFirst(new ChannelInboundHandlerAdapter() {\n         @Override\n@@ -1138,7 +1101,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception\n   @Test\n   public void testClientDrainHandler() {\n     pausingServer((s) -> {\n-      client.connect(testAddress, onSuccess(sock -> {\n+      client.connect(testAddress).onComplete(onSuccess(sock -> {\n         assertFalse(sock.writeQueueFull());\n         sock.setWriteQueueMaxSize(1000);\n         Buffer buff = TestUtils.randomBuffer(10000);\n@@ -1163,15 +1126,15 @@ void pausingServer(Handler<AsyncResult<NetServer>> listenHandler) {\n     server.connectHandler(sock -> {\n       sock.pause();\n       Handler<Message<Buffer>> resumeHandler = (m) -> sock.resume();\n-      MessageConsumer reg = vertx.eventBus().<Buffer>consumer(\"server_resume\").handler(resumeHandler);\n+      MessageConsumer<?> reg = vertx.eventBus().<Buffer>consumer(\"server_resume\").handler(resumeHandler);\n       sock.closeHandler(v -> reg.unregister());\n-    }).listen(testAddress, listenHandler);\n+    }).listen(testAddress).onComplete(listenHandler);\n   }\n \n   @Test\n   public void testServerDrainHandler() {\n     drainingServer(s -> {\n-      client.connect(testAddress, onSuccess(sock -> {\n+      client.connect(testAddress).onComplete(onSuccess(sock -> {\n         sock.pause();\n         setHandlers(sock);\n         sock.handler(buf -> {});\n@@ -1207,7 +1170,7 @@ void drainingServer(Handler<AsyncResult<NetServer>> listenHandler) {\n           vertx.eventBus().send(\"client_resume\", \"\");\n         }\n       });\n-    }).listen(testAddress, listenHandler);\n+    }).listen(testAddress).onComplete(listenHandler);\n   }\n \n   @Test\n@@ -1225,7 +1188,7 @@ private void reconnectAttempts(int attempts) {\n     client = vertx.createNetClient(new NetClientOptions().setReconnectAttempts(attempts).setReconnectInterval(10));\n \n     //The server delays starting for a a few seconds, but it should still connect\n-    client.connect(testAddress, onSuccess(so -> testComplete()));\n+    client.connect(testAddress).onComplete(onSuccess(so -> testComplete()));\n \n     // Start the server after a delay\n     vertx.setTimer(2000, id -> startEchoServer(testAddress, s -> {}));\n@@ -1240,11 +1203,7 @@ public void testReconnectAttemptsNotEnough() {\n     client.close();\n     client = vertx.createNetClient(new NetClientOptions().setReconnectAttempts(100).setReconnectInterval(10));\n \n-    client.connect(testAddress, (res) -> {\n-      assertFalse(res.succeeded());\n-      assertTrue(res.failed());\n-      testComplete();\n-    });\n+    client.connect(testAddress).onComplete(onFailure(err -> testComplete()));\n \n     await();\n   }\n@@ -1351,8 +1310,8 @@ private void testTimeout(NetClientOptions clientOptions, NetServerOptions server\n     };\n     Handler<NetSocket> clientHandler = clientSends ? sender : receiver;\n     Handler<NetSocket> serverHandler = clientSends ? receiver : sender;\n-    server.connectHandler(serverHandler).listen(testAddress, onSuccess(s -> {\n-      client.connect(testAddress, onSuccess(clientHandler::handle));\n+    server.connectHandler(serverHandler).listen(testAddress).onComplete(onSuccess(s -> {\n+      client.connect(testAddress).onComplete(onSuccess(clientHandler::handle));\n     }));\n     await();\n   }\n@@ -1639,7 +1598,7 @@ public void testServerCertificateMultipleWrongAlias() throws Exception {\n       .serverCert(Cert.MULTIPLE_JKS_WRONG_ALIAS)\n       .clientTrustAll(true);\n     test.setupServer(true);\n-    server.listen(test.bindAddress, onFailure(t -> {\n+    server.listen(test.bindAddress).onComplete(onFailure(t -> {\n       assertThat(t, is(instanceOf(IllegalArgumentException.class)));\n       assertThat(t.getMessage(), containsString(\"alias does not exist in the keystore\"));\n       testComplete();\n@@ -1860,7 +1819,7 @@ void setupServer(boolean shouldPass) {\n                   complete();\n                 });\n               }\n-              socket.upgradeToSsl(handler);\n+              socket.upgradeToSsl().onComplete(handler);\n             } else {\n               assertTrue(socket.isSsl());\n               assertEquals(1, upgradedServerCount.get());\n@@ -1875,7 +1834,7 @@ void setupServer(boolean shouldPass) {\n \n     void run(boolean shouldPass) {\n       setupServer(shouldPass);\n-      server.listen(bindAddress, onSuccess(ar -> {\n+      server.listen(bindAddress).onComplete(onSuccess(ar -> {\n         client.close();\n         NetClientOptions clientOptions = new NetClientOptions();\n         if (!startTLS) {\n@@ -1991,7 +1950,7 @@ public void testListenDomainSocketAddress() throws Exception {\n     for (int i = 0;i < len;i++) {\n       for (int j = 0;j < len;j++) {\n         SocketAddress sockAddress = addresses.get(i);\n-        client.connect(sockAddress, onSuccess(so -> {\n+        client.connect(sockAddress).onComplete(onSuccess(so -> {\n           Buffer received = Buffer.buffer();\n           so.handler(received::appendBuffer);\n           so.closeHandler(v -> {\n@@ -2030,7 +1989,7 @@ public void testSharedServersRoundRobin() throws Exception {\n       theServer.connectHandler(sock -> {\n         connectCount.compute(theServer, (s, cur) -> cur == null ? 1 : cur + 1);\n         latchConns.countDown();\n-      }).listen(testAddress, onSuccess(s -> latchListen.countDown()));\n+      }).listen(testAddress).onComplete(onSuccess(s -> latchListen.countDown()));\n     }\n     assertTrue(latchListen.await(10, TimeUnit.SECONDS));\n \n@@ -2041,7 +2000,7 @@ public void testSharedServersRoundRobin() throws Exception {\n     AtomicInteger connecting = new AtomicInteger(10);\n     for (int i = 0; i < numConnections; i++) {\n       connecting.decrementAndGet();\n-      client.connect(testAddress, res -> {\n+      client.connect(testAddress).onComplete(res -> {\n         connecting.incrementAndGet();\n         if (res.succeeded()) {\n           latchClient.countDown();\n@@ -2076,7 +2035,7 @@ public void testSharedServersRoundRobinWithOtherServerRunningOnDifferentPort() t\n     server = vertx.createNetServer(new NetServerOptions().setPort(4321));\n     server.connectHandler(sock -> {\n       fail(\"Should not connect\");\n-    }).listen(ar2 -> {\n+    }).listen().onComplete(ar2 -> {\n       if (ar2.succeeded()) {\n         latch.countDown();\n       } else {\n@@ -2095,7 +2054,7 @@ public void testSharedServersRoundRobinButFirstStartAndStopServer() throws Excep\n     server = vertx.createNetServer();\n     server.connectHandler(sock -> {\n       fail(\"Should not connect\");\n-    }).listen(testAddress, ar -> {\n+    }).listen(testAddress).onComplete(ar -> {\n       if (ar.succeeded()) {\n         latch.countDown();\n       } else {\n@@ -2104,10 +2063,7 @@ public void testSharedServersRoundRobinButFirstStartAndStopServer() throws Excep\n     });\n     awaitLatch(latch);\n     CountDownLatch closeLatch = new CountDownLatch(1);\n-    server.close(ar -> {\n-      assertTrue(ar.succeeded());\n-      closeLatch.countDown();\n-    });\n+    server.close().onComplete(onSuccess(v -> closeLatch.countDown()));\n     assertTrue(closeLatch.await(10, TimeUnit.SECONDS));\n \n     Thread.sleep(500); // Let some time\n@@ -2128,9 +2084,7 @@ public void testClosingVertxCloseSharedServers() throws Exception {\n       servers.add((NetServerImpl) server);\n     }\n     CountDownLatch latch = new CountDownLatch(1);\n-    vertx.close(onSuccess(v -> {\n-      latch.countDown();\n-    }));\n+    vertx.close().onComplete(onSuccess(v -> latch.countDown()));\n     awaitLatch(latch);\n     servers.forEach(server -> {\n       assertTrue(server.isClosed());\n@@ -2150,7 +2104,7 @@ public void testWriteHandlerIdNullByDefault() throws Exception {\n     });\n     startServer();\n     waitFor(2);\n-    client.connect(testAddress, onSuccess(socket -> {\n+    client.connect(testAddress).onComplete(onSuccess(socket -> {\n       assertNull(socket.writeHandlerID());\n       socket\n         .closeHandler(v -> complete())\n@@ -2188,7 +2142,7 @@ public void testFanout() throws Exception {\n \n     CountDownLatch receivedLatch = new CountDownLatch(numConnections);\n     for (int i = 0; i < numConnections; i++) {\n-      client.connect(testAddress, onSuccess(socket -> {\n+      client.connect(testAddress).onComplete(onSuccess(socket -> {\n         socket.handler(data -> {\n           receivedLatch.countDown();\n         });\n@@ -2207,17 +2161,16 @@ public void testRemoteAddress() {\n       assertEquals(null, addr.hostName());\n       assertEquals(\"127.0.0.1\", addr.hostAddress());\n       socket.close();\n-    }).listen(1234, \"localhost\", ar -> {\n-      assertTrue(ar.succeeded());\n-      vertx.createNetClient(new NetClientOptions()).connect(1234, \"localhost\", onSuccess(socket -> {\n+    }).listen(1234, \"localhost\").onComplete(onSuccess(v -> {\n+      vertx.createNetClient(new NetClientOptions()).connect(1234, \"localhost\").onComplete(onSuccess(socket -> {\n         SocketAddress addr = socket.remoteAddress();\n         assertEquals(\"localhost\", addr.host());\n         assertEquals(\"localhost\", addr.hostName());\n         assertEquals(\"127.0.0.1\", addr.hostAddress());\n         assertEquals(addr.port(), 1234);\n-        socket.closeHandler(v -> testComplete());\n+        socket.closeHandler(v2 -> testComplete());\n       }));\n-    });\n+    }));\n     await();\n   }\n \n@@ -2231,15 +2184,13 @@ public void testWriteSameBufferMoreThanOnce() throws Exception {\n           testComplete();\n         }\n       });\n-    }).listen(testAddress, ar -> {\n-      assertTrue(ar.succeeded());\n-      client.connect(testAddress, result -> {\n-        NetSocket socket = result.result();\n+    }).listen(testAddress).onComplete(onSuccess(v -> {\n+      client.connect(testAddress).onComplete(onSuccess(socket -> {\n         Buffer buff = Buffer.buffer(\"foo\");\n         socket.write(buff);\n         socket.write(buff);\n-      });\n-    });\n+      }));\n+    }));\n     await();\n   }\n \n@@ -2261,16 +2212,13 @@ public void sendFileClientToServer() throws Exception {\n       // Send some data to the client to trigger the sendfile\n       sock.write(\"foo\");\n     });\n-    server.listen(testAddress, ar -> {\n-      assertTrue(ar.succeeded());\n-      client.connect(testAddress, ar2 -> {\n-        assertTrue(ar2.succeeded());\n-        NetSocket sock = ar2.result();\n+    server.listen(testAddress).onComplete(onSuccess(v -> {\n+      client.connect(testAddress).onComplete(onSuccess(sock -> {\n         sock.handler(buf -> {\n           sock.sendFile(file.getAbsolutePath());\n         });\n-      });\n-    });\n+      }));\n+    }));\n \n     await();\n   }\n@@ -2287,11 +2235,8 @@ public void sendFileServerToClient() throws Exception {\n         sock.sendFile(file.getAbsolutePath());\n       });\n     });\n-    server.listen(testAddress, ar -> {\n-      assertTrue(ar.succeeded());\n-      client.connect(testAddress, ar2 -> {\n-        assertTrue(ar2.succeeded());\n-        NetSocket sock = ar2.result();\n+    server.listen(testAddress).onComplete(onSuccess(v -> {\n+      client.connect(testAddress).onComplete(onSuccess(sock -> {\n         sock.handler(buff -> {\n           received.appendBuffer(buff);\n           if (received.length() == expected.length()) {\n@@ -2300,8 +2245,8 @@ public void sendFileServerToClient() throws Exception {\n           }\n         });\n         sock.write(\"foo\");\n-      });\n-    });\n+      }));\n+    }));\n \n     await();\n   }\n@@ -2313,17 +2258,14 @@ public void testSendFileDirectory() throws Exception {\n       socket.handler(buff -> {\n         fail(\"Should not receive any data\");\n       });\n-    }).listen(testAddress, ar -> {\n-      assertTrue(ar.succeeded());\n-      client.connect(testAddress, result -> {\n-        assertTrue(result.succeeded());\n-        NetSocket socket = result.result();\n+    }).listen(testAddress).onComplete(onSuccess(v -> {\n+      client.connect(testAddress).onComplete(onSuccess(socket -> {\n         socket.sendFile(fDir.getAbsolutePath()).onComplete(onFailure(err -> {\n           assertEquals(FileNotFoundException.class, err.getClass());\n           testComplete();\n         }));\n-      });\n-    });\n+      }));\n+    }));\n     await();\n   }\n \n@@ -2337,12 +2279,9 @@ public void testServerOptionsCopiedBeforeUse() {\n     server.connectHandler(sock -> {\n       testComplete();\n     });\n-    server.listen(ar -> {\n-      assertTrue(ar.succeeded());\n-      client.connect(1234, \"localhost\", ar2 -> {\n-        assertTrue(ar2.succeeded());\n-      });\n-    });\n+    server.listen().onComplete(onSuccess(v -> {\n+      client.connect(1234, \"localhost\").onComplete(onSuccess(v2 -> {}));\n+    }));\n     await();\n   }\n \n@@ -2356,12 +2295,9 @@ public void testClientOptionsCopiedBeforeUse() {\n     server.connectHandler(sock -> {\n       testComplete();\n     });\n-    server.listen(1234, \"localhost\", ar -> {\n-      assertTrue(ar.succeeded());\n-      client.connect(1234, \"localhost\", ar2 -> {\n-        assertTrue(ar2.succeeded());\n-      });\n-    });\n+    server.listen(1234, \"localhost\").onComplete(onSuccess(v1 -> {\n+      client.connect(1234, \"localhost\").onComplete(onSuccess(v2 -> {}));\n+    }));\n     await();\n   }\n \n@@ -2378,9 +2314,7 @@ public void testListenWithNoHandler() {\n   @Test\n   public void testListenWithNoHandler2() {\n     try {\n-      server.listen(testAddress, ar -> {\n-        assertFalse(ar.succeeded());\n-      });\n+      server.listen(testAddress).onComplete(onFailure(err -> {}));\n       fail(\"Should throw exception\");\n     } catch (IllegalStateException e) {\n       // OK\n@@ -2391,7 +2325,7 @@ public void testListenWithNoHandler2() {\n   public void testSetHandlerAfterListen() {\n     server.connectHandler(sock -> {\n     });\n-    server.listen(testAddress, onSuccess(v -> testComplete()));\n+    server.listen(testAddress).onComplete(onSuccess(v -> testComplete()));\n     try {\n       server.connectHandler(sock -> {\n       });\n@@ -2406,8 +2340,7 @@ public void testSetHandlerAfterListen() {\n   public void testSetHandlerAfterListen2() {\n     server.connectHandler(sock -> {\n     });\n-    server.listen(testAddress, ar -> {\n-      assertTrue(ar.succeeded());\n+    server.listen(testAddress).onComplete(onSuccess(v -> {\n       try {\n         server.connectHandler(sock -> {\n         });\n@@ -2416,17 +2349,17 @@ public void testSetHandlerAfterListen2() {\n         // OK\n       }\n       testComplete();\n-    });\n+    }));\n     await();\n   }\n \n   @Test\n   public void testListenTwice() {\n     server.connectHandler(sock -> {\n     });\n-    server.listen(testAddress, onSuccess(s -> {\n+    server.listen(testAddress).onComplete(onSuccess(s -> {\n       try {\n-        server.listen(testAddress, res -> {});\n+        server.listen(testAddress);\n         fail(\"Should throw exception\");\n       } catch (IllegalStateException e) {\n         // OK\n@@ -2441,8 +2374,8 @@ public void testListenTwice() {\n   @Test\n   public void testListenOnPortNoHandler() {\n     server.connectHandler(NetSocket::close);\n-    server.listen(1234, onSuccess(ns -> {\n-      client.connect(1234, \"localhost\", onSuccess(so -> {\n+    server.listen(1234).onComplete(onSuccess(ns -> {\n+      client.connect(1234, \"localhost\").onComplete(onSuccess(so -> {\n         so.closeHandler(v -> {\n           testComplete();\n         });\n@@ -2454,8 +2387,8 @@ public void testListenOnPortNoHandler() {\n   @Test\n   public void testListen() {\n     server.connectHandler(NetSocket::close);\n-    server.listen(testAddress, onSuccess(ns -> {\n-      client.connect(testAddress, onSuccess(so -> {\n+    server.listen(testAddress).onComplete(onSuccess(ns -> {\n+      client.connect(testAddress).onComplete(onSuccess(so -> {\n         so.closeHandler(v -> {\n           testComplete();\n         });\n@@ -2468,17 +2401,15 @@ public void testListen() {\n   public void testListenTwice2() {\n     server.connectHandler(sock -> {\n     });\n-    server.listen(testAddress, ar -> {\n-      assertTrue(ar.succeeded());\n+    server.listen(testAddress).onComplete(onSuccess(v -> {\n       try {\n-        server.listen(testAddress, sock -> {\n-        });\n+        server.listen(testAddress);\n         fail(\"Should throw exception\");\n       } catch (IllegalStateException e) {\n         // OK\n       }\n       testComplete();\n-    });\n+    }));\n     await();\n   }\n \n@@ -2492,8 +2423,7 @@ public void testCloseTwice() {\n   public void testAttemptConnectAfterClose() {\n     client.close();\n     try {\n-      client.connect(testAddress, ar -> {\n-      });\n+      client.connect(testAddress);\n       fail(\"Should throw exception\");\n     } catch (IllegalStateException e) {\n       //OK\n@@ -2507,9 +2437,9 @@ public void testCloseWithHandler() {\n       so.closeHandler(v -> {\n         complete();\n       });\n-    }).listen(testAddress, onSuccess(s -> {\n-      client.connect(testAddress, onSuccess(so -> {\n-        so.close(onSuccess(v -> {\n+    }).listen(testAddress).onComplete(onSuccess(s -> {\n+      client.connect(testAddress).onComplete(onSuccess(so -> {\n+        so.close().onComplete(onSuccess(v -> {\n           complete();\n         }));\n       }));\n@@ -2524,13 +2454,10 @@ public void testClientMultiThreaded() throws Exception {\n     CountDownLatch latch = new CountDownLatch(numThreads);\n     server.connectHandler(socket -> {\n       socket.handler(socket::write);\n-    }).listen(testAddress, ar -> {\n-      assertTrue(ar.succeeded());\n+    }).listen(testAddress).onComplete(onSuccess(c -> {\n       for (int i = 0; i < numThreads; i++) {\n-        threads[i] = new Thread(() -> client.connect(testAddress, result -> {\n-          assertTrue(result.succeeded());\n+        threads[i] = new Thread(() -> client.connect(testAddress).onComplete(onSuccess(sock -> {\n           Buffer buff = randomBuffer(100000);\n-          NetSocket sock = result.result();\n           sock.write(buff);\n           Buffer received = Buffer.buffer();\n           sock.handler(rec -> {\n@@ -2540,10 +2467,10 @@ public void testClientMultiThreaded() throws Exception {\n               latch.countDown();\n             }\n           });\n-        }));\n+        })));\n         threads[i].start();\n       }\n-    });\n+    }));\n     awaitLatch(latch);\n     for (int i = 0; i < numThreads; i++) {\n       threads[i].join();\n@@ -2579,20 +2506,17 @@ public void start() {\n             assertSame(thr, Thread.currentThread());\n           }\n         });\n-        server.listen(testAddress, ar -> {\n-          assertTrue(ar.succeeded());\n+        server.listen(testAddress).onComplete(onSuccess(ar -> {\n           assertSame(ctx, context);\n           if (!worker) {\n             assertSame(thr, Thread.currentThread());\n           }\n           client = vertx.createNetClient(new NetClientOptions());\n-          client.connect(testAddress, ar2 -> {\n+          client.connect(testAddress).onComplete(onSuccess(sock -> {\n             assertSame(ctx, context);\n             if (!worker) {\n               assertSame(thr, Thread.currentThread());\n             }\n-            assertTrue(ar2.succeeded());\n-            NetSocket sock = ar2.result();\n             Buffer buff = TestUtils.randomBuffer(10000);\n             sock.write(buff);\n             Buffer brec = Buffer.buffer();\n@@ -2606,8 +2530,8 @@ public void start() {\n                 testComplete();\n               }\n             });\n-          });\n-        });\n+          }));\n+        }));\n       }\n     }\n     MyVerticle verticle = new MyVerticle();\n@@ -2633,7 +2557,7 @@ public void testContexts() throws Exception {\n     });\n     CountDownLatch listenLatch = new CountDownLatch(1);\n     AtomicReference<Context> listenContext = new AtomicReference<>();\n-    server.listen(testAddress, onSuccess(v -> {\n+    server.listen(testAddress).onComplete(onSuccess(v -> {\n       listenContext.set(Vertx.currentContext());\n       listenLatch.countDown();\n     }));\n@@ -2646,7 +2570,7 @@ public void testContexts() throws Exception {\n     for (int i = 0; i < numConnections; i++) {\n       Context context = ((VertxInternal)vertx).createEventLoopContext();\n       context.runOnContext(v -> {\n-        client.connect(testAddress, conn -> {\n+        client.connect(testAddress).onComplete(conn -> {\n           contexts.add(Vertx.currentContext());\n           if (connectCount.incrementAndGet() == numConnections) {\n             assertEquals(numConnections, contexts.size());\n@@ -2659,15 +2583,14 @@ public void testContexts() throws Exception {\n     awaitLatch(serverLatch);\n \n     // Close should be in own context\n-    server.close(ar -> {\n-      assertTrue(ar.succeeded());\n+    server.close().onComplete(onSuccess(ar -> {\n       Context closeContext = Vertx.currentContext();\n       assertFalse(contexts.contains(closeContext));\n       assertSame(serverConnectContext.get(), closeContext);\n       assertFalse(contexts.contains(listenContext.get()));\n       assertSame(serverConnectContext.get(), listenContext.get());\n       testComplete();\n-    });\n+    }));\n \n     await();\n   }\n@@ -2683,32 +2606,27 @@ public void testReadStreamPauseResume() {\n       so.write(\"hello\");\n       so.close();\n     });\n-    server.listen(testAddress, ar -> {\n-      assertTrue(ar.succeeded());\n+    server.listen(testAddress).onComplete(onSuccess(v -> {\n       paused.set(true);\n       socketStream.pause();\n-      client.connect(testAddress, ar2 -> {\n-        assertTrue(ar2.succeeded());\n-        NetSocket so2 = ar2.result();\n+      client.connect(testAddress).onComplete(onSuccess(so2 -> {\n         so2.handler(buffer -> {\n           fail();\n         });\n-        so2.closeHandler(v -> {\n+        so2.closeHandler(v2 -> {\n           paused.set(false);\n           socketStream.resume();\n-          client.connect(testAddress, ar3 -> {\n-            assertTrue(ar3.succeeded());\n-            NetSocket so3 = ar3.result();\n+          client.connect(testAddress).onComplete(onSuccess(so3 -> {\n             Buffer buffer = Buffer.buffer();\n             so3.handler(buffer::appendBuffer);\n             so3.closeHandler(v3 -> {\n               assertEquals(\"hello\", buffer.toString(\"utf-8\"));\n               testComplete();\n             });\n-          });\n+          }));\n         });\n-      });\n-    });\n+      }));\n+    }));\n     await();\n   }\n \n@@ -2724,11 +2642,11 @@ public void testMultipleServerClose() {\n       assertTrue(Vertx.currentContext().isEventLoopContext());\n       times.incrementAndGet();\n     });\n-    server.close(ar1 -> {\n+    server.close().onComplete(ar1 -> {\n       assertNull(stack.get());\n       assertTrue(Vertx.currentContext().isEventLoopContext());\n-      server.close(ar2 -> {\n-        server.close(ar3 -> {\n+      server.close().onComplete(ar2 -> {\n+        server.close().onComplete(ar3 -> {\n           assertEquals(1, times.get());\n           testComplete();\n         });\n@@ -2769,12 +2687,12 @@ public void start() throws Exception {\n             assertSame(context, Vertx.currentContext());\n             complete();\n           });\n-        }).listen(testAddress, onSuccess(s -> {\n+        }).listen(testAddress).onComplete(onSuccess(s -> {\n           assertTrue(Vertx.currentContext().isWorkerContext());\n           assertTrue(Context.isOnWorkerThread());\n           assertSame(context, Vertx.currentContext());\n           NetClient client = vertx.createNetClient();\n-          client.connect(testAddress, onSuccess(res -> {\n+          client.connect(testAddress).onComplete(onSuccess(res -> {\n             assertTrue(Vertx.currentContext().isWorkerContext());\n             assertTrue(Context.isOnWorkerThread());\n             assertSame(context, Vertx.currentContext());\n@@ -2818,22 +2736,17 @@ public void testAsyncWriteIsFlushed() throws Exception {\n       startServer();\n       AtomicInteger done = new AtomicInteger();\n       for (int i = 0;i < num;i++) {\n-        client.connect(testAddress, ar -> {\n-          if (ar.succeeded()) {\n-            NetSocket so = ar.result();\n-            so.handler(buff -> {\n-              assertEquals(expected, buff);\n-              so.close();\n-              int val = done.incrementAndGet();\n-              if (val == num) {\n-                testComplete();\n-              }\n-            });\n-            so.write(TestUtils.randomBuffer(256));\n-          } else {\n-            ar.cause().printStackTrace();\n-          }\n-        });\n+        client.connect(testAddress).onComplete(onSuccess(so -> {\n+          so.handler(buff -> {\n+            assertEquals(expected, buff);\n+            so.close();\n+            int val = done.incrementAndGet();\n+            if (val == num) {\n+              testComplete();\n+            }\n+          });\n+          so.write(TestUtils.randomBuffer(256));\n+        }));\n       }\n       await();\n     } finally {\n@@ -2865,27 +2778,24 @@ public void testServerWorkerMissBufferWhenBufferArriveBeforeConnectCallback() th\n           testComplete();\n         });\n       });\n-      server.listen(testAddress, ar -> {\n-        assertTrue(ar.succeeded());\n+      server.listen(testAddress).onComplete(onSuccess(v2 -> {\n         // Create a one second worker starvation\n         for (int i = 1; i < workers.size(); i++) {\n-          workers.get(i).runOnContext(v2 -> {\n+          workers.get(i).runOnContext(v3 -> {\n             latch1.countDown();\n             try {\n               Thread.sleep(1000);\n             } catch (InterruptedException ignore) {\n             }\n           });\n         }\n-      });\n+      }));\n     });\n     awaitLatch(latch1);\n     NetClient client = vertx.createNetClient();\n-    client.connect(testAddress, ar -> {\n-      assertTrue(ar.succeeded());\n-      NetSocket so = ar.result();\n+    client.connect(testAddress).onComplete(onSuccess(so -> {\n       so.write(Buffer.buffer(\"hello\"));\n-    });\n+    }));\n     await();\n   }\n \n@@ -2905,21 +2815,18 @@ public void testClientWorkerMissBufferWhenBufferArriveBeforeConnectCallback() th\n       }\n       so.write(Buffer.buffer(\"hello\"));\n     });\n-    server.listen(testAddress, ar -> {\n-      assertTrue(ar.succeeded());\n+    server.listen(testAddress).onComplete(onSuccess(v -> {\n       latch1.countDown();\n-    });\n+    }));\n     awaitLatch(latch1);\n     workers.get(0).runOnContext(v -> {\n       NetClient client = vertx.createNetClient();\n-      client.connect(testAddress, ar -> {\n-        assertTrue(ar.succeeded());\n-        NetSocket so = ar.result();\n+      client.connect(testAddress).onComplete(onSuccess(so -> {\n         so.handler(buf -> {\n           assertEquals(\"hello\", buf.toString());\n           testComplete();\n         });\n-      });\n+      }));\n       // Create a one second worker starvation\n       for (int i = 1; i < workers.size(); i++) {\n         workers.get(i).runOnContext(v2 -> {\n@@ -2952,14 +2859,13 @@ public void testHostVerificationHttpsNotMatching() {\n     server.connectHandler(sock -> {\n \n     });\n-    server.listen(ar -> {\n-      assertTrue(ar.succeeded());\n-      client.connect(1234, \"localhost\", ar2 -> {\n-        //Should not be able to connect\n-        assertTrue(ar2.failed());\n-        testComplete();\n-      });\n-    });\n+    server\n+      .listen()\n+      .compose(v -> client.connect(1234, \"localhost\"))\n+      .onComplete(onFailure(err -> {\n+      //Should not be able to connect\n+      testComplete();\n+    }));\n     await();\n   }\n \n@@ -2984,14 +2890,12 @@ public void testHostVerificationHttpsMatching() {\n     server.connectHandler(sock -> {\n \n     });\n-    server.listen(ar -> {\n-      assertTrue(ar.succeeded());\n-      client.connect(1234, \"localhost\", ar2 -> {\n+    server.listen().onComplete(onSuccess(v -> {\n+      client.connect(1234, \"localhost\").onComplete(onSuccess(so -> {\n         //Should be able to connect\n-        assertTrue(ar2.succeeded());\n         testComplete();\n-      });\n-    });\n+      }));\n+    }));\n     await();\n   }\n \n@@ -3022,8 +2926,8 @@ private TestLoggerFactory testLogging() throws Exception {\n       server.connectHandler(so -> {\n         so.end(Buffer.buffer(\"fizzbuzz\"));\n       });\n-      server.listen(testAddress, onSuccess(v1 -> {\n-        client.connect(testAddress, onSuccess(so -> {\n+      server.listen(testAddress).onComplete(onSuccess(v1 -> {\n+        client.connect(testAddress).onComplete(onSuccess(so -> {\n           so.closeHandler(v2 -> testComplete());\n         }));\n       }));\n@@ -3044,18 +2948,14 @@ public void testWithSocks5Proxy() throws Exception {\n     });\n     proxy = new SocksProxy();\n     proxy.start(vertx);\n-    server.listen(1234, \"localhost\", ar -> {\n-      assertTrue(ar.succeeded());\n-      client.connect(1234, \"localhost\", ar2 -> {\n-        if (ar2.failed()) {\n-          log.warn(\"failed\", ar2.cause());\n-        }\n-        assertTrue(ar2.succeeded());\n+    server.listen(1234, \"localhost\")\n+      .onComplete(onSuccess(v -> {\n+      client.connect(1234, \"localhost\").onComplete(onSuccess(so -> {\n         // make sure we have gone through the proxy\n         assertEquals(\"localhost:1234\", proxy.getLastUri());\n         testComplete();\n-      });\n-    });\n+      }));\n+    }));\n     await();\n   }\n \n@@ -3073,13 +2973,11 @@ public void testWithSocks5ProxyAuth() throws Exception {\n     });\n     proxy = new SocksProxy().username(\"username\");\n     proxy.start(vertx);\n-    server.listen(1234, \"localhost\", ar -> {\n-      assertTrue(ar.succeeded());\n-      client.connect(1234, \"localhost\", ar2 -> {\n-        assertTrue(ar2.succeeded());\n+    server.listen(1234, \"localhost\").onComplete(onSuccess(c -> {\n+      client.connect(1234, \"localhost\").onComplete(onSuccess(so -> {\n         testComplete();\n-      });\n-    });\n+      }));\n+    }));\n     await();\n   }\n \n@@ -3107,13 +3005,11 @@ public void testConnectSSLWithSocks5Proxy() throws Exception {\n     });\n     proxy = new SocksProxy();\n     proxy.start(vertx);\n-    server.listen(ar -> {\n-      assertTrue(ar.succeeded());\n-      client.connect(1234, \"localhost\", ar2 -> {\n-        assertTrue(ar2.succeeded());\n+    server.listen().onComplete(onSuccess(v -> {\n+      client.connect(1234, \"localhost\").onComplete(onSuccess(so -> {\n         testComplete();\n-      });\n-    });\n+      }));\n+    }));\n     await();\n   }\n \n@@ -3141,16 +3037,13 @@ public void testUpgradeSSLWithSocks5Proxy() throws Exception {\n     });\n     proxy = new SocksProxy();\n     proxy.start(vertx);\n-    server.listen(ar -> {\n-      assertTrue(ar.succeeded());\n-      client.connect(1234, \"localhost\", ar2 -> {\n-        assertTrue(ar2.succeeded());\n-        NetSocket ns = ar2.result();\n-        ns.upgradeToSsl(onSuccess(v2 -> {\n+    server.listen().onComplete(onSuccess(v -> {\n+      client.connect(1234, \"localhost\").onComplete(onSuccess(ns -> {\n+        ns.upgradeToSsl().onComplete(onSuccess(v2 -> {\n           testComplete();\n         }));\n-      });\n-    });\n+      }));\n+    }));\n     await();\n   }\n \n@@ -3169,18 +3062,13 @@ public void testWithHttpConnectProxy() throws Exception {\n     });\n     proxy = new HttpProxy();\n     proxy.start(vertx);\n-    server.listen(1234, \"localhost\", ar -> {\n-      assertTrue(ar.succeeded());\n-      client.connect(1234, \"localhost\", ar2 -> {\n-        if (ar2.failed()) {\n-          log.warn(\"failed\", ar2.cause());\n-        }\n-        assertTrue(ar2.succeeded());\n+    server.listen(1234, \"localhost\").onComplete(onSuccess(ar -> {\n+      client.connect(1234, \"localhost\").onComplete(onSuccess(so -> {\n         // make sure we have gone through the proxy\n         assertEquals(\"localhost:1234\", proxy.getLastUri());\n         testComplete();\n-      });\n-    });\n+      }));\n+    }));\n     await();\n   }\n \n@@ -3197,18 +3085,13 @@ public void testWithSocks4aProxy() throws Exception {\n     });\n     proxy = new Socks4Proxy();\n     proxy.start(vertx);\n-    server.listen(1234, \"localhost\", ar -> {\n-      assertTrue(ar.succeeded());\n-      client.connect(1234, \"localhost\", ar2 -> {\n-        if (ar2.failed()) {\n-          log.warn(\"failed\", ar2.cause());\n-        }\n-        assertTrue(ar2.succeeded());\n+    server.listen(1234, \"localhost\").onComplete(onSuccess(v -> {\n+      client.connect(1234, \"localhost\").onComplete(onSuccess(so -> {\n         // make sure we have gone through the proxy\n         assertEquals(\"localhost:1234\", proxy.getLastUri());\n         testComplete();\n-      });\n-    });\n+      }));\n+    }));\n     await();\n   }\n \n@@ -3226,18 +3109,13 @@ public void testWithSocks4aProxyAuth() throws Exception {\n     });\n     proxy = new Socks4Proxy().username(\"username\");\n     proxy.start(vertx);\n-    server.listen(1234, \"localhost\", ar -> {\n-      assertTrue(ar.succeeded());\n-      client.connect(1234, \"localhost\", ar2 -> {\n-        if (ar2.failed()) {\n-          log.warn(\"failed\", ar2.cause());\n-        }\n-        assertTrue(ar2.succeeded());\n+    server.listen(1234, \"localhost\").onComplete(onSuccess(v -> {\n+      client.connect(1234, \"localhost\").onComplete(onSuccess(so -> {\n         // make sure we have gone through the proxy\n         assertEquals(\"localhost:1234\", proxy.getLastUri());\n         testComplete();\n-      });\n-    });\n+      }));\n+    }));\n     await();\n   }\n \n@@ -3253,18 +3131,13 @@ public void testWithSocks4LocalResolver() throws Exception {\n \n     });\n     proxy = new Socks4Proxy().start(vertx);\n-    server.listen(1234, \"localhost\", ar -> {\n-      assertTrue(ar.succeeded());\n-      client.connect(1234, \"127.0.0.1\", ar2 -> {\n-        if (ar2.failed()) {\n-          log.warn(\"failed\", ar2.cause());\n-        }\n-        assertTrue(ar2.succeeded());\n+    server.listen(1234, \"localhost\").onComplete(onSuccess(v -> {\n+      client.connect(1234, \"127.0.0.1\").onComplete(onSuccess(so -> {\n         // make sure we have gone through the proxy\n         assertEquals(\"127.0.0.1:1234\", proxy.getLastUri());\n         testComplete();\n-      });\n-    });\n+      }));\n+    }));\n     await();\n   }\n \n@@ -3279,8 +3152,8 @@ public void testNonProxyHosts() throws Exception {\n     });\n     proxy = new HttpProxy();\n     proxy.start(vertx);\n-    server.listen(1234, \"localhost\", onSuccess(s -> {\n-      client.connect(1234, \"example.com\", onSuccess(so -> {\n+    server.listen(1234, \"localhost\").onComplete(onSuccess(s -> {\n+      client.connect(1234, \"example.com\").onComplete(onSuccess(so -> {\n         assertNull(proxy.getLastUri());\n         testComplete();\n       }));\n@@ -3293,25 +3166,20 @@ public void testTLSHostnameCertCheckCorrect() {\n     server.close();\n     server = vertx.createNetServer(new NetServerOptions().setSsl(true).setPort(4043)\n         .setKeyCertOptions(Cert.SERVER_JKS_ROOT_CA.get()));\n-    server.connectHandler(netSocket -> netSocket.close()).listen(ar -> {\n+    server.connectHandler(netSocket -> netSocket.close()).listen().onComplete(onSuccess(v -> {\n \n       NetClientOptions options = new NetClientOptions()\n           .setHostnameVerificationAlgorithm(\"HTTPS\")\n           .setTrustOptions(Trust.SERVER_JKS_ROOT_CA.get());\n \n       NetClient client = vertx.createNetClient(options);\n \n-      client.connect(4043, \"localhost\", arSocket -> {\n-        if (arSocket.succeeded()) {\n-          NetSocket ns = arSocket.result();\n-          ns.upgradeToSsl(onSuccess(v -> {\n-            testComplete();\n-          }));\n-        } else {\n-          fail(ar.cause());\n-        }\n-      });\n-    });\n+      client.connect(4043, \"localhost\").onComplete(onSuccess(ns -> {\n+        ns.upgradeToSsl().onComplete(onSuccess(v2 -> {\n+          testComplete();\n+        }));\n+      }));\n+    }));\n \n     await();\n   }\n@@ -3321,25 +3189,20 @@ public void testTLSHostnameCertCheckIncorrect() {\n     server.close();\n     server = vertx.createNetServer(new NetServerOptions().setSsl(true).setPort(4043)\n         .setKeyCertOptions(Cert.SERVER_JKS_ROOT_CA.get()));\n-    server.connectHandler(netSocket -> netSocket.close()).listen(ar -> {\n+    server.connectHandler(netSocket -> netSocket.close()).listen().onComplete(onSuccess(v -> {\n \n       NetClientOptions options = new NetClientOptions()\n           .setHostnameVerificationAlgorithm(\"HTTPS\")\n           .setTrustOptions(Trust.SERVER_JKS_ROOT_CA.get());\n \n       NetClient client = vertx.createNetClient(options);\n \n-      client.connect(4043, \"127.0.0.1\", arSocket -> {\n-        if (arSocket.succeeded()) {\n-          NetSocket ns = arSocket.result();\n-          ns.upgradeToSsl(onFailure(err -> {\n-            testComplete();\n-          }));\n-        } else {\n-          fail(ar.cause());\n-        }\n-      });\n-    });\n+      client.connect(4043, \"127.0.0.1\").onComplete(onSuccess(ns -> {\n+        ns.upgradeToSsl().onComplete(onFailure(err -> {\n+          testComplete();\n+        }));\n+      }));\n+    }));\n \n     await();\n   }\n@@ -3353,9 +3216,9 @@ public void testUpgradeToSSLIncorrectClientOptions() {\n     server = vertx.createNetServer(new NetServerOptions().setSsl(true).setPort(4043)\n       .setKeyCertOptions(Cert.SERVER_JKS_ROOT_CA.get()));\n     NetClient client = vertx.createNetClient();\n-    server.connectHandler(ns -> {}).listen(onSuccess(v -> {\n-      client.connect(4043, \"127.0.0.1\", onSuccess(ns -> {\n-        ns.upgradeToSsl(onFailure(err -> client.close(onSuccess(s -> testComplete()))));\n+    server.connectHandler(ns -> {}).listen().onComplete(onSuccess(v -> {\n+      client.connect(4043, \"127.0.0.1\").onComplete(onSuccess(ns -> {\n+        ns.upgradeToSsl().onComplete(onFailure(err -> client.close().onComplete(onSuccess(s -> testComplete()))));\n       }));\n     }));\n     await();\n@@ -3371,8 +3234,8 @@ public void testClientLocalAddress() {\n       assertEquals(expectedAddress, sock.remoteAddress().host());\n       sock.close();\n     });\n-    server.listen(1234, \"localhost\", onSuccess(v -> {\n-      client.connect(1234, \"localhost\", onSuccess(socket -> {\n+    server.listen(1234, \"localhost\").onComplete(onSuccess(v -> {\n+      client.connect(1234, \"localhost\").onComplete(onSuccess(socket -> {\n         socket.closeHandler(v2 -> {\n           testComplete();\n         });\n@@ -3406,19 +3269,19 @@ public void testSelfSignedCertificate() throws Exception {\n     server = vertx.createNetServer(serverOptions)\n       .connectHandler(socket -> {\n         socket.end(Buffer.buffer(\"123\"));\n-      })\n-      .listen(testAddress, onSuccess(s -> {\n+      });\n+     server.listen(testAddress).onComplete(onSuccess(s -> {\n \n         client = vertx.createNetClient(clientOptions);\n-        client.connect(testAddress, onSuccess(socket -> {\n+        client.connect(testAddress).onComplete(onSuccess(socket -> {\n           socket.handler(buffer -> {\n             assertEquals(\"123\", buffer.toString());\n             latch.countDown();\n           });\n         }));\n \n         client = vertx.createNetClient(clientTrustAllOptions);\n-        client.connect(testAddress, onSuccess(socket -> {\n+        client.connect(testAddress).onComplete(onSuccess(socket -> {\n           socket.handler(buffer -> {\n             assertEquals(\"123\", buffer.toString());\n             latch.countDown();\n@@ -3442,7 +3305,7 @@ public void testWorkerClient() throws Exception {\n       @Override\n       public void start() throws Exception {\n         NetClient client = vertx.createNetClient();\n-        client.connect(testAddress, onSuccess(so ->{\n+        client.connect(testAddress).onComplete(onSuccess(so ->{\n           assertTrue(Context.isOnWorkerThread());\n           Buffer received = Buffer.buffer();\n           so.handler(buff -> {\n@@ -3490,12 +3353,10 @@ public void start(Promise<Void> startPromise) throws Exception {\n             Thread.currentThread().interrupt();\n           }\n         });\n-        server.listen(testAddress, ar -> {\n-          startPromise.handle(ar.mapEmpty());\n-        });\n+        server.listen(testAddress).<Void>mapEmpty().onComplete(startPromise);\n       }\n-    }, new DeploymentOptions().setWorker(true), onSuccess(v -> {\n-      client.connect(testAddress, onSuccess(so -> {\n+    }, new DeploymentOptions().setWorker(true)).onComplete(onSuccess(v -> {\n+      client.connect(testAddress).onComplete(onSuccess(so -> {\n         so.write(expected);\n         so.close();\n       }));\n@@ -3544,15 +3405,14 @@ private void testNetServerInternal_(HttpClientOptions clientOptions, boolean exp\n     });\n     startServer(SocketAddress.inetSocketAddress(1234, \"localhost\"));\n     HttpClient client = vertx.createHttpClient(clientOptions);\n-    client.request(io.vertx.core.http.HttpMethod.GET, 1234, \"localhost\", \"/somepath\", onSuccess(req -> {\n-      req.send(onSuccess(resp -> {\n-        assertEquals(200, resp.statusCode());\n-        resp.body(onSuccess(body -> {\n-          assertEquals(\"Hello World\", body.toString());\n-          complete();\n-        }));\n+    client.request(io.vertx.core.http.HttpMethod.GET, 1234, \"localhost\", \"/somepath\")\n+      .compose(req -> req\n+        .send()\n+        .andThen(onSuccess(resp -> assertEquals(200, resp.statusCode())))\n+        .compose(HttpClientResponse::body)).onComplete(onSuccess(body -> {\n+        assertEquals(\"Hello World\", body.toString());\n+        complete();\n       }));\n-    }));\n     await();\n   }\n \n@@ -3629,11 +3489,11 @@ private void testNetClientInternal_(HttpServerOptions options, boolean expectSSL\n     server.requestHandler(req -> {\n       req.response().end(\"Hello World\"); });\n     CountDownLatch latch = new CountDownLatch(1);\n-    server.listen(onSuccess(v -> {\n+    server.listen().onComplete(onSuccess(v -> {\n       latch.countDown();\n     }));\n     awaitLatch(latch);\n-    client.connect(1234, \"localhost\", onSuccess(so -> {\n+    client.connect(1234, \"localhost\").onComplete(onSuccess(so -> {\n       NetSocketInternal soInt = (NetSocketInternal) so;\n       assertEquals(expectSSL, soInt.isSsl());\n       ChannelHandlerContext chctx = soInt.channelHandlerContext();\n@@ -3681,7 +3541,7 @@ public void testNetSocketInternalBuffer() throws Exception {\n       });\n     });\n     startServer();\n-    client.connect(testAddress, onSuccess(so -> {\n+    client.connect(testAddress).onComplete(onSuccess(so -> {\n       NetSocketInternal soi = (NetSocketInternal) so;\n       soi.write(Buffer.buffer(\"Hello World\"));\n       soi.handler(msg -> {\n@@ -3713,7 +3573,7 @@ public void testNetSocketInternalDirectBuffer() throws Exception {\n       });\n     });\n     startServer();\n-    client.connect(testAddress, onSuccess(so -> {\n+    client.connect(testAddress).onComplete(onSuccess(so -> {\n       NetSocketInternal soi = (NetSocketInternal) so;\n       soi.write(Buffer.buffer(\"Hello World\"));\n       // soi.messageHandler(msg -> fail(\"Unexpected\"));\n@@ -3739,13 +3599,13 @@ public void testNetSocketInternalRemoveVertxHandler() throws Exception {\n       so.closeHandler(v -> testComplete());\n     });\n     startServer();\n-    client.connect(testAddress, onSuccess(so -> {\n+    client.connect(testAddress).onComplete(onSuccess(so -> {\n       NetSocketInternal soi = (NetSocketInternal) so;\n       String id = soi.writeHandlerID();\n       ChannelHandlerContext ctx = soi.channelHandlerContext();\n       ChannelPipeline pipeline = ctx.pipeline();\n       pipeline.remove(VertxHandler.class);\n-      vertx.eventBus().request(id, \"test\", onFailure(what -> {\n+      vertx.eventBus().request(id, \"test\").onComplete(onFailure(what -> {\n         ctx.close();\n       }));\n     }));\n@@ -3761,8 +3621,8 @@ public void testCloseCompletionHandlerNotCalledWhenActualServerFailed() {\n         .setPemKeyCertOptions(new PemKeyCertOptions().setKeyPath(\"invalid\")))\n       .connectHandler(c -> {\n     });\n-    server.listen(10000, onFailure(err -> {\n-      server.close(onSuccess(v -> {\n+    server.listen(10000).onComplete(onFailure(err -> {\n+      server.close().onComplete(onSuccess(v -> {\n         testComplete();\n       }));\n     }));\n@@ -3794,7 +3654,7 @@ public void testServerNetSocketShouldBeClosedWhenTheClosedHandlerIsCalled() thro\n       });\n     });\n     startServer();\n-    client.connect(testAddress, onSuccess(so -> {\n+    client.connect(testAddress).onComplete(onSuccess(so -> {\n       vertx.setTimer(1000, id -> {\n         so.close();\n       });\n@@ -3823,7 +3683,7 @@ public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n       });\n     });\n     startServer();\n-    client.connect(testAddress, onSuccess(so -> {\n+    client.connect(testAddress).onComplete(onSuccess(so -> {\n       so.closeHandler(v -> testComplete());\n     }));\n     await();\n@@ -3859,7 +3719,7 @@ private void testIdleTimeoutSendChunkedFile(boolean idleOnServer) throws Excepti\n       }\n     };\n     Consumer<NetSocket> sender = so -> {\n-      so.sendFile(sent.getAbsolutePath(), ar -> {\n+      so.sendFile(sent.getAbsolutePath()).onComplete(ar -> {\n         sendResult.set(ar);\n         testChecker.run();\n       });\n@@ -3886,7 +3746,7 @@ private void testIdleTimeoutSendChunkedFile(boolean idleOnServer) throws Excepti\n     startServer();\n     client.close();\n     client = vertx.createNetClient(new NetClientOptions().setIdleTimeout(200).setIdleTimeoutUnit(TimeUnit.MILLISECONDS));\n-    client.connect(testAddress, onSuccess(idleOnServer ? receiver : sender));\n+    client.connect(testAddress).onComplete(onSuccess(idleOnServer ? receiver : sender));\n     await();\n   }\n \n@@ -3910,7 +3770,7 @@ public void testHalfCloseCallsEndHandlerAfterBuffersAreDelivered() throws Except\n       });\n     });\n     startServer();\n-    client.connect(testAddress, \"localhost\", onSuccess(so -> {\n+    client.connect(testAddress, \"localhost\").onComplete(onSuccess(so -> {\n       so.pause();\n       AtomicBoolean closed = new AtomicBoolean();\n       AtomicBoolean ended = new AtomicBoolean();\n@@ -3971,8 +3831,8 @@ public void testSslHandshakeTimeoutHappened(boolean onClient, boolean sni) throw\n       server.exceptionHandler(checker::accept);\n     }\n     server.connectHandler(s -> {\n-    }).listen(testAddress, onSuccess(s -> {\n-      client.connect(testAddress, ar -> {\n+    }).listen(testAddress).onComplete(onSuccess(s -> {\n+      client.connect(testAddress).onComplete(ar -> {\n         if (onClient) {\n           assertTrue(ar.failed());\n           checker.accept(ar.cause());\n@@ -4001,13 +3861,11 @@ public void testSslHandshakeTimeoutNotHappened() throws Exception {\n     client = vertx.createNetClient(clientOptions);\n \n     server.connectHandler(s -> {\n-    }).listen(testAddress, ar -> {\n-      assertTrue(ar.succeeded());\n-      client.connect(testAddress, res -> {\n-        assertTrue(res.succeeded());\n+    }).listen(testAddress).onComplete(onSuccess(v -> {\n+      client.connect(testAddress).onComplete(onSuccess(so -> {\n         testComplete();\n-      });\n-    });\n+      }));\n+    }));\n     await();\n   }\n \n@@ -4029,20 +3887,16 @@ public void testSslHandshakeTimeoutHappenedWhenUpgradeSsl() {\n     client = vertx.createNetClient(clientOptions);\n \n     server.connectHandler(s -> {\n-    }).listen(testAddress, ar -> {\n-      assertTrue(ar.succeeded());\n-      client.connect(testAddress, res -> {\n-        assertTrue(res.succeeded());\n-        NetSocket socket = res.result();\n-\n+    }).listen(testAddress).onComplete(onSuccess(v -> {\n+      client.connect(testAddress).onComplete(onSuccess(socket -> {\n         assertFalse(socket.isSsl());\n-        socket.upgradeToSsl(onFailure(err -> {\n+        socket.upgradeToSsl().onComplete(onFailure(err -> {\n           assertTrue(err instanceof SSLException);\n           assertEquals(\"handshake timed out after 200ms\", err.getMessage());\n           testComplete();\n         }));\n-      });\n-    });\n+      }));\n+    }));\n     await();\n   }\n \n@@ -4061,7 +3915,7 @@ protected void startServer(SocketAddress remoteAddress, Context context) throws\n   protected void startServer(SocketAddress remoteAddress, Context context, NetServer server) throws Exception {\n     CountDownLatch latch = new CountDownLatch(1);\n     context.runOnContext(v -> {\n-      server.listen(remoteAddress, onSuccess(s -> latch.countDown()));\n+      server.listen(remoteAddress).onComplete(onSuccess(s -> latch.countDown()));\n     });\n     awaitLatch(latch);\n   }\n@@ -4082,7 +3936,7 @@ public void testPausedDuringLastChunk() throws Exception {\n       });\n     });\n     startServer();\n-    client.connect(testAddress, \"localhost\", onSuccess(so -> {\n+    client.connect(testAddress, \"localhost\").onComplete(onSuccess(so -> {\n       so.close();\n     }));\n     await();\n@@ -4136,7 +3990,7 @@ public void testNetSocketHandlerFailureReportedToContextExceptionHandler() throw\n       });\n     });\n     startServer(testAddress);\n-    client.connect(testAddress, onSuccess(so -> {\n+    client.connect(testAddress).onComplete(onSuccess(so -> {\n       so.write(\"ping\");\n       so.close();\n     }));",
      "parent_sha": "f5d7348b4e15febb85b76c6bcac1ee34d2ad1835"
    }
  },
  {
    "oid": "f7cbccb16d70170b08d8f7ee6967e9ab8a3e1b55",
    "message": "Fix metrics racy tests",
    "date": "2020-11-14T21:41:45Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/f7cbccb16d70170b08d8f7ee6967e9ab8a3e1b55",
    "details": {
      "sha": "78bc85382144fa9feb33b73830b790eb3861e594",
      "filename": "src/test/java/io/vertx/core/spi/metrics/MetricsTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/f7cbccb16d70170b08d8f7ee6967e9ab8a3e1b55/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fspi%2Fmetrics%2FMetricsTest.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/f7cbccb16d70170b08d8f7ee6967e9ab8a3e1b55/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fspi%2Fmetrics%2FMetricsTest.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/src%2Ftest%2Fjava%2Fio%2Fvertx%2Fcore%2Fspi%2Fmetrics%2FMetricsTest.java?ref=f7cbccb16d70170b08d8f7ee6967e9ab8a3e1b55",
      "patch": "@@ -481,7 +481,7 @@ public void testReplyFailureTimeout1() throws Exception {\n       latch.countDown();\n     });\n     awaitLatch(latch);\n-    assertEquals(1, metrics.getReplyFailureAddresses().size());\n+    waitUntil(() -> metrics.getReplyFailureAddresses().size() == 1);\n     assertEquals(Collections.singletonList(ReplyFailure.TIMEOUT), metrics.getReplyFailures());\n   }\n \n@@ -500,7 +500,7 @@ public void testReplyFailureTimeout2() throws Exception {\n     });\n     awaitLatch(latch);\n     FakeEventBusMetrics metrics = FakeMetricsBase.getMetrics(eb);\n-    assertEquals(1, metrics.getReplyFailureAddresses().size());\n+    waitUntil(() -> metrics.getReplyFailureAddresses().size() == 1);\n     assertEquals(Collections.singletonList(ReplyFailure.TIMEOUT), metrics.getReplyFailures());\n   }\n ",
      "parent_sha": "456aff39703598f681198dbd446d5481df2535c7"
    }
  },
  {
    "oid": "74267e8ef430f9021b8e608253a0e371d018b8ed",
    "message": "minor indentation fix",
    "date": "2014-07-30T09:14:03Z",
    "url": "https://github.com/eclipse-vertx/vert.x/commit/74267e8ef430f9021b8e608253a0e371d018b8ed",
    "details": {
      "sha": "fa75aa38d73cce11cf775cbfae116c3b6bf32d32",
      "filename": "vertx-core/src/main/java/io/vertx/core/file/impl/AsyncFileImpl.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/eclipse-vertx/vert.x/blob/74267e8ef430f9021b8e608253a0e371d018b8ed/vertx-core%2Fsrc%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Ffile%2Fimpl%2FAsyncFileImpl.java",
      "raw_url": "https://github.com/eclipse-vertx/vert.x/raw/74267e8ef430f9021b8e608253a0e371d018b8ed/vertx-core%2Fsrc%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Ffile%2Fimpl%2FAsyncFileImpl.java",
      "contents_url": "https://api.github.com/repos/eclipse-vertx/vert.x/contents/vertx-core%2Fsrc%2Fmain%2Fjava%2Fio%2Fvertx%2Fcore%2Ffile%2Fimpl%2FAsyncFileImpl.java?ref=74267e8ef430f9021b8e608253a0e371d018b8ed",
      "patch": "@@ -112,9 +112,9 @@ public void close(Handler<AsyncResult<Void>> handler) {\n   @Override\n   public AsyncFile write(Buffer buffer, long position,  Handler<AsyncResult<Void>> handler) {\n     check();\n-     ByteBuf buf = buffer.getByteBuf();\n+    ByteBuf buf = buffer.getByteBuf();\n     if (buf.nioBufferCount() > 1) {\n-       Iterator<ByteBuffer> buffers = Arrays.asList(buf.nioBuffers()).iterator();\n+      Iterator<ByteBuffer> buffers = Arrays.asList(buf.nioBuffers()).iterator();\n       doWrite(buffers, position, handler);\n     } else {\n       ByteBuffer bb = buf.nioBuffer();\n@@ -124,8 +124,8 @@ public AsyncFile write(Buffer buffer, long position,  Handler<AsyncResult<Void>>\n   }\n \n   private void doWrite( Iterator<ByteBuffer> buffers, long position, Handler<AsyncResult<Void>> handler) {\n-     ByteBuffer b = buffers.next();\n-     int limit = b.limit();\n+    ByteBuffer b = buffers.next();\n+    int limit = b.limit();\n     doWrite(b, position, limit, ar -> {\n       if (ar.failed()) {\n         handler.handle(ar);",
      "parent_sha": "16ed31870684bced221fc635a2be30614ebf5bbc"
    }
  }
]