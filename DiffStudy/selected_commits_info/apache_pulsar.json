[
  {
    "oid": "5fa141ef013c74ddff75a6042e7b2f89b064782b",
    "message": "Make sure nextTuple emits tuple with non-null values (#1000)\n\n* Make sure nextTuple emits tuple with non-null values\r\n\r\n* remove recursive emit call and reduce receive-timeout",
    "date": "2017-12-22T14:38:31Z",
    "url": "https://github.com/apache/pulsar/commit/5fa141ef013c74ddff75a6042e7b2f89b064782b",
    "details": {
      "sha": "639adb915f0bafd0c1eb0851828862550218929e",
      "filename": "pulsar-storm/src/main/java/org/apache/pulsar/storm/PulsarSpout.java",
      "status": "modified",
      "additions": 24,
      "deletions": 6,
      "changes": 30,
      "blob_url": "https://github.com/apache/pulsar/blob/5fa141ef013c74ddff75a6042e7b2f89b064782b/pulsar-storm%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fstorm%2FPulsarSpout.java",
      "raw_url": "https://github.com/apache/pulsar/raw/5fa141ef013c74ddff75a6042e7b2f89b064782b/pulsar-storm%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fstorm%2FPulsarSpout.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-storm%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fstorm%2FPulsarSpout.java?ref=5fa141ef013c74ddff75a6042e7b2f89b064782b",
      "patch": "@@ -158,6 +158,16 @@ public void fail(Object msgId) {\n      */\n     @Override\n     public void nextTuple() {\n+        emitNextAvailableTuple();\n+    }\n+    \n+    /**\n+     * It makes sure that it emits next available non-tuple to topology unless consumer queue doesn't have any message\n+     * available. It receives message from consumer queue and converts it to tuple and emits to topology. if the\n+     * converted tuple is null then it tries to receives next message and perform the same until it finds non-tuple to\n+     * emit.\n+     */\n+    public void emitNextAvailableTuple() {\n         Message msg;\n \n         // check if there are any failed messages to re-emit in the topology\n@@ -182,12 +192,18 @@ public void nextTuple() {\n                 LOG.debug(\"[{}] Receiving the next message from pulsar consumer to emit to the collector\", spoutId);\n             }\n             try {\n-                msg = consumer.receive(1, TimeUnit.SECONDS);\n-                if (msg != null) {\n-                    ++messagesReceived;\n-                    messageSizeReceived += msg.getData().length;\n+                boolean done = false;\n+                while (!done) {\n+                    msg = consumer.receive(100, TimeUnit.MILLISECONDS);\n+                    if (msg != null) {\n+                        ++messagesReceived;\n+                        messageSizeReceived += msg.getData().length;\n+                        done = mapToValueAndEmit(msg);\n+                    } else {\n+                        // queue is empty and nothing to emit\n+                        done = true;\n+                    }\n                 }\n-                mapToValueAndEmit(msg);\n             } catch (PulsarClientException e) {\n                 LOG.error(\"[{}] Error receiving message from pulsar consumer\", spoutId, e);\n             }\n@@ -228,7 +244,7 @@ public void declareOutputFields(OutputFieldsDeclarer declarer) {\n \n     }\n \n-    private void mapToValueAndEmit(Message msg) {\n+    private boolean mapToValueAndEmit(Message msg) {\n         if (msg != null) {\n             Values values = pulsarSpoutConf.getMessageToValuesMapper().toValues(msg);\n             ++pendingAcks;\n@@ -244,8 +260,10 @@ private void mapToValueAndEmit(Message msg) {\n                 if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"[{}] Emitted message {} to the collector\", spoutId, msg.getMessageId());\n                 }\n+                return true;\n             }\n         }\n+        return false;\n     }\n \n     public class MessageRetries {",
      "parent_sha": "df9d4e553898e9025ca75c857d24412456cfcd65"
    }
  },
  {
    "oid": "1c3a743749924c7c2b7d865565d1fb3c548511c5",
    "message": "[pulsar-io] Fix invalid topic name generation in kafka-source-connector (#9035)\n\n### Motivation\r\n\r\nRight now, kafka-source-connector creates invalid topic name which causes error while creating producer in debezium io-source.\r\n\r\n```\r\n21:22:41,772 DEBUG [my-property/us-west/my-ns/debezium-postgres-source-0] [instance: 0] JavaInstance - Got result: object: (key = \"[B@3bbd472c\", value = \"[B@1aa204ba\")\r\n21:22:41,780 ERROR [my-property/us-west/my-ns/debezium-postgres-source-0] [instance: 0] PulsarSink - Failed to create Producer while doing user publish\r\norg.apache.pulsar.client.api.PulsarClientException$InvalidTopicNameException: Invalid topic name: 'my-property/us-west/my-ns/topic1'\r\n\tat org.apache.pulsar.client.api.PulsarClientException.unwrap(PulsarClientException.java:892) ~[org.apache.pulsar-pulsar-client-api-2.6.2.jar:2.6.2]\r\n\tat org.apache.pulsar.client.impl.ProducerBuilderImpl.create(ProducerBuilderImpl.java:93) ~[org.apache.pulsar-pulsar-client-original-2.6.2.jar:2.6.2]\r\n\tat org.apache.pulsar.functions.sink.PulsarSink$PulsarSinkProcessorBase.createProducer(PulsarSink.java:107) ~[org.apache.pulsar-pulsar-functions-instance-2.6.2.jar:2.6.2]\r\n\tat org.apache.pulsar.functions.sink.PulsarSink$PulsarSinkProcessorBase.lambda$getProducer$0(PulsarSink.java:117) [org.apache.pulsar-pulsar-functions-instance-2.6.2.jar:2.6.2]\r\n\tat java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1705) [?:?]\r\n\tat org.apache.pulsar.functions.sink.PulsarSink$PulsarSinkProcessorBase.getProducer(PulsarSink.java:115) [org.apache.pulsar-pulsar-functions-instance-2.6.2.jar:2.6.2]\r\n\tat org.apache.pulsar.functions.sink.PulsarSink$PulsarSinkProcessorBase.getProducer(PulsarSink.java:111) [org.apache.pulsar-pulsar-functions-instance-2.6.2.jar:2.6.2]\r\n\tat org.apache.pulsar.functions.sink.PulsarSink$PulsarSinkAtMostOnceProcessor.newMessage(PulsarSink.java:184) [org.apache.pulsar-pulsar-functions-instance-2.6.2.jar:2.6.2]\r\n\tat org.apache.pulsar.functions.sink.PulsarSink.write(PulsarSink.java:295) [org.apache.pulsar-pulsar-functions-instance-2.6.2.jar:2.6.2]\r\n\tat org.apache.pulsar.functions.instance.JavaInstanceRunnable.sendOutputMessage(JavaInstanceRunnable.java:449) [org.apache.pulsar-pulsar-functions-instance-2.6.2.jar:2.6.2]\r\n\tat org.apache.pulsar.functions.instance.JavaInstanceRunnable.lambda$processResult$0(JavaInstanceRunnable.java:431) [org.apache.pulsar-pulsar-functions-instance-2.6.2.jar:2.6.2]\r\n\tat java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859) [?:?]\r\n\tat java.util.concurrent.CompletableFuture.uniWhenCompleteStage(CompletableFuture.java:883) [?:?]\r\n\tat java.util.concurrent.CompletableFuture.whenComplete(CompletableFuture.java:2251) [?:?]\r\n\tat org.apache.pulsar.functions.instance.JavaInstanceRunnable.processResult(JavaInstanceRunnable.java:422) [org.apache.pulsar-pulsar-functions-instance-2.6.2.jar:2.6.2]\r\n\tat org.apache.pulsar.functions.instance.JavaInstanceRunnable.run(JavaInstanceRunnable.java:283) [org.apache.pulsar-pulsar-functions-instance-2.6.2.jar:2.6.2]\r\n\tat java.lang.Thread.run(Thread.java:834) [?:?]\r\n21:22:41,781 INFO [my-property/us-west/my-ns/debezium-postgres-source-0] [instance: 0] JavaInstanceRunnable - Encountered exception in sink write: \r\njava.lang.RuntimeException: org.apache.pulsar.client.api.PulsarClientException$InvalidTopicNameException: Invalid topic name: 'my-property/us-west/my-ns/topic1'\r\n\tat org.apache.pulsar.functions.sink.PulsarSink$PulsarSinkProcessorBase.lambda$getProducer$0(PulsarSink.java:124) ~[org.apache.pulsar-pulsar-functions-instance-2.6.2.jar:2.6.2]\r\n\tat java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1705) ~[?:?]\r\n\tat org.apache.pulsar.functions.sink.PulsarSink$PulsarSinkProcessorBase.getProducer(PulsarSink.java:115) ~[org.apache.pulsar-pulsar-functions-instance-2.6.2.jar:2.6.2]\r\n\tat org.apache.pulsar.functions.sink.PulsarSink$PulsarSinkProcessorBase.getProducer(PulsarSink.java:111) ~[org.apache.pulsar-pulsar-functions-instance-2.6.2.jar:2.6.2]\r\n\tat org.apache.pulsar.functions.sink.PulsarSink$PulsarSinkAtMostOnceProcessor.newMessage(PulsarSink.java:184) ~[org.apache.pulsar-pulsar-functions-instance-2.6.2.jar:2.6.2]\r\n\tat org.apache.pulsar.functions.sink.PulsarSink.write(PulsarSink.java:295) ~[org.apache.pulsar-pulsar-functions-instance-2.6.2.jar:2.6.2]\r\n\tat org.apache.pulsar.functions.instance.JavaInstanceRunnable.sendOutputMessage(JavaInstanceRunnable.java:449) [org.apache.pulsar-pulsar-functions-instance-2.6.2.jar:2.6.2]\r\n\tat org.apache.pulsar.functions.instance.JavaInstanceRunnable.lambda$processResult$0(JavaInstanceRunnable.java:431) [org.apache.pulsar-pulsar-functions-instance-2.6.2.jar:2.6.2]\r\n\tat java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:859) [?:?]\r\n\tat java.util.concurrent.CompletableFuture.uniWhenCompleteStage(CompletableFuture.java:883) [?:?]\r\n\tat java.util.concurrent.CompletableFuture.whenComplete(CompletableFuture.java:2251) [?:?]\r\n\tat org.apache.pulsar.functions.instance.JavaInstanceRunnable.processResult(JavaInstanceRunnable.java:422) [org.apache.pulsar-pulsar-functions-instance-2.6.2.jar:2.6.2]\r\n\tat org.apache.pulsar.functions.instance.JavaInstanceRunnable.run(JavaInstanceRunnable.java:283) [org.apache.pulsar-pulsar-functions-instance-2.6.2.jar:2.6.2]\r\n\tat java.lang.Thread.run(Thread.java:834) [?:?]\r\nCaused by: org.apache.pulsar.client.api.PulsarClientException$InvalidTopicNameException: Invalid topic name: 'my-property/us-west/my-ns/topic1'\r\n\tat org.apache.pulsar.client.api.PulsarClientException.unwrap(PulsarClientException.java:892) ~[org.apache.pulsar-pulsar-client-api-2.6.2.jar:2.6.2]\r\n\tat org.apache.pulsar.client.impl.ProducerBuilderImpl.create(ProducerBuilderImpl.java:93) ~[org.apache.pulsar-pulsar-client-original-2.6.2.jar:2.6.2]\r\n\tat org.apache.pulsar.functions.sink.PulsarSink$PulsarSinkProcessorBase.createProducer(PulsarSink.java:107) ~[org.apache.pulsar-pulsar-functions-instance-2.6.2.jar:2.6.2]\r\n\tat org.apache.pulsar.functions.sink.PulsarSink$PulsarSinkProcessorBase.lambda$getProducer$0(PulsarSink.java:117) ~[org.apache.pulsar-pulsar-functions-instance-2.6.2.jar:2.6.2]\r\n\t... 13 more\r\n21:22:41,790 INFO [my-property/us-west/my-ns/debezium-postgres-source-0] [instance: 0] AvroDataConfig - AvroDataConfig values: \r\n\tschemas.cache.config = 1000\r\n\tenhanced.avro.schema.support = false\r\n\tconnect.meta.data = true\r\n```",
    "date": "2021-01-11T03:24:36Z",
    "url": "https://github.com/apache/pulsar/commit/1c3a743749924c7c2b7d865565d1fb3c548511c5",
    "details": {
      "sha": "5a6a1a6161212f676b969a590827b114b2ed3eda",
      "filename": "pulsar-io/kafka-connect-adaptor/src/main/java/org/apache/pulsar/io/kafka/connect/AbstractKafkaConnectSource.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/pulsar/blob/1c3a743749924c7c2b7d865565d1fb3c548511c5/pulsar-io%2Fkafka-connect-adaptor%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fio%2Fkafka%2Fconnect%2FAbstractKafkaConnectSource.java",
      "raw_url": "https://github.com/apache/pulsar/raw/1c3a743749924c7c2b7d865565d1fb3c548511c5/pulsar-io%2Fkafka-connect-adaptor%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fio%2Fkafka%2Fconnect%2FAbstractKafkaConnectSource.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-io%2Fkafka-connect-adaptor%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fio%2Fkafka%2Fconnect%2FAbstractKafkaConnectSource.java?ref=1c3a743749924c7c2b7d865565d1fb3c548511c5",
      "patch": "@@ -189,7 +189,7 @@ public abstract class AbstractKafkaSourceRecord<T> implements Record {\n         KafkaSchemaWrappedSchema valueSchema;\n \n         AbstractKafkaSourceRecord(SourceRecord srcRecord) {\n-            this.destinationTopic = Optional.of(topicNamespace + \"/\" + srcRecord.topic());\n+            this.destinationTopic = Optional.of(\"persistent://\"+topicNamespace + \"/\" + srcRecord.topic());\n         }\n \n         @Override",
      "parent_sha": "6d25a418d3d21947f79c185ff9418992948fb8ed"
    }
  },
  {
    "oid": "707b3a4893db0df6f4ee1d6696a72e14e50e82d4",
    "message": "Avoid warning logs on topic policies not present (#10785)",
    "date": "2021-06-02T18:28:50Z",
    "url": "https://github.com/apache/pulsar/commit/707b3a4893db0df6f4ee1d6696a72e14e50e82d4",
    "details": {
      "sha": "3862757596d59796be85faa5ccc8ff375cd98f19",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/BacklogQuotaManager.java",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/apache/pulsar/blob/707b3a4893db0df6f4ee1d6696a72e14e50e82d4/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FBacklogQuotaManager.java",
      "raw_url": "https://github.com/apache/pulsar/raw/707b3a4893db0df6f4ee1d6696a72e14e50e82d4/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FBacklogQuotaManager.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FBacklogQuotaManager.java?ref=707b3a4893db0df6f4ee1d6696a72e14e50e82d4",
      "patch": "@@ -82,10 +82,12 @@ public BacklogQuota getBacklogQuota(TopicName topicName) {\n         }\n \n         try {\n-            return Optional.ofNullable(pulsar.getTopicPoliciesService().getTopicPolicies(topicName))\n-                    .map(TopicPolicies::getBackLogQuotaMap)\n-                    .map(map -> map.get(BacklogQuotaType.destination_storage.name()))\n-                    .orElseGet(() -> getBacklogQuota(topicName.getNamespace(), policyPath));\n+            if (pulsar.getTopicPoliciesService().cacheIsInitialized(topicName)) {\n+                return Optional.ofNullable(pulsar.getTopicPoliciesService().getTopicPolicies(topicName))\n+                        .map(TopicPolicies::getBackLogQuotaMap)\n+                        .map(map -> map.get(BacklogQuotaType.destination_storage.name()))\n+                        .orElseGet(() -> getBacklogQuota(topicName.getNamespace(), policyPath));\n+            }\n         } catch (Exception e) {\n             log.warn(\"Failed to read topic policies data, will apply the namespace backlog quota: topicName={}\",\n                     topicName, e);",
      "parent_sha": "045841ed4abe50b410e618fa811b1dca6ccdf582"
    }
  },
  {
    "oid": "a5789c2660e1cd451508aedd20404a9fc92be9d5",
    "message": "Fix flaky test RGUsageMTAggrWaitForAllMsgsTest.testMTProduceConsumeRGUsageNonPersistentTopicNamesDifferentTenant (#13826)",
    "date": "2022-01-19T09:21:42Z",
    "url": "https://github.com/apache/pulsar/commit/a5789c2660e1cd451508aedd20404a9fc92be9d5",
    "details": {
      "sha": "87b3d5a02dcaae6aa28e26cf27ed94390f12b954",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/broker/resourcegroup/RGUsageMTAggrWaitForAllMsgsTest.java",
      "status": "modified",
      "additions": 8,
      "deletions": 7,
      "changes": 15,
      "blob_url": "https://github.com/apache/pulsar/blob/a5789c2660e1cd451508aedd20404a9fc92be9d5/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fresourcegroup%2FRGUsageMTAggrWaitForAllMsgsTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/a5789c2660e1cd451508aedd20404a9fc92be9d5/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fresourcegroup%2FRGUsageMTAggrWaitForAllMsgsTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fresourcegroup%2FRGUsageMTAggrWaitForAllMsgsTest.java?ref=a5789c2660e1cd451508aedd20404a9fc92be9d5",
      "patch": "@@ -84,6 +84,7 @@ public long computeLocalQuota(long confUsage, long myUsage, long[] allUsages) {\n         this.rgservice = new ResourceGroupService(pulsar, TimeUnit.SECONDS, transportMgr, dummyQuotaCalc);\n \n         this.prepareRGs();\n+        Thread.sleep(2000);\n     }\n \n     @AfterClass(alwaysRun = true)\n@@ -164,22 +165,22 @@ public void run() {\n                     sentNumBytes += mesg.length;\n                     sentNumMsgs++;\n                     log.debug(\"Producer={}, sent msg-ix={}, msgId={}\", producerId, ix, msgId);\n-                } catch (PulsarClientException p) {\n+                } catch (PulsarClientException e) {\n                     numExceptions++;\n-                    log.info(\"Producer={} got exception while sending {}-th time: ex={}\",\n-                            producerId, ix, p.getMessage());\n+                    log.error(\"Producer={} got exception while sending {}-th time: ex={}\",\n+                            producerId, ix, e.getMessage());\n                 }\n             }\n             try {\n                 producer.flush();\n                 producer.close();\n-            } catch (PulsarClientException p) {\n+            } catch (PulsarClientException e) {\n                 numExceptions++;\n-                log.info(\"Producer={} got exception while closing producer: ex={}\",\n-                        producerId, p.getMessage());\n+                log.error(\"Producer={} got exception while closing producer: ex={}\",\n+                        producerId, e.getMessage());\n             }\n \n-            log.debug(\"Producer={} done with topic={}; got {} exceptions\", producerId, myProduceTopic, numExceptions);\n+            log.info(\"Producer={} done with topic={}; got {} exceptions\", producerId, myProduceTopic, numExceptions);\n         }\n     }\n ",
      "parent_sha": "e602bb1e944fbbccb0410d9bc148162b2be29f5d"
    }
  },
  {
    "oid": "41a7917ca762bd4a2329b9ca3cc84d0d00b24daf",
    "message": "[fix][txn] Fix the incorrect log of Transaction Builder (#19357)\n\n### Motivation\r\n\r\nIf the transaction build fails, the `Success to new txn` still is printed. This is an incorrect log and will make users confused.\r\n\r\n### Modifications\r\n\r\n* Print success log only if the transaction build successfully.\r\n\r\nSigned-off-by: Zike Yang <zike@apache.org>\r\nCo-authored-by: Nicol\u00f2 Boschi <boschi1997@gmail.com>",
    "date": "2023-02-01T01:51:13Z",
    "url": "https://github.com/apache/pulsar/commit/41a7917ca762bd4a2329b9ca3cc84d0d00b24daf",
    "details": {
      "sha": "c5e9d4781c56ffe2bc37052441654ccaf74c057b",
      "filename": "pulsar-client/src/main/java/org/apache/pulsar/client/impl/transaction/TransactionBuilderImpl.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/apache/pulsar/blob/41a7917ca762bd4a2329b9ca3cc84d0d00b24daf/pulsar-client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2Ftransaction%2FTransactionBuilderImpl.java",
      "raw_url": "https://github.com/apache/pulsar/raw/41a7917ca762bd4a2329b9ca3cc84d0d00b24daf/pulsar-client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2Ftransaction%2FTransactionBuilderImpl.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2Ftransaction%2FTransactionBuilderImpl.java?ref=41a7917ca762bd4a2329b9ca3cc84d0d00b24daf",
      "patch": "@@ -65,14 +65,14 @@ public CompletableFuture<Transaction> build() {\n         transactionCoordinatorClient\n                 .newTransactionAsync(txnTimeout, timeUnit)\n                 .whenComplete((txnID, throwable) -> {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Success to new txn. txnID: {}\", txnID);\n-                    }\n                     if (throwable != null) {\n                         log.error(\"New transaction error.\", throwable);\n                         future.completeExceptionally(throwable);\n                         return;\n                     }\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"'newTransaction' command completed successfully for transaction: {}\", txnID);\n+                    }\n                     TransactionImpl transaction = new TransactionImpl(client, timeUnit.toMillis(txnTimeout),\n                             txnID.getLeastSigBits(), txnID.getMostSigBits());\n                     future.complete(transaction);",
      "parent_sha": "c4ec5e0cbc249f96f49a98f246ed9648fb48dcfd"
    }
  },
  {
    "oid": "74247e18ccfd1c443e64f726e75b7e2b5f8cb255",
    "message": "Removes warning of unchecked conversion (#16442)",
    "date": "2022-07-13T01:20:37Z",
    "url": "https://github.com/apache/pulsar/commit/74247e18ccfd1c443e64f726e75b7e2b5f8cb255",
    "details": {
      "sha": "d9b25c333790f66e30e752ba01266f056858b807",
      "filename": "pulsar-client-api/src/main/java/org/apache/pulsar/common/schema/KeyValue.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/pulsar/blob/74247e18ccfd1c443e64f726e75b7e2b5f8cb255/pulsar-client-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fcommon%2Fschema%2FKeyValue.java",
      "raw_url": "https://github.com/apache/pulsar/raw/74247e18ccfd1c443e64f726e75b7e2b5f8cb255/pulsar-client-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fcommon%2Fschema%2FKeyValue.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-client-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fcommon%2Fschema%2FKeyValue.java?ref=74247e18ccfd1c443e64f726e75b7e2b5f8cb255",
      "patch": "@@ -56,7 +56,7 @@ public boolean equals(Object obj) {\n         if (!(obj instanceof KeyValue)) {\n             return false;\n         }\n-        KeyValue<K, V> another = (KeyValue<K, V>) obj;\n+        @SuppressWarnings(\"unchecked\") KeyValue<K, V> another = (KeyValue<K, V>) obj;\n         return Objects.equals(key, another.key)\n             && Objects.equals(value, another.value);\n     }",
      "parent_sha": "fddd11b6d7729f1d3570e653c631597320c4be45"
    }
  },
  {
    "oid": "a758b65224bdca9db897678fa06332fd1e833acb",
    "message": "[pulsar-broker] fix ConcurrentModificationException while load-report serialization (#4452)",
    "date": "2019-06-03T23:11:11Z",
    "url": "https://github.com/apache/pulsar/commit/a758b65224bdca9db897678fa06332fd1e833acb",
    "details": {
      "sha": "f76ccd168593f3858466b0d42934d094d0450567",
      "filename": "pulsar-common/src/main/java/org/apache/pulsar/policies/data/loadbalancer/LocalBrokerData.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/apache/pulsar/blob/a758b65224bdca9db897678fa06332fd1e833acb/pulsar-common%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fpolicies%2Fdata%2Floadbalancer%2FLocalBrokerData.java",
      "raw_url": "https://github.com/apache/pulsar/raw/a758b65224bdca9db897678fa06332fd1e833acb/pulsar-common%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fpolicies%2Fdata%2Floadbalancer%2FLocalBrokerData.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-common%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fpolicies%2Fdata%2Floadbalancer%2FLocalBrokerData.java?ref=a758b65224bdca9db897678fa06332fd1e833acb",
      "patch": "@@ -25,6 +25,7 @@\n import java.util.Set;\n \n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.google.common.collect.Maps;\n \n \n /**\n@@ -94,7 +95,7 @@ public LocalBrokerData(final String webServiceUrl, final String webServiceUrlTls\n         this.webServiceUrlTls = webServiceUrlTls;\n         this.pulsarServiceUrl = pulsarServiceUrl;\n         this.pulsarServiceUrlTls = pulsarServiceUrlTls;\n-        lastStats = new HashMap<>();\n+        lastStats = Maps.newConcurrentMap();\n         lastUpdate = System.currentTimeMillis();\n         cpu = new ResourceUsage();\n         memory = new ResourceUsage();",
      "parent_sha": "870a2814b514187a81743d80061a129ba4018cf3"
    }
  },
  {
    "oid": "e1f7505cbc2cadcba7cb79d8e3ed5b7855688858",
    "message": "Fix broker to specify a list of bookie groups. (#6349)\n\n### Motivation\r\n\r\nFixes #6343\r\n\r\n### Modifications\r\n\r\nAdd a method to cast object value to `String`.",
    "date": "2020-02-24T13:46:31Z",
    "url": "https://github.com/apache/pulsar/commit/e1f7505cbc2cadcba7cb79d8e3ed5b7855688858",
    "details": {
      "sha": "ef4f72bb14901be77ecb40cfc8591c1f5e969ff7",
      "filename": "pulsar-zookeeper-utils/src/main/java/org/apache/pulsar/zookeeper/ZkIsolatedBookieEnsemblePlacementPolicy.java",
      "status": "modified",
      "additions": 14,
      "deletions": 2,
      "changes": 16,
      "blob_url": "https://github.com/apache/pulsar/blob/e1f7505cbc2cadcba7cb79d8e3ed5b7855688858/pulsar-zookeeper-utils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fzookeeper%2FZkIsolatedBookieEnsemblePlacementPolicy.java",
      "raw_url": "https://github.com/apache/pulsar/raw/e1f7505cbc2cadcba7cb79d8e3ed5b7855688858/pulsar-zookeeper-utils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fzookeeper%2FZkIsolatedBookieEnsemblePlacementPolicy.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-zookeeper-utils%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fzookeeper%2FZkIsolatedBookieEnsemblePlacementPolicy.java?ref=e1f7505cbc2cadcba7cb79d8e3ed5b7855688858",
      "patch": "@@ -71,7 +71,7 @@ public RackawareEnsemblePlacementPolicyImpl initialize(ClientConfiguration conf,\n             Optional<DNSToSwitchMapping> optionalDnsResolver, HashedWheelTimer timer, FeatureProvider featureProvider,\n             StatsLogger statsLogger) {\n         if (conf.getProperty(ISOLATION_BOOKIE_GROUPS) != null) {\n-            String isolationGroupsString = (String) conf.getProperty(ISOLATION_BOOKIE_GROUPS);\n+            String isolationGroupsString = castToString(conf.getProperty(ISOLATION_BOOKIE_GROUPS));\n             if (!isolationGroupsString.isEmpty()) {\n                 for (String isolationGroup : isolationGroupsString.split(\",\")) {\n                     primaryIsolationGroups.add(isolationGroup);\n@@ -80,7 +80,7 @@ public RackawareEnsemblePlacementPolicyImpl initialize(ClientConfiguration conf,\n             }\n         }\n         if (conf.getProperty(SECONDARY_ISOLATION_BOOKIE_GROUPS) != null) {\n-            String secondaryIsolationGroupsString = (String) conf.getProperty(SECONDARY_ISOLATION_BOOKIE_GROUPS);\n+            String secondaryIsolationGroupsString = castToString(conf.getProperty(SECONDARY_ISOLATION_BOOKIE_GROUPS));\n             if (!secondaryIsolationGroupsString.isEmpty()) {\n                 for (String isolationGroup : secondaryIsolationGroupsString.split(\",\")) {\n                     secondaryIsolationGroups.add(isolationGroup);\n@@ -90,6 +90,18 @@ public RackawareEnsemblePlacementPolicyImpl initialize(ClientConfiguration conf,\n         return super.initialize(conf, optionalDnsResolver, timer, featureProvider, statsLogger);\n     }\n \n+    private String castToString(Object obj) {\n+        if (obj instanceof List<?>) {\n+            List<String> result = new ArrayList<>();\n+            for (Object o : (List<?>) obj) {\n+                result.add(String.class.cast(o));\n+            }\n+            return String.join(\",\", result);\n+        } else {\n+            return obj.toString();\n+        }\n+    }\n+\n     private ZooKeeperCache getAndSetZkCache(Configuration conf) {\n         ZooKeeperCache zkCache = null;\n         if (conf.getProperty(ZooKeeperCache.ZK_CACHE_INSTANCE) != null) {",
      "parent_sha": "63ccd43e1a3294d696a4af37c76261eed1bb3124"
    }
  },
  {
    "oid": "600b55d2aff1aed6427348fe50cb1d4a3bc5a809",
    "message": "Check if javaInstance is created in the first place before invocing close (#1688)",
    "date": "2018-05-01T01:57:16Z",
    "url": "https://github.com/apache/pulsar/commit/600b55d2aff1aed6427348fe50cb1d4a3bc5a809",
    "details": {
      "sha": "a4fe026a2969ab0a20e3059250413bdbb485e7ae",
      "filename": "pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaInstanceRunnable.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/apache/pulsar/blob/600b55d2aff1aed6427348fe50cb1d4a3bc5a809/pulsar-functions%2Finstance%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Finstance%2FJavaInstanceRunnable.java",
      "raw_url": "https://github.com/apache/pulsar/raw/600b55d2aff1aed6427348fe50cb1d4a3bc5a809/pulsar-functions%2Finstance%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Finstance%2FJavaInstanceRunnable.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-functions%2Finstance%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Finstance%2FJavaInstanceRunnable.java?ref=600b55d2aff1aed6427348fe50cb1d4a3bc5a809",
      "patch": "@@ -348,7 +348,9 @@ private void sendOutputMessage(Record srcRecord,\n     @Override\n     public void close() {\n         processor.close();\n-        javaInstance.close();\n+        if (null != javaInstance) {\n+            javaInstance.close();\n+        }\n \n         // kill the state table\n         if (null != stateTable) {",
      "parent_sha": "fb7198a669e0647cf3213739b7b6ffb8c650d978"
    }
  },
  {
    "oid": "b85730069ee4c5f96406a075e354d0592fdab434",
    "message": "[improve][broker] backlog quota exceed limit log replaced with `debug` (#22488)",
    "date": "2024-04-12T16:37:28Z",
    "url": "https://github.com/apache/pulsar/commit/b85730069ee4c5f96406a075e354d0592fdab434",
    "details": {
      "sha": "3c9ab04d79a0d853d20956392a34f2b2ca38176b",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/persistent/PersistentTopic.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/apache/pulsar/blob/b85730069ee4c5f96406a075e354d0592fdab434/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2Fpersistent%2FPersistentTopic.java",
      "raw_url": "https://github.com/apache/pulsar/raw/b85730069ee4c5f96406a075e354d0592fdab434/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2Fpersistent%2FPersistentTopic.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2Fpersistent%2FPersistentTopic.java?ref=b85730069ee4c5f96406a075e354d0592fdab434",
      "patch": "@@ -3224,14 +3224,14 @@ public CompletableFuture<Void> checkBacklogQuotaExceeded(String producerName, Ba\n             if ((retentionPolicy == BacklogQuota.RetentionPolicy.producer_request_hold\n                     || retentionPolicy == BacklogQuota.RetentionPolicy.producer_exception)) {\n                 if (backlogQuotaType == BacklogQuotaType.destination_storage && isSizeBacklogExceeded()) {\n-                    log.info(\"[{}] Size backlog quota exceeded. Cannot create producer [{}]\", this.getName(),\n+                    log.debug(\"[{}] Size backlog quota exceeded. Cannot create producer [{}]\", this.getName(),\n                             producerName);\n                     return FutureUtil.failedFuture(new TopicBacklogQuotaExceededException(retentionPolicy));\n                 }\n                 if (backlogQuotaType == BacklogQuotaType.message_age) {\n                     return checkTimeBacklogExceeded().thenCompose(isExceeded -> {\n                         if (isExceeded) {\n-                            log.info(\"[{}] Time backlog quota exceeded. Cannot create producer [{}]\", this.getName(),\n+                            log.debug(\"[{}] Time backlog quota exceeded. Cannot create producer [{}]\", this.getName(),\n                                     producerName);\n                             return FutureUtil.failedFuture(new TopicBacklogQuotaExceededException(retentionPolicy));\n                         } else {",
      "parent_sha": "dbe1a4816c12535da2013ed5da5ee7796d8b4638"
    }
  },
  {
    "oid": "4ad8b5b0bca4e18f0f92589545c3c81253656598",
    "message": "Fix clear transaction buffer snapshot flaky test (#14922)\n\n### Motivation\r\n```\r\njava.lang.AssertionError: \r\nExpected :true\r\nActual   :false\r\n<Click to see difference>\r\n\tat org.testng.Assert.fail(Assert.java:99)\r\n\tat org.testng.Assert.failNotEquals(Assert.java:1037)\r\n\tat org.testng.Assert.assertTrue(Assert.java:45)\r\n\tat org.testng.Assert.assertTrue(Assert.java:55)\r\n\tat org.apache.pulsar.broker.transaction.TopicTransactionBufferRecoverTest.checkSnapshotCount(TopicTransactionBufferRecoverTest.java:452)\r\n\tat org.apache.pulsar.broker.transaction.TopicTransactionBufferRecoverTest.clearTransactionBufferSnapshotTest(TopicTransactionBufferRecoverTest.java:427)\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:566)\r\n\tat org.testng.internal.MethodInvocationHelper.invokeMethod(MethodInvocationHelper.java:132)\r\n// ...\r\n```\r\n\r\nCurrently, the clear transaction buffer snapshot is flaky, because we used `@Cleanup` annotation, the `@Cleanup` annotation will put the close producer method to the bottom of the test method, then the producer will close after deleting the topic. \r\n\r\nWhen we delete the topic, all relevant producers will receive a `CLOSE_PRODUCER` command, then the producer client will try to reconnect to the broker, so it will send the `PRODUCER` command again, then the transaction buffer snapshot will take a new snapshot, so the test will fail.\r\n\r\n### Modifications\r\n\r\nMake the producer close before the topic deleting.",
    "date": "2022-04-14T03:11:11Z",
    "url": "https://github.com/apache/pulsar/commit/4ad8b5b0bca4e18f0f92589545c3c81253656598",
    "details": {
      "sha": "78259c23b8a58f09c01b9aec760adaae6b6db9e3",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/broker/transaction/TopicTransactionBufferRecoverTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/pulsar/blob/4ad8b5b0bca4e18f0f92589545c3c81253656598/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Ftransaction%2FTopicTransactionBufferRecoverTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/4ad8b5b0bca4e18f0f92589545c3c81253656598/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Ftransaction%2FTopicTransactionBufferRecoverTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Ftransaction%2FTopicTransactionBufferRecoverTest.java?ref=4ad8b5b0bca4e18f0f92589545c3c81253656598",
      "patch": "@@ -391,7 +391,6 @@ private void testTopicTransactionBufferDeleteAbort() throws Exception {\n     public void clearTransactionBufferSnapshotTest() throws Exception {\n         String topic = NAMESPACE1 + \"/tb-snapshot-delete-\" + RandomUtils.nextInt();\n \n-        @Cleanup\n         Producer<byte[]> producer = pulsarClient\n                 .newProducer()\n                 .topic(topic)\n@@ -404,6 +403,7 @@ public void clearTransactionBufferSnapshotTest() throws Exception {\n         producer.newMessage(txn).value(\"test\".getBytes()).sendAsync();\n         producer.newMessage(txn).value(\"test\".getBytes()).sendAsync();\n         txn.commit().get();\n+        producer.close();\n \n         // take snapshot\n         PersistentTopic originalTopic = (PersistentTopic) getPulsarServiceList().get(0)",
      "parent_sha": "14e5a92be04de6e45cbabbfd977a07ef4159e5b8"
    }
  },
  {
    "oid": "58120841ec74373b5ea718dd0325d4542dde4330",
    "message": "[fix] fix for code scanning alert no. 48: Uncontrolled data used in path expression (#23985)\n\nCo-authored-by: Copilot Autofix powered by AI <62310815+github-advanced-security[bot]@users.noreply.github.com>",
    "date": "2025-02-14T16:54:59Z",
    "url": "https://github.com/apache/pulsar/commit/58120841ec74373b5ea718dd0325d4542dde4330",
    "details": {
      "sha": "8bf7851fc8d6300662811e6a869a9d06d3b13024",
      "filename": "pulsar-package-management/filesystem-storage/src/main/java/org/apache/pulsar/packages/management/storage/filesystem/FileSystemPackagesStorage.java",
      "status": "modified",
      "additions": 5,
      "deletions": 2,
      "changes": 7,
      "blob_url": "https://github.com/apache/pulsar/blob/58120841ec74373b5ea718dd0325d4542dde4330/pulsar-package-management%2Ffilesystem-storage%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fpackages%2Fmanagement%2Fstorage%2Ffilesystem%2FFileSystemPackagesStorage.java",
      "raw_url": "https://github.com/apache/pulsar/raw/58120841ec74373b5ea718dd0325d4542dde4330/pulsar-package-management%2Ffilesystem-storage%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fpackages%2Fmanagement%2Fstorage%2Ffilesystem%2FFileSystemPackagesStorage.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-package-management%2Ffilesystem-storage%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fpackages%2Fmanagement%2Fstorage%2Ffilesystem%2FFileSystemPackagesStorage.java?ref=58120841ec74373b5ea718dd0325d4542dde4330",
      "patch": "@@ -59,11 +59,14 @@ public class FileSystemPackagesStorage implements PackagesStorage {\n     }\n \n     private File getPath(String path) throws IOException {\n-        if (path.contains(\"..\")) {\n+        // Normalize the path to remove any redundant path elements\n+        File f = Paths.get(storagePath.toString(), path).normalize().toFile();\n+\n+        // Ensure the normalized path is still within the storagePath\n+        if (!f.getAbsolutePath().startsWith(storagePath.getAbsolutePath())) {\n             throw new IOException(\"Invalid path: \" + path);\n         }\n \n-        File f = Paths.get(storagePath.toString(), path).toFile();\n         if (!f.getParentFile().exists()) {\n             if (!f.getParentFile().mkdirs()) {\n                 throw new RuntimeException(\"Failed to create parent dirs for \" + path);",
      "parent_sha": "eb7a4f36da3711b9b93527d0bfe26acad1d64b1d"
    }
  },
  {
    "oid": "3e965b2d4b3812068d92e8073ca1fff39cd2437d",
    "message": "Make spark consumer-listener lambda Serializable (#866)",
    "date": "2017-10-27T16:58:24Z",
    "url": "https://github.com/apache/pulsar/commit/3e965b2d4b3812068d92e8073ca1fff39cd2437d",
    "details": {
      "sha": "c761b2d4f19be9408d88a7d8a51c00b07c90ad67",
      "filename": "pulsar-spark/src/main/java/org/apache/pulsar/spark/SparkStreamingPulsarReceiver.java",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/apache/pulsar/blob/3e965b2d4b3812068d92e8073ca1fff39cd2437d/pulsar-spark%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fspark%2FSparkStreamingPulsarReceiver.java",
      "raw_url": "https://github.com/apache/pulsar/raw/3e965b2d4b3812068d92e8073ca1fff39cd2437d/pulsar-spark%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fspark%2FSparkStreamingPulsarReceiver.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-spark%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fspark%2FSparkStreamingPulsarReceiver.java?ref=3e965b2d4b3812068d92e8073ca1fff39cd2437d",
      "patch": "@@ -18,17 +18,21 @@\n  */\n package org.apache.pulsar.spark;\n \n+import java.io.Serializable;\n import java.util.concurrent.TimeUnit;\n \n import org.apache.pulsar.client.api.ClientConfiguration;\n import org.apache.pulsar.client.api.ConsumerConfiguration;\n+import org.apache.pulsar.client.api.MessageListener;\n import org.apache.pulsar.client.api.PulsarClient;\n import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.spark.storage.StorageLevel;\n import org.apache.spark.streaming.receiver.Receiver;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n public class SparkStreamingPulsarReceiver extends Receiver<byte[]> {\n \n     private ClientConfiguration clientConfiguration;\n@@ -46,14 +50,16 @@ public SparkStreamingPulsarReceiver(ClientConfiguration clientConfiguration,\n     public SparkStreamingPulsarReceiver(StorageLevel storageLevel, ClientConfiguration clientConfiguration,\n             ConsumerConfiguration consumerConfiguration, String url, String topic, String subscription) {\n         super(storageLevel);\n+        checkNotNull(clientConfiguration, \"ClientConfiguration must not be null\");\n+        checkNotNull(consumerConfiguration, \"ConsumerConfiguration must not be null\");\n         this.clientConfiguration = clientConfiguration;\n         this.url = url;\n         this.topic = topic;\n         this.subscription = subscription;\n         if (consumerConfiguration.getAckTimeoutMillis() == 0) {\n             consumerConfiguration.setAckTimeout(60, TimeUnit.SECONDS);\n         }\n-        consumerConfiguration.setMessageListener((consumer, msg) -> {\n+        consumerConfiguration.setMessageListener((MessageListener & Serializable) (consumer, msg) -> {\n             try {\n                 store(msg.getData());\n                 consumer.acknowledgeAsync(msg);",
      "parent_sha": "6bd024da113587c1b92d56ed735d49d97d3bfb78"
    }
  },
  {
    "oid": "aabd5d020543210921f10648caf6720adc41d651",
    "message": "[fix][flaky-test] Fix failed test NonPersistentTopicE2ETest.testGCWillDeleteSchema (#16381)",
    "date": "2022-07-05T02:38:53Z",
    "url": "https://github.com/apache/pulsar/commit/aabd5d020543210921f10648caf6720adc41d651",
    "details": {
      "sha": "fb1dbfea3f1d786e27ce08db5f58f40b40d76f84",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/NonPersistentTopicE2ETest.java",
      "status": "modified",
      "additions": 26,
      "deletions": 25,
      "changes": 51,
      "blob_url": "https://github.com/apache/pulsar/blob/aabd5d020543210921f10648caf6720adc41d651/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FNonPersistentTopicE2ETest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/aabd5d020543210921f10648caf6720adc41d651/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FNonPersistentTopicE2ETest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FNonPersistentTopicE2ETest.java?ref=aabd5d020543210921f10648caf6720adc41d651",
      "patch": "@@ -83,7 +83,7 @@ private boolean topicHasSchema(String topicName) {\n     @Test(groups = \"broker\")\n     public void testGCWillDeleteSchema() throws Exception {\n         // 1. Simple successful GC\n-        String topicName = \"non-persistent://prop/ns-abc/topic-1\";\n+        final String topicName = \"non-persistent://prop/ns-abc/topic-1\";\n         Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName).create();\n         producer.close();\n \n@@ -100,56 +100,57 @@ public void testGCWillDeleteSchema() throws Exception {\n         assertTrue(topicHasSchema(topicName));\n         runGC();\n \n-        topic = getTopic(topicName);\n-        assertFalse(topic.isPresent());\n+        Awaitility.await().untilAsserted(() -> {\n+            assertFalse(getTopic(topicName).isPresent());\n+        });\n         assertFalse(topicHasSchema(topicName));\n \n         // 1a. Topic that add/removes subscription can be GC'd\n-        topicName = \"non-persistent://prop/ns-abc/topic-1a\";\n+        final String topicName2 = \"non-persistent://prop/ns-abc/topic-1a\";\n         String subName = \"sub1\";\n-        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(topicName).subscriptionName(subName).subscribe();\n-        topic = getTopic(topicName);\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(topicName2).subscriptionName(subName).subscribe();\n+        topic = getTopic(topicName2);\n         assertTrue(topic.isPresent());\n         topic.get().addSchema(schemaData).join();\n-        assertTrue(topicHasSchema(topicName));\n+        assertTrue(topicHasSchema(topicName2));\n \n-        admin.topics().deleteSubscription(topicName, subName);\n+        admin.topics().deleteSubscription(topicName2, subName);\n         consumer.close();\n \n         runGC();\n-        topic = getTopic(topicName);\n-        assertFalse(topic.isPresent());\n-        assertFalse(topicHasSchema(topicName));\n+        Awaitility.await().untilAsserted(() -> {\n+            assertFalse(getTopic(topicName2).isPresent());\n+        });\n+        assertFalse(topicHasSchema(topicName2));\n \n         // 2. Topic is not GCed with live connection\n-        topicName = \"non-persistent://prop/ns-abc/topic-2\";\n+        final String topicName3 = \"non-persistent://prop/ns-abc/topic-2\";\n         subName = \"sub1\";\n-        consumer = pulsarClient.newConsumer().topic(topicName).subscriptionName(subName).subscribe();\n-        topic = getTopic(topicName);\n+        consumer = pulsarClient.newConsumer().topic(topicName3).subscriptionName(subName).subscribe();\n+        topic = getTopic(topicName3);\n         assertTrue(topic.isPresent());\n         topic.get().addSchema(schemaData).join();\n-        assertTrue(topicHasSchema(topicName));\n+        assertTrue(topicHasSchema(topicName3));\n \n         runGC();\n-        topic = getTopic(topicName);\n-        assertTrue(topic.isPresent());\n-        assertTrue(topicHasSchema(topicName));\n+        assertTrue(getTopic(topicName3).isPresent());\n+        assertTrue(topicHasSchema(topicName3));\n \n         // 3. Topic with subscription is not GCed even with no connections\n         consumer.close();\n \n         runGC();\n-        topic = getTopic(topicName);\n-        assertTrue(topic.isPresent());\n-        assertTrue(topicHasSchema(topicName));\n+        assertTrue(getTopic(topicName3).isPresent());\n+        assertTrue(topicHasSchema(topicName3));\n \n         // 4. Topic can be GCed after unsubscribe\n-        admin.topics().deleteSubscription(topicName, subName);\n+        admin.topics().deleteSubscription(topicName3, subName);\n \n         runGC();\n-        topic = getTopic(topicName);\n-        assertFalse(topic.isPresent());\n-        assertFalse(topicHasSchema(topicName));\n+        Awaitility.await().untilAsserted(() -> {\n+            assertFalse(getTopic(topicName3).isPresent());\n+        });\n+        assertFalse(topicHasSchema(topicName3));\n     }\n \n     @Test(groups = \"broker\")",
      "parent_sha": "95abf3afd0cb3fdb368f9f9fae6dcff0b95983ce"
    }
  },
  {
    "oid": "1225a24c079b2c6c781cb47d55139b3bae2dafad",
    "message": "[fix][broker] Fix unable to start multiple bookies for BKCluster (#18072)",
    "date": "2022-10-20T02:24:41Z",
    "url": "https://github.com/apache/pulsar/commit/1225a24c079b2c6c781cb47d55139b3bae2dafad",
    "details": {
      "sha": "d845f912d2e186fa28479f78a972f703388c2c74",
      "filename": "pulsar-metadata/src/main/java/org/apache/pulsar/metadata/bookkeeper/BKCluster.java",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/apache/pulsar/blob/1225a24c079b2c6c781cb47d55139b3bae2dafad/pulsar-metadata%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fmetadata%2Fbookkeeper%2FBKCluster.java",
      "raw_url": "https://github.com/apache/pulsar/raw/1225a24c079b2c6c781cb47d55139b3bae2dafad/pulsar-metadata%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fmetadata%2Fbookkeeper%2FBKCluster.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-metadata%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fmetadata%2Fbookkeeper%2FBKCluster.java?ref=1225a24c079b2c6c781cb47d55139b3bae2dafad",
      "patch": "@@ -201,13 +201,17 @@ protected void cleanupTempDirs() throws Exception {\n     private ServerConfiguration newServerConfiguration(int index) throws Exception {\n         File dataDir;\n         if (clusterConf.dataDir != null) {\n-            dataDir = new File(clusterConf.dataDir);\n+            if (index == 0) {\n+                dataDir = new File(clusterConf.dataDir);\n+            } else {\n+                dataDir = new File(clusterConf.dataDir + \"/\" + index);\n+            }\n         } else {\n             // Use temp dir and clean it up later\n             dataDir = createTempDir(\"bookie\",  \"test-\" + index);\n         }\n \n-        if (clusterConf.clearOldData) {\n+        if (clusterConf.clearOldData && dataDir.exists()) {\n             cleanDirectory(dataDir);\n         }\n ",
      "parent_sha": "3eac2219814208715042dd0766d8eae60faa8835"
    }
  },
  {
    "oid": "2c2ac1af68d1e662f9c8cea62868c215bd272eea",
    "message": "[improve][test] Improve NamespacesTest to reduce the execution time (#17875)",
    "date": "2022-11-02T01:43:01Z",
    "url": "https://github.com/apache/pulsar/commit/2c2ac1af68d1e662f9c8cea62868c215bd272eea",
    "details": {
      "sha": "307c8447674f65f04644ccd0f8c1439e7c0cf70c",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/NamespacesTest.java",
      "status": "modified",
      "additions": 101,
      "deletions": 17,
      "changes": 118,
      "blob_url": "https://github.com/apache/pulsar/blob/2c2ac1af68d1e662f9c8cea62868c215bd272eea/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2FNamespacesTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/2c2ac1af68d1e662f9c8cea62868c215bd272eea/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2FNamespacesTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2FNamespacesTest.java?ref=2c2ac1af68d1e662f9c8cea62868c215bd272eea",
      "patch": "@@ -39,16 +39,21 @@\n import java.time.Duration;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n import java.util.EnumSet;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n import java.util.UUID;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import javax.ws.rs.BadRequestException;\n import javax.ws.rs.ClientErrorException;\n import javax.ws.rs.WebApplicationException;\n@@ -61,6 +66,7 @@\n import org.apache.bookkeeper.mledger.LedgerOffloader;\n import org.apache.bookkeeper.mledger.ManagedLedgerConfig;\n import org.apache.bookkeeper.util.ZkUtils;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.pulsar.broker.BrokerTestUtil;\n import org.apache.pulsar.broker.admin.v1.Namespaces;\n import org.apache.pulsar.broker.admin.v1.PersistentTopics;\n@@ -76,6 +82,7 @@\n import org.apache.pulsar.client.admin.PulsarAdminException;\n import org.apache.pulsar.client.admin.PulsarAdminException.NotFoundException;\n import org.apache.pulsar.client.admin.internal.BaseResource;\n+import org.apache.pulsar.client.api.ClientBuilder;\n import org.apache.pulsar.client.api.Consumer;\n import org.apache.pulsar.client.api.ConsumerBuilder;\n import org.apache.pulsar.client.api.Producer;\n@@ -112,9 +119,9 @@\n import org.mockito.Mockito;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import org.testng.annotations.AfterClass;\n import org.testng.annotations.AfterMethod;\n import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.BeforeMethod;\n import org.testng.annotations.Test;\n \n @Test(groups = \"broker-admin\")\n@@ -139,8 +146,9 @@ public NamespacesTest() {\n         super();\n     }\n \n+    @Override\n     @BeforeClass\n-    public void initNamespace() throws Exception {\n+    public void setup() throws Exception {\n         testLocalNamespaces = new ArrayList<>();\n         testGlobalNamespaces = new ArrayList<>();\n \n@@ -154,11 +162,37 @@ public void initNamespace() throws Exception {\n         uriField = PulsarWebResource.class.getDeclaredField(\"uri\");\n         uriField.setAccessible(true);\n         uriInfo = mock(UriInfo.class);\n+\n+        initAndStartBroker();\n     }\n \n     @Override\n-    @BeforeMethod\n-    public void setup() throws Exception {\n+    @AfterClass(alwaysRun = true)\n+    public void cleanup() throws Exception {\n+        super.internalCleanup();\n+        conf.setClusterName(testLocalCluster);\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void cleanupAfterMethod() throws Exception{\n+        // cleanup.\n+        Set<String> existsNsSetAferSetup = Stream.concat(testLocalNamespaces.stream(), testGlobalNamespaces.stream())\n+                .map(Objects::toString).collect(Collectors.toSet());\n+        cleanupNamespaceByPredicate(this.testTenant, v -> !existsNsSetAferSetup.contains(v));\n+        cleanupNamespaceByPredicate(this.testOtherTenant, v -> !existsNsSetAferSetup.contains(v));\n+    }\n+\n+    protected void customizeNewPulsarClientBuilder(ClientBuilder clientBuilder) {\n+        // Make method \"testMaxTopicsPerNamespace\" run faster.\n+        clientBuilder.operationTimeout(1, TimeUnit.SECONDS);\n+    }\n+\n+    private void resetBroker() throws Exception {\n+        cleanup();\n+        initAndStartBroker();\n+    }\n+\n+    private void initAndStartBroker() throws Exception {\n         conf.setTopicLevelPoliciesEnabled(false);\n         conf.setSystemTopicEnabled(false);\n         conf.setClusterName(testLocalCluster);\n@@ -207,13 +241,6 @@ public void setup() throws Exception {\n         nsSvc = pulsar.getNamespaceService();\n     }\n \n-    @Override\n-    @AfterMethod(alwaysRun = true)\n-    public void cleanup() throws Exception {\n-        super.internalCleanup();\n-        conf.setClusterName(testLocalCluster);\n-    }\n-\n     @Test\n     public void testCreateNamespaces() throws Exception {\n         try {\n@@ -646,6 +673,8 @@ public void testGlobalNamespaceReplicationConfiguration() throws Exception {\n             assertEquals(e.getResponse().getStatus(), Status.PRECONDITION_FAILED.getStatusCode());\n         }\n \n+        // cleanup\n+        resetBroker();\n     }\n \n     @Test\n@@ -723,6 +752,9 @@ public boolean matches(NamespaceName nsname) {\n         assertEquals(captor.getValue().getResponse().getStatus(), Status.TEMPORARY_REDIRECT.getStatusCode());\n         assertEquals(captor.getValue().getResponse().getLocation().toString(),\n                 UriBuilder.fromUri(uri).host(\"broker-usc.com\").port(8080).toString());\n+\n+        // cleanup\n+        resetBroker();\n     }\n \n     @Test\n@@ -802,6 +834,9 @@ public void testDeleteNamespaces() throws Exception {\n         responseCaptor = ArgumentCaptor.forClass(Response.class);\n         verify(response, timeout(5000).times(1)).resume(responseCaptor.capture());\n         assertEquals(responseCaptor.getValue().getStatus(), Status.NO_CONTENT.getStatusCode());\n+\n+        // cleanup\n+        resetBroker();\n     }\n \n     @Test\n@@ -882,6 +917,9 @@ public boolean matches(NamespaceBundle bundle) {\n         ArgumentCaptor<Response> captor2 = ArgumentCaptor.forClass(Response.class);\n         verify(response, timeout(5000).times(1)).resume(captor2.capture());\n         assertEquals(captor2.getValue().getStatus(), Status.NO_CONTENT.getStatusCode());\n+\n+        // cleanup\n+        resetBroker();\n     }\n \n     @Test\n@@ -901,6 +939,9 @@ public void testUnloadNamespaces() throws Exception {\n         ArgumentCaptor<Response> captor = ArgumentCaptor.forClass(Response.class);\n         verify(response, timeout(5000).times(1)).resume(captor.capture());\n         assertEquals(captor.getValue().getStatus(), Status.NO_CONTENT.getStatusCode());\n+\n+        // cleanup\n+        resetBroker();\n     }\n \n     @Test\n@@ -940,6 +981,9 @@ public void testSplitBundles() throws Exception {\n         } catch (RestException re) {\n             assertEquals(re.getResponse().getStatus(), Status.PRECONDITION_FAILED.getStatusCode());\n         }\n+\n+        // cleanup\n+        resetBroker();\n     }\n \n     @Test\n@@ -967,6 +1011,9 @@ public void testSplitBundleWithUnDividedRange() throws Exception {\n                 \"0x08375b1a_0x08375b1b\", false, false, null);\n         ArgumentCaptor<Response> captor = ArgumentCaptor.forClass(Response.class);\n         verify(response, timeout(5000).times(1)).resume(any(RestException.class));\n+\n+        // cleanup\n+        resetBroker();\n     }\n \n     @Test\n@@ -998,6 +1045,9 @@ public void testUnloadNamespaceWithBundles() throws Exception {\n         namespaces.unloadNamespaceBundle(response, testTenant, testLocalCluster, bundledNsLocal, \"0x00000000_0x80000000\",\n                 false);\n         verify(response, timeout(5000).times(1)).resume(any(RestException.class));\n+\n+        // cleanup\n+        resetBroker();\n     }\n \n     private void createBundledTestNamespaces(String property, String cluster, String namespace, BundlesData bundle)\n@@ -1061,6 +1111,9 @@ public void testRetention() throws Exception {\n         } catch (RestException e) {\n             fail(\"ValidateNamespaceOwnershipWithBundles failed\");\n         }\n+\n+        // cleanup\n+        resetBroker();\n     }\n \n     @Test\n@@ -1133,6 +1186,9 @@ public void testValidateTopicOwnership() throws Exception {\n         topics.validateTopicName(topicName.getTenant(), topicName.getCluster(),\n                 topicName.getNamespacePortion(), topicName.getEncodedLocalName());\n         topics.validateAdminOperationOnTopic(false);\n+\n+        // cleanup\n+        resetBroker();\n     }\n \n     @Test\n@@ -1566,7 +1622,7 @@ public void testRetentionPolicyValidation() throws Exception {\n     public void testMaxTopicsPerNamespace() throws Exception {\n         cleanup();\n         conf.setMaxTopicsPerNamespace(15);\n-        setup();\n+        initAndStartBroker();\n \n         String namespace = BrokerTestUtil.newUniqueName(\"testTenant/ns1\");\n         TenantInfoImpl tenantInfo = new TenantInfoImpl(Set.of(\"role1\", \"role2\"),\n@@ -1618,7 +1674,7 @@ public void testMaxTopicsPerNamespace() throws Exception {\n         conf.setMaxTopicsPerNamespace(0);\n         conf.setDefaultNumPartitions(3);\n         conf.setAllowAutoTopicCreationType(\"partitioned\");\n-        setup();\n+        initAndStartBroker();\n \n         admin.tenants().createTenant(\"testTenant\", tenantInfo);\n         admin.namespaces().createNamespace(namespace, Set.of(\"use\"));\n@@ -1647,7 +1703,7 @@ public void testMaxTopicsPerNamespace() throws Exception {\n         conf.setMaxTopicsPerNamespace(0);\n         conf.setDefaultNumPartitions(1);\n         conf.setAllowAutoTopicCreationType(\"non-partitioned\");\n-        setup();\n+        initAndStartBroker();\n \n         admin.tenants().createTenant(\"testTenant\", tenantInfo);\n         admin.namespaces().createNamespace(namespace, Set.of(\"use\"));\n@@ -1682,9 +1738,8 @@ public void testMaxTopicsPerNamespace() throws Exception {\n             pulsarClient.newConsumer().topic(topic + \"_c\" + i).subscriptionName(\"test_sub\").subscribe().close();\n         }\n \n-        conf.setMaxTopicsPerNamespace(0);\n-        conf.setDefaultNumPartitions(1);\n-        conf.setAllowAutoTopicCreationType(\"non-partitioned\");\n+        // cleanup\n+        resetBroker();\n     }\n \n     private void assertInvalidRetentionPolicy(String namespace, int retentionTimeInMinutes, int retentionSizeInMB) {\n@@ -1876,6 +1931,9 @@ public void testSplitBundleForMultiTimes() throws Exception{\n         }\n         BundlesData bundles = admin.namespaces().getBundles(namespace);\n         assertEquals(bundles.getNumBundles(), 14);\n+\n+        // cleanup\n+        resetBroker();\n     }\n \n     @Test\n@@ -1913,5 +1971,31 @@ public void testOperationSubscriptionDispatchRate() throws Exception {\n             assertEquals(e.getResponse().getStatus(), Status.NOT_FOUND.getStatusCode());\n         }\n     }\n+    /**\n+     * see {@link #cleanupNamespaceByNsCollection(Collection)}\n+     */\n+    private void cleanupNamespaceByPredicate(String tenant, Predicate<String> predicate) throws Exception{\n+        cleanupNamespaceByNsCollection(admin.namespaces().getNamespaces(tenant).stream()\n+                .filter(predicate).collect(Collectors.toSet()));\n+    }\n+\n+    /**\n+     * Remove namespaces.\n+     */\n+    private void cleanupNamespaceByNsCollection(Collection<String> namespaces)\n+            throws Exception{\n+        if (namespaces == null){\n+            return;\n+        }\n+        boolean forceDeleteNamespaceAllowedOriginalValue = pulsar.getConfiguration().isForceDeleteNamespaceAllowed();\n+        pulsar.getConfiguration().setForceDeleteNamespaceAllowed(true);\n+        for (String ns : namespaces){\n+            if (StringUtils.isEmpty(ns)){\n+                continue;\n+            }\n+            deleteNamespaceGraceFully(ns, true);\n+        }\n+        pulsar.getConfiguration().setForceDeleteNamespaceAllowed(forceDeleteNamespaceAllowedOriginalValue);\n+    }\n \n }",
      "parent_sha": "987e0dacd31aeaba6a2f1a59ec5c55fb59bb7999"
    }
  },
  {
    "oid": "cd5351f8078b7d3ac9e0a75bddca408d69640f29",
    "message": "add current time into topic name for ReplicatorTest (#7092)",
    "date": "2020-05-29T03:43:56Z",
    "url": "https://github.com/apache/pulsar/commit/cd5351f8078b7d3ac9e0a75bddca408d69640f29",
    "details": {
      "sha": "4919b24eb55983b75e24b5fa843fdabfebabb04f",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/ReplicatorTest.java",
      "status": "modified",
      "additions": 33,
      "deletions": 19,
      "changes": 52,
      "blob_url": "https://github.com/apache/pulsar/blob/cd5351f8078b7d3ac9e0a75bddca408d69640f29/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FReplicatorTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/cd5351f8078b7d3ac9e0a75bddca408d69640f29/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FReplicatorTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FReplicatorTest.java?ref=cd5351f8078b7d3ac9e0a75bddca408d69640f29",
      "patch": "@@ -123,7 +123,8 @@ public void testConfigChange() throws Exception {\n         // Run a set of producer tasks to create the topics\n         List<Future<Void>> results = Lists.newArrayList();\n         for (int i = 0; i < 10; i++) {\n-            final TopicName dest = TopicName.get(String.format(\"persistent://pulsar/ns/topic-%d\", i));\n+            final TopicName dest = TopicName.get(String\n+                    .format(\"persistent://pulsar/ns/topic-%d-%d\", System.currentTimeMillis(), i));\n \n             results.add(executor.submit(new Callable<Void>() {\n                 @Override\n@@ -206,26 +207,31 @@ public void testConcurrentReplicator() throws Exception {\n         final String namespace = \"pulsar/concurrent\";\n         admin1.namespaces().createNamespace(namespace);\n         admin1.namespaces().setNamespaceReplicationClusters(namespace, Sets.newHashSet(\"r1\", \"r2\"));\n-        final TopicName topicName = TopicName.get(String.format(\"persistent://\" + namespace + \"/topic-%d\", 0));\n+        final TopicName topicName = TopicName\n+                .get(String.format(\"persistent://\" + namespace + \"/topic-%d-%d\", System.currentTimeMillis(), 0));\n \n         @Cleanup\n-        PulsarClient client1 = PulsarClient.builder().serviceUrl(url1.toString()).statsInterval(0, TimeUnit.SECONDS)\n+        PulsarClient client1 = PulsarClient.builder()\n+                .serviceUrl(url1.toString()).statsInterval(0, TimeUnit.SECONDS)\n                 .build();\n         Producer<byte[]> producer = client1.newProducer().topic(topicName.toString())\n             .enableBatching(false)\n             .messageRoutingMode(MessageRoutingMode.SinglePartition)\n             .create();\n         producer.close();\n \n-        PersistentTopic topic = (PersistentTopic) pulsar1.getBrokerService().getOrCreateTopic(topicName.toString()).get();\n+        PersistentTopic topic = (PersistentTopic) pulsar1.getBrokerService()\n+                .getOrCreateTopic(topicName.toString()).get();\n \n-        PulsarClientImpl pulsarClient = spy((PulsarClientImpl) pulsar1.getBrokerService().getReplicationClient(\"r3\"));\n+        PulsarClientImpl pulsarClient = spy((PulsarClientImpl) pulsar1.getBrokerService()\n+                .getReplicationClient(\"r3\"));\n         final Method startRepl = PersistentTopic.class.getDeclaredMethod(\"startReplicator\", String.class);\n         startRepl.setAccessible(true);\n \n         Field replClientField = BrokerService.class.getDeclaredField(\"replicationClients\");\n         replClientField.setAccessible(true);\n-        ConcurrentOpenHashMap<String, PulsarClient> replicationClients = (ConcurrentOpenHashMap<String, PulsarClient>) replClientField\n+        ConcurrentOpenHashMap<String, PulsarClient> replicationClients =\n+                (ConcurrentOpenHashMap<String, PulsarClient>) replClientField\n                 .get(pulsar1.getBrokerService());\n         replicationClients.put(\"r3\", pulsarClient);\n \n@@ -242,8 +248,10 @@ public void testConcurrentReplicator() throws Exception {\n         }\n         Thread.sleep(3000);\n \n-        Mockito.verify(pulsarClient, Mockito.times(1)).createProducerAsync(Mockito.any(ProducerConfigurationData.class),\n-                Mockito.any(Schema.class), eq(null));\n+        Mockito.verify(pulsarClient, Mockito.times(1))\n+                .createProducerAsync(\n+                        Mockito.any(ProducerConfigurationData.class),\n+                        Mockito.any(Schema.class), eq(null));\n \n         executor.shutdown();\n     }\n@@ -400,7 +408,8 @@ public void testFailures() throws Exception {\n         try {\n             // 1. Create a consumer using the reserved consumer id prefix \"pulsar.repl.\"\n \n-            final TopicName dest = TopicName.get(String.format(\"persistent://pulsar/ns/res-cons-id\"));\n+            final TopicName dest = TopicName\n+                    .get(String.format(\"persistent://pulsar/ns/res-cons-id-%d\", System.currentTimeMillis()));\n \n             // Create another consumer using replication prefix as sub id\n             MessageConsumer consumer = new MessageConsumer(url2, dest, \"pulsar.repl.\");\n@@ -415,7 +424,8 @@ public void testFailures() throws Exception {\n     @Test(timeOut = 30000)\n     public void testReplicatePeekAndSkip() throws Exception {\n \n-        final TopicName dest = TopicName.get(\"persistent://pulsar/ns/peekAndSeekTopic\");\n+        final TopicName dest = TopicName.get(\n+                String.format(\"persistent://pulsar/ns/peekAndSeekTopic-%d\", System.currentTimeMillis()));\n \n         @Cleanup\n         MessageProducer producer1 = new MessageProducer(url1, dest);\n@@ -440,7 +450,8 @@ public void testReplicatorClearBacklog() throws Exception {\n         // This test is to verify that reset cursor fails on global topic\n         SortedSet<String> testDests = new TreeSet<String>();\n \n-        final TopicName dest = TopicName.get(\"persistent://pulsar/ns/clearBacklogTopic\");\n+        final TopicName dest = TopicName\n+                .get(String.format(\"persistent://pulsar/ns/clearBacklogTopic-%d\", System.currentTimeMillis()));\n         testDests.add(dest.toString());\n \n         @Cleanup\n@@ -493,7 +504,8 @@ public void testReplicationForBatchMessages() throws Exception {\n         log.info(\"--- Starting ReplicatorTest::testReplicationForBatchMessages ---\");\n \n         // Run a set of producer tasks to create the topics\n-        final TopicName dest = TopicName.get(String.format(\"persistent://pulsar/ns/repltopicbatch-%d\", System.nanoTime()));\n+        final TopicName dest = TopicName\n+                .get(String.format(\"persistent://pulsar/ns/repltopicbatch-%d\", System.nanoTime()));\n \n         @Cleanup\n         MessageProducer producer1 = new MessageProducer(url1, dest, true);\n@@ -547,7 +559,7 @@ public void testReplicationForBatchMessages() throws Exception {\n     @Test(timeOut = 30000)\n     public void testDeleteReplicatorFailure() throws Exception {\n         log.info(\"--- Starting ReplicatorTest::testDeleteReplicatorFailure ---\");\n-        final String topicName = \"persistent://pulsar/ns/repltopicbatch\";\n+        final String topicName = \"persistent://pulsar/ns/repltopicbatch-\" + System.currentTimeMillis() + \"-\";\n         final TopicName dest = TopicName.get(topicName);\n \n         @Cleanup\n@@ -588,7 +600,7 @@ public void deleteCursorFailed(ManagedLedgerException exception, Object ctx) {\n     @Test(priority = 5, timeOut = 30000)\n     public void testReplicatorProducerClosing() throws Exception {\n         log.info(\"--- Starting ReplicatorTest::testDeleteReplicatorFailure ---\");\n-        final String topicName = \"persistent://pulsar/ns/repltopicbatch\";\n+        final String topicName = \"persistent://pulsar/ns/repltopicbatch-\" + System.currentTimeMillis() + \"-\";\n         final TopicName dest = TopicName.get(topicName);\n \n         @Cleanup\n@@ -686,7 +698,7 @@ public void testResumptionAfterBacklogRelaxed() throws Exception {\n      */\n     @Test(timeOut = 15000)\n     public void testCloseReplicatorStartProducer() throws Exception {\n-        TopicName dest = TopicName.get(\"persistent://pulsar/ns1/closeCursor\");\n+        TopicName dest = TopicName.get(\"persistent://pulsar/ns1/closeCursor-\" + System.currentTimeMillis() + \"-\");\n         // Producer on r1\n         @Cleanup\n         MessageProducer producer1 = new MessageProducer(url1, dest);\n@@ -732,7 +744,7 @@ public void testCloseReplicatorStartProducer() throws Exception {\n \n     @Test(timeOut = 30000)\n     public void verifyChecksumAfterReplication() throws Exception {\n-        final String topicName = \"persistent://pulsar/ns/checksumAfterReplication\";\n+        final String topicName = \"persistent://pulsar/ns/checksumAfterReplication-\" + System.currentTimeMillis() + \"-\";\n \n         PulsarClient c1 = PulsarClient.builder().serviceUrl(url1.toString()).build();\n         Producer<byte[]> p1 = c1.newProducer().topic(topicName)\n@@ -771,8 +783,10 @@ public void testReplicatorOnPartitionedTopic(boolean isPartitionedTopic) throws\n         log.info(\"--- Starting ReplicatorTest::{} --- \", methodName);\n \n         final String namespace = \"pulsar/partitionedNs-\" + isPartitionedTopic;\n-        final String persistentTopicName = \"persistent://\" + namespace + \"/partTopic-\" + isPartitionedTopic;\n-        final String nonPersistentTopicName = \"non-persistent://\" + namespace + \"/partTopic-\" + isPartitionedTopic;\n+        final String persistentTopicName =\n+                \"persistent://\" + namespace + \"/partTopic-\" + System.currentTimeMillis() + \"-\" + isPartitionedTopic;\n+        final String nonPersistentTopicName =\n+                \"non-persistent://\" + namespace + \"/partTopic-\" + System.currentTimeMillis() + \"-\"+ isPartitionedTopic;\n         BrokerService brokerService = pulsar1.getBrokerService();\n \n         admin1.namespaces().createNamespace(namespace);\n@@ -824,7 +838,7 @@ public void testReplicatedCluster() throws Exception {\n         log.info(\"--- Starting ReplicatorTest::testReplicatedCluster ---\");\n \n         final String namespace = \"pulsar/global/repl\";\n-        final String topicName = String.format(\"persistent://%s/topic1\", namespace);\n+        final String topicName = String.format(\"persistent://%s/topic1-%d\", namespace, System.currentTimeMillis());\n         admin1.namespaces().createNamespace(namespace);\n         admin1.namespaces().setNamespaceReplicationClusters(namespace, Sets.newHashSet(\"r1\", \"r2\", \"r3\"));\n         admin1.topics().createPartitionedTopic(topicName, 4);",
      "parent_sha": "ff594b8144ace2ea8534773ff78ddb9d4a99455c"
    }
  },
  {
    "oid": "601cc7d0bd632b6e8d02d5617d09eca9ac7ca90a",
    "message": "Use internalReceive with timeout to avoid blocking (#7177)\n\n### Motivation\r\n\r\nSimilar error as #142 occurs in partitioned topics.\r\n\r\n### Modifications\r\n\r\nAdded the same fix as #142 to partitioned topics.\r\nUse internalReceive with timeout to avoid blocking.",
    "date": "2020-06-08T04:09:19Z",
    "url": "https://github.com/apache/pulsar/commit/601cc7d0bd632b6e8d02d5617d09eca9ac7ca90a",
    "details": {
      "sha": "ca67edfb80df6faa6500330af78549d9c71f122d",
      "filename": "pulsar-client/src/main/java/org/apache/pulsar/client/impl/MultiTopicsConsumerImpl.java",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/apache/pulsar/blob/601cc7d0bd632b6e8d02d5617d09eca9ac7ca90a/pulsar-client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FMultiTopicsConsumerImpl.java",
      "raw_url": "https://github.com/apache/pulsar/raw/601cc7d0bd632b6e8d02d5617d09eca9ac7ca90a/pulsar-client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FMultiTopicsConsumerImpl.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FMultiTopicsConsumerImpl.java?ref=601cc7d0bd632b6e8d02d5617d09eca9ac7ca90a",
      "patch": "@@ -271,7 +271,13 @@ private void messageReceived(ConsumerImpl<T> consumer, Message<T> message) {\n             listenerExecutor.execute(() -> {\n                 Message<T> msg;\n                 try {\n-                    msg = internalReceive();\n+                    msg = internalReceive(0, TimeUnit.MILLISECONDS);\n+                    if (msg == null) {\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"[{}] [{}] Message has been cleared from the queue\", topic, subscription);\n+                        }\n+                        return;\n+                    }\n                 } catch (PulsarClientException e) {\n                     log.warn(\"[{}] [{}] Failed to dequeue the message for listener\", topic, subscription, e);\n                     return;",
      "parent_sha": "844b2ec7816cba2e9c75b1fba151b065f631d5f6"
    }
  },
  {
    "oid": "b96c50d010f378e087e07c57ae6fac25878433bf",
    "message": "Fix Intermittent test for dispatcher (#774)",
    "date": "2017-09-21T00:05:28Z",
    "url": "https://github.com/apache/pulsar/commit/b96c50d010f378e087e07c57ae6fac25878433bf",
    "details": {
      "sha": "a15aabda46c04fea6e29edb08f5601e35f49957a",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/client/api/DispatcherBlockConsumerTest.java",
      "status": "modified",
      "additions": 75,
      "deletions": 106,
      "changes": 181,
      "blob_url": "https://github.com/apache/pulsar/blob/b96c50d010f378e087e07c57ae6fac25878433bf/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fapi%2FDispatcherBlockConsumerTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/b96c50d010f378e087e07c57ae6fac25878433bf/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fapi%2FDispatcherBlockConsumerTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fapi%2FDispatcherBlockConsumerTest.java?ref=b96c50d010f378e087e07c57ae6fac25878433bf",
      "patch": "@@ -29,6 +29,7 @@\n import java.lang.reflect.Field;\n import java.util.Arrays;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.CountDownLatch;\n@@ -61,6 +62,7 @@\n import org.testng.annotations.BeforeMethod;\n import org.testng.annotations.DataProvider;\n import org.testng.annotations.Test;\n+import org.testng.collections.Lists;\n \n import com.google.common.collect.ArrayListMultimap;\n import com.google.common.collect.Maps;\n@@ -95,7 +97,7 @@ public Object[][] bundleUnloading() {\n      *\n      * @throws Exception\n      */\n-    @Test\n+    @Test(timeOut=10000)\n     public void testConsumerBlockingWithUnAckedMessagesAtDispatcher() throws Exception {\n         log.info(\"-- Starting {} test --\", methodName);\n \n@@ -137,7 +139,6 @@ public void testConsumerBlockingWithUnAckedMessagesAtDispatcher() throws Excepti\n                     msg = consumers[i].receive(500, TimeUnit.MILLISECONDS);\n                     if (msg != null) {\n                         messages.put(msg, consumers[i]);\n-                        log.info(\"Received message: \" + new String(msg.getData()));\n                     } else {\n                         break;\n                     }\n@@ -156,33 +157,33 @@ public void testConsumerBlockingWithUnAckedMessagesAtDispatcher() throws Excepti\n                     fail(\"ack failed\", e);\n                 }\n             });\n-            // wait to start dispatching-async\n-            Thread.sleep(1000);\n-            // try to consume remaining messages\n-            int remainingMessages = totalProducedMsgs - messages.size();\n+            \n             // try to consume remaining messages: broker may take time to deliver so, retry multiple time to consume\n             // all messages\n-            for (int retry = 0; retry < 5; retry++) {\n-                for (int i = 0; i < consumers.length; i++) {\n-                    for (int j = 0; j < remainingMessages; j++) {\n-                        msg = consumers[i].receive(100, TimeUnit.MILLISECONDS);\n-                        if (msg != null) {\n-                            messages.put(msg, consumers[i]);\n-                            log.info(\"Received message: \" + new String(msg.getData()));\n-                        } else {\n-                            break;\n+            List<MessageId> result = Lists.newArrayList();\n+            // expecting messages which are not received\n+            int expectedRemainingMessages = totalProducedMsgs - messages.size();\n+            CountDownLatch latch = new CountDownLatch(expectedRemainingMessages);\n+            for (int i = 0; i < consumers.length; i++) {\n+                final int consumerCount = i;\n+                for (int j = 0; j < totalProducedMsgs; j++) {\n+                    consumers[i].receiveAsync().thenAccept(m -> {\n+                        result.add(m.getMessageId());\n+                        try {\n+                            consumers[consumerCount].acknowledge(m);\n+                        } catch (PulsarClientException e) {\n+                            fail(\"failed to ack msg\", e);\n                         }\n-                    }\n-                }\n-                if (messages.size() >= totalProducedMsgs) {\n-                    break;\n-                } else {\n-                    Thread.sleep(100);\n+                        latch.countDown();\n+                    });\n                 }\n             }\n \n-            // total received-messages should match to produced messages\n-            assertEquals(totalProducedMsgs, messages.size());\n+            latch.await();\n+\n+            // total received-messages should match to produced messages (it may have duplicate messages)\n+            assertTrue(result.size() >= expectedRemainingMessages);\n+\n             producer.close();\n             Arrays.asList(consumers).forEach(c -> {\n                 try {\n@@ -205,7 +206,7 @@ public void testConsumerBlockingWithUnAckedMessagesAtDispatcher() throws Excepti\n      *\n      * @throws Exception\n      */\n-    @Test\n+    @Test(timeOut=10000)\n     public void testConsumerBlockingWithUnAckedMessagesAndRedelivery() throws Exception {\n         log.info(\"-- Starting {} test --\", methodName);\n \n@@ -252,75 +253,38 @@ public void testConsumerBlockingWithUnAckedMessagesAndRedelivery() throws Except\n                 }\n             }\n \n-            int totalConsumedMsgs = messages.size();\n             // client must receive number of messages = unAckedMessagesBufferSize rather all produced messages\n             assertNotEquals(messages.size(), totalProducedMsgs);\n \n-            // trigger redelivery\n+            // (3) trigger redelivery\n             messages.asMap().forEach((c, msgs) -> {\n                 c.redeliverUnacknowledgedMessages(\n                         msgs.stream().map(m -> (MessageIdImpl) m).collect(Collectors.toSet()));\n             });\n \n-            // wait for redelivery to be completed\n-            Thread.sleep(1000);\n-\n-            // now, broker must have redelivered all unacked messages\n-            messages.clear();\n-            for (int i = 0; i < 3; i++) {\n-                for (int j = 0; j < totalProducedMsgs; j++) {\n-                    msg = consumers[i].receive(500, TimeUnit.MILLISECONDS);\n-                    if (msg != null) {\n-                        messages.put(consumers[i], msg.getMessageId());\n-                        log.info(\"Received message: \" + new String(msg.getData()));\n-                    } else {\n-                        break;\n-                    }\n-                }\n-            }\n-\n-            // check all unacked messages have been redelivered: with delta 30: 3 consumers with receiverQueueSize=10\n-            Set<MessageId> result = Sets.newHashSet(messages.values());\n-            assertEquals(totalConsumedMsgs, result.size(), 3 * receiverQueueSize);\n-\n-            // start acknowledging messages\n-            messages.asMap().forEach((c, msgs) -> {\n-                msgs.forEach(m -> {\n-                    try {\n-                        c.acknowledge(m);\n-                    } catch (PulsarClientException e) {\n-                        fail(\"ack failed\", e);\n-                    }\n-                });\n-            });\n-\n-            // now: dispatcher must be unblocked: wait to start dispatching-async\n-            Thread.sleep(1000);\n-            result = Sets.newHashSet(messages.values());\n-            // try to consume remaining messages: broker may take time to deliver so, retry multiple time to consume\n+            // (4) try to consume remaining messages: broker may take time to deliver so, retry multiple time to consume\n             // all messages\n-            for (int retry = 0; retry < 5; retry++) {\n-                for (int i = 0; i < consumers.length; i++) {\n-                    for (int j = 0; j < totalProducedMsgs; j++) {\n-                        msg = consumers[i].receive(100, TimeUnit.MILLISECONDS);\n-                        if (msg != null) {\n-                            result.add(msg.getMessageId());\n-                            consumers[i].acknowledge(msg);\n-                            log.info(\"Received message: \" + new String(msg.getData()));\n-                        } else {\n-                            break;\n+            List<MessageId> result = Lists.newArrayList();\n+            CountDownLatch latch = new CountDownLatch(totalProducedMsgs);\n+            for (int i = 0; i < consumers.length; i++) {\n+                final int consumerCount = i;\n+                for (int j = 0; j < totalProducedMsgs; j++) {\n+                    consumers[i].receiveAsync().thenAccept(m -> {\n+                        result.add(m.getMessageId());\n+                        try {\n+                            consumers[consumerCount].acknowledge(m);\n+                        } catch (PulsarClientException e) {\n+                            fail(\"failed to ack msg\", e);\n                         }\n-                    }\n-                }\n-                if (result.size() >= totalProducedMsgs) {\n-                    break;\n-                } else {\n-                    Thread.sleep(100);\n+                        latch.countDown();\n+                    });\n                 }\n             }\n \n-            // total received-messages should match to produced messages\n-            assertEquals(totalProducedMsgs, result.size());\n+            latch.await();\n+\n+            // total received-messages should match to produced messages (it may have duplicate messages)\n+            assertTrue(result.size() >= totalProducedMsgs);\n             producer.close();\n             Arrays.asList(consumers).forEach(c -> {\n                 try {\n@@ -389,10 +353,10 @@ public void testCloseConsumerBlockedDispatcher() throws Exception {\n             // client must receive number of messages = unAckedMessagesBufferSize rather all produced messages\n             assertEquals(messages.size(), unackMsgAllowed, receiverQueueSize * 2);\n \n-            // create consumer2\n-            Consumer consumer2 = pulsarClient.subscribe(topicName, subscriberName, conf);\n             // close consumer1: all messages of consumer1 must be replayed and received by consumer2\n             consumer1.close();\n+            // create consumer2\n+            Consumer consumer2 = pulsarClient.subscribe(topicName, subscriberName, conf);\n             Map<Message, Consumer> messages2 = Maps.newHashMap();\n             // try to consume remaining messages: broker may take time to deliver so, retry multiple time to consume\n             // all messages\n@@ -431,7 +395,7 @@ public void testCloseConsumerBlockedDispatcher() throws Exception {\n      *\n      * @throws Exception\n      */\n-    @Test\n+    @Test(timeOut=10000)\n     public void testRedeliveryOnBlockedDistpatcher() throws Exception {\n         log.info(\"-- Starting {} test --\", methodName);\n \n@@ -482,7 +446,7 @@ public void testRedeliveryOnBlockedDistpatcher() throws Exception {\n \n             int totalConsumedMsgs = messages.size();\n             // client must receive number of messages = unAckedMessagesBufferSize rather all produced messages\n-            assertEquals(totalConsumedMsgs, unackMsgAllowed, 2 * receiverQueueSize);\n+            assertEquals(totalConsumedMsgs, unackMsgAllowed, 3 * receiverQueueSize);\n \n             // trigger redelivery\n             Arrays.asList(consumers).forEach(c -> {\n@@ -525,36 +489,31 @@ public void testRedeliveryOnBlockedDistpatcher() throws Exception {\n                 });\n             });\n \n-            // now: dispatcher must be unblocked: wait to start dispatching-async\n-            Thread.sleep(1000);\n-            result.clear();\n             messages1.values().forEach(s -> result.addAll(s));\n             // try to consume remaining messages\n-            int remainingMessages = totalProducedMsgs - messages1.size();\n+            int remainingMessages = totalProducedMsgs - result.size();\n             // try to consume remaining messages: broker may take time to deliver so, retry multiple time to consume\n             // all messages\n-            for (int retry = 0; retry < 5; retry++) {\n-                for (int i = 0; i < consumers.length; i++) {\n-                    for (int j = 0; j < remainingMessages; j++) {\n-                        msg = consumers[i].receive(100, TimeUnit.MILLISECONDS);\n-                        if (msg != null) {\n-                            result.add(msg.getMessageId());\n-                            consumers[i].acknowledge(msg);\n-                            log.info(\"Received message: \" + new String(msg.getData()));\n-                        } else {\n-                            break;\n+            CountDownLatch latch = new CountDownLatch(remainingMessages);\n+            List<MessageId> consumedMessages = Lists.newArrayList();\n+            for (int i = 0; i < consumers.length; i++) {\n+                final int counsumerIndex = i;\n+                for (int j = 0; j < remainingMessages; j++) {\n+                    consumers[i].receiveAsync().thenAccept(m -> {\n+                        consumedMessages.add(m.getMessageId());\n+                        try {\n+                            consumers[counsumerIndex].acknowledge(m);\n+                        } catch (PulsarClientException e) {\n+                            fail(\"failed to ack\", e);\n                         }\n-                    }\n-                }\n-                if (result.size() >= totalProducedMsgs) {\n-                    break;\n-                } else {\n-                    Thread.sleep(100);\n+                        latch.countDown();\n+                    });\n                 }\n             }\n \n-            // total received-messages should match to produced messages\n-            assertEquals(totalProducedMsgs, result.size());\n+            latch.await();\n+            // total received-messages should match remaining messages excluding duplicate\n+            assertTrue(consumedMessages.size() >= remainingMessages);\n             producer.close();\n             Arrays.asList(consumers).forEach(c -> {\n                 try {\n@@ -797,6 +756,11 @@ public void testBlockBrokerDispatching() throws Exception {\n                 } else {\n                     break;\n                 }\n+                // once consumer receives maxUnAckPerBroker-msgs then sleep to give a chance to scheduler to block the\n+                // subscription\n+                if (j == maxUnAckPerBroker) {\n+                    Thread.sleep(200);\n+                }\n             }\n             // client must receive number of messages = maxUnAckPerbroker rather all produced messages\n             assertNotEquals(messages1.size(), totalProducedMsgs);\n@@ -976,6 +940,11 @@ public void testBrokerDispatchBlockAndSubAckBackRequiredMsgs() {\n                 } else {\n                     break;\n                 }\n+                // once consumer receives maxUnAckPerBroker-msgs then sleep to give a chance to scheduler to block the\n+                // subscription\n+                if (j == maxUnAckPerBroker) {\n+                    Thread.sleep(200);\n+                }\n             }\n             // client must receive number of messages = maxUnAckPerbroker rather all produced messages\n             assertNotEquals(messages1.size(), totalProducedMsgs);",
      "parent_sha": "94b1fb9a36c8dc8f2fac9ec1dd9c7bc6fcc31d6c"
    }
  },
  {
    "oid": "b1359a562baf63a2ebfc43cfc4b10f59a0720e86",
    "message": "fix exception cast error (#8828)\n\nFixes #8827\r\n\r\n### Motivation\r\n\r\nfix exception cast error",
    "date": "2020-12-04T17:31:46Z",
    "url": "https://github.com/apache/pulsar/commit/b1359a562baf63a2ebfc43cfc4b10f59a0720e86",
    "details": {
      "sha": "781b5aed169c786b485ff2120bf40e0721ce00de",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/AdminResource.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/apache/pulsar/blob/b1359a562baf63a2ebfc43cfc4b10f59a0720e86/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2FAdminResource.java",
      "raw_url": "https://github.com/apache/pulsar/raw/b1359a562baf63a2ebfc43cfc4b10f59a0720e86/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2FAdminResource.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2FAdminResource.java?ref=b1359a562baf63a2ebfc43cfc4b10f59a0720e86",
      "patch": "@@ -697,7 +697,7 @@ protected static PartitionedTopicMetadata fetchPartitionedTopicMetadata(PulsarSe\n             return pulsar.getBrokerService().fetchPartitionedTopicMetadataAsync(topicName).get();\n         } catch (Exception e) {\n             if (e.getCause() instanceof RestException) {\n-                throw (RestException) e;\n+                throw (RestException) e.getCause();\n             }\n             throw new RestException(e);\n         }\n@@ -710,7 +710,7 @@ protected static PartitionedTopicMetadata fetchPartitionedTopicMetadataCheckAllo\n                     .get();\n         } catch (Exception e) {\n             if (e.getCause() instanceof RestException) {\n-                throw (RestException) e;\n+                throw (RestException) e.getCause();\n             }\n             throw new RestException(e);\n         }",
      "parent_sha": "18fd15bb73908b37fad961a578c15ffc9230f44f"
    }
  },
  {
    "oid": "ec0a44058d249a7510bb3d05685b2ee5e0874eb6",
    "message": "Fix NPE when unloading namespace bundle (#13571)\n\n* Fix NPE when unloading namespace bundle",
    "date": "2022-01-05T06:46:32Z",
    "url": "https://github.com/apache/pulsar/commit/ec0a44058d249a7510bb3d05685b2ee5e0874eb6",
    "details": {
      "sha": "0451571103015c1de086ef564694cf89f4e67219",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/BrokerService.java",
      "status": "modified",
      "additions": 11,
      "deletions": 10,
      "changes": 21,
      "blob_url": "https://github.com/apache/pulsar/blob/ec0a44058d249a7510bb3d05685b2ee5e0874eb6/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FBrokerService.java",
      "raw_url": "https://github.com/apache/pulsar/raw/ec0a44058d249a7510bb3d05685b2ee5e0874eb6/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FBrokerService.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FBrokerService.java?ref=ec0a44058d249a7510bb3d05685b2ee5e0874eb6",
      "patch": "@@ -874,17 +874,18 @@ public void unloadNamespaceBundlesGracefully() {\n             // unload all namespace-bundles gracefully\n             long closeTopicsStartTime = System.nanoTime();\n             Set<NamespaceBundle> serviceUnits = pulsar.getNamespaceService().getOwnedServiceUnits();\n-            serviceUnits.forEach(su -> {\n-                if (su instanceof NamespaceBundle) {\n-                    try {\n-                        pulsar.getNamespaceService().unloadNamespaceBundle(su,\n-                                pulsar.getConfiguration().getNamespaceBundleUnloadingTimeoutMs(), TimeUnit.MILLISECONDS)\n-                                .get();\n-                    } catch (Exception e) {\n-                        log.warn(\"Failed to unload namespace bundle {}\", su, e);\n+            if (serviceUnits != null) {\n+                serviceUnits.forEach(su -> {\n+                    if (su instanceof NamespaceBundle) {\n+                        try {\n+                            pulsar.getNamespaceService().unloadNamespaceBundle(su, pulsar.getConfiguration()\n+                                    .getNamespaceBundleUnloadingTimeoutMs(), TimeUnit.MILLISECONDS).get();\n+                        } catch (Exception e) {\n+                            log.warn(\"Failed to unload namespace bundle {}\", su, e);\n+                        }\n                     }\n-                }\n-            });\n+                });\n+            }\n \n             double closeTopicsTimeSeconds = TimeUnit.NANOSECONDS.toMillis((System.nanoTime() - closeTopicsStartTime))\n                     / 1000.0;",
      "parent_sha": "4b5085f9183e4d4cf0e728b17f436162c0b786c6"
    }
  },
  {
    "oid": "ebde4dcb5d15a95741cf9e2328e0b80781378293",
    "message": "Correct error\uff1athe number of {} is different to arguments count. (#4570)",
    "date": "2019-06-20T15:30:04Z",
    "url": "https://github.com/apache/pulsar/commit/ebde4dcb5d15a95741cf9e2328e0b80781378293",
    "details": {
      "sha": "d1218eb6e9eb1f80296d6732f91fa88a66659f35",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/web/PulsarWebResource.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/pulsar/blob/ebde4dcb5d15a95741cf9e2328e0b80781378293/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fweb%2FPulsarWebResource.java",
      "raw_url": "https://github.com/apache/pulsar/raw/ebde4dcb5d15a95741cf9e2328e0b80781378293/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fweb%2FPulsarWebResource.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fweb%2FPulsarWebResource.java?ref=ebde4dcb5d15a95741cf9e2328e0b80781378293",
      "patch": "@@ -619,7 +619,7 @@ protected void validateGlobalNamespaceOwnership(NamespaceName namespace) {\n                 URI redirect = getRedirectionUrl(peerClusterData);\n                 // redirect to the cluster requested\n                 if (log.isDebugEnabled()) {\n-                    log.debug(\"[{}] Redirecting the rest call to {}: cluster={}\", redirect, peerClusterData);\n+                    log.debug(\"[{}] Redirecting the rest call to {}: cluster={}\", clientAppId(),redirect, peerClusterData);\n \n                 }\n                 throw new WebApplicationException(Response.temporaryRedirect(redirect).build());",
      "parent_sha": "e643c5e4968484b06f64e216cb110a733b1aa5db"
    }
  },
  {
    "oid": "55ef1639cb8cb9e578068e027a16e1ad77fa060a",
    "message": "[Flaky test] Reduce flakiness in MultiTopicsReaderTest by configuring infinite retention for namespace (#9866)",
    "date": "2021-03-11T01:44:46Z",
    "url": "https://github.com/apache/pulsar/commit/55ef1639cb8cb9e578068e027a16e1ad77fa060a",
    "details": {
      "sha": "6359701e8b0224a927ab59c7630d5b5f77b96f7b",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/client/impl/MultiTopicsReaderTest.java",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/apache/pulsar/blob/55ef1639cb8cb9e578068e027a16e1ad77fa060a/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FMultiTopicsReaderTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/55ef1639cb8cb9e578068e027a16e1ad77fa060a/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FMultiTopicsReaderTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FMultiTopicsReaderTest.java?ref=55ef1639cb8cb9e578068e027a16e1ad77fa060a",
      "patch": "@@ -47,6 +47,7 @@\n import org.apache.pulsar.client.api.Schema;\n import org.apache.pulsar.common.policies.data.ClusterData;\n import org.apache.pulsar.common.policies.data.PersistentTopicInternalStats;\n+import org.apache.pulsar.common.policies.data.Policies;\n import org.apache.pulsar.common.policies.data.RetentionPolicies;\n import org.apache.pulsar.common.policies.data.TenantInfo;\n import org.apache.pulsar.common.util.Murmur3_32Hash;\n@@ -68,7 +69,11 @@ protected void setup() throws Exception {\n                 new ClusterData(pulsar.getWebServiceAddress()));\n         admin.tenants().createTenant(\"my-property\",\n                 new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"test\")));\n-        admin.namespaces().createNamespace(\"my-property/my-ns\", Sets.newHashSet(\"test\"));\n+        Policies policies = new Policies();\n+        policies.replication_clusters = Sets.newHashSet(\"test\");\n+        // infinite retention\n+        policies.retention_policies = new RetentionPolicies(-1, -1);\n+        admin.namespaces().createNamespace(\"my-property/my-ns\", policies);\n     }\n \n     @AfterMethod(alwaysRun = true)",
      "parent_sha": "dd5c3b48879efa9b6505e8d52d378122850bb32a"
    }
  },
  {
    "oid": "6d840b46455c110dfe7065ced62052f8f6d3fb95",
    "message": "[Broker] Correct message of status code 403 in v2/PersistentTopics (#13491)",
    "date": "2021-12-28T10:37:50Z",
    "url": "https://github.com/apache/pulsar/commit/6d840b46455c110dfe7065ced62052f8f6d3fb95",
    "details": {
      "sha": "73b1d20b8c5b45b8a3f8886cf69c02d25b836067",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/v2/PersistentTopics.java",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/apache/pulsar/blob/6d840b46455c110dfe7065ced62052f8f6d3fb95/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2Fv2%2FPersistentTopics.java",
      "raw_url": "https://github.com/apache/pulsar/raw/6d840b46455c110dfe7065ced62052f8f6d3fb95/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2Fv2%2FPersistentTopics.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2Fv2%2FPersistentTopics.java?ref=6d840b46455c110dfe7065ced62052f8f6d3fb95",
      "patch": "@@ -2800,7 +2800,7 @@ public void getDispatchRate(@Suspended final AsyncResponse asyncResponse,\n     @POST\n     @Path(\"/{tenant}/{namespace}/{topic}/dispatchRate\")\n     @ApiOperation(value = \"Set message dispatch rate configuration for specified topic.\")\n-    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Topic does not exist\"),\n+    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Don't have admin permission\"),\n             @ApiResponse(code = 404, message = \"Topic does not exist\"),\n             @ApiResponse(code = 405,\n                     message = \"Topic level policy is disabled, please enable the topic level policy and retry\"),\n@@ -2837,7 +2837,7 @@ public void setDispatchRate(@Suspended final AsyncResponse asyncResponse,\n     @DELETE\n     @Path(\"/{tenant}/{namespace}/{topic}/dispatchRate\")\n     @ApiOperation(value = \"Remove message dispatch rate configuration for specified topic.\")\n-    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Topic does not exist\"),\n+    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Don't have admin permission\"),\n             @ApiResponse(code = 404, message = \"Topic does not exist\"),\n             @ApiResponse(code = 405,\n                     message = \"Topic level policy is disabled, please enable the topic level policy and retry\"),\n@@ -2894,7 +2894,7 @@ public void getSubscriptionDispatchRate(@Suspended final AsyncResponse asyncResp\n     @POST\n     @Path(\"/{tenant}/{namespace}/{topic}/subscriptionDispatchRate\")\n     @ApiOperation(value = \"Set subscription message dispatch rate configuration for specified topic.\")\n-    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Topic does not exist\"),\n+    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Don't have admin permission\"),\n             @ApiResponse(code = 404, message = \"Topic does not exist\"),\n             @ApiResponse(code = 405,\n                     message = \"Topic level policy is disabled, please enable the topic level policy and retry\"),\n@@ -2932,7 +2932,7 @@ public void setSubscriptionDispatchRate(\n     @DELETE\n     @Path(\"/{tenant}/{namespace}/{topic}/subscriptionDispatchRate\")\n     @ApiOperation(value = \"Remove subscription message dispatch rate configuration for specified topic.\")\n-    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Topic does not exist\"),\n+    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Don't have admin permission\"),\n             @ApiResponse(code = 404, message = \"Topic does not exist\"),\n             @ApiResponse(code = 405,\n                     message = \"Topic level policy is disabled, please enable the topic level policy and retry\"),\n@@ -2988,7 +2988,7 @@ public void getCompactionThreshold(@Suspended final AsyncResponse asyncResponse,\n     @POST\n     @Path(\"/{tenant}/{namespace}/{topic}/compactionThreshold\")\n     @ApiOperation(value = \"Set compaction threshold configuration for specified topic.\")\n-    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Topic does not exist\"),\n+    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Don't have admin permission\"),\n             @ApiResponse(code = 404, message = \"Topic does not exist\"),\n             @ApiResponse(code = 405,\n                     message = \"Topic level policy is disabled, please enable the topic level policy and retry\"),\n@@ -3024,7 +3024,7 @@ public void setCompactionThreshold(@Suspended final AsyncResponse asyncResponse,\n     @DELETE\n     @Path(\"/{tenant}/{namespace}/{topic}/compactionThreshold\")\n     @ApiOperation(value = \"Remove compaction threshold configuration for specified topic.\")\n-    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Topic does not exist\"),\n+    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Don't have admin permission\"),\n             @ApiResponse(code = 404, message = \"Topic does not exist\"),\n             @ApiResponse(code = 405,\n                     message = \"Topic level policy is disabled, please enable the topic level policy and retry\"),\n@@ -3081,7 +3081,7 @@ public void getMaxConsumersPerSubscription(@Suspended final AsyncResponse asyncR\n     @POST\n     @Path(\"/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription\")\n     @ApiOperation(value = \"Set max consumers per subscription configuration for specified topic.\")\n-    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Topic does not exist\"),\n+    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Don't have admin permission\"),\n             @ApiResponse(code = 404, message = \"Topic does not exist\"),\n             @ApiResponse(code = 405,\n                     message = \"Topic level policy is disabled, please enable the topic level policy and retry\"),\n@@ -3119,7 +3119,7 @@ public void setMaxConsumersPerSubscription(\n     @DELETE\n     @Path(\"/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription\")\n     @ApiOperation(value = \"Remove max consumers per subscription configuration for specified topic.\")\n-    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Topic does not exist\"),\n+    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Don't have admin permission\"),\n             @ApiResponse(code = 404, message = \"Topic does not exist\"),\n             @ApiResponse(code = 405,\n                     message = \"Topic level policy is disabled, please enable the topic level policy and retry\"),\n@@ -3177,7 +3177,7 @@ public void getPublishRate(@Suspended final AsyncResponse asyncResponse,\n     @POST\n     @Path(\"/{tenant}/{namespace}/{topic}/publishRate\")\n     @ApiOperation(value = \"Set message publish rate configuration for specified topic.\")\n-    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Topic does not exist\"),\n+    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Don't have admin permission\"),\n             @ApiResponse(code = 404, message = \"Topic does not exist\"),\n             @ApiResponse(code = 405,\n                     message = \"Topic level policy is disabled, please enable the topic level policy and retry\"),\n@@ -3213,7 +3213,7 @@ public void setPublishRate(@Suspended final AsyncResponse asyncResponse,\n     @DELETE\n     @Path(\"/{tenant}/{namespace}/{topic}/publishRate\")\n     @ApiOperation(value = \"Remove message publish rate configuration for specified topic.\")\n-    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Topic does not exist\"),\n+    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Don't have admin permission\"),\n             @ApiResponse(code = 404, message = \"Topic does not exist\"),\n             @ApiResponse(code = 405,\n                     message = \"Topic level policy is disabled, please enable the topic level policy and retry\"),\n@@ -3272,7 +3272,7 @@ public void getSubscriptionTypesEnabled(@Suspended final AsyncResponse asyncResp\n     @POST\n     @Path(\"/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled\")\n     @ApiOperation(value = \"Set is enable sub types for specified topic\")\n-    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Topic does not exist\"),\n+    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Don't have admin permission\"),\n             @ApiResponse(code = 404, message = \"Topic does not exist\"),\n             @ApiResponse(code = 405,\n                     message = \"Topic level policy is disabled, please enable the topic level policy and retry\"),\n@@ -3365,7 +3365,7 @@ public void getSubscribeRate(@Suspended final AsyncResponse asyncResponse,\n     @POST\n     @Path(\"/{tenant}/{namespace}/{topic}/subscribeRate\")\n     @ApiOperation(value = \"Set subscribe rate configuration for specified topic.\")\n-    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Topic does not exist\"),\n+    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Don't have admin permission\"),\n             @ApiResponse(code = 404, message = \"Topic does not exist\"),\n             @ApiResponse(code = 405,\n                     message = \"Topic level policy is disabled, please enable the topic level policy and retry\"),\n@@ -3402,7 +3402,7 @@ public void setSubscribeRate(\n     @DELETE\n     @Path(\"/{tenant}/{namespace}/{topic}/subscribeRate\")\n     @ApiOperation(value = \"Remove subscribe rate configuration for specified topic.\")\n-    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Topic does not exist\"),\n+    @ApiResponses(value = {@ApiResponse(code = 403, message = \"Don't have admin permission\"),\n             @ApiResponse(code = 404, message = \"Topic does not exist\"),\n             @ApiResponse(code = 405,\n                     message = \"Topic level policy is disabled, please enable the topic level policy and retry\"),",
      "parent_sha": "132ba0cbc3f6c918831b847948f293cb6a3e5d1e"
    }
  },
  {
    "oid": "01b55678321b6cf254f5d289f7eb177a6aea9be9",
    "message": "[Flaky-test]: AdminApiTest.testNamespaceSplitBundleConcurrent (#14565)",
    "date": "2022-03-05T10:29:52Z",
    "url": "https://github.com/apache/pulsar/commit/01b55678321b6cf254f5d289f7eb177a6aea9be9",
    "details": {
      "sha": "4a65128b22aa4650cd185926fb61716a1b47b2d1",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/AdminApiTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/apache/pulsar/blob/01b55678321b6cf254f5d289f7eb177a6aea9be9/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2FAdminApiTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/01b55678321b6cf254f5d289f7eb177a6aea9be9/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2FAdminApiTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2FAdminApiTest.java?ref=01b55678321b6cf254f5d289f7eb177a6aea9be9",
      "patch": "@@ -1533,10 +1533,11 @@ public void testNamespaceSplitBundleConcurrent() throws Exception {\n             fail(\"split bundle shouldn't have thrown exception\");\n         }\n \n+        Awaitility.await().untilAsserted(() ->\n+                assertEquals(bundleFactory.getBundles(NamespaceName.get(namespace)).getBundles().size(), 4));\n         String[] splitRange4 = { namespace + \"/0x00000000_0x3fffffff\", namespace + \"/0x3fffffff_0x7fffffff\",\n                 namespace + \"/0x7fffffff_0xbfffffff\", namespace + \"/0xbfffffff_0xffffffff\" };\n         bundles = bundleFactory.getBundles(NamespaceName.get(namespace));\n-        assertEquals(bundles.getBundles().size(), 4);\n         for (int i = 0; i < bundles.getBundles().size(); i++) {\n             assertEquals(bundles.getBundles().get(i).toString(), splitRange4[i]);\n         }\n@@ -1566,13 +1567,13 @@ public void testNamespaceSplitBundleConcurrent() throws Exception {\n         } catch (Exception e) {\n             fail(\"split bundle shouldn't have thrown exception\");\n         }\n-\n+        Awaitility.await().untilAsserted(() ->\n+                assertEquals(bundleFactory.getBundles(NamespaceName.get(namespace)).getBundles().size(), 8));\n         String[] splitRange8 = { namespace + \"/0x00000000_0x1fffffff\", namespace + \"/0x1fffffff_0x3fffffff\",\n                 namespace + \"/0x3fffffff_0x5fffffff\", namespace + \"/0x5fffffff_0x7fffffff\",\n                 namespace + \"/0x7fffffff_0x9fffffff\", namespace + \"/0x9fffffff_0xbfffffff\",\n                 namespace + \"/0xbfffffff_0xdfffffff\", namespace + \"/0xdfffffff_0xffffffff\" };\n         bundles = bundleFactory.getBundles(NamespaceName.get(namespace));\n-        assertEquals(bundles.getBundles().size(), 8);\n         for (int i = 0; i < bundles.getBundles().size(); i++) {\n             assertEquals(bundles.getBundles().get(i).toString(), splitRange8[i]);\n         }",
      "parent_sha": "4f1e39b6921ea401b8c27f17a041d06d85f8abf8"
    }
  },
  {
    "oid": "f32154c06c6475fac1cd89d105d3c31d5d8713dc",
    "message": "[Broker] Fixed wrong behaviour caused by not cleaning up topic policy service state. (#14503)",
    "date": "2022-03-09T01:18:39Z",
    "url": "https://github.com/apache/pulsar/commit/f32154c06c6475fac1cd89d105d3c31d5d8713dc",
    "details": {
      "sha": "bbb02577119b8ff50a572f6e48d1f0b5942a6952",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/SystemTopicBasedTopicPoliciesService.java",
      "status": "modified",
      "additions": 20,
      "deletions": 19,
      "changes": 39,
      "blob_url": "https://github.com/apache/pulsar/blob/f32154c06c6475fac1cd89d105d3c31d5d8713dc/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FSystemTopicBasedTopicPoliciesService.java",
      "raw_url": "https://github.com/apache/pulsar/raw/f32154c06c6475fac1cd89d105d3c31d5d8713dc/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FSystemTopicBasedTopicPoliciesService.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FSystemTopicBasedTopicPoliciesService.java?ref=f32154c06c6475fac1cd89d105d3c31d5d8713dc",
      "patch": "@@ -23,6 +23,7 @@\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.TimeUnit;\n@@ -255,8 +256,7 @@ private void prepareInitPoliciesCache(NamespaceName namespace, CompletableFuture\n                 if (ex != null) {\n                     log.error(\"[{}] Failed to create reader on __change_events topic\", namespace, ex);\n                     result.completeExceptionally(ex);\n-                    readerCaches.remove(namespace);\n-                    reader.closeAsync();\n+                    cleanCacheAndCloseReader(reader.getSystemTopic().getTopicName().getNamespaceObject(), false);\n                 } else {\n                     initPolicesCache(reader, result);\n                     result.thenRun(() -> readMorePolicies(reader));\n@@ -290,14 +290,7 @@ public CompletableFuture<Void> removeOwnedNamespaceBundleAsync(NamespaceBundle n\n         }\n         AtomicInteger bundlesCount = ownedBundlesCountPerNamespace.get(namespace);\n         if (bundlesCount == null || bundlesCount.decrementAndGet() <= 0) {\n-            CompletableFuture<SystemTopicClient.Reader<PulsarEvent>> readerCompletableFuture =\n-                    readerCaches.remove(namespace);\n-            if (readerCompletableFuture != null) {\n-                readerCompletableFuture.thenAccept(SystemTopicClient.Reader::closeAsync);\n-                ownedBundlesCountPerNamespace.remove(namespace);\n-                policyCacheInitMap.remove(namespace);\n-                policiesCache.entrySet().removeIf(entry -> entry.getKey().getNamespaceObject().equals(namespace));\n-            }\n+            cleanCacheAndCloseReader(namespace, true);\n         }\n         return CompletableFuture.completedFuture(null);\n     }\n@@ -331,9 +324,7 @@ private void initPolicesCache(SystemTopicClient.Reader<PulsarEvent> reader, Comp\n                 log.error(\"[{}] Failed to check the move events for the system topic\",\n                         reader.getSystemTopic().getTopicName(), ex);\n                 future.completeExceptionally(ex);\n-                readerCaches.remove(reader.getSystemTopic().getTopicName().getNamespaceObject());\n-                policyCacheInitMap.remove(reader.getSystemTopic().getTopicName().getNamespaceObject());\n-                reader.closeAsync();\n+                cleanCacheAndCloseReader(reader.getSystemTopic().getTopicName().getNamespaceObject(), false);\n                 return;\n             }\n             if (hasMore) {\n@@ -342,9 +333,7 @@ private void initPolicesCache(SystemTopicClient.Reader<PulsarEvent> reader, Comp\n                         log.error(\"[{}] Failed to read event from the system topic.\",\n                                 reader.getSystemTopic().getTopicName(), e);\n                         future.completeExceptionally(e);\n-                        readerCaches.remove(reader.getSystemTopic().getTopicName().getNamespaceObject());\n-                        policyCacheInitMap.remove(reader.getSystemTopic().getTopicName().getNamespaceObject());\n-                        reader.closeAsync();\n+                        cleanCacheAndCloseReader(reader.getSystemTopic().getTopicName().getNamespaceObject(), false);\n                         return;\n                     }\n                     refreshTopicPoliciesCache(msg);\n@@ -373,6 +362,18 @@ private void initPolicesCache(SystemTopicClient.Reader<PulsarEvent> reader, Comp\n         });\n     }\n \n+    private void cleanCacheAndCloseReader(NamespaceName namespace, boolean cleanOwnedBundlesCount) {\n+        CompletableFuture<SystemTopicClient.Reader<PulsarEvent>> readerFuture = readerCaches.remove(namespace);\n+        policiesCache.entrySet().removeIf(entry -> Objects.equals(entry.getKey().getNamespaceObject(), namespace));\n+        if (cleanOwnedBundlesCount) {\n+            ownedBundlesCountPerNamespace.remove(namespace);\n+        }\n+        if (readerFuture != null && !readerFuture.isCompletedExceptionally()) {\n+            readerFuture.thenAccept(SystemTopicClient.Reader::closeAsync);\n+        }\n+        policyCacheInitMap.remove(namespace);\n+    }\n+\n     private void readMorePolicies(SystemTopicClient.Reader<PulsarEvent> reader) {\n         reader.readNextAsync().whenComplete((msg, ex) -> {\n             if (ex == null) {\n@@ -382,10 +383,10 @@ private void readMorePolicies(SystemTopicClient.Reader<PulsarEvent> reader) {\n             } else {\n                 if (ex instanceof PulsarClientException.AlreadyClosedException) {\n                     log.error(\"Read more topic policies exception, close the read now!\", ex);\n-                    NamespaceName namespace = reader.getSystemTopic().getTopicName().getNamespaceObject();\n-                    ownedBundlesCountPerNamespace.remove(namespace);\n-                    readerCaches.remove(namespace);\n+                    cleanCacheAndCloseReader(\n+                            reader.getSystemTopic().getTopicName().getNamespaceObject(), false);\n                 } else {\n+                    log.warn(\"Read more topic polices exception, read again.\", ex);\n                     readMorePolicies(reader);\n                 }\n             }",
      "parent_sha": "d4c2e613d305f8f785b5ef357b7cbe2ccc271043"
    }
  },
  {
    "oid": "18dc1c87f3217766453600ba849e82625ee73086",
    "message": "Fix: deadlock while closing non-persistent topic (#1660)",
    "date": "2018-04-27T18:29:37Z",
    "url": "https://github.com/apache/pulsar/commit/18dc1c87f3217766453600ba849e82625ee73086",
    "details": {
      "sha": "1cc940386310a874c79204e6f8d436f82b9c1e58",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/nonpersistent/NonPersistentTopic.java",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/apache/pulsar/blob/18dc1c87f3217766453600ba849e82625ee73086/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2Fnonpersistent%2FNonPersistentTopic.java",
      "raw_url": "https://github.com/apache/pulsar/raw/18dc1c87f3217766453600ba849e82625ee73086/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2Fnonpersistent%2FNonPersistentTopic.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2Fnonpersistent%2FNonPersistentTopic.java?ref=18dc1c87f3217766453600ba849e82625ee73086",
      "patch": "@@ -489,8 +489,12 @@ public CompletableFuture<Void> close() {\n \n         FutureUtil.waitForAll(futures).thenRun(() -> {\n             log.info(\"[{}] Topic closed\", topic);\n-            brokerService.pulsar().getExecutor().execute(() -> brokerService.removeTopicFromCache(topic));\n-            closeFuture.complete(null);\n+            // unload topic iterates over topics map and removing from the map with the same thread creates deadlock.\n+            // so, execute it in different thread\n+            brokerService.executor().execute(() -> {\n+                brokerService.removeTopicFromCache(topic);\n+                closeFuture.complete(null);\n+            });\n         }).exceptionally(exception -> {\n             log.error(\"[{}] Error closing topic\", topic, exception);\n             isFenced = false;",
      "parent_sha": "f307080e9558bf34edfffbecf9bdcdbe08fa7427"
    }
  },
  {
    "oid": "7a24136cedf28559acf0e2b08eed594c4f3264eb",
    "message": "Remove redundant parameter totalMessages (#4583)\n\nRemove redundant parameter ```totalMessages``` for publish method.",
    "date": "2019-06-29T15:19:03Z",
    "url": "https://github.com/apache/pulsar/commit/7a24136cedf28559acf0e2b08eed594c4f3264eb",
    "details": {
      "sha": "006be6c5ccc4d730963462dc43f886ab1e4a6212",
      "filename": "pulsar-client-tools/src/main/java/org/apache/pulsar/client/cli/CmdProduce.java",
      "status": "modified",
      "additions": 4,
      "deletions": 7,
      "changes": 11,
      "blob_url": "https://github.com/apache/pulsar/blob/7a24136cedf28559acf0e2b08eed594c4f3264eb/pulsar-client-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fcli%2FCmdProduce.java",
      "raw_url": "https://github.com/apache/pulsar/raw/7a24136cedf28559acf0e2b08eed594c4f3264eb/pulsar-client-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fcli%2FCmdProduce.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-client-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fcli%2FCmdProduce.java?ref=7a24136cedf28559acf0e2b08eed594c4f3264eb",
      "patch": "@@ -24,8 +24,6 @@\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.google.common.collect.Lists;\n import com.google.common.util.concurrent.RateLimiter;\n-import com.google.gson.Gson;\n-import com.google.gson.JsonObject;\n import com.google.gson.JsonParseException;\n \n import java.net.URI;\n@@ -37,7 +35,6 @@\n import java.util.Map;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n \n import org.apache.commons.lang3.StringUtils;\n@@ -164,13 +161,13 @@ public int run() throws PulsarClientException {\n         String topic = this.mainOptions.get(0);\n \n         if (this.serviceURL.startsWith(\"ws\")) {\n-            return publishToWebSocket(totalMessages, topic);\n+            return publishToWebSocket(topic);\n         } else {\n-            return publish(totalMessages, topic);\n+            return publish(topic);\n         }\n     }\n \n-    private int publish(int totalMessages, String topic) {\n+    private int publish(String topic) {\n         int numMessagesSent = 0;\n         int returnCode = 0;\n \n@@ -203,7 +200,7 @@ private int publish(int totalMessages, String topic) {\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private int publishToWebSocket(int totalMessages, String topic) {\n+    private int publishToWebSocket(String topic) {\n         int numMessagesSent = 0;\n         int returnCode = 0;\n ",
      "parent_sha": "5de6e6ba9b566754f099fd1bd96809ed75ac1543"
    }
  },
  {
    "oid": "416e7e5d110c35cbd51f7b082b70e944244a4938",
    "message": "Avoid call sync method in async rest API for force delete subscription  (#13668)",
    "date": "2022-01-12T16:21:29Z",
    "url": "https://github.com/apache/pulsar/commit/416e7e5d110c35cbd51f7b082b70e944244a4938",
    "details": {
      "sha": "37d5bcb083b3eae31a3426c75f9d55b94bdfc06c",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java",
      "status": "modified",
      "additions": 28,
      "deletions": 27,
      "changes": 55,
      "blob_url": "https://github.com/apache/pulsar/blob/416e7e5d110c35cbd51f7b082b70e944244a4938/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2Fimpl%2FPersistentTopicsBase.java",
      "raw_url": "https://github.com/apache/pulsar/raw/416e7e5d110c35cbd51f7b082b70e944244a4938/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2Fimpl%2FPersistentTopicsBase.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2Fimpl%2FPersistentTopicsBase.java?ref=416e7e5d110c35cbd51f7b082b70e944244a4938",
      "patch": "@@ -1605,33 +1605,34 @@ protected void internalDeleteSubscriptionForcefully(AsyncResponse asyncResponse,\n \n     private void internalDeleteSubscriptionForNonPartitionedTopicForcefully(AsyncResponse asyncResponse,\n                                                                             String subName, boolean authoritative) {\n-        try {\n-            validateTopicOwnership(topicName, authoritative);\n-            validateTopicOperation(topicName, TopicOperation.UNSUBSCRIBE);\n-\n-            Topic topic = getTopicReference(topicName);\n-            Subscription sub = topic.getSubscription(subName);\n-            if (sub == null) {\n-                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n-                return;\n-            }\n-            sub.deleteForcefully().get();\n-            log.info(\"[{}][{}] Deleted subscription forcefully {}\", clientAppId(), topicName, subName);\n-            asyncResponse.resume(Response.noContent().build());\n-        } catch (Exception e) {\n-            if (e instanceof WebApplicationException) {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"[{}] Failed to delete subscription forcefully from topic {},\"\n-                                    + \" redirecting to other brokers.\",\n-                            clientAppId(), topicName, e);\n-                }\n-                asyncResponse.resume(e);\n-            } else {\n-                log.error(\"[{}] Failed to delete subscription forcefully {} {}\",\n-                        clientAppId(), topicName, subName, e);\n-                asyncResponse.resume(new RestException(e));\n-            }\n-        }\n+        validateTopicOwnershipAsync(topicName, authoritative)\n+                .thenRun(() -> validateTopicOperation(topicName, TopicOperation.UNSUBSCRIBE))\n+                .thenCompose(__ -> {\n+                    Topic topic = getTopicReference(topicName);\n+                    Subscription sub = topic.getSubscription(subName);\n+                    if (sub == null) {\n+                        throw new RestException(Status.NOT_FOUND, \"Subscription not found\");\n+                    }\n+                    return sub.deleteForcefully();\n+                }).thenRun(() -> {\n+                    log.info(\"[{}][{}] Deleted subscription forcefully {}\", clientAppId(), topicName, subName);\n+                    asyncResponse.resume(Response.noContent().build());\n+                }).exceptionally(e -> {\n+                    Throwable cause = e.getCause();\n+                    if (cause instanceof WebApplicationException) {\n+                        if (log.isDebugEnabled() && ((WebApplicationException) cause).getResponse().getStatus()\n+                                == Status.TEMPORARY_REDIRECT.getStatusCode()) {\n+                            log.debug(\"[{}] Failed to delete subscription from topic {}, redirecting to other brokers.\",\n+                                    clientAppId(), topicName, cause);\n+                        }\n+                        asyncResponse.resume(cause);\n+                    } else {\n+                        log.error(\"[{}] Failed to delete subscription forcefully {} {}\",\n+                                clientAppId(), topicName, subName, cause);\n+                        asyncResponse.resume(new RestException(cause));\n+                    }\n+                    return null;\n+                });\n     }\n \n     protected void internalSkipAllMessages(AsyncResponse asyncResponse, String subName, boolean authoritative) {",
      "parent_sha": "e5d828ac92f8102fc3c70d122b1270110757c591"
    }
  },
  {
    "oid": "86438dbdeef7605528120dcfe83e5fd60b16efd0",
    "message": "Remove the exception which will never be thrown (#3942)",
    "date": "2019-03-29T23:57:22Z",
    "url": "https://github.com/apache/pulsar/commit/86438dbdeef7605528120dcfe83e5fd60b16efd0",
    "details": {
      "sha": "dabfcbde2cb23fc889e7d0b50fe3a60df3cfa060",
      "filename": "pulsar-client-tools/src/main/java/org/apache/pulsar/client/cli/PulsarClientTool.java",
      "status": "modified",
      "additions": 2,
      "deletions": 7,
      "changes": 9,
      "blob_url": "https://github.com/apache/pulsar/blob/86438dbdeef7605528120dcfe83e5fd60b16efd0/pulsar-client-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fcli%2FPulsarClientTool.java",
      "raw_url": "https://github.com/apache/pulsar/raw/86438dbdeef7605528120dcfe83e5fd60b16efd0/pulsar-client-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fcli%2FPulsarClientTool.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-client-tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fcli%2FPulsarClientTool.java?ref=86438dbdeef7605528120dcfe83e5fd60b16efd0",
      "patch": "@@ -22,7 +22,6 @@\n import static org.apache.commons.lang3.StringUtils.isNotBlank;\n \n import java.io.FileInputStream;\n-import java.net.MalformedURLException;\n import java.util.Arrays;\n import java.util.Properties;\n \n@@ -65,7 +64,7 @@ public class PulsarClientTool {\n     CmdProduce produceCommand;\n     CmdConsume consumeCommand;\n \n-    public PulsarClientTool(Properties properties) throws MalformedURLException {\n+    public PulsarClientTool(Properties properties) {\n         this.serviceURL = StringUtils.isNotBlank(properties.getProperty(\"brokerServiceUrl\"))\n                 ? properties.getProperty(\"brokerServiceUrl\") : properties.getProperty(\"webServiceUrl\");\n         // fallback to previous-version serviceUrl property to maintain backward-compatibility\n@@ -90,7 +89,7 @@ public PulsarClientTool(Properties properties) throws MalformedURLException {\n         commandParser.addCommand(\"consume\", consumeCommand);\n     }\n \n-    private void updateConfig() throws UnsupportedAuthenticationException, MalformedURLException {\n+    private void updateConfig() throws UnsupportedAuthenticationException {\n         ClientBuilder clientBuilder = PulsarClient.builder();\n         Authentication authentication = null;\n         if (isNotBlank(this.authPluginClassName)) {\n@@ -121,10 +120,6 @@ public int run(String[] args) {\n             try {\n                 this.updateConfig(); // If the --url, --auth-plugin, or --auth-params parameter are not specified,\n                                      // it will default to the values passed in by the constructor\n-            } catch (MalformedURLException mue) {\n-                System.out.println(\"Unable to parse URL \" + this.serviceURL);\n-                commandParser.usage();\n-                return -1;\n             } catch (UnsupportedAuthenticationException exp) {\n                 System.out.println(\"Failed to load an authentication plugin\");\n                 commandParser.usage();",
      "parent_sha": "50fb65d8075f78f4a295f4192d75007cfcea830c"
    }
  },
  {
    "oid": "1a80429c8ba12f0ce487d6fecbce62c3ca952e1a",
    "message": "fix flaky test in AdminApiOffloadTest (#11028)",
    "date": "2021-06-23T15:09:06Z",
    "url": "https://github.com/apache/pulsar/commit/1a80429c8ba12f0ce487d6fecbce62c3ca952e1a",
    "details": {
      "sha": "d85b6106f95ae533518f24bc4f6ca6cbf2804164",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/AdminApiOffloadTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/apache/pulsar/blob/1a80429c8ba12f0ce487d6fecbce62c3ca952e1a/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2FAdminApiOffloadTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/1a80429c8ba12f0ce487d6fecbce62c3ca952e1a/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2FAdminApiOffloadTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2FAdminApiOffloadTest.java?ref=1a80429c8ba12f0ce487d6fecbce62c3ca952e1a",
      "patch": "@@ -47,7 +47,6 @@\n import org.apache.pulsar.common.naming.NamespaceName;\n import org.apache.pulsar.common.naming.TopicName;\n import org.apache.pulsar.common.policies.data.ClusterData;\n-import org.apache.pulsar.common.policies.data.ClusterDataImpl;\n import org.apache.pulsar.common.policies.data.OffloadPolicies;\n import org.apache.pulsar.common.policies.data.OffloadPoliciesImpl;\n import org.apache.pulsar.common.policies.data.OffloadedReadPriority;\n@@ -335,6 +334,8 @@ private void testOffload(boolean isPartitioned) throws Exception {\n         Map<NamespaceName, LedgerOffloader> map = new HashMap<>();\n         map.put(TopicName.get(topicName).getNamespaceObject(), namespaceOffloader);\n         doReturn(map).when(pulsar).getLedgerOffloaderMap();\n+        doReturn(namespaceOffloader).when(pulsar)\n+                .getManagedLedgerOffloader(TopicName.get(topicName).getNamespaceObject(), null);\n \n         admin.topics().removeOffloadPolicies(topicName);\n         Awaitility.await().untilAsserted(()",
      "parent_sha": "cad0542471468820eb60725d1784677e55bd5834"
    }
  },
  {
    "oid": "4544f6eb3706e21c8953210c256eb22445a1a440",
    "message": "add function-name reference with function failure log (#2246)",
    "date": "2018-07-27T06:36:06Z",
    "url": "https://github.com/apache/pulsar/commit/4544f6eb3706e21c8953210c256eb22445a1a440",
    "details": {
      "sha": "6abb5fbfc078262a7442a8af8592e0ab74cd0f7a",
      "filename": "pulsar-functions/runtime/src/main/java/org/apache/pulsar/functions/runtime/RuntimeSpawner.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/apache/pulsar/blob/4544f6eb3706e21c8953210c256eb22445a1a440/pulsar-functions%2Fruntime%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Fruntime%2FRuntimeSpawner.java",
      "raw_url": "https://github.com/apache/pulsar/raw/4544f6eb3706e21c8953210c256eb22445a1a440/pulsar-functions%2Fruntime%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Fruntime%2FRuntimeSpawner.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-functions%2Fruntime%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Fruntime%2FRuntimeSpawner.java?ref=4544f6eb3706e21c8953210c256eb22445a1a440",
      "patch": "@@ -82,7 +82,9 @@ public void start() throws Exception {\n                 @Override\n                 public void run() {\n                     if (!runtime.isAlive()) {\n-                        log.error(\"Function Container is dead with exception\", runtime.getDeathException());\n+                        log.error(\"[{}-{}] Function Container is dead with exception\",\n+                                instanceConfig.getFunctionDetails().getName(), instanceConfig.getInstanceId(),\n+                                runtime.getDeathException());\n                         log.error(\"Restarting...\");\n                         // Just for the sake of sanity, just destroy the runtime\n                         runtime.stop();",
      "parent_sha": "831897763655dcd2fb0bdc3c6743d0ebef8b6490"
    }
  },
  {
    "oid": "8574e58642a06d8eedba33a4106b6b585cb5979b",
    "message": "Return correct authz and auth errors from proxy to client (#9055)\n\nCo-authored-by: Jerry Peng <jerryp@splunk.com>",
    "date": "2020-12-26T22:59:23Z",
    "url": "https://github.com/apache/pulsar/commit/8574e58642a06d8eedba33a4106b6b585cb5979b",
    "details": {
      "sha": "f2d7242e5f385feabd06fe8dcc8122c29fc35ace",
      "filename": "pulsar-proxy/src/main/java/org/apache/pulsar/proxy/server/LookupProxyHandler.java",
      "status": "modified",
      "additions": 15,
      "deletions": 2,
      "changes": 17,
      "blob_url": "https://github.com/apache/pulsar/blob/8574e58642a06d8eedba33a4106b6b585cb5979b/pulsar-proxy%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fproxy%2Fserver%2FLookupProxyHandler.java",
      "raw_url": "https://github.com/apache/pulsar/raw/8574e58642a06d8eedba33a4106b6b585cb5979b/pulsar-proxy%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fproxy%2Fserver%2FLookupProxyHandler.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-proxy%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fproxy%2Fserver%2FLookupProxyHandler.java?ref=8574e58642a06d8eedba33a4106b6b585cb5979b",
      "patch": "@@ -27,6 +27,7 @@\n import java.util.Optional;\n \n import org.apache.commons.lang3.StringUtils;\n+import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.common.protocol.Commands;\n import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetTopicsOfNamespace;\n import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetSchema;\n@@ -231,7 +232,7 @@ private void handlePartitionMetadataResponse(CommandPartitionedTopicMetadata par\n                         log.warn(\"[{}] Failed to get partitioned metadata for topic {} {}\", clientAddress, topicName,\n                                 ex.getMessage(), ex);\n                         proxyConnection.ctx().writeAndFlush(Commands.newPartitionMetadataResponse(\n-                                ServerError.ServiceNotReady, ex.getMessage(), clientRequestId));\n+                          getServerError(ex), ex.getMessage(), clientRequestId));\n                         return null;\n                     });\n         } else {\n@@ -259,7 +260,7 @@ private void handlePartitionMetadataResponse(CommandPartitionedTopicMetadata par\n                     if (t != null) {\n                         log.warn(\"[{}] failed to get Partitioned metadata : {}\", topicName.toString(),\n                             t.getMessage(), t);\n-                        proxyConnection.ctx().writeAndFlush(Commands.newLookupErrorResponse(ServerError.ServiceNotReady,\n+                        proxyConnection.ctx().writeAndFlush(Commands.newLookupErrorResponse(getServerError(t),\n                             t.getMessage(), clientRequestId));\n                     } else {\n                         proxyConnection.ctx().writeAndFlush(\n@@ -443,5 +444,17 @@ private InetSocketAddress getAddr(String brokerServiceUrl, long clientRequestId)\n         return InetSocketAddress.createUnresolved(brokerURI.getHost(), brokerURI.getPort());\n     }\n \n+    private ServerError getServerError(Throwable error) {\n+        ServerError responseError;\n+        if (error instanceof PulsarClientException.AuthorizationException) {\n+            responseError = ServerError.AuthorizationError;\n+        } else if (error instanceof PulsarClientException.AuthenticationException) {\n+            responseError = ServerError.AuthenticationError;\n+        } else {\n+            responseError = ServerError.ServiceNotReady;\n+        }\n+        return responseError;\n+    }\n+\n     private static final Logger log = LoggerFactory.getLogger(LookupProxyHandler.class);\n }",
      "parent_sha": "2c3e33be7d6f1e8beea4f6bf1382d03b91c4cb87"
    }
  },
  {
    "oid": "33d14813ea5d7616219d972afefabc261a7774ae",
    "message": "Support json format in AuthenticationAthenz's authParams (#793)",
    "date": "2017-10-07T17:34:51Z",
    "url": "https://github.com/apache/pulsar/commit/33d14813ea5d7616219d972afefabc261a7774ae",
    "details": {
      "sha": "6d352b257f89fbbd26117445352d6ca695a5584a",
      "filename": "pulsar-client-auth-athenz/src/main/java/org/apache/pulsar/client/impl/auth/AuthenticationAthenz.java",
      "status": "modified",
      "additions": 30,
      "deletions": 3,
      "changes": 33,
      "blob_url": "https://github.com/apache/pulsar/blob/33d14813ea5d7616219d972afefabc261a7774ae/pulsar-client-auth-athenz%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2Fauth%2FAuthenticationAthenz.java",
      "raw_url": "https://github.com/apache/pulsar/raw/33d14813ea5d7616219d972afefabc261a7774ae/pulsar-client-auth-athenz%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2Fauth%2FAuthenticationAthenz.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-client-auth-athenz%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2Fauth%2FAuthenticationAthenz.java?ref=33d14813ea5d7616219d972afefabc261a7774ae",
      "patch": "@@ -23,6 +23,7 @@\n import java.net.URI;\n import java.net.URISyntaxException;\n import java.util.Base64;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.TimeUnit;\n@@ -32,10 +33,15 @@\n \n import org.apache.pulsar.client.api.Authentication;\n import org.apache.pulsar.client.api.AuthenticationDataProvider;\n+import org.apache.pulsar.client.api.EncodedAuthenticationParameterSupport;\n import org.apache.pulsar.client.api.PulsarClientException;\n import org.apache.pulsar.client.api.PulsarClientException.GettingAuthenticationDataException;\n+import org.apache.pulsar.common.util.ObjectMapperFactory;\n \n import java.security.PrivateKey;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n import com.google.common.base.Splitter;\n \n import com.yahoo.athenz.zts.RoleToken;\n@@ -44,7 +50,7 @@\n import com.yahoo.athenz.auth.impl.SimpleServiceIdentityProvider;\n import com.yahoo.athenz.auth.util.Crypto;\n \n-public class AuthenticationAthenz implements Authentication {\n+public class AuthenticationAthenz implements Authentication, EncodedAuthenticationParameterSupport {\n \n     private transient ZTSClient ztsClient = null;\n     private String tenantDomain;\n@@ -91,8 +97,29 @@ private boolean cachedRoleTokenIsValid() {\n         return (System.nanoTime() - cachedRoleTokenTimestamp) < TimeUnit.HOURS.toNanos(cacheDurationInHour);\n     }\n \n+    @Override\n+    public void configure(String encodedAuthParamString) {\n+\n+        if (isBlank(encodedAuthParamString)) {\n+            throw new IllegalArgumentException(\"authParams must not be empty\");\n+        }\n+\n+        // Convert JSON to Map\n+        try {\n+            ObjectMapper jsonMapper = ObjectMapperFactory.create();\n+            Map<String, String> authParamsMap = jsonMapper.readValue(encodedAuthParamString, new TypeReference<HashMap<String, String>>() {});\n+            setAuthParams(authParamsMap);\n+        } catch (IOException e) {\n+            throw new IllegalArgumentException(\"Failed to parse authParams\");\n+        }\n+    }\n+\n     @Override\n     public void configure(Map<String, String> authParams) {\n+        setAuthParams(authParams);\n+    }\n+\n+    private void setAuthParams(Map<String, String> authParams){\n         this.tenantDomain = authParams.get(\"tenantDomain\");\n         this.tenantService = authParams.get(\"tenantService\");\n         this.providerDomain = authParams.get(\"providerDomain\");\n@@ -124,7 +151,7 @@ public void start() throws PulsarClientException {\n     public void close() throws IOException {\n     }\n \n-    ZTSClient getZtsClient() {\n+    private ZTSClient getZtsClient() {\n         if (ztsClient == null) {\n             ServiceIdentityProvider siaProvider = new SimpleServiceIdentityProvider(tenantDomain, tenantService,\n                     privateKey, keyId);\n@@ -133,7 +160,7 @@ ZTSClient getZtsClient() {\n         return ztsClient;\n     }\n \n-    PrivateKey loadPrivateKey(String privateKeyURL) {\n+    private PrivateKey loadPrivateKey(String privateKeyURL) {\n         PrivateKey privateKey = null;\n         try {\n             URI uri = new URI(privateKeyURL);",
      "parent_sha": "c65207eba8a470575f8fbe486330618053aa7b5e"
    }
  },
  {
    "oid": "f0aeb5acfb127c42d8f5dda65804617e69e77dd3",
    "message": "docs: remove unuseful info in docs generation (#17827)",
    "date": "2022-09-26T07:03:11Z",
    "url": "https://github.com/apache/pulsar/commit/f0aeb5acfb127c42d8f5dda65804617e69e77dd3",
    "details": {
      "sha": "99b2e7971855f39af4499337094856f28850c73e",
      "filename": "pulsar-broker-common/src/main/java/org/apache/pulsar/broker/BaseGenerateDocumentation.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/pulsar/blob/f0aeb5acfb127c42d8f5dda65804617e69e77dd3/pulsar-broker-common%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2FBaseGenerateDocumentation.java",
      "raw_url": "https://github.com/apache/pulsar/raw/f0aeb5acfb127c42d8f5dda65804617e69e77dd3/pulsar-broker-common%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2FBaseGenerateDocumentation.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker-common%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2FBaseGenerateDocumentation.java?ref=f0aeb5acfb127c42d8f5dda65804617e69e77dd3",
      "patch": "@@ -151,7 +151,7 @@ public int compare(Field o1, Field o2) {\n             !> This page is automatically generated from code files.\n             If you find something inaccurate, feel free to update `\"\"\";\n     protected String suffix = \"\"\"\n-            `. Do NOT edit this markdown file manually. Manual changes will be overwritten by automatic generation.\n+            `.\n             \"\"\";\n \n     protected String generateDocByFieldContext(String className, String type, StringBuilder sb) throws Exception {",
      "parent_sha": "5068800d1f235fe293adf21a8c6000b48a2a54ad"
    }
  },
  {
    "oid": "5bcdb5ef40a24fefad042efac484f2be4b92c527",
    "message": "Fix time unit error in errMsg when producer send fails. (#14299)",
    "date": "2022-02-15T16:07:23Z",
    "url": "https://github.com/apache/pulsar/commit/5bcdb5ef40a24fefad042efac484f2be4b92c527",
    "details": {
      "sha": "573e17a88f8f528646c4c08977b6c43ccfb40e2f",
      "filename": "pulsar-client/src/main/java/org/apache/pulsar/client/impl/ProducerImpl.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/apache/pulsar/blob/5bcdb5ef40a24fefad042efac484f2be4b92c527/pulsar-client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FProducerImpl.java",
      "raw_url": "https://github.com/apache/pulsar/raw/5bcdb5ef40a24fefad042efac484f2be4b92c527/pulsar-client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FProducerImpl.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FProducerImpl.java?ref=5bcdb5ef40a24fefad042efac484f2be4b92c527",
      "patch": "@@ -1336,7 +1336,8 @@ void sendComplete(final Exception e) {\n                     long sequenceId = te.getSequenceId();\n                     long ns = System.nanoTime();\n                     String errMsg = String.format(\n-                        \"%s : createdAt %s ns ago, firstSentAt %s ns ago, lastSentAt %s ns ago, retryCount %s\",\n+                        \"%s : createdAt %s seconds ago, firstSentAt %s seconds ago, lastSentAt %s seconds ago, \"\n+                                + \"retryCount %s\",\n                         te.getMessage(),\n                         RelativeTimeUtil.nsToSeconds(ns - this.createdAt),\n                         RelativeTimeUtil.nsToSeconds(this.firstSentAt <= 0",
      "parent_sha": "45ebe88ef2cc641145e39a7dba25efedc5810ab3"
    }
  },
  {
    "oid": "7da97557ff82cc034c8429e7d9e3836846311f86",
    "message": "Ignore \"javax.ws.*\" from PowerMockito (address rebase issue)",
    "date": "2018-03-04T00:44:14Z",
    "url": "https://github.com/apache/pulsar/commit/7da97557ff82cc034c8429e7d9e3836846311f86",
    "details": {
      "sha": "3a99cb1438397bad47b4fb036f6075bd2a0edbf4",
      "filename": "pulsar-functions/worker/src/test/java/org/apache/pulsar/functions/worker/rest/api/v1/ApiV1ResourceTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/pulsar/blob/7da97557ff82cc034c8429e7d9e3836846311f86/pulsar-functions%2Fworker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Fworker%2Frest%2Fapi%2Fv1%2FApiV1ResourceTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/7da97557ff82cc034c8429e7d9e3836846311f86/pulsar-functions%2Fworker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Fworker%2Frest%2Fapi%2Fv1%2FApiV1ResourceTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-functions%2Fworker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Fworker%2Frest%2Fapi%2Fv1%2FApiV1ResourceTest.java?ref=7da97557ff82cc034c8429e7d9e3836846311f86",
      "patch": "@@ -69,7 +69,7 @@\n  * Unit test of {@link ApiV1Resource}.\n  */\n @PrepareForTest(Utils.class)\n-@PowerMockIgnore(\"javax.management.*\")\n+@PowerMockIgnore({ \"javax.management.*\", \"javax.ws.*\" })\n public class ApiV1ResourceTest {\n \n     @ObjectFactory",
      "parent_sha": "914179c564f7b5bad027cfa99563633a79b1618f"
    }
  },
  {
    "oid": "87b1dd6d10b1ce7daf12050168ce4c27ec0ff75a",
    "message": "[improve][ml] Use correct isActive method for cursor (#19322)",
    "date": "2023-01-26T09:31:44Z",
    "url": "https://github.com/apache/pulsar/commit/87b1dd6d10b1ce7daf12050168ce4c27ec0ff75a",
    "details": {
      "sha": "3120663f21a72978bb6ba9933355f1fab793646e",
      "filename": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedLedgerImpl.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/pulsar/blob/87b1dd6d10b1ce7daf12050168ce4c27ec0ff75a/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedLedgerImpl.java",
      "raw_url": "https://github.com/apache/pulsar/raw/87b1dd6d10b1ce7daf12050168ce4c27ec0ff75a/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedLedgerImpl.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedLedgerImpl.java?ref=87b1dd6d10b1ce7daf12050168ce4c27ec0ff75a",
      "patch": "@@ -3662,7 +3662,7 @@ Pair<PositionImpl, Long> getFirstPositionAndCounter() {\n \n     public void activateCursor(ManagedCursor cursor) {\n         synchronized (activeCursors) {\n-            if (!cursor.isActive()) {\n+            if (!isCursorActive(cursor)) {\n                 Position positionForOrdering = config.isCacheEvictionByMarkDeletedPosition()\n                         ? cursor.getMarkDeletedPosition()\n                         : cursor.getReadPosition();",
      "parent_sha": "6112b6501e32b9d46612ebbc7a18482661894053"
    }
  },
  {
    "oid": "b421e631ddc4c3c879faab201ba0fb30bb55304e",
    "message": "Don't format bookkeeper if /ledgers exist (#1588)\n\nIf you want to run pulsar on a preexisting bookkeeper installation,\r\nthere's currently no way to format the metadata.\r\n\r\nThis patch skips the bookkeeper initialization if /ledgers already\r\nexists, which indicates that it has already been formatted.",
    "date": "2018-04-16T21:59:42Z",
    "url": "https://github.com/apache/pulsar/commit/b421e631ddc4c3c879faab201ba0fb30bb55304e",
    "details": {
      "sha": "31bbdb7d224fa1680492320fe73acdae61ee4866",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/PulsarClusterMetadataSetup.java",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/apache/pulsar/blob/b421e631ddc4c3c879faab201ba0fb30bb55304e/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2FPulsarClusterMetadataSetup.java",
      "raw_url": "https://github.com/apache/pulsar/raw/b421e631ddc4c3c879faab201ba0fb30bb55304e/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2FPulsarClusterMetadataSetup.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2FPulsarClusterMetadataSetup.java?ref=b421e631ddc4c3c879faab201ba0fb30bb55304e",
      "patch": "@@ -102,18 +102,19 @@ public static void main(String[] args) throws Exception {\n         log.info(\"Setting up cluster {} with zk={} global-zk={}\", arguments.cluster, arguments.zookeeper,\n                 arguments.globalZookeeper);\n \n+        ZooKeeperClientFactory zkfactory = new ZookeeperClientFactoryImpl();\n+        ZooKeeper localZk = zkfactory.create(arguments.zookeeper, SessionType.ReadWrite, 30000).get();\n+        ZooKeeper globalZk = zkfactory.create(arguments.globalZookeeper, SessionType.ReadWrite, 30000).get();\n+\n         // Format BookKeeper metadata\n         ServerConfiguration bkConf = new ServerConfiguration();\n         bkConf.setLedgerManagerFactoryClass(HierarchicalLedgerManagerFactory.class);\n         bkConf.setZkServers(arguments.zookeeper);\n-        if (!BookKeeperAdmin.format(bkConf, false /* interactive */, false /* force */)) {\n+        if (localZk.exists(\"/ledgers\", false) == null // only format if /ledgers doesn't exist\n+                && !BookKeeperAdmin.format(bkConf, false /* interactive */, false /* force */)) {\n             throw new IOException(\"Failed to initialize BookKeeper metadata\");\n         }\n \n-        ZooKeeperClientFactory zkfactory = new ZookeeperClientFactoryImpl();\n-        ZooKeeper localZk = zkfactory.create(arguments.zookeeper, SessionType.ReadWrite, 30000).get();\n-        ZooKeeper globalZk = zkfactory.create(arguments.globalZookeeper, SessionType.ReadWrite, 30000).get();\n-\n         localZk.create(\"/managed-ledgers\", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n         localZk.create(\"/namespace\", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n ",
      "parent_sha": "9d19a0ea112d192621d464e708910e2587705bd0"
    }
  },
  {
    "oid": "96fb7dab7a1bc260d8ee3c9d5df15de6863ee15b",
    "message": "[improve][broker] Added isActive in ManagedCursorImpl (#19341)",
    "date": "2023-01-28T16:37:13Z",
    "url": "https://github.com/apache/pulsar/commit/96fb7dab7a1bc260d8ee3c9d5df15de6863ee15b",
    "details": {
      "sha": "34cd26274ffa03b539a8e0e44729cfb498b85713",
      "filename": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java",
      "status": "modified",
      "additions": 10,
      "deletions": 3,
      "changes": 13,
      "blob_url": "https://github.com/apache/pulsar/blob/96fb7dab7a1bc260d8ee3c9d5df15de6863ee15b/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedCursorImpl.java",
      "raw_url": "https://github.com/apache/pulsar/raw/96fb7dab7a1bc260d8ee3c9d5df15de6863ee15b/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedCursorImpl.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedCursorImpl.java?ref=96fb7dab7a1bc260d8ee3c9d5df15de6863ee15b",
      "patch": "@@ -218,6 +218,9 @@ public class ManagedCursorImpl implements ManagedCursor {\n     private static final String COMPACTION_CURSOR_NAME = \"__compaction\";\n     private volatile boolean cacheReadEntry = false;\n \n+    // active state cache in ManagedCursor. It should be in sync with the state in activeCursors in ManagedLedger.\n+    private volatile boolean isActive = false;\n+\n     class MarkDeleteEntry {\n         final PositionImpl newPosition;\n         final MarkDeleteCallback callback;\n@@ -1208,19 +1211,23 @@ public void asyncFindNewestMatching(FindPositionConstraint constraint, Predicate\n \n     @Override\n     public void setActive() {\n-        if (!alwaysInactive) {\n+        if (!isActive && !alwaysInactive) {\n             ledger.activateCursor(this);\n+            isActive = true;\n         }\n     }\n \n     @Override\n     public boolean isActive() {\n-        return ledger.isCursorActive(this);\n+        return isActive;\n     }\n \n     @Override\n     public void setInactive() {\n-        ledger.deactivateCursor(this);\n+        if (isActive) {\n+            ledger.deactivateCursor(this);\n+            isActive = false;\n+        }\n     }\n \n     @Override",
      "parent_sha": "ad8d2dfc261b54551d657092165a5b6803b6f4d4"
    }
  },
  {
    "oid": "1bf41aafacc9630f4284ec783ad9993d8b034265",
    "message": "[doc] fix java client javadoc typo (#14649)",
    "date": "2022-03-14T06:33:44Z",
    "url": "https://github.com/apache/pulsar/commit/1bf41aafacc9630f4284ec783ad9993d8b034265",
    "details": {
      "sha": "079a42c63b35702e595229653d1e5f7396b893f3",
      "filename": "pulsar-client-api/src/main/java/org/apache/pulsar/client/api/Message.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/apache/pulsar/blob/1bf41aafacc9630f4284ec783ad9993d8b034265/pulsar-client-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fapi%2FMessage.java",
      "raw_url": "https://github.com/apache/pulsar/raw/1bf41aafacc9630f4284ec783ad9993d8b034265/pulsar-client-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fapi%2FMessage.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-client-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fapi%2FMessage.java?ref=1bf41aafacc9630f4284ec783ad9993d8b034265",
      "patch": "@@ -264,10 +264,10 @@ default Optional<Schema<?>> getReaderSchema() {\n     Optional<Long> getBrokerPublishTime();\n \n     /**\n-     * Check whether the message has a index.\n+     * Check whether the message has an index.\n      *\n      * @since 2.9.0\n-     * @return true if the message has a index, otherwise false.\n+     * @return true if the message has an index, otherwise false.\n      */\n     boolean hasIndex();\n ",
      "parent_sha": "ad2cc2d38280b7dd0f056ee981ec8d3b157e3526"
    }
  },
  {
    "oid": "f916e2cc4df5ce02996981be02c4346725135fe7",
    "message": "support lazy init BaseMetadataStoreTest#etcdCluster (#14167)",
    "date": "2022-02-08T18:40:53Z",
    "url": "https://github.com/apache/pulsar/commit/f916e2cc4df5ce02996981be02c4346725135fe7",
    "details": {
      "sha": "8dd2c0176502fb855d44910cd408c02ef0a9c9b5",
      "filename": "pulsar-metadata/src/test/java/org/apache/pulsar/metadata/BaseMetadataStoreTest.java",
      "status": "modified",
      "additions": 14,
      "deletions": 8,
      "changes": 22,
      "blob_url": "https://github.com/apache/pulsar/blob/f916e2cc4df5ce02996981be02c4346725135fe7/pulsar-metadata%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fmetadata%2FBaseMetadataStoreTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/f916e2cc4df5ce02996981be02c4346725135fe7/pulsar-metadata%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fmetadata%2FBaseMetadataStoreTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-metadata%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fmetadata%2FBaseMetadataStoreTest.java?ref=f916e2cc4df5ce02996981be02c4346725135fe7",
      "patch": "@@ -22,6 +22,7 @@\n import io.etcd.jetcd.launcher.EtcdCluster;\n import io.etcd.jetcd.launcher.EtcdClusterFactory;\n import java.io.File;\n+import java.net.URI;\n import java.util.UUID;\n import java.util.concurrent.CompletionException;\n import java.util.function.Supplier;\n@@ -41,9 +42,6 @@ public abstract class BaseMetadataStoreTest extends TestRetrySupport {\n     public final void setup() throws Exception {\n         incrementSetupNumber();\n         zks = new TestZKServer();\n-\n-        etcdCluster = EtcdClusterFactory.buildCluster(\"test\", 1, false);\n-        etcdCluster.start();\n     }\n \n     @AfterClass(alwaysRun = true)\n@@ -57,6 +55,7 @@ public final void cleanup() throws Exception {\n \n         if (etcdCluster != null) {\n             etcdCluster.close();\n+            etcdCluster = null;\n         }\n     }\n \n@@ -74,14 +73,21 @@ public Object[][] implementations() {\n         // The new connection string won't be available to the test method unless a\n         // Supplier<String> lambda is used for providing the value.\n         return new Object[][]{\n-                { \"ZooKeeper\", stringSupplier(() -> zks.getConnectionString()) },\n-                { \"Memory\", stringSupplier(() -> \"memory:\" + UUID.randomUUID()) },\n-                { \"RocksDB\", stringSupplier(() -> \"rocksdb:\" + createTempFolder()) },\n-                {\"Etcd\", stringSupplier(() -> \"etcd:\" + etcdCluster.getClientEndpoints().stream().map(x -> x.toString())\n-                        .collect(Collectors.joining(\",\")))},\n+                {\"ZooKeeper\", stringSupplier(() -> zks.getConnectionString())},\n+                {\"Memory\", stringSupplier(() -> \"memory:\" + UUID.randomUUID())},\n+                {\"RocksDB\", stringSupplier(() -> \"rocksdb:\" + createTempFolder())},\n+                {\"Etcd\", stringSupplier(() -> \"etcd:\" + getEtcdClusterConnectString())},\n         };\n     }\n \n+    private synchronized String getEtcdClusterConnectString() {\n+        if (etcdCluster == null) {\n+            etcdCluster = EtcdClusterFactory.buildCluster(\"test\", 1, false);\n+            etcdCluster.start();\n+        }\n+        return etcdCluster.getClientEndpoints().stream().map(URI::toString).collect(Collectors.joining(\",\"));\n+    }\n+\n     public static Supplier<String> stringSupplier(Supplier<String> supplier) {\n         return supplier;\n     }",
      "parent_sha": "605070b0d24d98d313c800e0a27d51253eb535b5"
    }
  },
  {
    "oid": "b50e0eba8387ca0a3c5b7f7cd05f20e48c6c6f45",
    "message": "improve data-generator source performance (#4058)\n\n### Motivation\r\n\r\nOnly initialize factory once in the beginning",
    "date": "2019-04-18T05:31:54Z",
    "url": "https://github.com/apache/pulsar/commit/b50e0eba8387ca0a3c5b7f7cd05f20e48c6c6f45",
    "details": {
      "sha": "118025adbf7ddc504ac3970850c528e351b19d5f",
      "filename": "pulsar-io/data-generator/src/main/java/org/apache/pulsar/io/datagenerator/DataGeneratorSource.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/apache/pulsar/blob/b50e0eba8387ca0a3c5b7f7cd05f20e48c6c6f45/pulsar-io%2Fdata-generator%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fio%2Fdatagenerator%2FDataGeneratorSource.java",
      "raw_url": "https://github.com/apache/pulsar/raw/b50e0eba8387ca0a3c5b7f7cd05f20e48c6c6f45/pulsar-io%2Fdata-generator%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fio%2Fdatagenerator%2FDataGeneratorSource.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-io%2Fdata-generator%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fio%2Fdatagenerator%2FDataGeneratorSource.java?ref=b50e0eba8387ca0a3c5b7f7cd05f20e48c6c6f45",
      "patch": "@@ -29,9 +29,11 @@\n \n public class DataGeneratorSource implements Source<Person> {\n \n+    private Fairy fairy;\n+\n     @Override\n     public void open(Map<String, Object> config, SourceContext sourceContext) throws Exception {\n-\n+       this.fairy = Fairy.create();\n     }\n \n     @Override\n@@ -45,7 +47,7 @@ public Optional<String> getKey() {\n \n             @Override\n             public Person getValue() {\n-                return new Person(Fairy.create().person());\n+                return new Person(fairy.person());\n             }\n         };\n     }",
      "parent_sha": "d25dc2f764fb8243436e1d0bbec9b0a413258f3a"
    }
  },
  {
    "oid": "9394ed4263520b66093aa8c7f3a94c32349f399b",
    "message": "Clear redundant code (#11071)",
    "date": "2021-07-01T01:03:57Z",
    "url": "https://github.com/apache/pulsar/commit/9394ed4263520b66093aa8c7f3a94c32349f399b",
    "details": {
      "sha": "1e5061831bcd0abfd891ec498e7320edb1bffbf4",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/BrokerService.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/pulsar/blob/9394ed4263520b66093aa8c7f3a94c32349f399b/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FBrokerService.java",
      "raw_url": "https://github.com/apache/pulsar/raw/9394ed4263520b66093aa8c7f3a94c32349f399b/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FBrokerService.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FBrokerService.java?ref=9394ed4263520b66093aa8c7f3a94c32349f399b",
      "patch": "@@ -1053,7 +1053,7 @@ public PulsarClient getReplicationClient(String cluster) {\n                     log.info(\"Configuring proxy-url {} with protocol {}\", data.getProxyServiceUrl(),\n                             data.getProxyProtocol());\n                 }\n-                if (data.getListenerName() != null && StringUtils.isNotBlank(data.getListenerName())) {\n+                if (StringUtils.isNotBlank(data.getListenerName())) {\n                     clientBuilder.listenerName(data.getListenerName());\n                     log.info(\"Configuring listenerName {}\", data.getListenerName());\n                 }",
      "parent_sha": "cedf441e46513f2cf92febd2c6a6dea4b4ea854c"
    }
  },
  {
    "oid": "f609eb69d8ba238a372049ec8eb505ded729ae29",
    "message": "Fix flaky ReplicatorTest.testUpdateGlobalTopicPartition (#7075)",
    "date": "2020-05-28T20:27:05Z",
    "url": "https://github.com/apache/pulsar/commit/f609eb69d8ba238a372049ec8eb505ded729ae29",
    "details": {
      "sha": "ee71dc23b0782353c09047df586b62c43cf6390f",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/ReplicatorTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/pulsar/blob/f609eb69d8ba238a372049ec8eb505ded729ae29/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FReplicatorTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/f609eb69d8ba238a372049ec8eb505ded729ae29/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FReplicatorTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FReplicatorTest.java?ref=f609eb69d8ba238a372049ec8eb505ded729ae29",
      "patch": "@@ -868,7 +868,7 @@ public void testUpdateGlobalTopicPartition() throws Exception {\n \n         final String cluster1 = pulsar1.getConfig().getClusterName();\n         final String cluster2 = pulsar2.getConfig().getClusterName();\n-        final String namespace = \"pulsar/global/ns3\";\n+        final String namespace = \"pulsar/ns-\" + System.nanoTime();\n         final String topicName = \"persistent://\" + namespace + \"/topic1\";\n         int startPartitions = 4;\n         int newPartitions = 8;",
      "parent_sha": "9b50aac5586d325bb1af4229778486e23283dc75"
    }
  },
  {
    "oid": "47fd1a3e414982555d55ca92e669fc63d3095636",
    "message": "[improve][test] Restart broker in SimpleProducerConsumerTest if ns deletion times out (#22734)",
    "date": "2024-05-20T13:21:31Z",
    "url": "https://github.com/apache/pulsar/commit/47fd1a3e414982555d55ca92e669fc63d3095636",
    "details": {
      "sha": "a9d97b7febdb71c81af7997a349a4f9db96a4c2e",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/client/api/SimpleProducerConsumerTest.java",
      "status": "modified",
      "additions": 22,
      "deletions": 15,
      "changes": 37,
      "blob_url": "https://github.com/apache/pulsar/blob/47fd1a3e414982555d55ca92e669fc63d3095636/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fapi%2FSimpleProducerConsumerTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/47fd1a3e414982555d55ca92e669fc63d3095636/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fapi%2FSimpleProducerConsumerTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fapi%2FSimpleProducerConsumerTest.java?ref=47fd1a3e414982555d55ca92e669fc63d3095636",
      "patch": "@@ -121,6 +121,7 @@\n import org.apache.pulsar.common.protocol.Commands;\n import org.apache.pulsar.common.schema.SchemaType;\n import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.tests.ThreadDumpUtil;\n import org.awaitility.Awaitility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -147,25 +148,31 @@ protected void setup() throws Exception {\n     }\n \n     @AfterMethod(alwaysRun = true)\n-    public void rest() throws Exception {\n-        pulsar.getConfiguration().setForceDeleteTenantAllowed(true);\n-        pulsar.getConfiguration().setForceDeleteNamespaceAllowed(true);\n+    public void cleanupAfterMethod() throws Exception {\n+        try {\n+            pulsar.getConfiguration().setForceDeleteTenantAllowed(true);\n+            pulsar.getConfiguration().setForceDeleteNamespaceAllowed(true);\n \n-        for (String tenant : admin.tenants().getTenants()) {\n-            for (String namespace : admin.namespaces().getNamespaces(tenant)) {\n-                deleteNamespaceWithRetry(namespace, true);\n+            for (String tenant : admin.tenants().getTenants()) {\n+                for (String namespace : admin.namespaces().getNamespaces(tenant)) {\n+                    deleteNamespaceWithRetry(namespace, true);\n+                }\n+                admin.tenants().deleteTenant(tenant, true);\n             }\n-            admin.tenants().deleteTenant(tenant, true);\n-        }\n-\n-        for (String cluster : admin.clusters().getClusters()) {\n-            admin.clusters().deleteCluster(cluster);\n-        }\n \n-        pulsar.getConfiguration().setForceDeleteTenantAllowed(false);\n-        pulsar.getConfiguration().setForceDeleteNamespaceAllowed(false);\n+            for (String cluster : admin.clusters().getClusters()) {\n+                admin.clusters().deleteCluster(cluster);\n+            }\n \n-        super.producerBaseSetup();\n+            pulsar.getConfiguration().setForceDeleteTenantAllowed(false);\n+            pulsar.getConfiguration().setForceDeleteNamespaceAllowed(false);\n+            super.producerBaseSetup();\n+        } catch (Exception | AssertionError e) {\n+            log.warn(\"Failed to clean up state. Restarting broker.\", e);\n+            log.warn(\"Thread dump:\\n{}\", ThreadDumpUtil.buildThreadDiagnosticString());\n+            cleanup();\n+            setup();\n+        }\n     }\n \n     @DataProvider",
      "parent_sha": "9c60134f5af7c3eef11c764f06869bacab6f2344"
    }
  },
  {
    "oid": "3831cd11d005cfa060f2bce0236798dfc688cdf9",
    "message": "[Tests] Reduce flakiness of BacklogQuotaManagerTest (#10572)\n\n- use Awaitility for checking PersistentTopicInternalStats",
    "date": "2021-05-13T18:52:02Z",
    "url": "https://github.com/apache/pulsar/commit/3831cd11d005cfa060f2bce0236798dfc688cdf9",
    "details": {
      "sha": "e73c437e81b49b80461f3a690a97b1ba6162a172",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/BacklogQuotaManagerTest.java",
      "status": "modified",
      "additions": 123,
      "deletions": 93,
      "changes": 216,
      "blob_url": "https://github.com/apache/pulsar/blob/3831cd11d005cfa060f2bce0236798dfc688cdf9/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FBacklogQuotaManagerTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/3831cd11d005cfa060f2bce0236798dfc688cdf9/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FBacklogQuotaManagerTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FBacklogQuotaManagerTest.java?ref=3831cd11d005cfa060f2bce0236798dfc688cdf9",
      "patch": "@@ -22,9 +22,18 @@\n import static org.testng.Assert.assertFalse;\n import static org.testng.Assert.assertTrue;\n import static org.testng.Assert.fail;\n-\n import com.beust.jcommander.internal.Maps;\n import com.google.common.collect.Sets;\n+import java.net.URL;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import lombok.Cleanup;\n import org.apache.pulsar.broker.PulsarService;\n import org.apache.pulsar.broker.ServiceConfiguration;\n@@ -42,20 +51,13 @@\n import org.apache.pulsar.common.policies.data.TenantInfo;\n import org.apache.pulsar.common.policies.data.TopicStats;\n import org.apache.pulsar.zookeeper.LocalBookkeeperEnsemble;\n+import org.awaitility.Awaitility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.testng.annotations.AfterMethod;\n import org.testng.annotations.BeforeMethod;\n import org.testng.annotations.Test;\n \n-import java.net.URL;\n-import java.util.Optional;\n-import java.util.UUID;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.CyclicBarrier;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n @Test(groups = \"broker\")\n public class BacklogQuotaManagerTest {\n     PulsarService pulsar;\n@@ -66,7 +68,7 @@ public class BacklogQuotaManagerTest {\n \n     LocalBookkeeperEnsemble bkEnsemble;\n \n-    private static final int TIME_TO_CHECK_BACKLOG_QUOTA = 5;\n+    private static final int TIME_TO_CHECK_BACKLOG_QUOTA = 3;\n     private static final int MAX_ENTRIES_PER_LEDGER = 5;\n \n     @BeforeMethod\n@@ -145,14 +147,14 @@ public void testBacklogQuotaWithReader() throws Exception {\n         assertEquals(admin.namespaces().getBacklogQuotaMap(\"prop/ns-quota\"),\n                 Maps.newHashMap());\n         admin.namespaces().setBacklogQuota(\"prop/ns-quota\",\n-          new BacklogQuota(10 * 1024, 5, BacklogQuota.RetentionPolicy.producer_exception));\n+          new BacklogQuota(10 * 1024, TIME_TO_CHECK_BACKLOG_QUOTA, BacklogQuota.RetentionPolicy.producer_exception));\n         try (PulsarClient client = PulsarClient.builder().serviceUrl(adminUrl.toString()).statsInterval(0, TimeUnit.SECONDS).build();) {\n             final String topic1 = \"persistent://prop/ns-quota/topic1\";\n             final int numMsgs = 20;\n \n             Reader<byte[]> reader = client.newReader().topic(topic1).receiverQueueSize(1).startMessageId(MessageId.latest).create();\n \n-            org.apache.pulsar.client.api.Producer<byte[]> producer = client.newProducer().topic(topic1).sendTimeout(2, TimeUnit.SECONDS).create();\n+            org.apache.pulsar.client.api.Producer<byte[]> producer = createProducer(client, topic1);\n \n             byte[] content = new byte[1024];\n             for (int i = 0; i < numMsgs; i++) {\n@@ -185,19 +187,21 @@ public void testBacklogQuotaWithReader() throws Exception {\n                 fail(\"Should not have gotten exception: \" + ce.getMessage());\n             }\n \n-            // make sure ledgers are trimmed\n-            PersistentTopicInternalStats internalStats =\n-              admin.topics().getInternalStats(topic1, false);\n-\n-            // check there is only one ledger left\n             // TODO in theory there shouldn't be any ledgers left if we are using readers.\n             //  However, trimming of ledgers are piggy packed onto ledger operations.\n             //  So if there isn't new data coming in, trimming never occurs.\n             //  We need to trigger trimming on a schedule to actually delete all remaining ledgers\n-            assertEquals(internalStats.ledgers.size(), 1);\n+            Awaitility.await().untilAsserted(() -> {\n+                // make sure ledgers are trimmed\n+                PersistentTopicInternalStats internalStats =\n+                        admin.topics().getInternalStats(topic1, false);\n+\n+                // check there is only one ledger left\n+                assertEquals(internalStats.ledgers.size(), 1);\n \n-            // check if its the expected ledger id given MAX_ENTRIES_PER_LEDGER\n-            assertEquals(internalStats.ledgers.get(0).ledgerId, (2 * numMsgs / MAX_ENTRIES_PER_LEDGER) - 1);\n+                // check if its the expected ledger id given MAX_ENTRIES_PER_LEDGER\n+                assertEquals(internalStats.ledgers.get(0).ledgerId, (2 * numMsgs / MAX_ENTRIES_PER_LEDGER) - 1);\n+            });\n \n             // check reader can still read with out error\n \n@@ -216,18 +220,18 @@ public void testTriggerBacklogQuotaSizeWithReader() throws Exception {\n         assertEquals(admin.namespaces().getBacklogQuotaMap(\"prop/ns-quota\"),\n                 Maps.newHashMap());\n         admin.namespaces().setBacklogQuota(\"prop/ns-quota\",\n-          new BacklogQuota(10 * 1024, 2, BacklogQuota.RetentionPolicy.producer_exception));\n+          new BacklogQuota(10 * 1024, TIME_TO_CHECK_BACKLOG_QUOTA, BacklogQuota.RetentionPolicy.producer_exception));\n         try (PulsarClient client = PulsarClient.builder().serviceUrl(adminUrl.toString()).statsInterval(0, TimeUnit.SECONDS).build();) {\n             final String topic1 = \"persistent://prop/ns-quota/topic1\" + UUID.randomUUID();\n             final int numMsgs = 20;\n             Reader<byte[]> reader = client.newReader().topic(topic1).receiverQueueSize(1).startMessageId(MessageId.latest).create();\n-            Producer<byte[]> producer = client.newProducer().topic(topic1).sendTimeout(2, TimeUnit.SECONDS).create();\n+            Producer<byte[]> producer = createProducer(client, topic1);\n             byte[] content = new byte[1024];\n             for (int i = 0; i < numMsgs; i++) {\n                 content[0] = (byte) (content[0] + 1);\n                 producer.send(content);\n             }\n-            Thread.sleep(2 * 1000);\n+            Thread.sleep(TIME_TO_CHECK_BACKLOG_QUOTA * 1000);\n             admin.brokers().backlogQuotaCheck();\n             rolloverStats();\n             TopicStats stats = admin.topics().getStats(topic1);\n@@ -248,15 +252,16 @@ public void testTriggerBacklogQuotaSizeWithReader() throws Exception {\n                 fail(\"Should not have gotten exception: \" + ce.getMessage());\n             }\n \n-            // make sure ledgers are trimmed\n-            PersistentTopicInternalStats internalStats = admin.topics().getInternalStats(topic1, false);\n+            Awaitility.await().untilAsserted(() -> {\n+                // make sure ledgers are trimmed\n+                PersistentTopicInternalStats internalStats = admin.topics().getInternalStats(topic1, false);\n \n-            // check there is only one ledger left\n-            assertEquals(internalStats.ledgers.size(), 1);\n-\n-            // check if its the expected ledger id given MAX_ENTRIES_PER_LEDGER\n-            assertEquals(internalStats.ledgers.get(0).ledgerId, (2 * numMsgs / MAX_ENTRIES_PER_LEDGER) - 1);\n+                // check there is only one ledger left\n+                assertEquals(internalStats.ledgers.size(), 1);\n \n+                // check if its the expected ledger id given MAX_ENTRIES_PER_LEDGER\n+                assertEquals(internalStats.ledgers.get(0).ledgerId, (2 * numMsgs / MAX_ENTRIES_PER_LEDGER) - 1);\n+            });\n             // check reader can still read with out error\n \n             while (true) {\n@@ -281,18 +286,18 @@ public void testTriggerBacklogTimeQuotaWithReader() throws Exception {\n         assertEquals(admin.namespaces().getBacklogQuotaMap(\"prop/ns-quota\"),\n                 Maps.newHashMap());\n         admin.namespaces().setBacklogQuota(\"prop/ns-quota\",\n-                new BacklogQuota(10 * 1024, 5, BacklogQuota.RetentionPolicy.producer_exception));\n+                new BacklogQuota(10 * 1024, TIME_TO_CHECK_BACKLOG_QUOTA, BacklogQuota.RetentionPolicy.producer_exception));\n         try (PulsarClient client = PulsarClient.builder().serviceUrl(adminUrl.toString()).statsInterval(0, TimeUnit.SECONDS).build();) {\n             final String topic1 = \"persistent://prop/ns-quota/topic2\" + UUID.randomUUID();\n             final int numMsgs = 9;\n             Reader<byte[]> reader = client.newReader().topic(topic1).receiverQueueSize(1).startMessageId(MessageId.latest).create();\n-            Producer<byte[]> producer = client.newProducer().topic(topic1).sendTimeout(2, TimeUnit.SECONDS).create();\n+            Producer<byte[]> producer = createProducer(client, topic1);\n             byte[] content = new byte[1024];\n             for (int i = 0; i < numMsgs; i++) {\n                 content[0] = (byte) (content[0] + 1);\n                 producer.send(content);\n             }\n-            Thread.sleep(5 * 1000);\n+            Thread.sleep(TIME_TO_CHECK_BACKLOG_QUOTA * 1000);\n             admin.brokers().backlogQuotaCheck();\n             rolloverStats();\n             TopicStats stats = admin.topics().getStats(topic1);\n@@ -304,7 +309,18 @@ public void testTriggerBacklogTimeQuotaWithReader() throws Exception {\n             // non-durable subscription won't trigger the check for time based backlog quota\n             // and cause back pressure action to be token. Since broker don't keep track consuming position for reader.\n             assertEquals(nonDurableSubscriptionBacklog, numMsgs,\n-                    \"non-durable subscription backlog is [\" + nonDurableSubscriptionBacklog + \"]\"); ;\n+                    \"non-durable subscription backlog is [\" + nonDurableSubscriptionBacklog + \"]\");\n+\n+            Awaitility.await()\n+                    .pollDelay(Duration.ofSeconds(TIME_TO_CHECK_BACKLOG_QUOTA))\n+                    .pollInterval(Duration.ofSeconds(1)).untilAsserted(() -> {\n+                // make sure ledgers are trimmed\n+                PersistentTopicInternalStats internalStats = admin.topics().getInternalStats(topic1, false);\n+\n+                // check that there are 2 ledgers\n+                assertEquals(internalStats.ledgers.size(), 2);\n+            });\n+\n             try {\n                 // try to send over backlog quota and make sure it fails\n                 for (int i = 0; i < numMsgs; i++) {\n@@ -315,15 +331,6 @@ public void testTriggerBacklogTimeQuotaWithReader() throws Exception {\n                 fail(\"Should not have gotten exception: \" + ce.getMessage());\n             }\n \n-            // make sure ledgers are trimmed\n-            PersistentTopicInternalStats internalStats = admin.topics().getInternalStats(topic1, false);\n-\n-            // check there is only one ledger left\n-            assertEquals(internalStats.ledgers.size(), 2);\n-\n-            // check if its the expected ledger id given MAX_ENTRIES_PER_LEDGER\n-            assertEquals(internalStats.ledgers.get(0).ledgerId, (2 * numMsgs / MAX_ENTRIES_PER_LEDGER) - 1);\n-\n             // check reader can still read without error\n             while (true) {\n                 Message<byte[]> msg = reader.readNext(5, TimeUnit.SECONDS);\n@@ -354,7 +361,7 @@ public void testConsumerBacklogEvictionSizeQuota() throws Exception {\n \n         Consumer<byte[]> consumer1 = client.newConsumer().topic(topic1).subscriptionName(subName1).subscribe();\n         Consumer<byte[]> consumer2 = client.newConsumer().topic(topic1).subscriptionName(subName2).subscribe();\n-        org.apache.pulsar.client.api.Producer<byte[]> producer = client.newProducer().topic(topic1).create();\n+        org.apache.pulsar.client.api.Producer<byte[]> producer = createProducer(client, topic1);\n         byte[] content = new byte[1024];\n         for (int i = 0; i < numMsgs; i++) {\n             producer.send(content);\n@@ -386,7 +393,7 @@ public void testConsumerBacklogEvictionTimeQuotaPrecise() throws Exception {\n \n         Consumer<byte[]> consumer1 = client.newConsumer().topic(topic1).subscriptionName(subName1).subscribe();\n         Consumer<byte[]> consumer2 = client.newConsumer().topic(topic1).subscriptionName(subName2).subscribe();\n-        org.apache.pulsar.client.api.Producer<byte[]> producer = client.newProducer().topic(topic1).create();\n+        org.apache.pulsar.client.api.Producer<byte[]> producer = createProducer(client, topic1);\n         byte[] content = new byte[1024];\n         for (int i = 0; i < numMsgs; i++) {\n             producer.send(content);\n@@ -424,7 +431,7 @@ public void testConsumerBacklogEvictionTimeQuota() throws Exception {\n \n         Consumer<byte[]> consumer1 = client.newConsumer().topic(topic1).subscriptionName(subName1).subscribe();\n         Consumer<byte[]> consumer2 = client.newConsumer().topic(topic1).subscriptionName(subName2).subscribe();\n-        org.apache.pulsar.client.api.Producer<byte[]> producer = client.newProducer().topic(topic1).create();\n+        org.apache.pulsar.client.api.Producer<byte[]> producer = createProducer(client, topic1);\n         byte[] content = new byte[1024];\n         for (int i = 0; i < numMsgs; i++) {\n             producer.send(content);\n@@ -462,7 +469,7 @@ public void testConsumerBacklogEvictionWithAckSizeQuota() throws Exception {\n \n         Consumer<byte[]> consumer1 = client.newConsumer().topic(topic1).subscriptionName(subName1).subscribe();\n         Consumer<byte[]> consumer2 = client.newConsumer().topic(topic1).subscriptionName(subName2).subscribe();\n-        org.apache.pulsar.client.api.Producer<byte[]> producer = client.newProducer().topic(topic1).create();\n+        org.apache.pulsar.client.api.Producer<byte[]> producer = createProducer(client, topic1);\n         byte[] content = new byte[1024];\n         for (int i = 0; i < numMsgs; i++) {\n             producer.send(content);\n@@ -494,7 +501,7 @@ public void testConsumerBacklogEvictionWithAckTimeQuotaPrecise() throws Exceptio\n \n         Consumer<byte[]> consumer1 = client.newConsumer().topic(topic1).subscriptionName(subName1).subscribe();\n         Consumer<byte[]> consumer2 = client.newConsumer().topic(topic1).subscriptionName(subName2).subscribe();\n-        org.apache.pulsar.client.api.Producer<byte[]> producer = client.newProducer().topic(topic1).create();\n+        org.apache.pulsar.client.api.Producer<byte[]> producer = createProducer(client, topic1);\n         byte[] content = new byte[1024];\n \n         for (int i = 0; i < numMsgs; i++) {\n@@ -529,12 +536,23 @@ public void testConsumerBacklogEvictionWithAckTimeQuotaPrecise() throws Exceptio\n         client.close();\n     }\n \n+    private Producer<byte[]> createProducer(PulsarClient client, String topic)\n+            throws PulsarClientException {\n+        return client.newProducer()\n+                .enableBatching(false)\n+                .sendTimeout(2, TimeUnit.SECONDS)\n+                .topic(topic)\n+                .create();\n+    }\n+\n     @Test\n     public void testConsumerBacklogEvictionWithAckTimeQuota() throws Exception {\n         assertEquals(admin.namespaces().getBacklogQuotaMap(\"prop/ns-quota\"),\n                 Maps.newHashMap());\n         admin.namespaces().setBacklogQuota(\"prop/ns-quota\",\n-                new BacklogQuota(10 * 1024, TIME_TO_CHECK_BACKLOG_QUOTA, BacklogQuota.RetentionPolicy.consumer_backlog_eviction));\n+                new BacklogQuota(20 * 1024, 2 * TIME_TO_CHECK_BACKLOG_QUOTA,\n+                        BacklogQuota.RetentionPolicy.consumer_backlog_eviction));\n+        @Cleanup\n         PulsarClient client = PulsarClient.builder().serviceUrl(adminUrl.toString()).build();\n \n         final String topic1 = \"persistent://prop/ns-quota/topic12\";\n@@ -544,40 +562,56 @@ public void testConsumerBacklogEvictionWithAckTimeQuota() throws Exception {\n \n         Consumer<byte[]> consumer1 = client.newConsumer().topic(topic1).subscriptionName(subName1).subscribe();\n         Consumer<byte[]> consumer2 = client.newConsumer().topic(topic1).subscriptionName(subName2).subscribe();\n-        org.apache.pulsar.client.api.Producer<byte[]> producer = client.newProducer().topic(topic1).create();\n+        org.apache.pulsar.client.api.Producer<byte[]> producer = createProducer(client, topic1);\n         byte[] content = new byte[1024];\n \n+        List<Message<byte[]>> messagesToAcknowledge = new ArrayList<>();\n+\n         for (int i = 0; i < numMsgs; i++) {\n             producer.send(content);\n-            consumer1.receive();\n+            messagesToAcknowledge.add(consumer1.receive());\n             consumer2.receive();\n         }\n \n-        TopicStats stats = admin.topics().getStats(topic1);\n-        assertEquals(stats.subscriptions.get(subName1).msgBacklog, 14);\n-        assertEquals(stats.subscriptions.get(subName2).msgBacklog, 14);\n+        {\n+            TopicStats stats = admin.topics().getStats(topic1);\n+            assertEquals(stats.subscriptions.get(subName1).msgBacklog, 14);\n+            assertEquals(stats.subscriptions.get(subName2).msgBacklog, 14);\n+        }\n \n-        consumer1.redeliverUnacknowledgedMessages();\n         for (int i = 0; i < numMsgs; i++) {\n+            // pause before acknowledging the 11. message so that 2 first ledgers (5 msgs/ledger) will expire before the\n+            // last ledger\n+            if (i == 10) {\n+                Thread.sleep(TIME_TO_CHECK_BACKLOG_QUOTA * 1000L);\n+            }\n             // only one consumer acknowledges the message\n-            consumer1.acknowledge(consumer1.receive());\n+            consumer1.acknowledge(messagesToAcknowledge.get(i));\n         }\n \n-        Thread.sleep(1000);\n-        rolloverStats();\n-        stats = admin.topics().getStats(topic1);\n-        // sub1 has empty backlog as it acked all messages\n-        assertEquals(stats.subscriptions.get(subName1).msgBacklog, 0);\n-        assertEquals(stats.subscriptions.get(subName2).msgBacklog, 14);\n-\n-        Thread.sleep((TIME_TO_CHECK_BACKLOG_QUOTA * 2) * 1000);\n-        rolloverStats();\n-\n-        stats = admin.topics().getStats(topic1);\n-        // Messages on first 2 ledgers should be expired, backlog is number of\n-        // message in current ledger which should be 4.\n-        assertEquals(stats.subscriptions.get(subName2).msgBacklog, 4);\n-        client.close();\n+        Awaitility.await()\n+                .pollInterval(Duration.ofSeconds(1))\n+                .untilAsserted(() -> {\n+                    rolloverStats();\n+                    TopicStats stats = admin.topics().getStats(topic1);\n+                    // sub1 has empty backlog as it acked all messages\n+                    assertEquals(stats.subscriptions.get(subName1).msgBacklog, 0);\n+                    assertEquals(stats.subscriptions.get(subName2).msgBacklog, 14);\n+                });\n+\n+        Awaitility.await()\n+                .pollInterval(Duration.ofSeconds(1))\n+                .atMost(Duration.ofSeconds(4 * TIME_TO_CHECK_BACKLOG_QUOTA))\n+                .untilAsserted(() -> {\n+                    // Messages on first 2 ledgers should be expired, backlog is number of\n+                    // message in current ledger which should be 4.\n+                    long msgBacklog = admin.topics().getStats(topic1).subscriptions.get(subName2).msgBacklog;\n+                    // TODO: for some reason the backlog size is sometimes off by one\n+                    // Internally there's a method `long getNumberOfEntriesInBacklog(boolean getPreciseBacklog)`\n+                    // on org.apache.pulsar.broker.service.Subscription interface\n+                    // the `boolean getPreciseBacklog` parameter indicates that the backlog size isn't accurate\n+                    assertEquals(msgBacklog, 4, 1);\n+                });\n     }\n \n     @Test\n@@ -608,8 +642,7 @@ public void testConcurrentAckAndEviction() throws Exception {\n             public void run() {\n                 try {\n                     barrier.await();\n-                    org.apache.pulsar.client.api.Producer<byte[]> producer = client.newProducer().topic(topic1)\n-                            .create();\n+                    org.apache.pulsar.client.api.Producer<byte[]> producer = createProducer(client, topic1);\n                     byte[] content = new byte[1024];\n                     for (int i = 0; i < numMsgs; i++) {\n                         producer.send(content);\n@@ -623,7 +656,7 @@ public void run() {\n             }\n         };\n \n-        Thread ConsumerThread = new Thread() {\n+        Thread consumerThread = new Thread() {\n             public void run() {\n                 try {\n                     barrier.await();\n@@ -641,7 +674,7 @@ public void run() {\n         };\n \n         producerThread.start();\n-        ConsumerThread.start();\n+        consumerThread.start();\n \n         // test hangs without timeout since there is nothing to consume due to eviction\n         counter.await(20, TimeUnit.SECONDS);\n@@ -682,8 +715,7 @@ public void testNoEviction() throws Exception {\n             public void run() {\n                 try {\n                     barrier.await();\n-                    org.apache.pulsar.client.api.Producer<byte[]> producer = client2.newProducer().topic(topic1)\n-                            .create();\n+                    org.apache.pulsar.client.api.Producer<byte[]> producer = createProducer(client2, topic1);\n                     byte[] content = new byte[1024];\n                     for (int i = 0; i < numMsgs; i++) {\n                         producer.send(content);\n@@ -697,7 +729,7 @@ public void run() {\n             }\n         };\n \n-        Thread ConsumerThread = new Thread() {\n+        Thread consumerThread = new Thread() {\n             public void run() {\n                 try {\n                     barrier.await();\n@@ -714,7 +746,7 @@ public void run() {\n         };\n \n         producerThread.start();\n-        ConsumerThread.start();\n+        consumerThread.start();\n         counter.await();\n         assertFalse(gotException.get());\n     }\n@@ -751,8 +783,7 @@ public void testEvictionMulti() throws Exception {\n             public void run() {\n                 try {\n                     barrier.await();\n-                    org.apache.pulsar.client.api.Producer<byte[]> producer = client2.newProducer().topic(topic1)\n-                            .create();\n+                    org.apache.pulsar.client.api.Producer<byte[]> producer = createProducer(client2, topic1);\n                     byte[] content = new byte[1024];\n                     for (int i = 0; i < numMsgs; i++) {\n                         producer.send(content);\n@@ -770,8 +801,7 @@ public void run() {\n             public void run() {\n                 try {\n                     barrier.await();\n-                    org.apache.pulsar.client.api.Producer<byte[]> producer = client3.newProducer().topic(topic1)\n-                            .create();\n+                    org.apache.pulsar.client.api.Producer<byte[]> producer = createProducer(client3, topic1);\n                     byte[] content = new byte[1024];\n                     for (int i = 0; i < numMsgs; i++) {\n                         producer.send(content);\n@@ -785,7 +815,7 @@ public void run() {\n             }\n         };\n \n-        Thread ConsumerThread1 = new Thread() {\n+        Thread consumerThread1 = new Thread() {\n             public void run() {\n                 try {\n                     barrier.await();\n@@ -800,7 +830,7 @@ public void run() {\n             }\n         };\n \n-        Thread ConsumerThread2 = new Thread() {\n+        Thread consumerThread2 = new Thread() {\n             public void run() {\n                 try {\n                     barrier.await();\n@@ -817,8 +847,8 @@ public void run() {\n \n         producerThread1.start();\n         producerThread2.start();\n-        ConsumerThread1.start();\n-        ConsumerThread2.start();\n+        consumerThread1.start();\n+        consumerThread2.start();\n         counter.await(20, TimeUnit.SECONDS);\n         assertFalse(gotException.get());\n         Thread.sleep((TIME_TO_CHECK_BACKLOG_QUOTA + 1) * 1000);\n@@ -844,7 +874,7 @@ public void testAheadProducerOnHold() throws Exception {\n         Consumer<byte[]> consumer = client.newConsumer().topic(topic1).subscriptionName(subName1).subscribe();\n \n         byte[] content = new byte[1024];\n-        Producer<byte[]> producer = client.newProducer().topic(topic1).sendTimeout(2, TimeUnit.SECONDS).create();\n+        Producer<byte[]> producer = createProducer(client, topic1);\n         for (int i = 0; i <= numMsgs; i++) {\n             try {\n                 producer.send(content);\n@@ -883,7 +913,7 @@ public void testAheadProducerOnHoldTimeout() throws Exception {\n         client.newConsumer().topic(topic1).subscriptionName(subName1).subscribe();\n \n         byte[] content = new byte[1024];\n-        Producer<byte[]> producer = client.newProducer().topic(topic1).sendTimeout(2, TimeUnit.SECONDS).create();\n+        Producer<byte[]> producer = createProducer(client, topic1);\n         for (int i = 0; i < 10; i++) {\n             producer.send(content);\n         }\n@@ -918,7 +948,7 @@ public void testProducerException() throws Exception {\n         client.newConsumer().topic(topic1).subscriptionName(subName1).subscribe();\n \n         byte[] content = new byte[1024];\n-        Producer<byte[]> producer = client.newProducer().topic(topic1).sendTimeout(2, TimeUnit.SECONDS).create();\n+        Producer<byte[]> producer = createProducer(client, topic1);\n         for (int i = 0; i < 10; i++) {\n             producer.send(content);\n         }\n@@ -955,7 +985,7 @@ public void testProducerExceptionAndThenUnblockSizeQuota() throws Exception {\n         Consumer<byte[]> consumer = client.newConsumer().topic(topic1).subscriptionName(subName1).subscribe();\n \n         byte[] content = new byte[1024];\n-        Producer<byte[]> producer = client.newProducer().topic(topic1).sendTimeout(2, TimeUnit.SECONDS).create();\n+        Producer<byte[]> producer = createProducer(client, topic1);\n         for (int i = 0; i < 10; i++) {\n             producer.send(content);\n         }\n@@ -1015,7 +1045,7 @@ public void testProducerExceptionAndThenUnblockTimeQuotaPrecise() throws Excepti\n         Consumer<byte[]> consumer = client.newConsumer().topic(topic1).subscriptionName(subName1).subscribe();\n \n         byte[] content = new byte[1024];\n-        Producer<byte[]> producer = client.newProducer().topic(topic1).sendTimeout(2, TimeUnit.SECONDS).create();\n+        Producer<byte[]> producer = createProducer(client, topic1);\n         for (int i = 0; i < numMsgs; i++) {\n             producer.send(content);\n         }\n@@ -1077,7 +1107,7 @@ public void testProducerExceptionAndThenUnblockTimeQuota() throws Exception {\n         Consumer<byte[]> consumer = client.newConsumer().topic(topic1).subscriptionName(subName1).subscribe();\n \n         byte[] content = new byte[1024];\n-        Producer<byte[]> producer = client.newProducer().topic(topic1).sendTimeout(2, TimeUnit.SECONDS).create();\n+        Producer<byte[]> producer = createProducer(client, topic1);\n         for (int i = 0; i < numMsgs; i++) {\n             producer.send(content);\n         }",
      "parent_sha": "61dc9e30da2367b26bdffe5329275d837f84ec7f"
    }
  },
  {
    "oid": "3120a4bc59439476019b1cc08ba71283881ad2e6",
    "message": "[Tiered Storage] Add logs for cleanup offloaded data operation (#9852)\n\n### Motivation\r\n\r\nThe cleanup offloaded data operation was lack of logs, it's hard for users to analyze the tiered storage data loss reason.\r\n\r\n### Modifications\r\n\r\nAdd some logs for the cleanup offloaded data operation.",
    "date": "2021-03-11T03:50:48Z",
    "url": "https://github.com/apache/pulsar/commit/3120a4bc59439476019b1cc08ba71283881ad2e6",
    "details": {
      "sha": "01f32e8b1d031c9b819ed0de289076a888fa8c08",
      "filename": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedLedgerImpl.java",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/apache/pulsar/blob/3120a4bc59439476019b1cc08ba71283881ad2e6/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedLedgerImpl.java",
      "raw_url": "https://github.com/apache/pulsar/raw/3120a4bc59439476019b1cc08ba71283881ad2e6/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedLedgerImpl.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedLedgerImpl.java?ref=3120a4bc59439476019b1cc08ba71283881ad2e6",
      "patch": "@@ -2764,6 +2764,8 @@ private void offloadLoop(CompletableFuture<PositionImpl> promise, Queue<LedgerIn\n                                            scheduledExecutor, name)\n                             .whenComplete((ignore2, exception) -> {\n                                     if (exception != null) {\n+                                        log.error(\"[{}] Failed to offload data for the ledgerId {}\",\n+                                                name, ledgerId, exception);\n                                         cleanupOffloaded(\n                                             ledgerId, uuid,\n                                             driverName, driverMetadata,\n@@ -2954,13 +2956,15 @@ private void cleanupOffloaded(long ledgerId, UUID uuid, String offloadDriverName\n                                                                                        * identify offloader\n                                                                                        */\n             Map<String, String> offloadDriverMetadata, String cleanupReason) {\n+        log.info(\"[{}] Cleanup offload for ledgerId {} uuid {} because of the reason {}.\",\n+                name, ledgerId, uuid.toString(), cleanupReason);\n         Retries.run(Backoff.exponentialJittered(TimeUnit.SECONDS.toMillis(1), TimeUnit.SECONDS.toHours(1)).limit(10),\n                 Retries.NonFatalPredicate,\n                 () -> config.getLedgerOffloader().deleteOffloaded(ledgerId, uuid, offloadDriverMetadata),\n                 scheduledExecutor, name).whenComplete((ignored, exception) -> {\n                     if (exception != null) {\n-                        log.warn(\"Error cleaning up offload for {}, (cleanup reason: {})\", ledgerId, cleanupReason,\n-                                exception);\n+                        log.warn(\"[{}] Error cleaning up offload for {}, (cleanup reason: {})\",\n+                                name, ledgerId, cleanupReason, exception);\n                     }\n                 });\n     }",
      "parent_sha": "7f92adee9d9d60f92d14896b52c885eecfde4d77"
    }
  },
  {
    "oid": "d460f09b8d755112f42324495b554a774eb1d011",
    "message": "[Broker] Set default value of applied to false on topic policy (#14181)",
    "date": "2022-02-10T01:48:19Z",
    "url": "https://github.com/apache/pulsar/commit/d460f09b8d755112f42324495b554a774eb1d011",
    "details": {
      "sha": "c58cc5cf3c9b00bc2e70631eafef898c76a8b842",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/v2/PersistentTopics.java",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/apache/pulsar/blob/d460f09b8d755112f42324495b554a774eb1d011/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2Fv2%2FPersistentTopics.java",
      "raw_url": "https://github.com/apache/pulsar/raw/d460f09b8d755112f42324495b554a774eb1d011/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2Fv2%2FPersistentTopics.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2Fv2%2FPersistentTopics.java?ref=d460f09b8d755112f42324495b554a774eb1d011",
      "patch": "@@ -328,7 +328,7 @@ public void getOffloadPolicies(@Suspended final AsyncResponse asyncResponse,\n             @PathParam(\"tenant\") String tenant,\n             @PathParam(\"namespace\") String namespace,\n             @PathParam(\"topic\") @Encoded String encodedTopic,\n-            @QueryParam(\"applied\") boolean applied,\n+            @QueryParam(\"applied\") @DefaultValue(\"false\") boolean applied,\n             @QueryParam(\"isGlobal\") @DefaultValue(\"false\") boolean isGlobal,\n             @ApiParam(value = \"Is authentication required to perform this operation\")\n             @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative) {\n@@ -397,7 +397,7 @@ public void getMaxUnackedMessagesOnConsumer(@Suspended final AsyncResponse async\n             @PathParam(\"tenant\") String tenant,\n             @PathParam(\"namespace\") String namespace,\n             @PathParam(\"topic\") @Encoded String encodedTopic,\n-            @QueryParam(\"applied\") boolean applied,\n+            @QueryParam(\"applied\") @DefaultValue(\"false\") boolean applied,\n             @QueryParam(\"isGlobal\") @DefaultValue(\"false\") boolean isGlobal,\n             @ApiParam(value = \"Is authentication required to perform this operation\")\n             @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative) {\n@@ -540,7 +540,7 @@ public void getInactiveTopicPolicies(@Suspended final AsyncResponse asyncRespons\n             @PathParam(\"tenant\") String tenant,\n             @PathParam(\"namespace\") String namespace,\n             @PathParam(\"topic\") @Encoded String encodedTopic,\n-            @QueryParam(\"applied\") boolean applied,\n+            @QueryParam(\"applied\") @DefaultValue(\"false\") boolean applied,\n             @QueryParam(\"isGlobal\") @DefaultValue(\"false\") boolean isGlobal,\n             @ApiParam(value = \"Is authentication required to perform this operation\")\n             @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative) {\n@@ -609,7 +609,7 @@ public void getMaxUnackedMessagesOnSubscription(@Suspended final AsyncResponse a\n             @PathParam(\"tenant\") String tenant,\n             @PathParam(\"namespace\") String namespace,\n             @PathParam(\"topic\") @Encoded String encodedTopic,\n-            @QueryParam(\"applied\") boolean applied,\n+            @QueryParam(\"applied\") @DefaultValue(\"false\") boolean applied,\n             @QueryParam(\"isGlobal\") @DefaultValue(\"false\") boolean isGlobal,\n             @ApiParam(value = \"Is authentication required to perform this operation\")\n             @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative) {\n@@ -685,7 +685,7 @@ public void getDelayedDeliveryPolicies(@Suspended final AsyncResponse asyncRespo\n             @PathParam(\"namespace\") String namespace,\n             @PathParam(\"topic\") @Encoded String encodedTopic,\n             @QueryParam(\"isGlobal\") @DefaultValue(\"false\") boolean isGlobal,\n-            @QueryParam(\"applied\") boolean applied,\n+            @QueryParam(\"applied\") @DefaultValue(\"false\") boolean applied,\n             @ApiParam(value = \"Is authentication required to perform this operation\")\n             @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative) {\n         validateTopicName(tenant, namespace, encodedTopic);\n@@ -1693,7 +1693,7 @@ public void getBacklogQuotaMap(\n             @PathParam(\"tenant\") String tenant,\n             @PathParam(\"namespace\") String namespace,\n             @PathParam(\"topic\") @Encoded String encodedTopic,\n-            @QueryParam(\"applied\") boolean applied,\n+            @QueryParam(\"applied\") @DefaultValue(\"false\") boolean applied,\n             @ApiParam(value = \"Is authentication required to perform this operation\")\n             @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative,\n             @QueryParam(\"isGlobal\") @DefaultValue(\"false\") boolean isGlobal) {\n@@ -1771,7 +1771,7 @@ public void getReplicationClusters(@Suspended final AsyncResponse asyncResponse,\n                               @PathParam(\"tenant\") String tenant,\n                               @PathParam(\"namespace\") String namespace,\n                               @PathParam(\"topic\") @Encoded String encodedTopic,\n-                              @QueryParam(\"applied\") boolean applied,\n+                              @QueryParam(\"applied\") @DefaultValue(\"false\") boolean applied,\n                               @ApiParam(value = \"Is authentication required to perform this operation\")\n                               @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative) {\n         validateTopicName(tenant, namespace, encodedTopic);\n@@ -1852,7 +1852,7 @@ public void getMessageTTL(@Suspended final AsyncResponse asyncResponse,\n             @PathParam(\"tenant\") String tenant,\n             @PathParam(\"namespace\") String namespace,\n             @PathParam(\"topic\") @Encoded String encodedTopic,\n-            @QueryParam(\"applied\") boolean applied,\n+            @QueryParam(\"applied\") @DefaultValue(\"false\") boolean applied,\n             @QueryParam(\"isGlobal\") @DefaultValue(\"false\") boolean isGlobal,\n             @ApiParam(value = \"Is authentication required to perform this operation\")\n             @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative) {\n@@ -1942,7 +1942,7 @@ public void getDeduplication(@Suspended final AsyncResponse asyncResponse,\n             @PathParam(\"tenant\") String tenant,\n             @PathParam(\"namespace\") String namespace,\n             @PathParam(\"topic\") @Encoded String encodedTopic,\n-            @QueryParam(\"applied\") boolean applied,\n+            @QueryParam(\"applied\") @DefaultValue(\"false\") boolean applied,\n             @QueryParam(\"isGlobal\") @DefaultValue(\"false\") boolean isGlobal,\n             @ApiParam(value = \"Is authentication required to perform this operation\")\n             @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative) {\n@@ -2021,7 +2021,7 @@ public void getRetention(@Suspended final AsyncResponse asyncResponse,\n             @PathParam(\"namespace\") String namespace,\n             @PathParam(\"topic\") @Encoded String encodedTopic,\n             @QueryParam(\"isGlobal\") @DefaultValue(\"false\") boolean isGlobal,\n-            @QueryParam(\"applied\") boolean applied,\n+            @QueryParam(\"applied\") @DefaultValue(\"false\") boolean applied,\n             @ApiParam(value = \"Is authentication required to perform this operation\")\n             @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative) {\n         validateTopicName(tenant, namespace, encodedTopic);\n@@ -2115,7 +2115,7 @@ public void getPersistence(@Suspended final AsyncResponse asyncResponse,\n             @PathParam(\"tenant\") String tenant,\n             @PathParam(\"namespace\") String namespace,\n             @PathParam(\"topic\") @Encoded String encodedTopic,\n-            @QueryParam(\"applied\") boolean applied,\n+            @QueryParam(\"applied\") @DefaultValue(\"false\") boolean applied,\n             @QueryParam(\"isGlobal\") @DefaultValue(\"false\") boolean isGlobal,\n             @ApiParam(value = \"Is authentication required to perform this operation\")\n             @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative) {\n@@ -2299,7 +2299,7 @@ public void getReplicatorDispatchRate(@Suspended final AsyncResponse asyncRespon\n             @PathParam(\"namespace\") String namespace,\n             @PathParam(\"topic\") @Encoded String encodedTopic,\n             @QueryParam(\"isGlobal\") @DefaultValue(\"false\") boolean isGlobal,\n-            @QueryParam(\"applied\") boolean applied,\n+            @QueryParam(\"applied\") @DefaultValue(\"false\") boolean applied,\n             @ApiParam(value = \"Is authentication required to perform this operation\")\n             @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative) {\n         validateTopicName(tenant, namespace, encodedTopic);\n@@ -2385,7 +2385,7 @@ public void getMaxProducers(@Suspended final AsyncResponse asyncResponse,\n             @PathParam(\"tenant\") String tenant,\n             @PathParam(\"namespace\") String namespace,\n             @PathParam(\"topic\") @Encoded String encodedTopic,\n-            @QueryParam(\"applied\") boolean applied,\n+            @QueryParam(\"applied\") @DefaultValue(\"false\") boolean applied,\n             @QueryParam(\"isGlobal\") @DefaultValue(\"false\") boolean isGlobal,\n             @ApiParam(value = \"Is authentication required to perform this operation\")\n             @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative) {\n@@ -2477,7 +2477,7 @@ public void getMaxConsumers(@Suspended final AsyncResponse asyncResponse,\n             @PathParam(\"namespace\") String namespace,\n             @PathParam(\"topic\") @Encoded String encodedTopic,\n             @QueryParam(\"isGlobal\") @DefaultValue(\"false\") boolean isGlobal,\n-            @QueryParam(\"applied\") boolean applied,\n+            @QueryParam(\"applied\") @DefaultValue(\"false\") boolean applied,\n             @ApiParam(value = \"Is authentication required to perform this operation\")\n             @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative) {\n         validateTopicName(tenant, namespace, encodedTopic);\n@@ -2879,7 +2879,7 @@ public void getDispatchRate(@Suspended final AsyncResponse asyncResponse,\n             @PathParam(\"tenant\") String tenant,\n             @PathParam(\"namespace\") String namespace,\n             @PathParam(\"topic\") @Encoded String encodedTopic,\n-            @QueryParam(\"applied\") boolean applied,\n+            @QueryParam(\"applied\") @DefaultValue(\"false\") boolean applied,\n             @QueryParam(\"isGlobal\") @DefaultValue(\"false\") boolean isGlobal,\n             @ApiParam(value = \"Is authentication required to perform this operation\")\n             @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative) {\n@@ -2974,7 +2974,7 @@ public void getSubscriptionDispatchRate(@Suspended final AsyncResponse asyncResp\n             @PathParam(\"tenant\") String tenant,\n             @PathParam(\"namespace\") String namespace,\n             @PathParam(\"topic\") @Encoded String encodedTopic,\n-            @QueryParam(\"applied\") boolean applied,\n+            @QueryParam(\"applied\") @DefaultValue(\"false\") boolean applied,\n             @QueryParam(\"isGlobal\") @DefaultValue(\"false\") boolean isGlobal,\n             @ApiParam(value = \"Is authentication required to perform this operation\")\n             @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative) {\n@@ -3071,7 +3071,7 @@ public void getCompactionThreshold(@Suspended final AsyncResponse asyncResponse,\n             @PathParam(\"tenant\") String tenant,\n             @PathParam(\"namespace\") String namespace,\n             @PathParam(\"topic\") @Encoded String encodedTopic,\n-            @QueryParam(\"applied\") boolean applied,\n+            @QueryParam(\"applied\") @DefaultValue(\"false\") boolean applied,\n             @QueryParam(\"isGlobal\") @DefaultValue(\"false\") boolean isGlobal,\n             @ApiParam(value = \"Is authentication required to perform this operation\")\n             @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative) {\n@@ -3457,7 +3457,7 @@ public void getSubscribeRate(@Suspended final AsyncResponse asyncResponse,\n             @PathParam(\"tenant\") String tenant,\n             @PathParam(\"namespace\") String namespace,\n             @PathParam(\"topic\") @Encoded String encodedTopic,\n-            @QueryParam(\"applied\") boolean applied,\n+            @QueryParam(\"applied\") @DefaultValue(\"false\") boolean applied,\n             @QueryParam(\"isGlobal\") @DefaultValue(\"false\") boolean isGlobal,\n             @ApiParam(value = \"Is authentication required to perform this operation\")\n             @QueryParam(\"authoritative\") @DefaultValue(\"false\") boolean authoritative) {",
      "parent_sha": "0287f7f4278c8bf892d869d81d5d1982be39a516"
    }
  },
  {
    "oid": "2dccc85a1223dc606cadec8a0ee55af7c4bca1d3",
    "message": "fixing bug in scheduler (#215)",
    "date": "2018-03-04T00:44:13Z",
    "url": "https://github.com/apache/pulsar/commit/2dccc85a1223dc606cadec8a0ee55af7c4bca1d3",
    "details": {
      "sha": "3c4e997b04906870f60313c6f3ef62f9dc433bcd",
      "filename": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/SchedulerManager.java",
      "status": "modified",
      "additions": 8,
      "deletions": 9,
      "changes": 17,
      "blob_url": "https://github.com/apache/pulsar/blob/2dccc85a1223dc606cadec8a0ee55af7c4bca1d3/pulsar-functions%2Fworker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Fworker%2FSchedulerManager.java",
      "raw_url": "https://github.com/apache/pulsar/raw/2dccc85a1223dc606cadec8a0ee55af7c4bca1d3/pulsar-functions%2Fworker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Fworker%2FSchedulerManager.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-functions%2Fworker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Fworker%2FSchedulerManager.java?ref=2dccc85a1223dc606cadec8a0ee55af7c4bca1d3",
      "patch": "@@ -32,6 +32,7 @@\n import org.apache.pulsar.functions.worker.scheduler.IScheduler;\n \n import java.util.HashMap;\n+import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n@@ -112,17 +113,15 @@ private void invokeScheduler() {\n         Map<String, Map<String, Assignment>> workerIdToAssignments = this.functionRuntimeManager.getCurrentAssignments();\n \n         //delete assignments of functions that don't exist anymore\n-        List<Assignment> invalidAssignments = new LinkedList<>();\n-        for (Map<String, Assignment> entryMap : workerIdToAssignments.values()) {\n-            for (Map.Entry<String, Assignment> entry : entryMap.entrySet()) {\n-                String fullyQualifiedName = entry.getKey();\n-                Assignment assignment = entry.getValue();\n-                if (!fullyQualifiedNames.contains(fullyQualifiedName)) {\n-                    invalidAssignments.add(assignment);\n-                }\n+        Iterator<Map.Entry<String, Map<String, Assignment>>> it = workerIdToAssignments.entrySet().iterator();\n+        while(it.hasNext()) {\n+            Map.Entry<String, Map<String, Assignment>> workerIdToAssignmentEntry = it.next();\n+            Map<String, Assignment> functionMap = workerIdToAssignmentEntry.getValue();\n+            functionMap.entrySet().removeIf(entry -> !fullyQualifiedNames.contains(entry.getKey()));\n+            if (functionMap.isEmpty()) {\n+                it.remove();\n             }\n         }\n-        this.functionRuntimeManager.removeAssignments(invalidAssignments);\n \n         List<Assignment> currentAssignments = workerIdToAssignments\n                 .entrySet().stream()",
      "parent_sha": "4b62d14cb7dea58fded16c9fa2209b18024b2511"
    }
  },
  {
    "oid": "75293574665809ac6b439e0f20693fc607797f7a",
    "message": "[improve] Validate range of argument before long -> int conversion (#22830)",
    "date": "2024-06-04T10:12:33Z",
    "url": "https://github.com/apache/pulsar/commit/75293574665809ac6b439e0f20693fc607797f7a",
    "details": {
      "sha": "4fef0802ed41364d559c99061fcf0799463ea169",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/TransactionsBase.java",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/apache/pulsar/blob/75293574665809ac6b439e0f20693fc607797f7a/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2Fimpl%2FTransactionsBase.java",
      "raw_url": "https://github.com/apache/pulsar/raw/75293574665809ac6b439e0f20693fc607797f7a/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2Fimpl%2FTransactionsBase.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2Fimpl%2FTransactionsBase.java?ref=75293574665809ac6b439e0f20693fc607797f7a",
      "patch": "@@ -564,8 +564,15 @@ protected CompletableFuture<PositionInPendingAckStats> internalGetPositionStatsP\n \n     protected CompletableFuture<Void> internalAbortTransaction(boolean authoritative, long mostSigBits,\n                                                                long leastSigBits) {\n+\n+        if (mostSigBits < 0 || mostSigBits > Integer.MAX_VALUE) {\n+            return CompletableFuture.failedFuture(new IllegalArgumentException(\"mostSigBits out of bounds\"));\n+        }\n+\n+        int partitionIdx = (int) mostSigBits;\n+\n         return validateTopicOwnershipAsync(\n-                SystemTopicNames.TRANSACTION_COORDINATOR_ASSIGN.getPartition((int) mostSigBits), authoritative)\n+                SystemTopicNames.TRANSACTION_COORDINATOR_ASSIGN.getPartition(partitionIdx), authoritative)\n                 .thenCompose(__ -> validateSuperUserAccessAsync())\n                 .thenCompose(__ -> pulsar().getTransactionMetadataStoreService()\n                         .endTransaction(new TxnID(mostSigBits, leastSigBits), TxnAction.ABORT_VALUE, false));",
      "parent_sha": "94549856364656cbde2d26e4907bc8f2d4c60e07"
    }
  },
  {
    "oid": "08d40157ee24acb91eac126147e37d1e1f682996",
    "message": "Avoid running duplicate ReplicatorTest (#911)",
    "date": "2017-11-24T17:00:28Z",
    "url": "https://github.com/apache/pulsar/commit/08d40157ee24acb91eac126147e37d1e1f682996",
    "details": {
      "sha": "71fc1cb8b3ef8de1bf0435aae5d58f1ffa7ab721",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/ReplicatorTlsTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/pulsar/blob/08d40157ee24acb91eac126147e37d1e1f682996/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FReplicatorTlsTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/08d40157ee24acb91eac126147e37d1e1f682996/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FReplicatorTlsTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FReplicatorTlsTest.java?ref=08d40157ee24acb91eac126147e37d1e1f682996",
      "patch": "@@ -30,7 +30,7 @@\n import org.testng.annotations.Test;\n import org.testng.collections.Lists;\n \n-public class ReplicatorTlsTest extends ReplicatorTest {\n+public class ReplicatorTlsTest extends ReplicatorTestBase {\n \n     @Override\n     @BeforeClass",
      "parent_sha": "304d0b02ae8a7374e0621350a5ef01a6de8f397e"
    }
  },
  {
    "oid": "e8fd71efd86fbd2ed28e8e7205daa49826ef0afa",
    "message": "fix Flaky-test: PulsarFunctionLocalRunTest.testE2EPulsarFunctionLocalRunMultipleInstance (#16872)",
    "date": "2022-08-03T03:06:51Z",
    "url": "https://github.com/apache/pulsar/commit/e8fd71efd86fbd2ed28e8e7205daa49826ef0afa",
    "details": {
      "sha": "5d6395a9813e8b3e8f080eccd7eb26000119f583",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/functions/worker/PulsarFunctionLocalRunTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/apache/pulsar/blob/e8fd71efd86fbd2ed28e8e7205daa49826ef0afa/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Fworker%2FPulsarFunctionLocalRunTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/e8fd71efd86fbd2ed28e8e7205daa49826ef0afa/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Fworker%2FPulsarFunctionLocalRunTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Fworker%2FPulsarFunctionLocalRunTest.java?ref=e8fd71efd86fbd2ed28e8e7205daa49826ef0afa",
      "patch": "@@ -27,7 +27,6 @@\n import static org.testng.Assert.assertNotEquals;\n import static org.testng.Assert.assertTrue;\n import static org.testng.Assert.fail;\n-\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import java.io.File;\n@@ -47,7 +46,6 @@\n import java.util.Optional;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n-\n import lombok.Cleanup;\n import org.apache.pulsar.broker.PulsarService;\n import org.apache.pulsar.broker.ServiceConfiguration;\n@@ -449,6 +447,7 @@ private void testE2EPulsarFunctionLocalRun(String jarFilePathUrl, int parallelis\n \n         functionConfig.setJar(jarFilePathUrl);\n         functionConfig.setParallelism(parallelism);\n+        functionConfig.setRetainOrdering(true);\n         int metricsPort = FunctionCommon.findAvailablePort();\n         @Cleanup\n         LocalRunner localRunner = LocalRunner.builder()",
      "parent_sha": "d004cf44c7754c0584200fbce9a735dc222a0ee7"
    }
  },
  {
    "oid": "994eb45848c6a0bca25ae852d4c4e15c94fe54b2",
    "message": "Fix response when set offload policies. (#6951)\n\n### Motivation\r\n\r\nThe response should be completed in the zookeeper callback when calling `setData()` asynchronously in `internalSetOffloadPolicies`, otherwise it will always return success.\r\n\r\n### Modifications\r\n\r\nComplete `internalSetOffloadPolicies` response in the zookeeper callback.",
    "date": "2020-05-19T15:04:57Z",
    "url": "https://github.com/apache/pulsar/commit/994eb45848c6a0bca25ae852d4c4e15c94fe54b2",
    "details": {
      "sha": "4164db22b29cbf7ddbecfc3f50466966891c6e61",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/apache/pulsar/blob/994eb45848c6a0bca25ae852d4c4e15c94fe54b2/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2Fimpl%2FNamespacesBase.java",
      "raw_url": "https://github.com/apache/pulsar/raw/994eb45848c6a0bca25ae852d4c4e15c94fe54b2/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2Fimpl%2FNamespacesBase.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2Fimpl%2FNamespacesBase.java?ref=994eb45848c6a0bca25ae852d4c4e15c94fe54b2",
      "patch": "@@ -2611,10 +2611,14 @@ protected void internalSetOffloadPolicies(AsyncResponse asyncResponse, OffloadPo\n             }\n \n             policies.offload_policies = offloadPolicies;\n+            String updatedOffloadPolicies = jsonMapper().writeValueAsString(policies.offload_policies);\n             globalZk().setData(path, jsonMapper().writeValueAsBytes(policies), nodeStat.getVersion(),\n                     (rc, path1, ctx, stat) -> {\n                         if (rc == KeeperException.Code.OK.intValue()) {\n                             policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                            log.info(\"[{}] Successfully updated offload configuration: namespace={}, map={}\", clientAppId(),\n+                                    namespaceName, updatedOffloadPolicies);\n+                            asyncResponse.resume(Response.noContent().build());\n                         } else {\n                             String errorMsg = String.format(\n                                     \"[%s] Failed to update offload configuration for namespace %s\",\n@@ -2630,9 +2634,6 @@ protected void internalSetOffloadPolicies(AsyncResponse asyncResponse, OffloadPo\n                             }\n                         }\n                     }, null);\n-            log.info(\"[{}] Successfully updated offload configuration: namespace={}, map={}\", clientAppId(),\n-                    namespaceName, jsonMapper().writeValueAsString(policies.offload_policies));\n-            asyncResponse.resume(Response.noContent().build());\n         } catch (Exception e) {\n             log.error(\"[{}] Failed to update offload configuration for namespace {}\", clientAppId(), namespaceName,\n                     e);",
      "parent_sha": "225baf5fac4051b04e87bb1d351d85273449b761"
    }
  },
  {
    "oid": "9cfe50adb5619218951ace00640fd70e8b599d06",
    "message": "[pulsar-broker] Improve JwtParser build (#12063)",
    "date": "2021-09-17T17:31:24Z",
    "url": "https://github.com/apache/pulsar/commit/9cfe50adb5619218951ace00640fd70e8b599d06",
    "details": {
      "sha": "c089fa09953d4278adb2acabd10384ad66efb568",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/utils/auth/tokens/TokensCliUtils.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/apache/pulsar/blob/9cfe50adb5619218951ace00640fd70e8b599d06/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Futils%2Fauth%2Ftokens%2FTokensCliUtils.java",
      "raw_url": "https://github.com/apache/pulsar/raw/9cfe50adb5619218951ace00640fd70e8b599d06/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Futils%2Fauth%2Ftokens%2FTokensCliUtils.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Futils%2Fauth%2Ftokens%2FTokensCliUtils.java?ref=9cfe50adb5619218951ace00640fd70e8b599d06",
      "patch": "@@ -276,8 +276,9 @@ public void run() throws Exception {\n \n             // Validate the token\n             @SuppressWarnings(\"unchecked\")\n-            Jwt<?, Claims> jwt = Jwts.parser()\n+            Jwt<?, Claims> jwt = Jwts.parserBuilder()\n                     .setSigningKey(validationKey)\n+                    .build()\n                     .parse(token);\n \n             System.out.println(jwt.getBody());",
      "parent_sha": "37162cfaad7f8f17707a1deb3c9948669fa4fb63"
    }
  },
  {
    "oid": "1ec3cf4bfbd42163331a28d270c6225bb5b5d91c",
    "message": "Fix ProxyLookupThrottlingTest (#5639)\n\n*Motivation*\r\n\r\nProxyLookupThrottlingTest relies on the number of permits for testing the behavior of current lookup.\r\nWe should reset the proxyService for each run.\r\n\r\n*Modifications*\r\n\r\nChange the setup and cleanup methods from `BeforeClass/AfterClass` to `BeforeMethod/AfterMethod`.",
    "date": "2019-11-19T17:59:01Z",
    "url": "https://github.com/apache/pulsar/commit/1ec3cf4bfbd42163331a28d270c6225bb5b5d91c",
    "details": {
      "sha": "2c1c691299b2cc1f542bfa82481d545bbd300cf6",
      "filename": "pulsar-proxy/src/test/java/org/apache/pulsar/proxy/server/ProxyLookupThrottlingTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/apache/pulsar/blob/1ec3cf4bfbd42163331a28d270c6225bb5b5d91c/pulsar-proxy%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fproxy%2Fserver%2FProxyLookupThrottlingTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/1ec3cf4bfbd42163331a28d270c6225bb5b5d91c/pulsar-proxy%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fproxy%2Fserver%2FProxyLookupThrottlingTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-proxy%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fproxy%2Fserver%2FProxyLookupThrottlingTest.java?ref=1ec3cf4bfbd42163331a28d270c6225bb5b5d91c",
      "patch": "@@ -33,7 +33,9 @@\n import org.mockito.Mockito;\n import org.testng.Assert;\n import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n import org.testng.annotations.Test;\n \n public class ProxyLookupThrottlingTest extends MockedPulsarServiceBaseTest {\n@@ -45,7 +47,7 @@ public class ProxyLookupThrottlingTest extends MockedPulsarServiceBaseTest {\n     private ProxyConfiguration proxyConfig = new ProxyConfiguration();\n \n     @Override\n-    @BeforeClass\n+    @BeforeMethod\n     protected void setup() throws Exception {\n         internalSetup();\n \n@@ -64,7 +66,7 @@ protected void setup() throws Exception {\n     }\n \n     @Override\n-    @AfterClass\n+    @AfterMethod\n     protected void cleanup() throws Exception {\n         internalCleanup();\n         proxyService.close();",
      "parent_sha": "9dd8dfdc5d02fa4072361e89d06a839289f55e41"
    }
  },
  {
    "oid": "5a65e98a66d4628dd95a0d9602370390eb364039",
    "message": "[fix][broker] Fix deadlock while skip non-recoverable ledgers. (#21915)\n\n### Motivation\r\nThe sequence of events leading to the deadlock when methods from org.apache.bookkeeper.mledger.impl.ManagedCursorImpl are invoked concurrently is as follows:\r\n\r\n1. Thread A calls asyncDelete, which then goes on to internally call internalAsyncMarkDelete. This results in acquiring a lock on pendingMarkDeleteOps through synchronized (pendingMarkDeleteOps).\r\n\r\n2. Inside internalAsyncMarkDelete, internalMarkDelete is called which subsequently calls persistPositionToLedger. At the start of persistPositionToLedger, buildIndividualDeletedMessageRanges is invoked, where it tries to acquire a read lock using lock.readLock().lock(). At this point, if the write lock is being held by another thread, Thread A will block waiting for the read lock.\r\n\r\n3. Concurrently, Thread B executes skipNonRecoverableLedger which first obtains a write lock using lock.writeLock().lock() and then proceeds to call asyncDelete.\r\n\r\n4. At this moment, Thread B already holds the write lock and is attempting to acquire the synchronized lock on pendingMarkDeleteOps that Thread A already holds, while Thread A is waiting for the read lock that Thread B needs to release.\r\n\r\nIn code, the deadlock appears as follows:\r\n\r\nThread A: synchronized (pendingMarkDeleteOps) -> lock.readLock().lock() (waiting)\r\nThread B: lock.writeLock().lock() -> synchronized (pendingMarkDeleteOps) (waiting)\r\n\r\n### Modifications\r\n\r\nAvoid using a long-range lock.\r\n\r\nCo-authored-by: ruihongzhou <ruihongzhou@tencent.com>\r\nCo-authored-by: Jiwe Guo <technoboy@apache.org>\r\nCo-authored-by: Lari Hotari <lhotari@apache.org>",
    "date": "2024-01-22T06:23:53Z",
    "url": "https://github.com/apache/pulsar/commit/5a65e98a66d4628dd95a0d9602370390eb364039",
    "details": {
      "sha": "03f0b24a635338483f6dc464e60be6975625cac4",
      "filename": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java",
      "status": "modified",
      "additions": 15,
      "deletions": 21,
      "changes": 36,
      "blob_url": "https://github.com/apache/pulsar/blob/5a65e98a66d4628dd95a0d9602370390eb364039/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedCursorImpl.java",
      "raw_url": "https://github.com/apache/pulsar/raw/5a65e98a66d4628dd95a0d9602370390eb364039/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedCursorImpl.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedCursorImpl.java?ref=5a65e98a66d4628dd95a0d9602370390eb364039",
      "patch": "@@ -59,6 +59,7 @@\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n import java.util.function.Function;\n import java.util.function.Predicate;\n+import java.util.stream.LongStream;\n import org.apache.bookkeeper.client.AsyncCallback.CloseCallback;\n import org.apache.bookkeeper.client.AsyncCallback.OpenCallback;\n import org.apache.bookkeeper.client.BKException;\n@@ -2793,30 +2794,23 @@ public void skipNonRecoverableLedger(final long ledgerId){\n         if (ledgerInfo == null) {\n             return;\n         }\n-        lock.writeLock().lock();\n         log.warn(\"[{}] [{}] Since the ledger [{}] is lost and the autoSkipNonRecoverableData is true, this ledger will\"\n                 + \" be auto acknowledge in subscription\", ledger.getName(), name, ledgerId);\n-        try {\n-            for (int i = 0; i < ledgerInfo.getEntries(); i++) {\n-                if (!individualDeletedMessages.contains(ledgerId, i)) {\n-                    asyncDelete(PositionImpl.get(ledgerId, i), new AsyncCallbacks.DeleteCallback() {\n-                        @Override\n-                        public void deleteComplete(Object ctx) {\n-                            // ignore.\n-                        }\n+        asyncDelete(() -> LongStream.range(0, ledgerInfo.getEntries())\n+                        .mapToObj(i -> (Position) PositionImpl.get(ledgerId, i)).iterator(),\n+                new AsyncCallbacks.DeleteCallback() {\n+                    @Override\n+                    public void deleteComplete(Object ctx) {\n+                        // ignore.\n+                    }\n \n-                        @Override\n-                        public void deleteFailed(ManagedLedgerException ex, Object ctx) {\n-                            // The method internalMarkDelete already handled the failure operation. We only need to\n-                            // make sure the memory state is updated.\n-                            // If the broker crashed, the non-recoverable ledger will be detected again.\n-                        }\n-                    }, null);\n-                }\n-            }\n-        } finally {\n-            lock.writeLock().unlock();\n-        }\n+                    @Override\n+                    public void deleteFailed(ManagedLedgerException ex, Object ctx) {\n+                        // The method internalMarkDelete already handled the failure operation. We only need to\n+                        // make sure the memory state is updated.\n+                        // If the broker crashed, the non-recoverable ledger will be detected again.\n+                    }\n+                }, null);\n     }\n \n     // //////////////////////////////////////////////////",
      "parent_sha": "153cd5e429fdfbde1266b07f57de692805fed538"
    }
  },
  {
    "oid": "cb306c8e6c5da3a05ea312a5e5746eb178d9ab10",
    "message": "[fix] [broker] Make the service name resolver cache of PulsarWebResource expire after access (#19532)",
    "date": "2023-02-16T09:07:32Z",
    "url": "https://github.com/apache/pulsar/commit/cb306c8e6c5da3a05ea312a5e5746eb178d9ab10",
    "details": {
      "sha": "5484a70e1aad07d26166c4adabc861c36d0fd66c",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/web/PulsarWebResource.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/pulsar/blob/cb306c8e6c5da3a05ea312a5e5746eb178d9ab10/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fweb%2FPulsarWebResource.java",
      "raw_url": "https://github.com/apache/pulsar/raw/cb306c8e6c5da3a05ea312a5e5746eb178d9ab10/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fweb%2FPulsarWebResource.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fweb%2FPulsarWebResource.java?ref=cb306c8e6c5da3a05ea312a5e5746eb178d9ab10",
      "patch": "@@ -103,7 +103,7 @@ public abstract class PulsarWebResource {\n     private static final Logger log = LoggerFactory.getLogger(PulsarWebResource.class);\n \n     private static final LoadingCache<String, PulsarServiceNameResolver> SERVICE_NAME_RESOLVER_CACHE =\n-            Caffeine.newBuilder().expireAfterWrite(Duration.ofMinutes(5)).build(\n+            Caffeine.newBuilder().expireAfterAccess(Duration.ofMinutes(5)).build(\n                     new CacheLoader<>() {\n                         @Override\n                         public @Nullable PulsarServiceNameResolver load(@NonNull String serviceUrl) throws Exception {",
      "parent_sha": "b7b2053b4e4342a16d5ac9ee5ca02b4ff8571564"
    }
  },
  {
    "oid": "d4ca1ff357585136d4c05068770f17874dca557c",
    "message": "[Proxy] set default httpProxyTimeout to 5 minutes (#12299)",
    "date": "2021-10-08T08:08:09Z",
    "url": "https://github.com/apache/pulsar/commit/d4ca1ff357585136d4c05068770f17874dca557c",
    "details": {
      "sha": "0573670e993aebe98858dc1c9a48727c9bfbf7e4",
      "filename": "pulsar-proxy/src/main/java/org/apache/pulsar/proxy/server/ProxyConfiguration.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/pulsar/blob/d4ca1ff357585136d4c05068770f17874dca557c/pulsar-proxy%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fproxy%2Fserver%2FProxyConfiguration.java",
      "raw_url": "https://github.com/apache/pulsar/raw/d4ca1ff357585136d4c05068770f17874dca557c/pulsar-proxy%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fproxy%2Fserver%2FProxyConfiguration.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-proxy%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fproxy%2Fserver%2FProxyConfiguration.java?ref=d4ca1ff357585136d4c05068770f17874dca557c",
      "patch": "@@ -496,7 +496,7 @@ public class ProxyConfiguration implements PulsarConfiguration {\n             doc = \"Http proxy timeout.\\n\\n\"\n                     + \"The timeout value for HTTP proxy is in millisecond.\"\n     )\n-    private int httpProxyTimeout = 30 * 1000;\n+    private int httpProxyTimeout = 5 * 60 * 1000;\n \n     @FieldContext(\n            minValue = 1,",
      "parent_sha": "3545a29b34d91272f9de3af76c521acad0759eeb"
    }
  },
  {
    "oid": "894146af259de25390906c0ae34e89451d55306a",
    "message": "In PulsarKafkaProducer use flush() from pulsar API (#3549)",
    "date": "2019-02-11T03:45:36Z",
    "url": "https://github.com/apache/pulsar/commit/894146af259de25390906c0ae34e89451d55306a",
    "details": {
      "sha": "3fd00c2955d40a00fea49cbef782b72fc7cca43f",
      "filename": "pulsar-client-kafka-compat/pulsar-client-kafka/src/main/java/org/apache/kafka/clients/producer/PulsarKafkaProducer.java",
      "status": "modified",
      "additions": 6,
      "deletions": 17,
      "changes": 23,
      "blob_url": "https://github.com/apache/pulsar/blob/894146af259de25390906c0ae34e89451d55306a/pulsar-client-kafka-compat%2Fpulsar-client-kafka%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fkafka%2Fclients%2Fproducer%2FPulsarKafkaProducer.java",
      "raw_url": "https://github.com/apache/pulsar/raw/894146af259de25390906c0ae34e89451d55306a/pulsar-client-kafka-compat%2Fpulsar-client-kafka%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fkafka%2Fclients%2Fproducer%2FPulsarKafkaProducer.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-client-kafka-compat%2Fpulsar-client-kafka%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fkafka%2Fclients%2Fproducer%2FPulsarKafkaProducer.java?ref=894146af259de25390906c0ae34e89451d55306a",
      "patch": "@@ -32,6 +32,7 @@\n import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n \n import org.apache.kafka.common.Cluster;\n import org.apache.kafka.common.Metric;\n@@ -66,9 +67,6 @@ public class PulsarKafkaProducer<K, V> implements Producer<K, V> {\n     private final Partitioner partitioner;\n     private volatile Cluster cluster = Cluster.empty();\n \n-    /** Map that contains the last future for each producer */\n-    private final ConcurrentMap<String, CompletableFuture<MessageId>> lastSendFuture = new ConcurrentHashMap<>();\n-\n     public PulsarKafkaProducer(Map<String, Object> configs) {\n         this(configs, null, null);\n     }\n@@ -174,10 +172,7 @@ public Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callbac\n         int messageSize = buildMessage(messageBuilder, record);;\n \n         CompletableFuture<RecordMetadata> future = new CompletableFuture<>();\n-        CompletableFuture<MessageId> sendFuture = messageBuilder.sendAsync();\n-        lastSendFuture.put(record.topic(), sendFuture);\n-\n-        sendFuture.thenAccept((messageId) -> {\n+        messageBuilder.sendAsync().thenAccept((messageId) -> {\n             future.complete(getRecordMetadata(record.topic(), messageBuilder, messageId, messageSize));\n         }).exceptionally(ex -> {\n             future.completeExceptionally(ex);\n@@ -197,16 +192,10 @@ public Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callbac\n \n     @Override\n     public void flush() {\n-        lastSendFuture.forEach((topic, future) -> {\n-            try {\n-                future.get();\n-            } catch (InterruptedException | ExecutionException e) {\n-                throw new RuntimeException(e);\n-            }\n-\n-            // Remove the futures to remove eventually failed operations in order to trigger errors only once\n-            lastSendFuture.remove(topic, future);\n-        });\n+        producers.values().stream()\n+                .map(p -> p.flushAsync())\n+                .collect(Collectors.toList())\n+                .forEach(CompletableFuture::join);\n     }\n \n     @Override",
      "parent_sha": "1b44aaa78743f8dce68ffe31c25619123c9a5a5f"
    }
  },
  {
    "oid": "b17982d81e63336ce4696537fa1e6ba6cfaa9d7f",
    "message": "Fix some typos (#13715)\n\n**Motivation**\r\nFix some typos.\r\n\r\nCo-authored-by: Prashant Kumar <prashantk@splunk.com>\r\nCo-authored-by: ZhangJian He <shoothzj@gmail.com>",
    "date": "2022-02-28T05:00:26Z",
    "url": "https://github.com/apache/pulsar/commit/b17982d81e63336ce4696537fa1e6ba6cfaa9d7f",
    "details": {
      "sha": "382a3ccdf4aa14ec95aff97d827b48617210eacf",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/namespace/OwnershipCache.java",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/apache/pulsar/blob/b17982d81e63336ce4696537fa1e6ba6cfaa9d7f/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fnamespace%2FOwnershipCache.java",
      "raw_url": "https://github.com/apache/pulsar/raw/b17982d81e63336ce4696537fa1e6ba6cfaa9d7f/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fnamespace%2FOwnershipCache.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fnamespace%2FOwnershipCache.java?ref=b17982d81e63336ce4696537fa1e6ba6cfaa9d7f",
      "patch": "@@ -177,7 +177,8 @@ public CompletableFuture<Optional<NamespaceEphemeralData>> getOwnerAsync(Namespa\n     }\n \n     /**\n-     * Method to get the current owner of the <code>ServiceUnit</code> or set the local broker as the owner if absent.\n+     * Method to get the current owner of the <code>NamespaceBundle</code>\n+     * or set the local broker as the owner if absent.\n      *\n      * @param bundle\n      *            the <code>NamespaceBundle</code>\n@@ -187,12 +188,12 @@ public CompletableFuture<Optional<NamespaceEphemeralData>> getOwnerAsync(Namespa\n     public CompletableFuture<NamespaceEphemeralData> tryAcquiringOwnership(NamespaceBundle bundle) throws Exception {\n         if (!refreshSelfOwnerInfo()) {\n             return FutureUtil.failedFuture(\n-                    new RuntimeException(\"Namespace service does not ready for acquiring ownership\"));\n+                    new RuntimeException(\"Namespace service is not ready for acquiring ownership\"));\n         }\n \n         LOG.info(\"Trying to acquire ownership of {}\", bundle);\n \n-        // Doing a get() on the ownedBundlesCache will trigger an async metatada write to acquire the lock over the\n+        // Doing a get() on the ownedBundlesCache will trigger an async metadata write to acquire the lock over the\n         // service unit\n         return ownedBundlesCache.get(bundle)\n                 .thenApply(namespaceBundle -> {",
      "parent_sha": "deafd19066366226bb992d3ce53cca51fb6bdfdb"
    }
  },
  {
    "oid": "e2bf486287e7392fa2ff0edde0e7ad631f828132",
    "message": "Allow topic compaction to be disabled in Pulsar Functions (#7677)\n\nCo-authored-by: Jerry Peng <jerryp@splunk.com>",
    "date": "2020-07-28T17:11:26Z",
    "url": "https://github.com/apache/pulsar/commit/e2bf486287e7392fa2ff0edde0e7ad631f828132",
    "details": {
      "sha": "b1ac384a2f0c8aa38cc9d3816046e7146fe70107",
      "filename": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/SchedulerManager.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/apache/pulsar/blob/e2bf486287e7392fa2ff0edde0e7ad631f828132/pulsar-functions%2Fworker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Fworker%2FSchedulerManager.java",
      "raw_url": "https://github.com/apache/pulsar/raw/e2bf486287e7392fa2ff0edde0e7ad631f828132/pulsar-functions%2Fworker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Fworker%2FSchedulerManager.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-functions%2Fworker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Fworker%2FSchedulerManager.java?ref=e2bf486287e7392fa2ff0edde0e7ad631f828132",
      "patch": "@@ -189,7 +189,9 @@ public synchronized void initialize() {\n                     new LinkedBlockingQueue<>(5));\n             executorService.setThreadFactory(new ThreadFactoryBuilder().setNameFormat(\"worker-scheduler-%d\").build());\n             scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(new DefaultThreadFactory(\"worker-assignment-topic-compactor\"));\n-            scheduleCompaction(this.scheduledExecutorService, workerConfig.getTopicCompactionFrequencySec());\n+            if (workerConfig.getTopicCompactionFrequencySec() > 0) {\n+                scheduleCompaction(this.scheduledExecutorService, workerConfig.getTopicCompactionFrequencySec());\n+            }\n \n             isRunning = true;\n             lastMessageProduced = null;",
      "parent_sha": "fffd9f144bb14a220d17e951fea29b16ad2db103"
    }
  },
  {
    "oid": "cf045e4152bbe54eabdc1bb29888f071c3fe563d",
    "message": "Handle KeeperException.BadVersionException thrown by updateSchemaLocator() (#6683)\n\nCo-authored-by: Sijie Guo <sijie@apache.org>",
    "date": "2020-04-08T17:34:19Z",
    "url": "https://github.com/apache/pulsar/commit/cf045e4152bbe54eabdc1bb29888f071c3fe563d",
    "details": {
      "sha": "df41e717ceee030a8e03143dd9962e675e9e46c3",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/schema/BookkeeperSchemaStorage.java",
      "status": "modified",
      "additions": 23,
      "deletions": 1,
      "changes": 24,
      "blob_url": "https://github.com/apache/pulsar/blob/cf045e4152bbe54eabdc1bb29888f071c3fe563d/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2Fschema%2FBookkeeperSchemaStorage.java",
      "raw_url": "https://github.com/apache/pulsar/raw/cf045e4152bbe54eabdc1bb29888f071c3fe563d/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2Fschema%2FBookkeeperSchemaStorage.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2Fschema%2FBookkeeperSchemaStorage.java?ref=cf045e4152bbe54eabdc1bb29888f071c3fe563d",
      "patch": "@@ -264,7 +264,29 @@ private CompletableFuture<Long> putSchema(String schemaId, byte[] data, byte[] h\n                 //don't check the schema whether already exist\n                 return readSchemaEntry(locator.getIndexList().get(0).getPosition())\n                         .thenCompose(schemaEntry -> addNewSchemaEntryToStore(schemaId, locator.getIndexList(), data).thenCompose(\n-                        position -> updateSchemaLocator(schemaId, optLocatorEntry.get(), position, hash)));\n+                        position -> {\n+                            CompletableFuture<Long> future = new CompletableFuture<>();\n+                            updateSchemaLocator(schemaId, optLocatorEntry.get(), position, hash)\n+                                    .thenAccept(future::complete)\n+                                    .exceptionally(ex -> {\n+                                        if (ex.getCause() instanceof KeeperException.BadVersionException) {\n+                                            // There was a race condition on the schema creation. Since it has now been created,\n+                                            // retry the whole operation so that we have a chance to recover without bubbling error\n+                                            putSchema(schemaId, data, hash)\n+                                                    .thenAccept(future::complete)\n+                                                    .exceptionally(ex2 -> {\n+                                                        future.completeExceptionally(ex2);\n+                                                        return null;\n+                                                    });\n+                                        } else {\n+                                            // For other errors, just fail the operation\n+                                            future.completeExceptionally(ex);\n+                                        }\n+                                        return null;\n+                                    });\n+                            return future;\n+                        })\n+                );\n             } else {\n                 // No schema was defined yet\n                 CompletableFuture<Long> future = new CompletableFuture<>();",
      "parent_sha": "5663acb68e905ab0634a80748a44c7c9b9c0a8a9"
    }
  },
  {
    "oid": "25d4c5559eb14c0a4a47d7f5c6fa48324442051c",
    "message": "unacked messages should always be changed even if BlockConsumerOnUnackMsgs is disabled (#96)",
    "date": "2016-11-01T16:59:53Z",
    "url": "https://github.com/apache/pulsar/commit/25d4c5559eb14c0a4a47d7f5c6fa48324442051c",
    "details": {
      "sha": "a6aaad0b0edf1e373e58025349542e6f76b36365",
      "filename": "pulsar-broker/src/main/java/com/yahoo/pulsar/broker/service/Consumer.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/apache/pulsar/blob/25d4c5559eb14c0a4a47d7f5c6fa48324442051c/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Fcom%2Fyahoo%2Fpulsar%2Fbroker%2Fservice%2FConsumer.java",
      "raw_url": "https://github.com/apache/pulsar/raw/25d4c5559eb14c0a4a47d7f5c6fa48324442051c/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Fcom%2Fyahoo%2Fpulsar%2Fbroker%2Fservice%2FConsumer.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Fcom%2Fyahoo%2Fpulsar%2Fbroker%2Fservice%2FConsumer.java?ref=25d4c5559eb14c0a4a47d7f5c6fa48324442051c",
      "patch": "@@ -181,7 +181,7 @@ public Pair<ChannelPromise, Integer> sendMessages(final List<Entry> entries) {\n     }\n \n     private void incrementUnackedMessages(int ackedMessages) {\n-        if (shouldBlockConsumerOnUnackMsgs() && unackedMessages.addAndGet(ackedMessages) >= maxUnackedMessages) {\n+        if (unackedMessages.addAndGet(ackedMessages) >= maxUnackedMessages && shouldBlockConsumerOnUnackMsgs()) {\n             blockedConsumerOnUnackedMsgs = true;\n         }\n     }\n@@ -432,9 +432,9 @@ private void removePendingAcks(PositionImpl position) {\n             int totalAckedMsgs = ackOwnedConsumer.getPendingAcks().remove(position);\n             // unblock consumer-throttling when receives half of maxUnackedMessages => consumer can start again\n             // consuming messages\n-            if (ackOwnedConsumer.shouldBlockConsumerOnUnackMsgs()\n-                    && ((ackOwnedConsumer.unackedMessages.addAndGet(-totalAckedMsgs) <= (maxUnackedMessages / 2))\n-                            && ackOwnedConsumer.blockedConsumerOnUnackedMsgs)) {\n+            if (((ackOwnedConsumer.unackedMessages.addAndGet(-totalAckedMsgs) <= (maxUnackedMessages / 2))\n+                    && ackOwnedConsumer.blockedConsumerOnUnackedMsgs)\n+                    && ackOwnedConsumer.shouldBlockConsumerOnUnackMsgs()) {\n                 ackOwnedConsumer.blockedConsumerOnUnackedMsgs = false;\n                 flowConsumerBlockedPermits(ackOwnedConsumer);\n             }",
      "parent_sha": "5e55d799c7b6ea23f86950f63f571bf8e81ca07f"
    }
  },
  {
    "oid": "e2851da923a729423de54dc3a95d1e7a43b6e08a",
    "message": "[fix] [ml] The atomicity of multiple fields of ml is broken (#19346)",
    "date": "2023-01-29T15:09:44Z",
    "url": "https://github.com/apache/pulsar/commit/e2851da923a729423de54dc3a95d1e7a43b6e08a",
    "details": {
      "sha": "f6c9fb3bfd806b868e41987293d838752fb15619",
      "filename": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedLedgerImpl.java",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/apache/pulsar/blob/e2851da923a729423de54dc3a95d1e7a43b6e08a/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedLedgerImpl.java",
      "raw_url": "https://github.com/apache/pulsar/raw/e2851da923a729423de54dc3a95d1e7a43b6e08a/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedLedgerImpl.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedLedgerImpl.java?ref=e2851da923a729423de54dc3a95d1e7a43b6e08a",
      "patch": "@@ -1554,16 +1554,16 @@ public void operationComplete(Void v, Stat stat) {\n                         log.debug(\"[{}] Updating of ledgers list after create complete. version={}\", name, stat);\n                     }\n                     ledgersStat = stat;\n-                    ledgers.put(lh.getId(), newLedger);\n-                    currentLedger = lh;\n-                    currentLedgerEntries = 0;\n-                    currentLedgerSize = 0;\n-                    metadataMutex.unlock();\n-                    updateLedgersIdsComplete();\n                     synchronized (ManagedLedgerImpl.this) {\n+                        ledgers.put(lh.getId(), newLedger);\n+                        currentLedger = lh;\n+                        currentLedgerEntries = 0;\n+                        currentLedgerSize = 0;\n+                        updateLedgersIdsComplete();\n                         mbean.addLedgerSwitchLatencySample(System.currentTimeMillis()\n                                 - lastLedgerCreationInitiationTimestamp, TimeUnit.MILLISECONDS);\n                     }\n+                    metadataMutex.unlock();\n \n                     // May need to update the cursor position\n                     maybeUpdateCursorBeforeTrimmingConsumedLedger();",
      "parent_sha": "8ea41f1493ce9f1856008b62899653f3bdd29a1e"
    }
  },
  {
    "oid": "89a808cf88d10c8380e69ef129ad9f593d0b5eae",
    "message": "Fix null error messages of onFailure exception in KinesisSink. (#10416)",
    "date": "2021-04-28T10:06:00Z",
    "url": "https://github.com/apache/pulsar/commit/89a808cf88d10c8380e69ef129ad9f593d0b5eae",
    "details": {
      "sha": "868233222e391f1ed52534753201e0f45c50dced",
      "filename": "pulsar-io/kinesis/src/main/java/org/apache/pulsar/io/kinesis/KinesisSink.java",
      "status": "modified",
      "additions": 14,
      "deletions": 2,
      "changes": 16,
      "blob_url": "https://github.com/apache/pulsar/blob/89a808cf88d10c8380e69ef129ad9f593d0b5eae/pulsar-io%2Fkinesis%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fio%2Fkinesis%2FKinesisSink.java",
      "raw_url": "https://github.com/apache/pulsar/raw/89a808cf88d10c8380e69ef129ad9f593d0b5eae/pulsar-io%2Fkinesis%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fio%2Fkinesis%2FKinesisSink.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-io%2Fkinesis%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fio%2Fkinesis%2FKinesisSink.java?ref=89a808cf88d10c8380e69ef129ad9f593d0b5eae",
      "patch": "@@ -28,6 +28,7 @@\n import com.amazonaws.services.kinesis.producer.KinesisProducer;\n import com.amazonaws.services.kinesis.producer.KinesisProducerConfiguration;\n import com.amazonaws.services.kinesis.producer.KinesisProducerConfiguration.ThreadingModel;\n+import com.amazonaws.services.kinesis.producer.UserRecordFailedException;\n import com.amazonaws.services.kinesis.producer.UserRecordResult;\n import com.google.common.util.concurrent.FutureCallback;\n import com.google.common.util.concurrent.ListenableFuture;\n@@ -226,8 +227,19 @@ public void onSuccess(UserRecordResult result) {\n \n         @Override\n         public void onFailure(Throwable exception) {\n-            LOG.error(\"[{}] Failed to published message for replicator of {}-{}, {} \", kinesisSink.streamName,\n-                    resultContext.getPartitionId(), resultContext.getRecordSequence(), exception.getMessage());\n+            if (exception instanceof UserRecordFailedException) {\n+                // If the exception is UserRecordFailedException, we need to extract it to see real error messages.\n+                UserRecordFailedException failedException = (UserRecordFailedException) exception;\n+                StringBuffer stringBuffer = new StringBuffer();\n+                failedException.getResult().getAttempts().forEach(attempt ->\n+                        stringBuffer.append(String.format(\"errorMessage:%s, errorCode:%s, delay:%d, duration:%d;\",\n+                                attempt.getErrorMessage(), attempt.getErrorCode(), attempt.getDelay(), attempt.getDuration())));\n+                LOG.error(\"[{}] Failed to published message for replicator of {}-{}: Attempts:{}\", kinesisSink.streamName,\n+                        resultContext.getPartitionId(), resultContext.getRecordSequence(), stringBuffer.toString());\n+            } else {\n+                LOG.error(\"[{}] Failed to published message for replicator of {}-{}, {} \", kinesisSink.streamName,\n+                        resultContext.getPartitionId(), resultContext.getRecordSequence(), exception.getMessage());\n+            }\n             kinesisSink.previousPublishFailed = TRUE;\n             if (kinesisSink.sinkContext != null) {\n                 kinesisSink.sinkContext.recordMetric(METRICS_TOTAL_FAILURE, 1);",
      "parent_sha": "fef5a4f0d04148e50f4a046d0de358cf875a83c3"
    }
  },
  {
    "oid": "26d569b9a894b1ab051bdf215cb99a107f8abee5",
    "message": "Avoid get partition metadata while the topic name is a partition name. (#6339)\n\nMotivation\r\n\r\nTo avoid get partition metadata while the topic name is a partition name.\r\nCurrently, if users want to skip all messages for a partitioned topic or unload a partitioned topic, the broker will call get topic metadata many times. For a topic with the partition name, it is not necessary to call get partitioned topic metadata again.",
    "date": "2020-02-17T10:02:43Z",
    "url": "https://github.com/apache/pulsar/commit/26d569b9a894b1ab051bdf215cb99a107f8abee5",
    "details": {
      "sha": "503b21b430d58eb4ea4efc1e44d3e6fe5b37b412",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java",
      "status": "modified",
      "additions": 493,
      "deletions": 441,
      "changes": 934,
      "blob_url": "https://github.com/apache/pulsar/blob/26d569b9a894b1ab051bdf215cb99a107f8abee5/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2Fimpl%2FPersistentTopicsBase.java",
      "raw_url": "https://github.com/apache/pulsar/raw/26d569b9a894b1ab051bdf215cb99a107f8abee5/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2Fimpl%2FPersistentTopicsBase.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2Fimpl%2FPersistentTopicsBase.java?ref=26d569b9a894b1ab051bdf215cb99a107f8abee5",
      "patch": "@@ -638,19 +638,15 @@ protected void internalDeletePartitionedTopic(AsyncResponse asyncResponse, boole\n                 zkSync(path);\n                 log.info(\"[{}] Deleted partitioned topic {}\", clientAppId(), topicName);\n                 asyncResponse.resume(Response.noContent().build());\n-                return;\n             } catch (KeeperException.NoNodeException nne) {\n                 asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Partitioned topic does not exist\"));\n-                return;\n             } catch (KeeperException.BadVersionException e) {\n                 log.warn(\"[{}] Failed to delete partitioned topic {}: concurrent modification\", clientAppId(),\n                         topicName);\n                 asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n-                return;\n             } catch (Exception e) {\n                 log.error(\"[{}] Failed to delete partitioned topic {}\", clientAppId(), topicName, e);\n                 asyncResponse.resume(new RestException(e));\n-                return;\n             }\n         });\n     }\n@@ -660,57 +656,65 @@ protected void internalUnloadTopic(AsyncResponse asyncResponse, boolean authorit\n         if (topicName.isGlobal()) {\n             validateGlobalNamespaceOwnership(namespaceName);\n         }\n-\n-        getPartitionedTopicMetadataAsync(topicName, authoritative, false).whenComplete((meta, t) -> {\n-            if (meta.partitions > 0) {\n-                final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n-\n-                for (int i = 0; i < meta.partitions; i++) {\n-                    TopicName topicNamePartition = topicName.getPartition(i);\n-                    try {\n-                        futures.add(pulsar().getAdminClient().topics().unloadAsync(topicNamePartition.toString()));\n-                    } catch (Exception e) {\n-                        log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicNamePartition, e);\n-                        asyncResponse.resume(new RestException(e));\n-                        return;\n+        // If the topic name is a partition name, no need to get partition topic metadata again\n+        if (topicName.isPartitioned()) {\n+            internalUnloadNonPartitionedTopic(asyncResponse, authoritative);\n+        } else {\n+            getPartitionedTopicMetadataAsync(topicName, authoritative, false).whenComplete((meta, t) -> {\n+                if (meta.partitions > 0) {\n+                    final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n+\n+                    for (int i = 0; i < meta.partitions; i++) {\n+                        TopicName topicNamePartition = topicName.getPartition(i);\n+                        try {\n+                            futures.add(pulsar().getAdminClient().topics().unloadAsync(topicNamePartition.toString()));\n+                        } catch (Exception e) {\n+                            log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicNamePartition, e);\n+                            asyncResponse.resume(new RestException(e));\n+                            return;\n+                        }\n                     }\n-                }\n \n-                FutureUtil.waitForAll(futures).handle((result, exception) -> {\n-                    if (exception != null) {\n-                        Throwable th = exception.getCause();\n-                        if (th instanceof NotFoundException) {\n-                            asyncResponse.resume(new RestException(Status.NOT_FOUND, th.getMessage()));\n-                        } else {\n-                            log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicName, exception);\n-                            asyncResponse.resume(new RestException(exception));\n+                    FutureUtil.waitForAll(futures).handle((result, exception) -> {\n+                        if (exception != null) {\n+                            Throwable th = exception.getCause();\n+                            if (th instanceof NotFoundException) {\n+                                asyncResponse.resume(new RestException(Status.NOT_FOUND, th.getMessage()));\n+                            } else {\n+                                log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicName, exception);\n+                                asyncResponse.resume(new RestException(exception));\n+                            }\n+                            return null;\n                         }\n+\n+                        asyncResponse.resume(Response.noContent().build());\n                         return null;\n-                    }\n+                    });\n+                } else {\n+                    internalUnloadNonPartitionedTopic(asyncResponse, authoritative);\n+                }\n+            }).exceptionally(t -> {\n+                Throwable th = t.getCause();\n+                asyncResponse.resume(new RestException(th));\n+                return null;\n+            });\n+        }\n+    }\n \n-                    asyncResponse.resume(Response.noContent().build());\n-                    return null;\n-                });\n-            } else {\n-                validateAdminAccessForTenant(topicName.getTenant());\n-                validateTopicOwnership(topicName, authoritative);\n+    private void internalUnloadNonPartitionedTopic(AsyncResponse asyncResponse, boolean authoritative) {\n+        validateAdminAccessForTenant(topicName.getTenant());\n+        validateTopicOwnership(topicName, authoritative);\n \n-                Topic topic = getTopicReference(topicName);\n-                topic.close(false).whenComplete((r, ex) -> {\n-                    if (ex != null) {\n-                        log.error(\"[{}] Failed to unload topic {}, {}\", clientAppId(), topicName, ex.getMessage(), ex);\n-                        asyncResponse.resume(new RestException(ex));\n+        Topic topic = getTopicReference(topicName);\n+        topic.close(false).whenComplete((r, ex) -> {\n+            if (ex != null) {\n+                log.error(\"[{}] Failed to unload topic {}, {}\", clientAppId(), topicName, ex.getMessage(), ex);\n+                asyncResponse.resume(new RestException(ex));\n \n-                    } else {\n-                        log.info(\"[{}] Successfully unloaded topic {}\", clientAppId(), topicName);\n-                        asyncResponse.resume(Response.noContent().build());\n-                    }\n-                });\n+            } else {\n+                log.info(\"[{}] Successfully unloaded topic {}\", clientAppId(), topicName);\n+                asyncResponse.resume(Response.noContent().build());\n             }\n-        }).exceptionally(t -> {\n-            Throwable th = t.getCause();\n-            asyncResponse.resume(new RestException(th));\n-            return null;\n         });\n     }\n \n@@ -753,25 +757,26 @@ protected void internalGetSubscriptions(AsyncResponse asyncResponse, boolean aut\n         if (topicName.isGlobal()) {\n             validateGlobalNamespaceOwnership(namespaceName);\n         }\n-\n-        final List<String> subscriptions = Lists.newArrayList();\n-\n-        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-        if (partitionMetadata.partitions > 0) {\n-            try {\n-                // get the subscriptions only from the 1st partition since all the other partitions will have the same\n-                // subscriptions\n-                pulsar().getAdminClient().topics().getSubscriptionsAsync(topicName.getPartition(0).toString())\n+        // If the topic name is a partition name, no need to get partition topic metadata again\n+        if (topicName.isPartitioned()) {\n+            internalGetSubscriptionsForNonPartitionedTopic(asyncResponse, authoritative);\n+        } else {\n+            PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n+            if (partitionMetadata.partitions > 0) {\n+                try {\n+                    // get the subscriptions only from the 1st partition since all the other partitions will have the same\n+                    // subscriptions\n+                    pulsar().getAdminClient().topics().getSubscriptionsAsync(topicName.getPartition(0).toString())\n                         .whenComplete((r, ex) -> {\n                             if (ex != null) {\n                                 log.warn(\"[{}] Failed to get list of subscriptions for {}: {}\", clientAppId(),\n-                                        topicName, ex.getMessage());\n+                                    topicName, ex.getMessage());\n \n                                 if (ex instanceof PulsarAdminException) {\n                                     PulsarAdminException pae = (PulsarAdminException) ex;\n                                     if (pae.getStatusCode() == Status.NOT_FOUND.getStatusCode()) {\n                                         asyncResponse.resume(new RestException(Status.NOT_FOUND,\n-                                                \"Internal topics have not been generated yet\"));\n+                                            \"Internal topics have not been generated yet\"));\n                                         return;\n                                     } else {\n                                         asyncResponse.resume(new RestException(pae));\n@@ -782,29 +787,34 @@ protected void internalGetSubscriptions(AsyncResponse asyncResponse, boolean aut\n                                     return;\n                                 }\n                             }\n-\n+                            final List<String> subscriptions = Lists.newArrayList();\n                             subscriptions.addAll(r);\n                             asyncResponse.resume(subscriptions);\n                             return;\n                         });\n-            } catch (Exception e) {\n-                log.error(\"[{}] Failed to get list of subscriptions for {}\", clientAppId(), topicName, e);\n-                asyncResponse.resume(e);\n-                return;\n+                } catch (Exception e) {\n+                    log.error(\"[{}] Failed to get list of subscriptions for {}\", clientAppId(), topicName, e);\n+                    asyncResponse.resume(e);\n+                    return;\n+                }\n+            } else {\n+                internalGetSubscriptionsForNonPartitionedTopic(asyncResponse, authoritative);\n             }\n-        } else {\n-            validateAdminOperationOnTopic(authoritative);\n-            Topic topic = getTopicReference(topicName);\n+        }\n+    }\n \n-            try {\n-                topic.getSubscriptions().forEach((subName, sub) -> subscriptions.add(subName));\n-                asyncResponse.resume(subscriptions);\n-                return;\n-            } catch (Exception e) {\n-                log.error(\"[{}] Failed to get list of subscriptions for {}\", clientAppId(), topicName, e);\n-                asyncResponse.resume(new RestException(e));\n-                return;\n-            }\n+    private void internalGetSubscriptionsForNonPartitionedTopic(AsyncResponse asyncResponse, boolean authoritative) {\n+        validateAdminOperationOnTopic(authoritative);\n+        Topic topic = getTopicReference(topicName);\n+        try {\n+            final List<String> subscriptions = Lists.newArrayList();\n+            topic.getSubscriptions().forEach((subName, sub) -> subscriptions.add(subName));\n+            asyncResponse.resume(subscriptions);\n+            return;\n+        } catch (Exception e) {\n+            log.error(\"[{}] Failed to get list of subscriptions for {}\", clientAppId(), topicName, e);\n+            asyncResponse.resume(new RestException(e));\n+            return;\n         }\n     }\n \n@@ -952,67 +962,72 @@ protected void internalDeleteSubscription(AsyncResponse asyncResponse, String su\n         if (topicName.isGlobal()) {\n             validateGlobalNamespaceOwnership(namespaceName);\n         }\n-        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-        if (partitionMetadata.partitions > 0) {\n-            final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n+        // If the topic name is a partition name, no need to get partition topic metadata again\n+        if (topicName.isPartitioned()) {\n+            internalDeleteSubscriptionForNonPartitionedTopic(asyncResponse, subName, authoritative);\n+        } else {\n+            PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n+            if (partitionMetadata.partitions > 0) {\n+                final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n \n-            for (int i = 0; i < partitionMetadata.partitions; i++) {\n-                TopicName topicNamePartition = topicName.getPartition(i);\n-                try {\n-                    futures.add(pulsar().getAdminClient().topics()\n+                for (int i = 0; i < partitionMetadata.partitions; i++) {\n+                    TopicName topicNamePartition = topicName.getPartition(i);\n+                    try {\n+                        futures.add(pulsar().getAdminClient().topics()\n                             .deleteSubscriptionAsync(topicNamePartition.toString(), subName));\n-                } catch (Exception e) {\n-                    log.error(\"[{}] Failed to delete subscription {} {}\", clientAppId(), topicNamePartition, subName,\n+                    } catch (Exception e) {\n+                        log.error(\"[{}] Failed to delete subscription {} {}\", clientAppId(), topicNamePartition, subName,\n                             e);\n-                    asyncResponse.resume(new RestException(e));\n-                    return;\n+                        asyncResponse.resume(new RestException(e));\n+                        return;\n+                    }\n                 }\n-            }\n \n-            FutureUtil.waitForAll(futures).handle((result, exception) -> {\n-                if (exception != null) {\n-                    Throwable t = exception.getCause();\n-                    if (t instanceof NotFoundException) {\n-                        asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n-                        return null;\n-                    } else if (t instanceof PreconditionFailedException) {\n-                        asyncResponse.resume(new RestException(Status.PRECONDITION_FAILED,\n+                FutureUtil.waitForAll(futures).handle((result, exception) -> {\n+                    if (exception != null) {\n+                        Throwable t = exception.getCause();\n+                        if (t instanceof NotFoundException) {\n+                            asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n+                            return null;\n+                        } else if (t instanceof PreconditionFailedException) {\n+                            asyncResponse.resume(new RestException(Status.PRECONDITION_FAILED,\n                                 \"Subscription has active connected consumers\"));\n-                        return null;\n-                    } else {\n-                        log.error(\"[{}] Failed to delete subscription {} {}\", clientAppId(), topicName, subName, t);\n-                        asyncResponse.resume(new RestException(t));\n-                        return null;\n+                            return null;\n+                        } else {\n+                            log.error(\"[{}] Failed to delete subscription {} {}\", clientAppId(), topicName, subName, t);\n+                            asyncResponse.resume(new RestException(t));\n+                            return null;\n+                        }\n                     }\n-                }\n \n-                asyncResponse.resume(Response.noContent().build());\n-                return null;\n-            });\n-        } else {\n-            validateAdminAccessForSubscriber(subName, authoritative);\n-            Topic topic = getTopicReference(topicName);\n-            try {\n-                Subscription sub = topic.getSubscription(subName);\n-                checkNotNull(sub);\n-                sub.delete().get();\n-                log.info(\"[{}][{}] Deleted subscription {}\", clientAppId(), topicName, subName);\n-                asyncResponse.resume(Response.noContent().build());\n-                return;\n-            } catch (Exception e) {\n-                Throwable t = e.getCause();\n-                if (e instanceof NullPointerException) {\n-                    asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n-                    return;\n-                } else if (t instanceof SubscriptionBusyException) {\n-                    asyncResponse.resume(new RestException(Status.PRECONDITION_FAILED,\n-                            \"Subscription has active connected consumers\"));\n-                    return;\n-                } else {\n-                    log.error(\"[{}] Failed to delete subscription {} {}\", clientAppId(), topicName, subName, e);\n-                    asyncResponse.resume(new RestException(t));\n-                    return;\n-                }\n+                    asyncResponse.resume(Response.noContent().build());\n+                    return null;\n+                });\n+            } else {\n+                internalDeleteSubscriptionForNonPartitionedTopic(asyncResponse, subName, authoritative);\n+            }\n+        }\n+    }\n+\n+    private void internalDeleteSubscriptionForNonPartitionedTopic(AsyncResponse asyncResponse, String subName, boolean authoritative) {\n+        validateAdminAccessForSubscriber(subName, authoritative);\n+        Topic topic = getTopicReference(topicName);\n+        try {\n+            Subscription sub = topic.getSubscription(subName);\n+            checkNotNull(sub);\n+            sub.delete().get();\n+            log.info(\"[{}][{}] Deleted subscription {}\", clientAppId(), topicName, subName);\n+            asyncResponse.resume(Response.noContent().build());\n+        } catch (Exception e) {\n+            Throwable t = e.getCause();\n+            if (e instanceof NullPointerException) {\n+                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n+            } else if (t instanceof SubscriptionBusyException) {\n+                asyncResponse.resume(new RestException(Status.PRECONDITION_FAILED,\n+                    \"Subscription has active connected consumers\"));\n+            } else {\n+                log.error(\"[{}] Failed to delete subscription {} {}\", clientAppId(), topicName, subName, e);\n+                asyncResponse.resume(new RestException(t));\n             }\n         }\n     }\n@@ -1021,67 +1036,76 @@ protected void internalSkipAllMessages(AsyncResponse asyncResponse, String subNa\n         if (topicName.isGlobal()) {\n             validateGlobalNamespaceOwnership(namespaceName);\n         }\n-        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-        if (partitionMetadata.partitions > 0) {\n-            final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n+        // If the topic name is a partition name, no need to get partition topic metadata again\n+        if (topicName.isPartitioned()) {\n+            internalSkipAllMessagesForNonPartitionedTopic(asyncResponse, subName, authoritative);\n+        } else {\n+            PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n+            if (partitionMetadata.partitions > 0) {\n+                final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n \n-            for (int i = 0; i < partitionMetadata.partitions; i++) {\n-                TopicName topicNamePartition = topicName.getPartition(i);\n-                try {\n-                    futures.add(pulsar().getAdminClient().topics().skipAllMessagesAsync(topicNamePartition.toString(),\n+                for (int i = 0; i < partitionMetadata.partitions; i++) {\n+                    TopicName topicNamePartition = topicName.getPartition(i);\n+                    try {\n+                        futures.add(pulsar().getAdminClient().topics().skipAllMessagesAsync(topicNamePartition.toString(),\n                             subName));\n-                } catch (Exception e) {\n-                    log.error(\"[{}] Failed to skip all messages {} {}\", clientAppId(), topicNamePartition, subName, e);\n-                    asyncResponse.resume(new RestException(e));\n-                    return;\n+                    } catch (Exception e) {\n+                        log.error(\"[{}] Failed to skip all messages {} {}\", clientAppId(), topicNamePartition, subName, e);\n+                        asyncResponse.resume(new RestException(e));\n+                        return;\n+                    }\n                 }\n-            }\n \n-            FutureUtil.waitForAll(futures).handle((result, exception) -> {\n-                if (exception != null) {\n-                    Throwable t = exception.getCause();\n-                    if (t instanceof NotFoundException) {\n-                        asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n-                        return null;\n-                    } else {\n-                        log.error(\"[{}] Failed to skip all messages {} {}\", clientAppId(), topicName, subName, t);\n-                        asyncResponse.resume(new RestException(t));\n-                        return null;\n+                FutureUtil.waitForAll(futures).handle((result, exception) -> {\n+                    if (exception != null) {\n+                        Throwable t = exception.getCause();\n+                        if (t instanceof NotFoundException) {\n+                            asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n+                            return null;\n+                        } else {\n+                            log.error(\"[{}] Failed to skip all messages {} {}\", clientAppId(), topicName, subName, t);\n+                            asyncResponse.resume(new RestException(t));\n+                            return null;\n+                        }\n                     }\n-                }\n \n-                asyncResponse.resume(Response.noContent().build());\n-                return null;\n-            });\n-        } else {\n-            validateAdminAccessForSubscriber(subName, authoritative);\n-            PersistentTopic topic = (PersistentTopic) getTopicReference(topicName);\n-            BiConsumer<Void, Throwable> biConsumer = (v, ex) -> {\n-                if (ex != null) {\n-                    asyncResponse.resume(new RestException(ex));\n-                    log.error(\"[{}] Failed to skip all messages {} {}\", clientAppId(), topicName, subName, ex);\n-                } else {\n                     asyncResponse.resume(Response.noContent().build());\n-                    log.info(\"[{}] Cleared backlog on {} {}\", clientAppId(), topicName, subName);\n-                }\n-            };\n-            try {\n-                if (subName.startsWith(topic.getReplicatorPrefix())) {\n-                    String remoteCluster = PersistentReplicator.getRemoteCluster(subName);\n-                    PersistentReplicator repl = (PersistentReplicator) topic.getPersistentReplicator(remoteCluster);\n-                    checkNotNull(repl);\n-                    repl.clearBacklog().whenComplete(biConsumer);\n-                } else {\n-                    PersistentSubscription sub = topic.getSubscription(subName);\n-                    checkNotNull(sub);\n-                    sub.clearBacklog().whenComplete(biConsumer);\n-                }\n-            } catch (Exception e) {\n-                if (e instanceof NullPointerException) {\n-                    asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n-                } else {\n-                    asyncResponse.resume(new RestException(e));\n-                }\n+                    return null;\n+                });\n+            } else {\n+                internalSkipAllMessagesForNonPartitionedTopic(asyncResponse, subName, authoritative);\n+            }\n+        }\n+    }\n+\n+    private void internalSkipAllMessagesForNonPartitionedTopic(AsyncResponse asyncResponse, String subName, boolean authoritative) {\n+        validateAdminAccessForSubscriber(subName, authoritative);\n+        PersistentTopic topic = (PersistentTopic) getTopicReference(topicName);\n+        BiConsumer<Void, Throwable> biConsumer = (v, ex) -> {\n+            if (ex != null) {\n+                asyncResponse.resume(new RestException(ex));\n+                log.error(\"[{}] Failed to skip all messages {} {}\", clientAppId(), topicName, subName, ex);\n+            } else {\n+                asyncResponse.resume(Response.noContent().build());\n+                log.info(\"[{}] Cleared backlog on {} {}\", clientAppId(), topicName, subName);\n+            }\n+        };\n+        try {\n+            if (subName.startsWith(topic.getReplicatorPrefix())) {\n+                String remoteCluster = PersistentReplicator.getRemoteCluster(subName);\n+                PersistentReplicator repl = (PersistentReplicator) topic.getPersistentReplicator(remoteCluster);\n+                checkNotNull(repl);\n+                repl.clearBacklog().whenComplete(biConsumer);\n+            } else {\n+                PersistentSubscription sub = topic.getSubscription(subName);\n+                checkNotNull(sub);\n+                sub.clearBacklog().whenComplete(biConsumer);\n+            }\n+        } catch (Exception e) {\n+            if (e instanceof NullPointerException) {\n+                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n+            } else {\n+                asyncResponse.resume(new RestException(e));\n             }\n         }\n     }\n@@ -1122,182 +1146,194 @@ protected void internalExpireMessagesForAllSubscriptions(AsyncResponse asyncResp\n         if (topicName.isGlobal()) {\n             validateGlobalNamespaceOwnership(namespaceName);\n         }\n-        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-        if (partitionMetadata.partitions > 0) {\n-            final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n+        // If the topic name is a partition name, no need to get partition topic metadata again\n+        if (topicName.isPartitioned()) {\n+            internalExpireMessagesForAllSubscriptionsForNonPartitionedTopic(asyncResponse, expireTimeInSeconds, authoritative);\n+        } else {\n+            PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n+            if (partitionMetadata.partitions > 0) {\n+                final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n \n-            // expire messages for each partition topic\n-            for (int i = 0; i < partitionMetadata.partitions; i++) {\n-                TopicName topicNamePartition = topicName.getPartition(i);\n-                try {\n-                    futures.add(pulsar().getAdminClient().topics().expireMessagesForAllSubscriptionsAsync(\n+                // expire messages for each partition topic\n+                for (int i = 0; i < partitionMetadata.partitions; i++) {\n+                    TopicName topicNamePartition = topicName.getPartition(i);\n+                    try {\n+                        futures.add(pulsar().getAdminClient().topics().expireMessagesForAllSubscriptionsAsync(\n                             topicNamePartition.toString(), expireTimeInSeconds));\n-                } catch (Exception e) {\n-                    log.error(\"[{}] Failed to expire messages up to {} on {}\", clientAppId(), expireTimeInSeconds,\n+                    } catch (Exception e) {\n+                        log.error(\"[{}] Failed to expire messages up to {} on {}\", clientAppId(), expireTimeInSeconds,\n                             topicNamePartition, e);\n-                    asyncResponse.resume(new RestException(e));\n-                    return;\n+                        asyncResponse.resume(new RestException(e));\n+                        return;\n+                    }\n                 }\n-            }\n \n-            FutureUtil.waitForAll(futures).handle((result, exception) -> {\n-                if (exception != null) {\n-                    Throwable t = exception.getCause();\n-                    log.error(\"[{}] Failed to expire messages up to {} on {}\", clientAppId(), expireTimeInSeconds,\n+                FutureUtil.waitForAll(futures).handle((result, exception) -> {\n+                    if (exception != null) {\n+                        Throwable t = exception.getCause();\n+                        log.error(\"[{}] Failed to expire messages up to {} on {}\", clientAppId(), expireTimeInSeconds,\n                             topicName, t);\n-                    asyncResponse.resume(new RestException(t));\n-                    return null;\n-                }\n+                        asyncResponse.resume(new RestException(t));\n+                        return null;\n+                    }\n \n-                asyncResponse.resume(Response.noContent().build());\n-                return null;\n-            });\n-        } else {\n-            // validate ownership and redirect if current broker is not owner\n-            validateAdminOperationOnTopic(authoritative);\n+                    asyncResponse.resume(Response.noContent().build());\n+                    return null;\n+                });\n+            } else {\n+                internalExpireMessagesForAllSubscriptionsForNonPartitionedTopic(asyncResponse, expireTimeInSeconds, authoritative);\n+            }\n+        }\n+    }\n \n-            PersistentTopic topic = (PersistentTopic) getTopicReference(topicName);\n-            final AtomicReference<Throwable> exception = new AtomicReference<>();\n+    private void internalExpireMessagesForAllSubscriptionsForNonPartitionedTopic(AsyncResponse asyncResponse, int expireTimeInSeconds,\n+            boolean authoritative) {\n+        // validate ownership and redirect if current broker is not owner\n+        validateAdminOperationOnTopic(authoritative);\n \n-            topic.getReplicators().forEach((subName, replicator) -> {\n-                try {\n-                    internalExpireMessagesForSinglePartition(subName, expireTimeInSeconds, authoritative);\n-                } catch (Throwable t) {\n-                    exception.set(t);\n-                }\n-            });\n+        PersistentTopic topic = (PersistentTopic) getTopicReference(topicName);\n+        final AtomicReference<Throwable> exception = new AtomicReference<>();\n \n-            topic.getSubscriptions().forEach((subName, subscriber) -> {\n-                try {\n-                    internalExpireMessagesForSinglePartition(subName, expireTimeInSeconds, authoritative);\n-                } catch (Throwable t) {\n-                    exception.set(t);\n-                }\n-            });\n+        topic.getReplicators().forEach((subName, replicator) -> {\n+            try {\n+                internalExpireMessagesForSinglePartition(subName, expireTimeInSeconds, authoritative);\n+            } catch (Throwable t) {\n+                exception.set(t);\n+            }\n+        });\n \n-            if (exception.get() != null) {\n-                if (exception.get() instanceof WebApplicationException) {\n-                    WebApplicationException wae = (WebApplicationException) exception.get();\n-                    asyncResponse.resume(wae);\n-                    return;\n-                } else {\n-                    asyncResponse.resume(new RestException(exception.get()));\n-                    return;\n-                }\n+        topic.getSubscriptions().forEach((subName, subscriber) -> {\n+            try {\n+                internalExpireMessagesForSinglePartition(subName, expireTimeInSeconds, authoritative);\n+            } catch (Throwable t) {\n+                exception.set(t);\n             }\n+        });\n \n-            asyncResponse.resume(Response.noContent().build());\n-            return;\n+        if (exception.get() != null) {\n+            if (exception.get() instanceof WebApplicationException) {\n+                WebApplicationException wae = (WebApplicationException) exception.get();\n+                asyncResponse.resume(wae);\n+                return;\n+            } else {\n+                asyncResponse.resume(new RestException(exception.get()));\n+                return;\n+            }\n         }\n+\n+        asyncResponse.resume(Response.noContent().build());\n     }\n \n     protected void internalResetCursor(AsyncResponse asyncResponse, String subName, long timestamp,\n             boolean authoritative) {\n         if (topicName.isGlobal()) {\n             validateGlobalNamespaceOwnership(namespaceName);\n         }\n-\n-        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-        final int numPartitions = partitionMetadata.partitions;\n-        if (numPartitions > 0) {\n-            final CompletableFuture<Void> future = new CompletableFuture<>();\n-            final AtomicInteger count = new AtomicInteger(numPartitions);\n-            final AtomicInteger failureCount = new AtomicInteger(0);\n-            final AtomicReference<Throwable> partitionException = new AtomicReference<>();\n-\n-            for (int i = 0; i < numPartitions; i++) {\n-                TopicName topicNamePartition = topicName.getPartition(i);\n-                try {\n-                    pulsar().getAdminClient().topics()\n+        // If the topic name is a partition name, no need to get partition topic metadata again\n+        if (topicName.isPartitioned()) {\n+            internalResetCursorForNonPartitionedTopic(asyncResponse, subName, timestamp, authoritative);\n+        } else {\n+            PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n+            final int numPartitions = partitionMetadata.partitions;\n+            if (numPartitions > 0) {\n+                final CompletableFuture<Void> future = new CompletableFuture<>();\n+                final AtomicInteger count = new AtomicInteger(numPartitions);\n+                final AtomicInteger failureCount = new AtomicInteger(0);\n+                final AtomicReference<Throwable> partitionException = new AtomicReference<>();\n+\n+                for (int i = 0; i < numPartitions; i++) {\n+                    TopicName topicNamePartition = topicName.getPartition(i);\n+                    try {\n+                        pulsar().getAdminClient().topics()\n                             .resetCursorAsync(topicNamePartition.toString(), subName, timestamp).handle((r, ex) -> {\n-                                if (ex != null) {\n-                                    if (ex instanceof PreconditionFailedException) {\n-                                        // throw the last exception if all partitions get this error\n-                                        // any other exception on partition is reported back to user\n-                                        failureCount.incrementAndGet();\n-                                        partitionException.set(ex);\n-                                    } else {\n-                                        log.warn(\"[{}] [{}] Failed to reset cursor on subscription {} to time {}\",\n-                                                clientAppId(), topicNamePartition, subName, timestamp, ex);\n-                                        future.completeExceptionally(ex);\n-                                        return null;\n-                                    }\n+                            if (ex != null) {\n+                                if (ex instanceof PreconditionFailedException) {\n+                                    // throw the last exception if all partitions get this error\n+                                    // any other exception on partition is reported back to user\n+                                    failureCount.incrementAndGet();\n+                                    partitionException.set(ex);\n+                                } else {\n+                                    log.warn(\"[{}] [{}] Failed to reset cursor on subscription {} to time {}\",\n+                                        clientAppId(), topicNamePartition, subName, timestamp, ex);\n+                                    future.completeExceptionally(ex);\n+                                    return null;\n                                 }\n+                            }\n \n-                                if (count.decrementAndGet() == 0) {\n-                                    future.complete(null);\n-                                }\n+                            if (count.decrementAndGet() == 0) {\n+                                future.complete(null);\n+                            }\n \n-                                return null;\n-                            });\n-                } catch (Exception e) {\n-                    log.warn(\"[{}] [{}] Failed to reset cursor on subscription {} to time {}\", clientAppId(),\n+                            return null;\n+                        });\n+                    } catch (Exception e) {\n+                        log.warn(\"[{}] [{}] Failed to reset cursor on subscription {} to time {}\", clientAppId(),\n                             topicNamePartition, subName, timestamp, e);\n-                    future.completeExceptionally(e);\n+                        future.completeExceptionally(e);\n+                    }\n                 }\n-            }\n \n-            future.whenComplete((r, ex) -> {\n-                if (ex != null) {\n-                    if (ex instanceof PulsarAdminException) {\n-                        asyncResponse.resume(new RestException((PulsarAdminException) ex));\n-                        return;\n-                    } else {\n-                        asyncResponse.resume(new RestException(ex));\n-                        return;\n+                future.whenComplete((r, ex) -> {\n+                    if (ex != null) {\n+                        if (ex instanceof PulsarAdminException) {\n+                            asyncResponse.resume(new RestException((PulsarAdminException) ex));\n+                            return;\n+                        } else {\n+                            asyncResponse.resume(new RestException(ex));\n+                            return;\n+                        }\n                     }\n-                }\n \n-                // report an error to user if unable to reset for all partitions\n-                if (failureCount.get() == numPartitions) {\n-                    log.warn(\"[{}] [{}] Failed to reset cursor on subscription {} to time {}\", clientAppId(), topicName,\n+                    // report an error to user if unable to reset for all partitions\n+                    if (failureCount.get() == numPartitions) {\n+                        log.warn(\"[{}] [{}] Failed to reset cursor on subscription {} to time {}\", clientAppId(), topicName,\n                             subName, timestamp, partitionException.get());\n-                    asyncResponse.resume(\n+                        asyncResponse.resume(\n                             new RestException(Status.PRECONDITION_FAILED, partitionException.get().getMessage()));\n-                    return;\n-                } else if (failureCount.get() > 0) {\n-                    log.warn(\"[{}] [{}] Partial errors for reset cursor on subscription {} to time {}\", clientAppId(),\n+                        return;\n+                    } else if (failureCount.get() > 0) {\n+                        log.warn(\"[{}] [{}] Partial errors for reset cursor on subscription {} to time {}\", clientAppId(),\n                             topicName, subName, timestamp, partitionException.get());\n-                }\n+                    }\n \n-                asyncResponse.resume(Response.noContent().build());\n-                return;\n-            });\n-        } else {\n-            validateAdminAccessForSubscriber(subName, authoritative);\n-            log.info(\"[{}] [{}] Received reset cursor on subscription {} to time {}\", clientAppId(), topicName, subName,\n-                    timestamp);\n-            PersistentTopic topic = (PersistentTopic) getTopicReference(topicName);\n-            if (topic == null) {\n-                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Topic not found\"));\n-                return;\n+                    asyncResponse.resume(Response.noContent().build());\n+                });\n+            } else {\n+                internalResetCursorForNonPartitionedTopic(asyncResponse, subName, timestamp, authoritative);\n             }\n-            try {\n-                PersistentSubscription sub = topic.getSubscription(subName);\n-                checkNotNull(sub);\n-                sub.resetCursor(timestamp).get();\n-                log.info(\"[{}] [{}] Reset cursor on subscription {} to time {}\", clientAppId(), topicName, subName,\n-                        timestamp);\n-                asyncResponse.resume(Response.noContent().build());\n-                return;\n-            } catch (Exception e) {\n-                Throwable t = e.getCause();\n-                log.warn(\"[{}] [{}] Failed to reset cursor on subscription {} to time {}\", clientAppId(), topicName,\n-                        subName, timestamp, e);\n-                if (e instanceof NullPointerException) {\n-                    asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n-                    return;\n-                } else if (e instanceof NotAllowedException) {\n-                    asyncResponse.resume(new RestException(Status.METHOD_NOT_ALLOWED, e.getMessage()));\n-                    return;\n-                } else if (t instanceof SubscriptionInvalidCursorPosition) {\n-                    asyncResponse.resume(new RestException(Status.PRECONDITION_FAILED,\n-                            \"Unable to find position for timestamp specified -\" + t.getMessage()));\n-                    return;\n-                } else {\n-                    asyncResponse.resume(new RestException(e));\n-                    return;\n-                }\n+        }\n+    }\n+\n+    private void internalResetCursorForNonPartitionedTopic(AsyncResponse asyncResponse, String subName, long timestamp,\n+                                       boolean authoritative) {\n+        validateAdminAccessForSubscriber(subName, authoritative);\n+        log.info(\"[{}] [{}] Received reset cursor on subscription {} to time {}\", clientAppId(), topicName, subName,\n+            timestamp);\n+        PersistentTopic topic = (PersistentTopic) getTopicReference(topicName);\n+        if (topic == null) {\n+            asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Topic not found\"));\n+            return;\n+        }\n+        try {\n+            PersistentSubscription sub = topic.getSubscription(subName);\n+            checkNotNull(sub);\n+            sub.resetCursor(timestamp).get();\n+            log.info(\"[{}] [{}] Reset cursor on subscription {} to time {}\", clientAppId(), topicName, subName,\n+                timestamp);\n+            asyncResponse.resume(Response.noContent().build());\n+        } catch (Exception e) {\n+            Throwable t = e.getCause();\n+            log.warn(\"[{}] [{}] Failed to reset cursor on subscription {} to time {}\", clientAppId(), topicName,\n+                subName, timestamp, e);\n+            if (e instanceof NullPointerException) {\n+                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n+            } else if (e instanceof NotAllowedException) {\n+                asyncResponse.resume(new RestException(Status.METHOD_NOT_ALLOWED, e.getMessage()));\n+            } else if (t instanceof SubscriptionInvalidCursorPosition) {\n+                asyncResponse.resume(new RestException(Status.PRECONDITION_FAILED,\n+                    \"Unable to find position for timestamp specified -\" + t.getMessage()));\n+            } else {\n+                asyncResponse.resume(new RestException(e));\n             }\n         }\n     }\n@@ -1310,27 +1346,30 @@ protected void internalCreateSubscription(AsyncResponse asyncResponse, String su\n         final MessageIdImpl targetMessageId = messageId == null ? (MessageIdImpl) MessageId.earliest : messageId;\n         log.info(\"[{}][{}] Creating subscription {} at message id {}\", clientAppId(), topicName, subscriptionName,\n                 targetMessageId);\n-\n-        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-        final int numPartitions = partitionMetadata.partitions;\n-        if (numPartitions > 0) {\n-            final CompletableFuture<Void> future = new CompletableFuture<>();\n-            final AtomicInteger count = new AtomicInteger(numPartitions);\n-            final AtomicInteger failureCount = new AtomicInteger(0);\n-            final AtomicReference<Throwable> partitionException = new AtomicReference<>();\n-\n-            // Create the subscription on each partition\n-            for (int i = 0; i < numPartitions; i++) {\n-                TopicName topicNamePartition = topicName.getPartition(i);\n-                try {\n-                    pulsar().getAdminClient().topics()\n+        // If the topic name is a partition name, no need to get partition topic metadata again\n+        if (topicName.isPartitioned()) {\n+            internalCreateSubscriptionForNonPartitionedTopic(asyncResponse, subscriptionName, targetMessageId, authoritative, replicated);\n+        } else {\n+            PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n+            final int numPartitions = partitionMetadata.partitions;\n+            if (numPartitions > 0) {\n+                final CompletableFuture<Void> future = new CompletableFuture<>();\n+                final AtomicInteger count = new AtomicInteger(numPartitions);\n+                final AtomicInteger failureCount = new AtomicInteger(0);\n+                final AtomicReference<Throwable> partitionException = new AtomicReference<>();\n+\n+                // Create the subscription on each partition\n+                for (int i = 0; i < numPartitions; i++) {\n+                    TopicName topicNamePartition = topicName.getPartition(i);\n+                    try {\n+                        pulsar().getAdminClient().topics()\n                             .createSubscriptionAsync(topicNamePartition.toString(), subscriptionName, targetMessageId)\n                             .handle((r, ex) -> {\n                                 if (ex != null) {\n                                     // fail the operation on unknown exception or if all the partitioned failed due to\n                                     // subscription-already-exist\n                                     if (failureCount.incrementAndGet() == numPartitions\n-                                            || !(ex instanceof PulsarAdminException.ConflictException)) {\n+                                        || !(ex instanceof PulsarAdminException.ConflictException)) {\n                                         partitionException.set(ex);\n                                     }\n                                 }\n@@ -1341,75 +1380,79 @@ protected void internalCreateSubscription(AsyncResponse asyncResponse, String su\n \n                                 return null;\n                             });\n-                } catch (Exception e) {\n-                    log.warn(\"[{}] [{}] Failed to create subscription {} at message id {}\", clientAppId(),\n+                    } catch (Exception e) {\n+                        log.warn(\"[{}] [{}] Failed to create subscription {} at message id {}\", clientAppId(),\n                             topicNamePartition, subscriptionName, targetMessageId, e);\n-                    future.completeExceptionally(e);\n+                        future.completeExceptionally(e);\n+                    }\n                 }\n-            }\n \n-            future.whenComplete((r, ex) -> {\n-                if (ex != null) {\n-                    if (ex instanceof PulsarAdminException) {\n-                        asyncResponse.resume(new RestException((PulsarAdminException) ex));\n-                        return;\n-                    } else {\n-                        asyncResponse.resume(new RestException(ex));\n-                        return;\n+                future.whenComplete((r, ex) -> {\n+                    if (ex != null) {\n+                        if (ex instanceof PulsarAdminException) {\n+                            asyncResponse.resume(new RestException((PulsarAdminException) ex));\n+                            return;\n+                        } else {\n+                            asyncResponse.resume(new RestException(ex));\n+                            return;\n+                        }\n                     }\n-                }\n \n-                if (partitionException.get() != null) {\n-                    log.warn(\"[{}] [{}] Failed to create subscription {} at message id {}\", clientAppId(), topicName,\n+                    if (partitionException.get() != null) {\n+                        log.warn(\"[{}] [{}] Failed to create subscription {} at message id {}\", clientAppId(), topicName,\n                             subscriptionName, targetMessageId, partitionException.get());\n-                    if (partitionException.get() instanceof PulsarAdminException) {\n-                        asyncResponse.resume(new RestException((PulsarAdminException) partitionException.get()));\n-                        return;\n-                    } else {\n-                        asyncResponse.resume(new RestException(partitionException.get()));\n-                        return;\n+                        if (partitionException.get() instanceof PulsarAdminException) {\n+                            asyncResponse.resume(new RestException((PulsarAdminException) partitionException.get()));\n+                            return;\n+                        } else {\n+                            asyncResponse.resume(new RestException(partitionException.get()));\n+                            return;\n+                        }\n                     }\n-                }\n-\n-                asyncResponse.resume(Response.noContent().build());\n-                return;\n-            });\n-        } else {\n-            validateAdminAccessForSubscriber(subscriptionName, authoritative);\n-\n-            PersistentTopic topic = (PersistentTopic) getOrCreateTopic(topicName);\n \n-            if (topic.getSubscriptions().containsKey(subscriptionName)) {\n-                asyncResponse.resume(new RestException(Status.CONFLICT, \"Subscription already exists for topic\"));\n-                return;\n+                    asyncResponse.resume(Response.noContent().build());\n+                });\n+            } else {\n+                internalCreateSubscriptionForNonPartitionedTopic(asyncResponse, subscriptionName, targetMessageId, authoritative, replicated);\n             }\n+        }\n+    }\n \n-            try {\n-                PersistentSubscription subscription = (PersistentSubscription) topic\n-                        .createSubscription(subscriptionName, InitialPosition.Latest, replicated).get();\n-                // Mark the cursor as \"inactive\" as it was created without a real consumer connected\n-                subscription.deactivateCursor();\n-                subscription.resetCursor(PositionImpl.get(targetMessageId.getLedgerId(), targetMessageId.getEntryId()))\n-                        .get();\n-            } catch (Throwable e) {\n-                Throwable t = e.getCause();\n-                log.warn(\"[{}] [{}] Failed to create subscription {} at message id {}\", clientAppId(), topicName,\n-                        subscriptionName, targetMessageId, e);\n-                if (t instanceof SubscriptionInvalidCursorPosition) {\n-                    asyncResponse.resume(new RestException(Status.PRECONDITION_FAILED,\n-                            \"Unable to find position for position specified: \" + t.getMessage()));\n-                    return;\n-                } else {\n-                    asyncResponse.resume(new RestException(e));\n-                    return;\n-                }\n-            }\n+    private void internalCreateSubscriptionForNonPartitionedTopic(AsyncResponse asyncResponse, String subscriptionName,\n+              MessageIdImpl targetMessageId, boolean authoritative, boolean replicated) {\n+        validateAdminAccessForSubscriber(subscriptionName, authoritative);\n \n-            log.info(\"[{}][{}] Successfully created subscription {} at message id {}\", clientAppId(), topicName,\n-                    subscriptionName, targetMessageId);\n-            asyncResponse.resume(Response.noContent().build());\n+        PersistentTopic topic = (PersistentTopic) getOrCreateTopic(topicName);\n+\n+        if (topic.getSubscriptions().containsKey(subscriptionName)) {\n+            asyncResponse.resume(new RestException(Status.CONFLICT, \"Subscription already exists for topic\"));\n             return;\n         }\n+\n+        try {\n+            PersistentSubscription subscription = (PersistentSubscription) topic\n+                .createSubscription(subscriptionName, InitialPosition.Latest, replicated).get();\n+            // Mark the cursor as \"inactive\" as it was created without a real consumer connected\n+            subscription.deactivateCursor();\n+            subscription.resetCursor(PositionImpl.get(targetMessageId.getLedgerId(), targetMessageId.getEntryId()))\n+                .get();\n+        } catch (Throwable e) {\n+            Throwable t = e.getCause();\n+            log.warn(\"[{}] [{}] Failed to create subscription {} at message id {}\", clientAppId(), topicName,\n+                subscriptionName, targetMessageId, e);\n+            if (t instanceof SubscriptionInvalidCursorPosition) {\n+                asyncResponse.resume(new RestException(Status.PRECONDITION_FAILED,\n+                    \"Unable to find position for position specified: \" + t.getMessage()));\n+                return;\n+            } else {\n+                asyncResponse.resume(new RestException(e));\n+                return;\n+            }\n+        }\n+\n+        log.info(\"[{}][{}] Successfully created subscription {} at message id {}\", clientAppId(), topicName,\n+            subscriptionName, targetMessageId);\n+        asyncResponse.resume(Response.noContent().build());\n     }\n \n     protected void internalResetCursorOnPosition(String subName, boolean authoritative, MessageIdImpl messageId) {\n@@ -1418,10 +1461,8 @@ protected void internalResetCursorOnPosition(String subName, boolean authoritati\n         }\n         log.info(\"[{}][{}] received reset cursor on subscription {} to position {}\", clientAppId(), topicName,\n                 subName, messageId);\n-\n-        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-\n-        if (partitionMetadata.partitions > 0) {\n+        // If the topic name is a partition name, no need to get partition topic metadata again\n+        if (!topicName.isPartitioned() && getPartitionedTopicMetadata(topicName, authoritative, false).partitions > 0) {\n             log.warn(\"[{}] Not supported operation on partitioned-topic {} {}\", clientAppId(), topicName,\n                     subName);\n             throw new RestException(Status.METHOD_NOT_ALLOWED,\n@@ -1458,8 +1499,8 @@ protected Response internalPeekNthMessage(String subName, int messagePosition, b\n         if (topicName.isGlobal()) {\n             validateGlobalNamespaceOwnership(namespaceName);\n         }\n-        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-        if (partitionMetadata.partitions > 0) {\n+        // If the topic name is a partition name, no need to get partition topic metadata again\n+        if (!topicName.isPartitioned() && getPartitionedTopicMetadata(topicName, authoritative, false).partitions > 0) {\n             throw new RestException(Status.METHOD_NOT_ALLOWED, \"Peek messages on a partitioned topic is not allowed\");\n         }\n         validateAdminAccessForSubscriber(subName, authoritative);\n@@ -1602,43 +1643,8 @@ protected void internalExpireMessages(AsyncResponse asyncResponse, String subNam\n         if (topicName.isGlobal()) {\n             validateGlobalNamespaceOwnership(namespaceName);\n         }\n-\n-        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-        if (partitionMetadata.partitions > 0) {\n-            final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n-\n-            // expire messages for each partition topic\n-            for (int i = 0; i < partitionMetadata.partitions; i++) {\n-                TopicName topicNamePartition = topicName.getPartition(i);\n-                try {\n-                    futures.add(pulsar().getAdminClient().topics().expireMessagesAsync(topicNamePartition.toString(),\n-                            subName, expireTimeInSeconds));\n-                } catch (Exception e) {\n-                    log.error(\"[{}] Failed to expire messages up to {} on {}\", clientAppId(), expireTimeInSeconds,\n-                            topicNamePartition, e);\n-                    asyncResponse.resume(new RestException(e));\n-                    return;\n-                }\n-            }\n-\n-            FutureUtil.waitForAll(futures).handle((result, exception) -> {\n-                if (exception != null) {\n-                    Throwable t = exception.getCause();\n-                    if (t instanceof NotFoundException) {\n-                        asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n-                        return null;\n-                    } else {\n-                        log.error(\"[{}] Failed to expire messages up to {} on {}\", clientAppId(), expireTimeInSeconds,\n-                                topicName, t);\n-                        asyncResponse.resume(new RestException(t));\n-                        return null;\n-                    }\n-                }\n-\n-                asyncResponse.resume(Response.noContent().build());\n-                return null;\n-            });\n-        } else {\n+        // If the topic name is a partition name, no need to get partition topic metadata again\n+        if (topicName.isPartitioned()) {\n             try {\n                 internalExpireMessagesForSinglePartition(subName, expireTimeInSeconds, authoritative);\n             } catch (WebApplicationException wae) {\n@@ -1649,7 +1655,54 @@ protected void internalExpireMessages(AsyncResponse asyncResponse, String subNam\n                 return;\n             }\n             asyncResponse.resume(Response.noContent().build());\n-            return;\n+        } else {\n+            PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n+            if (partitionMetadata.partitions > 0) {\n+                final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n+\n+                // expire messages for each partition topic\n+                for (int i = 0; i < partitionMetadata.partitions; i++) {\n+                    TopicName topicNamePartition = topicName.getPartition(i);\n+                    try {\n+                        futures.add(pulsar().getAdminClient().topics().expireMessagesAsync(topicNamePartition.toString(),\n+                            subName, expireTimeInSeconds));\n+                    } catch (Exception e) {\n+                        log.error(\"[{}] Failed to expire messages up to {} on {}\", clientAppId(), expireTimeInSeconds,\n+                            topicNamePartition, e);\n+                        asyncResponse.resume(new RestException(e));\n+                        return;\n+                    }\n+                }\n+\n+                FutureUtil.waitForAll(futures).handle((result, exception) -> {\n+                    if (exception != null) {\n+                        Throwable t = exception.getCause();\n+                        if (t instanceof NotFoundException) {\n+                            asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n+                            return null;\n+                        } else {\n+                            log.error(\"[{}] Failed to expire messages up to {} on {}\", clientAppId(), expireTimeInSeconds,\n+                                topicName, t);\n+                            asyncResponse.resume(new RestException(t));\n+                            return null;\n+                        }\n+                    }\n+\n+                    asyncResponse.resume(Response.noContent().build());\n+                    return null;\n+                });\n+            } else {\n+                try {\n+                    internalExpireMessagesForSinglePartition(subName, expireTimeInSeconds, authoritative);\n+                } catch (WebApplicationException wae) {\n+                    asyncResponse.resume(wae);\n+                    return;\n+                } catch (Exception e) {\n+                    asyncResponse.resume(new RestException(e));\n+                    return;\n+                }\n+                asyncResponse.resume(Response.noContent().build());\n+            }\n         }\n     }\n \n@@ -1658,9 +1711,8 @@ private void internalExpireMessagesForSinglePartition(String subName, int expire\n         if (topicName.isGlobal()) {\n             validateGlobalNamespaceOwnership(namespaceName);\n         }\n-\n-        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-        if (partitionMetadata.partitions > 0) {\n+        // If the topic name is a partition name, no need to get partition topic metadata again\n+        if (!topicName.isPartitioned() && getPartitionedTopicMetadata(topicName, authoritative, false).partitions > 0) {\n             String msg = \"This method should not be called for partitioned topic\";\n             log.error(\"[{}] {} {} {}\", clientAppId(), msg, topicName, subName);\n             throw new IllegalStateException(msg);",
      "parent_sha": "3cf6be139e191f3fa058f01c469e1dbd4c8534be"
    }
  },
  {
    "oid": "d8e8813c550ab6ad8361de363f9f9c4107711c87",
    "message": "Fix #612: NonPersistentTopicTest test timeout was too short and sometimes failed (#629)",
    "date": "2017-08-03T00:37:57Z",
    "url": "https://github.com/apache/pulsar/commit/d8e8813c550ab6ad8361de363f9f9c4107711c87",
    "details": {
      "sha": "6144fa35129a9cc2090adb82ae2e0db5260372f8",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/client/api/NonPersistentTopicTest.java",
      "status": "modified",
      "additions": 8,
      "deletions": 9,
      "changes": 17,
      "blob_url": "https://github.com/apache/pulsar/blob/d8e8813c550ab6ad8361de363f9f9c4107711c87/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fapi%2FNonPersistentTopicTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/d8e8813c550ab6ad8361de363f9f9c4107711c87/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fapi%2FNonPersistentTopicTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fapi%2FNonPersistentTopicTest.java?ref=d8e8813c550ab6ad8361de363f9f9c4107711c87",
      "patch": "@@ -240,7 +240,6 @@ public void testConsumerInternalQueueMaxOut(SubscriptionType type) throws Except\n      */\n     @Test\n     public void testProducerRateLimit() throws Exception {\n-\n         int defaultNonPersistentMessageRate = conf.getMaxConcurrentNonPersistentMessagePerConnection();\n         try {\n             final String topic = \"non-persistent://my-property/use/my-ns/unacked-topic\";\n@@ -260,8 +259,9 @@ public void testProducerRateLimit() throws Exception {\n             for (int i = 0; i < totalProduceMessages; i++) {\n                 executor.submit(() -> {\n                     try {\n-                        producer.sendAsync(msgData).get(1, TimeUnit.SECONDS);\n+                        producer.send(msgData);\n                     } catch (Exception e) {\n+                        log.error(\"Failed to send message\", e);\n                         failed.set(true);\n                     }\n                     latch.countDown();\n@@ -290,12 +290,11 @@ public void testProducerRateLimit() throws Exception {\n         } finally {\n             conf.setMaxConcurrentNonPersistentMessagePerConnection(defaultNonPersistentMessageRate);\n         }\n-\n     }\n \n     /**\n      * verifies message delivery with multiple consumers on shared and failover subscriptions\n-     * \n+     *\n      * @throws Exception\n      */\n     @Test\n@@ -633,7 +632,7 @@ public void testLoadManagerAssignmentForNonPersistentTestAssignment(String loadM\n \n     /**\n      * verifies: broker should reject non-persistent topic loading if broker is not enable for non-persistent topic\n-     * \n+     *\n      * @param loadManagerName\n      * @throws Exception\n      */\n@@ -665,7 +664,7 @@ public void testNonPersistentTopicUnderPersistentNamespace() throws Exception {\n \n     /**\n      * verifies that broker started with onlyNonPersistent mode doesn't own persistent-topic\n-     * \n+     *\n      * @param loadManagerName\n      * @throws Exception\n      */\n@@ -723,7 +722,7 @@ public void testNonPersistentBrokerModeRejectPersistentTopic(String loadManagerN\n \n     /**\n      * Verifies msg-drop stats\n-     * \n+     *\n      * @throws Exception\n      */\n     @Test\n@@ -752,7 +751,7 @@ public void testMsgDropStat() throws Exception {\n             for (int i = 0; i < totalProduceMessages; i++) {\n                 executor.submit(() -> {\n                     producer.sendAsync(msgData).handle((msg,e)->{\n-                        latch.countDown();       \n+                        latch.countDown();\n                         return null;\n                     });\n                 });\n@@ -777,7 +776,7 @@ public void testMsgDropStat() throws Exception {\n         }\n \n     }\n-    \n+\n     class ReplicationClusterManager {\n         URL url1;\n         PulsarService pulsar1;",
      "parent_sha": "cd5189dc5de2c51ec5f803c0003facb794cc9cf7"
    }
  },
  {
    "oid": "40c831761a7519e4ce9f0b7b8808cdb6df3f418e",
    "message": "Fix issue where Key_Shared consumers could get stuck (#10920)",
    "date": "2021-06-14T21:50:59Z",
    "url": "https://github.com/apache/pulsar/commit/40c831761a7519e4ce9f0b7b8808cdb6df3f418e",
    "details": {
      "sha": "d9a56a095e34777395d776d555b92f0b16c26023",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/persistent/PersistentStickyKeyDispatcherMultipleConsumers.java",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/apache/pulsar/blob/40c831761a7519e4ce9f0b7b8808cdb6df3f418e/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2Fpersistent%2FPersistentStickyKeyDispatcherMultipleConsumers.java",
      "raw_url": "https://github.com/apache/pulsar/raw/40c831761a7519e4ce9f0b7b8808cdb6df3f418e/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2Fpersistent%2FPersistentStickyKeyDispatcherMultipleConsumers.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2Fpersistent%2FPersistentStickyKeyDispatcherMultipleConsumers.java?ref=40c831761a7519e4ce9f0b7b8808cdb6df3f418e",
      "patch": "@@ -121,8 +121,14 @@ public synchronized void addConsumer(Consumer consumer) throws BrokerServiceExce\n \n     @Override\n     public synchronized void removeConsumer(Consumer consumer) throws BrokerServiceException {\n-        super.removeConsumer(consumer);\n+        // The consumer must be removed from the selector before calling the superclass removeConsumer method.\n+        // In the superclass removeConsumer method, the pending acks that the consumer has are added to\n+        // messagesToRedeliver. If the consumer has not been removed from the selector at this point,\n+        // the broker will try to redeliver the messages to the consumer that has already been closed.\n+        // As a result, the messages are not redelivered to any consumer, and the mark-delete position does not move,\n+        // eventually causing all consumers to get stuck.\n         selector.removeConsumer(consumer);\n+        super.removeConsumer(consumer);\n         if (recentlyJoinedConsumers != null) {\n             recentlyJoinedConsumers.remove(consumer);\n             if (consumerList.size() == 1) {",
      "parent_sha": "ef7863239956e5b188da3762cbd1cc2216997374"
    }
  },
  {
    "oid": "e951cd05268bd4e01fd1ab161fa2df65d219c8fc",
    "message": "[improve][broker] Removing webURL check null (#21043)\n\n### Motivation\r\n\r\nRemoving `webUrl` null-check, because it couldn't be null.\r\n\r\n### Modifications\r\n\r\nRemoving `webUrl` null-check",
    "date": "2023-08-23T07:16:06Z",
    "url": "https://github.com/apache/pulsar/commit/e951cd05268bd4e01fd1ab161fa2df65d219c8fc",
    "details": {
      "sha": "e65ef50c72aff0ceaec89e747151194f4b6f6e5c",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/web/PulsarWebResource.java",
      "status": "modified",
      "additions": 7,
      "deletions": 9,
      "changes": 16,
      "blob_url": "https://github.com/apache/pulsar/blob/e951cd05268bd4e01fd1ab161fa2df65d219c8fc/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fweb%2FPulsarWebResource.java",
      "raw_url": "https://github.com/apache/pulsar/raw/e951cd05268bd4e01fd1ab161fa2df65d219c8fc/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fweb%2FPulsarWebResource.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fweb%2FPulsarWebResource.java?ref=e951cd05268bd4e01fd1ab161fa2df65d219c8fc",
      "patch": "@@ -759,15 +759,13 @@ protected CompletableFuture<Void> validateTopicOwnershipAsync(TopicName topicNam\n                 .build();\n \n         return nsService.getWebServiceUrlAsync(topicName, options)\n-                .thenApply(webUrl -> {\n-                    // Ensure we get a url\n-                    if (webUrl == null || !webUrl.isPresent()) {\n-                        log.info(\"Unable to get web service url\");\n-                        throw new RestException(Status.PRECONDITION_FAILED,\n-                                \"Failed to find ownership for topic:\" + topicName);\n-                    }\n-                    return webUrl.get();\n-                }).thenCompose(webUrl -> nsService.isServiceUnitOwnedAsync(topicName)\n+                .thenApply(webUrl ->\n+                        webUrl.orElseThrow(() -> {\n+                            log.info(\"Unable to get web service url\");\n+                            throw new RestException(Status.PRECONDITION_FAILED,\n+                                    \"Failed to find ownership for topic:\" + topicName);\n+                        })\n+                ).thenCompose(webUrl -> nsService.isServiceUnitOwnedAsync(topicName)\n                         .thenApply(isTopicOwned -> Pair.of(webUrl, isTopicOwned))\n                 ).thenAccept(pair -> {\n                     URL webUrl = pair.getLeft();",
      "parent_sha": "c1b0454614b7903913cb0311bdcacf2118893fc9"
    }
  },
  {
    "oid": "d9e1370a56f595e5613f6899220b05f8b695f928",
    "message": "fix: get list connectors return status (#3532)",
    "date": "2019-02-08T02:02:21Z",
    "url": "https://github.com/apache/pulsar/commit/d9e1370a56f595e5613f6899220b05f8b695f928",
    "details": {
      "sha": "2f4856e3996a3d686b84f0f68fe208a00defc3ae",
      "filename": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/rest/api/ComponentImpl.java",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/apache/pulsar/blob/d9e1370a56f595e5613f6899220b05f8b695f928/pulsar-functions%2Fworker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Fworker%2Frest%2Fapi%2FComponentImpl.java",
      "raw_url": "https://github.com/apache/pulsar/raw/d9e1370a56f595e5613f6899220b05f8b695f928/pulsar-functions%2Fworker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Fworker%2Frest%2Fapi%2FComponentImpl.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-functions%2Fworker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Fworker%2Frest%2Fapi%2FComponentImpl.java?ref=d9e1370a56f595e5613f6899220b05f8b695f928",
      "patch": "@@ -1037,9 +1037,7 @@ private void updateRequest(final FunctionMetaData functionMetaData) {\n \n     public List<ConnectorDefinition> getListOfConnectors() {\n         if (!isWorkerServiceAvailable()) {\n-            throw new WebApplicationException(\n-                    Response.status(Status.SERVICE_UNAVAILABLE).type(MediaType.APPLICATION_JSON)\n-                            .entity(new ErrorData(\"Function worker service is not avaialable\")).build());\n+            throwUnavailableException();\n         }\n \n         return this.worker().getConnectorsManager().getConnectors();",
      "parent_sha": "2bc5c5b748acd7bc23df130db9d42195276404ba"
    }
  },
  {
    "oid": "76646cfd9496820a6a6dbee225067045235838c0",
    "message": "[fix][broker] Fix RawReader out of order (#16390)\n\n* fix RawReader out ouf order\r\n\r\n* address comments\r\n\r\n* tune code",
    "date": "2022-07-06T17:54:22Z",
    "url": "https://github.com/apache/pulsar/commit/76646cfd9496820a6a6dbee225067045235838c0",
    "details": {
      "sha": "92cbbe4a399a544df4a69d1c8f084e6972009a6b",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/client/impl/RawReaderImpl.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/apache/pulsar/blob/76646cfd9496820a6a6dbee225067045235838c0/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FRawReaderImpl.java",
      "raw_url": "https://github.com/apache/pulsar/raw/76646cfd9496820a6a6dbee225067045235838c0/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FRawReaderImpl.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FRawReaderImpl.java?ref=76646cfd9496820a6a6dbee225067045235838c0",
      "patch": "@@ -211,9 +211,10 @@ void messageReceived(CommandMessage commandMessage, ByteBuf headersAndPayload, C\n                 log.debug(\"[{}][{}] Received raw message: {}/{}/{}\", topic, subscription,\n                         messageId.getEntryId(), messageId.getLedgerId(), messageId.getPartition());\n             }\n+\n             incomingRawMessages.add(\n-                    new RawMessageAndCnx(new RawMessageImpl(messageId, headersAndPayload), cnx));\n-            tryCompletePending();\n+                new RawMessageAndCnx(new RawMessageImpl(messageId, headersAndPayload), cnx));\n+            internalPinnedExecutor.execute(this::tryCompletePending);\n         }\n     }\n ",
      "parent_sha": "e23d312c04da1d82d35f9e2faf8a446f8e8a4eeb"
    }
  },
  {
    "oid": "5e832a1cc1441eaf8d64fe72c1a2af8829030d3d",
    "message": "[fix][test] Fix ReplicatorRateLimiterTest (#23369)",
    "date": "2024-09-29T07:13:38Z",
    "url": "https://github.com/apache/pulsar/commit/5e832a1cc1441eaf8d64fe72c1a2af8829030d3d",
    "details": {
      "sha": "2e0dd0a90e8a6fdaa9510e4851a58d5ccb39f69e",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/ReplicatorRateLimiterTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/pulsar/blob/5e832a1cc1441eaf8d64fe72c1a2af8829030d3d/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FReplicatorRateLimiterTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/5e832a1cc1441eaf8d64fe72c1a2af8829030d3d/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FReplicatorRateLimiterTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FReplicatorRateLimiterTest.java?ref=5e832a1cc1441eaf8d64fe72c1a2af8829030d3d",
      "patch": "@@ -611,7 +611,7 @@ public void testReplicatorRateLimiterByBytes() throws Exception {\n     }\n \n     private static Optional<DispatchRateLimiter> getRateLimiter(PersistentTopic topic) {\n-        return getRateLimiter(topic);\n+        return topic.getReplicators().values().stream().findFirst().map(Replicator::getRateLimiter).orElseThrow();\n     }\n \n     private static final Logger log = LoggerFactory.getLogger(ReplicatorRateLimiterTest.class);",
      "parent_sha": "950309b57a3674c43e2168168cdb9ef670ac6274"
    }
  },
  {
    "oid": "ebb3cb5384d188b3c9d6b3fe89c2f66254103bf7",
    "message": "[fix][standalone] correctly delete bookie registration znode (#23497)\n\nSigned-off-by: Zixuan Liu <nodeces@gmail.com>",
    "date": "2024-10-25T03:24:57Z",
    "url": "https://github.com/apache/pulsar/commit/ebb3cb5384d188b3c9d6b3fe89c2f66254103bf7",
    "details": {
      "sha": "939998f6f8054730b6e414a4485d49eb23f9207c",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/zookeeper/LocalBookkeeperEnsemble.java",
      "status": "modified",
      "additions": 15,
      "deletions": 11,
      "changes": 26,
      "blob_url": "https://github.com/apache/pulsar/blob/ebb3cb5384d188b3c9d6b3fe89c2f66254103bf7/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fzookeeper%2FLocalBookkeeperEnsemble.java",
      "raw_url": "https://github.com/apache/pulsar/raw/ebb3cb5384d188b3c9d6b3fe89c2f66254103bf7/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fzookeeper%2FLocalBookkeeperEnsemble.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fzookeeper%2FLocalBookkeeperEnsemble.java?ref=ebb3cb5384d188b3c9d6b3fe89c2f66254103bf7",
      "patch": "@@ -297,22 +297,16 @@ private void runBookies(ServerConfiguration baseConf) throws Exception {\n             }\n \n             int bookiePort = portManager.get();\n-\n+            String bookieId = \"bk\" + i + \"test\";\n             // Ensure registration Z-nodes are cleared when standalone service is restarted ungracefully\n-            String registrationZnode = String.format(\"/ledgers/available/%s:%d\",\n-                    baseConf.getAdvertisedAddress(), bookiePort);\n-            if (zkc.exists(registrationZnode, null) != null) {\n-                try {\n-                    zkc.delete(registrationZnode, -1);\n-                } catch (NoNodeException nne) {\n-                    // Ignore if z-node was just expired\n-                }\n-            }\n+            deleteBookieRegistrationZnode(\n+                    String.format(\"/ledgers/available/%s:%d\", baseConf.getAdvertisedAddress(), bookiePort));\n+            deleteBookieRegistrationZnode(String.format(\"/ledgers/available/%s\", bookieId));\n \n             bsConfs[i] = new ServerConfiguration(baseConf);\n             // override settings\n             bsConfs[i].setBookiePort(bookiePort);\n-            bsConfs[i].setBookieId(\"bk\" + i + \"test\");\n+            bsConfs[i].setBookieId(bookieId);\n             String zkServers = \"127.0.0.1:\" + zkPort;\n             String metadataServiceUriStr = \"zk://\" + zkServers + \"/ledgers\";\n \n@@ -327,6 +321,16 @@ private void runBookies(ServerConfiguration baseConf) throws Exception {\n         }\n     }\n \n+    private void deleteBookieRegistrationZnode(String registrationZnode) throws InterruptedException, KeeperException {\n+        if (zkc.exists(registrationZnode, null) != null) {\n+            try {\n+                zkc.delete(registrationZnode, -1);\n+            } catch (NoNodeException nne) {\n+                // Ignore if z-node was just expired\n+            }\n+        }\n+    }\n+\n     public void runStreamStorage(CompositeConfiguration conf) throws Exception {\n         String zkServers = \"127.0.0.1:\" + zkPort;\n         String metadataServiceUriStr = \"zk://\" + zkServers + \"/ledgers\";",
      "parent_sha": "fcb359299e9fd784afcebbc3967927a7f1f7c25c"
    }
  },
  {
    "oid": "bd568bcb0cadc368d7c5b5aa09437b8d9a174733",
    "message": "[Broker] Fix possible data race in getFirstAvailableConsumerPermits (#10831)\n\n* Fix possible race in getFirstAvailableConsumerPermits\r\n\r\n- there's a chance for a race so that the consumer's available permits goes\r\n  below zero after it has been checked in \"isConsumerAvailable\"\r\n\r\n* Address review feedback",
    "date": "2021-06-05T14:54:16Z",
    "url": "https://github.com/apache/pulsar/commit/bd568bcb0cadc368d7c5b5aa09437b8d9a174733",
    "details": {
      "sha": "3426355f8de79bb15f67503d086b7dc49a9d652c",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/persistent/PersistentDispatcherMultipleConsumers.java",
      "status": "modified",
      "additions": 5,
      "deletions": 2,
      "changes": 7,
      "blob_url": "https://github.com/apache/pulsar/blob/bd568bcb0cadc368d7c5b5aa09437b8d9a174733/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2Fpersistent%2FPersistentDispatcherMultipleConsumers.java",
      "raw_url": "https://github.com/apache/pulsar/raw/bd568bcb0cadc368d7c5b5aa09437b8d9a174733/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2Fpersistent%2FPersistentDispatcherMultipleConsumers.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2Fpersistent%2FPersistentDispatcherMultipleConsumers.java?ref=bd568bcb0cadc368d7c5b5aa09437b8d9a174733",
      "patch": "@@ -672,8 +672,11 @@ protected int getFirstAvailableConsumerPermits() {\n             return 0;\n         }\n         for (Consumer consumer : consumerList) {\n-            if (isConsumerAvailable(consumer)) {\n-                return consumer.getAvailablePermits();\n+            if (consumer != null && !consumer.isBlocked()) {\n+                int availablePermits = consumer.getAvailablePermits();\n+                if (availablePermits > 0) {\n+                    return availablePermits;\n+                }\n             }\n         }\n         return 0;",
      "parent_sha": "30b612b536fe53f00d4a66a2823c58e3779dc468"
    }
  },
  {
    "oid": "c40bb08f7e00b6e9dca2ca5f1a0a321113aab9a7",
    "message": "In functions log topic appender, don't set producer name (#3544)",
    "date": "2019-02-08T19:01:22Z",
    "url": "https://github.com/apache/pulsar/commit/c40bb08f7e00b6e9dca2ca5f1a0a321113aab9a7",
    "details": {
      "sha": "afdc6f9a77aa72132b05d68ef6b8b536ac85bdf9",
      "filename": "pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/LogAppender.java",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/apache/pulsar/blob/c40bb08f7e00b6e9dca2ca5f1a0a321113aab9a7/pulsar-functions%2Finstance%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Finstance%2FLogAppender.java",
      "raw_url": "https://github.com/apache/pulsar/raw/c40bb08f7e00b6e9dca2ca5f1a0a321113aab9a7/pulsar-functions%2Finstance%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Finstance%2FLogAppender.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-functions%2Finstance%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Finstance%2FLogAppender.java?ref=c40bb08f7e00b6e9dca2ca5f1a0a321113aab9a7",
      "patch": "@@ -19,6 +19,7 @@\n package org.apache.pulsar.functions.instance;\n \n import org.apache.logging.log4j.core.*;\n+import org.apache.pulsar.client.api.CompressionType;\n import org.apache.pulsar.client.api.Producer;\n import org.apache.pulsar.client.api.ProducerBuilder;\n import org.apache.pulsar.client.api.PulsarClient;\n@@ -88,13 +89,14 @@ public void initialize() {\n     public void start() {\n         this.state = State.STARTING;\n         try {\n-            ProducerBuilder<byte[]> producerBuilder = pulsarClient.newProducer()\n+            producer = pulsarClient.newProducer()\n                     .topic(logTopic)\n-                    .producerName(fqn)\n                     .blockIfQueueFull(false)\n                     .enableBatching(true)\n-                    .batchingMaxPublishDelay(10, TimeUnit.MILLISECONDS);\n-            producer = producerBuilder.create();\n+                    .compressionType(CompressionType.LZ4)\n+                    .batchingMaxPublishDelay(100, TimeUnit.MILLISECONDS)\n+                    .property(\"function\", fqn)\n+                    .create();\n         } catch (Exception e) {\n             throw new RuntimeException(\"Error starting LogTopic Producer\", e);\n         }",
      "parent_sha": "b424fad2b58bf98007689435d174ee6b36952938"
    }
  },
  {
    "oid": "91cb00eab0fbbc0d519f5ad1ac8ab722da56b349",
    "message": "Fix flaky test PersistentTopicsTest#testTriggerCompactionTopic. (#15937)",
    "date": "2022-06-05T11:22:36Z",
    "url": "https://github.com/apache/pulsar/commit/91cb00eab0fbbc0d519f5ad1ac8ab722da56b349",
    "details": {
      "sha": "356367f410ae64847e9351d0aff06d9fdcb84483",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/PersistentTopicsTest.java",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/apache/pulsar/blob/91cb00eab0fbbc0d519f5ad1ac8ab722da56b349/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2FPersistentTopicsTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/91cb00eab0fbbc0d519f5ad1ac8ab722da56b349/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2FPersistentTopicsTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2FPersistentTopicsTest.java?ref=91cb00eab0fbbc0d519f5ad1ac8ab722da56b349",
      "patch": "@@ -901,9 +901,13 @@ public void testTriggerCompactionTopic() {\n \n         // create non partitioned topic and compaction on it\n         response = mock(AsyncResponse.class);\n+        ArgumentCaptor<Response> responseCaptor = ArgumentCaptor.forClass(Response.class);\n         persistentTopics.createNonPartitionedTopic(response, testTenant, testNamespace, nonPartitionTopicName, true, null);\n+        verify(response, timeout(5000).times(1)).resume(responseCaptor.capture());\n+        Assert.assertEquals(responseCaptor.getValue().getStatus(), Response.Status.NO_CONTENT.getStatusCode());\n+        response = mock(AsyncResponse.class);\n+        responseCaptor = ArgumentCaptor.forClass(Response.class);\n         persistentTopics.compact(response, testTenant, testNamespace, nonPartitionTopicName, true);\n-        ArgumentCaptor<Response> responseCaptor = ArgumentCaptor.forClass(Response.class);\n         verify(response, timeout(5000).times(1)).resume(responseCaptor.capture());\n         Assert.assertEquals(responseCaptor.getValue().getStatus(), Response.Status.NO_CONTENT.getStatusCode());\n ",
      "parent_sha": "813aeccd7dd28820573156d089544096c57d0855"
    }
  },
  {
    "oid": "b533fe5825d236415d8bf07fcaaccd8750b63271",
    "message": "Flaky Tests: AdminApiSchemaTest#testSchemaInfoApi (#12461)",
    "date": "2021-11-11T17:16:49Z",
    "url": "https://github.com/apache/pulsar/commit/b533fe5825d236415d8bf07fcaaccd8750b63271",
    "details": {
      "sha": "960f9be38bd012b52877f0e5f6ce311219df98d6",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/schema/SchemaTest.java",
      "status": "modified",
      "additions": 5,
      "deletions": 2,
      "changes": 7,
      "blob_url": "https://github.com/apache/pulsar/blob/b533fe5825d236415d8bf07fcaaccd8750b63271/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fschema%2FSchemaTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/b533fe5825d236415d8bf07fcaaccd8750b63271/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fschema%2FSchemaTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fschema%2FSchemaTest.java?ref=b533fe5825d236415d8bf07fcaaccd8750b63271",
      "patch": "@@ -658,9 +658,12 @@ public void testNullKeyValueProperty() throws PulsarAdminException, PulsarClient\n         final Map<String, String> map = new HashMap<>();\n         map.put(\"key\", null);\n         map.put(null, \"value\"); // null key is not allowed for JSON, it's only for test here\n-        ((SchemaInfoImpl)Schema.INT32.getSchemaInfo()).setProperties(map);\n \n-        final Consumer<Integer> consumer = pulsarClient.newConsumer(Schema.INT32).topic(topic)\n+        // leave INT32 instance unchanged\n+        final Schema<Integer> integerSchema = Schema.INT32.clone();\n+        ((SchemaInfoImpl) integerSchema.getSchemaInfo()).setProperties(map);\n+\n+        final Consumer<Integer> consumer = pulsarClient.newConsumer(integerSchema).topic(topic)\n                 .subscriptionName(\"sub\")\n                 .subscribe();\n         consumer.close();",
      "parent_sha": "6ab7401056f6c0f6bdf695fecc2764fdff16fcac"
    }
  },
  {
    "oid": "ae90f22b54cb5f4132542211d4867c066ea7b9e7",
    "message": "Change MessageProcessor Interface to be public (#2030)\n\n* Change MessageProcessor Interface to be public\r\n\r\n* remove static",
    "date": "2018-06-26T19:18:37Z",
    "url": "https://github.com/apache/pulsar/commit/ae90f22b54cb5f4132542211d4867c066ea7b9e7",
    "details": {
      "sha": "1ab6d0429763d151a9f62e8f1eb6e842d9cdfbc1",
      "filename": "pulsar-client/src/main/java/org/apache/pulsar/client/impl/MessageParser.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/pulsar/blob/ae90f22b54cb5f4132542211d4867c066ea7b9e7/pulsar-client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FMessageParser.java",
      "raw_url": "https://github.com/apache/pulsar/raw/ae90f22b54cb5f4132542211d4867c066ea7b9e7/pulsar-client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FMessageParser.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FMessageParser.java?ref=ae90f22b54cb5f4132542211d4867c066ea7b9e7",
      "patch": "@@ -43,7 +43,7 @@\n @UtilityClass\n @Slf4j\n public class MessageParser {\n-    static interface MessageProcessor {\n+    public interface MessageProcessor {\n         void process(MessageId messageId, Message<?> message, ByteBuf payload);\n     }\n ",
      "parent_sha": "97d06c91b7b93b936e77bd009e19576011ea1b46"
    }
  },
  {
    "oid": "73739e105ea86327839149c0406682d656bee233",
    "message": "[fix][doc]correct the explanation for invalidateEntries in the EntryCache (#17650)",
    "date": "2022-09-29T03:56:35Z",
    "url": "https://github.com/apache/pulsar/commit/73739e105ea86327839149c0406682d656bee233",
    "details": {
      "sha": "640a7eeefcebb4097477b90e25bbb73f7224dfe4",
      "filename": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/cache/EntryCache.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/apache/pulsar/blob/73739e105ea86327839149c0406682d656bee233/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2Fcache%2FEntryCache.java",
      "raw_url": "https://github.com/apache/pulsar/raw/73739e105ea86327839149c0406682d656bee233/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2Fcache%2FEntryCache.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2Fcache%2FEntryCache.java?ref=73739e105ea86327839149c0406682d656bee233",
      "patch": "@@ -39,7 +39,7 @@ public interface EntryCache extends Comparable<EntryCache> {\n     /**\n      * Insert an entry in the cache.\n      *\n-     * <p/>If the overall limit have been reached, this will triggered the eviction of other entries, possibly from\n+     * <p/>If the overall limit have been reached, this will trigger the eviction of other entries, possibly from\n      * other EntryCache instances\n      *\n      * @param entry\n@@ -49,7 +49,7 @@ public interface EntryCache extends Comparable<EntryCache> {\n     boolean insert(EntryImpl entry);\n \n     /**\n-     * Remove from cache all the entries related to a ledger up to lastPosition included.\n+     * Remove from cache all the entries related to a ledger up to lastPosition excluded.\n      *\n      * @param lastPosition\n      *            the position of the last entry to be invalidated (non-inclusive)",
      "parent_sha": "537aa545c70aa0b3023ff026c4a919546340656b"
    }
  },
  {
    "oid": "e71b9fc4e256f24c9b6c0edd14e40e8af1f24374",
    "message": "Consumer received duplicated deplayed messages upon restart\n\nFix when send a delayed message ,there is a case when a consumer restarts and pull duplicate messages. #6403",
    "date": "2020-02-26T11:26:15Z",
    "url": "https://github.com/apache/pulsar/commit/e71b9fc4e256f24c9b6c0edd14e40e8af1f24374",
    "details": {
      "sha": "05f6f5c7621332ee82640917c95d465ca2a683f0",
      "filename": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/apache/pulsar/blob/e71b9fc4e256f24c9b6c0edd14e40e8af1f24374/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedCursorImpl.java",
      "raw_url": "https://github.com/apache/pulsar/raw/e71b9fc4e256f24c9b6c0edd14e40e8af1f24374/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedCursorImpl.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedCursorImpl.java?ref=e71b9fc4e256f24c9b6c0edd14e40e8af1f24374",
      "patch": "@@ -1116,7 +1116,14 @@ public synchronized void readEntryFailed(ManagedLedgerException mle, Object ctx)\n         };\n \n         positions.stream().filter(position -> !alreadyAcknowledgedPositions.contains(position))\n-                .forEach(p -> ledger.asyncReadEntry((PositionImpl) p, cb, ctx));\n+                .forEach(p ->{\n+                    if (((PositionImpl) p).compareTo(this.readPosition) == 0) {\n+                        this.setReadPosition(this.readPosition.getNext());\n+                        log.warn(\"[{}][{}] replayPosition{} equals readPosition{},\" + \" need set next readPositio\",\n+                                ledger.getName(), name, (PositionImpl) p, this.readPosition);\n+                    }\n+                    ledger.asyncReadEntry((PositionImpl) p, cb, ctx);\n+                });\n \n         return alreadyAcknowledgedPositions;\n     }",
      "parent_sha": "792ab172ce0419097fdf10eae156ba95b61abc21"
    }
  },
  {
    "oid": "463f590c8215bdee836ecfe44b83abbbd6ce6fbb",
    "message": "[fix][test] Fix `testMaxPendingChunkMessages` (#18655)\n\nSigned-off-by: Zike Yang <zike@apache.org>",
    "date": "2022-12-02T02:31:30Z",
    "url": "https://github.com/apache/pulsar/commit/463f590c8215bdee836ecfe44b83abbbd6ce6fbb",
    "details": {
      "sha": "2797d66f7fe21b6c46be4fd798163bdf1f6c49ac",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/client/impl/MessageChunkingTest.java",
      "status": "modified",
      "additions": 38,
      "deletions": 44,
      "changes": 82,
      "blob_url": "https://github.com/apache/pulsar/blob/463f590c8215bdee836ecfe44b83abbbd6ce6fbb/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FMessageChunkingTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/463f590c8215bdee836ecfe44b83abbbd6ce6fbb/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FMessageChunkingTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FMessageChunkingTest.java?ref=463f590c8215bdee836ecfe44b83abbbd6ce6fbb",
      "patch": "@@ -19,8 +19,8 @@\n package org.apache.pulsar.client.impl;\n \n import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertNotEquals;\n import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n import static org.testng.Assert.assertTrue;\n import static org.testng.Assert.fail;\n import io.netty.buffer.ByteBuf;\n@@ -33,8 +33,6 @@\n import java.util.Random;\n import java.util.Set;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n import java.util.concurrent.Semaphore;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n@@ -309,57 +307,53 @@ public void testPublishWithFailure() throws Exception {\n         producer.close();\n     }\n \n-    @Test(enabled = false)\n-    public void testMaxPendingChunkMessages() throws Exception {\n+    private void sendSingleChunk(Producer<String> producer, String uuid, int chunkId, int totalChunks)\n+            throws PulsarClientException {\n+        TypedMessageBuilderImpl<String> msg = (TypedMessageBuilderImpl<String>) producer.newMessage()\n+                .value(String.format(\"chunk-%s-%d|\", uuid, chunkId));\n+        MessageMetadata msgMetadata = msg.getMetadataBuilder();\n+        msgMetadata.setUuid(uuid)\n+                .setChunkId(chunkId)\n+                .setNumChunksFromMsg(totalChunks)\n+                .setTotalChunkMsgSize(100);\n+        msg.send();\n+    }\n \n+    @Test\n+    public void testMaxPendingChunkMessages() throws Exception {\n         log.info(\"-- Starting {} test --\", methodName);\n-        this.conf.setMaxMessageSize(100);\n-        final int totalMessages = 25;\n         final String topicName = \"persistent://my-property/my-ns/maxPending\";\n-        final int totalProducers = 25;\n-        @Cleanup(\"shutdownNow\")\n-        ExecutorService executor = Executors.newFixedThreadPool(totalProducers);\n \n         @Cleanup\n-        ConsumerImpl<byte[]> consumer = (ConsumerImpl<byte[]>) pulsarClient.newConsumer().topic(topicName)\n-                .subscriptionName(\"my-subscriber-name\").acknowledgmentGroupTime(0, TimeUnit.SECONDS)\n-                .maxPendingChunkedMessage(1).autoAckOldestChunkedMessageOnQueueFull(true)\n-                .ackTimeout(5, TimeUnit.SECONDS).subscribe();\n-\n-        ProducerBuilder<byte[]> producerBuilder = pulsarClient.newProducer().topic(topicName);\n+        Consumer<String> consumer = pulsarClient.newConsumer(Schema.STRING)\n+                .topic(topicName)\n+                .subscriptionName(\"my-subscriber-name\")\n+                .maxPendingChunkedMessage(1)\n+                .autoAckOldestChunkedMessageOnQueueFull(true)\n+                .subscribe();\n+        @Cleanup\n+        Producer<String> producer = pulsarClient.newProducer(Schema.STRING)\n+                .topic(topicName)\n+                .chunkMaxMessageSize(100)\n+                .enableChunking(true)\n+                .enableBatching(false)\n+                .create();\n \n-        Producer<byte[]>[] producers = new Producer[totalProducers];\n-        int totalPublishedMessages = totalProducers;\n-        List<CompletableFuture<MessageId>> futures = new ArrayList<>();\n-        for (int i = 0; i < totalProducers; i++) {\n-            producers[i] = producerBuilder.enableChunking(true).enableBatching(false).create();\n-            int index = i;\n-            executor.submit(() -> {\n-                futures.add(producers[index].sendAsync(createMessagePayload(450).getBytes()));\n-            });\n-        }\n+        sendSingleChunk(producer, \"0\", 0, 2);\n+        sendSingleChunk(producer, \"1\", 0, 2);\n+        sendSingleChunk(producer, \"1\", 1, 2);\n \n-        FutureUtil.waitForAll(futures).get();\n+        // The chunked message of uuid 0 is discarded.\n+        Message<String> receivedMsg = consumer.receive(5, TimeUnit.SECONDS);\n+        assertEquals(receivedMsg.getValue(), \"chunk-1-0|chunk-1-1|\");\n \n-        Message<byte[]> msg = null;\n-        Set<String> messageSet = new HashSet<>();\n-        for (int i = 0; i < totalMessages; i++) {\n-            msg = consumer.receive(1, TimeUnit.SECONDS);\n-            if (msg == null) {\n-                break;\n-            }\n-            String receivedMessage = new String(msg.getData());\n-            log.info(\"Received message: [{}]\", receivedMessage);\n-            messageSet.add(receivedMessage);\n-            consumer.acknowledge(msg);\n-        }\n+        consumer.acknowledge(receivedMsg);\n+        consumer.redeliverUnacknowledgedMessages();\n \n-        log.info(\"messageSet size: {}, totalPublishedMessages: {}\", messageSet.size(), totalPublishedMessages);\n-        assertNotEquals(messageSet.size(), totalPublishedMessages);\n+        sendSingleChunk(producer, \"0\", 1, 2);\n \n-        for (int i = 0; i < totalProducers; i++) {\n-            producers[i].close();\n-        }\n+        // Ensure that the chunked message of uuid 0 is discarded.\n+        assertNull(consumer.receive(5, TimeUnit.SECONDS));\n     }\n \n     /**",
      "parent_sha": "bbc7a25d3b2007c84b9bcd3a67205d0256dc4b3c"
    }
  },
  {
    "oid": "14e893a9bd5d49a94076dcd7ca2f3d6b7c3bebfc",
    "message": "Encode the path for download (#1765)",
    "date": "2018-05-11T05:46:09Z",
    "url": "https://github.com/apache/pulsar/commit/14e893a9bd5d49a94076dcd7ca2f3d6b7c3bebfc",
    "details": {
      "sha": "d306efa1bb42d650f8d20e199fceee28850836d8",
      "filename": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/rest/api/FunctionsImpl.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/pulsar/blob/14e893a9bd5d49a94076dcd7ca2f3d6b7c3bebfc/pulsar-functions%2Fworker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Fworker%2Frest%2Fapi%2FFunctionsImpl.java",
      "raw_url": "https://github.com/apache/pulsar/raw/14e893a9bd5d49a94076dcd7ca2f3d6b7c3bebfc/pulsar-functions%2Fworker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Fworker%2Frest%2Fapi%2FFunctionsImpl.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-functions%2Fworker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Ffunctions%2Fworker%2Frest%2Fapi%2FFunctionsImpl.java?ref=14e893a9bd5d49a94076dcd7ca2f3d6b7c3bebfc",
      "patch": "@@ -628,7 +628,7 @@ public Response downloadFunction(final @QueryParam(\"path\") String path) {\n                     @Override\n                     public void write(final OutputStream output) throws IOException {\n                         Utils.downloadFromBookkeeper(worker().getDlogNamespace(),\n-                                output, Codec.decode(path));\n+                                output, Codec.encode(path));\n                     }\n                 }).build();\n     }",
      "parent_sha": "40a5aa5366c6e8c1ed172bfc5fcf7e1749717703"
    }
  },
  {
    "oid": "fbb93b38e6e9119c9ab15382eed3440877c4167b",
    "message": "Fix flaky test ConnectionTimeoutTest#testLowTimeout. (#15068)\n\n### Motivation\r\n\r\nThe test `testLowTimeout` fails frequently.  Remove the unused assertion.  \r\n```\r\norg.apache.pulsar.client.impl.ConnectionTimeoutTest \u25ba testLowTimeout\r\nFailed test found in:\r\n  TEST-org.apache.pulsar.client.impl.ConnectionTimeoutTest.xml\r\nError:\r\n        java.lang.AssertionError: expected [false] but found [true]\r\n```",
    "date": "2022-04-08T02:30:22Z",
    "url": "https://github.com/apache/pulsar/commit/fbb93b38e6e9119c9ab15382eed3440877c4167b",
    "details": {
      "sha": "3ed22c358b0b8ffb6a05a90cca3a5756bc8cfe15",
      "filename": "pulsar-client/src/test/java/org/apache/pulsar/client/impl/ConnectionTimeoutTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 8,
      "changes": 9,
      "blob_url": "https://github.com/apache/pulsar/blob/fbb93b38e6e9119c9ab15382eed3440877c4167b/pulsar-client%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FConnectionTimeoutTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/fbb93b38e6e9119c9ab15382eed3440877c4167b/pulsar-client%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FConnectionTimeoutTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-client%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FConnectionTimeoutTest.java?ref=fbb93b38e6e9119c9ab15382eed3440877c4167b",
      "patch": "@@ -20,7 +20,6 @@\n \n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.TimeUnit;\n-\n import io.netty.channel.ConnectTimeoutException;\n import org.apache.pulsar.client.api.PulsarClient;\n import org.testng.Assert;\n@@ -33,21 +32,15 @@ public class ConnectionTimeoutTest {\n \n     @Test\n     public void testLowTimeout() throws Exception {\n-        long startNanos = System.nanoTime();\n-\n         try (PulsarClient clientLow = PulsarClient.builder().serviceUrl(blackholeBroker)\n                 .connectionTimeout(1, TimeUnit.MILLISECONDS)\n-                .operationTimeout(1000, TimeUnit.MILLISECONDS).build();\n-             PulsarClient clientDefault = PulsarClient.builder().serviceUrl(blackholeBroker)\n-                 .operationTimeout(1000, TimeUnit.MILLISECONDS).build()) {\n+                .operationTimeout(1000, TimeUnit.MILLISECONDS).build()) {\n             CompletableFuture<?> lowFuture = clientLow.newProducer().topic(\"foo\").createAsync();\n-            CompletableFuture<?> defaultFuture = clientDefault.newProducer().topic(\"foo\").createAsync();\n \n             try {\n                 lowFuture.get();\n                 Assert.fail(\"Shouldn't be able to connect to anything\");\n             } catch (Exception e) {\n-                Assert.assertFalse(defaultFuture.isDone());\n                 Assert.assertEquals(e.getCause().getCause().getCause().getClass(), ConnectTimeoutException.class);\n             }\n         }",
      "parent_sha": "2e2cd4480d6ee7c6183826686a93a6e155ac3b7b"
    }
  },
  {
    "oid": "875262a0ae2fba82a6dd7d46dd2467d675b0d9c3",
    "message": "Fixed bug in permits log message (#10318)\n\nCo-authored-by: Devin Bost <dbost@overstock.com>",
    "date": "2021-04-22T21:13:17Z",
    "url": "https://github.com/apache/pulsar/commit/875262a0ae2fba82a6dd7d46dd2467d675b0d9c3",
    "details": {
      "sha": "99971ca809b6b40d8bf4636c82a506840603157b",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/persistent/PersistentDispatcherMultipleConsumers.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/pulsar/blob/875262a0ae2fba82a6dd7d46dd2467d675b0d9c3/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2Fpersistent%2FPersistentDispatcherMultipleConsumers.java",
      "raw_url": "https://github.com/apache/pulsar/raw/875262a0ae2fba82a6dd7d46dd2467d675b0d9c3/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2Fpersistent%2FPersistentDispatcherMultipleConsumers.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2Fpersistent%2FPersistentDispatcherMultipleConsumers.java?ref=875262a0ae2fba82a6dd7d46dd2467d675b0d9c3",
      "patch": "@@ -495,7 +495,7 @@ protected void sendMessagesToConsumers(ReadType readType, List<Entry> entries) {\n             if (log.isDebugEnabled() && !c.isWritable()) {\n                 log.debug(\"[{}-{}] consumer is not writable. dispatching only 1 message to {}; \"\n                                 + \"availablePermits are {}\", topic.getName(), name,\n-                        c, availablePermits);\n+                        c, c.getAvailablePermits());\n             }\n             int messagesForC = Math.min(\n                     Math.min(entriesToDispatch, availablePermits),",
      "parent_sha": "458c254d6424bfd98ee6f65d3e437838b0150766"
    }
  },
  {
    "oid": "25cb1fb75bef7d11242c9c4400b95975b606207a",
    "message": "[improve][test] Improve the ClusterMetadataSetupTest to reduce the execution time (#17627)",
    "date": "2022-09-15T00:28:43Z",
    "url": "https://github.com/apache/pulsar/commit/25cb1fb75bef7d11242c9c4400b95975b606207a",
    "details": {
      "sha": "84a42aace857d1c69802864d73708ec799c35b8c",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/broker/zookeeper/ClusterMetadataSetupTest.java",
      "status": "modified",
      "additions": 11,
      "deletions": 8,
      "changes": 19,
      "blob_url": "https://github.com/apache/pulsar/blob/25cb1fb75bef7d11242c9c4400b95975b606207a/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fzookeeper%2FClusterMetadataSetupTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/25cb1fb75bef7d11242c9c4400b95975b606207a/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fzookeeper%2FClusterMetadataSetupTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fzookeeper%2FClusterMetadataSetupTest.java?ref=25cb1fb75bef7d11242c9c4400b95975b606207a",
      "patch": "@@ -48,14 +48,14 @@\n import org.apache.pulsar.metadata.api.MetadataStoreConfig;\n import org.apache.pulsar.metadata.api.extended.MetadataStoreExtended;\n import org.apache.pulsar.zookeeper.LocalBookkeeperEnsemble;\n-import org.apache.pulsar.zookeeper.ZookeeperServerTest;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.ZooKeeper;\n import org.apache.zookeeper.server.NIOServerCnxnFactory;\n import org.apache.zookeeper.server.ZooKeeperServer;\n import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.BeforeClass;\n import org.testng.annotations.DataProvider;\n import org.testng.annotations.Test;\n \n@@ -405,17 +405,22 @@ public void testInitialNamespaceSetupZKDefaultsFallbackWithChroot() throws Excep\n \n     }\n \n-    @BeforeMethod\n+    @BeforeClass\n     void setup() throws Exception {\n         localZkS = new ZookeeperServerTest(0);\n         localZkS.start();\n     }\n \n-    @AfterMethod(alwaysRun = true)\n+    @AfterClass\n     void teardown() throws Exception {\n         localZkS.close();\n     }\n \n+    @AfterMethod(alwaysRun = true)\n+    void cleanup() {\n+        localZkS.clear();\n+    }\n+\n     static class ZookeeperServerTest implements Closeable {\n         private final File zkTmpDir;\n         private ZooKeeperServer zks;\n@@ -448,10 +453,8 @@ public void start() throws IOException {\n             log.info(\"ZooKeeper started at {}\", hostPort);\n         }\n \n-        public void stop() throws IOException {\n-            zks.shutdown();\n-            serverFactory.shutdown();\n-            log.info(\"Stoppend ZK server at {}\", hostPort);\n+        private void clear() {\n+            zks.getZKDatabase().clear();\n         }\n \n         @Override",
      "parent_sha": "4ef8dc5abcb2b7a2e1d10449c59331b974d10854"
    }
  },
  {
    "oid": "fe19b3ca949009c952270a64ba94dbb329ea572f",
    "message": "[ML] Fix race condition in getManagedLedgerInternalStats when includeLedgerMetadata=true (#15918)\n\n- getLedgerMetadata is an asynchronous operation and the final result shouldn't complete before the\n  metadata for all ledgers has been retrieved",
    "date": "2022-06-04T07:36:00Z",
    "url": "https://github.com/apache/pulsar/commit/fe19b3ca949009c952270a64ba94dbb329ea572f",
    "details": {
      "sha": "56399f74fd667cf19926efbbf6524dc54576ae28",
      "filename": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedLedgerImpl.java",
      "status": "modified",
      "additions": 51,
      "deletions": 35,
      "changes": 86,
      "blob_url": "https://github.com/apache/pulsar/blob/fe19b3ca949009c952270a64ba94dbb329ea572f/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedLedgerImpl.java",
      "raw_url": "https://github.com/apache/pulsar/raw/fe19b3ca949009c952270a64ba94dbb329ea572f/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedLedgerImpl.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedLedgerImpl.java?ref=fe19b3ca949009c952270a64ba94dbb329ea572f",
      "patch": "@@ -37,6 +37,7 @@\n import io.netty.util.ReferenceCountUtil;\n import java.io.IOException;\n import java.time.Clock;\n+import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n@@ -4045,45 +4046,60 @@ public CompletableFuture<ManagedLedgerInternalStats> getManagedLedgerInternalSta\n         stats.lastConfirmedEntry = this.getLastConfirmedEntry().toString();\n         stats.state = this.getState().toString();\n \n-        stats.ledgers = Lists.newArrayList();\n-        this.getLedgersInfo().forEach((id, li) -> {\n-            ManagedLedgerInternalStats.LedgerInfo info = new ManagedLedgerInternalStats.LedgerInfo();\n-            info.ledgerId = li.getLedgerId();\n-            info.entries = li.getEntries();\n-            info.size = li.getSize();\n-            info.offloaded = li.hasOffloadContext() && li.getOffloadContext().getComplete();\n-            stats.ledgers.add(info);\n-            if (includeLedgerMetadata) {\n-                this.getLedgerMetadata(li.getLedgerId()).handle((lMetadata, ex) -> {\n-                    if (ex == null) {\n-                        info.metadata = lMetadata;\n-                    }\n+        stats.cursors = Maps.newTreeMap();\n+        this.getCursors().forEach(c -> {\n+            ManagedCursorImpl cursor = (ManagedCursorImpl) c;\n+            PersistentTopicInternalStats.CursorStats cs = new PersistentTopicInternalStats.CursorStats();\n+            cs.markDeletePosition = cursor.getMarkDeletedPosition().toString();\n+            cs.readPosition = cursor.getReadPosition().toString();\n+            cs.waitingReadOp = cursor.hasPendingReadRequest();\n+            cs.pendingReadOps = cursor.getPendingReadOpsCount();\n+            cs.messagesConsumedCounter = cursor.getMessagesConsumedCounter();\n+            cs.cursorLedger = cursor.getCursorLedger();\n+            cs.cursorLedgerLastEntry = cursor.getCursorLedgerLastEntry();\n+            cs.individuallyDeletedMessages = cursor.getIndividuallyDeletedMessages();\n+            cs.lastLedgerSwitchTimestamp = DateFormatter.format(cursor.getLastLedgerSwitchTimestamp());\n+            cs.state = cursor.getState();\n+            cs.numberOfEntriesSinceFirstNotAckedMessage = cursor.getNumberOfEntriesSinceFirstNotAckedMessage();\n+            cs.totalNonContiguousDeletedMessagesRange = cursor.getTotalNonContiguousDeletedMessagesRange();\n+            cs.properties = cursor.getProperties();\n+            stats.cursors.put(cursor.getName(), cs);\n+        });\n+\n+        // make a snapshot of the ledgers infos since we are iterating it twice when metadata is included\n+        // a list is sufficient since there's no need to lookup by the ledger id\n+        List<LedgerInfo> ledgersInfos = new ArrayList<>(this.getLedgersInfo().values());\n+\n+        // add asynchronous metadata retrieval operations to a hashmap\n+        Map<Long, CompletableFuture<String>> ledgerMetadataFutures = new HashMap();\n+        if (includeLedgerMetadata) {\n+            ledgersInfos.forEach(li -> {\n+                long ledgerId = li.getLedgerId();\n+                ledgerMetadataFutures.put(ledgerId, this.getLedgerMetadata(ledgerId).exceptionally(throwable -> {\n+                    log.warn(\"Getting metadata for ledger {} failed.\", ledgerId, throwable);\n                     return null;\n-                });\n-            }\n+                }));\n+            });\n+        }\n \n-            stats.cursors = Maps.newTreeMap();\n-            this.getCursors().forEach(c -> {\n-                ManagedCursorImpl cursor = (ManagedCursorImpl) c;\n-                PersistentTopicInternalStats.CursorStats cs = new PersistentTopicInternalStats.CursorStats();\n-                cs.markDeletePosition = cursor.getMarkDeletedPosition().toString();\n-                cs.readPosition = cursor.getReadPosition().toString();\n-                cs.waitingReadOp = cursor.hasPendingReadRequest();\n-                cs.pendingReadOps = cursor.getPendingReadOpsCount();\n-                cs.messagesConsumedCounter = cursor.getMessagesConsumedCounter();\n-                cs.cursorLedger = cursor.getCursorLedger();\n-                cs.cursorLedgerLastEntry = cursor.getCursorLedgerLastEntry();\n-                cs.individuallyDeletedMessages = cursor.getIndividuallyDeletedMessages();\n-                cs.lastLedgerSwitchTimestamp = DateFormatter.format(cursor.getLastLedgerSwitchTimestamp());\n-                cs.state = cursor.getState();\n-                cs.numberOfEntriesSinceFirstNotAckedMessage =\n-                        cursor.getNumberOfEntriesSinceFirstNotAckedMessage();\n-                cs.totalNonContiguousDeletedMessagesRange = cursor.getTotalNonContiguousDeletedMessagesRange();\n-                cs.properties = cursor.getProperties();\n-                stats.cursors.put(cursor.getName(), cs);\n+        // wait until metadata has been retrieved\n+        FutureUtil.waitForAll(ledgerMetadataFutures.values()).thenAccept(__ -> {\n+            stats.ledgers = Lists.newArrayList();\n+            ledgersInfos.forEach(li -> {\n+                ManagedLedgerInternalStats.LedgerInfo info = new ManagedLedgerInternalStats.LedgerInfo();\n+                info.ledgerId = li.getLedgerId();\n+                info.entries = li.getEntries();\n+                info.size = li.getSize();\n+                info.offloaded = li.hasOffloadContext() && li.getOffloadContext().getComplete();\n+                if (includeLedgerMetadata) {\n+                    // lookup metadata from the hashmap which contains completed async operations\n+                    info.metadata = ledgerMetadataFutures.get(li.getLedgerId()).getNow(null);\n+                }\n+                stats.ledgers.add(info);\n             });\n+            statFuture.complete(stats);\n         });\n-        statFuture.complete(stats);\n+\n         return statFuture;\n     }\n ",
      "parent_sha": "fcc7fe7d98ca6980e219adbd4792812dd60c2829"
    }
  },
  {
    "oid": "1bdbad348a032d1bf93c5f514c89e81278219f54",
    "message": "Ensumer Mocked BK client triggers the addEntry callbacks in order (#2694)",
    "date": "2018-10-02T16:42:47Z",
    "url": "https://github.com/apache/pulsar/commit/1bdbad348a032d1bf93c5f514c89e81278219f54",
    "details": {
      "sha": "cedd3b036b9bb58e3d99070125444460407aab88",
      "filename": "managed-ledger/src/test/java/org/apache/bookkeeper/client/PulsarMockLedgerHandle.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/pulsar/blob/1bdbad348a032d1bf93c5f514c89e81278219f54/managed-ledger%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPulsarMockLedgerHandle.java",
      "raw_url": "https://github.com/apache/pulsar/raw/1bdbad348a032d1bf93c5f514c89e81278219f54/managed-ledger%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPulsarMockLedgerHandle.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/managed-ledger%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fclient%2FPulsarMockLedgerHandle.java?ref=1bdbad348a032d1bf93c5f514c89e81278219f54",
      "patch": "@@ -181,7 +181,7 @@ public void asyncAddEntry(final ByteBuf data, final AddCallback cb, final Object\n                     } else {\n                         cb.addComplete(BKException.Code.OK, PulsarMockLedgerHandle.this, entryId, ctx);\n                     }\n-                });\n+                }, bk.executor);\n     }\n \n     @Override",
      "parent_sha": "248e3296412f1d5471fc048947e687f2374e8b68"
    }
  },
  {
    "oid": "f95c71f21aae9e8299597295ccb2bc6954d82ae5",
    "message": "Make standalone to advertise \"localhost\" to avoid failure when hostname is not resolvable (#5856)\n\n### Motivation\r\n\r\nThe standalone service is failing to startup when the hostname is not resolvable to an IP. This is common in laptops. \r\n\r\nThe reason is that the function worker in standalone is trying to connect to the advertised address rather than \"localhost\". \r\n\r\nTo fix this, we should make the standalone to always advertise \"localhost\" as the the broker address. This is ok because in any case the standalone treats the advertisement as the pulsar proxy, in that it forces the clients to always go through the same service url, so a client connecting from a different host won't have problems.",
    "date": "2020-01-04T12:25:04Z",
    "url": "https://github.com/apache/pulsar/commit/f95c71f21aae9e8299597295ccb2bc6954d82ae5",
    "details": {
      "sha": "e5e9b45beba16d1c99f48f1692cb87260c55f052",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/PulsarStandaloneStarter.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/pulsar/blob/f95c71f21aae9e8299597295ccb2bc6954d82ae5/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2FPulsarStandaloneStarter.java",
      "raw_url": "https://github.com/apache/pulsar/raw/f95c71f21aae9e8299597295ccb2bc6954d82ae5/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2FPulsarStandaloneStarter.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2FPulsarStandaloneStarter.java?ref=f95c71f21aae9e8299597295ccb2bc6954d82ae5",
      "patch": "@@ -67,7 +67,7 @@ public PulsarStandaloneStarter(String[] args) throws Exception {\n             zkServers = this.getAdvertisedAddress();\n         } else if (isBlank(config.getAdvertisedAddress())) {\n             // Use advertised address as local hostname\n-            config.setAdvertisedAddress(ServiceConfigurationUtils.unsafeLocalhostResolve());\n+            config.setAdvertisedAddress(\"localhost\");\n         } else {\n             // Use advertised address from config file\n         }",
      "parent_sha": "88fc454173af94d33986e608e94037db556a9226"
    }
  },
  {
    "oid": "f27d8253b17d4859a29921378faf819dbbe5ea5d",
    "message": "Fix RetentionPolicies comment typo (#16823)",
    "date": "2022-07-29T01:20:31Z",
    "url": "https://github.com/apache/pulsar/commit/f27d8253b17d4859a29921378faf819dbbe5ea5d",
    "details": {
      "sha": "2010ce0bf1eb24a1ea0bf64c3dce400528800cb6",
      "filename": "pulsar-client-admin-api/src/main/java/org/apache/pulsar/common/policies/data/RetentionPolicies.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/pulsar/blob/f27d8253b17d4859a29921378faf819dbbe5ea5d/pulsar-client-admin-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fcommon%2Fpolicies%2Fdata%2FRetentionPolicies.java",
      "raw_url": "https://github.com/apache/pulsar/raw/f27d8253b17d4859a29921378faf819dbbe5ea5d/pulsar-client-admin-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fcommon%2Fpolicies%2Fdata%2FRetentionPolicies.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-client-admin-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fcommon%2Fpolicies%2Fdata%2FRetentionPolicies.java?ref=f27d8253b17d4859a29921378faf819dbbe5ea5d",
      "patch": "@@ -22,7 +22,7 @@\n  * Definition of the retention policy.\n  *\n  * <p>When you set a retention policy you must set **both** a *size limit* and a *time limit*.\n- * In the case where you don't want to limit by either time or set, the value must be set to `-1`.\n+ * In the case where you don't want to limit by either time or size, the value must be set to `-1`.\n  * Retention policy will be effectively disabled and it won't prevent the deletion of acknowledged\n  * messages when either size or time limit is set to `0`.\n  * Infinite retention can be achieved by setting both time and size limits to `-1`.",
      "parent_sha": "336bffdce9ebe16e11996e2d43c2dace67807470"
    }
  },
  {
    "oid": "ad72b7e40d48a68700ff01b268eb791b0c50950d",
    "message": "Fix consumer stats log error. (#3327)",
    "date": "2019-01-08T18:27:54Z",
    "url": "https://github.com/apache/pulsar/commit/ad72b7e40d48a68700ff01b268eb791b0c50950d",
    "details": {
      "sha": "e330b57c1f535a32316eef86aaf830e63bd51a6c",
      "filename": "pulsar-client/src/main/java/org/apache/pulsar/client/impl/ConsumerStatsRecorderImpl.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/apache/pulsar/blob/ad72b7e40d48a68700ff01b268eb791b0c50950d/pulsar-client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FConsumerStatsRecorderImpl.java",
      "raw_url": "https://github.com/apache/pulsar/raw/ad72b7e40d48a68700ff01b268eb791b0c50950d/pulsar-client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FConsumerStatsRecorderImpl.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-client%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fimpl%2FConsumerStatsRecorderImpl.java?ref=ad72b7e40d48a68700ff01b268eb791b0c50950d",
      "patch": "@@ -131,8 +131,8 @@ private void init(ConsumerConfigurationData<?> conf) {\n                 if ((currentNumMsgsReceived | currentNumBytesReceived | currentNumReceiveFailed | currentNumAcksSent\n                         | currentNumAcksFailed) != 0) {\n                     log.info(\n-                            \"[{}] [{}] [{}] Prefetched messages: {} --- Consume throughput: {} msgs/s --- \"\n-                                    + \"Throughput received: {} msg/s --- {} Mbit/s --- \"\n+                            \"[{}] [{}] [{}] Prefetched messages: {} --- \"\n+                                    + \"Consume throughput received: {} msgs/s --- {} Mbit/s --- \"\n                                     + \"Ack sent rate: {} ack/s --- \" + \"Failed messages: {} --- \" + \"Failed acks: {}\",\n                             consumer.getTopic(), consumer.getSubscription(), consumer.consumerName,\n                             consumer.incomingMessages.size(), THROUGHPUT_FORMAT.format(receivedMsgsRate),",
      "parent_sha": "ccfa3894b9924f2c1dfff743b3905df654d6c156"
    }
  },
  {
    "oid": "b3545cc3b9ecd44ea4cfb1cb8735c65f6d85fbe9",
    "message": "[Tests] Fix flaky test ResourceGroupConfigListenerTest (#11048)\n\nFixes #11045\r\n\r\n### Motivation\r\n\r\nFixes flaky test ResourceGroupConfigListenerTest\r\n\r\n### Modifications\r\n\r\n- remove `atMost` and rely on Awaitility default of 10 seconds.\r\n- refactor deletion test to not use Thread.sleep\r\n  - first check that all resource groups exist\r\n  - then delete",
    "date": "2021-06-23T20:04:03Z",
    "url": "https://github.com/apache/pulsar/commit/b3545cc3b9ecd44ea4cfb1cb8735c65f6d85fbe9",
    "details": {
      "sha": "3071edb74f2acaf93480dfd39ca54a3b76fef40f",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/broker/resourcegroup/ResourceGroupConfigListenerTest.java",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/apache/pulsar/blob/b3545cc3b9ecd44ea4cfb1cb8735c65f6d85fbe9/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fresourcegroup%2FResourceGroupConfigListenerTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/b3545cc3b9ecd44ea4cfb1cb8735c65f6d85fbe9/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fresourcegroup%2FResourceGroupConfigListenerTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fresourcegroup%2FResourceGroupConfigListenerTest.java?ref=b3545cc3b9ecd44ea4cfb1cb8735c65f6d85fbe9",
      "patch": "@@ -22,23 +22,18 @@\n import static org.testng.Assert.assertNotNull;\n import static org.testng.Assert.assertNull;\n import static org.testng.Assert.assertThrows;\n-\n import com.google.common.collect.Sets;\n+import java.util.Random;\n import org.apache.pulsar.broker.auth.MockedPulsarServiceBaseTest;\n import org.apache.pulsar.client.admin.PulsarAdminException;\n import org.apache.pulsar.common.policies.data.ClusterData;\n-import org.apache.pulsar.common.policies.data.ClusterDataImpl;\n import org.apache.pulsar.common.policies.data.ResourceGroup;\n import org.apache.pulsar.common.policies.data.TenantInfoImpl;\n import org.awaitility.Awaitility;\n import org.testng.annotations.AfterClass;\n import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Ignore;\n import org.testng.annotations.Test;\n \n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n public class ResourceGroupConfigListenerTest extends MockedPulsarServiceBaseTest {\n \n     ResourceGroup testAddRg = new ResourceGroup();\n@@ -64,7 +59,7 @@ protected void cleanup() throws Exception {\n     public void createResourceGroup(String rgName, ResourceGroup rg) throws PulsarAdminException {\n         admin.resourcegroups().createResourceGroup(rgName, rg);\n \n-        Awaitility.await().atMost(1, TimeUnit.SECONDS).untilAsserted(() -> {\n+        Awaitility.await().untilAsserted(() -> {\n             final org.apache.pulsar.broker.resourcegroup.ResourceGroup resourceGroup = pulsar\n                     .getResourceGroupServiceManager().resourceGroupGet(rgName);\n             assertNotNull(resourceGroup);\n@@ -75,14 +70,14 @@ public void createResourceGroup(String rgName, ResourceGroup rg) throws PulsarAd\n \n     public void deleteResourceGroup(String rgName) throws PulsarAdminException {\n         admin.resourcegroups().deleteResourceGroup(rgName);\n-        Awaitility.await().atMost(1, TimeUnit.SECONDS)\n+        Awaitility.await()\n                 .untilAsserted(() -> assertNull(pulsar.getResourceGroupServiceManager().resourceGroupGet(rgName)));\n     }\n \n     public void updateResourceGroup(String rgName, ResourceGroup rg) throws PulsarAdminException {\n         testAddRg.setPublishRateInMsgs(200000);\n         admin.resourcegroups().updateResourceGroup(rgName, rg);\n-        Awaitility.await().atMost(1, TimeUnit.SECONDS).untilAsserted(() -> {\n+        Awaitility.await().untilAsserted(() -> {\n             final org.apache.pulsar.broker.resourcegroup.ResourceGroup resourceGroup = pulsar\n                     .getResourceGroupServiceManager().resourceGroupGet(rgName);\n             assertNotNull(resourceGroup);\n@@ -126,7 +121,7 @@ public void testResourceGroupAttachToNamespace() throws Exception {\n         admin.namespaces().createNamespace(namespaceName);\n         admin.namespaces().setNamespaceResourceGroup(namespaceName, rgName);\n \n-        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAsserted(() ->\n+        Awaitility.await().untilAsserted(() ->\n                         assertNotNull(pulsar\n                                 .getResourceGroupServiceManager()\n                                 .getNamespaceResourceGroup(namespaceName)));\n@@ -150,20 +145,25 @@ public void testResourceGroupCreateMany() throws Exception {\n             admin.resourcegroups().createResourceGroup(rgName, testAddRg);\n         }\n \n-        Thread.sleep(1000);\n+        Awaitility.await().untilAsserted(() -> {\n+            for (int i = 0; i < MAX_RGS; i++) {\n+                String rgName = String.format(\"testRg-%d\", i);\n+                assertNotNull(pulsar.getResourceGroupServiceManager().resourceGroupGet(rgName));\n+            }\n+        });\n+\n \n         for (int i = 0; i < MAX_RGS; i++) {\n             String rgName = String.format(\"testRg-%d\", i);\n-            assertNotNull(pulsar.getResourceGroupServiceManager().resourceGroupGet(rgName));\n             admin.resourcegroups().deleteResourceGroup(rgName);\n         }\n \n-        Thread.sleep(1000);\n-\n-        for (int i = 0; i < MAX_RGS; i++) {\n-            String rgName = String.format(\"testRg-%d\", i);\n-            assertNull(pulsar.getResourceGroupServiceManager().resourceGroupGet(rgName));\n-        }\n+        Awaitility.await().untilAsserted(() -> {\n+            for (int i = 0; i < MAX_RGS; i++) {\n+                String rgName = String.format(\"testRg-%d\", i);\n+                assertNull(pulsar.getResourceGroupServiceManager().resourceGroupGet(rgName));\n+            }\n+        });\n     }\n \n     private void prepareData() throws PulsarAdminException {",
      "parent_sha": "999329a8ffa174212bf2285872a9a93e4ae61a02"
    }
  },
  {
    "oid": "6fc5214d4740a5e9c9d4f1421c9b03eb580ef5d8",
    "message": "remove topic -> namespace cache in LedgerOffloaderStatsImpl (#15869)",
    "date": "2022-06-04T16:26:27Z",
    "url": "https://github.com/apache/pulsar/commit/6fc5214d4740a5e9c9d4f1421c9b03eb580ef5d8",
    "details": {
      "sha": "64b0d12516250dd4314b5f6b7117a0e21795490d",
      "filename": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/LedgerOffloaderStatsImpl.java",
      "status": "modified",
      "additions": 7,
      "deletions": 13,
      "changes": 20,
      "blob_url": "https://github.com/apache/pulsar/blob/6fc5214d4740a5e9c9d4f1421c9b03eb580ef5d8/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FLedgerOffloaderStatsImpl.java",
      "raw_url": "https://github.com/apache/pulsar/raw/6fc5214d4740a5e9c9d4f1421c9b03eb580ef5d8/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FLedgerOffloaderStatsImpl.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FLedgerOffloaderStatsImpl.java?ref=6fc5214d4740a5e9c9d4f1421c9b03eb580ef5d8",
      "patch": "@@ -59,7 +59,6 @@ public final class LedgerOffloaderStatsImpl implements LedgerOffloaderStats, Run\n     private final Summary readOffloadDataLatency;\n \n     private final Map<String, Long> topicAccess;\n-    private final Map<String, String> topic2Namespace;\n     private final Map<String, Pair<LongAdder, LongAdder>> offloadAndReadOffloadBytesMap;\n \n     final AtomicBoolean closed = new AtomicBoolean(false);\n@@ -73,7 +72,6 @@ private LedgerOffloaderStatsImpl(boolean exposeTopicLevelMetrics,\n         }\n \n         this.topicAccess = new ConcurrentHashMap<>();\n-        this.topic2Namespace = new ConcurrentHashMap<>();\n         this.offloadAndReadOffloadBytesMap = new ConcurrentHashMap<>();\n \n         String[] labels = exposeTopicLevelMetrics\n@@ -205,13 +203,11 @@ private String[] labelValues(String topic) {\n     }\n \n     private String getNamespace(String topic) {\n-        return this.topic2Namespace.computeIfAbsent(topic, t -> {\n-            try {\n-                return TopicName.get(t).getNamespace();\n-            } catch (IllegalArgumentException ex) {\n-                return UNKNOWN;\n-            }\n-        });\n+        try {\n+            return TopicName.get(topic).getNamespace();\n+        } catch (IllegalArgumentException ex) {\n+            return UNKNOWN;\n+        }\n     }\n \n     private void cleanExpiredTopicMetrics() {\n@@ -223,7 +219,6 @@ private void cleanExpiredTopicMetrics() {\n             long access = entry.getValue();\n \n             if (now - access >= timeout) {\n-                this.topic2Namespace.remove(topic);\n                 this.offloadAndReadOffloadBytesMap.remove(topic);\n                 String[] labelValues = this.labelValues(topic);\n                 this.offloadError.remove(labelValues);\n@@ -273,7 +268,6 @@ public void close() throws Exception {\n             CollectorRegistry.defaultRegistry.unregister(this.readOffloadRate);\n             CollectorRegistry.defaultRegistry.unregister(this.readOffloadIndexLatency);\n             CollectorRegistry.defaultRegistry.unregister(this.readOffloadDataLatency);\n-            this.topic2Namespace.clear();\n             this.offloadAndReadOffloadBytesMap.clear();\n         }\n     }\n@@ -285,7 +279,7 @@ public long getOffloadBytes(String topic) {\n             return pair.getLeft().sum();\n         }\n \n-        String namespace = this.topic2Namespace.get(topic);\n+        String namespace = this.getNamespace(topic);\n         List<String> topics = this.offloadAndReadOffloadBytesMap.keySet().stream()\n                 .filter(topicName -> topicName.contains(namespace)).collect(Collectors.toList());\n \n@@ -321,7 +315,7 @@ public long getReadOffloadBytes(String topic) {\n             return pair.getRight().sum();\n         }\n \n-        String namespace = this.topic2Namespace.get(topic);\n+        String namespace = this.getNamespace(topic);\n         List<String> topics = this.offloadAndReadOffloadBytesMap.keySet().stream()\n                 .filter(topicName -> topicName.contains(namespace)).collect(Collectors.toList());\n ",
      "parent_sha": "fe19b3ca949009c952270a64ba94dbb329ea572f"
    }
  },
  {
    "oid": "834e2cb78e6354a8e74146f599b20ab2c75af5d9",
    "message": "Fix lookup permission error (#7234)\n\n### Motivation\r\nCurrently\uff0cwhen pulsar AuthorizationService check lookup permission, if the role canProducer **or** canConsumer mean that canLookup, but actually in the code https://github.com/apache/pulsar/blob/master/pulsar-broker-common/src/main/java/org/apache/pulsar/broker/authorization/AuthorizationService.java#L267, if the method canProduce or canConsume throw exception, `canLookup` will just throw the exception and won't check the other permission.\r\n\r\n### Modification\r\ninvoke `canLookupAsync` instead.",
    "date": "2020-06-11T07:59:22Z",
    "url": "https://github.com/apache/pulsar/commit/834e2cb78e6354a8e74146f599b20ab2c75af5d9",
    "details": {
      "sha": "10b35ef7ffedc985830c9e13b0859438656a3624",
      "filename": "pulsar-broker-common/src/main/java/org/apache/pulsar/broker/authorization/AuthorizationService.java",
      "status": "modified",
      "additions": 12,
      "deletions": 2,
      "changes": 14,
      "blob_url": "https://github.com/apache/pulsar/blob/834e2cb78e6354a8e74146f599b20ab2c75af5d9/pulsar-broker-common%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fauthorization%2FAuthorizationService.java",
      "raw_url": "https://github.com/apache/pulsar/raw/834e2cb78e6354a8e74146f599b20ab2c75af5d9/pulsar-broker-common%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fauthorization%2FAuthorizationService.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker-common%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fauthorization%2FAuthorizationService.java?ref=834e2cb78e6354a8e74146f599b20ab2c75af5d9",
      "patch": "@@ -264,8 +264,18 @@ public boolean canConsume(TopicName topicName, String role, AuthenticationDataSo\n      */\n     public boolean canLookup(TopicName topicName, String role, AuthenticationDataSource authenticationData)\n             throws Exception {\n-        return canProduce(topicName, role, authenticationData)\n-                || canConsume(topicName, role, authenticationData, null);\n+        try {\n+            return canLookupAsync(topicName, role, authenticationData)\n+                    .get(conf.getZooKeeperOperationTimeoutSeconds(), SECONDS);\n+        } catch (InterruptedException e) {\n+            log.warn(\"Time-out {} sec while checking authorization on {} \", conf.getZooKeeperOperationTimeoutSeconds(),\n+                    topicName);\n+            throw e;\n+        } catch (Exception e) {\n+            log.warn(\"Role - {} failed to get lookup permissions for topic - {}. {}\", role, topicName,\n+                    e.getMessage());\n+            throw e;\n+        }\n     }\n \n     /**",
      "parent_sha": "0c9c9fccbbdebd730acc04a759786babe4ce967a"
    }
  },
  {
    "oid": "addfbd351c9b43995f252bd42123b236451ef258",
    "message": "[fix][admin] Fix get-publish-rete Admin API handle exception behavior (#16001)",
    "date": "2022-06-11T00:21:40Z",
    "url": "https://github.com/apache/pulsar/commit/addfbd351c9b43995f252bd42123b236451ef258",
    "details": {
      "sha": "f55ebb66837a6f359a25352e7accc99e0abcc92c",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/v2/Namespaces.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/apache/pulsar/blob/addfbd351c9b43995f252bd42123b236451ef258/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2Fv2%2FNamespaces.java",
      "raw_url": "https://github.com/apache/pulsar/raw/addfbd351c9b43995f252bd42123b236451ef258/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2Fv2%2FNamespaces.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fadmin%2Fv2%2FNamespaces.java?ref=addfbd351c9b43995f252bd42123b236451ef258",
      "patch": "@@ -773,9 +773,10 @@ public void getPublishRate(@Suspended AsyncResponse asyncResponse,\n             @PathParam(\"namespace\") String namespace) {\n         validateNamespaceName(property, namespace);\n         internalGetPublishRateAsync()\n-                .thenAccept(publishRate -> asyncResponse.resume(publishRate))\n+                .thenAccept(asyncResponse::resume)\n                 .exceptionally(ex -> {\n                     log.error(\"Failed to get publish rate for namespace {}\", namespaceName, ex);\n+                    resumeAsyncResponseExceptionally(asyncResponse, ex);\n                     return null;\n                 });\n     }",
      "parent_sha": "c4ee1097087b74172b2235b4a3e8b84c46973514"
    }
  },
  {
    "oid": "93ed61bf9bf3470af8f44c170c4ae41b8a57f466",
    "message": "[fix][test] Fix flaky test SimpleProducerConsumerStatTest#testPartitionTopicStats (#21642)",
    "date": "2023-11-29T14:13:38Z",
    "url": "https://github.com/apache/pulsar/commit/93ed61bf9bf3470af8f44c170c4ae41b8a57f466",
    "details": {
      "sha": "5185a3b7e267ce78baa03edf56a9a05c6a4a0bee",
      "filename": "pulsar-broker/src/test/java/org/apache/pulsar/client/api/SimpleProducerConsumerStatTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/apache/pulsar/blob/93ed61bf9bf3470af8f44c170c4ae41b8a57f466/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fapi%2FSimpleProducerConsumerStatTest.java",
      "raw_url": "https://github.com/apache/pulsar/raw/93ed61bf9bf3470af8f44c170c4ae41b8a57f466/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fapi%2FSimpleProducerConsumerStatTest.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fpulsar%2Fclient%2Fapi%2FSimpleProducerConsumerStatTest.java?ref=93ed61bf9bf3470af8f44c170c4ae41b8a57f466",
      "patch": "@@ -46,6 +46,7 @@\n import org.awaitility.Awaitility;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n import org.testng.annotations.AfterMethod;\n import org.testng.annotations.BeforeMethod;\n import org.testng.annotations.DataProvider;\n@@ -495,9 +496,10 @@ public void testPartitionTopicStats() throws Exception {\n             msg = consumer.receive(5, TimeUnit.SECONDS);\n             String receivedMessage = new String(msg.getData());\n             log.info(\"Received message: [{}]\", receivedMessage);\n-            String expectedMessage = \"my-message-\" + i;\n-            testMessageOrderAndDuplicates(messageSet, receivedMessage, expectedMessage);\n+            Assert.assertTrue(messageSet.add(receivedMessage), \"Received duplicate message \" + receivedMessage);\n         }\n+        Assert.assertEquals(messageSet.size(), numMessages);\n+\n         // Acknowledge the consumption of all messages at once\n         consumer.acknowledgeCumulative(msg);\n ",
      "parent_sha": "81a9a527b353c07db0743f970edb009a929888fe"
    }
  },
  {
    "oid": "aeb4503be59f9a9450dfd47cf5dfcb375735d064",
    "message": "[fix][broker] Typos in ManagedLedgerImpl (#18445)",
    "date": "2022-11-17T10:34:50Z",
    "url": "https://github.com/apache/pulsar/commit/aeb4503be59f9a9450dfd47cf5dfcb375735d064",
    "details": {
      "sha": "816ae9e55437c95ceabb67d45c4955722d33fb89",
      "filename": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedLedgerImpl.java",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/apache/pulsar/blob/aeb4503be59f9a9450dfd47cf5dfcb375735d064/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedLedgerImpl.java",
      "raw_url": "https://github.com/apache/pulsar/raw/aeb4503be59f9a9450dfd47cf5dfcb375735d064/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedLedgerImpl.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedLedgerImpl.java?ref=aeb4503be59f9a9450dfd47cf5dfcb375735d064",
      "patch": "@@ -174,7 +174,7 @@ public class ManagedLedgerImpl implements ManagedLedger, CreateCallback {\n     private final ManagedCursorContainer activeCursors = new ManagedCursorContainer();\n \n \n-    // Ever increasing counter of entries added\n+    // Ever-increasing counter of entries added\n     @VisibleForTesting\n     static final AtomicLongFieldUpdater<ManagedLedgerImpl> ENTRIES_ADDED_COUNTER_UPDATER = AtomicLongFieldUpdater\n             .newUpdater(ManagedLedgerImpl.class, \"entriesAddedCounter\");\n@@ -317,7 +317,7 @@ public enum PositionBound {\n             .newUpdater(ManagedLedgerImpl.class, ReadEntryCallbackWrapper.class, \"lastReadCallback\");\n \n     /**\n-     * Queue of pending entries to be added to the managed ledger. Typically entries are queued when a new ledger is.\n+     * Queue of pending entries to be added to the managed ledger. Typically, entries are queued when a new ledger is.\n      * created asynchronously and hence there is no ready ledger to write into.\n      */\n     final ConcurrentLinkedQueue<OpAddEntry> pendingAddEntries = new ConcurrentLinkedQueue<>();\n@@ -1847,7 +1847,7 @@ void asyncReadEntries(OpReadEntry opReadEntry) {\n         } else {\n             LedgerInfo ledgerInfo = ledgers.get(ledgerId);\n             if (ledgerInfo == null || ledgerInfo.getEntries() == 0) {\n-                // Cursor is pointing to a empty ledger, there's no need to try opening it. Skip this ledger and\n+                // Cursor is pointing to an empty ledger, there's no need to try opening it. Skip this ledger and\n                 // move to the next one\n                 opReadEntry.updateReadPosition(new PositionImpl(opReadEntry.readPosition.getLedgerId() + 1, 0));\n                 opReadEntry.checkReadCompletion();\n@@ -3053,7 +3053,7 @@ public void asyncOffloadPrefix(Position pos, OffloadCallback callback, Object ct\n             long current = ledgers.lastKey();\n \n             // the first ledger which will not be offloaded. Defaults to current,\n-            // in the case that the whole headmap is offloaded. Otherwise it will\n+            // in the case that the whole headmap is offloaded. Otherwise, it will\n             // be set as we iterate through the headmap values\n             long firstLedgerRetained = current;\n             for (LedgerInfo ls : ledgers.headMap(current).values()) {\n@@ -3392,7 +3392,7 @@ long getNumberOfEntries(Range<PositionImpl> range) {\n      * @param n\n      *            number of entries to skip ahead\n      * @param startRange\n-     *            specifies whether or not to include the start position in calculating the distance\n+     *            specifies whether to include the start position in calculating the distance\n      * @return the new position that is n entries ahead\n      */\n     public PositionImpl getPositionAfterN(final PositionImpl startPosition, long n, PositionBound startRange) {\n@@ -3516,10 +3516,10 @@ public boolean isValidPosition(PositionImpl position) {\n \n             if (ls == null) {\n                 if (position.getLedgerId() < last.getLedgerId()) {\n-                    // Pointing to a non existing ledger that is older than the current ledger is invalid\n+                    // Pointing to a non-existing ledger that is older than the current ledger is invalid\n                     return false;\n                 } else {\n-                    // Pointing to a non existing ledger is only legitimate if the ledger was empty\n+                    // Pointing to a non-existing ledger is only legitimate if the ledger was empty\n                     return position.getEntryId() == 0;\n                 }\n             }",
      "parent_sha": "883f7606f8cd827dfe0ec8bce098fcee64eb587a"
    }
  },
  {
    "oid": "c0f89dc981fbe36be834303f13bd09f3b62b3d67",
    "message": "[improve][broker] Use shrink map for trackerCache (#19534)\n\nSigned-off-by: xiaolongran <xiaolongran@tencent.com>",
    "date": "2023-02-16T15:18:11Z",
    "url": "https://github.com/apache/pulsar/commit/c0f89dc981fbe36be834303f13bd09f3b62b3d67",
    "details": {
      "sha": "8c992d2f7a90bd064e6a541bf25ba4e70cb2a82d",
      "filename": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/InMemoryRedeliveryTracker.java",
      "status": "modified",
      "additions": 7,
      "deletions": 3,
      "changes": 10,
      "blob_url": "https://github.com/apache/pulsar/blob/c0f89dc981fbe36be834303f13bd09f3b62b3d67/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FInMemoryRedeliveryTracker.java",
      "raw_url": "https://github.com/apache/pulsar/raw/c0f89dc981fbe36be834303f13bd09f3b62b3d67/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FInMemoryRedeliveryTracker.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/pulsar-broker%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fpulsar%2Fbroker%2Fservice%2FInMemoryRedeliveryTracker.java?ref=c0f89dc981fbe36be834303f13bd09f3b62b3d67",
      "patch": "@@ -21,12 +21,16 @@\n import java.util.List;\n import org.apache.bookkeeper.mledger.Position;\n import org.apache.bookkeeper.mledger.impl.PositionImpl;\n-import org.apache.bookkeeper.util.collections.ConcurrentLongLongPairHashMap;\n-import org.apache.bookkeeper.util.collections.ConcurrentLongLongPairHashMap.LongPair;\n+import org.apache.pulsar.common.util.collections.ConcurrentLongLongPairHashMap;\n+import org.apache.pulsar.common.util.collections.ConcurrentLongLongPairHashMap.LongPair;\n \n public class InMemoryRedeliveryTracker implements RedeliveryTracker {\n \n-    private ConcurrentLongLongPairHashMap trackerCache = new ConcurrentLongLongPairHashMap(256, 1);\n+    private ConcurrentLongLongPairHashMap trackerCache = ConcurrentLongLongPairHashMap.newBuilder()\n+            .concurrencyLevel(1)\n+            .expectedItems(256)\n+            .autoShrink(true)\n+            .build();\n \n     @Override\n     public int incrementAndGetRedeliveryCount(Position position) {",
      "parent_sha": "fe547c7b7e1d4cb344419cbe37dc2ae771ca630f"
    }
  },
  {
    "oid": "5cf3fa0d8050b16305ee060820b884d69ec8a828",
    "message": "Fix when nextValidLedger is null cause npe (#13975)",
    "date": "2022-04-08T03:40:25Z",
    "url": "https://github.com/apache/pulsar/commit/5cf3fa0d8050b16305ee060820b884d69ec8a828",
    "details": {
      "sha": "199868b543fdd3080c3ca91cfdceec051080b180",
      "filename": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/apache/pulsar/blob/5cf3fa0d8050b16305ee060820b884d69ec8a828/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedCursorImpl.java",
      "raw_url": "https://github.com/apache/pulsar/raw/5cf3fa0d8050b16305ee060820b884d69ec8a828/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedCursorImpl.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/managed-ledger%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fbookkeeper%2Fmledger%2Fimpl%2FManagedCursorImpl.java?ref=5cf3fa0d8050b16305ee060820b884d69ec8a828",
      "patch": "@@ -1711,7 +1711,8 @@ public void asyncMarkDelete(final Position position, Map<String, Long> propertie\n             try {\n                 long ledgerEntries = ledger.getLedgerInfo(markDeletePosition.getLedgerId()).get().getEntries();\n                 Long nextValidLedger = ledger.getNextValidLedger(ledger.getLastConfirmedEntry().getLedgerId());\n-                shouldCursorMoveForward = (markDeletePosition.getEntryId() + 1 >= ledgerEntries)\n+                shouldCursorMoveForward = nextValidLedger != null\n+                        && (markDeletePosition.getEntryId() + 1 >= ledgerEntries)\n                         && (newPosition.getLedgerId() == nextValidLedger);\n             } catch (Exception e) {\n                 log.warn(\"Failed to get ledger entries while setting mark-delete-position\", e);",
      "parent_sha": "fbb93b38e6e9119c9ab15382eed3440877c4167b"
    }
  },
  {
    "oid": "4df2593a62606d3fcfd5ebab8923870814832569",
    "message": "[fix][test] Catch exception when update data in mockZookeeper (#16473)",
    "date": "2022-07-12T14:39:38Z",
    "url": "https://github.com/apache/pulsar/commit/4df2593a62606d3fcfd5ebab8923870814832569",
    "details": {
      "sha": "b9325c161022330dbc0f122fe6bdaef378cbb789",
      "filename": "testmocks/src/main/java/org/apache/zookeeper/MockZooKeeper.java",
      "status": "modified",
      "additions": 90,
      "deletions": 69,
      "changes": 159,
      "blob_url": "https://github.com/apache/pulsar/blob/4df2593a62606d3fcfd5ebab8923870814832569/testmocks%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2FMockZooKeeper.java",
      "raw_url": "https://github.com/apache/pulsar/raw/4df2593a62606d3fcfd5ebab8923870814832569/testmocks%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2FMockZooKeeper.java",
      "contents_url": "https://api.github.com/repos/apache/pulsar/contents/testmocks%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2FMockZooKeeper.java?ref=4df2593a62606d3fcfd5ebab8923870814832569",
      "patch": "@@ -334,8 +334,8 @@ public void create(final String path, final byte[] data, final List<ACL> acl, Cr\n \n \n         executor.execute(() -> {\n-            lock();\n             try {\n+                lock();\n \n                 if (stopped) {\n                     cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null);\n@@ -394,7 +394,7 @@ public void create(final String path, final byte[] data, final List<ACL> acl, Cr\n                                             KeeperState.SyncConnected,\n                                             parent)));\n                 }\n-            } catch (Exception ex) {\n+            } catch (Throwable ex) {\n                 log.error(\"create path : {} error\", path, ex);\n                 cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx, null);\n             } finally {\n@@ -429,28 +429,33 @@ public byte[] getData(String path, Watcher watcher, Stat stat) throws KeeperExce\n     @Override\n     public void getData(final String path, boolean watch, final DataCallback cb, final Object ctx) {\n         executor.execute(() -> {\n-            checkReadOpDelay();\n-            Optional<KeeperException.Code> failure = programmedFailure(Op.GET, path);\n-            if (failure.isPresent()) {\n-                cb.processResult(failure.get().intValue(), path, ctx, null, null);\n-                return;\n-            } else if (stopped) {\n-                cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null, null);\n-                return;\n-            }\n-\n-            MockZNode value;\n-            lock();\n             try {\n-                value = tree.get(path);\n-            } finally {\n-                unlockIfLocked();\n-            }\n+                checkReadOpDelay();\n+                Optional<KeeperException.Code> failure = programmedFailure(Op.GET, path);\n+                if (failure.isPresent()) {\n+                    cb.processResult(failure.get().intValue(), path, ctx, null, null);\n+                    return;\n+                } else if (stopped) {\n+                    cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null, null);\n+                    return;\n+                }\n \n-            if (value == null) {\n-                cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx, null, null);\n-            } else {\n-                cb.processResult(0, path, ctx, value.getContent(), createStatForZNode(value));\n+                MockZNode value;\n+                lock();\n+                try {\n+                    value = tree.get(path);\n+                } finally {\n+                    unlockIfLocked();\n+                }\n+\n+                if (value == null) {\n+                    cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx, null, null);\n+                } else {\n+                    cb.processResult(0, path, ctx, value.getContent(), createStatForZNode(value));\n+                }\n+            } catch (Throwable ex) {\n+                log.error(\"get data : {} error\", path, ex);\n+                cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx, null, null);\n             }\n         });\n     }\n@@ -459,8 +464,8 @@ public void getData(final String path, boolean watch, final DataCallback cb, fin\n     public void getData(final String path, final Watcher watcher, final DataCallback cb, final Object ctx) {\n         executor.execute(() -> {\n             checkReadOpDelay();\n-            lock();\n             try {\n+                lock();\n                 Optional<KeeperException.Code> failure = programmedFailure(Op.GET, path);\n                 if (failure.isPresent()) {\n                     unlockIfLocked();\n@@ -485,6 +490,9 @@ public void getData(final String path, final Watcher watcher, final DataCallback\n                     unlockIfLocked();\n                     cb.processResult(0, path, ctx, value.getContent(), stat);\n                 }\n+            } catch (Throwable ex) {\n+                log.error(\"get data : {} error\", path, ex);\n+                cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx, null, null);\n             } finally {\n                 unlockIfLocked();\n             }\n@@ -494,9 +502,9 @@ public void getData(final String path, final Watcher watcher, final DataCallback\n     @Override\n     public void getChildren(final String path, final Watcher watcher, final ChildrenCallback cb, final Object ctx) {\n         executor.execute(() -> {\n-            lock();\n             List<String> children = Lists.newArrayList();\n             try {\n+                lock();\n                 Optional<KeeperException.Code> failure = programmedFailure(Op.GET_CHILDREN, path);\n                 if (failure.isPresent()) {\n                     unlockIfLocked();\n@@ -532,11 +540,14 @@ public void getChildren(final String path, final Watcher watcher, final Children\n                 if (watcher != null) {\n                     watchers.put(path, watcher);\n                 }\n+                cb.processResult(0, path, ctx, children);\n+            } catch (Throwable ex) {\n+                log.error(\"get children : {} error\", path, ex);\n+                cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx, null);\n             } finally {\n                 unlockIfLocked();\n             }\n \n-            cb.processResult(0, path, ctx, children);\n         });\n     }\n \n@@ -606,8 +617,8 @@ public List<String> getChildren(String path, boolean watch) throws KeeperExcepti\n     public void getChildren(final String path, boolean watcher, final Children2Callback cb, final Object ctx) {\n         executor.execute(() -> {\n             Set<String> children = new TreeSet<>();\n-            lock();\n             try {\n+                lock();\n                 Optional<KeeperException.Code> failure = programmedFailure(Op.GET_CHILDREN, path);\n                 if (failure.isPresent()) {\n                     unlockIfLocked();\n@@ -633,10 +644,13 @@ public void getChildren(final String path, boolean watcher, final Children2Callb\n                     String child = relativePath.split(\"/\", 2)[0];\n                     children.add(child);\n                 });\n+                cb.processResult(0, path, ctx, new ArrayList<>(children), new Stat());\n+            } catch (Throwable ex) {\n+                log.error(\"get children : {} error\", path, ex);\n+                cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx, null, null);\n             } finally {\n                 unlockIfLocked();\n             }\n-            cb.processResult(0, path, ctx, new ArrayList<>(children), new Stat());\n         });\n \n     }\n@@ -705,8 +719,8 @@ public void exists(String path, boolean watch, StatCallback cb, Object ctx) {\n     @Override\n     public void exists(String path, Watcher watcher, StatCallback cb, Object ctx) {\n         executor.execute(() -> {\n-            lock();\n             try {\n+                lock();\n                 Optional<KeeperException.Code> failure = programmedFailure(Op.EXISTS, path);\n                 if (failure.isPresent()) {\n                     unlockIfLocked();\n@@ -729,6 +743,9 @@ public void exists(String path, Watcher watcher, StatCallback cb, Object ctx) {\n                     unlockIfLocked();\n                     cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx, null);\n                 }\n+            } catch (Throwable ex) {\n+                log.error(\"exist : {} error\", path, ex);\n+                cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx, null);\n             } finally {\n                 unlockIfLocked();\n             }\n@@ -805,56 +822,60 @@ public void setData(final String path, final byte[] data, int version, final Sta\n         }\n \n         executor.execute(() -> {\n-            final Set<Watcher> toNotify = Sets.newHashSet();\n-            Stat stat;\n-            lock();\n             try {\n+                final Set<Watcher> toNotify = Sets.newHashSet();\n+                Stat stat;\n+                lock();\n+                try {\n+                    Optional<KeeperException.Code> failure = programmedFailure(Op.SET, path);\n+                    if (failure.isPresent()) {\n+                        unlockIfLocked();\n+                        cb.processResult(failure.get().intValue(), path, ctx, null);\n+                        return;\n+                    } else if (stopped) {\n+                        unlockIfLocked();\n+                        cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null);\n+                        return;\n+                    }\n \n-                Optional<KeeperException.Code> failure = programmedFailure(Op.SET, path);\n-                if (failure.isPresent()) {\n-                    unlockIfLocked();\n-                    cb.processResult(failure.get().intValue(), path, ctx, null);\n-                    return;\n-                } else if (stopped) {\n-                    unlockIfLocked();\n-                    cb.processResult(KeeperException.Code.CONNECTIONLOSS.intValue(), path, ctx, null);\n-                    return;\n-                }\n+                    if (!tree.containsKey(path)) {\n+                        unlockIfLocked();\n+                        cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx, null);\n+                        return;\n+                    }\n \n-                if (!tree.containsKey(path)) {\n-                    unlockIfLocked();\n-                    cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx, null);\n-                    return;\n-                }\n+                    MockZNode mockZNode = tree.get(path);\n+                    int currentVersion = mockZNode.getVersion();\n \n-                MockZNode mockZNode = tree.get(path);\n-                int currentVersion = mockZNode.getVersion();\n+                    // Check version\n+                    if (version != -1 && version != currentVersion) {\n+                        log.debug(\"[{}] Current version: {} -- Expected: {}\", path, currentVersion, version);\n+                        unlockIfLocked();\n+                        cb.processResult(KeeperException.Code.BADVERSION.intValue(), path, ctx, null);\n+                        return;\n+                    }\n \n-                // Check version\n-                if (version != -1 && version != currentVersion) {\n-                    log.debug(\"[{}] Current version: {} -- Expected: {}\", path, currentVersion, version);\n+                    log.debug(\"[{}] Updating -- current version: {}\", path, currentVersion);\n+                    MockZNode newZNode = MockZNode.of(data, currentVersion + 1, mockZNode.getEphemeralOwner());\n+                    tree.put(path, newZNode);\n+                    stat = createStatForZNode(newZNode);\n+                } finally {\n                     unlockIfLocked();\n-                    cb.processResult(KeeperException.Code.BADVERSION.intValue(), path, ctx, null);\n-                    return;\n                 }\n+                cb.processResult(0, path, ctx, stat);\n \n-                log.debug(\"[{}] Updating -- current version: {}\", path, currentVersion);\n-                MockZNode newZNode = MockZNode.of(data, currentVersion + 1, mockZNode.getEphemeralOwner());\n-                tree.put(path, newZNode);\n-                stat = createStatForZNode(newZNode);\n-            } finally {\n-                unlockIfLocked();\n-            }\n-            cb.processResult(0, path, ctx, stat);\n+                toNotify.addAll(watchers.get(path));\n+                watchers.removeAll(path);\n \n-            toNotify.addAll(watchers.get(path));\n-            watchers.removeAll(path);\n+                for (Watcher watcher : toNotify) {\n+                    watcher.process(new WatchedEvent(EventType.NodeDataChanged, KeeperState.SyncConnected, path));\n+                }\n \n-            for (Watcher watcher : toNotify) {\n-                watcher.process(new WatchedEvent(EventType.NodeDataChanged, KeeperState.SyncConnected, path));\n+                triggerPersistentWatches(path, null, EventType.NodeDataChanged);\n+            } catch (Throwable ex) {\n+                log.error(\"Update data : {} error\", path, ex);\n+                cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx, null);\n             }\n-\n-            triggerPersistentWatches(path, null, EventType.NodeDataChanged);\n         });\n     }\n \n@@ -918,8 +939,8 @@ public void delete(final String path, int version) throws InterruptedException,\n     @Override\n     public void delete(final String path, int version, final VoidCallback cb, final Object ctx) {\n         Runnable r = () -> {\n-            lock();\n             try {\n+                lock();\n                 final Set<Watcher> toNotifyDelete = Sets.newHashSet();\n                 toNotifyDelete.addAll(watchers.get(path));\n \n@@ -965,7 +986,7 @@ public void delete(final String path, int version, final VoidCallback cb, final\n                                     parent)));\n                     triggerPersistentWatches(path, parent, EventType.NodeDeleted);\n                 }\n-            } catch (Exception ex) {\n+            } catch (Throwable ex) {\n                 log.error(\"delete path : {} error\", path, ex);\n                 cb.processResult(KeeperException.Code.SYSTEMERROR.intValue(), path, ctx);\n             } finally {",
      "parent_sha": "3752a1170bd7b362901c3e792548c62352b4b1ad"
    }
  }
]