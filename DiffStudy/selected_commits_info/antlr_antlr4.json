[
  {
    "oid": "f05c9962df412bc05dc755a6b9b0f3da7033af4f",
    "message": "force travis build",
    "date": "2015-09-17T18:28:48Z",
    "url": "https://github.com/antlr/antlr4/commit/f05c9962df412bc05dc755a6b9b0f3da7033af4f",
    "details": {
      "sha": "449c577e2fb911db08c2c89ed36adcf1295f2cf4",
      "filename": "runtime-testsuite/test/org/antlr/v4/test/runtime/python3/BasePython3Test.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/antlr/antlr4/blob/f05c9962df412bc05dc755a6b9b0f3da7033af4f/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fpython3%2FBasePython3Test.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/f05c9962df412bc05dc755a6b9b0f3da7033af4f/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fpython3%2FBasePython3Test.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fpython3%2FBasePython3Test.java?ref=f05c9962df412bc05dc755a6b9b0f3da7033af4f",
      "patch": "@@ -46,7 +46,7 @@ protected String getPythonExecutable() {\n \t\tif(\"true\".equals(os))\n \t\t\treturn \"python3\";\n \t\telse\n-\t\t\treturn \"python3.4\";\n+\t\t\treturn \"python3.4\"; \n \t}\n \n \t@Override",
      "parent_sha": "fce545b51c42213eb8d50797acbee028184ef4e7"
    }
  },
  {
    "oid": "2410b97aab94919b285261108f62c5733748b4b9",
    "message": "addDFAEdge needs to return the true target state of the added edge",
    "date": "2013-04-18T20:52:20Z",
    "url": "https://github.com/antlr/antlr4/commit/2410b97aab94919b285261108f62c5733748b4b9",
    "details": {
      "sha": "2489b05d1dd14308638072740b52c3da5829d7a4",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java",
      "status": "modified",
      "additions": 8,
      "deletions": 7,
      "changes": 15,
      "blob_url": "https://github.com/antlr/antlr4/blob/2410b97aab94919b285261108f62c5733748b4b9/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/2410b97aab94919b285261108f62c5733748b4b9/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java?ref=2410b97aab94919b285261108f62c5733748b4b9",
      "patch": "@@ -700,7 +700,7 @@ else if ( PredictionMode.hasSLLConflictTerminatingPrediction(mode, reach) ) {\n \t\t\t\t\tinput.seek(startIndex);\n \t\t\t\t\tBitSet alts = evalSemanticContext(D.predicates, outerContext, true);\n \t\t\t\t\tD.prediction = ATN.INVALID_ALT_NUMBER; // indicate we have preds\n-\t\t\t\t\taddDFAEdge(dfa, previousD, t, D);\n+\t\t\t\t\tD = addDFAEdge(dfa, previousD, t, D);\n \t\t\t\t\tswitch (alts.cardinality()) {\n \t\t\t\t\tcase 0:\n \t\t\t\t\t\tthrow noViableAlt(input, outerContext, D.configs, startIndex);\n@@ -718,7 +718,7 @@ else if ( PredictionMode.hasSLLConflictTerminatingPrediction(mode, reach) ) {\n \t\t\t}\n \n \t\t\t// all adds to dfa are done after we've created full D state\n-\t\t\taddDFAEdge(dfa, previousD, t, D);\n+\t\t\tD = addDFAEdge(dfa, previousD, t, D);\n \t\t\tif ( D.isAcceptState ) return predictedAlt;\n \n \t\t\tprevious = reach;\n@@ -1547,13 +1547,13 @@ else if ( c.alt!=alt ) {\n \t\treturn alt;\n \t}\n \n-\tprotected void addDFAEdge(@NotNull DFA dfa,\n-\t\t\t\t\t\t\t  @Nullable DFAState from,\n-\t\t\t\t\t\t\t  int t,\n-\t\t\t\t\t\t\t  @Nullable DFAState to)\n+\tprotected DFAState addDFAEdge(@NotNull DFA dfa,\n+\t\t\t\t\t\t\t\t  @Nullable DFAState from,\n+\t\t\t\t\t\t\t\t  int t,\n+\t\t\t\t\t\t\t\t  @Nullable DFAState to)\n \t{\n \t\tif ( debug ) System.out.println(\"EDGE \"+from+\" -> \"+to+\" upon \"+getTokenName(t));\n-\t\tif ( from==null || t < -1 || to == null ) return;\n+\t\tif ( from==null || t < -1 || to == null ) return to;\n \t\tto = addDFAState(dfa, to); // used existing if possible not incoming\n \t\tsynchronized (from) {\n \t\t\tif ( from.edges==null ) {\n@@ -1562,6 +1562,7 @@ protected void addDFAEdge(@NotNull DFA dfa,\n \t\t\tfrom.edges[t+1] = to; // connect\n \t\t}\n \t\tif ( debug ) System.out.println(\"DFA=\\n\"+dfa.toString(parser!=null?parser.getTokenNames():null));\n+\t\treturn to;\n \t}\n \n \t/** Add D if not there and return D. Return previous if already present. */",
      "parent_sha": "74f4938033a1d4c3f6a08e7b2a2c451527baeaf5"
    }
  },
  {
    "oid": "db0a57c6ee4629b02c32abfb12fc2d325eaa5d57",
    "message": "Increment match_calls atomically\n\nThis ensures the correctness of the counter value, i.e. the value is the number of calls to the match() method.",
    "date": "2019-09-11T04:16:49Z",
    "url": "https://github.com/antlr/antlr4/commit/db0a57c6ee4629b02c32abfb12fc2d325eaa5d57",
    "details": {
      "sha": "79c6c73e56aac1d8ab0b38ffeedf15ff86ea8eef",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/antlr/antlr4/blob/db0a57c6ee4629b02c32abfb12fc2d325eaa5d57/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FLexerATNSimulator.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/db0a57c6ee4629b02c32abfb12fc2d325eaa5d57/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FLexerATNSimulator.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FLexerATNSimulator.java?ref=db0a57c6ee4629b02c32abfb12fc2d325eaa5d57",
      "patch": "@@ -103,7 +103,9 @@ public void copyState(LexerATNSimulator simulator) {\n \t}\n \n \tpublic int match(CharStream input, int mode) {\n-\t\tmatch_calls++;\n+\t\tsynchronized (LexerATNSimulator.class) {\n+\t\t\tmatch_calls++;\n+\t\t}\n \t\tthis.mode = mode;\n \t\tint mark = input.mark();\n \t\ttry {",
      "parent_sha": "f11ce46ddf244bc61be90775ade6fa3ca2e7833e"
    }
  },
  {
    "oid": "5e0f9a4490673b886f80abd4789b452532ea6887",
    "message": "Ensure target non-null in Transition constructor (additional runtime-side consistency check).",
    "date": "2012-03-19T13:33:36Z",
    "url": "https://github.com/antlr/antlr4/commit/5e0f9a4490673b886f80abd4789b452532ea6887",
    "details": {
      "sha": "4cc711ba85fe3a93dc188d6a5043e16e79e0de10",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/atn/Transition.java",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/antlr/antlr4/blob/5e0f9a4490673b886f80abd4789b452532ea6887/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FTransition.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/5e0f9a4490673b886f80abd4789b452532ea6887/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FTransition.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FTransition.java?ref=5e0f9a4490673b886f80abd4789b452532ea6887",
      "patch": "@@ -91,7 +91,13 @@ public abstract class Transition {\n \t@NotNull\n \tpublic ATNState target;\n \n-\tprotected Transition(@NotNull ATNState target) { this.target = target; }\n+\tprotected Transition(@NotNull ATNState target) {\n+\t\tif (target == null) {\n+\t\t\tthrow new NullPointerException(\"target cannot be null.\");\n+\t\t}\n+\n+\t\tthis.target = target;\n+\t}\n \n \tpublic int getSerializationType() { return 0; }\n ",
      "parent_sha": "4bc615d72ff72756f8fcbf284911b9dbcb79a2cc"
    }
  },
  {
    "oid": "ec47251bb2fbaa47416b455fde699276409f8a3d",
    "message": "unbuffered release() can get markers in weird order since we reset p to beginning of buffer. Might mark at 1 and then at release p = 0 etc... Don't   look for errors. Just reset earliestMarker if needed.",
    "date": "2012-07-04T18:32:41Z",
    "url": "https://github.com/antlr/antlr4/commit/ec47251bb2fbaa47416b455fde699276409f8a3d",
    "details": {
      "sha": "0ac49c3dfb6275a039726681efb0500a783ae2c4",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/UnbufferedCharStream.java",
      "status": "modified",
      "additions": 9,
      "deletions": 4,
      "changes": 13,
      "blob_url": "https://github.com/antlr/antlr4/blob/ec47251bb2fbaa47416b455fde699276409f8a3d/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FUnbufferedCharStream.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/ec47251bb2fbaa47416b455fde699276409f8a3d/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FUnbufferedCharStream.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FUnbufferedCharStream.java?ref=ec47251bb2fbaa47416b455fde699276409f8a3d",
      "patch": "@@ -177,19 +177,24 @@ public int mark() {\n             throw new IllegalArgumentException(\"can't set marker earlier than previous existing marker: \"+p+\"<\"+ earliestMarker);\n         }\n         if ( earliestMarker < 0 ) earliestMarker = m; // set first marker\n+//\t\tStackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n+//\t\tSystem.out.println(stackTrace[2].getMethodName()+\": mark \" + m);\n         return m;\n     }\n \n+\t/** Release can get markers in weird order since we reset p to beginning\n+\t *  of buffer. Might mark at 1 and then at release p = 0 etc... Don't\n+\t *  look for errors. Just reset earliestMarker if needed.\n+\t * @param marker\n+\t */\n     @Override\n     public void release(int marker) {\n+//\t\tStackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n+//\t\tSystem.out.println(stackTrace[2].getMethodName()+\": release \" + marker);\n         // release is noop unless we remove earliest. then we don't need to\n         // keep anything in buffer. We only care about earliest. Releasing\n         // marker other than earliest does nothing as we can just keep in\n         // buffer.\n-        if ( marker < earliestMarker || marker >= n ) {\n-            throw new IllegalArgumentException(\"invalid marker: \"+\n-                    marker+\" not in \"+0+\"..\"+n);\n-        }\n         if ( marker == earliestMarker) earliestMarker = -1;\n     }\n ",
      "parent_sha": "00808ef11fef46163e4189907acff0517b1044c0"
    }
  },
  {
    "oid": "664d66d9373b77995163d37c1391da43b526beb0",
    "message": "Fix incorrect combineMax implementation (fixes #299)",
    "date": "2014-01-17T02:35:03Z",
    "url": "https://github.com/antlr/antlr4/commit/664d66d9373b77995163d37c1391da43b526beb0",
    "details": {
      "sha": "466cf051dc40542642e3b71091f2598037e0c399",
      "filename": "tool/src/org/antlr/v4/codegen/model/RuleFunction.java",
      "status": "modified",
      "additions": 23,
      "deletions": 1,
      "changes": 24,
      "blob_url": "https://github.com/antlr/antlr4/blob/664d66d9373b77995163d37c1391da43b526beb0/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fcodegen%2Fmodel%2FRuleFunction.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/664d66d9373b77995163d37c1391da43b526beb0/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fcodegen%2Fmodel%2FRuleFunction.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fcodegen%2Fmodel%2FRuleFunction.java?ref=664d66d9373b77995163d37c1391da43b526beb0",
      "patch": "@@ -307,20 +307,42 @@ public ElementFrequenciesVisitor(TreeNodeStream input) {\n \t\t * Common\n \t\t */\n \n+\t\t/**\n+\t\t * Generate a frequency set as the union of two input sets. If an\n+\t\t * element is contained in both sets, the value for the output will be\n+\t\t * the maximum of the two input values.\n+\t\t *\n+\t\t * @param a The first set.\n+\t\t * @param b The second set.\n+\t\t * @return The union of the two sets, with the maximum value chosen\n+\t\t * whenever both sets contain the same key.\n+\t\t */\n \t\tprotected static FrequencySet<String> combineMax(FrequencySet<String> a, FrequencySet<String> b) {\n \t\t\tFrequencySet<String> result = combineAndClip(a, b, 1);\n \t\t\tfor (Map.Entry<String, MutableInt> entry : a.entrySet()) {\n \t\t\t\tresult.get(entry.getKey()).v = entry.getValue().v;\n \t\t\t}\n \n-\t\t\tfor (Map.Entry<String, MutableInt> entry : a.entrySet()) {\n+\t\t\tfor (Map.Entry<String, MutableInt> entry : b.entrySet()) {\n \t\t\t\tMutableInt slot = result.get(entry.getKey());\n \t\t\t\tslot.v = Math.max(slot.v, entry.getValue().v);\n \t\t\t}\n \n \t\t\treturn result;\n \t\t}\n \n+\t\t/**\n+\t\t * Generate a frequency set as the union of two input sets, with the\n+\t\t * values clipped to a specified maximum value. If an element is\n+\t\t * contained in both sets, the value for the output, prior to clipping,\n+\t\t * will be the sum of the two input values.\n+\t\t *\n+\t\t * @param a The first set.\n+\t\t * @param b The second set.\n+\t\t * @param clip The maximum value to allow for any output.\n+\t\t * @return The sum of the two sets, with the individual elements clipped\n+\t\t * to the maximum value gived by {@code clip}.\n+\t\t */\n \t\tprotected static FrequencySet<String> combineAndClip(FrequencySet<String> a, FrequencySet<String> b, int clip) {\n \t\t\tFrequencySet<String> result = new FrequencySet<String>();\n \t\t\tfor (Map.Entry<String, MutableInt> entry : a.entrySet()) {",
      "parent_sha": "9889de87ac6d3b7c3092e4f95fd67a9a58cdda25"
    }
  },
  {
    "oid": "d01c583e36446adb996aea28bbe88d38ca7b7d18",
    "message": "v4: Class<?> instead of Class\n\n[git-p4: depot-paths = \"//depot/code/antlr4/main/\": change = 9361]",
    "date": "2011-11-18T02:30:27Z",
    "url": "https://github.com/antlr/antlr4/commit/d01c583e36446adb996aea28bbe88d38ca7b7d18",
    "details": {
      "sha": "06a092fc9b867f586398431c9ce1c002aac8538a",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/tree/gui/PostScriptDocument.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/antlr/antlr4/blob/d01c583e36446adb996aea28bbe88d38ca7b7d18/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Ftree%2Fgui%2FPostScriptDocument.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/d01c583e36446adb996aea28bbe88d38ca7b7d18/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Ftree%2Fgui%2FPostScriptDocument.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Ftree%2Fgui%2FPostScriptDocument.java?ref=d01c583e36446adb996aea28bbe88d38ca7b7d18",
      "patch": "@@ -105,7 +105,7 @@ public void setFont(String fontName, int fontSize) {\n \t\tthis.fontName = fontName;\n \t\tthis.fontSize = fontSize;\n \t\ttry {\n-\t\t\tClass c = Class.forName(\"org.antlr.v4.runtime.tree.gui.\" + fontName);\n+\t\t\tClass<?> c = Class.forName(\"org.antlr.v4.runtime.tree.gui.\" + fontName);\n \t\t\tthis.fontMetrics = (BasicFontMetrics)c.newInstance();\n \t\t}\n \t\tcatch (Exception e) {",
      "parent_sha": "5e567eacc9633a3857c9f81cbdba90a99d3ff236"
    }
  },
  {
    "oid": "b570641e2b94c345420cd888d365c33c9d69e947",
    "message": "Simplify ParseTree.visitChildren; ParseTree.visit and visitChildren take a RuleNode parameter; update comments",
    "date": "2012-03-04T18:17:43Z",
    "url": "https://github.com/antlr/antlr4/commit/b570641e2b94c345420cd888d365c33c9d69e947",
    "details": {
      "sha": "84c448c7e08128ee62838ca7708d20df7c7aed20",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/tree/ParseTreeVisitor.java",
      "status": "modified",
      "additions": 12,
      "deletions": 24,
      "changes": 36,
      "blob_url": "https://github.com/antlr/antlr4/blob/b570641e2b94c345420cd888d365c33c9d69e947/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Ftree%2FParseTreeVisitor.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/b570641e2b94c345420cd888d365c33c9d69e947/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Ftree%2FParseTreeVisitor.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Ftree%2FParseTreeVisitor.java?ref=b570641e2b94c345420cd888d365c33c9d69e947",
      "patch": "@@ -3,38 +3,26 @@\n import org.antlr.v4.runtime.ParserRuleContext;\n import org.antlr.v4.runtime.Token;\n \n-/** T is return type of visit methods. Use T=Void for no return type. */\n+/** {@code T} is return type of {@code visit} methods. Use {@link Void} for no return type.\n+ */\n public class ParseTreeVisitor<T> {\n-\tpublic T visit(ParseTree ctx) {\n-\t\treturn ctx.accept(this);\n+\tpublic T visit(ParseTree.RuleNode node) {\n+\t\treturn node.accept(this);\n \t}\n \n-\t/** Visit all rule, nonleaf children. Not that useful if you are using T as\n-\t *  non-Void.  This returns value returned from last child visited,\n-\t *  losing all computations from first n-1 children.  Works fine for\n-\t *  ctxs with one child then.\n+\t/** Visit all rule, non-leaf children. This returns value returned from last\n+\t *  child visited, losing all computations from first n-1 children.  Works\n+\t *  fine for contexts with one child then.\n \t *  Handy if you are just walking the tree with a visitor and only\n-\t *  care about some nodes.  The ParserRuleContext.accept() method\n+\t *  care about some nodes.  The {@link ParserRuleContext#accept} method\n \t *  walks all children by default; i.e., calls this method.\n \t */\n-\tpublic T visitChildren(ParseTree tree) {\n+\tpublic T visitChildren(ParseTree.RuleNode node) {\n \t\tT result = null;\n-\t\tint n = tree.getChildCount();\n+\t\tint n = node.getChildCount();\n \t\tfor (int i=0; i<n; i++) {\n-\t\t\tParseTree c = tree.getChild(i);\n-\t\t\tif ( c instanceof ParseTree.RuleNode ) {\n-\t\t\t\tParseTree.RuleNode r = (ParseTree.RuleNode)c;\n-\t\t\t\tParserRuleContext<?> rctx = (ParserRuleContext<? extends Token>)r.getRuleContext();\n-\t\t\t\tresult = visit(rctx);\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tif ( c instanceof ParseTree.ErrorNodeImpl) {\n-\t\t\t\t\tresult = visitErrorNode((ParseTree.ErrorNode<? extends Token>)c);\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tresult = visitTerminal((ParseTree.TerminalNode<? extends Token>)c);\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\tParseTree c = node.getChild(i);\n+\t\t\tresult = c.accept(this);\n \t\t}\n \t\treturn result;\n \t}",
      "parent_sha": "a948736729c4c326753d507585e6d639dc55df95"
    }
  },
  {
    "oid": "8d0a1bbd8d4bf9188e456cb699596592ef6b0fb3",
    "message": "Show additional information about rules and viable alternatives for conflicts, ambiguity, and/or context sensitivity",
    "date": "2013-05-18T16:46:57Z",
    "url": "https://github.com/antlr/antlr4/commit/8d0a1bbd8d4bf9188e456cb699596592ef6b0fb3",
    "details": {
      "sha": "bc8847cfe3ebad74c13275ef51c6871893ab3759",
      "filename": "tool/test/org/antlr/v4/test/TestPerformance.java",
      "status": "modified",
      "additions": 29,
      "deletions": 3,
      "changes": 32,
      "blob_url": "https://github.com/antlr/antlr4/blob/8d0a1bbd8d4bf9188e456cb699596592ef6b0fb3/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestPerformance.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/8d0a1bbd8d4bf9188e456cb699596592ef6b0fb3/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestPerformance.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestPerformance.java?ref=8d0a1bbd8d4bf9188e456cb699596592ef6b0fb3",
      "patch": "@@ -1426,6 +1426,15 @@ public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol,\n \n \t}\n \n+\tprivate static BitSet getRepresentedAlts(ATNConfigSet configs) {\n+\t\tBitSet alts = new BitSet();\n+\t\tfor (ATNConfig config : configs) {\n+\t\t\talts.set(config.alt);\n+\t\t}\n+\n+\t\treturn alts;\n+\t}\n+\n \tprivate static class SummarizingDiagnosticErrorListener extends DiagnosticErrorListener {\n \n \t\t@Override\n@@ -1434,7 +1443,12 @@ public void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stop\n \t\t\t\treturn;\n \t\t\t}\n \n-\t\t\tsuper.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, ambigAlts, configs);\n+\t\t\t// show the rule name along with the decision\n+\t\t\tString format = \"reportAmbiguity d=%d (%s): ambigAlts=%s, input='%s'\";\n+\t\t\tint decision = dfa.decision;\n+\t\t\tString rule = recognizer.getRuleNames()[dfa.atnStartState.ruleIndex];\n+\t\t\tString input = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n+\t\t\trecognizer.notifyErrorListeners(String.format(format, decision, rule, ambigAlts, input));\n \t\t}\n \n \t\t@Override\n@@ -1443,7 +1457,13 @@ public void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startInd\n \t\t\t\treturn;\n \t\t\t}\n \n-\t\t\tsuper.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, configs);\n+\t\t\t// show the rule name and viable configs along with the base info\n+\t\t\tString format = \"reportAttemptingFullContext d=%d (%s), input='%s', viable=%s\";\n+\t\t\tint decision = dfa.decision;\n+\t\t\tString rule = recognizer.getRuleNames()[dfa.atnStartState.ruleIndex];\n+\t\t\tString input = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n+\t\t\tBitSet representedAlts = getRepresentedAlts(configs);\n+\t\t\trecognizer.notifyErrorListeners(String.format(format, decision, rule, input, representedAlts));\n \t\t}\n \n \t\t@Override\n@@ -1452,7 +1472,13 @@ public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex,\n \t\t\t\treturn;\n \t\t\t}\n \n-\t\t\tsuper.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, configs);\n+\t\t\t// show the rule name and viable configs along with the base info\n+\t\t\tString format = \"reportContextSensitivity d=%d (%s), input='%s', viable=%s\";\n+\t\t\tint decision = dfa.decision;\n+\t\t\tString rule = recognizer.getRuleNames()[dfa.atnStartState.ruleIndex];\n+\t\t\tString input = recognizer.getTokenStream().getText(Interval.of(startIndex, stopIndex));\n+\t\t\tBitSet representedAlts = getRepresentedAlts(configs);\n+\t\t\trecognizer.notifyErrorListeners(String.format(format, decision, rule, input, representedAlts));\n \t\t}\n \n \t}",
      "parent_sha": "aad78ba7d29fb1bab77f6731e4e83a71be8df119"
    }
  },
  {
    "oid": "ec8457383cdac3f1a274bda99d0da0b48a35fbff",
    "message": "Calculate detailed transition statistics per decision",
    "date": "2013-05-18T19:22:09Z",
    "url": "https://github.com/antlr/antlr4/commit/ec8457383cdac3f1a274bda99d0da0b48a35fbff",
    "details": {
      "sha": "923ce373723e509b6e74053c9fa8294f4745a610",
      "filename": "tool/test/org/antlr/v4/test/TestPerformance.java",
      "status": "modified",
      "additions": 200,
      "deletions": 22,
      "changes": 222,
      "blob_url": "https://github.com/antlr/antlr4/blob/ec8457383cdac3f1a274bda99d0da0b48a35fbff/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestPerformance.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/ec8457383cdac3f1a274bda99d0da0b48a35fbff/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestPerformance.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestPerformance.java?ref=ec8457383cdac3f1a274bda99d0da0b48a35fbff",
      "patch": "@@ -55,6 +55,7 @@\n import org.antlr.v4.runtime.atn.PredictionMode;\n import org.antlr.v4.runtime.dfa.DFA;\n import org.antlr.v4.runtime.dfa.DFAState;\n+import org.antlr.v4.runtime.misc.Interval;\n import org.antlr.v4.runtime.misc.NotNull;\n import org.antlr.v4.runtime.misc.Nullable;\n import org.antlr.v4.runtime.misc.ParseCancellationException;\n@@ -251,6 +252,7 @@ public class TestPerformance extends BaseTest {\n \t * required on-the-fly computation.\n \t */\n \tprivate static final boolean COMPUTE_TRANSITION_STATS = false;\n+\tprivate static final boolean SHOW_TRANSITION_STATS_PER_FILE = false;\n \t/**\n \t * If {@code true}, the transition statistics will be adjusted to a running\n \t * total before reporting the final results.\n@@ -356,6 +358,30 @@ public class TestPerformance extends BaseTest {\n \t\t}\n \t}\n \n+\tprivate static final long[][][] decisionInvocationsPerFile;\n+\tprivate static final long[][][] fullContextFallbackPerFile;\n+\tprivate static final long[][][] nonSllPerFile;\n+\tprivate static final long[][][] totalTransitionsPerDecisionPerFile;\n+\tprivate static final long[][][] computedTransitionsPerDecisionPerFile;\n+\tprivate static final long[][][] fullContextTransitionsPerDecisionPerFile;\n+\tstatic {\n+\t\tif (COMPUTE_TRANSITION_STATS && DETAILED_DFA_STATE_STATS) {\n+\t\t\tdecisionInvocationsPerFile = new long[PASSES][][];\n+\t\t\tfullContextFallbackPerFile = new long[PASSES][][];\n+\t\t\tnonSllPerFile = new long[PASSES][][];\n+\t\t\ttotalTransitionsPerDecisionPerFile = new long[PASSES][][];\n+\t\t\tcomputedTransitionsPerDecisionPerFile = new long[PASSES][][];\n+\t\t\tfullContextTransitionsPerDecisionPerFile = new long[PASSES][][];\n+\t\t} else {\n+\t\t\tdecisionInvocationsPerFile = null;\n+\t\t\tfullContextFallbackPerFile = null;\n+\t\t\tnonSllPerFile = null;\n+\t\t\ttotalTransitionsPerDecisionPerFile = null;\n+\t\t\tcomputedTransitionsPerDecisionPerFile = null;\n+\t\t\tfullContextTransitionsPerDecisionPerFile = null;\n+\t\t}\n+\t}\n+\n \tprivate static final long[][] timePerFile;\n \tprivate static final int[][] tokensPerFile;\n \tstatic {\n@@ -398,6 +424,15 @@ public void compileJdk() throws IOException, InterruptedException, ExecutionExce\n \t\t\tif (COMPUTE_TRANSITION_STATS) {\n \t\t\t\ttotalTransitionsPerFile[i] = new long[Math.min(sources.size(), MAX_FILES_PER_PARSE_ITERATION)];\n \t\t\t\tcomputedTransitionsPerFile[i] = new long[Math.min(sources.size(), MAX_FILES_PER_PARSE_ITERATION)];\n+\n+\t\t\t\tif (DETAILED_DFA_STATE_STATS) {\n+\t\t\t\t\tdecisionInvocationsPerFile[i] = new long[Math.min(sources.size(), MAX_FILES_PER_PARSE_ITERATION)][];\n+\t\t\t\t\tfullContextFallbackPerFile[i] = new long[Math.min(sources.size(), MAX_FILES_PER_PARSE_ITERATION)][];\n+\t\t\t\t\tnonSllPerFile[i] = new long[Math.min(sources.size(), MAX_FILES_PER_PARSE_ITERATION)][];\n+\t\t\t\t\ttotalTransitionsPerDecisionPerFile[i] = new long[Math.min(sources.size(), MAX_FILES_PER_PARSE_ITERATION)][];\n+\t\t\t\t\tcomputedTransitionsPerDecisionPerFile[i] = new long[Math.min(sources.size(), MAX_FILES_PER_PARSE_ITERATION)][];\n+\t\t\t\t\tfullContextTransitionsPerDecisionPerFile[i] = new long[Math.min(sources.size(), MAX_FILES_PER_PARSE_ITERATION)][];\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tif (COMPUTE_TIMING_STATS) {\n@@ -465,7 +500,7 @@ public void run() {\n \t\texecutorService.shutdown();\n \t\texecutorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);\n \n-\t\tif (COMPUTE_TRANSITION_STATS) {\n+\t\tif (COMPUTE_TRANSITION_STATS && SHOW_TRANSITION_STATS_PER_FILE) {\n \t\t\tcomputeTransitionStatistics();\n \t\t}\n \n@@ -804,8 +839,17 @@ public FileParseResult call() {\n \t\t\ttry {\n \t\t\t\tFileParseResult fileResult = future.get();\n \t\t\t\tif (COMPUTE_TRANSITION_STATS) {\n-\t\t\t\t\ttotalTransitionsPerFile[currentPass][currentIndex] = fileResult.parserTotalTransitions;\n-\t\t\t\t\tcomputedTransitionsPerFile[currentPass][currentIndex] = fileResult.parserComputedTransitions;\n+\t\t\t\t\ttotalTransitionsPerFile[currentPass][currentIndex] = sum(fileResult.parserTotalTransitions);\n+\t\t\t\t\tcomputedTransitionsPerFile[currentPass][currentIndex] = sum(fileResult.parserComputedTransitions);\n+\n+\t\t\t\t\tif (DETAILED_DFA_STATE_STATS) {\n+\t\t\t\t\t\tdecisionInvocationsPerFile[currentPass][currentIndex] = fileResult.decisionInvocations;\n+\t\t\t\t\t\tfullContextFallbackPerFile[currentPass][currentIndex] = fileResult.fullContextFallback;\n+\t\t\t\t\t\tnonSllPerFile[currentPass][currentIndex] = fileResult.nonSll;\n+\t\t\t\t\t\ttotalTransitionsPerDecisionPerFile[currentPass][currentIndex] = fileResult.parserTotalTransitions;\n+\t\t\t\t\t\tcomputedTransitionsPerDecisionPerFile[currentPass][currentIndex] = fileResult.parserComputedTransitions;\n+\t\t\t\t\t\tfullContextTransitionsPerDecisionPerFile[currentPass][currentIndex] = fileResult.parserFullContextTransitions;\n+\t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (COMPUTE_TIMING_STATS) {\n@@ -907,7 +951,13 @@ public FileParseResult call() {\n                 System.out.format(\"There are %d parser DFAState instances, %d configs (%d unique).%n\", states, configs, uniqueConfigs.size());\n \n \t\t\t\tif (DETAILED_DFA_STATE_STATS) {\n-\t\t\t\t\tSystem.out.format(\"\\tDecision\\tStates\\tConfigs\\tRule%n\");\n+\t\t\t\t\tif (COMPUTE_TRANSITION_STATS) {\n+\t\t\t\t\t\tSystem.out.format(\"\\tDecision\\tStates\\tConfigs\\tPredict (ALL)\\tPredict (LL)\\tNon-SLL\\tTransitions\\tTransitions (ATN)\\tTransitions (LL)\\tLA (SLL)\\tLA (LL)\\tRule%n\");\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tSystem.out.format(\"\\tDecision\\tStates\\tConfigs\\tRule%n\");\n+\t\t\t\t\t}\n+\n \t\t\t\t\tfor (int i = 0; i < decisionToDFA.length; i++) {\n \t\t\t\t\t\tDFA dfa = decisionToDFA[i];\n \t\t\t\t\t\tif (dfa == null || dfa.states.isEmpty()) {\n@@ -920,7 +970,57 @@ public FileParseResult call() {\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tString ruleName = parser.getRuleNames()[parser.getATN().decisionToState.get(dfa.decision).ruleIndex];\n-\t\t\t\t\t\tSystem.out.format(\"\\t%d\\t%d\\t%d\\t%s%n\", dfa.decision, dfa.states.size(), decisionConfigs, ruleName);\n+\n+\t\t\t\t\t\tlong calls = 0;\n+\t\t\t\t\t\tlong fullContextCalls = 0;\n+\t\t\t\t\t\tlong nonSllCalls = 0;\n+\t\t\t\t\t\tlong transitions = 0;\n+\t\t\t\t\t\tlong computedTransitions = 0;\n+\t\t\t\t\t\tlong fullContextTransitions = 0;\n+\t\t\t\t\t\tdouble lookahead = 0;\n+\t\t\t\t\t\tdouble fullContextLookahead = 0;\n+\t\t\t\t\t\tString formatString;\n+\t\t\t\t\t\tif (COMPUTE_TRANSITION_STATS) {\n+\t\t\t\t\t\t\tfor (long[] data : decisionInvocationsPerFile[currentPass]) {\n+\t\t\t\t\t\t\t\tcalls += data[i];\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tfor (long[] data : fullContextFallbackPerFile[currentPass]) {\n+\t\t\t\t\t\t\t\tfullContextCalls += data[i];\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tfor (long[] data : nonSllPerFile[currentPass]) {\n+\t\t\t\t\t\t\t\tnonSllCalls += data[i];\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tfor (long[] data : totalTransitionsPerDecisionPerFile[currentPass]) {\n+\t\t\t\t\t\t\t\ttransitions += data[i];\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tfor (long[] data : computedTransitionsPerDecisionPerFile[currentPass]) {\n+\t\t\t\t\t\t\t\tcomputedTransitions += data[i];\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tfor (long[] data : fullContextTransitionsPerDecisionPerFile[currentPass]) {\n+\t\t\t\t\t\t\t\tfullContextTransitions += data[i];\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tif (calls > 0) {\n+\t\t\t\t\t\t\t\tlookahead = (double)(transitions - fullContextTransitions) / (double)calls;\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tif (fullContextCalls > 0) {\n+\t\t\t\t\t\t\t\tfullContextLookahead = (double)fullContextTransitions / (double)fullContextCalls;\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tformatString = \"\\t%1$d\\t%2$d\\t%3$d\\t%4$d\\t%5$d\\t%6$d\\t%7$d\\t%8$d\\t%9$d\\t%10$f\\t%11$f\\t%12$s%n\";\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\tcalls = 0;\n+\t\t\t\t\t\t\tformatString = \"\\t%1$d\\t%2$d\\t%3$d\\t%12$s%n\";\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tSystem.out.format(formatString, dfa.decision, dfa.states.size(), decisionConfigs, calls, fullContextCalls, nonSllCalls, transitions, computedTransitions, fullContextTransitions, lookahead, fullContextLookahead, ruleName);\n \t\t\t\t\t}\n \t\t\t\t}\n             }\n@@ -987,6 +1087,15 @@ public FileParseResult call() {\n \t\t}\n     }\n \n+\tprivate static long sum(long[] array) {\n+\t\tlong result = 0;\n+\t\tfor (int i = 0; i < array.length; i++) {\n+\t\t\tresult += array[i];\n+\t\t}\n+\n+\t\treturn result;\n+\t}\n+\n     protected void compileJavaParser(boolean leftRecursive) throws IOException {\n         String grammarFileName = \"Java.g4\";\n         String sourceName = leftRecursive ? \"Java-LR.g4\" : \"Java.g4\";\n@@ -1275,9 +1384,12 @@ protected static class FileParseResult {\n \t\tpublic final long lexerComputedTransitions;\n \n \t\tpublic final int parserDFASize;\n-\t\tpublic final long parserTotalTransitions;\n-\t\tpublic final long parserComputedTransitions;\n-\t\tpublic final long parserFullContextTransitions;\n+\t\tpublic final long[] decisionInvocations;\n+\t\tpublic final long[] fullContextFallback;\n+\t\tpublic final long[] nonSll;\n+\t\tpublic final long[] parserTotalTransitions;\n+\t\tpublic final long[] parserComputedTransitions;\n+\t\tpublic final long[] parserFullContextTransitions;\n \n \t\tpublic FileParseResult(String sourceName, int checksum, @Nullable ParseTree parseTree, int tokenCount, long startTime, Lexer lexer, Parser parser) {\n \t\t\tthis.sourceName = sourceName;\n@@ -1314,13 +1426,19 @@ public FileParseResult(String sourceName, int checksum, @Nullable ParseTree pars\n \t\t\tif (parser != null) {\n \t\t\t\tParserATNSimulator interpreter = parser.getInterpreter();\n \t\t\t\tif (interpreter instanceof StatisticsParserATNSimulator) {\n+\t\t\t\t\tdecisionInvocations = ((StatisticsParserATNSimulator)interpreter).decisionInvocations;\n+\t\t\t\t\tfullContextFallback = ((StatisticsParserATNSimulator)interpreter).fullContextFallback;\n+\t\t\t\t\tnonSll = ((StatisticsParserATNSimulator)interpreter).nonSll;\n \t\t\t\t\tparserTotalTransitions = ((StatisticsParserATNSimulator)interpreter).totalTransitions;\n \t\t\t\t\tparserComputedTransitions = ((StatisticsParserATNSimulator)interpreter).computedTransitions;\n \t\t\t\t\tparserFullContextTransitions = ((StatisticsParserATNSimulator)interpreter).fullContextTransitions;\n \t\t\t\t} else {\n-\t\t\t\t\tparserTotalTransitions = 0;\n-\t\t\t\t\tparserComputedTransitions = 0;\n-\t\t\t\t\tparserFullContextTransitions = 0;\n+\t\t\t\t\tdecisionInvocations = new long[0];\n+\t\t\t\t\tfullContextFallback = new long[0];\n+\t\t\t\t\tnonSll = new long[0];\n+\t\t\t\t\tparserTotalTransitions = new long[0];\n+\t\t\t\t\tparserComputedTransitions = new long[0];\n+\t\t\t\t\tparserFullContextTransitions = new long[0];\n \t\t\t\t}\n \n \t\t\t\tint dfaSize = 0;\n@@ -1333,9 +1451,12 @@ public FileParseResult(String sourceName, int checksum, @Nullable ParseTree pars\n \t\t\t\tparserDFASize = dfaSize;\n \t\t\t} else {\n \t\t\t\tparserDFASize = 0;\n-\t\t\t\tparserTotalTransitions = 0;\n-\t\t\t\tparserComputedTransitions = 0;\n-\t\t\t\tparserFullContextTransitions = 0;\n+\t\t\t\tdecisionInvocations = new long[0];\n+\t\t\t\tfullContextFallback = new long[0];\n+\t\t\t\tnonSll = new long[0];\n+\t\t\t\tparserTotalTransitions = new long[0];\n+\t\t\t\tparserComputedTransitions = new long[0];\n+\t\t\t\tparserFullContextTransitions = new long[0];\n \t\t\t}\n \t\t}\n \t}\n@@ -1368,36 +1489,71 @@ protected DFAState computeTargetState(CharStream input, DFAState s, int t) {\n \n \tprivate static class StatisticsParserATNSimulator extends ParserATNSimulator {\n \n-\t\tpublic long totalTransitions;\n-\t\tpublic long computedTransitions;\n-\t\tpublic long fullContextTransitions;\n+\t\tpublic final long[] decisionInvocations;\n+\t\tpublic final long[] fullContextFallback;\n+\t\tpublic final long[] nonSll;\n+\t\tpublic final long[] totalTransitions;\n+\t\tpublic final long[] computedTransitions;\n+\t\tpublic final long[] fullContextTransitions;\n+\n+\t\tprivate int decision;\n \n \t\tpublic StatisticsParserATNSimulator(ATN atn, DFA[] decisionToDFA, PredictionContextCache sharedContextCache) {\n \t\t\tsuper(atn, decisionToDFA, sharedContextCache);\n+\t\t\tdecisionInvocations = new long[atn.decisionToState.size()];\n+\t\t\tfullContextFallback = new long[atn.decisionToState.size()];\n+\t\t\tnonSll = new long[atn.decisionToState.size()];\n+\t\t\ttotalTransitions = new long[atn.decisionToState.size()];\n+\t\t\tcomputedTransitions = new long[atn.decisionToState.size()];\n+\t\t\tfullContextTransitions = new long[atn.decisionToState.size()];\n \t\t}\n \n \t\tpublic StatisticsParserATNSimulator(Parser parser, ATN atn, DFA[] decisionToDFA, PredictionContextCache sharedContextCache) {\n \t\t\tsuper(parser, atn, decisionToDFA, sharedContextCache);\n+\t\t\tdecisionInvocations = new long[atn.decisionToState.size()];\n+\t\t\tfullContextFallback = new long[atn.decisionToState.size()];\n+\t\t\tnonSll = new long[atn.decisionToState.size()];\n+\t\t\ttotalTransitions = new long[atn.decisionToState.size()];\n+\t\t\tcomputedTransitions = new long[atn.decisionToState.size()];\n+\t\t\tfullContextTransitions = new long[atn.decisionToState.size()];\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int adaptivePredict(TokenStream input, int decision, ParserRuleContext outerContext) {\n+\t\t\ttry {\n+\t\t\t\tthis.decision = decision;\n+\t\t\t\tdecisionInvocations[decision]++;\n+\t\t\t\treturn super.adaptivePredict(input, decision, outerContext);\n+\t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tthis.decision = -1;\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected int execATNWithFullContext(DFA dfa, DFAState D, ATNConfigSet s0, TokenStream input, int startIndex, ParserRuleContext outerContext) {\n+\t\t\tfullContextFallback[decision]++;\n+\t\t\treturn super.execATNWithFullContext(dfa, D, s0, input, startIndex, outerContext);\n \t\t}\n \n \t\t@Override\n \t\tprotected DFAState getExistingTargetState(DFAState previousD, int t) {\n-\t\t\ttotalTransitions++;\n+\t\t\ttotalTransitions[decision]++;\n \t\t\treturn super.getExistingTargetState(previousD, t);\n \t\t}\n \n \t\t@Override\n \t\tprotected DFAState computeTargetState(DFA dfa, DFAState previousD, int t) {\n-\t\t\tcomputedTransitions++;\n+\t\t\tcomputedTransitions[decision]++;\n \t\t\treturn super.computeTargetState(dfa, previousD, t);\n \t\t}\n \n \t\t@Override\n \t\tprotected ATNConfigSet computeReachSet(ATNConfigSet closure, int t, boolean fullCtx) {\n \t\t\tif (fullCtx) {\n-\t\t\t\ttotalTransitions++;\n-\t\t\t\tcomputedTransitions++;\n-\t\t\t\tfullContextTransitions++;\n+\t\t\t\ttotalTransitions[decision]++;\n+\t\t\t\tcomputedTransitions[decision]++;\n+\t\t\t\tfullContextTransitions[decision]++;\n \t\t\t}\n \n \t\t\treturn super.computeReachSet(closure, t, fullCtx);\n@@ -1436,9 +1592,21 @@ private static BitSet getRepresentedAlts(ATNConfigSet configs) {\n \t}\n \n \tprivate static class SummarizingDiagnosticErrorListener extends DiagnosticErrorListener {\n+\t\tprivate BitSet _sllConflict;\n+\t\tprivate ATNConfigSet _sllConfigs;\n \n \t\t@Override\n \t\tpublic void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, boolean exact, BitSet ambigAlts, ATNConfigSet configs) {\n+\t\t\tif (COMPUTE_TRANSITION_STATS && DETAILED_DFA_STATE_STATS) {\n+\t\t\t\tBitSet sllPredictions = _sllConflict != null ? _sllConflict : getRepresentedAlts(_sllConfigs);\n+\t\t\t\tint sllPrediction = sllPredictions.nextSetBit(0);\n+\t\t\t\tBitSet llPredictions = ambigAlts != null ? ambigAlts : getRepresentedAlts(configs);\n+\t\t\t\tint llPrediction = llPredictions.cardinality() == 0 ? ATN.INVALID_ALT_NUMBER : llPredictions.nextSetBit(0);\n+\t\t\t\tif (sllPrediction != llPrediction) {\n+\t\t\t\t\t((StatisticsParserATNSimulator)recognizer.getInterpreter()).nonSll[dfa.decision]++;\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\tif (!REPORT_AMBIGUITIES) {\n \t\t\t\treturn;\n \t\t\t}\n@@ -1453,6 +1621,8 @@ public void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stop\n \n \t\t@Override\n \t\tpublic void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex, BitSet conflictingAlts, ATNConfigSet configs) {\n+\t\t\t_sllConflict = conflictingAlts;\n+\t\t\t_sllConfigs = configs;\n \t\t\tif (!REPORT_FULL_CONTEXT) {\n \t\t\t\treturn;\n \t\t\t}\n@@ -1468,6 +1638,14 @@ public void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startInd\n \n \t\t@Override\n \t\tpublic void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, int prediction, ATNConfigSet configs) {\n+\t\t\tif (COMPUTE_TRANSITION_STATS && DETAILED_DFA_STATE_STATS) {\n+\t\t\t\tBitSet sllPredictions = _sllConflict != null ? _sllConflict : getRepresentedAlts(_sllConfigs);\n+\t\t\t\tint sllPrediction = sllPredictions.nextSetBit(0);\n+\t\t\t\tif (sllPrediction != prediction) {\n+\t\t\t\t\t((StatisticsParserATNSimulator)recognizer.getInterpreter()).nonSll[dfa.decision]++;\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\tif (!REPORT_CONTEXT_SENSITIVITY) {\n \t\t\t\treturn;\n \t\t\t}",
      "parent_sha": "0644d1a4710fc750256b88e532c805c26b7c6180"
    }
  },
  {
    "oid": "64b6408e4a04ea7cbddf68dec7b0f12f941688c4",
    "message": "Update documentation for ANTLRErrorListener (fixes #603)",
    "date": "2014-06-16T04:56:50Z",
    "url": "https://github.com/antlr/antlr4/commit/64b6408e4a04ea7cbddf68dec7b0f12f941688c4",
    "details": {
      "sha": "3b98968b4546d1465fa20715c73d9e8a3a0ebfc8",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/ANTLRErrorListener.java",
      "status": "modified",
      "additions": 25,
      "deletions": 10,
      "changes": 35,
      "blob_url": "https://github.com/antlr/antlr4/blob/64b6408e4a04ea7cbddf68dec7b0f12f941688c4/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FANTLRErrorListener.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/64b6408e4a04ea7cbddf68dec7b0f12f941688c4/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FANTLRErrorListener.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FANTLRErrorListener.java?ref=64b6408e4a04ea7cbddf68dec7b0f12f941688c4",
      "patch": "@@ -31,6 +31,7 @@\n package org.antlr.v4.runtime;\n \n import org.antlr.v4.runtime.atn.ATNConfigSet;\n+import org.antlr.v4.runtime.atn.DecisionInfo;\n import org.antlr.v4.runtime.atn.ParserATNSimulator;\n import org.antlr.v4.runtime.atn.PredictionMode;\n import org.antlr.v4.runtime.dfa.DFA;\n@@ -85,29 +86,37 @@ public void syntaxError(@NotNull Recognizer<?, ?> recognizer,\n \t * This method is called by the parser when a full-context prediction\n \t * results in an ambiguity.\n \t *\n-\t * <p>When {@code exact} is {@code true}, <em>all</em> of the alternatives in\n-\t * {@code ambigAlts} are viable, i.e. this is reporting an exact ambiguity.\n-\t * When {@code exact} is {@code false}, <em>at least two</em> of the\n-\t * alternatives in {@code ambigAlts} are viable for the current input, but\n+\t * <p>When {@code ambigAlts} is not null, it contains the set of potentially\n+\t * viable alternatives identified by the prediction algorithm. When\n+\t * {@code ambigAlts} is null, use {@link ATNConfigSet#getAlts} to obtain the\n+\t * represented alternatives from the {@code configs} argument.</p>\n+\t *\n+\t * <p>When {@code exact} is {@code true}, <em>all</em> of the potentially\n+\t * viable alternatives are truly viable, i.e. this is reporting an exact\n+\t * ambiguity. When {@code exact} is {@code false}, <em>at least two</em> of\n+\t * the potentially viable alternatives are viable for the current input, but\n \t * the prediction algorithm terminated as soon as it determined that at\n-\t * least the <em>minimum</em> alternative in {@code ambigAlts} is viable.</p>\n+\t * least the <em>minimum</em> potentially viable alternative is truly\n+\t * viable.</p>\n \t *\n-\t * <p>When the {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} prediction mode\n-\t * is used, the parser is required to identify exact ambiguities so\n+\t * <p>When the {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} prediction\n+\t * mode is used, the parser is required to identify exact ambiguities so\n \t * {@code exact} will always be {@code true}.</p>\n \t *\n \t * <p>This method is not used by lexers.</p>\n \t *\n \t * @param recognizer the parser instance\n \t * @param dfa the DFA for the current decision\n \t * @param startIndex the input index where the decision started\n-\t * @param stopIndex the input input where the ambiguity is reported\n+\t * @param stopIndex the input input where the ambiguity was identified\n \t * @param exact {@code true} if the ambiguity is exactly known, otherwise\n \t * {@code false}. This is always {@code true} when\n \t * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} is used.\n-\t * @param ambigAlts the potentially ambiguous alternatives\n+\t * @param ambigAlts the potentially ambiguous alternatives, or {@code null}\n+\t * to indicate that the potentially ambiguous alternatives are the complete\n+\t * set of represented alternatives in {@code configs}\n \t * @param configs the ATN configuration set where the ambiguity was\n-\t * determined\n+\t * identified\n \t */\n \tvoid reportAmbiguity(@NotNull Parser recognizer,\n \t\t\t\t\t\t @NotNull DFA dfa,\n@@ -164,6 +173,12 @@ void reportAttemptingFullContext(@NotNull Parser recognizer,\n \t * beginning the full-context prediction. In all cases, the final prediction\n \t * is passed as the {@code prediction} argument.</p>\n \t *\n+\t * <p>Note that the definition of \"context sensitivity\" in this method\n+\t * differs from the concept in {@link DecisionInfo#contextSensitivities}.\n+\t * This method reports all instances where an SLL conflict occurred but LL\n+\t * parsing produced a unique result, whether or not that unique result\n+\t * matches the minimum alternative in the SLL conflicting set.</p>\n+\t *\n \t * <p>This method is not used by lexers.</p>\n \t *\n \t * @param recognizer the parser instance",
      "parent_sha": "633d4e2e19ab176aaf3edabc67eebe5ecd0a43e0"
    }
  },
  {
    "oid": "a9e44f3aab09c3641d542474bb947ee3dd720f3a",
    "message": "Use isEmpty() instead of size()==0, use StringBuilder instead of StringBuffer, use chained append() calls instead of string concatenation, add @Override annotations",
    "date": "2012-02-09T00:57:05Z",
    "url": "https://github.com/antlr/antlr4/commit/a9e44f3aab09c3641d542474bb947ee3dd720f3a",
    "details": {
      "sha": "3c52bb9cf9bd6b47512233fda69df8f4368d174d",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/misc/IntervalSet.java",
      "status": "modified",
      "additions": 10,
      "deletions": 8,
      "changes": 18,
      "blob_url": "https://github.com/antlr/antlr4/blob/a9e44f3aab09c3641d542474bb947ee3dd720f3a/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fmisc%2FIntervalSet.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/a9e44f3aab09c3641d542474bb947ee3dd720f3a/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fmisc%2FIntervalSet.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fmisc%2FIntervalSet.java?ref=a9e44f3aab09c3641d542474bb947ee3dd720f3a",
      "patch": "@@ -363,7 +363,7 @@ public boolean contains(int el) {\n     /** return true if this set has no members */\n     @Override\n     public boolean isNil() {\n-        return intervals==null || intervals.size()==0;\n+        return intervals==null || intervals.isEmpty();\n     }\n \n     /** If this set is a single integer, return it otherwise Token.INVALID_TYPE */\n@@ -422,6 +422,7 @@ public int hashCode() {\n      *  to make sure they are the same.  Interval.equals() is used\n      *  by the List.equals() method to check the ranges.\n      */\n+    @Override\n     public boolean equals(Object obj) {\n         if ( obj==null || !(obj instanceof IntervalSet) ) {\n             return false;\n@@ -430,11 +431,12 @@ public boolean equals(Object obj) {\n \t\treturn this.intervals.equals(other.intervals);\n \t}\n \n+\t@Override\n \tpublic String toString() { return toString(false); }\n \n \tpublic String toString(boolean elemAreChar) {\n-\t\tStringBuffer buf = new StringBuffer();\n-\t\tif ( this.intervals==null || this.intervals.size()==0 ) {\n+\t\tStringBuilder buf = new StringBuilder();\n+\t\tif ( this.intervals==null || this.intervals.isEmpty() ) {\n \t\t\treturn \"{}\";\n \t\t}\n \t\tif ( this.size()>1 ) {\n@@ -447,12 +449,12 @@ public String toString(boolean elemAreChar) {\n \t\t\tint b = I.b;\n \t\t\tif ( a==b ) {\n \t\t\t\tif ( a==-1 ) buf.append(\"<EOF>\");\n-\t\t\t\telse if ( elemAreChar ) buf.append(\"'\"+(char)a+\"'\");\n+\t\t\t\telse if ( elemAreChar ) buf.append(\"'\").append((char)a).append(\"'\");\n \t\t\t\telse buf.append(a);\n \t\t\t}\n \t\t\telse {\n-\t\t\t\tif ( elemAreChar ) buf.append(\"'\"+(char)a+\"'..'\"+(char)b+\"'\");\n-\t\t\t\telse buf.append(a+\"..\"+b);\n+\t\t\t\tif ( elemAreChar ) buf.append(\"'\").append((char)a).append(\"'..'\").append((char)b).append(\"'\");\n+\t\t\t\telse buf.append(a).append(\"..\").append(b);\n \t\t\t}\n \t\t\tif ( iter.hasNext() ) {\n \t\t\t\tbuf.append(\", \");\n@@ -465,8 +467,8 @@ public String toString(boolean elemAreChar) {\n \t}\n \n \tpublic String toString(String[] tokenNames) {\n-\t\tStringBuffer buf = new StringBuffer();\n-\t\tif ( this.intervals==null || this.intervals.size()==0 ) {\n+\t\tStringBuilder buf = new StringBuilder();\n+\t\tif ( this.intervals==null || this.intervals.isEmpty() ) {\n \t\t\treturn \"{}\";\n \t\t}\n \t\tif ( this.size()>1 ) {",
      "parent_sha": "d181b230dc1ce38dd759eba558fdec8108b270bb"
    }
  },
  {
    "oid": "c68e127a7cf14470565d6e6ae1eff06db3e56ea7",
    "message": "Revert \"[Java] Preserve serialized ATN version 3 compatibility (#3583)\"\n\nThis reverts commit 01bc811557adad0de63e8db85b78ca8885480378.",
    "date": "2022-03-18T18:12:27Z",
    "url": "https://github.com/antlr/antlr4/commit/c68e127a7cf14470565d6e6ae1eff06db3e56ea7",
    "details": {
      "sha": "0bd643a131000b18a41b20879d7b3d7153dd516d",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/atn/ATNDeserializer.java",
      "status": "modified",
      "additions": 4,
      "deletions": 10,
      "changes": 14,
      "blob_url": "https://github.com/antlr/antlr4/blob/c68e127a7cf14470565d6e6ae1eff06db3e56ea7/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FATNDeserializer.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/c68e127a7cf14470565d6e6ae1eff06db3e56ea7/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FATNDeserializer.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FATNDeserializer.java?ref=c68e127a7cf14470565d6e6ae1eff06db3e56ea7",
      "patch": "@@ -20,10 +20,10 @@\n  * @author Sam Harwell\n  */\n public class ATNDeserializer {\n-\n-  static final int LEGACY_SERIALIZED_VERSION = 3;\n-\n-\tpublic static final int SERIALIZED_VERSION = 4;\n+\tpublic static final int SERIALIZED_VERSION;\n+\tstatic {\n+\t\tSERIALIZED_VERSION = 4;\n+\t}\n \n \tinterface UnicodeDeserializer {\n \t\t// Wrapper for readInt() or readInt32()\n@@ -90,12 +90,6 @@ public ATN deserialize(char[] data) {\n \n \t\tint p = 0;\n \t\tint version = toInt(data[p++]);\n-    if (version == LEGACY_SERIALIZED_VERSION) {\n-      // Preserve backwards compatibility for version 3. We simply skip over the UUID and assume all\n-      // features were supported.\n-      p += 8;\n-      version = SERIALIZED_VERSION;\n-    }\n \t\tif (version != SERIALIZED_VERSION) {\n \t\t\tString reason = String.format(Locale.getDefault(), \"Could not deserialize ATN with version %d (expected %d).\", version, SERIALIZED_VERSION);\n \t\t\tthrow new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(), reason));",
      "parent_sha": "6d79c193b625a88d010a4ea7322a044697f4fbb1"
    }
  },
  {
    "oid": "d71c2157cec0245df8a2ec0a3c29e3a7188d4a05",
    "message": "Fixed @sharwell note about comment.",
    "date": "2017-01-08T12:08:48Z",
    "url": "https://github.com/antlr/antlr4/commit/d71c2157cec0245df8a2ec0a3c29e3a7188d4a05",
    "details": {
      "sha": "cf21ddf57539163c8a425ae366de4163fe457587",
      "filename": "tool/src/org/antlr/v4/semantics/SymbolChecks.java",
      "status": "modified",
      "additions": 14,
      "deletions": 9,
      "changes": 23,
      "blob_url": "https://github.com/antlr/antlr4/blob/d71c2157cec0245df8a2ec0a3c29e3a7188d4a05/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fsemantics%2FSymbolChecks.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/d71c2157cec0245df8a2ec0a3c29e3a7188d4a05/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fsemantics%2FSymbolChecks.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fsemantics%2FSymbolChecks.java?ref=d71c2157cec0245df8a2ec0a3c29e3a7188d4a05",
      "patch": "@@ -141,15 +141,16 @@ public void checkForLabelConflicts(Collection<Rule> rules) {\n \t\t\t\t\t\tMap<String, List<LabelElementPair>> labelPairs = new HashMap<>();\n \t\t\t\t\t\tfor (LabelElementPair p : pairs) {\n \t\t\t\t\t\t\tString labelName = findAltLabelName(p.label);\n-\t\t\t\t\t\t\tList<LabelElementPair> list;\n-\t\t\t\t\t\t\tif (labelPairs.containsKey(labelName)) {\n-\t\t\t\t\t\t\t\tlist = labelPairs.get(labelName);\n+\t\t\t\t\t\t\tif (labelName != null) {\n+\t\t\t\t\t\t\t\tList<LabelElementPair> list;\n+\t\t\t\t\t\t\t\tif (labelPairs.containsKey(labelName)) {\n+\t\t\t\t\t\t\t\t\tlist = labelPairs.get(labelName);\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tlist = new ArrayList<>();\n+\t\t\t\t\t\t\t\t\tlabelPairs.put(labelName, list);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tlist.add(p);\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\t\tlist = new ArrayList<>();\n-\t\t\t\t\t\t\t\tlabelPairs.put(labelName, list);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tlist.add(p);\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tfor (List<LabelElementPair> internalPairs : labelPairs.values()) {\n@@ -203,7 +204,11 @@ else if (altAST.leftRecursiveAltInfo != null) {\n \tprivate void checkForTypeMismatch(Rule r, LabelElementPair prevLabelPair, LabelElementPair labelPair) {\n \t\t// label already defined; if same type, no problem\n \t\tif (prevLabelPair.type != labelPair.type) {\n-\t\t\t// TODO: replace rule token for left-recursive rule with correct token.\n+\t\t\t// Current behavior: take a token of rule declaration in case of left-recursive rule\n+\t\t\t// Desired behavior: take a token of proper label declaration in case of left-recursive rule\n+\t\t\t// See https://github.com/antlr/antlr4/pull/1585\n+\t\t\t// Such behavior is referring to the fact that the warning is typically reported on the actual label redefinition,\n+\t\t\t//   but for left-recursive rules the warning is reported on the enclosing rule.\n \t\t\torg.antlr.runtime.Token token = r instanceof LeftRecursiveRule\n \t\t\t\t\t?  ((GrammarAST) r.ast.getChild(0)).getToken()\n \t\t\t\t\t: labelPair.label.token;",
      "parent_sha": "c929469c5f36fb2094ab2f494fbba7f29f24242b"
    }
  },
  {
    "oid": "38739cec5e18a3f9cab9a408b3d9f8fa8c01029e",
    "message": "Fix handling of grammars in the default package (resolves antlr/antlr4#94)",
    "date": "2012-12-02T22:57:42Z",
    "url": "https://github.com/antlr/antlr4/commit/38739cec5e18a3f9cab9a408b3d9f8fa8c01029e",
    "details": {
      "sha": "51d0c48dcd093a608cc944435cbd321ea5753454",
      "filename": "antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4Mojo.java",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/antlr/antlr4/blob/38739cec5e18a3f9cab9a408b3d9f8fa8c01029e/antlr4-maven-plugin%2Fsrc%2Fmain%2Fjava%2Forg%2Fantlr%2Fmojo%2Fantlr4%2FAntlr4Mojo.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/38739cec5e18a3f9cab9a408b3d9f8fa8c01029e/antlr4-maven-plugin%2Fsrc%2Fmain%2Fjava%2Forg%2Fantlr%2Fmojo%2Fantlr4%2FAntlr4Mojo.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/antlr4-maven-plugin%2Fsrc%2Fmain%2Fjava%2Forg%2Fantlr%2Fmojo%2Fantlr4%2FAntlr4Mojo.java?ref=38739cec5e18a3f9cab9a408b3d9f8fa8c01029e",
      "patch": "@@ -403,7 +403,7 @@ private List<List<String>> processGrammarFiles(List<String> args, File sourceDir\n \t\tList<List<String>> result = new ArrayList<List<String>>();\n \t\tfor (Map.Entry<String, List<File>> entry : grammarFileByFolder.entrySet()) {\n \t\t\tList<String> folderArgs = new ArrayList<String>(args);\n-\t\t\tif (!folderArgs.contains(\"-package\")) {\n+\t\t\tif (!folderArgs.contains(\"-package\") && !entry.getKey().isEmpty()) {\n \t\t\t\tfolderArgs.add(\"-package\");\n \t\t\t\tfolderArgs.add(getPackageName(entry.getKey()));\n \t\t\t}\n@@ -457,6 +457,9 @@ private String findSourceSubdir(File sourceDirectory, String grammarFileName) {\n         }\n \n         File unprefixedGrammarFileName = new File(grammarFileName.substring(srcPath.length()));\n+\t\tif (unprefixedGrammarFileName.getParent() == null) {\n+\t\t\treturn \"\";\n+\t\t}\n \n         return unprefixedGrammarFileName.getParent() + File.separator;\n     }",
      "parent_sha": "f14cce653904adad2e3e551b17eafc1830418370"
    }
  },
  {
    "oid": "f554a2ed4f024d8947306202752ee05c4ba192b6",
    "message": "Eliminate debug and dfa_debug overhead in LexerATNSimulator by making them compile-time constants",
    "date": "2012-10-29T18:32:02Z",
    "url": "https://github.com/antlr/antlr4/commit/f554a2ed4f024d8947306202752ee05c4ba192b6",
    "details": {
      "sha": "1117a73e874a8743a3747832c68a540c65663cf5",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/antlr/antlr4/blob/f554a2ed4f024d8947306202752ee05c4ba192b6/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FLexerATNSimulator.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/f554a2ed4f024d8947306202752ee05c4ba192b6/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FLexerATNSimulator.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FLexerATNSimulator.java?ref=f554a2ed4f024d8947306202752ee05c4ba192b6",
      "patch": "@@ -46,8 +46,8 @@\n \n /** \"dup\" of ParserInterpreter */\n public class LexerATNSimulator extends ATNSimulator {\n-\tpublic static boolean debug = false;\n-\tpublic static boolean dfa_debug = false;\n+\tpublic static final boolean debug = false;\n+\tpublic static final boolean dfa_debug = false;\n \n \tpublic static final int MIN_DFA_EDGE = 0;\n \tpublic static final int MAX_DFA_EDGE = 127; // forces unicode to stay in ATN",
      "parent_sha": "7bf50c82635e2449188bdf595889fdc10c56503e"
    }
  },
  {
    "oid": "327a3a01008af0efdbf31caa3eb5eff0bccadb33",
    "message": "Revert \"update comment on consume()\"\n\nThis reverts commit 27a8e5e521f284535d6e363b2d402f6ea7f0801a.",
    "date": "2012-10-15T01:46:54Z",
    "url": "https://github.com/antlr/antlr4/commit/327a3a01008af0efdbf31caa3eb5eff0bccadb33",
    "details": {
      "sha": "0b0ca6ff832c77b2d0a499c3baf80273b97ae84a",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/IntStream.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/antlr/antlr4/blob/327a3a01008af0efdbf31caa3eb5eff0bccadb33/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FIntStream.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/327a3a01008af0efdbf31caa3eb5eff0bccadb33/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FIntStream.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FIntStream.java?ref=327a3a01008af0efdbf31caa3eb5eff0bccadb33",
      "patch": "@@ -79,9 +79,9 @@ public interface IntStream {\n \t * filtering streams (e.g. {@link CommonTokenStream} which distinguishes\n \t * between \"on-channel\" and \"off-channel\" tokens).\n \t *\n-\t * @throws IllegalStateException if an attempt is made to consume past\n-\t * end of the stream (i.e. if last char == {@link #EOF EOF} before calling\n-\t * {@code consume}). Sometimes need to match EOF during prediction.\n+\t * @throws IllegalStateException if an attempt is made to consume the the\n+\t * end of the stream (i.e. if {@code LA(1)==}{@link #EOF EOF} before calling\n+\t * {@code consume}).\n \t */\n \tvoid consume();\n ",
      "parent_sha": "54871d52ff7e838f3891272980cc86798221c722"
    }
  },
  {
    "oid": "9eb19cf9294f670729547f02b6f1c7bcff727701",
    "message": "added start/stop methods.\n\n[git-p4: depot-paths = \"//depot/code/antlr4/main/\": change = 9145]",
    "date": "2011-10-12T23:09:14Z",
    "url": "https://github.com/antlr/antlr4/commit/9eb19cf9294f670729547f02b6f1c7bcff727701",
    "details": {
      "sha": "6127b8bd9c4b02f8d3c7337b4e15faeaef549d0f",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/Token.java",
      "status": "modified",
      "additions": 12,
      "deletions": 1,
      "changes": 13,
      "blob_url": "https://github.com/antlr/antlr4/blob/9eb19cf9294f670729547f02b6f1c7bcff727701/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FToken.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/9eb19cf9294f670729547f02b6f1c7bcff727701/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FToken.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FToken.java?ref=9eb19cf9294f670729547f02b6f1c7bcff727701",
      "patch": "@@ -82,10 +82,21 @@ public interface Token {\n \tint getChannel();\n \n \t/** An index from 0..n-1 of the token object in the input stream.\n-\t *  This must be valid in order to use the ANTLRWorks debugger.\n+\t *  This must be valid in order to print token streams,\n+\t *  use TokenRewriteStream, and generally deal with ASTs.\n \t */\n \tint getTokenIndex();\n \n+\t/** The starting character index of the token\n+\t *  This method is optional; return -1 if not implemented.\n+\t */\n+\tint getStartIndex();\n+\n+\t/** The last character index of the token.\n+\t *  This method is optional; return -1 if not implemented.\n+\t */\n+\tint getStopIndex();\n+\n \t/** Where does this token come from? You can get the\n \t *  character input stream from the token source.\n \t */",
      "parent_sha": "3bbcfa5d255bfdef4612345382faf3af25eb73df"
    }
  },
  {
    "oid": "c970a2e7ee9532dacbf661af83be955bd087d53a",
    "message": "Updated doc comment",
    "date": "2012-03-17T22:30:53Z",
    "url": "https://github.com/antlr/antlr4/commit/c970a2e7ee9532dacbf661af83be955bd087d53a",
    "details": {
      "sha": "ef22e994198602defdeff06d866a463863ab72a0",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/CommonTokenStream.java",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/antlr/antlr4/blob/c970a2e7ee9532dacbf661af83be955bd087d53a/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FCommonTokenStream.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/c970a2e7ee9532dacbf661af83be955bd087d53a/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FCommonTokenStream.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FCommonTokenStream.java?ref=c970a2e7ee9532dacbf661af83be955bd087d53a",
      "patch": "@@ -59,7 +59,11 @@ public CommonTokenStream(TokenSource tokenSource, int channel) {\n         this.channel = channel;\n     }\n \n-    /** Always leave p on an on-channel token. */\n+    /**\n+\t * {@inheritDoc}\n+\t * <p>\n+\t * Always leave {@code p} on an on-channel token.\n+\t */\n     @Override\n     public void consume() {\n \t\tsuper.consume();",
      "parent_sha": "e8830ae51a2a14e14ef12b990a365fa2045e19e6"
    }
  },
  {
    "oid": "2393cfd40ec885281f6cee06e8b0fd64ff36149c",
    "message": "Remove unnecessary locals",
    "date": "2013-04-18T20:52:28Z",
    "url": "https://github.com/antlr/antlr4/commit/2393cfd40ec885281f6cee06e8b0fd64ff36149c",
    "details": {
      "sha": "70489535d7b329e6dfe599c56bb9987eb337bc99",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java",
      "status": "modified",
      "additions": 5,
      "deletions": 9,
      "changes": 14,
      "blob_url": "https://github.com/antlr/antlr4/blob/2393cfd40ec885281f6cee06e8b0fd64ff36149c/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/2393cfd40ec885281f6cee06e8b0fd64ff36149c/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java?ref=2393cfd40ec885281f6cee06e8b0fd64ff36149c",
      "patch": "@@ -557,27 +557,24 @@ public int execATN(@NotNull DFA dfa, @NotNull DFAState s0,\n \t\t}\n \t\tATN_failover++;\n \n-\t\tATNConfigSet previous = s0.configs;\n \t\tDFAState previousD = s0;\n \n \t\tif ( debug ) System.out.println(\"s0 = \"+s0);\n \n \t\tint t = input.LA(1);\n \n-        DecisionState decState = atn.getDecisionState(dfa.decision);\n-\n \t\twhile (true) { // while more work\n \t\t\tDFAState D = null;\n \t\t\tif (previousD.edges != null && t + 1 >= 0 && t + 1 < previousD.edges.length) {\n \t\t\t\tD = previousD.edges[t + 1];\n \t\t\t\tif ( D == ERROR ) {\n-\t\t\t\t\tthrow noViableAlt(input, outerContext, previous, startIndex);\n+\t\t\t\t\tthrow noViableAlt(input, outerContext, previousD.configs, startIndex);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (D == null) {\n \t//\t\t\tSystem.out.println(\"REACH \"+getLookaheadName(input));\n-\t\t\t\tATNConfigSet reach = computeReachSet(previous, t, false);\n+\t\t\t\tATNConfigSet reach = computeReachSet(previousD.configs, t, false);\n \t\t\t\tif ( reach==null ) {\n \t\t\t\t\t// if any configs in previous dipped into outer context, that\n \t\t\t\t\t// means that input up to t actually finished entry rule\n@@ -593,7 +590,7 @@ public int execATN(@NotNull DFA dfa, @NotNull DFAState s0,\n \t\t\t\t\t\t// return w/o altering DFA\n \t\t\t\t\t\treturn alt;\n \t\t\t\t\t}\n-\t\t\t\t\tthrow noViableAlt(input, outerContext, previous, startIndex);\n+\t\t\t\t\tthrow noViableAlt(input, outerContext, previousD.configs, startIndex);\n \t\t\t\t}\n \n \t\t\t\t// create new target state; we'll add to DFA after it's complete\n@@ -639,7 +636,7 @@ else if ( PredictionMode.hasSLLConflictTerminatingPrediction(mode, reach) ) {\n \t\t\t\t\telse {\n \t\t\t\t\t\t// IF PREDS, MIGHT RESOLVE TO SINGLE ALT => SLL (or syntax error)\n \t\t\t\t\t\tif ( D.configs.hasSemanticContext ) {\n-\t\t\t\t\t\t\tpredicateDFAState(D, decState);\n+\t\t\t\t\t\t\tpredicateDFAState(D, atn.getDecisionState(dfa.decision));\n \t\t\t\t\t\t\tif (D.predicates != null) {\n \t\t\t\t\t\t\t\tint conflictIndex = input.index();\n \t\t\t\t\t\t\t\tif (conflictIndex != startIndex) {\n@@ -682,7 +679,7 @@ else if ( PredictionMode.hasSLLConflictTerminatingPrediction(mode, reach) ) {\n \t\t\t\t}\n \n \t\t\t\tif ( D.isAcceptState && D.configs.hasSemanticContext ) {\n-\t\t\t\t\tpredicateDFAState(D, decState);\n+\t\t\t\t\tpredicateDFAState(D, atn.getDecisionState(dfa.decision));\n \t\t\t\t\tif (D.predicates != null) {\n \t\t\t\t\t\tD.prediction = ATN.INVALID_ALT_NUMBER;\n \t\t\t\t\t}\n@@ -750,7 +747,6 @@ else if ( D.requiresFullContext && mode != PredictionMode.SLL ) {\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tprevious = D.configs;\n \t\t\tpreviousD = D;\n \n \t\t\tif (t != IntStream.EOF) {",
      "parent_sha": "572712872227fcf03d97593e0bccffad6b99a759"
    }
  },
  {
    "oid": "1072ace723dd9c8486cde1ff21f004dac5753b60",
    "message": "remove uncessary sourceName variable",
    "date": "2015-08-15T04:02:55Z",
    "url": "https://github.com/antlr/antlr4/commit/1072ace723dd9c8486cde1ff21f004dac5753b60",
    "details": {
      "sha": "990cac617f79d92cf2170abb32cb906c57948ce5",
      "filename": "tool-testsuite/test/org/antlr/v4/test/tool/TestPerformance.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/antlr/antlr4/blob/1072ace723dd9c8486cde1ff21f004dac5753b60/tool-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Ftool%2FTestPerformance.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/1072ace723dd9c8486cde1ff21f004dac5753b60/tool-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Ftool%2FTestPerformance.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Ftool%2FTestPerformance.java?ref=1072ace723dd9c8486cde1ff21f004dac5753b60",
      "patch": "@@ -1109,10 +1109,9 @@ private static long sum(long[] array) {\n \n     protected void compileJavaParser(boolean leftRecursive) throws IOException {\n         String grammarFileName = leftRecursive ? \"JavaLR.g4\"    : \"Java.g4\";\n-        String sourceName      = leftRecursive ? \"JavaLR.g4\"    : \"Java.g4\";\n         String parserName      = leftRecursive ? \"JavaLRParser\" : \"JavaParser\";\n         String lexerName       = leftRecursive ? \"JavaLRLexer\"  : \"JavaLexer\";\n-        String body = load(sourceName, null);\n+        String body = load(grammarFileName, null);\n         List<String> extraOptions = new ArrayList<String>();\n \t\textraOptions.add(\"-Werror\");\n         if (FORCE_ATN) {",
      "parent_sha": "63200907d671975c044e290e9544f21e4c056ddb"
    }
  },
  {
    "oid": "6f057dbc59af404187bc2d60da90013ad785f7b3",
    "message": "Use STGroupFile filename constructor\n\n- URL constructor unnecessary",
    "date": "2018-11-13T20:59:12Z",
    "url": "https://github.com/antlr/antlr4/commit/6f057dbc59af404187bc2d60da90013ad785f7b3",
    "details": {
      "sha": "36341723e97ce33b4a9ee532b5674553172c8ea8",
      "filename": "tool/src/org/antlr/v4/codegen/Target.java",
      "status": "modified",
      "additions": 2,
      "deletions": 5,
      "changes": 7,
      "blob_url": "https://github.com/antlr/antlr4/blob/6f057dbc59af404187bc2d60da90013ad785f7b3/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fcodegen%2FTarget.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/6f057dbc59af404187bc2d60da90013ad785f7b3/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fcodegen%2FTarget.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fcodegen%2FTarget.java?ref=6f057dbc59af404187bc2d60da90013ad785f7b3",
      "patch": "@@ -506,10 +506,9 @@ public boolean grammarSymbolCausesIssueInGeneratedCode(GrammarAST idNode) {\n \n \tpublic boolean templatesExist() {\n \t\tString groupFileName = CodeGenerator.TEMPLATE_ROOT + \"/\" + getLanguage() + \"/\" + getLanguage() + STGroup.GROUP_FILE_EXTENSION;\n-\t\tURL url = Thread.currentThread().getContextClassLoader().getResource(groupFileName);\n \t\tSTGroup result = null;\n \t\ttry {\n-\t\t\tresult = new STGroupFile(url);\n+\t\t\tresult = new STGroupFile(groupFileName);\n \t\t}\n \t\tcatch (IllegalArgumentException iae) {\n \t\t\tresult = null;\n@@ -520,11 +519,9 @@ public boolean templatesExist() {\n \n \tprotected STGroup loadTemplates() {\n \t\tString groupFileName = CodeGenerator.TEMPLATE_ROOT + \"/\" + getLanguage() + \"/\" + getLanguage() + STGroup.GROUP_FILE_EXTENSION;\n-\t\tURL url = Thread.currentThread().getContextClassLoader().getResource(groupFileName);\n-\n \t\tSTGroup result = null;\n \t\ttry {\n-\t\t\tresult = new STGroupFile(url);\n+\t\t\tresult = new STGroupFile(groupFileName);\n \t\t}\n \t\tcatch (IllegalArgumentException iae) {\n \t\t\tgen.tool.errMgr.toolError(ErrorType.MISSING_CODE_GEN_TEMPLATES,",
      "parent_sha": "7fcadaa9f7b1fca5bb4857aa8b468072d95b711d"
    }
  },
  {
    "oid": "b917c01bbae1531037f554d56324dc69bc1fe1d3",
    "message": "Fix lexer error recovery could try to consume EOF",
    "date": "2012-11-04T17:30:03Z",
    "url": "https://github.com/antlr/antlr4/commit/b917c01bbae1531037f554d56324dc69bc1fe1d3",
    "details": {
      "sha": "f56cd5bafdd6e25f1c66d68ed1487bb8288dadfc",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/Lexer.java",
      "status": "modified",
      "additions": 9,
      "deletions": 6,
      "changes": 15,
      "blob_url": "https://github.com/antlr/antlr4/blob/b917c01bbae1531037f554d56324dc69bc1fe1d3/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FLexer.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/b917c01bbae1531037f554d56324dc69bc1fe1d3/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FLexer.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FLexer.java?ref=b917c01bbae1531037f554d56324dc69bc1fe1d3",
      "patch": "@@ -134,17 +134,17 @@ public Token nextToken() {\n \t\t\tthrow new IllegalStateException(\"nextToken requires a non-null input stream.\");\n \t\t}\n \n-\t\tif (_hitEOF) {\n-\t\t\temitEOF();\n-\t\t\treturn _token;\n-\t\t}\n-\n \t\t// Mark start location in char stream so unbuffered streams are\n \t\t// guaranteed at least have text of current token\n \t\tint tokenStartMarker = _input.mark();\n \t\ttry{\n \t\t\touter:\n \t\t\twhile (true) {\n+\t\t\t\tif (_hitEOF) {\n+\t\t\t\t\temitEOF();\n+\t\t\t\t\treturn _token;\n+\t\t\t\t}\n+\n \t\t\t\t_token = null;\n \t\t\t\t_channel = Token.DEFAULT_CHANNEL;\n \t\t\t\t_tokenStartCharIndex = _input.index();\n@@ -369,7 +369,10 @@ public List<? extends Token> getAllTokens() {\n \t}\n \n \tpublic void recover(LexerNoViableAltException e) {\n-\t\tgetInterpreter().consume(_input); // skip a char and try again\n+\t\tif (_input.LA(1) != IntStream.EOF) {\n+\t\t\t// skip a char and try again\n+\t\t\tgetInterpreter().consume(_input);\n+\t\t}\n \t}\n \n \tpublic void notifyListeners(LexerNoViableAltException e) {",
      "parent_sha": "090337011736a4ee094a2e5ef901d5e85128888d"
    }
  },
  {
    "oid": "2080be8a1457fd8db4eca8ffdfc16322c2e91f35",
    "message": "Cannot call IntStream.consume after EOF is reached",
    "date": "2013-01-02T14:30:25Z",
    "url": "https://github.com/antlr/antlr4/commit/2080be8a1457fd8db4eca8ffdfc16322c2e91f35",
    "details": {
      "sha": "fa9ff002ae5c1a1dfc6ea11a7f67bc2aa7f77f43",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java",
      "status": "modified",
      "additions": 11,
      "deletions": 5,
      "changes": 16,
      "blob_url": "https://github.com/antlr/antlr4/blob/2080be8a1457fd8db4eca8ffdfc16322c2e91f35/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/2080be8a1457fd8db4eca8ffdfc16322c2e91f35/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java?ref=2080be8a1457fd8db4eca8ffdfc16322c2e91f35",
      "patch": "@@ -510,7 +510,7 @@ public int execDFA(@NotNull DFA dfa, @NotNull DFAState s0,\n \t\t\t\tthrow noViableAlt(input, outerContext, s.configs, startIndex);\n \t\t\t}\n \t\t\ts = target;\n-\t\t\tif (!s.requiresFullContext && !s.isAcceptState) {\n+\t\t\tif (!s.requiresFullContext && !s.isAcceptState && t != IntStream.EOF) {\n \t\t\t\tinput.consume();\n \t\t\t\tt = input.LA(1);\n \t\t\t}\n@@ -742,8 +742,11 @@ else if ( PredictionMode.hasSLLConflictTerminatingPrediction(mode, reach) ) {\n \n \t\t\tprevious = reach;\n \t\t\tpreviousD = D;\n-\t\t\tinput.consume();\n-\t\t\tt = input.LA(1);\n+\n+\t\t\tif (t != IntStream.EOF) {\n+\t\t\t\tinput.consume();\n+\t\t\t\tt = input.LA(1);\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -846,9 +849,12 @@ public int execATNWithFullContext(DFA dfa,\n \t\t\t\t// we're not sure what the ambiguity is yet.\n \t\t\t\t// So, keep going.\n \t\t\t}\n+\n \t\t\tprevious = reach;\n-\t\t\tinput.consume();\n-\t\t\tt = input.LA(1);\n+\t\t\tif (t != IntStream.EOF) {\n+\t\t\t\tinput.consume();\n+\t\t\t\tt = input.LA(1);\n+\t\t\t}\n \t\t}\n \n \t\t// If the configuration set uniquely predicts an alternative,",
      "parent_sha": "e3383ecb612d21ddbcf8399bc228b9b5e5d6a799"
    }
  },
  {
    "oid": "d6e1ca2b61bb8b72b3f7cc52e68701287cb0f175",
    "message": "Fix NPE when the grammar has no rules",
    "date": "2012-11-19T00:13:27Z",
    "url": "https://github.com/antlr/antlr4/commit/d6e1ca2b61bb8b72b3f7cc52e68701287cb0f175",
    "details": {
      "sha": "16780393c45590dced3b78decabbdc40eeaba101",
      "filename": "tool/src/org/antlr/v4/Tool.java",
      "status": "modified",
      "additions": 11,
      "deletions": 5,
      "changes": 16,
      "blob_url": "https://github.com/antlr/antlr4/blob/d6e1ca2b61bb8b72b3f7cc52e68701287cb0f175/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2FTool.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/d6e1ca2b61bb8b72b3f7cc52e68701287cb0f175/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2FTool.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2FTool.java?ref=d6e1ca2b61bb8b72b3f7cc52e68701287cb0f175",
      "patch": "@@ -433,10 +433,16 @@ public void processNonCombinedGrammar(Grammar g, boolean gencode) {\n \tpublic boolean checkForRuleIssues(final Grammar g) {\n \t\t// check for redefined rules\n \t\tGrammarAST RULES = (GrammarAST)g.ast.getFirstChildWithType(ANTLRParser.RULES);\n-\t\tList<RuleAST> rules = (List<RuleAST>)RULES.getChildren();\n+\n+\t\tList<?> rules = (List<?>)RULES.getChildren();\n+\t\tif (rules == null) {\n+\t\t\trules = Collections.emptyList();\n+\t\t}\n+\n \t\tfinal Map<String, RuleAST> ruleToAST = new HashMap<String, RuleAST>();\n-\t\tfor (RuleAST r : rules) {\n-\t\t\tGrammarAST ID = (GrammarAST)r.getChild(0);\n+\t\tfor (Object r : rules) {\n+\t\t\tRuleAST ruleAST = (RuleAST)r;\n+\t\t\tGrammarAST ID = (GrammarAST)ruleAST.getChild(0);\n \t\t\tString ruleName = ID.getText();\n \t\t\tRuleAST prev = ruleToAST.get(ruleName);\n \t\t\tif ( prev !=null ) {\n@@ -446,10 +452,10 @@ public boolean checkForRuleIssues(final Grammar g) {\n \t\t\t\t\t\t\t\t\t\t   ID.getToken(),\n \t\t\t\t\t\t\t\t\t\t   ruleName,\n \t\t\t\t\t\t\t\t\t\t   prevChild.getToken().getLine());\n-\t\t\t\tr.dead = true;\n+\t\t\t\truleAST.dead = true;\n \t\t\t\tcontinue;\n \t\t\t}\n-\t\t\truleToAST.put(ruleName, r);\n+\t\t\truleToAST.put(ruleName, ruleAST);\n \t\t}\n \n \t\t// check for undefined rules",
      "parent_sha": "16ace4b429574f160ca9e515818d1d842ad39a3f"
    }
  },
  {
    "oid": "ec32b71761a480621de067c70711caa0691cbdc4",
    "message": "another unit test",
    "date": "2012-10-13T22:48:58Z",
    "url": "https://github.com/antlr/antlr4/commit/ec32b71761a480621de067c70711caa0691cbdc4",
    "details": {
      "sha": "ad583facbd978027f402e442ee1abed210e6c726",
      "filename": "tool/test/org/antlr/v4/test/TestFullContextParsing.java",
      "status": "modified",
      "additions": 37,
      "deletions": 1,
      "changes": 38,
      "blob_url": "https://github.com/antlr/antlr4/blob/ec32b71761a480621de067c70711caa0691cbdc4/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestFullContextParsing.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/ec32b71761a480621de067c70711caa0691cbdc4/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestFullContextParsing.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestFullContextParsing.java?ref=ec32b71761a480621de067c70711caa0691cbdc4",
      "patch": "@@ -253,7 +253,7 @@ public void testLoopsSimulateTailRecursion() throws Exception {\n \t}\n \n \t@Test\n-\tpublic void testTrueAmbiguityNoLoop() throws Exception {\n+\tpublic void testAmbiguityNoLoop() throws Exception {\n \t\t// simpler version of testLoopsSimulateTailRecursion, no loops\n \t\tString grammar =\n \t\t\t\"grammar T;\\n\" +\n@@ -277,4 +277,40 @@ public void testTrueAmbiguityNoLoop() throws Exception {\n \t\tassertEquals(expecting, this.stderrDuringParse);\n \t}\n \n+\t@Test\n+\tpublic void testExprAmbiguity() throws Exception {\n+\t\t// translated left-recursive expr rule to test ambig detection\n+\t\tString grammar =\n+\t\t\t\"grammar T;\\n\" +\n+\t\t\t\"s   :   expr[0] {System.out.println($expr.ctx.toStringTree(this));} ;\\n\" +\n+\t\t\t\"\\n\" +\n+\t\t\t\"expr[int _p]\\n\" +\n+\t\t\t\"    :   ID\\n\" +\n+\t\t\t\"        ( {5 >= $_p}? '*' expr[6]\\n\" +\n+\t\t\t\"        | {4 >= $_p}? '+' expr[5]\\n\" +\n+\t\t\t\"        )*\\n\" +\n+\t\t\t\"    ;\\n\" +\n+\t\t\t\"\\n\" +\n+\t\t\t\"ID  :   [a-zA-Z]+ ;      // match identifiers\\n\" +\n+\t\t\t\"WS  :   [ \\\\t\\\\r\\\\n]+ -> skip ; // toss out whitespace\\n\";\n+\n+\t\tString found = execParser(\"T.g4\", grammar, \"TParser\", \"TLexer\", \"s\", \"a+b\", true);\n+\t\tassertEquals(\"(expr a + (expr b))\\n\", found);\n+\n+\t\tString expecting =\n+\t\t\t\"line 1:1 reportAttemptingFullContext d=1, input='+'\\n\" +\n+\t\t\t\"line 1:1 reportContextSensitivity d=1, input='+'\\n\";\n+\t\tassertEquals(expecting, this.stderrDuringParse);\n+\n+\t\tfound = execParser(\"T.g4\", grammar, \"TParser\", \"TLexer\", \"s\", \"a+b*c\", true);\n+\t\tassertEquals(\"(expr a + (expr b * (expr c)))\\n\", found);\n+\n+\t\texpecting =\n+\t\t\t\"line 1:1 reportAttemptingFullContext d=1, input='+'\\n\" +\n+\t\t\t\"line 1:1 reportContextSensitivity d=1, input='+'\\n\" +\n+\t\t\t\"line 1:3 reportAttemptingFullContext d=1, input='*'\\n\" +\n+\t\t\t\"line 1:5 reportAmbiguity d=1: ambigAlts={1, 2}, input='*c'\\n\";\n+\t\tassertEquals(expecting, this.stderrDuringParse);\n+\t}\n+\n }",
      "parent_sha": "742887c9b1f7060d84411f7017699e3abdac18ac"
    }
  },
  {
    "oid": "e4f312c869138a9b3e6d1cb4393adaf36bbd4af5",
    "message": "aot compile large lexer test",
    "date": "2020-01-20T12:30:56Z",
    "url": "https://github.com/antlr/antlr4/commit/e4f312c869138a9b3e6d1cb4393adaf36bbd4af5",
    "details": {
      "sha": "75988a7c6497b2607ef74ecbaac31ff4dd4f466d",
      "filename": "runtime-testsuite/test/org/antlr/v4/test/runtime/dart/BaseDartTest.java",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/antlr/antlr4/blob/e4f312c869138a9b3e6d1cb4393adaf36bbd4af5/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fdart%2FBaseDartTest.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/e4f312c869138a9b3e6d1cb4393adaf36bbd4af5/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fdart%2FBaseDartTest.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fdart%2FBaseDartTest.java?ref=e4f312c869138a9b3e6d1cb4393adaf36bbd4af5",
      "patch": "@@ -26,6 +26,7 @@\n import org.antlr.v4.test.runtime.ErrorQueue;\n import org.antlr.v4.test.runtime.RuntimeTestSupport;\n import org.antlr.v4.test.runtime.StreamVacuum;\n+import org.antlr.v4.test.runtime.descriptors.LexerExecDescriptors;\n import org.antlr.v4.test.runtime.descriptors.PerformanceDescriptors;\n import org.antlr.v4.tool.*;\n import org.stringtemplate.v4.ST;\n@@ -47,7 +48,10 @@\n \n \n public class BaseDartTest implements RuntimeTestSupport {\n-\tprivate static final List<String> AOT_COMPILE_TESTS = Collections.singletonList(new PerformanceDescriptors.DropLoopEntryBranchInLRRule_4().input);\n+\tprivate static final List<String> AOT_COMPILE_TESTS = Arrays.asList(\n+\t\tnew PerformanceDescriptors.DropLoopEntryBranchInLRRule_4().input,\n+\t\tnew LexerExecDescriptors.LargeLexer().input\n+\t);\n \n \tpublic static final String newline = System.getProperty(\"line.separator\");\n \tpublic static final String pathSep = System.getProperty(\"path.separator\");\n@@ -383,7 +387,7 @@ public String execLexer(String grammarFileName,\n \t\tassertTrue(success);\n \t\twriteFile(tmpdir, \"input\", input);\n \t\twriteLexerTestFile(lexerName, showDFA);\n-\t\tString output = execClass(\"Test\", false);\n+\t\tString output = execClass(\"Test\", AOT_COMPILE_TESTS.contains(input));\n \t\treturn output;\n \t}\n ",
      "parent_sha": "6fb586b62c58ad9fdb8fa8a79efdba6aec261879"
    }
  },
  {
    "oid": "e366f0082088a7bf616a553041009132d2cd5d61",
    "message": "small improvement in error msg",
    "date": "2012-11-18T00:09:12Z",
    "url": "https://github.com/antlr/antlr4/commit/e366f0082088a7bf616a553041009132d2cd5d61",
    "details": {
      "sha": "2073450fab327167a176f4809bf1cd87d199b9c0",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/misc/TestRig.java",
      "status": "modified",
      "additions": 8,
      "deletions": 6,
      "changes": 14,
      "blob_url": "https://github.com/antlr/antlr4/blob/e366f0082088a7bf616a553041009132d2cd5d61/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fmisc%2FTestRig.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/e366f0082088a7bf616a553041009132d2cd5d61/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fmisc%2FTestRig.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fmisc%2FTestRig.java?ref=e366f0082088a7bf616a553041009132d2cd5d61",
      "patch": "@@ -138,18 +138,20 @@ else if ( arg.equals(\"-ps\") ) {\n //\t\tSystem.out.println(\"exec \"+grammarName+\".\"+startRuleName);\n \t\tString lexerName = grammarName+\"Lexer\";\n \t\tClassLoader cl = Thread.currentThread().getContextClassLoader();\n-\t\tClass<? extends Lexer> lexerClass;\n+\t\tClass<? extends Lexer> lexerClass = null;\n \t\ttry {\n \t\t\tlexerClass = cl.loadClass(lexerName).asSubclass(Lexer.class);\n \t\t}\n \t\tcatch (java.lang.ClassNotFoundException cnfe) {\n \t\t\t// might be pure lexer grammar; no Lexer suffix then\n \t\t\tlexerName = grammarName;\n-\t\t\tlexerClass = cl.loadClass(lexerName).asSubclass(Lexer.class);\n-\t\t}\n-\t\tif ( lexerClass==null ) {\n-\t\t\tSystem.err.println(\"Can't load \"+lexerName);\n-\t\t\treturn;\n+\t\t\ttry {\n+\t\t\t\tlexerClass = cl.loadClass(lexerName).asSubclass(Lexer.class);\n+\t\t\t}\n+\t\t\tcatch (ClassNotFoundException cnfe2) {\n+\t\t\t\tSystem.err.println(\"Can't load \"+lexerName+\" as lexer or parser\");\n+\t\t\t\treturn;\n+\t\t\t}\n \t\t}\n \n \t\tConstructor<? extends Lexer> lexerCtor = lexerClass.getConstructor(CharStream.class);",
      "parent_sha": "78c75ee5e433a01ac3226d75fa6b0addd11b2340"
    }
  },
  {
    "oid": "16ace4b429574f160ca9e515818d1d842ad39a3f",
    "message": "Fix token definitions: tokens in a tokens{...} block now have type TOKEN_REF (was ID before commit 38214f6312)",
    "date": "2012-11-19T00:03:06Z",
    "url": "https://github.com/antlr/antlr4/commit/16ace4b429574f160ca9e515818d1d842ad39a3f",
    "details": {
      "sha": "550b33a4cb65666d8dac817ee316e6ebaab8eb63",
      "filename": "tool/src/org/antlr/v4/semantics/SemanticPipeline.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/antlr/antlr4/blob/16ace4b429574f160ca9e515818d1d842ad39a3f/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fsemantics%2FSemanticPipeline.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/16ace4b429574f160ca9e515818d1d842ad39a3f/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fsemantics%2FSemanticPipeline.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fsemantics%2FSemanticPipeline.java?ref=16ace4b429574f160ca9e515818d1d842ad39a3f",
      "patch": "@@ -151,7 +151,7 @@ void identifyStartRules(SymbolCollector collector) {\n \tvoid assignLexerTokenTypes(Grammar g, List<GrammarAST> tokensDefs) {\n \t\tGrammar G = g.getOutermostGrammar(); // put in root, even if imported\n \t\tfor (GrammarAST def : tokensDefs) {\n-\t\t\tif ( def.getType()== ANTLRParser.ID ) G.defineTokenName(def.getText());\n+\t\t\tif ( def.getType()== ANTLRParser.TOKEN_REF ) G.defineTokenName(def.getText());\n \t\t}\n \n \t\t/* Define token types for nonfragment rules which do not include a 'type(...)'",
      "parent_sha": "178df68183d55d86d11b6c4c5daac7c70d00b605"
    }
  },
  {
    "oid": "bdc1911e6e384a7a72b931b293288c3f29bef840",
    "message": "Removed not used LabelType.",
    "date": "2016-12-07T19:40:27Z",
    "url": "https://github.com/antlr/antlr4/commit/bdc1911e6e384a7a72b931b293288c3f29bef840",
    "details": {
      "sha": "5674609db2d36b90c5cdd47508309a91a969950f",
      "filename": "tool/src/org/antlr/v4/tool/LabelType.java",
      "status": "modified",
      "additions": 1,
      "deletions": 6,
      "changes": 7,
      "blob_url": "https://github.com/antlr/antlr4/blob/bdc1911e6e384a7a72b931b293288c3f29bef840/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Ftool%2FLabelType.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/bdc1911e6e384a7a72b931b293288c3f29bef840/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Ftool%2FLabelType.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Ftool%2FLabelType.java?ref=bdc1911e6e384a7a72b931b293288c3f29bef840",
      "patch": "@@ -36,10 +36,5 @@ public enum LabelType {\n     TOKEN_LABEL,\n     RULE_LIST_LABEL,\n     TOKEN_LIST_LABEL,\n-    LEXER_STRING_LABEL,         // used in lexer for x='a'\n-    SUBRULE_LABEL,              // x=(...)\n-    SUBRULE_LIST_LABEL,         // x+=(...)\n-    WILDCARD_TREE_LABEL,        // Used in tree grammar x=.\n-    WILDCARD_TREE_LIST_LABEL    // Used in tree grammar x+=.\n-    ;\n+    LEXER_STRING_LABEL;         // used in lexer for x='a'\n }",
      "parent_sha": "4e4b902c204697755a049f795519dae360b61d72"
    }
  },
  {
    "oid": "d181b230dc1ce38dd759eba558fdec8108b270bb",
    "message": "Specify generic type parameter",
    "date": "2012-02-09T00:55:57Z",
    "url": "https://github.com/antlr/antlr4/commit/d181b230dc1ce38dd759eba558fdec8108b270bb",
    "details": {
      "sha": "6b9cc102c3f138555969d5aaa664c1e35f703181",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/NoViableAltException.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/antlr/antlr4/blob/d181b230dc1ce38dd759eba558fdec8108b270bb/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FNoViableAltException.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/d181b230dc1ce38dd759eba558fdec8108b270bb/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FNoViableAltException.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FNoViableAltException.java?ref=d181b230dc1ce38dd759eba558fdec8108b270bb",
      "patch": "@@ -57,7 +57,7 @@ public <Symbol> NoViableAltException(Parser recognizer,\n \t\t\t\t\t\t\t\t\t\t Token startToken,\n \t\t\t\t\t\t\t\t\t\t Token offendingToken,\n \t\t\t\t\t\t\t\t\t\t ATNConfigSet deadEndConfigs,\n-\t\t\t\t\t\t\t\t\t\t ParserRuleContext ctx)\n+\t\t\t\t\t\t\t\t\t\t ParserRuleContext<?> ctx)\n \t{\n \t\tsuper(recognizer, input, ctx);\n \t\tthis.deadEndConfigs = deadEndConfigs;",
      "parent_sha": "21a855e94e28d6794d9e800a18bb5047cf1ee4bd"
    }
  },
  {
    "oid": "5f9e2f6e05ec145e4aec1a7d22aac8b829080626",
    "message": "tweak\n\n[git-p4: depot-paths = \"//depot/code/antlr4/main/\": change = 9105]",
    "date": "2011-10-04T01:33:07Z",
    "url": "https://github.com/antlr/antlr4/commit/5f9e2f6e05ec145e4aec1a7d22aac8b829080626",
    "details": {
      "sha": "a805ecb73a0efa0a213d8e8ce2cf76f06799020b",
      "filename": "tool/test/org/antlr/v4/test/TestATNConstruction.java",
      "status": "modified",
      "additions": 9,
      "deletions": 5,
      "changes": 14,
      "blob_url": "https://github.com/antlr/antlr4/blob/5f9e2f6e05ec145e4aec1a7d22aac8b829080626/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestATNConstruction.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/5f9e2f6e05ec145e4aec1a7d22aac8b829080626/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestATNConstruction.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestATNConstruction.java?ref=5f9e2f6e05ec145e4aec1a7d22aac8b829080626",
      "patch": "@@ -1,8 +1,12 @@\n package org.antlr.v4.test;\n \n-import org.antlr.v4.automata.*;\n-import org.antlr.v4.runtime.atn.*;\n-import org.antlr.v4.tool.*;\n+import org.antlr.v4.automata.ATNPrinter;\n+import org.antlr.v4.automata.LexerATNFactory;\n+import org.antlr.v4.automata.ParserATNFactory;\n+import org.antlr.v4.runtime.atn.ATN;\n+import org.antlr.v4.runtime.atn.ATNState;\n+import org.antlr.v4.tool.Grammar;\n+import org.antlr.v4.tool.LexerGrammar;\n import org.junit.Test;\n \n public class TestATNConstruction extends BaseTest {\n@@ -258,7 +262,7 @@ public void testA() throws Exception {\n \t\t\t\"RuleStart_a_0->BlockStart_4\\n\" +\n \t\t\t\"BlockStart_4->s2\\n\" +\n \t\t\t\"BlockStart_4->BlockEnd_5\\n\" +\n-\t\t\t\"s2-{A..B}->s3\\n\" +\n+\t\t\t\"s2-{A, B}->s3\\n\" +\n \t\t\t\"BlockEnd_5->RuleStop_a_1\\n\" +\n \t\t\t\"s3->BlockEnd_5\\n\" +\n \t\t\t\"RuleStop_a_1-EOF->s6\\n\";\n@@ -271,7 +275,7 @@ public void testA() throws Exception {\n \t\t\t\"a : (A | B) C;\");\n \t\tString expecting =\n \t\t\t\"RuleStart_a_0->s2\\n\" +\n-\t\t\t\"s2-{A..B}->s3\\n\" +\n+\t\t\t\"s2-{A, B}->s3\\n\" +\n \t\t\t\"s3->s4\\n\" +\n \t\t\t\"s4-C->s5\\n\" +\n \t\t\t\"s5->RuleStop_a_1\\n\" +",
      "parent_sha": "2707837bc84e7003886dd24483f058b649dc571a"
    }
  },
  {
    "oid": "702b91fab746b2001ef5c8d9762ae817e8c80812",
    "message": "Ignore TestPerformance by default since it fails without special configuration",
    "date": "2012-02-09T19:30:44Z",
    "url": "https://github.com/antlr/antlr4/commit/702b91fab746b2001ef5c8d9762ae817e8c80812",
    "details": {
      "sha": "f2d26daf87ef8cb35487cf4cbdbb4cae0c9b3e60",
      "filename": "tool/test/org/antlr/v4/test/TestPerformance.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/antlr/antlr4/blob/702b91fab746b2001ef5c8d9762ae817e8c80812/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestPerformance.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/702b91fab746b2001ef5c8d9762ae817e8c80812/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestPerformance.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestPerformance.java?ref=702b91fab746b2001ef5c8d9762ae817e8c80812",
      "patch": "@@ -6,6 +6,7 @@\n import org.antlr.v4.runtime.tree.ParseTreeListener;\n import org.antlr.v4.runtime.tree.ParseTreeWalker;\n import org.junit.Assert;\n+import org.junit.Ignore;\n import org.junit.Test;\n \n import java.io.*;\n@@ -75,7 +76,7 @@ public class TestPerformance extends BaseTest {\n     private int tokenCount;\n \n     @Test\n-//    @Ignore\n+    @Ignore\n     public void compileJdk() throws IOException {\n         compileParser(USE_LR_GRAMMAR);\n         JavaParserFactory factory = getParserFactory();",
      "parent_sha": "7fb73a38493492a27f4ba8c5924c01e48a6c6d1e"
    }
  },
  {
    "oid": "a60df9d28ed2ee28aa39447ad8ac4894c2b5480b",
    "message": "Updated documentation of Parser's parse listener related methods; event trigger methods are protected instead of public",
    "date": "2013-03-26T23:53:03Z",
    "url": "https://github.com/antlr/antlr4/commit/a60df9d28ed2ee28aa39447ad8ac4894c2b5480b",
    "details": {
      "sha": "25cdbb2b77457d0a9323fb60a5947d71d938b53f",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/Parser.java",
      "status": "modified",
      "additions": 72,
      "deletions": 27,
      "changes": 99,
      "blob_url": "https://github.com/antlr/antlr4/blob/a60df9d28ed2ee28aa39447ad8ac4894c2b5480b/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FParser.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/a60df9d28ed2ee28aa39447ad8ac4894c2b5480b/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FParser.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FParser.java?ref=a60df9d28ed2ee28aa39447ad8ac4894c2b5480b",
      "patch": "@@ -44,6 +44,7 @@\n import org.antlr.v4.runtime.tree.TerminalNode;\n \n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n \n /** This is all the parsing support code essentially; most of it is error recovery stuff. */\n@@ -282,31 +283,70 @@ public void setTrimParseTree(boolean trimParseTrees) {\n \t * using the default {@link Parser.TrimToSizeListener} during the parse process.\n \t */\n \tpublic boolean getTrimParseTree() {\n-\t\tif (_parseListeners == null) return false;\n-\t\treturn _parseListeners.contains(TrimToSizeListener.INSTANCE);\n+\t\treturn getParseListeners().contains(TrimToSizeListener.INSTANCE);\n \t}\n \n-    public List<ParseTreeListener> getParseListeners() {\n-        return _parseListeners;\n-    }\n+\t@NotNull\n+\tpublic List<ParseTreeListener> getParseListeners() {\n+\t\tList<ParseTreeListener> listeners = _parseListeners;\n+\t\tif (listeners == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\n+\t\treturn listeners;\n+\t}\n \n-\t/** Provide a listener that gets notified about token matches,\n-\t *  and rule entry/exit events DURING the parse. It's a little bit\n-\t *  weird for left recursive rule entry events but it's\n-\t *  deterministic.\n+\t/**\n+\t * Registers {@code listener} to receive events during the parsing process.\n+\t * <p/>\n+\t * To support output-preserving grammar transformations (including but not\n+\t * limited to left-recursion removal, automated left-factoring, and\n+\t * optimized code generation), calls to listener methods during the parse\n+\t * may differ substantially from calls made by\n+\t * {@link ParseTreeWalker#DEFAULT} used after the parse is complete. In\n+\t * particular, rule entry and exit events may occur in a different order\n+\t * during the parse than after the parser. In addition, calls to certain\n+\t * rule entry methods may be omitted.\n+\t * <p/>\n+\t * With the following specific exceptions, calls to listener events are\n+\t * <em>deterministic</em>, i.e. for identical input the calls to listener\n+\t * methods will be the same.\n \t *\n-\t *  THIS IS ONLY FOR ADVANCED USERS. Please give your\n-\t *  ParseTreeListener to a ParseTreeWalker instead of giving it to\n-\t *  the parser!!!!\n+\t * <ul>\n+\t * <li>Alterations to the grammar used to generate code may change the\n+\t * behavior of the listener calls.</li>\n+\t * <li>Alterations to the command line options passed to ANTLR 4 when\n+\t * generating the parser may change the behavior of the listener calls.</li>\n+\t * <li>Changing the version of the ANTLR Tool used to generate the parser\n+\t * may change the behavior of the listener calls.</li>\n+\t * </ul>\n+\t *\n+\t * @param listener the listener to add\n+\t *\n+\t * @throws NullPointerException if {@code} listener is {@code null}\n \t */\n-    public void addParseListener(ParseTreeListener listener) {\n-\t\tif ( listener==null ) return;\n-\t\tif ( _parseListeners==null ) {\n+\tpublic void addParseListener(@NotNull ParseTreeListener listener) {\n+\t\tif (listener == null) {\n+\t\t\tthrow new NullPointerException(\"listener\");\n+\t\t}\n+\n+\t\tif (_parseListeners == null) {\n \t\t\t_parseListeners = new ArrayList<ParseTreeListener>();\n \t\t}\n-        this._parseListeners.add(listener);\n-    }\n \n+\t\tthis._parseListeners.add(listener);\n+\t}\n+\n+\t/**\n+\t * Remove {@code listener} from the list of parse listeners.\n+\t * <p/>\n+\t * If {@code listener} is {@code null} or has not been added as a parse\n+\t * listener, this method does nothing.\n+\t *\n+\t * @see #addParseListener\n+\t *\n+\t * @param listener the listener to remove\n+\t */\n \tpublic void removeParseListener(ParseTreeListener listener) {\n \t\tif (_parseListeners != null) {\n \t\t\tif (_parseListeners.remove(listener)) {\n@@ -317,28 +357,33 @@ public void removeParseListener(ParseTreeListener listener) {\n \t\t}\n \t}\n \n+\t/**\n+\t * Remove all parse listeners.\n+\t *\n+\t * @see #addParseListener\n+\t */\n \tpublic void removeParseListeners() {\n \t\t_parseListeners = null;\n \t}\n \n-\t/** Notify any parse listeners (implemented as ParseTreeListener's)\n-\t *  of an enter rule event. This is not involved with\n-\t *  parse tree walking in any way; it's just reusing the\n-\t *  ParseTreeListener interface. This is not for the average user.\n+\t/**\n+\t * Notify any parse listeners of an enter rule event.\n+\t *\n+\t * @see #addParseListener\n \t */\n-\tpublic void triggerEnterRuleEvent() {\n+\tprotected void triggerEnterRuleEvent() {\n \t\tfor (ParseTreeListener listener : _parseListeners) {\n \t\t\tlistener.enterEveryRule(_ctx);\n \t\t\t_ctx.enterRule(listener);\n \t\t}\n \t}\n \n-\t/** Notify any parse listeners (implemented as ParseTreeListener's)\n-\t *  of an exit rule event. This is not involved with\n-\t *  parse tree walking in any way; it's just reusing the\n-\t *  ParseTreeListener interface. This is not for the average user.\n+\t/**\n+\t * Notify any parse listeners of an exit rule event.\n+\t *\n+\t * @see #addParseListener\n \t */\n-\tpublic void triggerExitRuleEvent() {\n+\tprotected void triggerExitRuleEvent() {\n \t\t// reverse order walk of listeners\n \t\tfor (int i = _parseListeners.size()-1; i >= 0; i--) {\n \t\t\tParseTreeListener listener = _parseListeners.get(i);",
      "parent_sha": "3acc78cf871d7709f51d0cbb8cd331ca6e3854d1"
    }
  },
  {
    "oid": "07a0a809925ee1bb2005152ca3674cb834f8edca",
    "message": "Yes another formatting fixes.",
    "date": "2017-11-25T13:29:03Z",
    "url": "https://github.com/antlr/antlr4/commit/07a0a809925ee1bb2005152ca3674cb834f8edca",
    "details": {
      "sha": "abbf22de3e2c3122bd57dee11c6abe92ed1ef263",
      "filename": "tool/src/org/antlr/v4/semantics/SymbolChecks.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/antlr/antlr4/blob/07a0a809925ee1bb2005152ca3674cb834f8edca/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fsemantics%2FSymbolChecks.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/07a0a809925ee1bb2005152ca3674cb834f8edca/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fsemantics%2FSymbolChecks.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fsemantics%2FSymbolChecks.java?ref=07a0a809925ee1bb2005152ca3674cb834f8edca",
      "patch": "@@ -442,7 +442,7 @@ private void checkForOverlap(Grammar g, Rule rule1, Rule rule2, List<String> fir\n \n \t// CAN ONLY CALL THE TWO NEXT METHODS AFTER GRAMMAR HAS RULE DEFS (see semanticpipeline)\n \tpublic void checkRuleArgs(Grammar g, List<GrammarAST> rulerefs) {\n-\t\tif ( rulerefs==null) return;\n+\t\tif ( rulerefs==null ) return;\n \t\tfor (GrammarAST ref : rulerefs) {\n \t\t\tString ruleName = ref.getText();\n \t\t\tRule r = g.getRule(ruleName);\n@@ -452,7 +452,7 @@ public void checkRuleArgs(Grammar g, List<GrammarAST> rulerefs) {\n \t\t\t\t\t\tg.fileName, ref.token, ruleName);\n \n \t\t\t}\n-\t\t\telse if ( arg == null && (r!=null && r.args!=null) ) {\n+\t\t\telse if ( arg==null && (r!=null && r.args!=null) ) {\n \t\t\t\terrMgr.grammarError(ErrorType.MISSING_RULE_ARGS,\n \t\t\t\t\t\tg.fileName, ref.token, ruleName);\n \t\t\t}",
      "parent_sha": "763eccc2a4f7c346700f5c520d5f4136769d1077"
    }
  },
  {
    "oid": "64203312acdf3ef7ed12e45ed955d1a237bc5d88",
    "message": "Improved SemanticContext.hashCode(), add @Override annotations",
    "date": "2012-02-09T00:54:40Z",
    "url": "https://github.com/antlr/antlr4/commit/64203312acdf3ef7ed12e45ed955d1a237bc5d88",
    "details": {
      "sha": "5050115795d5cdd088e2ae229569daf7724af664",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/atn/SemanticContext.java",
      "status": "modified",
      "additions": 10,
      "deletions": 1,
      "changes": 11,
      "blob_url": "https://github.com/antlr/antlr4/blob/64203312acdf3ef7ed12e45ed955d1a237bc5d88/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FSemanticContext.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/64203312acdf3ef7ed12e45ed955d1a237bc5d88/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FSemanticContext.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FSemanticContext.java?ref=64203312acdf3ef7ed12e45ed955d1a237bc5d88",
      "patch": "@@ -83,14 +83,19 @@ public Predicate(int ruleIndex, int predIndex, boolean isCtxDependent) {\n             this.isCtxDependent = isCtxDependent;\n         }\n \n+        @Override\n         public boolean eval(Recognizer<?,?> parser, RuleContext outerContext) {\n             RuleContext localctx = isCtxDependent ? outerContext : null;\n             return parser.sempred(localctx, ruleIndex, predIndex);\n         }\n \n \t\t@Override\n \t\tpublic int hashCode() {\n-\t\t\treturn ruleIndex + predIndex;\n+\t\t\tint hashCode = 1;\n+\t\t\thashCode = 31 * hashCode + ruleIndex;\n+\t\t\thashCode = 31 * hashCode + predIndex;\n+\t\t\thashCode = 31 * hashCode + (isCtxDependent ? 1 : 0);\n+\t\t\treturn hashCode;\n \t\t}\n \n \t\t@Override\n@@ -103,6 +108,7 @@ public boolean equals(Object obj) {\n \t\t\t\t   this.isCtxDependent == p.isCtxDependent;\n \t\t}\n \n+\t\t@Override\n \t\tpublic String toString() {\n             return \"{\"+ruleIndex+\":\"+predIndex+\"}?\";\n         }\n@@ -131,13 +137,15 @@ public int hashCode() {\n \t\t\treturn opnds.hashCode();\n \t\t}\n \n+\t\t@Override\n \t\tpublic boolean eval(Recognizer<?,?> parser, RuleContext outerContext) {\n \t\t\tfor (SemanticContext opnd : opnds) {\n \t\t\t\tif ( !opnd.eval(parser, outerContext) ) return false;\n \t\t\t}\n \t\t\treturn true;\n         }\n \n+\t\t@Override\n \t\tpublic String toString() {\n \t\t\treturn Utils.join(opnds.iterator(), \"&&\");\n         }\n@@ -166,6 +174,7 @@ public int hashCode() {\n \t\t\treturn opnds.hashCode() + 1; // differ from AND slightly\n \t\t}\n \n+\t\t@Override\n         public boolean eval(Recognizer<?,?> parser, RuleContext outerContext) {\n \t\t\tfor (SemanticContext opnd : opnds) {\n \t\t\t\tif ( opnd.eval(parser, outerContext) ) return true;",
      "parent_sha": "773e9e1c7eb74d52369abf350761d8653cd6ff47"
    }
  },
  {
    "oid": "f2dc9f476b01f1ae0964f9bb6deb2153cc063e37",
    "message": "runtime-testsuite/Go: timeout tests, honour GOROOT",
    "date": "2016-05-27T20:56:56Z",
    "url": "https://github.com/antlr/antlr4/commit/f2dc9f476b01f1ae0964f9bb6deb2153cc063e37",
    "details": {
      "sha": "e0b0aa9662f31b6eee930ae87e5bfb1cbdc45829",
      "filename": "runtime-testsuite/test/org/antlr/v4/test/runtime/go/BaseTest.java",
      "status": "modified",
      "additions": 14,
      "deletions": 5,
      "changes": 19,
      "blob_url": "https://github.com/antlr/antlr4/blob/f2dc9f476b01f1ae0964f9bb6deb2153cc063e37/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fgo%2FBaseTest.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/f2dc9f476b01f1ae0964f9bb6deb2153cc063e37/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fgo%2FBaseTest.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fgo%2FBaseTest.java?ref=f2dc9f476b01f1ae0964f9bb6deb2153cc063e37",
      "patch": "@@ -66,6 +66,7 @@\n import org.junit.Before;\n import org.junit.rules.TestRule;\n import org.junit.rules.TestWatcher;\n+import org.junit.rules.Timeout;\n import org.junit.runner.Description;\n import org.stringtemplate.v4.ST;\n import org.stringtemplate.v4.STGroup;\n@@ -125,6 +126,9 @@ protected void succeeded(Description description) {\n \n \t};\n \n+\t@org.junit.Rule\n+\tpublic final Timeout eachTimeout = new Timeout(60000);\n+\n \t@Before\n \tpublic void setUp() throws Exception {\n \t\t// new output dir for each test\n@@ -424,15 +428,21 @@ public String execModule(String fileName) {\n \tprivate String locateTool(String tool) {\n \t\tArrayList<String> paths = new ArrayList<String>(); // default cap is about right\n \n-\t\tString pathEnv = System.getenv(\"PATH\");\n-\t\tif (pathEnv != null) {\n-\t\t\tpaths.addAll(Arrays.asList(pathEnv.split(pathSep)));\n-\t\t}\n+\t\t// GOROOT should have priority if set\n \t\tString goroot = System.getenv(\"GOROOT\");\n \t\tif (goroot != null) {\n \t\t\tpaths.add(goroot + File.separatorChar + \"bin\");\n \t\t}\n \n+\t\tString pathEnv = System.getenv(\"PATH\");\n+\t\tif (pathEnv != null) {\n+\t\t\tpaths.addAll(Arrays.asList(pathEnv.split(pathSep)));\n+\t\t}\n+\n+\t\t// OS specific default locations of binary dist as last resort\n+\t\tpaths.add(\"/usr/local/go/bin\");\n+\t\tpaths.add(\"c:\\\\Go\\\\bin\");\n+\n \t\tfor (String path : paths) {\n \t\t\tFile candidate = new File(path + File.separatorChar + tool);\n \t\t\tif (candidate.exists()) {\n@@ -443,7 +453,6 @@ private String locateTool(String tool) {\n \t}\n \n \tprivate String locateGo() {\n-\t\t// typically /usr/local/go/bin\n \t\tString propName = \"antlr-go\";\n \t\tString prop = System.getProperty(propName);\n \t\tif (prop == null || prop.length() == 0) {",
      "parent_sha": "439a3b78689d779da534e6d27f7427f5dfa71672"
    }
  },
  {
    "oid": "9236477438c17b61a64b616b373d76538eb5e99f",
    "message": "Fix code in TestPerformance that clears the DFA",
    "date": "2013-04-15T16:12:16Z",
    "url": "https://github.com/antlr/antlr4/commit/9236477438c17b61a64b616b373d76538eb5e99f",
    "details": {
      "sha": "7ed5ea2e2aa9d83d8eb648ceb5be9d5ebe90193d",
      "filename": "tool/test/org/antlr/v4/test/TestPerformance.java",
      "status": "modified",
      "additions": 16,
      "deletions": 4,
      "changes": 20,
      "blob_url": "https://github.com/antlr/antlr4/blob/9236477438c17b61a64b616b373d76538eb5e99f/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestPerformance.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/9236477438c17b61a64b616b373d76538eb5e99f/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestPerformance.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestPerformance.java?ref=9236477438c17b61a64b616b373d76538eb5e99f",
      "patch": "@@ -282,11 +282,17 @@ public void compileJdk() throws IOException, InterruptedException {\n             currentPass = i + 1;\n             if (CLEAR_DFA) {\n \t\t\t\tif (sharedLexers.length > 0) {\n-\t\t\t\t\tArrays.fill(sharedLexers[0].getInterpreter().decisionToDFA, null);\n+\t\t\t\t\tATN atn = sharedLexers[0].getATN();\n+\t\t\t\t\tfor (int j = 0; j < sharedLexers[0].getInterpreter().decisionToDFA.length; j++) {\n+\t\t\t\t\t\tsharedLexers[0].getInterpreter().decisionToDFA[j] = new DFA(atn.getDecisionState(j), j);\n+\t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (sharedParsers.length > 0) {\n-\t\t\t\t\tArrays.fill(sharedParsers[0].getInterpreter().decisionToDFA, null);\n+\t\t\t\t\tATN atn = sharedParsers[0].getATN();\n+\t\t\t\t\tfor (int j = 0; j < sharedParsers[0].getInterpreter().decisionToDFA.length; j++) {\n+\t\t\t\t\t\tsharedParsers[0].getInterpreter().decisionToDFA[j] = new DFA(atn.getDecisionState(j), j);\n+\t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tArrays.fill(sharedLexers, null);\n@@ -685,7 +691,10 @@ public int parseFile(CharStream input, int thread) {\n                         }\n \n \t\t\t\t\t\tif (!REUSE_LEXER_DFA) {\n-\t\t\t\t\t\t\tArrays.fill(lexer.getInterpreter().decisionToDFA, null);\n+\t\t\t\t\t\t\tATN atn = lexer.getATN();\n+\t\t\t\t\t\t\tfor (int i = 0; i < lexer.getInterpreter().decisionToDFA.length; i++) {\n+\t\t\t\t\t\t\t\tlexer.getInterpreter().decisionToDFA[i] = new DFA(atn.getDecisionState(i), i);\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \n                         CommonTokenStream tokens = new CommonTokenStream(lexer);\n@@ -723,7 +732,10 @@ public int parseFile(CharStream input, int thread) {\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (!REUSE_PARSER_DFA) {\n-\t\t\t\t\t\t\tArrays.fill(parser.getInterpreter().decisionToDFA, null);\n+\t\t\t\t\t\t\tATN atn = parser.getATN();\n+\t\t\t\t\t\t\tfor (int i = 0; i < parser.getInterpreter().decisionToDFA.length; i++) {\n+\t\t\t\t\t\t\t\tparser.getInterpreter().decisionToDFA[i] = new DFA(atn.getDecisionState(i), i);\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tparser.getInterpreter().setPredictionMode(TWO_STAGE_PARSING ? PredictionMode.SLL : PREDICTION_MODE);",
      "parent_sha": "db85cbc257def9f1b5d6dc3dfbd5187d2902cfef"
    }
  },
  {
    "oid": "8962fb666a122ecd6e9a285659419b1e37a30477",
    "message": "Suppressed dart execParser debug message.",
    "date": "2020-04-28T05:27:39Z",
    "url": "https://github.com/antlr/antlr4/commit/8962fb666a122ecd6e9a285659419b1e37a30477",
    "details": {
      "sha": "65746b22abf81df93e958bb77f3e8018bcd36904",
      "filename": "runtime-testsuite/test/org/antlr/v4/test/runtime/dart/BaseDartTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/antlr/antlr4/blob/8962fb666a122ecd6e9a285659419b1e37a30477/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fdart%2FBaseDartTest.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/8962fb666a122ecd6e9a285659419b1e37a30477/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fdart%2FBaseDartTest.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fdart%2FBaseDartTest.java?ref=8962fb666a122ecd6e9a285659419b1e37a30477",
      "patch": "@@ -610,8 +610,8 @@ public String execClass(String className, boolean compile) {\n \t\t\t\t\tclassName + \".dart\", new File(tmpdir, \"input\").getAbsolutePath()\n \t\t\t\t};\n \t\t\t}\n-\t\t\tString cmdLine = Utils.join(args, \" \");\n-\t\t\tSystem.err.println(\"execParser: \" + cmdLine);\n+\t\t\t//String cmdLine = Utils.join(args, \" \");\n+\t\t\t//System.err.println(\"execParser: \" + cmdLine);\n \t\t\tProcess process =\n \t\t\t\tRuntime.getRuntime().exec(args, null, new File(tmpdir));\n \t\t\tStreamVacuum stdoutVacuum = new StreamVacuum(process.getInputStream());",
      "parent_sha": "187e5bb84941858e150bc244d62752c316b7272c"
    }
  },
  {
    "oid": "e9dd953cf1bb4bb96eed3294c9734961a8c38e0e",
    "message": "Fixed another occurrence of NewFileInputStream.",
    "date": "2017-04-30T02:55:32Z",
    "url": "https://github.com/antlr/antlr4/commit/e9dd953cf1bb4bb96eed3294c9734961a8c38e0e",
    "details": {
      "sha": "48791461fa9db15adc7fbfd11b9b3d4fa8408730",
      "filename": "runtime-testsuite/test/org/antlr/v4/test/runtime/go/BaseGoTest.java",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/antlr/antlr4/blob/e9dd953cf1bb4bb96eed3294c9734961a8c38e0e/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fgo%2FBaseGoTest.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/e9dd953cf1bb4bb96eed3294c9734961a8c38e0e/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fgo%2FBaseGoTest.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fgo%2FBaseGoTest.java?ref=e9dd953cf1bb4bb96eed3294c9734961a8c38e0e",
      "patch": "@@ -674,6 +674,7 @@ protected void writeParserTestFile(String parserName, String lexerName,\n \t\t\t\t\"import (\\n\"\n \t\t\t\t+\"\t\\\"github.com/antlr/antlr4/runtime/Go/antlr\\\"\\n\"\n \t\t\t\t+\"\t\\\"./parser\\\"\\n\"\n+\t\t\t\t+\"\t\\\"fmt\\\"\\n\"\n \t\t\t\t+\"\t\\\"os\\\"\\n\"\n \t\t\t\t+\")\\n\"\n \t\t\t\t+ \"\\n\"\n@@ -738,7 +739,11 @@ protected void writeLexerTestFile(String lexerName, boolean showDFA) {\n \t\t\t\t+ \")\\n\"\n \t\t\t\t+ \"\\n\"\n \t\t\t\t+ \"func main() {\\n\"\n-\t\t\t\t+ \"\tinput := antlr.NewFileStream(os.Args[1])\\n\"\n+\t\t\t\t+ \"\tinput, err := antlr.NewFileStream(os.Args[1])\\n\"\n+\t\t\t\t+ \"     if err != nil {\\n\"\n+\t\t\t\t+ \"     \tfmt.Printf(\\\"Failed to find file: %v\\\", err)\\n\"\n+\t\t\t\t+ \"     \treturn\\n\"\n+\t\t\t\t+ \"     }\\n\"\n \t\t\t\t+ \"\tlexer := parser.New<lexerName>(input)\\n\"\n \t\t\t\t+ \"\tstream := antlr.NewCommonTokenStream(lexer,0)\\n\"\n \t\t\t\t+ \"\tstream.Fill()\\n\"",
      "parent_sha": "fc8b14b1dc7f36a49242b935deaeba0b5ee334e3"
    }
  },
  {
    "oid": "fedb7c105b6b2749176ec25944e3673307d05ee0",
    "message": "tweaks",
    "date": "2012-07-31T05:24:12Z",
    "url": "https://github.com/antlr/antlr4/commit/fedb7c105b6b2749176ec25944e3673307d05ee0",
    "details": {
      "sha": "a8dfe1a84b0be7aae97436c382112091611337dc",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java",
      "status": "modified",
      "additions": 16,
      "deletions": 11,
      "changes": 27,
      "blob_url": "https://github.com/antlr/antlr4/blob/fedb7c105b6b2749176ec25944e3673307d05ee0/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/fedb7c105b6b2749176ec25944e3673307d05ee0/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java?ref=fedb7c105b6b2749176ec25944e3673307d05ee0",
      "patch": "@@ -521,7 +521,7 @@ public int execATN(@NotNull DFA dfa, @NotNull DFAState s0,\n \t\t\t\tD2.prediction = predictedAlt;\n \t\t\t}\n \t\t\telse {\n-\t\t\t\tD.configs.conflictingAlts = getConflictingAlts(reach, false);\n+\t\t\t\tD.configs.conflictingAlts = getConflictingAlts(reach);\n \t\t\t\tD2.configs.conflictingAlts = D.configs.conflictingAlts;\n \t\t\t\tif ( D.configs.conflictingAlts!=null ) {\n \t\t\t\t\tif ( greedy ) {\n@@ -537,7 +537,10 @@ public int execATN(@NotNull DFA dfa, @NotNull DFAState s0,\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tD.isAcceptState = true;\n \t\t\t\t\t\t\tD2.isAcceptState = true;\n-\t\t\t\t\t\t\tpredictedAlt = resolveToMinAlt(D, D.configs.conflictingAlts);\n+\t\t\t\t\t\t\tD.prediction = D.configs.conflictingAlts.getMinElement();\n+\t\t\t\t\t\t\tD2.prediction = D2.configs.conflictingAlts.getMinElement();\n+\t\t\t\t\t\t\tif ( debug ) System.out.println(\"RESOLVED TO \"+D.prediction+\" for \"+D);\n+\t\t\t\t\t\t\tpredictedAlt = D.prediction;\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse {\n \t\t\t\t\t\t\tif ( debug ) System.out.println(\"RETRY with outerContext=\"+outerContext);\n@@ -611,6 +614,8 @@ public int execATN(@NotNull DFA dfa, @NotNull DFAState s0,\n \t\t\t\tint nalts = decState.getNumberOfTransitions();\n \t\t\t\tList<DFAState.PredPrediction> predPredictions =\n \t\t\t\t\tpredicateDFAState(D, D.configs, outerContext, nalts);\n+\t\t\t\t// TODO: get rid of side-effects? sets predicted 2x\n+\t\t\t\tpredicateDFAState(D2, D2.configs, outerContext, nalts); // alters D\n \t\t\t\tif ( predPredictions!=null ) {\n \t\t\t\t\tint stopIndex = input.index();\n \t\t\t\t\tinput.seek(startIndex);\n@@ -685,7 +690,7 @@ public ATNConfigSet execATNWithFullContext(DFA dfa,\n \t\t\t}\n \t\t\treach.uniqueAlt = getUniqueAlt(reach);\n \t\t\tif ( reach.uniqueAlt!=ATN.INVALID_ALT_NUMBER ) break;\n-\t\t\treach.conflictingAlts = getConflictingAlts(reach, fullCtx);\n+\t\t\treach.conflictingAlts = getConflictingAlts(reach);\n \t\t\tif ( reach.conflictingAlts!=null ) break;\n \t\t\tprevious = reach;\n \t\t\tinput.consume();\n@@ -1260,7 +1265,7 @@ public ATNConfig ruleTransition(@NotNull ATNConfig config, @NotNull Transition t\n \t TODO: now we know contexts are merged, can we optimize?  Use big int -> config array?\n \t */\n \t@Nullable\n-\tpublic IntervalSet getConflictingAlts(@NotNull ATNConfigSet configs, boolean fullCtx) {\n+\tpublic IntervalSet getConflictingAlts(@NotNull ATNConfigSet configs) {\n \t\tif ( debug ) System.out.println(\"### check ambiguous  \"+configs);\n //\t\tSystem.out.println(\"getConflictingAlts; set size=\"+configs.size());\n \t\t// First get a list of configurations for each state.\n@@ -1367,13 +1372,13 @@ protected IntervalSet getConflictingAltsFromConfigSet(ATNConfigSet configs) {\n \t\treturn conflictingAlts;\n \t}\n \n-\tprotected int resolveToMinAlt(@NotNull DFAState D, IntervalSet conflictingAlts) {\n-\t\t// kill dead alts so we don't chase them ever\n-//\t\tkillAlts(conflictingAlts, D.configset);\n-\t\tD.prediction = conflictingAlts.getMinElement();\n-\t\tif ( debug ) System.out.println(\"RESOLVED TO \"+D.prediction+\" for \"+D);\n-\t\treturn D.prediction;\n-\t}\n+//\tprotected int resolveToMinAlt(@NotNull DFAState D, IntervalSet conflictingAlts) {\n+//\t\t// kill dead alts so we don't chase them ever\n+////\t\tkillAlts(conflictingAlts, D.configset);\n+//\t\tD.prediction = conflictingAlts.getMinElement();\n+//\t\tif ( debug ) System.out.println(\"RESOLVED TO \"+D.prediction+\" for \"+D);\n+//\t\treturn D.prediction;\n+//\t}\n \n \tprotected int resolveNongreedyToExitBranch(@NotNull ATNConfigSet reach,\n \t\t\t\t\t\t\t\t\t\t\t   @NotNull IntervalSet conflictingAlts)",
      "parent_sha": "85ea296632b238a16681b754b8084ed438f61b4e"
    }
  },
  {
    "oid": "dc3279cf23c54f207cccd749a9b92ccad6b4f69c",
    "message": "assertNotEquals wasn't found (I upgraded to junit 4.10 too). weird.",
    "date": "2012-12-21T00:33:26Z",
    "url": "https://github.com/antlr/antlr4/commit/dc3279cf23c54f207cccd749a9b92ccad6b4f69c",
    "details": {
      "sha": "a0aca9a81be63e67118a2990d1dea1acd1948bff",
      "filename": "tool/test/org/antlr/v4/test/TestIntervalSet.java",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/antlr/antlr4/blob/dc3279cf23c54f207cccd749a9b92ccad6b4f69c/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestIntervalSet.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/dc3279cf23c54f207cccd749a9b92ccad6b4f69c/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestIntervalSet.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestIntervalSet.java?ref=dc3279cf23c54f207cccd749a9b92ccad6b4f69c",
      "patch": "@@ -34,7 +34,9 @@\n import org.antlr.v4.runtime.misc.IntervalSet;\n import org.junit.Test;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n \n public class TestIntervalSet extends BaseTest {\n \n@@ -223,7 +225,7 @@ public void testSingleElement() throws Exception {\n         assertEquals(s, s2);\n \n         IntervalSet s3 = IntervalSet.of(15,55);\n-        assertNotEquals(s, s3);\n+        assertFalse(s.equals(s3));\n     }\n \n     @Test public void testEquals() throws Exception {\n@@ -237,7 +239,7 @@ public void testSingleElement() throws Exception {\n \n         IntervalSet s3 = IntervalSet.of(10,20);\n         s3.add(2);\n-        assertNotEquals(s, s3);\n+\t\tassertFalse(s.equals(s3));\n     }\n \n     @Test public void testSingleElementMinusDisjointSet() throws Exception {",
      "parent_sha": "e6d1c7f257d560929243040e28e93d5bccb5587d"
    }
  },
  {
    "oid": "cb16e369fe27b58d04c64e2b6c6c9c96a0f843dc",
    "message": "Misprint in comment.",
    "date": "2016-12-04T01:05:55Z",
    "url": "https://github.com/antlr/antlr4/commit/cb16e369fe27b58d04c64e2b6c6c9c96a0f843dc",
    "details": {
      "sha": "6479005a80c4785f87ffd4caec3de324dc1591a3",
      "filename": "tool/src/org/antlr/v4/tool/ErrorType.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/antlr/antlr4/blob/cb16e369fe27b58d04c64e2b6c6c9c96a0f843dc/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Ftool%2FErrorType.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/cb16e369fe27b58d04c64e2b6c6c9c96a0f843dc/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Ftool%2FErrorType.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Ftool%2FErrorType.java?ref=cb16e369fe27b58d04c64e2b6c6c9c96a0f843dc",
      "patch": "@@ -972,7 +972,7 @@ public enum ErrorType {\n \t */\n \tMODE_CONFLICTS_WITH_TOKEN(170, \"mode <arg> conflicts with token with same name\", ErrorSeverity.ERROR),\n \t/**\n-\t * Compiler Error 172.\n+\t * Compiler Error 171.\n \t *\n \t * <p>can not use or declare token with reserved name</p>\n \t *",
      "parent_sha": "0e1b5d9d7a6fbb6e19ca12a9b8c45365e3bb3f06"
    }
  },
  {
    "oid": "c4f4f60d593374d2eadbf1602dad6b87853b1757",
    "message": "Extract method getCommandArguments",
    "date": "2012-12-01T19:28:31Z",
    "url": "https://github.com/antlr/antlr4/commit/c4f4f60d593374d2eadbf1602dad6b87853b1757",
    "details": {
      "sha": "5c3b5c2ec65b344fb090ada179bf32f864694b58",
      "filename": "antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4Mojo.java",
      "status": "modified",
      "additions": 35,
      "deletions": 30,
      "changes": 65,
      "blob_url": "https://github.com/antlr/antlr4/blob/c4f4f60d593374d2eadbf1602dad6b87853b1757/antlr4-maven-plugin%2Fsrc%2Fmain%2Fjava%2Forg%2Fantlr%2Fmojo%2Fantlr4%2FAntlr4Mojo.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/c4f4f60d593374d2eadbf1602dad6b87853b1757/antlr4-maven-plugin%2Fsrc%2Fmain%2Fjava%2Forg%2Fantlr%2Fmojo%2Fantlr4%2FAntlr4Mojo.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/antlr4-maven-plugin%2Fsrc%2Fmain%2Fjava%2Forg%2Fantlr%2Fmojo%2Fantlr4%2FAntlr4Mojo.java?ref=c4f4f60d593374d2eadbf1602dad6b87853b1757",
      "patch": "@@ -222,36 +222,7 @@ public void execute()\n             outputDir.mkdirs();\n         }\n \n-\t\tList<String> args = new ArrayList<String>();\n-\n-\t\tif (getOutputDirectory() != null) {\n-\t\t\targs.add(\"-o\");\n-\t\t\targs.add(outputDir.getAbsolutePath());\n-\t\t}\n-\n-\t\t// Where do we want ANTLR to look for .tokens and import grammars?\n-\t\t//\n-\t\tif (getLibDirectory() != null && getLibDirectory().exists()) {\n-\t\t\targs.add(\"-lib\");\n-\t\t\targs.add(libDirectory.getAbsolutePath());\n-\t\t}\n-\n-        // Next we need to set the options given to us in the pom into the\n-        // tool instance we have created.\n-        //\n-\t\tif (atn) {\n-\t\t\targs.add(\"-atn\");\n-\t\t}\n-\t\tif (verbose_dfa) {\n-\t\t\targs.add(\"-Xverbose-dfa\");\n-\t\t}\n-\t\tif (messageFormat != null && !\"\".equals(messageFormat)) {\n-\t\t\targs.add(\"-message-format\");\n-\t\t\targs.add(messageFormat);\n-\t\t}\n-\t\tif (force_atn) {\n-\t\t\targs.add(\"-Xforce-atn\");\n-\t\t}\n+\t\tList<String> args = getCommandArguments();\n \n         try {\n \n@@ -325,6 +296,40 @@ public void execute()\n \n     }\n \n+\tprivate List<String> getCommandArguments() {\n+\t\tList<String> args = new ArrayList<String>();\n+\n+\t\tif (getOutputDirectory() != null) {\n+\t\t\targs.add(\"-o\");\n+\t\t\targs.add(outputDirectory.getAbsolutePath());\n+\t\t}\n+\n+\t\t// Where do we want ANTLR to look for .tokens and import grammars?\n+\t\t//\n+\t\tif (getLibDirectory() != null && getLibDirectory().exists()) {\n+\t\t\targs.add(\"-lib\");\n+\t\t\targs.add(libDirectory.getAbsolutePath());\n+\t\t}\n+\n+        // Next we need to set the options given to us in the pom into the\n+        // tool instance we have created.\n+        //\n+\t\tif (atn) {\n+\t\t\targs.add(\"-atn\");\n+\t\t}\n+\t\tif (verbose_dfa) {\n+\t\t\targs.add(\"-Xverbose-dfa\");\n+\t\t}\n+\t\tif (messageFormat != null && !\"\".equals(messageFormat)) {\n+\t\t\targs.add(\"-message-format\");\n+\t\t\targs.add(messageFormat);\n+\t\t}\n+\t\tif (force_atn) {\n+\t\t\targs.add(\"-Xforce-atn\");\n+\t\t}\n+\n+\t\treturn args;\n+\t}\n \n     /**\n      *",
      "parent_sha": "b9c7e2075ebd239eb6a9ce5a18f771aad549d9fb"
    }
  },
  {
    "oid": "8a301f59f8a7f77002b49fde77f67b0b02311dd1",
    "message": "try making smaller config list.",
    "date": "2012-07-28T17:29:04Z",
    "url": "https://github.com/antlr/antlr4/commit/8a301f59f8a7f77002b49fde77f67b0b02311dd1",
    "details": {
      "sha": "ed9428eb4511a858b6ab59d46886660980e07587",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/atn/ATNConfigSet.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/antlr/antlr4/blob/8a301f59f8a7f77002b49fde77f67b0b02311dd1/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FATNConfigSet.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/8a301f59f8a7f77002b49fde77f67b0b02311dd1/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FATNConfigSet.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FATNConfigSet.java?ref=8a301f59f8a7f77002b49fde77f67b0b02311dd1",
      "patch": "@@ -276,7 +276,7 @@ public boolean equals(ATNConfig a, ATNConfig b) {\n \n \t/** Track the elements as they are added to the set; supports get(i) */\n \t// too hard to keep in sync\n-\tpublic final ArrayList<ATNConfig> configs = new ArrayList<ATNConfig>();\n+\tpublic final ArrayList<ATNConfig> configs = new ArrayList<ATNConfig>(7);\n \n \t// TODO: these fields make me pretty uncomfortable but nice to pack up info together, saves recomputation\n \t// TODO: can we track conflicts as they are added to save scanning configs later?",
      "parent_sha": "2ee5a2f3ae60c2b7adb2a4f920d6ad0d26e22722"
    }
  },
  {
    "oid": "31f3a57a6e8fd4bed0a03d18964f7508e80e70ed",
    "message": "Rewritten test to make it threadsafe (and Travis happy)",
    "date": "2016-11-18T19:19:23Z",
    "url": "https://github.com/antlr/antlr4/commit/31f3a57a6e8fd4bed0a03d18964f7508e80e70ed",
    "details": {
      "sha": "d90d19929ea50c8484030493e78a111fe79bcd37",
      "filename": "antlr4-maven-plugin/src/test/java/org/antlr/mojo/antlr4/Antlr4MojoTest.java",
      "status": "modified",
      "additions": 232,
      "deletions": 236,
      "changes": 468,
      "blob_url": "https://github.com/antlr/antlr4/blob/31f3a57a6e8fd4bed0a03d18964f7508e80e70ed/antlr4-maven-plugin%2Fsrc%2Ftest%2Fjava%2Forg%2Fantlr%2Fmojo%2Fantlr4%2FAntlr4MojoTest.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/31f3a57a6e8fd4bed0a03d18964f7508e80e70ed/antlr4-maven-plugin%2Fsrc%2Ftest%2Fjava%2Forg%2Fantlr%2Fmojo%2Fantlr4%2FAntlr4MojoTest.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/antlr4-maven-plugin%2Fsrc%2Ftest%2Fjava%2Forg%2Fantlr%2Fmojo%2Fantlr4%2FAntlr4MojoTest.java?ref=31f3a57a6e8fd4bed0a03d18964f7508e80e70ed",
      "patch": "@@ -11,25 +11,15 @@\n import org.codehaus.plexus.util.xml.Xpp3Dom;\n \n import static org.junit.Assert.*;\n-\n import org.junit.Rule;\n import org.junit.Test;\n import org.junit.rules.ExpectedException;\n \n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n import java.io.IOException;\n-import java.io.PrintStream;\n import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n+import java.nio.file.Path;\n import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n \n \n public class Antlr4MojoTest {\n@@ -44,317 +34,323 @@ public class Antlr4MojoTest {\n \n     @Test\n     public void importTokens() throws Exception {\n-        Map.Entry<ByteArrayOutputStream, PrintStream> stdout = redirect();\n-        ByteArrayOutputStream output = stdout.getKey();\n+        Path baseDir = resources.getBasedir(\"importTokens\").toPath();\n+        Path antlrDir = baseDir.resolve(\"src/main/antlr4\");\n+        Path generatedSources = baseDir.resolve(\"target/generated-sources/antlr4\");\n \n-        try {\n-            File baseDir = resources.getBasedir(\"importTokens\");\n-            File antlrDir = new File(baseDir, \"src/main/antlr4\");\n+        Path genParser = generatedSources.resolve(\"test/SimpleParser.java\");\n+        Path tokens = antlrDir.resolve(\"imports/SimpleLexer.tokens\");\n \n-            File tokens = new File(antlrDir, \"imports/SimpleLexer.tokens\");\n+        MavenProject project = maven.readMavenProject(baseDir.toFile());\n+        MavenSession session = maven.newMavenSession(project);\n+        MojoExecution exec = maven.newMojoExecution(\"antlr4\");\n \n-            MavenProject project = maven.readMavenProject(baseDir);\n-            MavenSession session = maven.newMavenSession(project);\n-            MojoExecution exec = maven.newMojoExecution(\"antlr4\");\n+        ////////////////////////////////////////////////////////////////////////\n+        // 1st - all grammars have to be processed\n+        ////////////////////////////////////////////////////////////////////////\n \n-            ////////////////////////////////////////////////////////////////////////\n-            // 1st - all grammars have to be processed\n-            ////////////////////////////////////////////////////////////////////////\n+        assertFalse(Files.exists(genParser));\n \n-            maven.executeMojo(session, project, exec);\n+        maven.executeMojo(session, project, exec);\n+\n+        assertTrue(Files.exists(genParser));\n \n-            assertEquals(Arrays.asList(\"test/SimpleParser.g4\"), processAndReset(output));\n+        ////////////////////////////////////////////////////////////////////////\n+        // 2nd - nothing has been modified, no grammars have to be processed\n+        ////////////////////////////////////////////////////////////////////////\n \n-            ////////////////////////////////////////////////////////////////////////\n-            // 2nd - nothing has been modified, no grammars have to be processed\n-            ////////////////////////////////////////////////////////////////////////\n+        {\n+            byte[] sum = checksum(genParser);\n \n             maven.executeMojo(session, project, exec);\n \n-            assertEquals(Collections.emptyList(), processAndReset(output));\n+            assertTrue(Arrays.equals(sum, checksum(genParser)));\n+        }\n \n-            ////////////////////////////////////////////////////////////////////////\n-            // 3rd - the imported grammar changed, every dependency has to be processed\n-            ////////////////////////////////////////////////////////////////////////\n+        ////////////////////////////////////////////////////////////////////////\n+        // 3rd - the imported grammar changed, every dependency has to be processed\n+        ////////////////////////////////////////////////////////////////////////\n \n-            String original = modify(tokens);\n+        try(Change change = Change.of(tokens, \"DOT=4\")) {\n+            byte[] sum = checksum(genParser);\n \n-            try {\n-                maven.executeMojo(session, project, exec);\n+            maven.executeMojo(session, project, exec);\n \n-                assertEquals(Arrays.asList(\"test/SimpleParser.g4\"),\n-                    processAndReset(output));\n-            } finally {\n-                write(tokens, original);\n-            }\n-        } finally {\n-            System.setOut(stdout.getValue());\n+            assertFalse(Arrays.equals(sum, checksum(genParser)));\n         }\n     }\n \n     @Test\n     public void importsCustomLayout() throws Exception {\n-        Map.Entry<ByteArrayOutputStream, PrintStream> stdout = redirect();\n-        ByteArrayOutputStream output = stdout.getKey();\n-\n-        try {\n-            File baseDir = resources.getBasedir(\"importsCustom\");\n-            File antlrDir = new File(baseDir, \"src/main/antlr4\");\n-            File generatedSources = new File(baseDir, \"target/generated-sources/antlr4\");\n-\n-            File baseGrammar = new File(antlrDir, \"imports/TestBaseLexer.g4\");\n-            File lexerGrammar = new File(antlrDir, \"TestLexer.g4\");\n-            File parserGrammar = new File(antlrDir, \"TestParser.g4\");\n-            File lexerTokens = new File(generatedSources, \"TestLexer.tokens\");\n-\n-            Xpp3Dom outputDirectory = TestMavenRuntime.newParameter(\"outputDirectory\",\n-                    \"src/main/java/com/foo\");\n-            Xpp3Dom arguments = new Xpp3Dom(\"arguments\");\n-            arguments.addChild(TestMavenRuntime.newParameter(\"argument\", \"-package\"));\n-            arguments.addChild(TestMavenRuntime.newParameter(\"argument\", \"foo\"));\n-\n-            MavenProject project = maven.readMavenProject(baseDir);\n-            MavenSession session = maven.newMavenSession(project);\n-            MojoExecution exec = maven.newMojoExecution(\"antlr4\", outputDirectory,\n-                    arguments);\n-\n-            ////////////////////////////////////////////////////////////////////////\n-            // 1st - all grammars have to be processed\n-            ////////////////////////////////////////////////////////////////////////\n+        Path baseDir = resources.getBasedir(\"importsCustom\").toPath();\n+        Path antlrDir = baseDir.resolve(\"src/main/antlr4\");\n+        Path generatedSources = baseDir.resolve(\"src/main/java\");\n \n-            maven.executeMojo(session, project, exec);\n+        Path genTestLexer = generatedSources.resolve(\"foo/TestLexer.java\");\n+        Path genTestParser = generatedSources.resolve(\"foo/TestParser.java\");\n+        Path genHello = generatedSources.resolve(\"foo/HelloParser.java\");\n \n-            assertEquals(Arrays.asList(\"Hello.g4\", \"TestLexer.g4\", \"TestParser.g4\"),\n-                processAndReset(output));\n+        Path baseGrammar = antlrDir.resolve(\"imports/TestBaseLexer.g4\");\n+        Path lexerGrammar = antlrDir.resolve(\"TestLexer.g4\");\n+        Path parserGrammar = antlrDir.resolve(\"TestParser.g4\");\n \n-            ////////////////////////////////////////////////////////////////////////\n-            // 2nd - nothing has been modified, no grammars have to be processed\n-            ////////////////////////////////////////////////////////////////////////\n+        Xpp3Dom outputDirectory = TestMavenRuntime.newParameter(\"outputDirectory\",\n+                \"src/main/java/foo\");\n+        Xpp3Dom arguments = new Xpp3Dom(\"arguments\");\n+        arguments.addChild(TestMavenRuntime.newParameter(\"argument\", \"-package\"));\n+        arguments.addChild(TestMavenRuntime.newParameter(\"argument\", \"foo\"));\n \n-            maven.executeMojo(session, project, exec);\n+        MavenProject project = maven.readMavenProject(baseDir.toFile());\n+        MavenSession session = maven.newMavenSession(project);\n+        MojoExecution exec = maven.newMojoExecution(\"antlr4\", outputDirectory, arguments);\n \n-            assertEquals(Collections.emptyList(), processAndReset(output));\n+        ////////////////////////////////////////////////////////////////////////\n+        // 1st - all grammars have to be processed\n+        ////////////////////////////////////////////////////////////////////////\n \n-            ////////////////////////////////////////////////////////////////////////\n-            // 3rd - the imported grammar changed, every dependency has to be processed\n-            ////////////////////////////////////////////////////////////////////////\n+        assertFalse(Files.exists(genHello));\n+        assertFalse(Files.exists(genTestParser));\n+        assertFalse(Files.exists(genTestLexer));\n \n-            // modify the grammar to make checksum comparison detect a change\n-            String original = modify(baseGrammar);\n+        maven.executeMojo(session, project, exec);\n \n-            try {\n-                maven.executeMojo(session, project, exec);\n+        assertTrue(Files.exists(genHello));\n+        assertTrue(Files.exists(genTestParser));\n+        assertTrue(Files.exists(genTestLexer));\n \n-                assertEquals(Arrays.asList(\"TestLexer.g4\", \"TestParser.g4\"),\n-                    processAndReset(output));\n-            } finally {\n-                write(baseGrammar, original);\n-            }\n+        ////////////////////////////////////////////////////////////////////////\n+        // 2nd - nothing has been modified, no grammars have to be processed\n+        ////////////////////////////////////////////////////////////////////////\n \n-            ////////////////////////////////////////////////////////////////////////\n-            // 4th - the lexer grammar changed, the parser grammar has to be processed as well\n-            ////////////////////////////////////////////////////////////////////////\n+        {\n+            byte[] testLexerSum = checksum(genTestLexer);\n+            byte[] testParserSum = checksum(genTestParser);\n+            byte[] helloSum = checksum(genHello);\n \n-            // modify the grammar to make checksum comparison detect a change\n-            original = modify(lexerGrammar);\n+            maven.executeMojo(session, project, exec);\n \n-            try {\n-                lexerTokens.delete();\n+            assertTrue(Arrays.equals(testLexerSum, checksum(genTestLexer)));\n+            assertTrue(Arrays.equals(testParserSum, checksum(genTestParser)));\n+            assertTrue(Arrays.equals(helloSum, checksum(genHello)));\n+        }\n \n-                maven.executeMojo(session, project, exec);\n+        ////////////////////////////////////////////////////////////////////////\n+        // 3rd - the imported grammar changed, every dependency has to be processed\n+        ////////////////////////////////////////////////////////////////////////\n \n-                assertEquals(Arrays.asList(\"TestLexer.g4\", \"TestParser.g4\"),\n-                    processAndReset(output));\n-            } finally {\n-                write(lexerGrammar, original);\n-            }\n+        // modify the grammar to make checksum comparison detect a change\n+        try(Change change = Change.of(baseGrammar, \"DOT: '.' ;\")) {\n+            byte[] testLexerSum = checksum(genTestLexer);\n+            byte[] testParserSum = checksum(genTestParser);\n+            byte[] helloSum = checksum(genHello);\n+\n+            maven.executeMojo(session, project, exec);\n \n-            ////////////////////////////////////////////////////////////////////////\n-            // 5th - the parser grammar changed, no other grammars have to be processed\n-            ////////////////////////////////////////////////////////////////////////\n+            assertFalse(Arrays.equals(testLexerSum, checksum(genTestLexer)));\n+            assertFalse(Arrays.equals(testParserSum, checksum(genTestParser)));\n+            assertTrue(Arrays.equals(helloSum, checksum(genHello)));\n+        }\n \n-            // modify the grammar to make checksum comparison detect a change\n-            original = modify(parserGrammar);\n+        ////////////////////////////////////////////////////////////////////////\n+        // 4th - the lexer grammar changed, the parser grammar has to be processed as well\n+        ////////////////////////////////////////////////////////////////////////\n \n-            try {\n-                maven.executeMojo(session, project, exec);\n+        // modify the grammar to make checksum comparison detect a change\n+        try(Change change = Change.of(lexerGrammar, \"fragment DOT : '.';\")) {\n+            byte[] testLexerSum = checksum(genTestLexer);\n+            byte[] testParserSum = checksum(genTestParser);\n+            byte[] helloSum = checksum(genHello);\n \n-                assertEquals(Arrays.asList(\"TestParser.g4\"), processAndReset(output));\n-            } finally {\n-                write(parserGrammar, original);\n-            }\n-        } finally {\n-            System.out.flush();\n-            System.setOut(stdout.getValue());\n+            maven.executeMojo(session, project, exec);\n+\n+            assertFalse(Arrays.equals(testLexerSum, checksum(genTestLexer)));\n+            assertFalse(Arrays.equals(testParserSum, checksum(genTestParser)));\n+            assertTrue(Arrays.equals(helloSum, checksum(genHello)));\n+        }\n+\n+        ////////////////////////////////////////////////////////////////////////\n+        // 5th - the parser grammar changed, no other grammars have to be processed\n+        ////////////////////////////////////////////////////////////////////////\n+\n+        // modify the grammar to make checksum comparison detect a change\n+        try(Change change = Change.of(parserGrammar, \" t : WS* ;\")) {\n+            byte[] testLexerSum = checksum(genTestLexer);\n+            byte[] testParserSum = checksum(genTestParser);\n+            byte[] helloSum = checksum(genHello);\n+\n+            maven.executeMojo(session, project, exec);\n+\n+            assertTrue(Arrays.equals(testLexerSum, checksum(genTestLexer)));\n+            assertFalse(Arrays.equals(testParserSum, checksum(genTestParser)));\n+            assertTrue(Arrays.equals(helloSum, checksum(genHello)));\n         }\n     }\n \n     @Test\n     public void importsStandardLayout() throws Exception {\n-        Map.Entry<ByteArrayOutputStream, PrintStream> stdout = redirect();\n-        ByteArrayOutputStream output = stdout.getKey();\n+        Path baseDir = resources.getBasedir(\"importsStandard\").toPath();\n+        Path antlrDir = baseDir.resolve(\"src/main/antlr4\");\n+        Path generatedSources = baseDir.resolve(\"target/generated-sources/antlr4\");\n \n-        try {\n-            File baseDir = resources.getBasedir(\"importsStandard\");\n-            File antlrDir = new File(baseDir, \"src/main/antlr4\");\n-            File generatedSources = new File(baseDir, \"target/generated-sources/antlr4\");\n+        Path genTestLexer = generatedSources.resolve(\"test/TestLexer.java\");\n+        Path genTestParser = generatedSources.resolve(\"test/TestParser.java\");\n+        Path genHello = generatedSources.resolve(\"test/HelloParser.java\");\n \n-            File baseGrammar = new File(antlrDir, \"imports/TestBaseLexer.g4\");\n-            File lexerGrammar = new File(antlrDir, \"test/TestLexer.g4\");\n-            File parserGrammar = new File(antlrDir, \"test/TestParser.g4\");\n-            File lexerTokens = new File(generatedSources, \"TestLexer.tokens\");\n+        Path baseGrammar = antlrDir.resolve(\"imports/TestBaseLexer.g4\");\n+        Path lexerGrammar = antlrDir.resolve(\"test/TestLexer.g4\");\n+        Path parserGrammar = antlrDir.resolve(\"test/TestParser.g4\");\n \n-            MavenProject project = maven.readMavenProject(baseDir);\n-            MavenSession session = maven.newMavenSession(project);\n-            MojoExecution exec = maven.newMojoExecution(\"antlr4\");\n+        MavenProject project = maven.readMavenProject(baseDir.toFile());\n+        MavenSession session = maven.newMavenSession(project);\n+        MojoExecution exec = maven.newMojoExecution(\"antlr4\");\n \n-            ////////////////////////////////////////////////////////////////////////\n-            // 1st - all grammars have to be processed\n-            ////////////////////////////////////////////////////////////////////////\n+        ////////////////////////////////////////////////////////////////////////\n+        // 1st - all grammars have to be processed\n+        ////////////////////////////////////////////////////////////////////////\n \n-            maven.executeMojo(session, project, exec);\n+        assertFalse(Files.exists(genHello));\n+        assertFalse(Files.exists(genTestParser));\n+        assertFalse(Files.exists(genTestLexer));\n \n-            assertEquals(Arrays.asList(\"test/Hello.g4\", \"test/TestLexer.g4\",\n-                    \"test/TestParser.g4\"), processAndReset(output));\n+        maven.executeMojo(session, project, exec);\n \n-            ////////////////////////////////////////////////////////////////////////\n-            // 2nd - nothing has been modified, no grammars have to be processed\n-            ////////////////////////////////////////////////////////////////////////\n+        assertTrue(Files.exists(genHello));\n+        assertTrue(Files.exists(genTestParser));\n+        assertTrue(Files.exists(genTestLexer));\n \n-            maven.executeMojo(session, project, exec);\n+        ////////////////////////////////////////////////////////////////////////\n+        // 2nd - nothing has been modified, no grammars have to be processed\n+        ////////////////////////////////////////////////////////////////////////\n \n-            assertEquals(Collections.emptyList(), processAndReset(output));\n+        {\n+            byte[] testLexerSum = checksum(genTestLexer);\n+            byte[] testParserSum = checksum(genTestParser);\n+            byte[] helloSum = checksum(genHello);\n \n-            ////////////////////////////////////////////////////////////////////////\n-            // 3rd - the imported grammar changed, every dependency has to be processed\n-            ////////////////////////////////////////////////////////////////////////\n+            maven.executeMojo(session, project, exec);\n \n-            // modify the grammar to make checksum comparison detect a change\n-            String original = modify(baseGrammar);\n+            assertTrue(Arrays.equals(testLexerSum, checksum(genTestLexer)));\n+            assertTrue(Arrays.equals(testParserSum, checksum(genTestParser)));\n+            assertTrue(Arrays.equals(helloSum, checksum(genHello)));\n+        }\n \n-            try {\n-                maven.executeMojo(session, project, exec);\n+        ////////////////////////////////////////////////////////////////////////\n+        // 3rd - the imported grammar changed, every dependency has to be processed\n+        ////////////////////////////////////////////////////////////////////////\n \n-                assertEquals(Arrays.asList(\"test/TestLexer.g4\", \"test/TestParser.g4\"),\n-                    processAndReset(output));\n-            } finally {\n-                write(baseGrammar, original);\n-            }\n+        // modify the grammar to make checksum comparison detect a change\n+        try(Change change = Change.of(baseGrammar, \"DOT: '.' ;\")) {\n+            byte[] testLexerSum = checksum(genTestLexer);\n+            byte[] testParserSum = checksum(genTestParser);\n+            byte[] helloSum = checksum(genHello);\n \n-            ////////////////////////////////////////////////////////////////////////\n-            // 4th - the lexer grammar changed, the parser grammar has to be processed as well\n-            ////////////////////////////////////////////////////////////////////////\n+            maven.executeMojo(session, project, exec);\n \n-            // modify the grammar to make checksum comparison detect a change\n-            original = modify(lexerGrammar);\n+            assertFalse(Arrays.equals(testLexerSum, checksum(genTestLexer)));\n+            assertFalse(Arrays.equals(testParserSum, checksum(genTestParser)));\n+            assertTrue(Arrays.equals(helloSum, checksum(genHello)));\n+        }\n \n-            try {\n-                lexerTokens.delete();\n+        ////////////////////////////////////////////////////////////////////////\n+        // 4th - the lexer grammar changed, the parser grammar has to be processed as well\n+        ////////////////////////////////////////////////////////////////////////\n \n-                maven.executeMojo(session, project, exec);\n+        // modify the grammar to make checksum comparison detect a change\n+        try(Change change = Change.of(lexerGrammar)) {\n+            byte[] testLexerSum = checksum(genTestLexer);\n+            byte[] testParserSum = checksum(genTestParser);\n+            byte[] helloSum = checksum(genHello);\n \n-                assertEquals(Arrays.asList(\"test/TestLexer.g4\", \"test/TestParser.g4\"),\n-                    processAndReset(output));\n-            } finally {\n-                write(lexerGrammar, original);\n-            }\n+            maven.executeMojo(session, project, exec);\n \n-            ////////////////////////////////////////////////////////////////////////\n-            // 5th - the parser grammar changed, no other grammars have to be processed\n-            ////////////////////////////////////////////////////////////////////////\n+            assertFalse(Arrays.equals(testLexerSum, checksum(genTestLexer)));\n+            assertFalse(Arrays.equals(testParserSum, checksum(genTestParser)));\n+            assertTrue(Arrays.equals(helloSum, checksum(genHello)));\n+        }\n \n-            // modify the grammar to make checksum comparison detect a change\n-            original = modify(parserGrammar);\n+        ////////////////////////////////////////////////////////////////////////\n+        // 5th - the parser grammar changed, no other grammars have to be processed\n+        ////////////////////////////////////////////////////////////////////////\n \n-            try {\n-                maven.executeMojo(session, project, exec);\n+        // modify the grammar to make checksum comparison detect a change\n+        try(Change change = Change.of(parserGrammar, \" t : WS* ;\")) {\n+            byte[] testLexerSum = checksum(genTestLexer);\n+            byte[] testParserSum = checksum(genTestParser);\n+            byte[] helloSum = checksum(genHello);\n \n-                assertEquals(Arrays.asList(\"test/TestParser.g4\"),\n-                    processAndReset(output));\n-            } finally {\n-                write(parserGrammar, original);\n-            }\n-        } finally {\n-            System.out.flush();\n-            System.setOut(stdout.getValue());\n+            maven.executeMojo(session, project, exec);\n+\n+            assertTrue(Arrays.equals(testLexerSum, checksum(genTestLexer)));\n+            assertFalse(Arrays.equals(testParserSum, checksum(genTestParser)));\n+            assertTrue(Arrays.equals(helloSum, checksum(genHello)));\n         }\n     }\n \n     @Test\n     public void processWhenDependencyRemoved() throws Exception {\n-        Map.Entry<ByteArrayOutputStream, PrintStream> stdout = redirect();\n-        ByteArrayOutputStream output = stdout.getKey();\n-\n-        try {\n-            File baseDir = resources.getBasedir(\"dependencyRemoved\");\n-            File antlrDir = new File(baseDir, \"src/main/antlr4\");\n+        Path baseDir = resources.getBasedir(\"dependencyRemoved\").toPath();\n+        Path antlrDir = baseDir.resolve(\"src/main/antlr4\");\n \n-            File baseGrammar = new File(antlrDir, \"imports/HelloBase.g4\");\n+        Path baseGrammar = antlrDir.resolve(\"imports/HelloBase.g4\");\n \n-            MavenProject project = maven.readMavenProject(baseDir);\n-            MavenSession session = maven.newMavenSession(project);\n-            MojoExecution exec = maven.newMojoExecution(\"antlr4\");\n-\n-            maven.executeMojo(session, project, exec);\n+        MavenProject project = maven.readMavenProject(baseDir.toFile());\n+        MavenSession session = maven.newMavenSession(project);\n+        MojoExecution exec = maven.newMojoExecution(\"antlr4\");\n \n-            String t = text(baseGrammar);\n+        maven.executeMojo(session, project, exec);\n \n-            try {\n-                // if the base grammar no longer exists, processing must be performed\n-                baseGrammar.delete();\n+        try(Change temp = Change.of(baseGrammar)) {\n+            // if the base grammar no longer exists, processing must be performed\n+            Files.delete(baseGrammar);\n \n-                thrown.expect(MojoExecutionException.class);\n-                thrown.expectMessage(\"ANTLR 4 caught 1 build errors.\");\n+            thrown.expect(MojoExecutionException.class);\n+            thrown.expectMessage(\"ANTLR 4 caught 1 build errors.\");\n \n-                maven.executeMojo(session, project, exec);\n-            } finally {\n-                write(baseGrammar, t);\n-            }\n-        } finally {\n-            System.out.flush();\n-            System.setOut(stdout.getValue());\n+            maven.executeMojo(session, project, exec);\n         }\n     }\n \n-    private List<String> processAndReset(ByteArrayOutputStream output) {\n-        Pattern pattern = Pattern.compile(\"Processing grammar: (.+)\");\n-        Matcher matcher = pattern.matcher(output.toString());\n-\n-        // we reset here simply for convenience\n-        output.reset();\n-\n-        List<String> result = new ArrayList<String>();\n+    private byte[] checksum(Path path) throws IOException {\n+        return MojoUtils.checksum(path.toFile());\n+    }\n \n-        while (matcher.find()) {\n-            result.add(matcher.group(1));\n-        }\n+    private static class Change implements AutoCloseable {\n+        final Path file;\n+        final byte[] original;\n \n-        Collections.sort(result);\n+        public Change(Path file, String change) {\n+            this.file = file;\n \n-        return result;\n-    }\n+            try {\n+                original = Files.readAllBytes(file);\n+            } catch (IOException ex) {\n+                throw new RuntimeException(\"Could not read file \" + file);\n+            }\n \n-    private String modify(File file) throws IOException {\n-        String content = text(file);\n-        write(file, content + \"\\n\");\n+            String text = new String(original, StandardCharsets.UTF_8) + change;\n \n-        return content;\n-    }\n+            write(file, text.getBytes(StandardCharsets.UTF_8));\n+        }\n \n-    private void write(File file, String text) throws IOException {\n-        Files.write(file.toPath(), text.getBytes(StandardCharsets.UTF_8));\n-    }\n+        private void write(Path file, byte[] data) {\n+            try {\n+                Files.write(file, data);\n+            } catch (IOException ex) {\n+                throw new RuntimeException(\"Could not write file \" + file);\n+            }\n+        }\n \n-    private String text(File file) throws IOException {\n-        return new String(Files.readAllBytes(file.toPath()), StandardCharsets.UTF_8);\n-    }\n+        public static Change of(Path file, String change) {\n+            return new Change(file, change);\n+        }\n \n-    private Map.Entry<ByteArrayOutputStream, PrintStream> redirect() {\n-        // there does not seem to be a clean way to intercept logging output\n-        ByteArrayOutputStream buf = new ByteArrayOutputStream();\n-        PrintStream old = System.out;\n-        System.setOut(new PrintStream(buf));\n+        public static Change of(Path file) {\n+            return new Change(file, \"\\n\");\n+        }\n \n-        return new AbstractMap.SimpleEntry<ByteArrayOutputStream, PrintStream>(buf, old);\n+        @Override\n+        public void close() {\n+            write(file, original);\n+        }\n     }\n }",
      "parent_sha": "81efb0e366a6584fd5e3a98e986107f6af03d47c"
    }
  },
  {
    "oid": "95f5cc6b8bfbeb1f69a90964cb3f92c1bd27bf28",
    "message": "Support specifying the inputDirectory in code",
    "date": "2012-04-10T14:49:31Z",
    "url": "https://github.com/antlr/antlr4/commit/95f5cc6b8bfbeb1f69a90964cb3f92c1bd27bf28",
    "details": {
      "sha": "ca277283215a28e9a23e8b645775fd7c773e416a",
      "filename": "tool/src/org/antlr/v4/Tool.java",
      "status": "modified",
      "additions": 8,
      "deletions": 2,
      "changes": 10,
      "blob_url": "https://github.com/antlr/antlr4/blob/95f5cc6b8bfbeb1f69a90964cb3f92c1bd27bf28/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2FTool.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/95f5cc6b8bfbeb1f69a90964cb3f92c1bd27bf28/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2FTool.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2FTool.java?ref=95f5cc6b8bfbeb1f69a90964cb3f92c1bd27bf28",
      "patch": "@@ -106,6 +106,7 @@ public Option(String fieldName, String name, OptionArgType argType, String descr\n \n \t// fields set by option manager\n \n+\tpublic File inputDirectory;\n \tpublic String outputDirectory;\n \tpublic String libDirectory;\n \tpublic boolean report = false;\n@@ -381,7 +382,12 @@ public Grammar createGrammar(GrammarRootAST ast) {\n \n \tpublic GrammarRootAST loadGrammar(String fileName) {\n \t\ttry {\n-\t\t\tANTLRFileStream in = new ANTLRFileStream(fileName, grammarEncoding);\n+\t\t\tFile file = new File(fileName);\n+\t\t\tif (!file.isAbsolute()) {\n+\t\t\t\tfile = new File(inputDirectory, fileName);\n+\t\t\t}\n+\n+\t\t\tANTLRFileStream in = new ANTLRFileStream(file.getAbsolutePath(), grammarEncoding);\n \t\t\tGrammarRootAST t = load(in);\n \t\t\treturn t;\n \t\t}\n@@ -510,7 +516,7 @@ public Writer getOutputFileWriter(Grammar g, String fileName) throws IOException\n \t}\n \n \tpublic File getImportedGrammarFile(Grammar g, String fileName) {\n-\t\tFile importedFile = new File(fileName);\n+\t\tFile importedFile = new File(inputDirectory, fileName);\n \t\tif ( !importedFile.exists() ) {\n \t\t\tFile gfile = new File(g.fileName);\n \t\t\tString parentDir = gfile.getParent();",
      "parent_sha": "35aeeb7c5c08498c8f201e175c3848d4fadfb22a"
    }
  },
  {
    "oid": "657d496d713e3d2bce246c6092b6975a609aa644",
    "message": "Prevent XPath from returning the same node multiple times (fixes #370)",
    "date": "2014-01-15T20:32:34Z",
    "url": "https://github.com/antlr/antlr4/commit/657d496d713e3d2bce246c6092b6975a609aa644",
    "details": {
      "sha": "5ffa080e39cef3d29fd89329d609cabffe4ddebd",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/tree/xpath/XPath.java",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/antlr/antlr4/blob/657d496d713e3d2bce246c6092b6975a609aa644/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Ftree%2Fxpath%2FXPath.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/657d496d713e3d2bce246c6092b6975a609aa644/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Ftree%2Fxpath%2FXPath.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Ftree%2Fxpath%2FXPath.java?ref=657d496d713e3d2bce246c6092b6975a609aa644",
      "patch": "@@ -12,6 +12,8 @@\n import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n import java.util.List;\n \n /** Represent a subset of XPath XML path syntax for use in identifying nodes in\n@@ -176,14 +178,14 @@ public static Collection<ParseTree> findAll(ParseTree tree, String xpath, Parser\n \t */\n \tpublic Collection<ParseTree> evaluate(final ParseTree t) {\n \t\tParserRuleContext dummyRoot = new ParserRuleContext();\n-\t\tdummyRoot.children = new ArrayList<ParseTree>() {{add(t);}}; // don't set t's parent.\n+\t\tdummyRoot.children = Collections.singletonList(t); // don't set t's parent.\n \n-\t\tCollection<ParseTree> work = new ArrayList<ParseTree>();\n+\t\tCollection<ParseTree> work = Collections.<ParseTree>singleton(dummyRoot);\n \t\twork.add(dummyRoot);\n \n \t\tint i = 0;\n \t\twhile ( i < elements.length ) {\n-\t\t\tCollection<ParseTree> next = new ArrayList<ParseTree>();\n+\t\t\tCollection<ParseTree> next = new LinkedHashSet<ParseTree>();\n \t\t\tfor (ParseTree node : work) {\n \t\t\t\tif ( node.getChildCount()>0 ) {\n \t\t\t\t\t// only try to match next element if it has children",
      "parent_sha": "83ad25ea1dc78a264a50b95e9a2ea5a15a489969"
    }
  },
  {
    "oid": "aa9a51a334e0e72d651d1cbd7fa1d81d4f146d40",
    "message": "Add documentation to ParseTreeWalker",
    "date": "2020-03-16T03:45:40Z",
    "url": "https://github.com/antlr/antlr4/commit/aa9a51a334e0e72d651d1cbd7fa1d81d4f146d40",
    "details": {
      "sha": "b668dfed3b4147c4a08e4e27da600b9c69732878",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/tree/ParseTreeWalker.java",
      "status": "modified",
      "additions": 22,
      "deletions": 7,
      "changes": 29,
      "blob_url": "https://github.com/antlr/antlr4/blob/aa9a51a334e0e72d651d1cbd7fa1d81d4f146d40/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Ftree%2FParseTreeWalker.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/aa9a51a334e0e72d651d1cbd7fa1d81d4f146d40/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Ftree%2FParseTreeWalker.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Ftree%2FParseTreeWalker.java?ref=aa9a51a334e0e72d651d1cbd7fa1d81d4f146d40",
      "patch": "@@ -7,12 +7,20 @@\n package org.antlr.v4.runtime.tree;\n \n import org.antlr.v4.runtime.ParserRuleContext;\n-import org.antlr.v4.runtime.RuleContext;\n \n public class ParseTreeWalker {\n     public static final ParseTreeWalker DEFAULT = new ParseTreeWalker();\n \n-    public void walk(ParseTreeListener listener, ParseTree t) {\n+\n+\t/**\n+\t * Performs a walk on the given parse tree starting at the root and going down recursively\n+\t * with depth-first search. On each node, {@link ParseTreeWalker#enterRule} is called before\n+\t * recursively walking down into child nodes, then\n+\t * {@link ParseTreeWalker#exitRule} is called after the recursive call to wind up.\n+\t * @param listener The listener used by the walker to process grammar rules\n+\t * @param t The parse tree to be walked on\n+\t */\n+\tpublic void walk(ParseTreeListener listener, ParseTree t) {\n \t\tif ( t instanceof ErrorNode) {\n \t\t\tlistener.visitErrorNode((ErrorNode)t);\n \t\t\treturn;\n@@ -31,18 +39,25 @@ else if ( t instanceof TerminalNode) {\n     }\n \n \t/**\n-\t * The discovery of a rule node, involves sending two events: the generic\n-\t * {@link ParseTreeListener#enterEveryRule} and a\n-\t * {@link RuleContext}-specific event. First we trigger the generic and then\n-\t * the rule specific. We to them in reverse order upon finishing the node.\n+\t * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener#enterEveryRule}\n+\t * then by triggering the event specific to the given parse tree node\n+\t * @param listener The listener responding to the trigger events\n+\t * @param r The grammar rule containing the rule context\n \t */\n     protected void enterRule(ParseTreeListener listener, RuleNode r) {\n \t\tParserRuleContext ctx = (ParserRuleContext)r.getRuleContext();\n \t\tlistener.enterEveryRule(ctx);\n \t\tctx.enterRule(listener);\n     }\n \n-    protected void exitRule(ParseTreeListener listener, RuleNode r) {\n+\n+\t/**\n+\t * Exits a grammar rule by first triggering the event specific to the given parse tree node\n+\t * then by triggering the generic event {@link ParseTreeListener#enterEveryRule}\n+\t * @param listener The listener responding to the trigger events\n+\t * @param r The grammar rule containing the rule context\n+\t */\n+\tprotected void exitRule(ParseTreeListener listener, RuleNode r) {\n \t\tParserRuleContext ctx = (ParserRuleContext)r.getRuleContext();\n \t\tctx.exitRule(listener);\n \t\tlistener.exitEveryRule(ctx);",
      "parent_sha": "1284814c2112c7ffe275a4831511b4a0f21dd44c"
    }
  },
  {
    "oid": "dc150f4aa27944c526e27b9ec51134b966a67865",
    "message": "refactor tokens.size() to be size()",
    "date": "2015-06-18T17:23:12Z",
    "url": "https://github.com/antlr/antlr4/commit/dc150f4aa27944c526e27b9ec51134b966a67865",
    "details": {
      "sha": "914a6d09951db979e7a135e20fcc4e2cc658d52c",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/BufferedTokenStream.java",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "blob_url": "https://github.com/antlr/antlr4/blob/dc150f4aa27944c526e27b9ec51134b966a67865/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FBufferedTokenStream.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/dc150f4aa27944c526e27b9ec51134b966a67865/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FBufferedTokenStream.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FBufferedTokenStream.java?ref=dc150f4aa27944c526e27b9ec51134b966a67865",
      "patch": "@@ -133,11 +133,11 @@ public void consume() {\n \t\t\tif (fetchedEOF) {\n \t\t\t\t// the last token in tokens is EOF. skip check if p indexes any\n \t\t\t\t// fetched token except the last.\n-\t\t\t\tskipEofCheck = p < tokens.size() - 1;\n+\t\t\t\tskipEofCheck = p < size() - 1;\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// no EOF token in tokens. skip check if p indexes a fetched token.\n-\t\t\t\tskipEofCheck = p < tokens.size();\n+\t\t\t\tskipEofCheck = p < size();\n \t\t\t}\n \t\t}\n \t\telse {\n@@ -162,7 +162,7 @@ public void consume() {\n \t */\n     protected boolean sync(int i) {\n \t\tassert i >= 0;\n-        int n = i - tokens.size() + 1; // how many more elements we need?\n+        int n = i - size() + 1; // how many more elements we need?\n         //System.out.println(\"sync(\"+i+\") needs \"+n);\n         if ( n > 0 ) {\n \t\t\tint fetched = fetch(n);\n@@ -184,7 +184,7 @@ protected int fetch(int n) {\n         for (int i = 0; i < n; i++) {\n             Token t = tokenSource.nextToken();\n             if ( t instanceof WritableToken ) {\n-                ((WritableToken)t).setTokenIndex(tokens.size());\n+                ((WritableToken)t).setTokenIndex(size());\n             }\n             tokens.add(t);\n             if ( t.getType()==Token.EOF ) {\n@@ -198,8 +198,8 @@ protected int fetch(int n) {\n \n     @Override\n     public Token get(int i) {\n-        if ( i < 0 || i >= tokens.size() ) {\n-            throw new IndexOutOfBoundsException(\"token index \"+i+\" out of range 0..\"+(tokens.size()-1));\n+        if ( i < 0 || i >= size() ) {\n+            throw new IndexOutOfBoundsException(\"token index \"+i+\" out of range 0..\"+(size()-1));\n         }\n         return tokens.get(i);\n     }\n@@ -209,7 +209,7 @@ public List<Token> get(int start, int stop) {\n \t\tif ( start<0 || stop<0 ) return null;\n \t\tlazyInit();\n \t\tList<Token> subset = new ArrayList<Token>();\n-\t\tif ( stop>=tokens.size() ) stop = tokens.size()-1;\n+\t\tif ( stop>=size() ) stop = size()-1;\n \t\tfor (int i = start; i <= stop; i++) {\n \t\t\tToken t = tokens.get(i);\n \t\t\tif ( t.getType()==Token.EOF ) break;\n@@ -235,9 +235,9 @@ public Token LT(int k) {\n \n \t\tint i = p + k - 1;\n \t\tsync(i);\n-        if ( i >= tokens.size() ) { // return EOF token\n+        if ( i >= size() ) { // return EOF token\n             // EOF must be last token\n-            return tokens.get(tokens.size()-1);\n+            return tokens.get(size()-1);\n         }\n //\t\tif ( i>range ) range = i;\n         return tokens.get(i);\n@@ -290,11 +290,11 @@ public List<Token> getTokens(int start, int stop) {\n      */\n     public List<Token> getTokens(int start, int stop, Set<Integer> types) {\n         lazyInit();\n-\t\tif ( start<0 || stop>=tokens.size() ||\n-\t\t\t stop<0  || start>=tokens.size() )\n+\t\tif ( start<0 || stop>=size() ||\n+\t\t\t stop<0  || start>=size() )\n \t\t{\n \t\t\tthrow new IndexOutOfBoundsException(\"start \"+start+\" or stop \"+stop+\n-\t\t\t\t\t\t\t\t\t\t\t\t\" not in 0..\"+(tokens.size()-1));\n+\t\t\t\t\t\t\t\t\t\t\t\t\" not in 0..\"+(size()-1));\n \t\t}\n         if ( start>stop ) return null;\n \n@@ -379,8 +379,8 @@ protected int previousTokenOnChannel(int i, int channel) {\n \t */\n \tpublic List<Token> getHiddenTokensToRight(int tokenIndex, int channel) {\n \t\tlazyInit();\n-\t\tif ( tokenIndex<0 || tokenIndex>=tokens.size() ) {\n-\t\t\tthrow new IndexOutOfBoundsException(tokenIndex+\" not in 0..\"+(tokens.size()-1));\n+\t\tif ( tokenIndex<0 || tokenIndex>=size() ) {\n+\t\t\tthrow new IndexOutOfBoundsException(tokenIndex+\" not in 0..\"+(size()-1));\n \t\t}\n \n \t\tint nextOnChannel =\n@@ -408,8 +408,8 @@ public List<Token> getHiddenTokensToRight(int tokenIndex) {\n \t */\n \tpublic List<Token> getHiddenTokensToLeft(int tokenIndex, int channel) {\n \t\tlazyInit();\n-\t\tif ( tokenIndex<0 || tokenIndex>=tokens.size() ) {\n-\t\t\tthrow new IndexOutOfBoundsException(tokenIndex+\" not in 0..\"+(tokens.size()-1));\n+\t\tif ( tokenIndex<0 || tokenIndex>=size() ) {\n+\t\t\tthrow new IndexOutOfBoundsException(tokenIndex+\" not in 0..\"+(size()-1));\n \t\t}\n \n \t\tif (tokenIndex == 0) {\n@@ -468,7 +468,7 @@ public String getText(Interval interval) {\n \t\tint stop = interval.b;\n         if ( start<0 || stop<0 ) return \"\";\n         lazyInit();\n-        if ( stop>=tokens.size() ) stop = tokens.size()-1;\n+        if ( stop>=size() ) stop = size()-1;\n \n \t\tStringBuilder buf = new StringBuilder();\n \t\tfor (int i = start; i <= stop; i++) {",
      "parent_sha": "0e692ed436c33686973242464641c8bf829468e0"
    }
  },
  {
    "oid": "76972cb940f655c32255d29a999302c7ffc9bdcd",
    "message": "fix: reverse accidental IntelliJ formatting\n\nSigned-off-by: Jim.Idle <jimi@idle.ws>",
    "date": "2023-03-28T08:17:25Z",
    "url": "https://github.com/antlr/antlr4/commit/76972cb940f655c32255d29a999302c7ffc9bdcd",
    "details": {
      "sha": "40b7db5156ebda432082d67ce6a8769df742821b",
      "filename": "runtime-testsuite/test/org/antlr/v4/test/runtime/RuntimeRunner.java",
      "status": "modified",
      "additions": 16,
      "deletions": 48,
      "changes": 64,
      "blob_url": "https://github.com/antlr/antlr4/blob/76972cb940f655c32255d29a999302c7ffc9bdcd/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2FRuntimeRunner.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/76972cb940f655c32255d29a999302c7ffc9bdcd/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2FRuntimeRunner.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2FRuntimeRunner.java?ref=76972cb940f655c32255d29a999302c7ffc9bdcd",
      "patch": "@@ -26,45 +26,25 @@ public abstract class RuntimeRunner implements AutoCloseable {\n \n \tpublic abstract String getLanguage();\n \n-\tprotected String getExtension() {\n-\t\treturn getLanguage().toLowerCase();\n-\t}\n+\tprotected String getExtension() { return getLanguage().toLowerCase(); }\n \n-\tprotected String getTitleName() {\n-\t\treturn getLanguage();\n-\t}\n+\tprotected String getTitleName() { return getLanguage(); }\n \n-\tprotected String getTestFileName() {\n-\t\treturn \"Test\";\n-\t}\n+\tprotected String getTestFileName() { return \"Test\"; }\n \n-\tprotected String getLexerSuffix() {\n-\t\treturn \"Lexer\";\n-\t}\n+\tprotected String getLexerSuffix() { return \"Lexer\"; }\n \n-\tprotected String getParserSuffix() {\n-\t\treturn \"Parser\";\n-\t}\n+\tprotected String getParserSuffix() { return \"Parser\"; }\n \n-\tprotected String getBaseListenerSuffix() {\n-\t\treturn \"BaseListener\";\n-\t}\n+\tprotected String getBaseListenerSuffix() { return \"BaseListener\"; }\n \n-\tprotected String getListenerSuffix() {\n-\t\treturn \"Listener\";\n-\t}\n+\tprotected String getListenerSuffix() { return \"Listener\"; }\n \n-\tprotected String getBaseVisitorSuffix() {\n-\t\treturn \"BaseVisitor\";\n-\t}\n+\tprotected String getBaseVisitorSuffix() { return \"BaseVisitor\"; }\n \n-\tprotected String getVisitorSuffix() {\n-\t\treturn \"Visitor\";\n-\t}\n+\tprotected String getVisitorSuffix() { return \"Visitor\"; }\n \n-\tprotected String grammarNameToFileName(String grammarName) {\n-\t\treturn grammarName;\n-\t}\n+\tprotected String grammarNameToFileName(String grammarName) { return grammarName; }\n \n \tprivate static String runtimeToolPath;\n \tprivate static String compilerPath;\n@@ -97,29 +77,17 @@ protected final String getRuntimeToolPath() {\n \t\treturn runtimeToolPath;\n \t}\n \n-\tprotected String getCompilerName() {\n-\t\treturn null;\n-\t}\n+\tprotected String getCompilerName() { return null; }\n \n-\tprotected String getRuntimeToolName() {\n-\t\treturn getLanguage().toLowerCase();\n-\t}\n+\tprotected String getRuntimeToolName() { return getLanguage().toLowerCase(); }\n \n-\tprotected String getTestFileWithExt() {\n-\t\treturn getTestFileName() + \".\" + getExtension();\n-\t}\n+\tprotected String getTestFileWithExt() { return getTestFileName() + \".\" + getExtension(); }\n \n-\tprotected String getExecFileName() {\n-\t\treturn getTestFileWithExt();\n-\t}\n+\tprotected String getExecFileName() { return getTestFileWithExt(); }\n \n-\tprotected String[] getExtraRunArgs() {\n-\t\treturn null;\n-\t}\n+\tprotected String[] getExtraRunArgs() { return null; }\n \n-\tprotected Map<String, String> getExecEnvironment() {\n-\t\treturn null;\n-\t}\n+\tprotected Map<String, String> getExecEnvironment() { return null; }\n \n \tprotected String getPropertyPrefix() {\n \t\treturn \"antlr-\" + getLanguage().toLowerCase();",
      "parent_sha": "a597aecb1f9bd2ff04af37c0108fa18306478983"
    }
  },
  {
    "oid": "762fd6f32013dcb7c8532e2d68f21b8204cc36c3",
    "message": "Move source directory existence check earlier",
    "date": "2012-12-01T19:52:25Z",
    "url": "https://github.com/antlr/antlr4/commit/762fd6f32013dcb7c8532e2d68f21b8204cc36c3",
    "details": {
      "sha": "c65f91d3fd3530f6fd34fb7752c6acdb8bc37abe",
      "filename": "antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4Mojo.java",
      "status": "modified",
      "additions": 7,
      "deletions": 10,
      "changes": 17,
      "blob_url": "https://github.com/antlr/antlr4/blob/762fd6f32013dcb7c8532e2d68f21b8204cc36c3/antlr4-maven-plugin%2Fsrc%2Fmain%2Fjava%2Forg%2Fantlr%2Fmojo%2Fantlr4%2FAntlr4Mojo.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/762fd6f32013dcb7c8532e2d68f21b8204cc36c3/antlr4-maven-plugin%2Fsrc%2Fmain%2Fjava%2Forg%2Fantlr%2Fmojo%2Fantlr4%2FAntlr4Mojo.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/antlr4-maven-plugin%2Fsrc%2Fmain%2Fjava%2Forg%2Fantlr%2Fmojo%2Fantlr4%2FAntlr4Mojo.java?ref=762fd6f32013dcb7c8532e2d68f21b8204cc36c3",
      "patch": "@@ -211,6 +211,11 @@ public void execute() throws MojoExecutionException, MojoFailureException {\n             //\n         }\n \n+\t\tif (!sourceDirectory.exists()) {\n+\t\t\tlog.info(\"No ANTLR 4 grammars to compile in \" + sourceDirectory.getAbsolutePath());\n+\t\t\treturn;\n+\t\t}\n+\n         // Ensure that the output directory path is all in tact so that\n         // ANTLR can just write into it.\n         //\n@@ -245,17 +250,9 @@ public void execute() throws MojoExecutionException, MojoFailureException {\n \t\t\t// Set working directory for ANTLR to be the base source directory\n \t\t\ttool.inputDirectory = sourceDirectory;\n \n-\t\t\tif (!sourceDirectory.exists()) {\n-\t\t\t\tif (log.isInfoEnabled()) {\n-\t\t\t\t\tlog.info(\"No ANTLR 4 grammars to compile in \" + sourceDirectory.getAbsolutePath());\n-\t\t\t\t}\n-\t\t\t\treturn;\n-\t\t\t} else {\n-\t\t\t\tif (log.isInfoEnabled()) {\n-\t\t\t\t\tlog.info(\"ANTLR 4: Processing source directory \" + sourceDirectory.getAbsolutePath());\n-\t\t\t\t}\n+\t\t\tif (log.isInfoEnabled()) {\n+\t\t\t\tlog.info(\"ANTLR 4: Processing source directory \" + sourceDirectory.getAbsolutePath());\n \t\t\t}\n-\n         } catch (Exception e) {\n             log.error(\"The attempt to create the ANTLR 4 build tool failed, see exception report for details\", e);\n             throw new MojoFailureException(\"Jim failed you!\");",
      "parent_sha": "924186ad46fed0554b59f1c19e064070e29c8952"
    }
  },
  {
    "oid": "8cbd7c0693445c554ea3d65f5beda9cdc3e26799",
    "message": "Get parser tests working.",
    "date": "2017-06-04T05:57:21Z",
    "url": "https://github.com/antlr/antlr4/commit/8cbd7c0693445c554ea3d65f5beda9cdc3e26799",
    "details": {
      "sha": "78dd08c2a7ca3742f0e50fad4f8915c18ff5c250",
      "filename": "runtime-testsuite/test/org/antlr/v4/test/runtime/swift/BaseSwiftTest.java",
      "status": "modified",
      "additions": 56,
      "deletions": 84,
      "changes": 140,
      "blob_url": "https://github.com/antlr/antlr4/blob/8cbd7c0693445c554ea3d65f5beda9cdc3e26799/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fswift%2FBaseSwiftTest.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/8cbd7c0693445c554ea3d65f5beda9cdc3e26799/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fswift%2FBaseSwiftTest.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fswift%2FBaseSwiftTest.java?ref=8cbd7c0693445c554ea3d65f5beda9cdc3e26799",
      "patch": "@@ -22,6 +22,7 @@\n import java.util.Set;\n \n import static org.antlr.v4.test.runtime.BaseRuntimeTest.antlrOnString;\n+import static org.antlr.v4.test.runtime.BaseRuntimeTest.mkdir;\n import static org.antlr.v4.test.runtime.BaseRuntimeTest.writeFile;\n import static org.junit.Assert.assertTrue;\n \n@@ -87,7 +88,7 @@ public void run() {\n \t/**\n \t * Source files used in each small swift project.\n \t */\n-\tprivate Set<String> sourceFiles = new HashSet<String>();\n+\tprivate Set<String> sourceFiles = new HashSet<>();\n \n \t@Override\n \tpublic void testSetUp() throws Exception {\n@@ -139,11 +140,10 @@ public String getANTLRToolErrors() {\n \n \t@Override\n \tpublic String execLexer(String grammarFileName, String grammarStr, String lexerName, String input, boolean showDFA) {\n-\t\tboolean success = generateParser(grammarFileName,\n+\t\tgenerateParser(grammarFileName,\n \t\t\t\tgrammarStr,\n \t\t\t\tnull,\n \t\t\t\tlexerName);\n-\t\tassertTrue(success);\n \t\twriteFile(tmpdir, \"input\", input);\n \t\twriteLexerTestFile(lexerName, showDFA);\n \t\taddSourceFiles(\"main.swift\");\n@@ -154,32 +154,12 @@ public String execLexer(String grammarFileName, String grammarStr, String lexerN\n \t\treturn \"\"; // TODO:\n \t}\n \n-\tprivate String execTest() {\n+\tprivate String execTest(String projectDir, String projectName) {\n \t\ttry {\n-\t\t\tString exec = tmpdir + \"/\" + EXEC_NAME;\n-\t\t\tString[] args =\n-\t\t\t\t\tnew String[]{exec, \"input\"};\n-\t\t\tProcessBuilder pb = new ProcessBuilder(args);\n-\t\t\tpb.directory(new File(tmpdir));\n-\t\t\tProcess p = pb.start();\n-\t\t\tStreamVacuum stdoutVacuum = new StreamVacuum(p.getInputStream());\n-\t\t\tStreamVacuum stderrVacuum = new StreamVacuum(p.getErrorStream());\n-\t\t\tstdoutVacuum.start();\n-\t\t\tstderrVacuum.start();\n-\t\t\tp.waitFor();\n-\t\t\tstdoutVacuum.join();\n-\t\t\tstderrVacuum.join();\n-\t\t\tString output = stdoutVacuum.toString();\n-\t\t\tif ( output.length()==0 ) {\n-\t\t\t\toutput = null;\n-\t\t\t}\n-\t\t\tif (stderrVacuum.toString().length() > 0) {\n-\t\t\t\tthis.stderrDuringParse = stderrVacuum.toString();\n-\t\t\t}\n-\t\t\treturn output;\n+\t\t\treturn runProcess(projectDir, \"./.build/debug/\" + projectName, \"input\");\n \t\t}\n \t\tcatch (Exception e) {\n-\t\t\tSystem.err.println(\"can't exec recognizer\");\n+\t\t\tSystem.err.println(\"Execution of testcase failed.\");\n \t\t\te.printStackTrace(System.err);\n \t\t}\n \t\treturn null;\n@@ -189,27 +169,35 @@ private void addSourceFiles(String... files) {\n \t\tCollections.addAll(this.sourceFiles, files);\n \t}\n \n-\tprivate boolean compile() {\n-\t\ttry {\n-\t\t\treturn buildProject();\n-\t\t} catch (Exception e) {\n-\t\t\treturn false;\n+\tprivate void listSourceFiles() {\n+\t\tfor (String sourceFile: this.sourceFiles) {\n+\t\t\tSystem.out.println(sourceFile);\n \t\t}\n \t}\n \n \tprivate static final String EXEC_NAME = \"Test\";\n \n-\tprivate boolean buildProject() throws Exception {\n-\t\tString fileList = sourceFiles.toString().replace(\"[\", \"\").replace(\"]\", \"\")\n-\t\t\t\t.replace(\", \", \" \");\n+\tprivate void buildProject(String projectDir) {\n+\t\tmkdir(projectDir);\n+\t\texec(projectDir, \"swift\", \"package\", \"init\", \"--type\", \"executable\");\n+\t\tfor (String sourceFile: sourceFiles) {\n+\t\t\tString absPath = getTmpDir() + \"/\" + sourceFile;\n+\t\t\texec(getTmpDir(), \"mv\", \"-f\", absPath, projectDir + \"/Sources/\");\n+\t\t}\n+\t\texec(getTmpDir(), \"mv\", \"-f\", \"input\", projectDir);\n \n-//\t\tString argsString = \"xcrun -sdk macosx swiftc \" + fileList + \" -o \" + EXEC_NAME + \" -I \" + ANTLR_FRAMEWORK_DIR + \" -L \" + ANTLR_FRAMEWORK_DIR + \" -module-link-name Antlr4 -suppress-warnings\";\n-//\t\treturn runProcess(argsString, tmpdir);\n-\t\treturn true;\n+\t\ttry {\n+\t\t\tString dylibPath = ANTLR_RUNTIME_PATH + \"/.build/debug/\";\n+\t\t\trunProcess(projectDir, \"swift\", \"build\",\n+\t\t\t\t\t\"-Xswiftc\", \"-I\"+dylibPath,\n+\t\t\t\t\t\"-Xlinker\", \"-L\"+dylibPath,\n+\t\t\t\t\t\"-Xlinker\", \"-lAntlr4\");\n+\t\t} catch (IOException | InterruptedException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n \t}\n \n-\tprivate static boolean runProcess(String argsString, String execPath) throws IOException, InterruptedException {\n-\t\tString[] args = argsString.split(\" \");\n+\tprivate static String runProcess(String execPath, String... args) throws IOException, InterruptedException {\n \t\tProcess process = Runtime.getRuntime().exec(args, null, new File(execPath));\n \t\tStreamVacuum stdoutVacuum = new StreamVacuum(process.getInputStream());\n \t\tStreamVacuum stderrVacuum = new StreamVacuum(process.getErrorStream());\n@@ -219,43 +207,30 @@ private static boolean runProcess(String argsString, String execPath) throws IOE\n \t\tstdoutVacuum.join();\n \t\tstderrVacuum.join();\n \t\tif (stderrVacuum.toString().length() > 0) {\n-\t\t\t//this.stderrDuringParse = stderrVacuum.toString();\n-\t\t\tSystem.err.println(\"buildProject stderrVacuum: \" + stderrVacuum);\n+\t\t\tthrow new RuntimeException(stderrVacuum.toString());\n \t\t}\n-\t\treturn process.exitValue() == 0;\n+\t\treturn stdoutVacuum.toString();\n \t}\n \n \t@Override\n \tpublic String execParser(String grammarFileName, String grammarStr, String parserName, String lexerName, String listenerName, String visitorName, String startRuleName, String input, boolean showDiagnosticErrors) {\n-\t\treturn execParser(grammarFileName, grammarStr, parserName,\n-\t\t\t\tlexerName, startRuleName, input, showDiagnosticErrors, false);\n-\t}\n-\n-\tprivate String execParser(String grammarFileName,\n-\t\t\t\t\t\t\t\tString grammarStr,\n-\t\t\t\t\t\t\t\tString parserName,\n-\t\t\t\t\t\t\t\tString lexerName,\n-\t\t\t\t\t\t\t\tString startRuleName,\n-\t\t\t\t\t\t\t\tString input, boolean debug,boolean profile)\n-\t{\n-\t\tboolean success = generateParser(grammarFileName,\n+\t\tgenerateParser(grammarFileName,\n \t\t\t\tgrammarStr,\n \t\t\t\tparserName,\n \t\t\t\tlexerName,\n \t\t\t\t\"-visitor\");\n-\t\tassertTrue(success);\n-\t\twriteFile(tmpdir, \"input\", input);\n+\t\twriteFile(getTmpDir(), \"input\", input);\n \t\treturn execParser(parserName,\n \t\t\t\tlexerName,\n \t\t\t\tstartRuleName,\n-\t\t\t\tdebug,profile);\n+\t\t\t\tshowDiagnosticErrors,false);\n \t}\n \n \tprivate String execParser(String parserName,\n-\t\t\t\t\t\t\t\tString lexerName,\n-\t\t\t\t\t\t\t\tString parserStartRuleName,\n-\t\t\t\t\t\t\t\tboolean debug,\n-\t\t\t\t\t\t\t\tboolean profile)\n+\t\t\t\t\t\t\t  String lexerName,\n+\t\t\t\t\t\t\t  String parserStartRuleName,\n+\t\t\t\t\t\t\t  boolean debug,\n+\t\t\t\t\t\t\t  boolean profile)\n \t{\n \t\tthis.stderrDuringParse = null;\n \t\tif ( parserName==null ) {\n@@ -270,19 +245,17 @@ private String execParser(String parserName,\n \t\t}\n \n \t\taddSourceFiles(\"main.swift\");\n-\t\treturn execParser();\n-\t}\n-\n-\tprivate String execParser() {\n-\t\tcompile();\n-\t\treturn execTest();\n+\t\tString projectName = \"testcase-\" + System.currentTimeMillis();\n+\t\tString projectDir = getTmpDir() + \"/\" + projectName;\n+\t\tbuildProject(projectDir);\n+\t\treturn execTest(projectDir, projectName);\n \t}\n \n \tprivate void writeParserTestFile(String parserName,\n-\t\t\t\t\t\t\t\t\t   String lexerName,\n-\t\t\t\t\t\t\t\t\t   String parserStartRuleName,\n-\t\t\t\t\t\t\t\t\t   boolean debug,\n-\t\t\t\t\t\t\t\t\t   boolean profile) {\n+\t\t\t\t\t\t\t\t\t String lexerName,\n+\t\t\t\t\t\t\t\t\t String parserStartRuleName,\n+\t\t\t\t\t\t\t\t\t boolean debug,\n+\t\t\t\t\t\t\t\t\t boolean profile) {\n \n \t\tST outputFileST = new ST(\n \t\t\t\t\"import Antlr4\\n\" +\n@@ -345,7 +318,7 @@ private void writeParserTestFile(String parserName,\n \n \tprivate void writeLexerTestFile(String lexerName, boolean showDFA) {\n \t\tST outputFileST = new ST(\n-\t\t\t\t\t\t\"import Antlr4\\n\" +\n+\t\t\t\t\"import Antlr4\\n\" +\n \t\t\t\t\t\t\"import Foundation\\n\" +\n \n \t\t\t\t\t\t\"setbuf(__stdoutp, nil)\\n\" +\n@@ -374,27 +347,27 @@ private void writeLexerTestFile(String lexerName, boolean showDFA) {\n \t}\n \n \t/**\n-\t * Return true if all is well\n+\t * Generates the parser for one test case.\n \t */\n-\tprivate boolean generateParser(String grammarFileName,\n-\t\t\t\t\t\t\t\t   String grammarStr,\n-\t\t\t\t\t\t\t\t   String parserName,\n-\t\t\t\t\t\t\t\t   String lexerName,\n-\t\t\t\t\t\t\t\t   String... extraOptions) {\n+\tprivate void generateParser(String grammarFileName,\n+\t\t\t\t\t\t\t\tString grammarStr,\n+\t\t\t\t\t\t\t\tString parserName,\n+\t\t\t\t\t\t\t\tString lexerName,\n+\t\t\t\t\t\t\t\tString... extraOptions) {\n \t\tErrorQueue equeue = antlrOnString(getTmpDir(), \"Swift\", grammarFileName, grammarStr, false, extraOptions);\n-\t\tif (!equeue.errors.isEmpty()) {\n-\t\t\treturn false;\n-\t\t}\n+\t\tassertTrue(equeue.errors.isEmpty());\n+\t\tSystem.out.println(getTmpDir());\n \n-\t\tList<String> files = new ArrayList<String>();\n+\t\tList<String> files = new ArrayList<>();\n \t\tif (lexerName != null) {\n \t\t\tfiles.add(lexerName + \".swift\");\n \t\t\tfiles.add(lexerName + \"ATN.swift\");\n \t\t}\n+\n \t\tif (parserName != null) {\n \t\t\tfiles.add(parserName + \".swift\");\n \t\t\tfiles.add(parserName + \"ATN.swift\");\n-\t\t\tSet<String> optionsSet = new HashSet<String>(Arrays.asList(extraOptions));\n+\t\t\tSet<String> optionsSet = new HashSet<>(Arrays.asList(extraOptions));\n \t\t\tString grammarName = grammarFileName.substring(0, grammarFileName.lastIndexOf('.'));\n \t\t\tif (!optionsSet.contains(\"-no-listener\")) {\n \t\t\t\tfiles.add(grammarName + \"Listener.swift\");\n@@ -406,6 +379,5 @@ private boolean generateParser(String grammarFileName,\n \t\t\t}\n \t\t}\n \t\taddSourceFiles(files.toArray(new String[files.size()]));\n-\t\treturn true;\n \t}\n }",
      "parent_sha": "6acec92866552a46afea96d23352ebfcd26f6a0f"
    }
  },
  {
    "oid": "0e608ab0a40defea09ad90cff4c854275b85ce13",
    "message": "clean up unit tests\n\n[git-p4: depot-paths = \"//depot/code/antlr4/main/\": change = 9065]",
    "date": "2011-09-11T23:16:53Z",
    "url": "https://github.com/antlr/antlr4/commit/0e608ab0a40defea09ad90cff4c854275b85ce13",
    "details": {
      "sha": "eb713e0ce1c70802f958efb64084f8214761bc0c",
      "filename": "tool/test/org/antlr/v4/test/TestActionTranslation.java",
      "status": "modified",
      "additions": 16,
      "deletions": 11,
      "changes": 27,
      "blob_url": "https://github.com/antlr/antlr4/blob/0e608ab0a40defea09ad90cff4c854275b85ce13/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestActionTranslation.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/0e608ab0a40defea09ad90cff4c854275b85ce13/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestActionTranslation.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestActionTranslation.java?ref=0e608ab0a40defea09ad90cff4c854275b85ce13",
      "patch": "@@ -92,32 +92,32 @@ public class TestActionTranslation extends BaseTest {\n \t@Test public void testComplicatedArgParsingWithTranslation() throws Exception {\n \t\tString action = \"x, $ID.text+\\\"3242\\\", (*$ID).foo(21,33), 3.2+1, '\\\\n', \"+\n \t\t\t\t\t\t\"\\\"a,oo\\\\nick\\\", {bl, \\\"fdkj\\\"eck}\";\n-\t\tString expected = \"x, (_rID!=null?_rID.getText():null)+\\\"3242\\\",\" +\n-\t\t\t\t\t\t  \" (*_tID).foo(21,33), 3.2+1, '\\\\n', \\\"a,oo\\\\nick\\\", {bl, \\\"fdkj\\\"eck}\";\n+\t\tString expected = \"x, (_localctx._tID!=null?_localctx._tID.getText():null)+\\\"3242\\\",\" +\n+\t\t\t\t\t\t  \" (*_localctx._tID).foo(21,33), 3.2+1, '\\\\n', \\\"a,oo\\\\nick\\\", {bl, \\\"fdkj\\\"eck}\";\n \t\ttestActions(attributeTemplate, \"inline\", action, expected);\n \t}\n \n \t@Test public void testArguments() throws Exception {\n \t\tString action = \"$x; $a.x\";\n-\t\tString expected = \"_ctx.x; _ctx.x\";\n+\t\tString expected = \"_localctx.x; _localctx.x\";\n \t\ttestActions(attributeTemplate, \"inline\", action, expected);\n \t}\n \n \t@Test public void testReturnValue() throws Exception {\n \t\tString action = \"$x; $a.x\";\n-\t\tString expected = \"_ctx.x; _ctx.x\";\n+\t\tString expected = \"_localctx.x; _localctx.x\";\n \t\ttestActions(attributeTemplate, \"inline\", action, expected);\n \t}\n \n \t@Test public void testReturnValueWithNumber() throws Exception {\n \t\tString action = \"$a.x1\";\n-\t\tString expected = \"_ctx.x1\";\n+\t\tString expected = \"_localctx.x1\";\n \t\ttestActions(attributeTemplate, \"inline\", action, expected);\n \t}\n \n \t@Test public void testReturnValuesCurrentRule() throws Exception {\n \t\tString action = \"$y; $a.y;\";\n-\t\tString expected = \"_ctx.y; _ctx.y;\";\n+\t\tString expected = \"_localctx.y; _localctx.y;\";\n \t\ttestActions(attributeTemplate, \"inline\", action, expected);\n \t}\n \n@@ -129,29 +129,34 @@ public class TestActionTranslation extends BaseTest {\n \n     @Test public void testReturnWithMultipleRuleRefs() throws Exception {\n \t\tString action = \"$c.x; $c.y;\";\n-\t\tString expected = \"_rc.x; _rc.y;\";\n+\t\tString expected = \"_localctx._rc.x; _localctx._rc.y;\";\n \t\ttestActions(attributeTemplate, \"inline\", action, expected);\n     }\n \n     @Test public void testTokenRefs() throws Exception {\n \t\tString action = \"$id; $ID; $id.text; $id.getText(); $id.line;\";\n-\t\tString expected = \"id; _tID; (id!=null?id.getText():null); id.getText(); (id!=null?id.getLine():0);\";\n+\t\tString expected = \"_localctx.id; _localctx._tID; (_localctx.id!=null?_localctx.id.getText():null); _localctx.id.getText(); (_localctx.id!=null?_localctx.id.getLine():0);\";\n \t\ttestActions(attributeTemplate, \"inline\", action, expected);\n     }\n \n     @Test public void testRuleRefs() throws Exception {\n         String action = \"$lab.start; $c.tree;\";\n-\t\tString expected = \"(lab!=null?(()lab.start):null); (_rc!=null?(()_rc.tree):null);\";\n+\t\tString expected = \"(_localctx.lab!=null?(_localctx.lab.start):null); (_localctx._rc!=null?((CommonAST)_localctx._rc.tree):null);\";\n \t\ttestActions(attributeTemplate, \"inline\", action, expected);\n     }\n \n \t@Test public void testRefToTextAttributeForCurrentRule() throws Exception {\n         String action = \"$a.text; $text\";\n \t\tString expected =\n-\t\t\t\"((TokenStream)input).toString(_localctx.start, input.LT(-1)); \" +\n-\t\t\t\"((TokenStream)input).toString(_localctx.start, input.LT(-1))\";\n+\t\t\t\"(_localctx._ra!=null?((TokenStream)_input).toString(_localctx._ra.start,_localctx._ra.stop):\" +\n+\t\t\t\"null); ((TokenStream)_input).toString(_localctx.start, _input.LT(-1))\";\n \t\ttestActions(attributeTemplate, \"init\", action, expected);\n+\t\texpected =\n+\t\t\t\"((TokenStream)_input).toString(_localctx.start, _input.LT(-1)); ((TokenStream)_input).toString(_localctx.start, _input.LT(-1))\";\n \t\ttestActions(attributeTemplate, \"inline\", action, expected);\n+\t\texpected =\n+\t\t\t\"(_localctx._ra!=null?((TokenStream)_input).toString(_localctx._ra.start,_localctx._ra.stop):null);\" +\n+\t\t\t\" ((TokenStream)_input).toString(_localctx.start, _input.LT(-1))\";\n \t\ttestActions(attributeTemplate, \"finally\", action, expected);\n     }\n ",
      "parent_sha": "64ccba416817b93f242f2d59bf3bf2a9ed9ff193"
    }
  },
  {
    "oid": "6abc73cba37a5d68258f3f1d13b0e60d5b3f0d49",
    "message": "tweak\n\n[git-p4: depot-paths = \"//depot/code/antlr4/main/\": change = 9418]",
    "date": "2011-11-20T23:04:48Z",
    "url": "https://github.com/antlr/antlr4/commit/6abc73cba37a5d68258f3f1d13b0e60d5b3f0d49",
    "details": {
      "sha": "c78a79f3d9ddaf49adeb78cf6fab5cc7e9c7a2fd",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/ANTLRStringStream.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/antlr/antlr4/blob/6abc73cba37a5d68258f3f1d13b0e60d5b3f0d49/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FANTLRStringStream.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/6abc73cba37a5d68258f3f1d13b0e60d5b3f0d49/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FANTLRStringStream.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FANTLRStringStream.java?ref=6abc73cba37a5d68258f3f1d13b0e60d5b3f0d49",
      "patch": "@@ -121,7 +121,7 @@ public int size() {\n     /** mark/release do nothing; we have entire buffer */\n \t@Override\n \tpublic int mark() {\n-\t\treturn p;\n+\t\treturn -1;\n     }\n \n \t@Override",
      "parent_sha": "2c98cae7518cb4e7b50cbdb54fda56998717f00e"
    }
  },
  {
    "oid": "78d8002303af1195329102ff5c53849158aec44f",
    "message": "allow atn state optimization; sam fixed.",
    "date": "2012-08-05T04:34:42Z",
    "url": "https://github.com/antlr/antlr4/commit/78d8002303af1195329102ff5c53849158aec44f",
    "details": {
      "sha": "032df79d4a33974b12559ca676d0ee932aecc8a1",
      "filename": "tool/src/org/antlr/v4/automata/ATNOptimizer.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/antlr/antlr4/blob/78d8002303af1195329102ff5c53849158aec44f/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fautomata%2FATNOptimizer.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/78d8002303af1195329102ff5c53849158aec44f/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fautomata%2FATNOptimizer.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fautomata%2FATNOptimizer.java?ref=78d8002303af1195329102ff5c53849158aec44f",
      "patch": "@@ -57,7 +57,7 @@ public class ATNOptimizer {\n \n \tpublic static void optimize(@NotNull Grammar g, @NotNull ATN atn) {\n \t\toptimizeSets(g, atn);\n-//\t\toptimizeStates(atn); // TODO leads to class cast exception\n+\t\toptimizeStates(atn);\n \t}\n \n \tprivate static void optimizeSets(Grammar g, ATN atn) {",
      "parent_sha": "492980de71f30014fd5d4c23712cc18abfbc8555"
    }
  },
  {
    "oid": "bedb935bdebc5fb79581a7d6fa44b7d092126997",
    "message": "v4: Fix IndexOutOfBoundsException when token type < -1\n\n[git-p4: depot-paths = \"//depot/code/antlr4/main/\": change = 9211]",
    "date": "2011-10-27T16:55:08Z",
    "url": "https://github.com/antlr/antlr4/commit/bedb935bdebc5fb79581a7d6fa44b7d092126997",
    "details": {
      "sha": "5fda0efb7bdaefb8c59e1bd28d5e47b2a5f18c53",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/antlr/antlr4/blob/bedb935bdebc5fb79581a7d6fa44b7d092126997/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/bedb935bdebc5fb79581a7d6fa44b7d092126997/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java?ref=bedb935bdebc5fb79581a7d6fa44b7d092126997",
      "patch": "@@ -184,7 +184,7 @@ public int execDFA(ObjectStream input, DFA dfa, DFAState s0, RuleContext outerCo\n \t\t\t\tif ( s.complete || t==CharStream.EOF ) break;\n \t\t\t}\n \t\t\t// if no edge, pop over to ATN interpreter, update DFA and return\n-\t\t\tif ( s.edges == null || t >= s.edges.length || s.edges[t+1] == null ) {\n+\t\t\tif ( s.edges == null || t >= s.edges.length || t < -1 || s.edges[t+1] == null ) {\n \t\t\t\tif ( dfa_debug ) System.out.println(\"no edge for \"+t);\n \t\t\t\tint alt = -1;\n \t\t\t\tif ( dfa_debug ) {",
      "parent_sha": "980db2caac89f41b8a8f9ab88306c2113c8d0102"
    }
  },
  {
    "oid": "6934495853f9a655a20f74bed4f81ce698022135",
    "message": "Fixed documentation link",
    "date": "2014-01-15T02:06:05Z",
    "url": "https://github.com/antlr/antlr4/commit/6934495853f9a655a20f74bed4f81ce698022135",
    "details": {
      "sha": "90f7ddded7b7dee9e58c21332d37291bf33c4c30",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/antlr/antlr4/blob/6934495853f9a655a20f74bed4f81ce698022135/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/6934495853f9a655a20f74bed4f81ce698022135/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java?ref=6934495853f9a655a20f74bed4f81ce698022135",
      "patch": "@@ -953,7 +953,7 @@ protected ATNConfigSet computeStartState(@NotNull ATNState p,\n \t *\n \t * <ol>\n \t * <li>Evaluate the precedence predicates for each configuration using\n-\t * {@link SemanticContext.evalPrecedence}.</li>\n+\t * {@link SemanticContext#evalPrecedence}.</li>\n \t * <li>Remove all configurations which predict an alternative greater than\n \t * 1, for which another configuration that predicts alternative 1 is in the\n \t * same ATN state. This transformation is valid for the following reasons:",
      "parent_sha": "f4e5b23bafb3f29e81aa0540e0414e4fe5d23308"
    }
  },
  {
    "oid": "2f54b3554be065e5cd2bb9d0a0da506c34c6ec9a",
    "message": "Mark field PredictionContextCache.cache final",
    "date": "2014-01-23T13:18:09Z",
    "url": "https://github.com/antlr/antlr4/commit/2f54b3554be065e5cd2bb9d0a0da506c34c6ec9a",
    "details": {
      "sha": "b9d12e4fc3cd1c8da481221777c4da812047b20c",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/atn/PredictionContextCache.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/antlr/antlr4/blob/2f54b3554be065e5cd2bb9d0a0da506c34c6ec9a/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FPredictionContextCache.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/2f54b3554be065e5cd2bb9d0a0da506c34c6ec9a/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FPredictionContextCache.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FPredictionContextCache.java?ref=2f54b3554be065e5cd2bb9d0a0da506c34c6ec9a",
      "patch": "@@ -38,7 +38,7 @@\n  *  can be used for both lexers and parsers.\n  */\n public class PredictionContextCache {\n-\tprotected Map<PredictionContext, PredictionContext> cache =\n+\tprotected final Map<PredictionContext, PredictionContext> cache =\n \t\tnew HashMap<PredictionContext, PredictionContext>();\n \n \t/** Add a context to the cache and return it. If the context already exists,",
      "parent_sha": "970ad8c5269087ba7e37908d4728429e06054034"
    }
  },
  {
    "oid": "e5867ee58feac5bf0538a802c78bdb26ab5040aa",
    "message": "Java: LexerInterpreter ctor without channelNames argument marked as Deprecated.",
    "date": "2017-01-31T13:32:32Z",
    "url": "https://github.com/antlr/antlr4/commit/e5867ee58feac5bf0538a802c78bdb26ab5040aa",
    "details": {
      "sha": "d52f1f7df5a54fb9c44c97366db35437bc4d437c",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/LexerInterpreter.java",
      "status": "modified",
      "additions": 8,
      "deletions": 2,
      "changes": 10,
      "blob_url": "https://github.com/antlr/antlr4/blob/e5867ee58feac5bf0538a802c78bdb26ab5040aa/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FLexerInterpreter.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/e5867ee58feac5bf0538a802c78bdb26ab5040aa/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FLexerInterpreter.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FLexerInterpreter.java?ref=e5867ee58feac5bf0538a802c78bdb26ab5040aa",
      "patch": "@@ -12,6 +12,7 @@\n import org.antlr.v4.runtime.atn.PredictionContextCache;\n import org.antlr.v4.runtime.dfa.DFA;\n \n+import java.util.ArrayList;\n import java.util.Collection;\n \n public class LexerInterpreter extends Lexer {\n@@ -32,8 +33,13 @@ public class LexerInterpreter extends Lexer {\n \t\tnew PredictionContextCache();\n \n \t@Deprecated\n-\tpublic LexerInterpreter(String grammarFileName, Collection<String> tokenNames, Collection<String> ruleNames, Collection<String> channelNames, Collection<String> modeNames, ATN atn, CharStream input) {\n-\t\tthis(grammarFileName, VocabularyImpl.fromTokenNames(tokenNames.toArray(new String[tokenNames.size()])), ruleNames, channelNames, modeNames, atn, input);\n+\tpublic LexerInterpreter(String grammarFileName, Collection<String> tokenNames, Collection<String> ruleNames, Collection<String> modeNames, ATN atn, CharStream input) {\n+\t\tthis(grammarFileName, VocabularyImpl.fromTokenNames(tokenNames.toArray(new String[tokenNames.size()])), ruleNames, new ArrayList<String>(), modeNames, atn, input);\n+\t}\n+\n+\t@Deprecated\n+\tpublic LexerInterpreter(String grammarFileName, Vocabulary vocabulary, Collection<String> ruleNames, Collection<String> modeNames, ATN atn, CharStream input) {\n+\t\tthis(grammarFileName, vocabulary, ruleNames, new ArrayList<String>(), modeNames, atn, input);\n \t}\n \n \tpublic LexerInterpreter(String grammarFileName, Vocabulary vocabulary, Collection<String> ruleNames, Collection<String> channelNames, Collection<String> modeNames, ATN atn, CharStream input) {",
      "parent_sha": "b1a9daa6b0ecba82080afd4234ee5cc180d8edcc"
    }
  },
  {
    "oid": "6b2817f8bbe313ccfe90b64b0e3be95aa5b320d4",
    "message": "get last not first when get() finds multiple matching nodes.",
    "date": "2013-12-20T20:47:19Z",
    "url": "https://github.com/antlr/antlr4/commit/6b2817f8bbe313ccfe90b64b0e3be95aa5b320d4",
    "details": {
      "sha": "62d20fb297d9f3d399232f04339172485c94a06b",
      "filename": "tool/test/org/antlr/v4/test/TestParseTreeMatcher.java",
      "status": "modified",
      "additions": 24,
      "deletions": 2,
      "changes": 26,
      "blob_url": "https://github.com/antlr/antlr4/blob/6b2817f8bbe313ccfe90b64b0e3be95aa5b320d4/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestParseTreeMatcher.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/6b2817f8bbe313ccfe90b64b0e3be95aa5b320d4/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestParseTreeMatcher.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestParseTreeMatcher.java?ref=6b2817f8bbe313ccfe90b64b0e3be95aa5b320d4",
      "patch": "@@ -193,6 +193,28 @@ public void testCompilingMultipleTokens() throws Exception {\n \t\tassertEquals(\"[]\", m.getAll(\"undefined\").toString());\n \t}\n \n+\t@Test public void testLabelGetsLastIDNode() throws Exception {\n+\t\tString grammar =\n+\t\t\t\"grammar X9;\\n\" +\n+\t\t\t\"s : ID ID ';' ;\\n\" +\n+\t\t\t\"ID : [a-z]+ ;\\n\" +\n+\t\t\t\"WS : [ \\\\r\\\\n\\\\t]+ -> skip ;\\n\";\n+\n+\t\tString input = \"x y;\";\n+\t\tString pattern = \"<id:ID> <id:ID>;\";\n+\t\tParseTreeMatch m = checkPatternMatch(grammar, \"s\", input, pattern, \"X9\");\n+\t\tassertEquals(\"{ID=[x, y], id=[x, y]}\", m.getLabels().toString());\n+\t\tassertNotNull(m.get(\"id\"));\n+\t\tassertNotNull(m.get(\"ID\"));\n+\t\tassertEquals(\"y\", m.get(\"id\").getText());\n+\t\tassertEquals(\"y\", m.get(\"ID\").getText());\n+\t\tassertEquals(\"[x, y]\", m.getAll(\"id\").toString());\n+\t\tassertEquals(\"[x, y]\", m.getAll(\"ID\").toString());\n+\n+\t\tassertNull(m.get(\"undefined\"));\n+\t\tassertEquals(\"[]\", m.getAll(\"undefined\").toString());\n+\t}\n+\n \t@Test public void testIDNodeWithMultipleLabelMatches() throws Exception {\n \t\tString grammar =\n \t\t\t\"grammar X7;\\n\" +\n@@ -207,9 +229,9 @@ public void testCompilingMultipleTokens() throws Exception {\n \t\tassertNotNull(m.get(\"a\")); // get first\n \t\tassertNotNull(m.get(\"b\"));\n \t\tassertNotNull(m.get(\"ID\"));\n-\t\tassertEquals(\"x\", m.get(\"a\").getText());\n+\t\tassertEquals(\"z\", m.get(\"a\").getText());\n \t\tassertEquals(\"y\", m.get(\"b\").getText());\n-\t\tassertEquals(\"x\", m.get(\"ID\").getText()); // get first\n+\t\tassertEquals(\"z\", m.get(\"ID\").getText()); // get last\n \t\tassertEquals(\"[x, z]\", m.getAll(\"a\").toString());\n \t\tassertEquals(\"[y]\", m.getAll(\"b\").toString());\n \t\tassertEquals(\"[x, y, z]\", m.getAll(\"ID\").toString()); // ordered",
      "parent_sha": "2ff3bb6f52109aa66ab6f4662b5e7e1a593a02f9"
    }
  },
  {
    "oid": "c70c1baccfca89306877832c531259a6d26450dc",
    "message": "Disable annotation processors during testing for performance",
    "date": "2015-05-22T20:32:57Z",
    "url": "https://github.com/antlr/antlr4/commit/c70c1baccfca89306877832c531259a6d26450dc",
    "details": {
      "sha": "244be08892b3112a5879d64856a00470cd2085da",
      "filename": "tool/test/org/antlr/v4/test/rt/java/BaseTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/antlr/antlr4/blob/c70c1baccfca89306877832c531259a6d26450dc/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Frt%2Fjava%2FBaseTest.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/c70c1baccfca89306877832c531259a6d26450dc/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Frt%2Fjava%2FBaseTest.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Frt%2Fjava%2FBaseTest.java?ref=c70c1baccfca89306877832c531259a6d26450dc",
      "patch": "@@ -459,7 +459,7 @@ protected boolean compile(String... fileNames) {\n \t\t\tfileManager.getJavaFileObjectsFromFiles(files);\n \n \t\tIterable<String> compileOptions =\n-\t\t\tArrays.asList(\"-g\", \"-source\", \"1.6\", \"-target\", \"1.6\", \"-implicit:class\", \"-Xlint:-options\", \"-d\", tmpdir, \"-cp\", tmpdir+pathSep+CLASSPATH);\n+\t\t\tArrays.asList(\"-g\", \"-source\", \"1.6\", \"-target\", \"1.6\", \"-implicit:class\", \"-Xlint:-options\", \"-proc:none\", \"-d\", tmpdir, \"-cp\", tmpdir+pathSep+CLASSPATH);\n \n \t\tJavaCompiler.CompilationTask task =\n \t\t\tcompiler.getTask(null, fileManager, null, compileOptions, null,",
      "parent_sha": "8dce2d5fb54a11023ecb60bc3e8cb14d3ee7ccdf"
    }
  },
  {
    "oid": "d77766b60696e06d78596b1a566888de0ca6221c",
    "message": "fix: Fixes the failing go runtime test suite which was missing the /v4 off the replace option on the go.mod file (#4163)\n\nArrrgh!\n\nSigned-off-by: Jim.Idle <jimi@idle.ws>",
    "date": "2023-03-28T08:17:24Z",
    "url": "https://github.com/antlr/antlr4/commit/d77766b60696e06d78596b1a566888de0ca6221c",
    "details": {
      "sha": "22aacfbc7ccf16cd733efce53e931371d7be576a",
      "filename": "runtime-testsuite/test/org/antlr/v4/test/runtime/go/GoRunner.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/antlr/antlr4/blob/d77766b60696e06d78596b1a566888de0ca6221c/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fgo%2FGoRunner.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/d77766b60696e06d78596b1a566888de0ca6221c/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fgo%2FGoRunner.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fgo%2FGoRunner.java?ref=d77766b60696e06d78596b1a566888de0ca6221c",
      "patch": "@@ -79,7 +79,7 @@ public String[] getExtraRunArgs() {\n \tprotected void initRuntime(RunOptions runOptions) throws Exception {\n \t\tString cachePath = getCachePath();\n \t\tmkdir(cachePath);\n-\t\tPath runtimeFilesPath = Paths.get(getRuntimePath(\"Go\"), \"antlr\");\n+\t\tPath runtimeFilesPath = Paths.get(getRuntimePath(\"Go\"), \"antlr\", \"v4\");\n \t\tString runtimeToolPath = getRuntimeToolPath();\n \t\tFile goModFile = new File(cachePath, \"go.mod\");\n \t\tif (goModFile.exists())",
      "parent_sha": "21b27dfa446b10be003c520ee46ad8ceb3f7d031"
    }
  },
  {
    "oid": "bf8473e0fd9eceb929ae2b94bede266c2c3e181b",
    "message": "add cmt\n\n[git-p4: depot-paths = \"//depot/code/antlr4/main/\": change = 9755]",
    "date": "2011-12-27T01:57:00Z",
    "url": "https://github.com/antlr/antlr4/commit/bf8473e0fd9eceb929ae2b94bede266c2c3e181b",
    "details": {
      "sha": "455daabb7dfc7579920667cb5a82d44c9e2afe79",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/antlr/antlr4/blob/bf8473e0fd9eceb929ae2b94bede266c2c3e181b/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FLexerATNSimulator.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/bf8473e0fd9eceb929ae2b94bede266c2c3e181b/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FLexerATNSimulator.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FLexerATNSimulator.java?ref=bf8473e0fd9eceb929ae2b94bede266c2c3e181b",
      "patch": "@@ -44,7 +44,7 @@ public class LexerATNSimulator extends ATNSimulator {\n \n \tpublic static boolean debug = false;\n \tpublic static boolean dfa_debug = false;\n-\tpublic static final int NUM_EDGES = 255;\n+\tpublic static final int NUM_EDGES = 255; // forces unicode to stay in ATN\n \n \tprivate boolean trace = false;\n \tprivate OutputStream traceStream = null;",
      "parent_sha": "24c572d05536f719e87ca0712fd5571a0a210785"
    }
  },
  {
    "oid": "2e9c449ec4811eb417d3b308e1f9b3105a0d62a1",
    "message": "fix a few tests",
    "date": "2012-07-03T19:42:10Z",
    "url": "https://github.com/antlr/antlr4/commit/2e9c449ec4811eb417d3b308e1f9b3105a0d62a1",
    "details": {
      "sha": "b955ed8be1b4000bd969f29a9a3ac7f2d961067a",
      "filename": "tool/test/org/antlr/v4/test/TestSemPredEvalLexer.java",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/antlr/antlr4/blob/2e9c449ec4811eb417d3b308e1f9b3105a0d62a1/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestSemPredEvalLexer.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/2e9c449ec4811eb417d3b308e1f9b3105a0d62a1/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestSemPredEvalLexer.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestSemPredEvalLexer.java?ref=2e9c449ec4811eb417d3b308e1f9b3105a0d62a1",
      "patch": "@@ -38,13 +38,13 @@ public class TestSemPredEvalLexer extends BaseTest {\n \t\t\t\"[@1,5:7='abc',<2>,1:5]\\n\" +\n \t\t\t\"[@2,9:12='enum',<2>,1:9]\\n\" +\n \t\t\t\"[@3,13:12='<EOF>',<-1>,1:13]\\n\" +\n-\t\t\t\"s0-' '->:s5=>3\\n\" +\n-\t\t\t\"s0-'a'->:s4=>2\\n\" +\n+\t\t\t\"s0-' '->:s4=>3\\n\" +\n+\t\t\t\"s0-'a'->:s5=>2\\n\" +\n \t\t\t\"s0-'e'->:s1=>2\\n\" +\n \t\t\t\":s1=>2-'n'->:s2=>2\\n\" +\n \t\t\t\":s2=>2-'u'->:s3=>2\\n\" +\n-\t\t\t\":s4=>2-'b'->:s4=>2\\n\" +\n-\t\t\t\":s4=>2-'c'->:s4=>2\\n\"; // no 'm'-> transition...conflicts with pred\n+\t\t\t\":s5=>2-'b'->:s5=>2\\n\" +\n+\t\t\t\":s5=>2-'c'->:s5=>2\\n\"; // no 'm'-> transition...conflicts with pred\n \t\tassertEquals(expecting, found);\n \t}\n \n@@ -60,7 +60,7 @@ public class TestSemPredEvalLexer extends BaseTest {\n \t\t\t\"[@1,5:7='abc',<2>,1:5]\\n\" +\n \t\t\t\"[@2,9:12='enum',<2>,1:9]\\n\" +\n \t\t\t\"[@3,13:12='<EOF>',<-1>,1:13]\\n\" +\n-\t\t\t\"s0-' '->:s2=>3\\n\"; // no DFA for enum/id. all paths lead to pred.\n+\t\t\t\"s0-' '->:s1=>3\\n\"; // no DFA for enum/id. all paths lead to pred.\n \t\tassertEquals(expecting, found);\n \t}\n ",
      "parent_sha": "1d9aef0a5e453f0972cf4518aa14a0e804142ba9"
    }
  },
  {
    "oid": "78c24f05888e52de1f5579183bb9081fbed12d4e",
    "message": "indentation fix",
    "date": "2014-09-27T09:47:13Z",
    "url": "https://github.com/antlr/antlr4/commit/78c24f05888e52de1f5579183bb9081fbed12d4e",
    "details": {
      "sha": "fdfdb8029d214d5f5bc4e1ec52bdd61df4c39fda",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/TokenStreamRewriter.java",
      "status": "modified",
      "additions": 47,
      "deletions": 50,
      "changes": 97,
      "blob_url": "https://github.com/antlr/antlr4/blob/78c24f05888e52de1f5579183bb9081fbed12d4e/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FTokenStreamRewriter.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/78c24f05888e52de1f5579183bb9081fbed12d4e/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FTokenStreamRewriter.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FTokenStreamRewriter.java?ref=78c24f05888e52de1f5579183bb9081fbed12d4e",
      "patch": "@@ -115,16 +115,16 @@\n  */\n public class TokenStreamRewriter {\n \tpublic static final String DEFAULT_PROGRAM_NAME = \"default\";\n-    public static final int PROGRAM_INIT_SIZE = 100;\n+\tpublic static final int PROGRAM_INIT_SIZE = 100;\n \tpublic static final int MIN_TOKEN_INDEX = 0;\n \n \t// Define the rewrite operation hierarchy\n \n \tpublic class RewriteOperation {\n-        /** What index into rewrites List are we? */\n-        protected int instructionIndex;\n-        /** Token buffer index. */\n-        protected int index;\n+\t/** What index into rewrites List are we? */\n+\tprotected int instructionIndex;\n+\t/** Token buffer index. */\n+\tprotected int index;\n \t\tprotected Object text;\n \n \t\tprotected RewriteOperation(int index) {\n@@ -148,7 +148,7 @@ public String toString() {\n \t\t\tint $index = opName.indexOf('$');\n \t\t\topName = opName.substring($index+1, opName.length());\n \t\t\treturn \"<\"+opName+\"@\"+tokens.get(index)+\n-\t\t\t\t   \":\\\"\"+text+\"\\\">\";\n+\t\t\t\t\t\":\\\"\"+text+\"\\\">\";\n \t\t}\n \t}\n \n@@ -187,10 +187,10 @@ public int execute(StringBuilder buf) {\n \t\tpublic String toString() {\n \t\t\tif ( text==null ) {\n \t\t\t\treturn \"<DeleteOp@\"+tokens.get(index)+\n-\t\t\t\t\t   \"..\"+tokens.get(lastIndex)+\">\";\n+\t\t\t\t\t\t\"..\"+tokens.get(lastIndex)+\">\";\n \t\t\t}\n \t\t\treturn \"<ReplaceOp@\"+tokens.get(index)+\n-\t\t\t\t   \"..\"+tokens.get(lastIndex)+\":\\\"\"+text+\"\\\">\";\n+\t\t\t\t\t\"..\"+tokens.get(lastIndex)+\":\\\"\"+text+\"\\\">\";\n \t\t}\n \t}\n \n@@ -224,7 +224,7 @@ public void rollback(int instructionIndex) {\n \n \t/** Rollback the instruction stream for a program so that\n \t *  the indicated instruction (via instructionIndex) is no\n-\t *  longer in the stream.  UNTESTED!\n+\t *  longer in the stream. UNTESTED!\n \t */\n \tpublic void rollback(String programName, int instructionIndex) {\n \t\tList<RewriteOperation> is = programs.get(programName);\n@@ -274,8 +274,8 @@ public void insertBefore(String programName, Token t, Object text) {\n \tpublic void insertBefore(String programName, int index, Object text) {\n \t\tRewriteOperation op = new InsertBeforeOp(index,text);\n \t\tList<RewriteOperation> rewrites = getProgram(programName);\n-        op.instructionIndex = rewrites.size();\n-        rewrites.add(op);\n+\t\top.instructionIndex = rewrites.size();\n+\t\trewrites.add(op);\n \t}\n \n \tpublic void replace(int index, Object text) {\n@@ -300,8 +300,8 @@ public void replace(String programName, int from, int to, @Nullable Object text)\n \t\t}\n \t\tRewriteOperation op = new ReplaceOp(from, to, text);\n \t\tList<RewriteOperation> rewrites = getProgram(programName);\n-        op.instructionIndex = rewrites.size();\n-        rewrites.add(op);\n+\t\top.instructionIndex = rewrites.size();\n+\t\trewrites.add(op);\n \t}\n \n \tpublic void replace(String programName, Token from, Token to, @Nullable Object text) {\n@@ -390,21 +390,21 @@ public String getText(String programName, Interval interval) {\n \t\tint start = interval.a;\n \t\tint stop = interval.b;\n \n-        // ensure start/end are in range\n-        if ( stop>tokens.size()-1 ) stop = tokens.size()-1;\n-        if ( start<0 ) start = 0;\n+\t\t// ensure start/end are in range\n+\t\tif ( stop>tokens.size()-1 ) stop = tokens.size()-1;\n+\t\tif ( start<0 ) start = 0;\n \n-        if ( rewrites==null || rewrites.isEmpty() ) {\n+\t\tif ( rewrites==null || rewrites.isEmpty() ) {\n \t\t\treturn tokens.getText(interval); // no instructions to execute\n \t\t}\n \t\tStringBuilder buf = new StringBuilder();\n \n \t\t// First, optimize instruction stream\n \t\tMap<Integer, RewriteOperation> indexToOp = reduceToSingleOperationPerIndex(rewrites);\n \n-        // Walk buffer, executing instructions and emitting tokens\n-        int i = start;\n-        while ( i <= stop && i < tokens.size() ) {\n+\t\t// Walk buffer, executing instructions and emitting tokens\n+\t\tint i = start;\n+\t\twhile ( i <= stop && i < tokens.size() ) {\n \t\t\tRewriteOperation op = indexToOp.get(i);\n \t\t\tindexToOp.remove(i); // remove so any left have index size-1\n \t\t\tToken t = tokens.get(i);\n@@ -418,22 +418,22 @@ public String getText(String programName, Interval interval) {\n \t\t\t}\n \t\t}\n \n-        // include stuff after end if it's last index in buffer\n-        // So, if they did an insertAfter(lastValidIndex, \"foo\"), include\n-        // foo if end==lastValidIndex.\n-        if ( stop==tokens.size()-1 ) {\n-            // Scan any remaining operations after last token\n-            // should be included (they will be inserts).\n+\t\t// include stuff after end if it's last index in buffer\n+\t\t// So, if they did an insertAfter(lastValidIndex, \"foo\"), include\n+\t\t// foo if end==lastValidIndex.\n+\t\tif ( stop==tokens.size()-1 ) {\n+\t\t\t// Scan any remaining operations after last token\n+\t\t\t// should be included (they will be inserts).\n \t\t\tfor (RewriteOperation op : indexToOp.values()) {\n-                if ( op.index >= tokens.size()-1 ) buf.append(op.text);\n-            }\n-        }\n-        return buf.toString();\n+\t\t\t\tif ( op.index >= tokens.size()-1 ) buf.append(op.text);\n+\t\t\t}\n+\t\t}\n+\t\treturn buf.toString();\n \t}\n \n \t/** We need to combine operations and report invalid operations (like\n-\t *  overlapping replaces that are not completed nested).  Inserts to\n-\t *  same index need to be combined etc...   Here are the cases:\n+\t *  overlapping replaces that are not completed nested). Inserts to\n+\t *  same index need to be combined etc...  Here are the cases:\n \t *\n \t *  I.i.u I.j.v\t\t\t\t\t\t\t\tleave alone, nonoverlapping\n \t *  I.i.u I.i.v\t\t\t\t\t\t\t\tcombine: Iivu\n@@ -456,25 +456,25 @@ public String getText(String programName, Interval interval) {\n \t *  I.i.u = insert u before op @ index i\n \t *  R.x-y.u = replace x-y indexed tokens with u\n \t *\n-\t *  First we need to examine replaces.  For any replace op:\n+\t *  First we need to examine replaces. For any replace op:\n \t *\n \t * \t\t1. wipe out any insertions before op within that range.\n \t *\t\t2. Drop any replace op before that is contained completely within\n-\t *         that range.\n+\t *\t that range.\n \t *\t\t3. Throw exception upon boundary overlap with any previous replace.\n \t *\n \t *  Then we can deal with inserts:\n \t *\n \t * \t\t1. for any inserts to same index, combine even if not adjacent.\n \t * \t\t2. for any prior replace with same left boundary, combine this\n-\t *         insert with replace and delete this replace.\n+\t *\t insert with replace and delete this replace.\n \t * \t\t3. throw exception if index in same range as previous replace\n \t *\n \t *  Don't actually delete; make op null in list. Easier to walk list.\n \t *  Later we can throw as we add to index &rarr; op map.\n \t *\n \t *  Note that I.2 R.2-2 will wipe out I.2 even though, technically, the\n-\t *  inserted stuff would be before the replace range.  But, if you\n+\t *  inserted stuff would be before the replace range. But, if you\n \t *  add tokens in front of a method body '{' and then delete the method\n \t *  body, I think the stuff before the '{' you added should disappear too.\n \t *\n@@ -499,16 +499,16 @@ protected Map<Integer, RewriteOperation> reduceToSingleOperationPerIndex(List<Re\n \t\t\t\t\trop.text = iop.text.toString() + (rop.text!=null?rop.text.toString():\"\");\n \t\t\t\t}\n \t\t\t\telse if ( iop.index > rop.index && iop.index <= rop.lastIndex ) {\n-                    // delete insert as it's a no-op.\n-                    rewrites.set(iop.instructionIndex, null);\n+\t\t\t\t\t// delete insert as it's a no-op.\n+\t\t\t\t\trewrites.set(iop.instructionIndex, null);\n \t\t\t\t}\n \t\t\t}\n \t\t\t// Drop any prior replaces contained within\n \t\t\tList<? extends ReplaceOp> prevReplaces = getKindOfOps(rewrites, ReplaceOp.class, i);\n \t\t\tfor (ReplaceOp prevRop : prevReplaces) {\n \t\t\t\tif ( prevRop.index>=rop.index && prevRop.lastIndex <= rop.lastIndex ) {\n-                    // delete replace as it's a no-op.\n-                    rewrites.set(prevRop.instructionIndex, null);\n+\t\t\t\t\t// delete replace as it's a no-op.\n+\t\t\t\t\trewrites.set(prevRop.instructionIndex, null);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t\t// throw exception unless disjoint or identical\n@@ -526,8 +526,7 @@ else if ( iop.index > rop.index && iop.index <= rop.lastIndex ) {\n \t\t\t\t\tSystem.out.println(\"new rop \"+rop);\n \t\t\t\t}\n \t\t\t\telse if ( !disjoint && !same ) {\n-\t\t\t\t\tthrow new IllegalArgumentException(\"replace op boundaries of \"+rop+\n-\t\t\t\t\t\t\t\t\t\t\t\t\t   \" overlap with previous \"+prevRop);\n+\t\t\t\t\tthrow new IllegalArgumentException(\"replace op boundaries of \"+rop+\" overlap with previous \"+prevRop);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -545,21 +544,20 @@ else if ( !disjoint && !same ) {\n \t\t\t\t\t// convert to strings...we're in process of toString'ing\n \t\t\t\t\t// whole token buffer so no lazy eval issue with any templates\n \t\t\t\t\tiop.text = catOpText(iop.text,prevIop.text);\n-                    // delete redundant prior insert\n-                    rewrites.set(prevIop.instructionIndex, null);\n+\t\t\t\t\t// delete redundant prior insert\n+\t\t\t\t\trewrites.set(prevIop.instructionIndex, null);\n \t\t\t\t}\n \t\t\t}\n \t\t\t// look for replaces where iop.index is in range; error\n \t\t\tList<? extends ReplaceOp> prevReplaces = getKindOfOps(rewrites, ReplaceOp.class, i);\n \t\t\tfor (ReplaceOp rop : prevReplaces) {\n \t\t\t\tif ( iop.index == rop.index ) {\n \t\t\t\t\trop.text = catOpText(iop.text,rop.text);\n-\t\t\t\t\trewrites.set(i, null);  // delete current insert\n+\t\t\t\t\trewrites.set(i, null);\t// delete current insert\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t\tif ( iop.index >= rop.index && iop.index <= rop.lastIndex ) {\n-\t\t\t\t\tthrow new IllegalArgumentException(\"insert op \"+iop+\n-\t\t\t\t\t\t\t\t\t\t\t\t\t   \" within boundaries of previous \"+rop);\n+\t\t\t\t\tthrow new IllegalArgumentException(\"insert op \"+iop+\" within boundaries of previous \"+rop);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -585,8 +583,8 @@ protected String catOpText(Object a, Object b) {\n \t\treturn x+y;\n \t}\n \n-    /** Get all operations before an index of a particular kind */\n-    protected <T extends RewriteOperation> List<? extends T> getKindOfOps(List<? extends RewriteOperation> rewrites, Class<T> kind, int before) {\n+\t/** Get all operations before an index of a particular kind */\n+\tprotected <T extends RewriteOperation> List<? extends T> getKindOfOps(List<? extends RewriteOperation> rewrites, Class<T> kind, int before) {\n \t\tList<T> ops = new ArrayList<T>();\n \t\tfor (int i=0; i<before && i<rewrites.size(); i++) {\n \t\t\tRewriteOperation op = rewrites.get(i);\n@@ -597,5 +595,4 @@ protected <T extends RewriteOperation> List<? extends T> getKindOfOps(List<? ext\n \t\t}\n \t\treturn ops;\n \t}\n-\n }",
      "parent_sha": "f143495ab2efb743c4c719546d8f3cc70b22df9d"
    }
  },
  {
    "oid": "80b3ec8c620c2fcd4cdabb1f5d1b9cbf1677e364",
    "message": "Dispatch accept() for terminal nodes to visitor",
    "date": "2012-03-04T03:57:08Z",
    "url": "https://github.com/antlr/antlr4/commit/80b3ec8c620c2fcd4cdabb1f5d1b9cbf1677e364",
    "details": {
      "sha": "fcd10ef16da9e54916221e14466b261f92682e2b",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/tree/ParseTree.java",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/antlr/antlr4/blob/80b3ec8c620c2fcd4cdabb1f5d1b9cbf1677e364/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Ftree%2FParseTree.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/80b3ec8c620c2fcd4cdabb1f5d1b9cbf1677e364/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Ftree%2FParseTree.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Ftree%2FParseTree.java?ref=80b3ec8c620c2fcd4cdabb1f5d1b9cbf1677e364",
      "patch": "@@ -80,7 +80,9 @@ public Interval getSourceInterval() {\n \t\tpublic int getChildCount() { return 0; }\n \n \t\t@Override\n-\t\tpublic <T> T accept(ParseTreeVisitor<? extends T> visitor) { return null; }\n+\t\tpublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n+\t\t\treturn visitor.visitTerminal(this);\n+\t\t}\n \n \t\t@Override\n \t\tpublic String toStringTree(Parser parser) {\n@@ -117,6 +119,11 @@ public static class ErrorNodeImpl<Symbol extends Token> extends\n \t\tpublic ErrorNodeImpl(Symbol token) {\n \t\t\tsuper(token);\n \t\t}\n+\n+\t\t@Override\n+\t\tpublic <T> T accept(ParseTreeVisitor<? extends T> visitor) {\n+\t\t\treturn visitor.visitErrorNode(this);\n+\t\t}\n \t}\n \n \t// the following methods narrow the return type; they are not additional methods",
      "parent_sha": "0375f8318a4e5318af66ef67d025967b5299c5e2"
    }
  },
  {
    "oid": "578d8f4d6cc6d7ac8ad5803ea7608366b46733c9",
    "message": "Cache runtime test templates to static field\n\nSigned-off-by: Ivan Kochurkin <kvanttt@gmail.com>",
    "date": "2022-06-26T21:36:15Z",
    "url": "https://github.com/antlr/antlr4/commit/578d8f4d6cc6d7ac8ad5803ea7608366b46733c9",
    "details": {
      "sha": "dd3c56c44be87c0cf40eb4408ec130130a189f50",
      "filename": "runtime-testsuite/test/org/antlr/v4/test/runtime/RuntimeTests.java",
      "status": "modified",
      "additions": 18,
      "deletions": 10,
      "changes": 28,
      "blob_url": "https://github.com/antlr/antlr4/blob/578d8f4d6cc6d7ac8ad5803ea7608366b46733c9/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2FRuntimeTests.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/578d8f4d6cc6d7ac8ad5803ea7608366b46733c9/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2FRuntimeTests.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime-testsuite%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2FRuntimeTests.java?ref=578d8f4d6cc6d7ac8ad5803ea7608366b46733c9",
      "patch": "@@ -15,13 +15,11 @@\n import org.junit.jupiter.api.TestFactory;\n import org.junit.jupiter.api.parallel.Execution;\n import org.junit.jupiter.api.parallel.ExecutionMode;\n-import org.stringtemplate.v4.ST;\n-import org.stringtemplate.v4.STGroup;\n-import org.stringtemplate.v4.STGroupString;\n-import org.stringtemplate.v4.StringRenderer;\n+import org.stringtemplate.v4.*;\n \n import java.io.File;\n import java.io.IOException;\n+import java.net.URL;\n import java.nio.file.Files;\n import java.nio.file.Paths;\n import java.util.ArrayList;\n@@ -44,9 +42,9 @@\n public abstract class RuntimeTests {\n \tprotected abstract RuntimeRunner createRuntimeRunner();\n \n-\tprivate final static StringRenderer rendered = new StringRenderer();\n-\n \tprivate final static HashMap<String, RuntimeTestDescriptor[]> testDescriptors = new HashMap<>();\n+\tprivate final static HashMap<String, STGroup> cachedTargetTemplates = new HashMap<>();\n+\tprivate final static StringRenderer rendered = new StringRenderer();\n \n \tstatic {\n \t\tFile descriptorsDir = new File(Paths.get(RuntimeTestUtils.resourcePath.toString(), \"org/antlr/v4/test/runtime/descriptors\").toString());\n@@ -120,10 +118,20 @@ private static void test(RuntimeTestDescriptor descriptor, RuntimeRunner runner)\n \n \t\tFileUtils.mkdir(runner.getTempDirPath());\n \n-\t\tString sourceName = \"org/antlr/v4/test/runtime/templates/\" + targetName + \".test.stg\";\n-\t\tString template = RuntimeTestUtils.getTextFromResource(sourceName);\n-\t\tSTGroup targetTemplates = new STGroupString(sourceName, template, '<', '>');\n-\t\ttargetTemplates.registerRenderer(String.class, rendered);\n+\t\tSTGroup targetTemplates = cachedTargetTemplates.get(targetName);\n+\t\tif (targetTemplates == null) {\n+\t\t\tsynchronized (cachedTargetTemplates) {\n+\t\t\t\ttargetTemplates = cachedTargetTemplates.get(targetName);\n+\t\t\t\tif (targetTemplates == null) {\n+\t\t\t\t\tClassLoader classLoader = RuntimeTests.class.getClassLoader();\n+\t\t\t\t\tURL templates = classLoader.getResource(\"org/antlr/v4/test/runtime/templates/\" + targetName + \".test.stg\");\n+\t\t\t\t\tassert templates != null;\n+\t\t\t\t\ttargetTemplates = new STGroupFile(templates, \"UTF-8\", '<', '>');\n+\t\t\t\t\ttargetTemplates.registerRenderer(String.class, rendered);\n+\t\t\t\t\tcachedTargetTemplates.put(targetName, targetTemplates);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n \t\t// write out any slave grammars\n \t\tList<Pair<String, String>> slaveGrammars = descriptor.slaveGrammars;",
      "parent_sha": "7a9ca9997a38b2586b1bdd8124691b062554adea"
    }
  },
  {
    "oid": "1723bbd6f5b0637fa27a03f836117e3b2e2686f2",
    "message": "no debug",
    "date": "2012-10-12T01:54:26Z",
    "url": "https://github.com/antlr/antlr4/commit/1723bbd6f5b0637fa27a03f836117e3b2e2686f2",
    "details": {
      "sha": "4b4c4789aa70cd6e4f09f692a7928b99db14a392",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/antlr/antlr4/blob/1723bbd6f5b0637fa27a03f836117e3b2e2686f2/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/1723bbd6f5b0637fa27a03f836117e3b2e2686f2/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java?ref=1723bbd6f5b0637fa27a03f836117e3b2e2686f2",
      "patch": "@@ -255,7 +255,7 @@ They are likely LL(1) + pred eval. Easier to do the whole SLL unless\n \n */\n public class ParserATNSimulator extends ATNSimulator {\n-\tpublic static boolean debug = true;\n+\tpublic static boolean debug = false;\n \tpublic static boolean debug_list_atn_decisions = false;\n \tpublic static boolean dfa_debug = false;\n \tpublic static boolean retry_debug = false;",
      "parent_sha": "6654281aab95350d76ae0af92995d74f6af9f483"
    }
  },
  {
    "oid": "64210f4b7223f29e9ca79d8cb7b396a5e75907c9",
    "message": "Add @NotNull annotations, make ATNConfig.semanticContext field final",
    "date": "2012-02-08T23:21:09Z",
    "url": "https://github.com/antlr/antlr4/commit/64210f4b7223f29e9ca79d8cb7b396a5e75907c9",
    "details": {
      "sha": "1fbdfebc347e7cf9899cfb5adf48136fa8f8798a",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/atn/ATNConfig.java",
      "status": "modified",
      "additions": 5,
      "deletions": 7,
      "changes": 12,
      "blob_url": "https://github.com/antlr/antlr4/blob/64210f4b7223f29e9ca79d8cb7b396a5e75907c9/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FATNConfig.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/64210f4b7223f29e9ca79d8cb7b396a5e75907c9/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FATNConfig.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FATNConfig.java?ref=64210f4b7223f29e9ca79d8cb7b396a5e75907c9",
      "patch": "@@ -74,21 +74,19 @@ public class ATNConfig {\n \tpublic int lexerActionIndex = -1; // TOOD: move to subclass\n \n     @NotNull\n-    public SemanticContext semanticContext = SemanticContext.NONE;\n+    public final SemanticContext semanticContext;\n \n \tpublic ATNConfig(@NotNull ATNState state,\n \t\t\t\t\t int alt,\n \t\t\t\t\t @Nullable RuleContext context)\n \t{\n-\t\tthis.state = state;\n-\t\tthis.alt = alt;\n-\t\tthis.context = context;\n+\t\tthis(state, alt, context, SemanticContext.NONE);\n \t}\n \n \tpublic ATNConfig(@NotNull ATNState state,\n \t\t\t\t\t int alt,\n \t\t\t\t\t @Nullable RuleContext context,\n-\t\t\t\t\t SemanticContext semanticContext)\n+\t\t\t\t\t @NotNull SemanticContext semanticContext)\n \t{\n \t\tthis.state = state;\n \t\tthis.alt = alt;\n@@ -100,7 +98,7 @@ public ATNConfig(@NotNull ATNConfig c, @NotNull ATNState state) {\n    \t\tthis(c, state, c.context, c.semanticContext);\n    \t}\n \n-    public ATNConfig(@NotNull ATNConfig c, @NotNull ATNState state, SemanticContext semanticContext) {\n+    public ATNConfig(@NotNull ATNConfig c, @NotNull ATNState state, @NotNull SemanticContext semanticContext) {\n    \t\tthis(c, state, c.context, semanticContext);\n    \t}\n \n@@ -109,7 +107,7 @@ public ATNConfig(@NotNull ATNConfig c, @NotNull ATNState state, @Nullable RuleCo\n     }\n \n \tpublic ATNConfig(@NotNull ATNConfig c, @NotNull ATNState state, @Nullable RuleContext context,\n-                     SemanticContext semanticContext)\n+                     @NotNull SemanticContext semanticContext)\n     {\n \t\tthis.state = state;\n \t\tthis.alt = c.alt;",
      "parent_sha": "71e0c664770da4d3150fea1ecedc1371b77c84c4"
    }
  },
  {
    "oid": "3e279fbd3e6a6a8d715c0a3d125ad916f94937c9",
    "message": "v4: Update BaseTest harness for changes to the runtime\n\n[git-p4: depot-paths = \"//depot/code/antlr4/main/\": change = 9382]",
    "date": "2011-11-18T03:46:29Z",
    "url": "https://github.com/antlr/antlr4/commit/3e279fbd3e6a6a8d715c0a3d125ad916f94937c9",
    "details": {
      "sha": "45ea7e370ed0109c0bd49b6c311ae14a8cc37992",
      "filename": "tool/test/org/antlr/v4/test/BaseTest.java",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/antlr/antlr4/blob/3e279fbd3e6a6a8d715c0a3d125ad916f94937c9/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FBaseTest.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/3e279fbd3e6a6a8d715c0a3d125ad916f94937c9/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FBaseTest.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FBaseTest.java?ref=3e279fbd3e6a6a8d715c0a3d125ad916f94937c9",
      "patch": "@@ -1015,14 +1015,14 @@ protected void writeTreeTestFile(String parserName,\n \t\t\t\"        <lexerName> lex = new <lexerName>(input);\\n\" +\n \t\t\t\"        TokenRewriteStream tokens = new TokenRewriteStream(lex);\\n\" +\n \t\t\t\"        <createParser>\\n\"+\n-\t\t\t\"        ParserRuleContext r = parser.<parserStartRuleName>();\\n\" +\n+\t\t\t\"        ASTContext\\\\<? extends CommonAST> r = parser.<parserStartRuleName>();\\n\" +\n \t\t\t\"        <if(!treeParserStartRuleName)>\\n\" +\n-\t\t\t\"        if ( r.tree!=null ) {\\n\" +\n-\t\t\t\"            System.out.println(((Tree)r.tree).toStringTree());\\n\" +\n-\t\t\t\"            Trees.sanityCheckParentAndChildIndexes((CommonAST)r.tree);\\n\" +\n+\t\t\t\"        if ( r.getTree()!=null ) {\\n\" +\n+\t\t\t\"            System.out.println(((Tree)r.getTree()).toStringTree());\\n\" +\n+\t\t\t\"            Trees.sanityCheckParentAndChildIndexes((CommonAST)r.getTree());\\n\" +\n \t\t\t\"\t\t }\\n\" +\n \t\t\t\"        <else>\\n\" +\n-\t\t\t\"        CommonASTNodeStream nodes = new CommonASTNodeStream((Tree)r.tree);\\n\" +\n+\t\t\t\"        CommonASTNodeStream nodes = new CommonASTNodeStream((Tree)r.getTree());\\n\" +\n \t\t\t\"        nodes.setTokenStream(tokens);\\n\" +\n \t\t\t\"        <treeParserName> walker = new <treeParserName>(nodes);\\n\" +\n \t\t\t\"        walker.<treeParserStartRuleName>();\\n\" +",
      "parent_sha": "ff97c91ef2b5414d04747c83d348df3b87d86a47"
    }
  },
  {
    "oid": "a70479ad0c41dc8c207604229a6ba165970e1be7",
    "message": "Fix ParserATNSimulator handling of EOF and rule stop states",
    "date": "2012-11-04T19:35:09Z",
    "url": "https://github.com/antlr/antlr4/commit/a70479ad0c41dc8c207604229a6ba165970e1be7",
    "details": {
      "sha": "13080d7c6dfd02fca9e2b427b63f53b682c75bbf",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java",
      "status": "modified",
      "additions": 9,
      "deletions": 1,
      "changes": 10,
      "blob_url": "https://github.com/antlr/antlr4/blob/a70479ad0c41dc8c207604229a6ba165970e1be7/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/a70479ad0c41dc8c207604229a6ba165970e1be7/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java?ref=a70479ad0c41dc8c207604229a6ba165970e1be7",
      "patch": "@@ -30,6 +30,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n package org.antlr.v4.runtime.atn;\n \n import org.antlr.v4.runtime.CommonTokenStream;\n+import org.antlr.v4.runtime.IntStream;\n import org.antlr.v4.runtime.NoViableAltException;\n import org.antlr.v4.runtime.Parser;\n import org.antlr.v4.runtime.ParserRuleContext;\n@@ -867,6 +868,11 @@ protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t,\n \t\t\t\t\tintermediate.add(new ATNConfig(c, target), mergeCache);\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\tif (t == IntStream.EOF && c.state instanceof RuleStopState) {\n+\t\t\t\tassert c.context.isEmpty();\n+\t\t\t\tintermediate.add(c, mergeCache);\n+\t\t\t}\n \t\t}\n \t\t// Now figure out where the closure can take us, but only if we'll\n \t\t// need to continue looking for more input.\n@@ -992,7 +998,9 @@ public List<DFAState.PredPrediction> getPredicatePredictions(BitSet ambigAlts,\n \tpublic int getAltThatFinishedDecisionEntryRule(ATNConfigSet configs) {\n \t\tIntervalSet alts = new IntervalSet();\n \t\tfor (ATNConfig c : configs) {\n-\t\t\tif ( c.reachesIntoOuterContext>0 ) alts.add(c.alt);\n+\t\t\tif ( c.reachesIntoOuterContext>0 || (c.state instanceof RuleStopState && c.context.hasEmptyPath()) ) {\n+\t\t\t\talts.add(c.alt);\n+\t\t\t}\n \t\t}\n \t\tif ( alts.size()==0 ) return ATN.INVALID_ALT_NUMBER;\n \t\treturn alts.getMinElement();",
      "parent_sha": "68b9798d6f543b93bb66502e4826b06218170c57"
    }
  },
  {
    "oid": "fab788b4bad467071c85cb034c6a350373f692d5",
    "message": "Cache LeftRecursiveRules.stg to static field\n\nSigned-off-by: Ivan Kochurkin <kvanttt@gmail.com>",
    "date": "2022-06-26T21:36:15Z",
    "url": "https://github.com/antlr/antlr4/commit/fab788b4bad467071c85cb034c6a350373f692d5",
    "details": {
      "sha": "fb5969bc36ee1861dd91efcaa712f990bbafd918",
      "filename": "tool/src/org/antlr/v4/analysis/LeftRecursiveRuleAnalyzer.java",
      "status": "modified",
      "additions": 16,
      "deletions": 13,
      "changes": 29,
      "blob_url": "https://github.com/antlr/antlr4/blob/fab788b4bad467071c85cb034c6a350373f692d5/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fanalysis%2FLeftRecursiveRuleAnalyzer.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/fab788b4bad467071c85cb034c6a350373f692d5/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fanalysis%2FLeftRecursiveRuleAnalyzer.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fanalysis%2FLeftRecursiveRuleAnalyzer.java?ref=fab788b4bad467071c85cb034c6a350373f692d5",
      "patch": "@@ -27,6 +27,7 @@\n import org.stringtemplate.v4.STGroup;\n import org.stringtemplate.v4.STGroupFile;\n \n+import java.io.FileNotFoundException;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.LinkedHashMap;\n@@ -55,12 +56,24 @@ public static enum ASSOC { left, right }\n \n \tpublic GrammarAST retvals;\n \n-\tpublic STGroup recRuleTemplates;\n-\tpublic STGroup codegenTemplates;\n-\tpublic String language;\n+\tpublic final static STGroup recRuleTemplates;\n+\tpublic final STGroup codegenTemplates;\n+\tpublic final String language;\n \n \tpublic Map<Integer, ASSOC> altAssociativity = new HashMap<Integer, ASSOC>();\n \n+\tstatic {\n+\t\tString templateGroupFile = \"org/antlr/v4/tool/templates/LeftRecursiveRules.stg\";\n+\t\trecRuleTemplates = new STGroupFile(templateGroupFile);\n+\t\tif (!recRuleTemplates.isDefined(\"recRule\")) {\n+\t\t\ttry {\n+\t\t\t\tthrow new FileNotFoundException(\"can't find code generation templates: LeftRecursiveRules\");\n+\t\t\t} catch (FileNotFoundException e) {\n+\t\t\t\te.printStackTrace();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tpublic LeftRecursiveRuleAnalyzer(GrammarAST ruleAST,\n \t\t\t\t\t\t\t\t\t Tool tool, String ruleName, String language)\n \t{\n@@ -73,16 +86,6 @@ public LeftRecursiveRuleAnalyzer(GrammarAST ruleAST,\n \t\t\tthrow new NullPointerException(\"grammar must have a token stream\");\n \t\t}\n \n-\t\tloadPrecRuleTemplates();\n-\t}\n-\n-\tpublic void loadPrecRuleTemplates() {\n-\t\tString templateGroupFile = \"org/antlr/v4/tool/templates/LeftRecursiveRules.stg\";\n-\t\trecRuleTemplates = new STGroupFile(templateGroupFile);\n-\t\tif ( !recRuleTemplates.isDefined(\"recRule\") ) {\n-\t\t\ttool.errMgr.toolError(ErrorType.MISSING_CODE_GEN_TEMPLATES, \"LeftRecursiveRules\");\n-\t\t}\n-\n \t\t// use codegen to get correct language templates; that's it though\n \t\tcodegenTemplates = CodeGenerator.create(tool, null, language).getTemplates();\n \t}",
      "parent_sha": "6a7e651c76215633a71af1fbcd9e0b9190de4e06"
    }
  },
  {
    "oid": "30d89abc4a26ae73e5dbbd849c8f8e4a7799e370",
    "message": "rm type param\n\n[git-p4: depot-paths = \"//depot/code/antlr4/main/\": change = 9462]",
    "date": "2011-11-26T02:16:46Z",
    "url": "https://github.com/antlr/antlr4/commit/30d89abc4a26ae73e5dbbd849c8f8e4a7799e370",
    "details": {
      "sha": "cf6d939dfb1ebad3e63dcfc9479d65cffe4c3059",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/BailErrorStrategy.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/antlr/antlr4/blob/30d89abc4a26ae73e5dbbd849c8f8e4a7799e370/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FBailErrorStrategy.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/30d89abc4a26ae73e5dbbd849c8f8e4a7799e370/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FBailErrorStrategy.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FBailErrorStrategy.java?ref=30d89abc4a26ae73e5dbbd849c8f8e4a7799e370",
      "patch": "@@ -32,7 +32,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n /** Bail out of parser at first syntax error. Do this to use it:\n  *      myparser.setErrorHandler(new BailErrorStrategy<Token>());\n  */\n-public class BailErrorStrategy<Symbol> extends DefaultErrorStrategy<Symbol> {\n+public class BailErrorStrategy extends DefaultErrorStrategy<Token> {\n     /** Instead of recovering from exception e, Re-throw wrote it wrapped\n      *  in a generic RuntimeException so it is not caught by the\n      *  rule function catches.  Exception e is the \"cause\" of the\n@@ -47,7 +47,7 @@ public void recover(BaseRecognizer recognizer, RecognitionException e) {\n      *  successfully recovers, it won't throw an exception.\n      */\n     @Override\n-    public Symbol recoverInline(BaseRecognizer recognizer)\n+    public Token recoverInline(BaseRecognizer recognizer)\n         throws RecognitionException\n     {\n         throw new RuntimeException(new InputMismatchException(recognizer));",
      "parent_sha": "fe1691da78540dcb4cf828655787c4a78154903d"
    }
  },
  {
    "oid": "d6e2e41c1f92e3f3fceac6948397b1aad2f9271d",
    "message": "Fix stop index",
    "date": "2012-04-01T19:29:06Z",
    "url": "https://github.com/antlr/antlr4/commit/d6e2e41c1f92e3f3fceac6948397b1aad2f9271d",
    "details": {
      "sha": "d324e836b0fd8206fa01673826fbe5ead50ccbbf",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/atn/ParserATNSimulator.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/antlr/antlr4/blob/d6e2e41c1f92e3f3fceac6948397b1aad2f9271d/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/d6e2e41c1f92e3f3fceac6948397b1aad2f9271d/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FParserATNSimulator.java?ref=d6e2e41c1f92e3f3fceac6948397b1aad2f9271d",
      "patch": "@@ -397,7 +397,7 @@ public int execDFA(@NotNull DFA dfa, @NotNull DFAState s0,\n \t\t\t\tif ( dfa_debug && t>=0 ) System.out.println(\"no edge for \"+parser.getTokenNames()[t]);\n \t\t\t\tint alt;\n \t\t\t\tif ( dfa_debug ) {\n-\t\t\t\t\tInterval interval = Interval.of(startIndex, parser.getTokenStream().size()-1);\n+\t\t\t\t\tInterval interval = Interval.of(startIndex, parser.getTokenStream().index());\n \t\t\t\t\tSystem.out.println(\"ATN exec upon \"+\n \t\t\t\t\t\t\t\t\t   parser.getTokenStream().getText(interval) +\n \t\t\t\t\t\t\t\t\t   \" at DFA state \"+s.stateNumber);",
      "parent_sha": "e1870d16e9cd29dd4b4e1f3decd3ecb7af76e49b"
    }
  },
  {
    "oid": "daf793b1c149bc6d4d2d360f42d387067ede87c4",
    "message": "ParserInterpreter handles RecognitionException in the same way as the generated code",
    "date": "2014-01-26T18:50:55Z",
    "url": "https://github.com/antlr/antlr4/commit/daf793b1c149bc6d4d2d360f42d387067ede87c4",
    "details": {
      "sha": "2987697afc122ba38caeb358d7766a984693c0ca",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/ParserInterpreter.java",
      "status": "modified",
      "additions": 10,
      "deletions": 1,
      "changes": 11,
      "blob_url": "https://github.com/antlr/antlr4/blob/daf793b1c149bc6d4d2d360f42d387067ede87c4/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FParserInterpreter.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/daf793b1c149bc6d4d2d360f42d387067ede87c4/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FParserInterpreter.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FParserInterpreter.java?ref=daf793b1c149bc6d4d2d360f42d387067ede87c4",
      "patch": "@@ -156,7 +156,16 @@ public ParserRuleContext parse(int startRuleIndex) {\n \t\t\t\tbreak;\n \n \t\t\tdefault :\n-\t\t\t\tvisitState(p);\n+\t\t\t\ttry {\n+\t\t\t\t\tvisitState(p);\n+\t\t\t\t}\n+\t\t\t\tcatch (RecognitionException e) {\n+\t\t\t\t\tsetState(atn.ruleToStopState[p.ruleIndex].stateNumber);\n+\t\t\t\t\tgetContext().exception = e;\n+\t\t\t\t\tgetErrorHandler().reportError(this, e);\n+\t\t\t\t\tgetErrorHandler().recover(this, e);\n+\t\t\t\t}\n+\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}",
      "parent_sha": "ddbd7086b8a16f1e9237d933285e71edb35f7429"
    }
  },
  {
    "oid": "62333178ffc56a891e7e53b38231e9eb3cd25a57",
    "message": "node->nodejs executable",
    "date": "2015-06-22T19:29:51Z",
    "url": "https://github.com/antlr/antlr4/commit/62333178ffc56a891e7e53b38231e9eb3cd25a57",
    "details": {
      "sha": "9e9311dd1d7510e509ada9ba933136572bf61498",
      "filename": "tool/test/org/antlr/v4/test/runtime/javascript/node/BaseTest.java",
      "status": "modified",
      "additions": 13,
      "deletions": 7,
      "changes": 20,
      "blob_url": "https://github.com/antlr/antlr4/blob/62333178ffc56a891e7e53b38231e9eb3cd25a57/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fjavascript%2Fnode%2FBaseTest.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/62333178ffc56a891e7e53b38231e9eb3cd25a57/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fjavascript%2Fnode%2FBaseTest.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Fruntime%2Fjavascript%2Fnode%2FBaseTest.java?ref=62333178ffc56a891e7e53b38231e9eb3cd25a57",
      "patch": "@@ -403,7 +403,8 @@ public String execModule(String fileName) {\n \t\t\t\tSystem.err.println(\"exec stderrVacuum: \" + stderrVacuum);\n \t\t\t}\n \t\t\treturn output;\n-\t\t} catch (Exception e) {\n+\t\t}\n+\t\tcatch (Exception e) {\n \t\t\tSystem.err.println(\"can't exec recognizer\");\n \t\t\te.printStackTrace(System.err);\n \t\t}\n@@ -413,8 +414,9 @@ public String execModule(String fileName) {\n \tprivate String locateTool(String tool) {\n \t\tString[] roots = { \"/usr/bin/\", \"/usr/local/bin/\" };\n \t\tfor (String root : roots) {\n-\t\t\tif (new File(root + tool).exists())\n+\t\t\tif (new File(root + tool).exists()) {\n \t\t\t\treturn root + tool;\n+\t\t\t}\n \t\t}\n \t\tthrow new RuntimeException(\"Could not locate \" + tool);\n \t}\n@@ -423,22 +425,26 @@ private String locateNodeJS() {\n \t\t// typically /usr/local/bin/node\n \t\tString propName = \"antlr-javascript-nodejs\";\n \t\tString prop = System.getProperty(propName);\n-\t\tif (prop == null || prop.length() == 0)\n-\t\t\tprop = locateTool(\"node\");\n+\t\tif (prop == null || prop.length() == 0) {\n+\t\t\tprop = locateTool(\"nodejs\");\n+\t\t}\n \t\tFile file = new File(prop);\n-\t\tif (!file.exists())\n+\t\tif (!file.exists()) {\n \t\t\tthrow new RuntimeException(\"Missing system property:\" + propName);\n+\t\t}\n \t\treturn prop;\n \t}\n \n \tprivate String locateRuntime() {\n \t\tString propName = \"antlr-javascript-runtime\";\n \t\tString prop = System.getProperty(propName);\n-\t\tif (prop == null || prop.length() == 0)\n+\t\tif (prop == null || prop.length() == 0) {\n \t\t\tprop = \"../../antlr4-javascript/src\";\n+\t\t}\n \t\tFile file = new File(prop);\n-\t\tif (!file.exists())\n+\t\tif (!file.exists()) {\n \t\t\tthrow new RuntimeException(\"Missing system property:\" + propName);\n+\t\t}\n \t\treturn file.getAbsolutePath();\n \t}\n ",
      "parent_sha": "b8b317ce6908097aa0e274d680a856a14f4da413"
    }
  },
  {
    "oid": "d2f7ba83391a563d4fe1c2bb45b6303b9a17cdea",
    "message": "cleanup",
    "date": "2013-09-05T00:25:14Z",
    "url": "https://github.com/antlr/antlr4/commit/d2f7ba83391a563d4fe1c2bb45b6303b9a17cdea",
    "details": {
      "sha": "cb92c8c4b5225a45048cfeabcebe3769394d6cfc",
      "filename": "tool/test/org/antlr/v4/test/TestParseTreeMatcher.java",
      "status": "modified",
      "additions": 69,
      "deletions": 28,
      "changes": 97,
      "blob_url": "https://github.com/antlr/antlr4/blob/d2f7ba83391a563d4fe1c2bb45b6303b9a17cdea/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestParseTreeMatcher.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/d2f7ba83391a563d4fe1c2bb45b6303b9a17cdea/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestParseTreeMatcher.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestParseTreeMatcher.java?ref=d2f7ba83391a563d4fe1c2bb45b6303b9a17cdea",
      "patch": "@@ -12,18 +12,59 @@\n \n public class TestParseTreeMatcher extends BaseTest {\n \t@Test public void testChunking() throws Exception {\n-\t\t// tests\n \t\tParseTreePatternMatcher p = new ParseTreePatternMatcher();\n-\t\tSystem.out.println( p.split(\"<ID> = <expr> ;\") );\n-\t\tSystem.out.println( p.split(\" <ID> = <expr>\") );\n-\t\tSystem.out.println( p.split(\"<ID> = <expr>\") );\n-\t\tSystem.out.println( p.split(\"<expr>\") );\n-\t\tSystem.out.println(p.split(\"\\\\<x\\\\> foo\"));\n-\t\tSystem.out.println(p.split(\"foo \\\\<x\\\\> bar <tag>\"));\n-//\t\tSystem.out.println( p.split(\">expr<\") );\n+\t\tassertEquals(\"[ID, ' = ', expr, ' ;']\", p.split(\"<ID> = <expr> ;\").toString());\n+\t\tassertEquals(\"[' ', ID, ' = ', expr]\", p.split(\" <ID> = <expr>\").toString());\n+\t\tassertEquals(\"[ID, ' = ', expr]\", p.split(\"<ID> = <expr>\").toString());\n+\t\tassertEquals(\"[expr]\", p.split(\"<expr>\").toString());\n+\t\tassertEquals(\"['<x> foo']\", p.split(\"\\\\<x\\\\> foo\").toString());\n+\t\tassertEquals(\"['foo <x> bar ', tag]\", p.split(\"foo \\\\<x\\\\> bar <tag>\").toString());\n+\t}\n \n+\t@Test public void testDelimiters() throws Exception {\n+\t\tParseTreePatternMatcher p = new ParseTreePatternMatcher();\n \t\tp.setDelimiters(\"<<\", \">>\", \"$\");\n-\t\tSystem.out.println(p.split(\"<<ID>> = <<expr>> ;$<< ick $>>\"));\n+\t\tString result = p.split(\"<<ID>> = <<expr>> ;$<< ick $>>\").toString();\n+\t\tassertEquals(\"[ID, ' = ', expr, ' ;<< ick >>']\", result);\n+\t}\n+\n+\t@Test public void testInvertedTags() throws Exception {\n+\t\tParseTreePatternMatcher p = new ParseTreePatternMatcher();\n+\t\tString result = null;\n+\t\ttry {\n+\t\t\tp.split(\">expr<\");\n+\t\t}\n+\t\tcatch (IllegalArgumentException iae) {\n+\t\t\tresult = iae.getMessage();\n+\t\t}\n+\t\tString expected = \"tag delimiters out of order in pattern: >expr<\";\n+\t\tassertEquals(expected, result);\n+\t}\n+\n+\t@Test public void testUnclosedTag() throws Exception {\n+\t\tParseTreePatternMatcher p = new ParseTreePatternMatcher();\n+\t\tString result = null;\n+\t\ttry {\n+\t\t\tp.split(\"<expr hi mom\");\n+\t\t}\n+\t\tcatch (IllegalArgumentException iae) {\n+\t\t\tresult = iae.getMessage();\n+\t\t}\n+\t\tString expected = \"unterminated tag in pattern: <expr hi mom\";\n+\t\tassertEquals(expected, result);\n+\t}\n+\n+\t@Test public void testExtraClose() throws Exception {\n+\t\tParseTreePatternMatcher p = new ParseTreePatternMatcher();\n+\t\tString result = null;\n+\t\ttry {\n+\t\t\tp.split(\"<expr> >\");\n+\t\t}\n+\t\tcatch (IllegalArgumentException iae) {\n+\t\t\tresult = iae.getMessage();\n+\t\t}\n+\t\tString expected = \"missing start tag in pattern: <expr> >\";\n+\t\tassertEquals(expected, result);\n \t}\n \n \t@Test public void testTokenizingPattern() throws Exception {\n@@ -44,7 +85,7 @@ public class TestParseTreeMatcher extends BaseTest {\n \n \t\tList<? extends Token> tokens = p.tokenizePattern(\"<ID> = <expr> ;\");\n \t\tString results = tokens.toString();\n-\t\tString expected = \"[ID:3, [@-1,1:1='=',<1>,1:1], expr:1, [@-1,0:0=';',<2>,1:0]]\";\n+\t\tString expected = \"[ID:3, [@-1,1:1='=',<1>,1:1], expr:1, [@-1,1:1=';',<2>,1:1]]\";\n \t\tassertEquals(expected, results);\n \t}\n \n@@ -71,24 +112,6 @@ public void testCompilingPattern() throws Exception {\n \t\tassertEquals(expected, results);\n \t}\n \n-\tpublic void checkPatternMatch(String grammarName, String grammar, String startRule,\n-\t\t\t\t\t\t\t\t  String input, String pattern,\n-\t\t\t\t\t\t\t\t  String parserName, String lexerName)\n-\t\tthrows Exception\n-\t{\n-\t\tboolean ok =\n-\t\t\trawGenerateAndBuildRecognizer(grammarName, grammar, parserName, lexerName, false);\n-\t\tassertTrue(ok);\n-\n-\t\tParseTree result = execParser(startRule, input, parserName, lexerName);\n-\n-\t\tParseTreePatternMatcher p =\n-\t\t\tnew ParseTreePatternMatcher(loadLexerClassFromTempDir(lexerName),\n-\t\t\t\t\t\t\t\t\t\tloadParserClassFromTempDir(parserName));\n-\t\tboolean matches = p.matches(result, startRule, pattern);\n-\t\tassertTrue(matches);\n-\t}\n-\n \t@Test public void testIDNodeMatches() throws Exception {\n \t\tString grammar =\n \t\t\t\"grammar T;\\n\" +\n@@ -114,4 +137,22 @@ public void checkPatternMatch(String grammarName, String grammar, String startRu\n \t\tString pattern = \"<ID> = <expr> ;\";\n \t\tcheckPatternMatch(\"T.g4\", grammar, \"s\", input, pattern, \"TParser\", \"TLexer\");\n \t}\n+\n+\tpublic void checkPatternMatch(String grammarName, String grammar, String startRule,\n+\t\t\t\t\t\t\t\t  String input, String pattern,\n+\t\t\t\t\t\t\t\t  String parserName, String lexerName)\n+\t\tthrows Exception\n+\t{\n+\t\tboolean ok =\n+\t\t\trawGenerateAndBuildRecognizer(grammarName, grammar, parserName, lexerName, false);\n+\t\tassertTrue(ok);\n+\n+\t\tParseTree result = execParser(startRule, input, parserName, lexerName);\n+\n+\t\tParseTreePatternMatcher p =\n+\t\t\tnew ParseTreePatternMatcher(loadLexerClassFromTempDir(lexerName),\n+\t\t\t\t\t\t\t\t\t\tloadParserClassFromTempDir(parserName));\n+\t\tboolean matches = p.matches(result, startRule, pattern);\n+\t\tassertTrue(matches);\n+\t}\n }",
      "parent_sha": "4b87f84b99749b8ef0b04b87a08df7c4dcc89492"
    }
  },
  {
    "oid": "06b27b82448ea27c2cba603efab19cd142a43db5",
    "message": "added stub for ID*[','] if we want that syntax\n\n[git-p4: depot-paths = \"//depot/code/antlr4/main/\": change = 9455]",
    "date": "2011-11-25T20:13:29Z",
    "url": "https://github.com/antlr/antlr4/commit/06b27b82448ea27c2cba603efab19cd142a43db5",
    "details": {
      "sha": "bb3f7e56cad698203379ca8ca45bdbd5e8e30c56",
      "filename": "tool/src/org/antlr/v4/tool/GrammarTransformPipeline.java",
      "status": "modified",
      "additions": 37,
      "deletions": 10,
      "changes": 47,
      "blob_url": "https://github.com/antlr/antlr4/blob/06b27b82448ea27c2cba603efab19cd142a43db5/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Ftool%2FGrammarTransformPipeline.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/06b27b82448ea27c2cba603efab19cd142a43db5/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Ftool%2FGrammarTransformPipeline.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Ftool%2FGrammarTransformPipeline.java?ref=06b27b82448ea27c2cba603efab19cd142a43db5",
      "patch": "@@ -51,28 +51,55 @@ public GrammarTransformPipeline(Grammar g, Tool tool) {\n \t}\n \n \tpublic void process() {\n-\t\tGrammarRootAST ast = g.ast;\n-\t\tif ( ast==null ) return;\n-        tool.log(\"grammar\", \"before: \"+ast.toStringTree());\n+\t\tGrammarRootAST root = g.ast;\n+\t\tif ( root==null ) return;\n+        tool.log(\"grammar\", \"before: \"+root.toStringTree());\n \n         integrateImportedGrammars(g);\n-\t\tif ( ast.grammarType==ANTLRParser.PARSER || ast.grammarType==ANTLRParser.COMBINED ) {\n-\t\t\ttranslateLeftRecursiveRules(ast);\n+\t\tif ( root.grammarType==ANTLRParser.PARSER || root.grammarType==ANTLRParser.COMBINED ) {\n+\t\t\ttranslateLeftRecursiveRules(root);\n \t\t}\n-\t\treduceBlocksToSets(ast);\n+\t\treduceBlocksToSets(root);\n+        expandParameterizedLoops(root);\n \n-        tool.log(\"grammar\", \"after: \"+ast.toStringTree());\n+        tool.log(\"grammar\", \"after: \"+root.toStringTree());\n \t}\n \n-\tpublic void reduceBlocksToSets(GrammarRootAST ast) {\n+\tpublic void reduceBlocksToSets(GrammarRootAST root) {\n \t\torg.antlr.runtime.tree.CommonTreeNodeStream nodes =\n-\t\t\tnew org.antlr.runtime.tree.CommonTreeNodeStream(ast);\n+\t\t\tnew org.antlr.runtime.tree.CommonTreeNodeStream(root);\n \t\tGrammarASTAdaptor adaptor = new GrammarASTAdaptor();\n \t\tBlockSetTransformer transformer = new BlockSetTransformer(nodes, g);\n \t\ttransformer.setTreeAdaptor(adaptor);\n-\t\ttransformer.downup(ast);\n+\t\ttransformer.downup(root);\n \t}\n \n+    /** Find and replace\n+     *      ID*[','] with ID (',' ID)*\n+     *      ID+[','] with ID (',' ID)+\n+     *      (x {action} y)+[','] with x {action} y (',' x {action} y)+\n+     *\n+     *  Parameter must be a token.\n+     *  todo: do we want?\n+     */\n+    public void expandParameterizedLoops(GrammarRootAST root) {\n+        TreeVisitor v = new TreeVisitor(new GrammarASTAdaptor());\n+        v.visit(root, new TreeVisitorAction() {\n+            public Object pre(Object t) {\n+                if ( ((GrammarAST)t).getType() == 3 ) {\n+                    return expandParameterizedLoop((GrammarAST)t);\n+                }\n+                return t;\n+            }\n+            public Object post(Object t) { return t; }\n+        });\n+    }\n+\n+    public GrammarAST expandParameterizedLoop(GrammarAST t) {\n+        // todo: update grammar, alter AST\n+        return t;\n+    }\n+\n \tpublic void translateLeftRecursiveRules(GrammarRootAST ast) {\n \t\tString language = Grammar.getLanguageOption(ast);\n \t\tfor (GrammarAST r : ast.getNodesWithType(ANTLRParser.RULE)) {",
      "parent_sha": "3b543098aa6c509920572d1650987c39c3e80dd3"
    }
  },
  {
    "oid": "e2db920cced1ff26827f7e113c2bbcad54a6191a",
    "message": "msg.e -> msg.getCause()\n\n[git-p4: depot-paths = \"//depot/code/antlr4/main/\": change = 9218]",
    "date": "2011-10-27T18:12:41Z",
    "url": "https://github.com/antlr/antlr4/commit/e2db920cced1ff26827f7e113c2bbcad54a6191a",
    "details": {
      "sha": "8f6a884e76c8ce94a4453eb381f6203c8901144c",
      "filename": "tool/src/org/antlr/v4/tool/ErrorManager.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/antlr/antlr4/blob/e2db920cced1ff26827f7e113c2bbcad54a6191a/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Ftool%2FErrorManager.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/e2db920cced1ff26827f7e113c2bbcad54a6191a/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Ftool%2FErrorManager.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Ftool%2FErrorManager.java?ref=e2db920cced1ff26827f7e113c2bbcad54a6191a",
      "patch": "@@ -99,9 +99,9 @@ public ST getMessageTemplate(ANTLRMessage msg) {\n \t\t\t}\n \t\t\tif ( msg.args.length<2 ) messageST.add(\"arg2\", null); // some messages ref arg2\n \t\t}\n-\t\tif ( msg.e!=null ) {\n-\t\t\tmessageST.add(\"exception\", msg.e);\n-\t\t\tmessageST.add(\"stackTrace\", msg.e.getStackTrace());\n+\t\tif ( msg.getCause()!=null ) {\n+\t\t\tmessageST.add(\"exception\", msg.getCause());\n+\t\t\tmessageST.add(\"stackTrace\", msg.getCause().getStackTrace());\n \t\t}\n \t\telse {\n \t\t\tmessageST.add(\"exception\", null); // avoid ST error msg",
      "parent_sha": "bedb935bdebc5fb79581a7d6fa44b7d092126997"
    }
  },
  {
    "oid": "77342c2256a9de766b6bc7ed8e9080b0817bd35a",
    "message": "Added links to documentation",
    "date": "2014-01-23T13:12:53Z",
    "url": "https://github.com/antlr/antlr4/commit/77342c2256a9de766b6bc7ed8e9080b0817bd35a",
    "details": {
      "sha": "591371845ec78407264021be32a002af7edd54c0",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/TokenStreamRewriter.java",
      "status": "modified",
      "additions": 16,
      "deletions": 14,
      "changes": 30,
      "blob_url": "https://github.com/antlr/antlr4/blob/77342c2256a9de766b6bc7ed8e9080b0817bd35a/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FTokenStreamRewriter.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/77342c2256a9de766b6bc7ed8e9080b0817bd35a/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FTokenStreamRewriter.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FTokenStreamRewriter.java?ref=77342c2256a9de766b6bc7ed8e9080b0817bd35a",
      "patch": "@@ -43,30 +43,32 @@\n  *\n  * <p>\n  * You can insert stuff, replace, and delete chunks. Note that the operations\n- * are done lazily--only if you convert the buffer to a String with getText().\n- * This is very efficient because you are not moving data around all the time.\n- * As the buffer of tokens is converted to strings, the getText() method(s) scan\n- * the input token stream and check to see if there is an operation at the\n- * current index. If so, the operation is done and then normal String rendering\n- * continues on the buffer. This is like having multiple Turing machine\n- * instruction streams (programs) operating on a single input tape. :)</p>\n+ * are done lazily--only if you convert the buffer to a {@link String} with\n+ * {@link TokenStream#getText()}. This is very efficient because you are not\n+ * moving data around all the time. As the buffer of tokens is converted to\n+ * strings, the {@link #getText()} method(s) scan the input token stream and\n+ * check to see if there is an operation at the current index. If so, the\n+ * operation is done and then normal {@link String} rendering continues on the\n+ * buffer. This is like having multiple Turing machine instruction streams\n+ * (programs) operating on a single input tape. :)</p>\n  *\n  * <p>\n  * This rewriter makes no modifications to the token stream. It does not ask the\n  * stream to fill itself up nor does it advance the input cursor. The token\n- * stream index() will return the same value before and after any getText()\n- * call.</p>\n+ * stream {@link TokenStream#index()} will return the same value before and\n+ * after any {@link #getText()} call.</p>\n  *\n  * <p>\n  * The rewriter only works on tokens that you have in the buffer and ignores the\n  * current input cursor. If you are buffering tokens on-demand, calling\n- * getText() halfway through the input will only do rewrites for those tokens in\n- * the first half of the file.</p>\n+ * {@link #getText()} halfway through the input will only do rewrites for those\n+ * tokens in the first half of the file.</p>\n  *\n  * <p>\n- * Since the operations are done lazily at getText-time, operations do not screw\n- * up the token index values. That is, an insert operation at token index i does\n- * not change the index values for tokens i+1..n-1.</p>\n+ * Since the operations are done lazily at {@link #getText}-time, operations do\n+ * not screw up the token index values. That is, an insert operation at token\n+ * index {@code i} does not change the index values for tokens\n+ * {@code i}+1..n-1.</p>\n  *\n  * <p>\n  * Because operations never actually alter the buffer, you may always get the",
      "parent_sha": "0949ff824982128273ae838c2430ce58e5beb9ac"
    }
  },
  {
    "oid": "9420672520ebf8397af0ecb50c50c1b4e891983c",
    "message": "make explicit that graphs must be EmptyContext, never null (Coverity)",
    "date": "2013-08-31T23:29:40Z",
    "url": "https://github.com/antlr/antlr4/commit/9420672520ebf8397af0ecb50c50c1b4e891983c",
    "details": {
      "sha": "fb21cc7b993fec198946ffd782bc0e96a8e2c9fc",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/atn/PredictionContext.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/antlr/antlr4/blob/9420672520ebf8397af0ecb50c50c1b4e891983c/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FPredictionContext.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/9420672520ebf8397af0ecb50c50c1b4e891983c/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FPredictionContext.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FPredictionContext.java?ref=9420672520ebf8397af0ecb50c50c1b4e891983c",
      "patch": "@@ -173,8 +173,10 @@ public static PredictionContext merge(\n \t\tboolean rootIsWildcard,\n \t\tDoubleKeyMap<PredictionContext,PredictionContext,PredictionContext> mergeCache)\n \t{\n+\t\tassert a!=null && b!=null; // must be empty context, never null\n+\n \t\t// share same graph if both same\n-\t\tif ( (a==null&&b==null) || a==b || (a!=null&&a.equals(b)) ) return a;\n+\t\tif ( a==b || a.equals(b) ) return a;\n \n \t\tif ( a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {\n \t\t\treturn mergeSingletons((SingletonPredictionContext)a,",
      "parent_sha": "0ac47437bc54c7fc42408335b4005e2f2af2d2d0"
    }
  },
  {
    "oid": "afed3ac34969c21859084b6ddafb229709c5b20b",
    "message": "Remove unnecessary null checks",
    "date": "2012-10-29T18:31:58Z",
    "url": "https://github.com/antlr/antlr4/commit/afed3ac34969c21859084b6ddafb229709c5b20b",
    "details": {
      "sha": "01b058a6346daca2f05a377466a8662f74027168",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/atn/LexerATNSimulator.java",
      "status": "modified",
      "additions": 13,
      "deletions": 17,
      "changes": 30,
      "blob_url": "https://github.com/antlr/antlr4/blob/afed3ac34969c21859084b6ddafb229709c5b20b/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FLexerATNSimulator.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/afed3ac34969c21859084b6ddafb229709c5b20b/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FLexerATNSimulator.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FLexerATNSimulator.java?ref=afed3ac34969c21859084b6ddafb229709c5b20b",
      "patch": "@@ -298,20 +298,18 @@ protected int execATN(@NotNull CharStream input, @NotNull ATNConfigSet s0, @NotN\n \t\t\t// that already has lots of edges out of it. e.g., .* in comments.\n \t\t\tDFAState target = null;\n \t\t\tATNConfigSet reach = null;\n-\t\t\tif (s != null) {\n-\t\t\t\tif ( s.edges != null && t < s.edges.length && t > IntStream.EOF ) {\n-\t\t\t\t\tclosure = s.configs;\n-\t\t\t\t\ttarget = s.edges[t];\n-\t\t\t\t\tif (target == ERROR) {\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t\telse if (target != null) {\n-\t\t\t\t\t\tif ( debug ) {\n-\t\t\t\t\t\t\tSystem.out.println(\"reuse state \"+s.stateNumber+\n-\t\t\t\t\t\t\t\t\t\t\t   \" edge to \"+target.stateNumber);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\treach = target.configs;\n+\t\t\tif ( s.edges != null && t < s.edges.length && t > IntStream.EOF ) {\n+\t\t\t\tclosure = s.configs;\n+\t\t\t\ttarget = s.edges[t];\n+\t\t\t\tif (target == ERROR) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\telse if (target != null) {\n+\t\t\t\t\tif ( debug ) {\n+\t\t\t\t\t\tSystem.out.println(\"reuse state \"+s.stateNumber+\n+\t\t\t\t\t\t\t\t\t\t   \" edge to \"+target.stateNumber);\n \t\t\t\t\t}\n+\t\t\t\t\treach = target.configs;\n \t\t\t\t}\n \t\t\t}\n \n@@ -330,9 +328,7 @@ else if (target != null) {\n \t\t\t\t\tDFAState from = s != null ? s : addDFAState(closure);\n \t\t\t\t\t// we got nowhere on t, don't throw out this knowledge; it'd\n \t\t\t\t\t// cause a failover from DFA later.\n-\t\t\t\t\tif (from != null) {\n-\t\t\t\t\t\taddDFAEdge(from, t, ERROR);\n-\t\t\t\t\t}\n+\t\t\t\t\taddDFAEdge(from, t, ERROR);\n \t\t\t\t\tbreak; // stop when we can't match any more char\n \t\t\t\t}\n \n@@ -694,7 +690,7 @@ protected DFAState addDFAEdge(@NotNull DFAState from,\n \t\t\treturn to;\n \t\t}\n \n-\t\tif (from == null || to == null || suppressEdge) {\n+\t\tif (suppressEdge) {\n \t\t\treturn to;\n \t\t}\n ",
      "parent_sha": "d17f9191234183873862b585a8ab93cf99e291a1"
    }
  },
  {
    "oid": "4c1e9b4119647cb125e1c99cb952fe3af3c7438f",
    "message": "Improve performance of equals",
    "date": "2012-07-20T19:51:55Z",
    "url": "https://github.com/antlr/antlr4/commit/4c1e9b4119647cb125e1c99cb952fe3af3c7438f",
    "details": {
      "sha": "9058323d6d25d49e76de269d3b73287cece250f3",
      "filename": "tool/src/org/antlr/v4/codegen/model/decl/ContextGetterDecl.java",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/antlr/antlr4/blob/4c1e9b4119647cb125e1c99cb952fe3af3c7438f/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fcodegen%2Fmodel%2Fdecl%2FContextGetterDecl.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/4c1e9b4119647cb125e1c99cb952fe3af3c7438f/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fcodegen%2Fmodel%2Fdecl%2FContextGetterDecl.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fcodegen%2Fmodel%2Fdecl%2FContextGetterDecl.java?ref=4c1e9b4119647cb125e1c99cb952fe3af3c7438f",
      "patch": "@@ -52,11 +52,9 @@ public int hashCode() {\n \t */\n \t@Override\n \tpublic boolean equals(Object obj) {\n-\t\tif ( obj==null ) return false;\n+\t\tif ( this==obj ) return true;\n \t\t// A() and label A are different\n \t\tif ( !(obj instanceof ContextGetterDecl) ) return false;\n-\t\tif ( this==obj ) return true;\n-\t\tif ( this.hashCode() != obj.hashCode() ) return false;\n \t\treturn\n \t\t\tname.equals(((Decl) obj).name) &&\n \t\t\t\tgetArgType().equals(((ContextGetterDecl) obj).getArgType());",
      "parent_sha": "45e42d724318ae32626de31a0d87d7dcf7548bdf"
    }
  },
  {
    "oid": "5279b250caa563ed41cbf7d940850d110162679b",
    "message": "Use isEmpty() instead of size()==0, use StringBuilder instead of StringBuffer, use chained append() calls instead of string concatenation, remove unnecessary initializations.",
    "date": "2012-02-09T01:01:28Z",
    "url": "https://github.com/antlr/antlr4/commit/5279b250caa563ed41cbf7d940850d110162679b",
    "details": {
      "sha": "fa55ace2f18aa254b2dc41acd2116a1398de2ec2",
      "filename": "tool/src/org/antlr/v4/tool/DOTGenerator.java",
      "status": "modified",
      "additions": 6,
      "deletions": 7,
      "changes": 13,
      "blob_url": "https://github.com/antlr/antlr4/blob/5279b250caa563ed41cbf7d940850d110162679b/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Ftool%2FDOTGenerator.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/5279b250caa563ed41cbf7d940850d110162679b/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Ftool%2FDOTGenerator.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Ftool%2FDOTGenerator.java?ref=5279b250caa563ed41cbf7d940850d110162679b",
      "patch": "@@ -109,11 +109,11 @@ public String getDOT(DFA dfa, boolean isLexer) {\n \n \tprotected String getStateLabel(DFAState s) {\n \t\tif ( s==null ) return \"null\";\n-\t\tStringBuffer buf = new StringBuffer(250);\n+\t\tStringBuilder buf = new StringBuilder(250);\n \t\tbuf.append('s');\n \t\tbuf.append(s.stateNumber);\n \t\tif ( s.isAcceptState ) {\n-\t\t\tbuf.append(\"=>\"+s.prediction);\n+\t\t\tbuf.append(\"=>\").append(s.prediction);\n \t\t}\n \t\tif ( grammar!=null && grammar.tool.verbose_dfa ) {\n \t\t\tSet<Integer> alts = s.getAltSet();\n@@ -135,8 +135,8 @@ protected String getStateLabel(DFAState s) {\n \t\t\t\t\t// get a list of configs for just this alt\n \t\t\t\t\t// it will help us print better later\n \t\t\t\t\tList<ATNConfig> configsInAlt = new ArrayList<ATNConfig>();\n-\t\t\t\t\tfor (Iterator it = configurations.iterator(); it.hasNext();) {\n-\t\t\t\t\t\tATNConfig c = (ATNConfig) it.next();\n+\t\t\t\t\tfor (Iterator<ATNConfig> it = configurations.iterator(); it.hasNext();) {\n+\t\t\t\t\t\tATNConfig c = it.next();\n \t\t\t\t\t\tif ( c.alt!=alt ) continue;\n \t\t\t\t\t\tconfigsInAlt.add(c);\n \t\t\t\t\t}\n@@ -179,9 +179,8 @@ public String getDOT(ATNState startState, String[] ruleNames, boolean isLexer) {\n \t\tif ( startState==null )\treturn null;\n \n \t\t// The output DOT graph for visualization\n-\t\tST dot = null;\n \t\tSet<ATNState> markedStates = new HashSet<ATNState>();\n-\t\tdot = stlib.getInstanceOf(\"atn\");\n+\t\tST dot = stlib.getInstanceOf(\"atn\");\n \t\tdot.add(\"startState\", startState.stateNumber);\n \t\tdot.add(\"rankdir\", rankdir);\n \n@@ -211,7 +210,7 @@ public String getDOT(ATNState startState, String[] ruleNames, boolean isLexer) {\n //\t\t\t}\n \n \t\t\t// make a DOT edge for each transition\n-\t\t\tST edgeST = null;\n+\t\t\tST edgeST;\n \t\t\tfor (int i = 0; i < s.getNumberOfTransitions(); i++) {\n \t\t\t\tTransition edge = s.transition(i);\n \t\t\t\tif ( edge instanceof RuleTransition ) {",
      "parent_sha": "3b4ae2a7422c5b3084ca43ec8096ceebd7df20a4"
    }
  },
  {
    "oid": "850abe1c8143d7c28edb8377220572d596b0fd84",
    "message": "IntervalSet perf: Use binary search for IntervalSet.contains(el)",
    "date": "2017-03-24T19:19:38Z",
    "url": "https://github.com/antlr/antlr4/commit/850abe1c8143d7c28edb8377220572d596b0fd84",
    "details": {
      "sha": "d6723f3afe04ab8a21d1947590e3abc73f00075a",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/misc/IntervalSet.java",
      "status": "modified",
      "additions": 13,
      "deletions": 19,
      "changes": 32,
      "blob_url": "https://github.com/antlr/antlr4/blob/850abe1c8143d7c28edb8377220572d596b0fd84/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fmisc%2FIntervalSet.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/850abe1c8143d7c28edb8377220572d596b0fd84/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fmisc%2FIntervalSet.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fmisc%2FIntervalSet.java?ref=850abe1c8143d7c28edb8377220572d596b0fd84",
      "patch": "@@ -384,30 +384,24 @@ else if ( theirs.startsAfterNonDisjoint(mine) ) {\n     @Override\n     public boolean contains(int el) {\n \t\tint n = intervals.size();\n-\t\tfor (int i = 0; i < n; i++) {\n-\t\t\tInterval I = intervals.get(i);\n+\t\tint l = 0;\n+\t\tint r = n - 1;\n+\t\t// Binary search for the element in the (sorted,\n+\t\t// disjoint) array of intervals.\n+\t\twhile (l <= r) {\n+\t\t\tint m = (l + r) / 2;\n+\t\t\tInterval I = intervals.get(m);\n \t\t\tint a = I.a;\n \t\t\tint b = I.b;\n-\t\t\tif ( el<a ) {\n-\t\t\t\tbreak; // list is sorted and el is before this interval; not here\n-\t\t\t}\n-\t\t\tif ( el>=a && el<=b ) {\n-\t\t\t\treturn true; // found in this interval\n+\t\t\tif ( b<el ) {\n+\t\t\t\tl = m + 1;\n+\t\t\t} else if ( a>el ) {\n+\t\t\t\tr = m - 1;\n+\t\t\t} else { // el >= a && el <= b\n+\t\t\t\treturn true;\n \t\t\t}\n \t\t}\n \t\treturn false;\n-/*\n-\t\tfor (ListIterator iter = intervals.listIterator(); iter.hasNext();) {\n-            Interval I = (Interval) iter.next();\n-            if ( el<I.a ) {\n-                break; // list is sorted and el is before this interval; not here\n-            }\n-            if ( el>=I.a && el<=I.b ) {\n-                return true; // found in this interval\n-            }\n-        }\n-        return false;\n-        */\n     }\n \n     /** {@inheritDoc} */",
      "parent_sha": "0713128d04e42c9a23faf944f5513370664cb4ab"
    }
  },
  {
    "oid": "cc0d0506224774d3b435ea44da75a79133a6264a",
    "message": "Display the current pass number in TestPerformance result summary (helps monitor progress on very long runs)",
    "date": "2013-05-01T03:00:35Z",
    "url": "https://github.com/antlr/antlr4/commit/cc0d0506224774d3b435ea44da75a79133a6264a",
    "details": {
      "sha": "9edd5f9a15c34525ed0b735680fbfa7fd618e3d8",
      "filename": "tool/test/org/antlr/v4/test/TestPerformance.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/antlr/antlr4/blob/cc0d0506224774d3b435ea44da75a79133a6264a/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestPerformance.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/cc0d0506224774d3b435ea44da75a79133a6264a/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestPerformance.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2FTestPerformance.java?ref=cc0d0506224774d3b435ea44da75a79133a6264a",
      "patch": "@@ -794,7 +794,8 @@ public FileParseResult call() {\n \t\texecutorService.shutdown();\n \t\texecutorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);\n \n-        System.out.format(\"Total parse time for %d files (%d KB, %d tokens, checksum 0x%8X): %dms%n\",\n+        System.out.format(\"%d. Total parse time for %d files (%d KB, %d tokens, checksum 0x%8X): %dms%n\",\n+\t\t\t\t\t\t  currentPass + 1,\n                           inputCount,\n                           inputSize / 1024,\n                           tokenCount.get(currentPass),",
      "parent_sha": "3558151e561d7da5ad773390a409049c3d4d1e3e"
    }
  },
  {
    "oid": "125a509e4e389d839a67254844c73d5a74f1e49e",
    "message": "Fixes #1369 by removing any redundant edges.",
    "date": "2016-11-17T20:41:32Z",
    "url": "https://github.com/antlr/antlr4/commit/125a509e4e389d839a67254844c73d5a74f1e49e",
    "details": {
      "sha": "86d4f1f72a28a9a559df75b612e8c972377d6cca",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/atn/ATNState.java",
      "status": "modified",
      "additions": 12,
      "deletions": 10,
      "changes": 22,
      "blob_url": "https://github.com/antlr/antlr4/blob/125a509e4e389d839a67254844c73d5a74f1e49e/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FATNState.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/125a509e4e389d839a67254844c73d5a74f1e49e/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FATNState.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fatn%2FATNState.java?ref=125a509e4e389d839a67254844c73d5a74f1e49e",
      "patch": "@@ -192,18 +192,20 @@ else if (epsilonOnlyTransitions != e.isEpsilon()) {\n \t\t}\n \n \t\tboolean alreadyPresent = false;\n-//\t\tfor (Transition t : transitions) {\n-//\t\t\tif ( t.target.stateNumber == e.target.stateNumber ) {\n-//\t\t\t\tif ( t.label()!=null && e.label()!=null && t.label().equals(e.label()) ) {\n+\t\tfor (Transition t : transitions) {\n+\t\t\tif ( t.target.stateNumber == e.target.stateNumber ) {\n+\t\t\t\tif ( t.label()!=null && e.label()!=null && t.label().equals(e.label()) ) {\n //\t\t\t\t\tSystem.err.println(\"Repeated transition upon \"+e.label()+\" from \"+stateNumber+\"->\"+t.target.stateNumber);\n-//\t\t\t\t\talreadyPresent = true;\n-//\t\t\t\t}\n-//\t\t\t\telse if ( t.isEpsilon() && e.isEpsilon() ) {\n+\t\t\t\t\talreadyPresent = true;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\telse if ( t.isEpsilon() && e.isEpsilon() ) {\n //\t\t\t\t\tSystem.err.println(\"Repeated epsilon transition from \"+stateNumber+\"->\"+t.target.stateNumber);\n-//\t\t\t\t\talreadyPresent = true;\n-//\t\t\t\t}\n-//\t\t\t}\n-//\t\t}\n+\t\t\t\t\talreadyPresent = true;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t\tif ( !alreadyPresent ) {\n \t\t\ttransitions.add(index, e);\n \t\t}",
      "parent_sha": "1aa3c957ebb6f7060decbd78a1be62c67da2619c"
    }
  },
  {
    "oid": "28696fe2ff2435a8c7da2dfce36cf9303abbfde2",
    "message": "add toSet()\n\n[git-p4: depot-paths = \"//depot/code/antlr4/main/\": change = 9540]",
    "date": "2011-12-06T23:58:47Z",
    "url": "https://github.com/antlr/antlr4/commit/28696fe2ff2435a8c7da2dfce36cf9303abbfde2",
    "details": {
      "sha": "d7a45e9a88a6f50b183028a890eb9a7d2feaef21",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/misc/IntervalSet.java",
      "status": "modified",
      "additions": 39,
      "deletions": 30,
      "changes": 69,
      "blob_url": "https://github.com/antlr/antlr4/blob/28696fe2ff2435a8c7da2dfce36cf9303abbfde2/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fmisc%2FIntervalSet.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/28696fe2ff2435a8c7da2dfce36cf9303abbfde2/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fmisc%2FIntervalSet.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fmisc%2FIntervalSet.java?ref=28696fe2ff2435a8c7da2dfce36cf9303abbfde2",
      "patch": "@@ -1,40 +1,37 @@\n /*\n  [The \"BSD license\"]\n- Copyright (c) 2011 Terence Parr\n- All rights reserved.\n-\n- Redistribution and use in source and binary forms, with or without\n- modification, are permitted provided that the following conditions\n- are met:\n-\n- 1. Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer.\n- 2. Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in the\n-    documentation and/or other materials provided with the distribution.\n- 3. The name of the author may not be used to endorse or promote products\n-    derived from this software without specific prior written permission.\n-\n- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+  Copyright (c) 2011 Terence Parr\n+  All rights reserved.\n+\n+  Redistribution and use in source and binary forms, with or without\n+  modification, are permitted provided that the following conditions\n+  are met:\n+\n+  1. Redistributions of source code must retain the above copyright\n+     notice, this list of conditions and the following disclaimer.\n+  2. Redistributions in binary form must reproduce the above copyright\n+     notice, this list of conditions and the following disclaimer in the\n+     documentation and/or other materials provided with the distribution.\n+  3. The name of the author may not be used to endorse or promote products\n+     derived from this software without specific prior written permission.\n+\n+  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n+  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n+  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n+  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  */\n package org.antlr.v4.runtime.misc;\n \n import org.antlr.v4.runtime.Lexer;\n import org.antlr.v4.runtime.Token;\n \n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.ListIterator;\n+import java.util.*;\n \n /** A set of integers that relies on ranges being common to do\n  *  \"run-length-encoded\" like compression (if you view an IntSet like\n@@ -534,7 +531,19 @@ public List<Integer> toList() {\n \t\t\t}\n \t\t}\n \t\treturn values;\n-    }\n+\t}\n+\n+\tpublic Set<Integer> toSet() {\n+\t\tSet<Integer> s = new HashSet<Integer>();\n+\t\tfor (Interval I : intervals) {\n+\t\t\tint a = I.a;\n+\t\t\tint b = I.b;\n+\t\t\tfor (int v=a; v<=b; v++) {\n+\t\t\t\ts.add(v);\n+\t\t\t}\n+\t\t}\n+\t\treturn s;\n+\t}\n \n \t/** Get the ith element of ordered set.  Used only by RandomPhrase so\n \t *  don't bother to implement if you're not doing that for a new",
      "parent_sha": "cb5d55512a4df2205ca646c5c62eca70ceea75ea"
    }
  },
  {
    "oid": "5847fd6995fc5ea6c6736a6615316eb0802344c4",
    "message": "preparing for CSharp",
    "date": "2014-11-09T05:22:52Z",
    "url": "https://github.com/antlr/antlr4/commit/5847fd6995fc5ea6c6736a6615316eb0802344c4",
    "details": {
      "sha": "c51888c3106a42a4810f583fda41acc18c8f95d1",
      "filename": "tool/test/org/antlr/v4/test/rt/gen/Generator.java",
      "status": "modified",
      "additions": 10,
      "deletions": 4,
      "changes": 14,
      "blob_url": "https://github.com/antlr/antlr4/blob/5847fd6995fc5ea6c6736a6615316eb0802344c4/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Frt%2Fgen%2FGenerator.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/5847fd6995fc5ea6c6736a6615316eb0802344c4/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Frt%2Fgen%2FGenerator.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Ftest%2Forg%2Fantlr%2Fv4%2Ftest%2Frt%2Fgen%2FGenerator.java?ref=5847fd6995fc5ea6c6736a6615316eb0802344c4",
      "patch": "@@ -34,10 +34,11 @@ private static Map<String, File> readConfigs() throws Exception {\n \t\tMap<String, File> configs = new HashMap<String, File>();\n \t\tconfigs.put(\"Source\", readGrammarDir()); // source of test templates\n \t\tconfigs.put(\"Java\", readJavaDir()); // generated Java tests\n-\t\tconfigs.put(\"Python2\", readPython2Dir()); // generated Python2 tests\n-\t\tconfigs.put(\"Python3\", readPython3Dir()); // generated Python3 tests\n-\t\tconfigs.put(\"NodeJS\", readNodeJSDir()); // generated NodeJS tests\n-\t\tconfigs.put(\"Safari\", readSafariDir()); // generated Firefox tests\n+\t\tconfigs.put(\"CSharp\", readCSharpDir()); // generated CSharp tests\n+\t\t// configs.put(\"Python2\", readPython2Dir()); // generated Python2 tests\n+\t\t// configs.put(\"Python3\", readPython3Dir()); // generated Python3 tests\n+\t\t// configs.put(\"NodeJS\", readNodeJSDir()); // generated NodeJS tests\n+\t\t// configs.put(\"Safari\", readSafariDir()); // generated Firefox tests\n \t\t// configs.put(\"Firefox\", readFirefoxDir()); // generated Firefox tests\n \t\treturn configs;\n \t}\n@@ -50,6 +51,11 @@ private static File readJavaDir() throws Exception {\n \t\treturn new File(new URI(uri));\n \t}\n \n+\tprivate static File readCSharpDir() {\n+\t\t// TODO Auto-generated method stub\n+\t\treturn new File(\"/Users/ericvergnaud/Development/antlr4/antlr/antlr4-csharp/tool/test/org/antlr/v4/test/rt/csharp\");\n+\t}\n+\n \tprivate static File readPython2Dir() {\n \t\t// TODO Auto-generated method stub\n \t\treturn new File(\"/Users/ericvergnaud/Development/antlr4/antlr/antlr4-python2/tool/test/org/antlr/v4/test/rt/py2\");",
      "parent_sha": "86fc7fd44d07d136fed45762a8656ebf407db7c0"
    }
  },
  {
    "oid": "05f1dc0d265fc162be6101d3cab56dd5ae24fdb4",
    "message": "tweak",
    "date": "2012-10-01T23:09:18Z",
    "url": "https://github.com/antlr/antlr4/commit/05f1dc0d265fc162be6101d3cab56dd5ae24fdb4",
    "details": {
      "sha": "0b0ca6ff832c77b2d0a499c3baf80273b97ae84a",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/IntStream.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/antlr/antlr4/blob/05f1dc0d265fc162be6101d3cab56dd5ae24fdb4/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FIntStream.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/05f1dc0d265fc162be6101d3cab56dd5ae24fdb4/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FIntStream.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FIntStream.java?ref=05f1dc0d265fc162be6101d3cab56dd5ae24fdb4",
      "patch": "@@ -34,7 +34,7 @@\n \n /**\n  * A simple stream of symbols whose values are represented as integers. This\n- * interface provides <em>marked ranges</em> which support for a minimum level\n+ * interface provides <em>marked ranges</em> with support for a minimum level\n  * of buffering necessary to implement arbitrary lookahead during prediction.\n  * For more information on marked ranges, see {@link #mark}.\n  * <p/>\n@@ -112,7 +112,7 @@ public interface IntStream {\n \t * If {@code i} represents a position at or beyond the end of the stream,\n \t * this method returns {@link #EOF}.\n \t * <p/>\n-\t * The return value is unspecified if {@code i<0} and fewer than {@code -i}\n+\t * The return value is unspecified if {@code i&lt;0} and fewer than {@code -i}\n \t * calls to {@link #consume consume()} have occurred from the beginning of\n \t * the stream before calling this method.\n \t *",
      "parent_sha": "0f29f50f2a5ccf53c0a3ca78b23eb7a779c9c0ca"
    }
  },
  {
    "oid": "c1923a107e403dcf76fe15bbd3b79bb5aa16d837",
    "message": "-tree => -print option\n\n[git-p4: depot-paths = \"//depot/code/antlr4/main/\": change = 9748]",
    "date": "2011-12-26T22:05:58Z",
    "url": "https://github.com/antlr/antlr4/commit/c1923a107e403dcf76fe15bbd3b79bb5aa16d837",
    "details": {
      "sha": "b9332e4a5e4d6fbc81bc448bab9069cc3aaf8236",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/misc/TestRig.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/antlr/antlr4/blob/c1923a107e403dcf76fe15bbd3b79bb5aa16d837/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fmisc%2FTestRig.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/c1923a107e403dcf76fe15bbd3b79bb5aa16d837/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fmisc%2FTestRig.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fmisc%2FTestRig.java?ref=c1923a107e403dcf76fe15bbd3b79bb5aa16d837",
      "patch": "@@ -39,7 +39,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n /** Run a lexer/parser combo, optionally printing tree string or generating\n  *  postscript file. Optionally taking input file.\n  *\n- *  $ java org.antlr.v4.runtime.misc.TestRig GrammarName startRuleName [-tree] [-gui] [-ps file.ps] [input-filename]\n+ *  $ java org.antlr.v4.runtime.misc.TestRig GrammarName startRuleName [-print] [-gui] [-ps file.ps] [input-filename]\n  */\n public class TestRig {\n \tpublic static void main(String[] args) throws Exception {\n@@ -50,7 +50,7 @@ public static void main(String[] args) throws Exception {\n \t\tboolean gui = false;\n \t\tString psFile = null;\n \t\tif ( args.length < 2 ) {\n-\t\t\tSystem.err.println(\"java org.antlr.v4.runtime.misc.TestRig GrammarName startRuleName [-tree] [-gui] [-ps file.ps] [input-filename]\");\n+\t\t\tSystem.err.println(\"java org.antlr.v4.runtime.misc.TestRig GrammarName startRuleName [-print] [-gui] [-ps file.ps] [input-filename]\");\n \t\t\treturn;\n \t\t}\n \t\tint i=0;\n@@ -65,7 +65,7 @@ public static void main(String[] args) throws Exception {\n \t\t\t\tinputFile = arg;\n \t\t\t\tcontinue;\n \t\t\t}\n-\t\t\tif ( arg.equals(\"-tree\") ) {\n+\t\t\tif ( arg.equals(\"-print\") ) {\n \t\t\t\tprintTree = true;\n \t\t\t}\n \t\t\tif ( arg.equals(\"-gui\") ) {",
      "parent_sha": "db655f8f2c57f61580b7f467b7a880248419e37f"
    }
  },
  {
    "oid": "82a00104f64f115e82bb3d8ef375e42f84cebba7",
    "message": "Fix formatting problems in pull request",
    "date": "2013-03-06T21:15:32Z",
    "url": "https://github.com/antlr/antlr4/commit/82a00104f64f115e82bb3d8ef375e42f84cebba7",
    "details": {
      "sha": "28532f04d599bc8092c5f2c785ff827d380526b4",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/tree/gui/TreeViewer.java",
      "status": "modified",
      "additions": 42,
      "deletions": 33,
      "changes": 75,
      "blob_url": "https://github.com/antlr/antlr4/blob/82a00104f64f115e82bb3d8ef375e42f84cebba7/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Ftree%2Fgui%2FTreeViewer.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/82a00104f64f115e82bb3d8ef375e42f84cebba7/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Ftree%2Fgui%2FTreeViewer.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Ftree%2Fgui%2FTreeViewer.java?ref=82a00104f64f115e82bb3d8ef375e42f84cebba7",
      "patch": "@@ -44,7 +44,16 @@\n \n import javax.imageio.ImageIO;\n import javax.print.PrintException;\n-import javax.swing.*;\n+import javax.swing.BorderFactory;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JDialog;\n+import javax.swing.JFrame;\n+import javax.swing.JOptionPane;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.JSlider;\n+import javax.swing.SwingUtilities;\n import javax.swing.event.ChangeEvent;\n import javax.swing.event.ChangeListener;\n import java.awt.BasicStroke;\n@@ -288,43 +297,43 @@ protected static JDialog showInDialog(final TreeViewer viewer) {\n \t\t// Make the scrollpane (containing the viewer) the center component\n \t\tcontentPane.add(scrollPane, BorderLayout.CENTER);\n \n-        JPanel wrapper = new JPanel(new FlowLayout());\n-\n-        // Add an export-to-png button left of the \"OK\" button\n-        JButton png = new JButton(\"png\");\n-        png.addActionListener(\n-            new ActionListener() {\n-                @Override\n-                public void actionPerformed(ActionEvent e) {\n-                    BufferedImage bi = new BufferedImage(viewer.getSize().width,\n-                            viewer.getSize().height, BufferedImage.TYPE_INT_ARGB);\n-                    Graphics g = bi.createGraphics();\n-                    viewer.paint(g);\n-                    g.dispose();\n-\n-                    try{\n-                        File pngFile = new File(\"antlrv4_parse_tree_\" +\n-                                System.currentTimeMillis() +  \".png\");\n-                        ImageIO.write(bi, \"png\", pngFile);\n-                        JOptionPane.showMessageDialog(dialog,\n-                                \"Saved PNG to: \" + pngFile.getAbsolutePath());\n-                    } catch (Exception ex) {\n-                        JOptionPane.showMessageDialog(dialog,\n-                                \"Could not export to PNG: \" + ex.getMessage(),\n-                                \"Error\",\n-                                JOptionPane.ERROR_MESSAGE);\n-                        ex.printStackTrace();\n-                    }\n-                }\n-            }\n-        );\n-        wrapper.add(png);\n+\t\tJPanel wrapper = new JPanel(new FlowLayout());\n+\n+\t\t// Add an export-to-png button left of the \"OK\" button\n+\t\tJButton png = new JButton(\"png\");\n+\t\tpng.addActionListener(\n+\t\t\tnew ActionListener() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n+\t\t\t\t\tBufferedImage bi = new BufferedImage(viewer.getSize().width,\n+\t\t\t\t\t\t\tviewer.getSize().height, BufferedImage.TYPE_INT_ARGB);\n+\t\t\t\t\tGraphics g = bi.createGraphics();\n+\t\t\t\t\tviewer.paint(g);\n+\t\t\t\t\tg.dispose();\n+\n+\t\t\t\t\ttry{\n+\t\t\t\t\t\tFile pngFile = new File(\"antlrv4_parse_tree_\" +\n+\t\t\t\t\t\t\t\tSystem.currentTimeMillis() +  \".png\");\n+\t\t\t\t\t\tImageIO.write(bi, \"png\", pngFile);\n+\t\t\t\t\t\tJOptionPane.showMessageDialog(dialog,\n+\t\t\t\t\t\t\t\t\"Saved PNG to: \" + pngFile.getAbsolutePath());\n+\t\t\t\t\t} catch (Exception ex) {\n+\t\t\t\t\t\tJOptionPane.showMessageDialog(dialog,\n+\t\t\t\t\t\t\t\t\"Could not export to PNG: \" + ex.getMessage(),\n+\t\t\t\t\t\t\t\t\"Error\",\n+\t\t\t\t\t\t\t\tJOptionPane.ERROR_MESSAGE);\n+\t\t\t\t\t\tex.printStackTrace();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t);\n+\t\twrapper.add(png);\n \n \t  \t// Add button to bottom\n \t\tJPanel bottomPanel = new JPanel(new BorderLayout(0,0));\n \t\tcontentPane.add(bottomPanel, BorderLayout.SOUTH);\n \n-        JButton ok = new JButton(\"OK\");\n+\t\tJButton ok = new JButton(\"OK\");\n \t\tok.addActionListener(\n \t\t\tnew ActionListener() {\n \t\t\t\t@Override",
      "parent_sha": "d4c8db49400854d183f4a7e58af3e354a531625b"
    }
  },
  {
    "oid": "4480634f13bb2e404a8b3d8b38ec7c8fa67d016b",
    "message": "do exact LL ambigs for -diagnostics",
    "date": "2012-11-04T00:35:57Z",
    "url": "https://github.com/antlr/antlr4/commit/4480634f13bb2e404a8b3d8b38ec7c8fa67d016b",
    "details": {
      "sha": "682b1465951db12f1d71476d44e56cc0c6ee9099",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/misc/TestRig.java",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/antlr/antlr4/blob/4480634f13bb2e404a8b3d8b38ec7c8fa67d016b/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fmisc%2FTestRig.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/4480634f13bb2e404a8b3d8b38ec7c8fa67d016b/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fmisc%2FTestRig.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2Fmisc%2FTestRig.java?ref=4480634f13bb2e404a8b3d8b38ec7c8fa67d016b",
      "patch": "@@ -36,7 +36,6 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n import org.antlr.v4.runtime.Lexer;\n import org.antlr.v4.runtime.Parser;\n import org.antlr.v4.runtime.ParserRuleContext;\n-import org.antlr.v4.runtime.Token;\n import org.antlr.v4.runtime.TokenStream;\n import org.antlr.v4.runtime.atn.PredictionMode;\n \n@@ -218,13 +217,16 @@ static void process(Lexer lexer, Class<? extends Parser> parserClass, Parser par\n \t\t\tif ( startRuleName.equals(LEXER_START_RULE_NAME) ) return;\n \n \n-\t\t\tif ( diagnostics ) parser.addErrorListener(new DiagnosticErrorListener());\n+\t\t\tif ( diagnostics ) {\n+\t\t\t\tparser.addErrorListener(new DiagnosticErrorListener());\n+\t\t\t\tparser.getInterpreter().setPredictionMode(PredictionMode.LL_EXACT_AMBIG_DETECTION);\n+\t\t\t}\n \n \t\t\tif ( printTree || gui || psFile!=null ) {\n \t\t\t\tparser.setBuildParseTree(true);\n \t\t\t}\n \n-\t\t\tif ( SLL ) {\n+\t\t\tif ( SLL ) { // overrides diagnostics\n \t\t\t\tparser.getInterpreter().setPredictionMode(PredictionMode.SLL);\n \t\t\t}\n ",
      "parent_sha": "d1795d205f65e966f5143c501699eaec32d9201f"
    }
  },
  {
    "oid": "fe1691da78540dcb4cf828655787c4a78154903d",
    "message": "update comment\n\n[git-p4: depot-paths = \"//depot/code/antlr4/main/\": change = 9461]",
    "date": "2011-11-26T00:25:30Z",
    "url": "https://github.com/antlr/antlr4/commit/fe1691da78540dcb4cf828655787c4a78154903d",
    "details": {
      "sha": "c25e654b2b4ca81c95a13dd95fd28c8c2e9542be",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/BailErrorStrategy.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/antlr/antlr4/blob/fe1691da78540dcb4cf828655787c4a78154903d/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FBailErrorStrategy.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/fe1691da78540dcb4cf828655787c4a78154903d/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FBailErrorStrategy.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FBailErrorStrategy.java?ref=fe1691da78540dcb4cf828655787c4a78154903d",
      "patch": "@@ -29,7 +29,9 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n \n package org.antlr.v4.runtime;\n \n-/** Bail out of parser at first syntax error */\n+/** Bail out of parser at first syntax error. Do this to use it:\n+ *      myparser.setErrorHandler(new BailErrorStrategy<Token>());\n+ */\n public class BailErrorStrategy<Symbol> extends DefaultErrorStrategy<Symbol> {\n     /** Instead of recovering from exception e, Re-throw wrote it wrapped\n      *  in a generic RuntimeException so it is not caught by the",
      "parent_sha": "2c52166dd057f55493e7e8a2772002ec635cac95"
    }
  },
  {
    "oid": "1febc36e155bff1ddbaaad33f941e4fad54d19cc",
    "message": "avoid potential null ptr deref (Coverity)",
    "date": "2013-08-31T23:32:59Z",
    "url": "https://github.com/antlr/antlr4/commit/1febc36e155bff1ddbaaad33f941e4fad54d19cc",
    "details": {
      "sha": "c2b3644c22565d9fe13bc371ce2165bbbc08eedd",
      "filename": "tool/src/org/antlr/v4/misc/Graph.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/antlr/antlr4/blob/1febc36e155bff1ddbaaad33f941e4fad54d19cc/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fmisc%2FGraph.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/1febc36e155bff1ddbaaad33f941e4fad54d19cc/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fmisc%2FGraph.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fmisc%2FGraph.java?ref=1febc36e155bff1ddbaaad33f941e4fad54d19cc",
      "patch": "@@ -97,7 +97,9 @@ public List<T> sort() {\n \t\t\t\tn = tNode;\n \t\t\t\tif ( !visited.contains(n) ) break;\n \t\t\t}\n-\t\t\tDFS(n, visited, sorted);\n+\t\t\tif (n!=null) { // if at least one unvisited\n+\t\t\t\tDFS(n, visited, sorted);\n+\t\t\t}\n \t\t}\n \t\treturn sorted;\n \t}",
      "parent_sha": "9420672520ebf8397af0ecb50c50c1b4e891983c"
    }
  },
  {
    "oid": "d5dda9f99808d5e41060c61ab5df78ba41a04a2a",
    "message": "Added check for labels with different token types.\n\nSpaces -> Tabs.",
    "date": "2016-12-07T19:39:27Z",
    "url": "https://github.com/antlr/antlr4/commit/d5dda9f99808d5e41060c61ab5df78ba41a04a2a",
    "details": {
      "sha": "2e28c897b1e55cb62a0ad6ca1d044b5549c75475",
      "filename": "tool/src/org/antlr/v4/semantics/SymbolChecks.java",
      "status": "modified",
      "additions": 67,
      "deletions": 57,
      "changes": 124,
      "blob_url": "https://github.com/antlr/antlr4/blob/d5dda9f99808d5e41060c61ab5df78ba41a04a2a/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fsemantics%2FSymbolChecks.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/d5dda9f99808d5e41060c61ab5df78ba41a04a2a/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fsemantics%2FSymbolChecks.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fsemantics%2FSymbolChecks.java?ref=d5dda9f99808d5e41060c61ab5df78ba41a04a2a",
      "patch": "@@ -43,6 +43,7 @@\n import org.antlr.v4.tool.LexerGrammar;\n import org.antlr.v4.tool.Rule;\n import org.antlr.v4.tool.ast.GrammarAST;\n+import org.antlr.v4.tool.LabelType;\n \n import java.util.Collection;\n import java.util.HashMap;\n@@ -94,10 +95,10 @@ public SymbolChecks(Grammar g, SymbolCollector collector) {\n     }\n \n     public void process() {\n-        // methods affect fields, but no side-effects outside this object\n+\t\t// methods affect fields, but no side-effects outside this object\n \t\t// So, call order sensitive\n \t\t// First collect all rules for later use in checkForLabelConflict()\n-\t\tif ( g.rules!=null ) {\n+\t\tif (g.rules != null) {\n \t\t\tfor (Rule r : g.rules.values()) nameToRuleMap.put(r.name, r);\n \t\t}\n \t\tcheckReservedNames(g.rules.values());\n@@ -107,41 +108,39 @@ public void process() {\n \t}\n \n \tpublic void checkActionRedefinitions(List<GrammarAST> actions) {\n-\t\tif ( actions==null ) return;\n+\t\tif (actions == null) return;\n \t\tString scope = g.getDefaultActionScope();\n \t\tString name;\n \t\tGrammarAST nameNode;\n \t\tfor (GrammarAST ampersandAST : actions) {\n-\t\t\tnameNode = (GrammarAST)ampersandAST.getChild(0);\n-\t\t\tif ( ampersandAST.getChildCount()==2 ) {\n+\t\t\tnameNode = (GrammarAST) ampersandAST.getChild(0);\n+\t\t\tif (ampersandAST.getChildCount() == 2) {\n \t\t\t\tname = nameNode.getText();\n-\t\t\t}\n-\t\t\telse {\n+\t\t\t} else {\n \t\t\t\tscope = nameNode.getText();\n-                name = ampersandAST.getChild(1).getText();\n-            }\n-            Set<String> scopeActions = actionScopeToActionNames.get(scope);\n-            if ( scopeActions==null ) { // init scope\n-                scopeActions = new HashSet<String>();\n-                actionScopeToActionNames.put(scope, scopeActions);\n-            }\n-            if ( !scopeActions.contains(name) ) {\n-                scopeActions.add(name);\n-            }\n-            else {\n-                errMgr.grammarError(ErrorType.ACTION_REDEFINITION,\n-                                          g.fileName, nameNode.token, name);\n-            }\n-        }\n-    }\n+\t\t\t\tname = ampersandAST.getChild(1).getText();\n+\t\t\t}\n+\t\t\tSet<String> scopeActions = actionScopeToActionNames.get(scope);\n+\t\t\tif (scopeActions == null) { // init scope\n+\t\t\t\tscopeActions = new HashSet<String>();\n+\t\t\t\tactionScopeToActionNames.put(scope, scopeActions);\n+\t\t\t}\n+\t\t\tif (!scopeActions.contains(name)) {\n+\t\t\t\tscopeActions.add(name);\n+\t\t\t} else {\n+\t\t\t\terrMgr.grammarError(ErrorType.ACTION_REDEFINITION,\n+\t\t\t\t\t\tg.fileName, nameNode.token, name);\n+\t\t\t}\n+\t\t}\n+\t}\n \n-    public void checkForTokenConflicts(List<GrammarAST> tokenIDRefs) {\n+\tpublic void checkForTokenConflicts(List<GrammarAST> tokenIDRefs) {\n //        for (GrammarAST a : tokenIDRefs) {\n //            Token t = a.token;\n //            String ID = t.getText();\n //            tokenIDs.add(ID);\n //        }\n-    }\n+\t}\n \n     /** Make sure a label doesn't conflict with another symbol.\n      *  Labels must not conflict with: rules, tokens, scope names,\n@@ -150,43 +149,54 @@ public void checkForTokenConflicts(List<GrammarAST> tokenIDRefs) {\n      *  for repeated defs.\n      */\n     public void checkForLabelConflicts(Collection<Rule> rules) {\n-        for (Rule r : rules) {\n-            checkForAttributeConflicts(r);\n-            Map<String, LabelElementPair> labelNameSpace =\n-                new HashMap<String, LabelElementPair>();\n-            for (int i=1; i<=r.numberOfAlts; i++) {\n+\t\tfor (Rule r : rules) {\n+\t\t\tcheckForAttributeConflicts(r);\n+\t\t\tMap<String, LabelElementPair> labelNameSpace =\n+\t\t\t\t\tnew HashMap<String, LabelElementPair>();\n+\t\t\tfor (int i = 1; i <= r.numberOfAlts; i++) {\n \t\t\t\tif (r.hasAltSpecificContexts()) {\n \t\t\t\t\tlabelNameSpace.clear();\n \t\t\t\t}\n \n-                Alternative a = r.alt[i];\n-                for (List<LabelElementPair> pairs : a.labelDefs.values() ) {\n-                    for (LabelElementPair p : pairs) {\n-                        checkForLabelConflict(r, p.label);\n-                        String name = p.label.getText();\n-                        LabelElementPair prev = labelNameSpace.get(name);\n-                        if ( prev==null ) labelNameSpace.put(name, p);\n-                        else checkForTypeMismatch(prev, p);\n-                    }\n-                }\n-            }\n-        }\n-    }\n+\t\t\t\tAlternative a = r.alt[i];\n+\t\t\t\tfor (List<LabelElementPair> pairs : a.labelDefs.values()) {\n+\t\t\t\t\tfor (LabelElementPair p : pairs) {\n+\t\t\t\t\t\tcheckForLabelConflict(r, p.label);\n+\t\t\t\t\t\tString name = p.label.getText();\n+\t\t\t\t\t\tLabelElementPair prev = labelNameSpace.get(name);\n+\t\t\t\t\t\tif (prev == null) labelNameSpace.put(name, p);\n+\t\t\t\t\t\telse checkForTypeMismatch(prev, p);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n \n-    void checkForTypeMismatch(LabelElementPair prevLabelPair,\n-                                        LabelElementPair labelPair)\n-    {\n-        // label already defined; if same type, no problem\n-        if ( prevLabelPair.type != labelPair.type ) {\n-            String typeMismatchExpr = labelPair.type+\"!=\"+prevLabelPair.type;\n-            errMgr.grammarError(\n-                ErrorType.LABEL_TYPE_CONFLICT,\n-                g.fileName,\n-                labelPair.label.token,\n-                labelPair.label.getText(),\n-                typeMismatchExpr);\n-        }\n-    }\n+    void checkForTypeMismatch(LabelElementPair prevLabelPair, LabelElementPair labelPair) {\n+\t\t// label already defined; if same type, no problem\n+\t\tif (prevLabelPair.type != labelPair.type) {\n+\t\t\tString typeMismatchExpr = labelPair.type + \"!=\" + prevLabelPair.type;\n+\t\t\terrMgr.grammarError(\n+\t\t\t\t\tErrorType.LABEL_TYPE_CONFLICT,\n+\t\t\t\t\tg.fileName,\n+\t\t\t\t\tlabelPair.label.token,\n+\t\t\t\t\tlabelPair.label.getText(),\n+\t\t\t\t\ttypeMismatchExpr);\n+\t\t}\n+\t\tif (!prevLabelPair.element.getText().equals(labelPair.element.getText()) &&\n+\t\t\t(prevLabelPair.type.equals(LabelType.RULE_LABEL) || prevLabelPair.type.equals(LabelType.RULE_LIST_LABEL)) &&\n+\t\t\t(labelPair.type.equals(LabelType.RULE_LABEL) || labelPair.type.equals(LabelType.RULE_LIST_LABEL))) {\n+\n+\t\t\tString prevLabelOp = prevLabelPair.type.equals(LabelType.RULE_LIST_LABEL) ? \"+=\" : \"=\";\n+\t\t\tString labelOp = labelPair.type.equals(LabelType.RULE_LIST_LABEL) ? \"+=\" : \"=\";\n+\t\t\terrMgr.grammarError(\n+\t\t\t\t\tErrorType.LABEL_TYPE_CONFLICT,\n+\t\t\t\t\tg.fileName,\n+\t\t\t\t\tlabelPair.label.token,\n+\t\t\t\t\tlabelPair.label.getText() + labelOp + labelPair.element.getText(),\n+\t\t\t\t\tprevLabelPair.label.getText() + prevLabelOp + prevLabelPair.element.getText());\n+\t\t}\n+\t}\n \n \tpublic void checkForLabelConflict(Rule r, GrammarAST labelID) {\n \t\tString name = labelID.getText();",
      "parent_sha": "50646a6da8598ed13edc71c30f1590d9de7ea266"
    }
  },
  {
    "oid": "f91cb106a9946b3677f34a821e0eeaa2f150b089",
    "message": "Update copyright, remove options which are no longer relevant to the Tool",
    "date": "2012-12-01T19:14:51Z",
    "url": "https://github.com/antlr/antlr4/commit/f91cb106a9946b3677f34a821e0eeaa2f150b089",
    "details": {
      "sha": "e190720bdf666e38495f60bcf9376afe290ef51a",
      "filename": "antlr4-maven-plugin/src/main/java/org/antlr/mojo/antlr4/Antlr4Mojo.java",
      "status": "modified",
      "additions": 5,
      "deletions": 88,
      "changes": 93,
      "blob_url": "https://github.com/antlr/antlr4/blob/f91cb106a9946b3677f34a821e0eeaa2f150b089/antlr4-maven-plugin%2Fsrc%2Fmain%2Fjava%2Forg%2Fantlr%2Fmojo%2Fantlr4%2FAntlr4Mojo.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/f91cb106a9946b3677f34a821e0eeaa2f150b089/antlr4-maven-plugin%2Fsrc%2Fmain%2Fjava%2Forg%2Fantlr%2Fmojo%2Fantlr4%2FAntlr4Mojo.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/antlr4-maven-plugin%2Fsrc%2Fmain%2Fjava%2Forg%2Fantlr%2Fmojo%2Fantlr4%2FAntlr4Mojo.java?ref=f91cb106a9946b3677f34a821e0eeaa2f150b089",
      "patch": "@@ -1,9 +1,7 @@\n-/**\n-[The \"BSD licence\"]\n-\n-ANTLR        - Copyright (c) 2005-2008 Terence Parr\n-Maven Plugin - Copyright (c) 2009      Jim Idle\n-\n+/*\n+ [The \"BSD license\"]\n+ Copyright (c) 2012 Terence Parr\n+ Copyright (c) 2012 Sam Harwell\n All rights reserved.\n \n Redistribution and use in source and binary forms, with or without\n@@ -72,7 +70,7 @@ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n  * are required for generation of the compilable sources into the location\n  * that we use to compile them, such as target/generated-sources/antlr4 ...\n  * \n- * @author <a href=\"mailto:jimi@temporal-wave.com\">Jim Idle</a>\n+ * @author Sam Harwell\n  */\n @Mojo(\n \tname = \"antlr\",\n@@ -85,77 +83,24 @@ public class Antlr4Mojo\n     // First, let's deal with the options that the ANTLR tool itself\n     // can be configured by.\n     //\n-    /**\n-     * If set to true, then after the tool has processed an input grammar file\n-     * it will report variaous statistics about the parser, such as information\n-     * on cyclic DFAs, which rules may use backtracking, and so on.\n-     */\n-    @Parameter(defaultValue = \"false\")\n-    protected boolean report;\n-    /**\n-     * If set to true, then the ANTLR tool will print a version of the input\n-     * grammar which is devoid of any actions that may be present in the input file.\n-     */\n-    @Parameter(defaultValue = \"false\")\n-    protected boolean printGrammar;\n-    /**\n-     * If set to true, then the code generated by the ANTLR code generator will\n-     * be set to debug mode. This means that when run, the code will 'hang' and\n-     * wait for a debug connection on a TCP port (49100 by default).\n-     */\n-    @Parameter(defaultValue = \"false\")\n-    protected boolean debug;\n-    /**\n-     * If set to true, then then the generated parser will compute and report on\n-     * profile information at runtime.\n-     */\n-    @Parameter(defaultValue = \"false\")\n-    protected boolean profile;\n     /**\n      * If set to true then the ANTLR tool will generate a description of the atn\n      * for each rule in <a href=\"http://www.graphviz.org\">Dot format</a>\n      */\n     @Parameter(defaultValue = \"false\")\n     protected boolean atn;\n-    /**\n-     * If set to true, the generated parser code will log rule entry and exit points\n-     * to stdout as an aid to debugging.\n-     */\n-    @Parameter(defaultValue = \"false\")\n-    protected boolean trace;\n     /**\n      * If this parameter is set, it indicates that any warning or error messages returned\n      * by ANLTR, shoould be formatted in the specified way. Currently, ANTLR suports the\n      * built-in formats of antlr, gnu and vs2005.\n      */\n     @Parameter(defaultValue = \"antlr\")\n     protected String messageFormat;\n-    /**\n-     * If this parameter is set to true, then ANTLR will report all sorts of things\n-     * about what it is doing such as the names of files and the version of ANTLR and so on.\n-     */\n-    @Parameter(defaultValue = \"true\")\n-    protected boolean verbose;\n \n \tprotected boolean verbose_dfa;\n \n \tprotected boolean force_atn;\n \n-\tprotected boolean abstract_recognizer;\n-\n-    /**\n-     * The number of alts, beyond which ANTLR will not generate a switch statement\n-     * for the DFA.\n-     */\n-    @Parameter(defaultValue = \"300\")\n-    private int maxSwitchCaseLabels;\n-\n-    /**\n-     * The number of alts, below which ANTLR will not choose to generate a switch\n-     * statement over an if statement.\n-     */\n-    private int minSwitchAlts;\n-\n     /* --------------------------------------------------------------------\n      * The following are Maven specific parameters, rather than specificlly\n      * options that the ANTLR tool can use.\n@@ -268,16 +213,6 @@ public void execute()\n \n             // Flags\n             //\n-            log.debug(\"ANTLR: report              : \" + report);\n-            log.debug(\"ANTLR: printGrammar        : \" + printGrammar);\n-            log.debug(\"ANTLR: debug               : \" + debug);\n-            log.debug(\"ANTLR: profile             : \" + profile);\n-            log.debug(\"ANTLR: atn                 : \" + atn);\n-            log.debug(\"ANTLR: trace               : \" + trace);\n-            log.debug(\"ANTLR: messageFormat       : \" + messageFormat);\n-            log.debug(\"ANTLR: maxSwitchCaseLabels : \" + maxSwitchCaseLabels);\n-            log.debug(\"ANTLR: minSwitchAlts       : \" + minSwitchAlts);\n-            log.debug(\"ANTLR: verbose             : \" + verbose);\n         }\n \n         // Ensure that the output directory path is all in tact so that\n@@ -306,21 +241,9 @@ public void execute()\n         // Next we need to set the options given to us in the pom into the\n         // tool instance we have created.\n         //\n-\t\tif (debug) {\n-\t\t\targs.add(\"-debug\");\n-\t\t}\n \t\tif (atn) {\n \t\t\targs.add(\"-atn\");\n \t\t}\n-\t\tif (profile) {\n-\t\t\targs.add(\"-profile\");\n-\t\t}\n-\t\tif (report) {\n-\t\t\targs.add(\"-report\");\n-\t\t}\n-\t\tif (printGrammar) {\n-\t\t\targs.add(\"-print\");\n-\t\t}\n \t\tif (verbose_dfa) {\n \t\t\targs.add(\"-Xverbose-dfa\");\n \t\t}\n@@ -331,9 +254,6 @@ public void execute()\n \t\tif (force_atn) {\n \t\t\targs.add(\"-Xforce-atn\");\n \t\t}\n-\t\tif (abstract_recognizer) {\n-\t\t\targs.add(\"-abstract\");\n-\t\t}\n \n         try {\n \n@@ -395,9 +315,6 @@ public Writer getOutputFileWriter(Grammar g, String fileName) throws IOException\n \t\t\t};\n \t\t\ttool.addListener(new Antlr4ErrorLog(log));\n \n-\t\t\t// we set some options directly\n-\t\t\ttool.trace = trace;\n-\n \t\t\t// Where do we want ANTLR to produce its output? (Base directory)\n \t\t\t//\n \t\t\tif (log.isDebugEnabled())",
      "parent_sha": "66bdbb7abdaf8fcd0e7c4f2a5710b514f6cb2f3a"
    }
  },
  {
    "oid": "7050d07d5b1e3f15ef50da812ba6411f4d593974",
    "message": "tweak\n\n[git-p4: depot-paths = \"//depot/code/antlr4/main/\": change = 9304]",
    "date": "2011-11-12T21:19:49Z",
    "url": "https://github.com/antlr/antlr4/commit/7050d07d5b1e3f15ef50da812ba6411f4d593974",
    "details": {
      "sha": "2f0531b095df1f19d2b0c290d4581be6b8e13222",
      "filename": "tool/src/org/antlr/v4/codegen/Target.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/antlr/antlr4/blob/7050d07d5b1e3f15ef50da812ba6411f4d593974/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fcodegen%2FTarget.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/7050d07d5b1e3f15ef50da812ba6411f4d593974/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fcodegen%2FTarget.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/tool%2Fsrc%2Forg%2Fantlr%2Fv4%2Fcodegen%2FTarget.java?ref=7050d07d5b1e3f15ef50da812ba6411f4d593974",
      "patch": "@@ -224,7 +224,7 @@ public String getTargetStringLiteralFromString(String s, boolean quoted) {\n \t}\n \n \tpublic String getTargetStringLiteralFromString(String s) {\n-\t\treturn getTargetStringLiteralFromString(s, false);\n+\t\treturn getTargetStringLiteralFromString(s, true);\n \t}\n \n \t/** Convert from an ANTLR string literal found in a grammar file to",
      "parent_sha": "e6d316f3e96444f66c1109ce518f6f1954d5f0fb"
    }
  },
  {
    "oid": "919e3a1c0686d966a27394439a27140748e17053",
    "message": "Small optimization\n\n[git-p4: depot-paths = \"//depot/code/antlr4/main/\": change = 8820]",
    "date": "2011-07-02T19:28:30Z",
    "url": "https://github.com/antlr/antlr4/commit/919e3a1c0686d966a27394439a27140748e17053",
    "details": {
      "sha": "d7e5480de433d19d4a709af430f253b885e975c9",
      "filename": "runtime/Java/src/org/antlr/v4/runtime/CommonToken.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/antlr/antlr4/blob/919e3a1c0686d966a27394439a27140748e17053/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FCommonToken.java",
      "raw_url": "https://github.com/antlr/antlr4/raw/919e3a1c0686d966a27394439a27140748e17053/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FCommonToken.java",
      "contents_url": "https://api.github.com/repos/antlr/antlr4/contents/runtime%2FJava%2Fsrc%2Forg%2Fantlr%2Fv4%2Fruntime%2FCommonToken.java?ref=919e3a1c0686d966a27394439a27140748e17053",
      "patch": "@@ -101,7 +101,8 @@ public String getText() {\n \t\tif ( input==null ) {\n \t\t\treturn null;\n \t\t}\n-\t\tif ( start<input.size() && stop<input.size() ) {\n+\t\tint n = input.size();\n+\t\tif ( start<n && stop<n) {\n \t\t\treturn input.substring(start,stop);\n \t\t}\n \t\telse {",
      "parent_sha": "ab8d07d82fabf90182675d95329c121237f36578"
    }
  }
]