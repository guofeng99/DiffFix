[
  {
    "oid": "cbea11c4aba9eba5075b830cdc1eb346e6116dda",
    "message": "Remove unsafe based padding from RingBuffer.",
    "date": "2018-02-04T02:44:31Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/cbea11c4aba9eba5075b830cdc1eb346e6116dda",
    "details": {
      "sha": "8235f3476483de885ef0e1d59caff0bb7168e78d",
      "filename": "src/main/java/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 10,
      "deletions": 43,
      "changes": 53,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/cbea11c4aba9eba5075b830cdc1eb346e6116dda/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/cbea11c4aba9eba5075b830cdc1eb346e6116dda/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=cbea11c4aba9eba5075b830cdc1eb346e6116dda",
      "patch": "@@ -16,10 +16,7 @@\n package com.lmax.disruptor;\n \n \n-import sun.misc.Unsafe;\n-\n import com.lmax.disruptor.dsl.ProducerType;\n-import com.lmax.disruptor.util.Util;\n \n abstract class RingBufferPad\n {\n@@ -28,69 +25,40 @@ abstract class RingBufferPad\n \n abstract class RingBufferFields<E> extends RingBufferPad\n {\n-    private static final int BUFFER_PAD;\n-    private static final long REF_ARRAY_BASE;\n-    private static final int REF_ELEMENT_SHIFT;\n-    private static final Unsafe UNSAFE = Util.getUnsafe();\n-\n-    static\n-    {\n-        final int scale = UNSAFE.arrayIndexScale(Object[].class);\n-        if (4 == scale)\n-        {\n-            REF_ELEMENT_SHIFT = 2;\n-        }\n-        else if (8 == scale)\n-        {\n-            REF_ELEMENT_SHIFT = 3;\n-        }\n-        else\n-        {\n-            throw new IllegalStateException(\"Unknown pointer size\");\n-        }\n-        BUFFER_PAD = 128 / scale;\n-        // Including the buffer pad in the array base offset\n-        REF_ARRAY_BASE = UNSAFE.arrayBaseOffset(Object[].class) + (BUFFER_PAD << REF_ELEMENT_SHIFT);\n-    }\n-\n-    private final long indexMask;\n     private final Object[] entries;\n-    protected final int bufferSize;\n     protected final Sequencer sequencer;\n \n     RingBufferFields(\n         EventFactory<E> eventFactory,\n         Sequencer sequencer)\n     {\n         this.sequencer = sequencer;\n-        this.bufferSize = sequencer.getBufferSize();\n \n-        if (bufferSize < 1)\n+        if (sequencer.getBufferSize() < 1)\n         {\n             throw new IllegalArgumentException(\"bufferSize must not be less than 1\");\n         }\n-        if (Integer.bitCount(bufferSize) != 1)\n+        if (Integer.bitCount(sequencer.getBufferSize()) != 1)\n         {\n             throw new IllegalArgumentException(\"bufferSize must be a power of 2\");\n         }\n \n-        this.indexMask = bufferSize - 1;\n-        this.entries = new Object[sequencer.getBufferSize() + 2 * BUFFER_PAD];\n+        this.entries = new Object[sequencer.getBufferSize()];\n         fill(eventFactory);\n     }\n \n     private void fill(EventFactory<E> eventFactory)\n     {\n-        for (int i = 0; i < bufferSize; i++)\n+        for (int i = 0; i < entries.length; i++)\n         {\n-            entries[BUFFER_PAD + i] = eventFactory.newInstance();\n+            entries[i] = eventFactory.newInstance();\n         }\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     protected final E elementAt(long sequence)\n     {\n-        return (E) UNSAFE.getObject(entries, REF_ARRAY_BASE + ((sequence & indexMask) << REF_ELEMENT_SHIFT));\n+        return (E) entries[(int) (sequence & (entries.length - 1))];\n     }\n }\n \n@@ -437,7 +405,7 @@ public long getCursor()\n      */\n     public int getBufferSize()\n     {\n-        return bufferSize;\n+        return sequencer.getBufferSize();\n     }\n \n     /**\n@@ -910,9 +878,9 @@ private void checkBatchSizing(int batchStartsAt, int batchSize)\n         {\n             throw new IllegalArgumentException(\"Both batchStartsAt and batchSize must be positive but got: batchStartsAt \" + batchStartsAt + \" and batchSize \" + batchSize);\n         }\n-        else if (batchSize > bufferSize)\n+        else if (batchSize > sequencer.getBufferSize())\n         {\n-            throw new IllegalArgumentException(\"The ring buffer cannot accommodate \" + batchSize + \" it only has space for \" + bufferSize + \" entities.\");\n+            throw new IllegalArgumentException(\"The ring buffer cannot accommodate \" + batchSize + \" it only has space for \" + sequencer.getBufferSize() + \" entities.\");\n         }\n     }\n \n@@ -1124,8 +1092,7 @@ private void translateAndPublishBatch(\n     public String toString()\n     {\n         return \"RingBuffer{\" +\n-            \"bufferSize=\" + bufferSize +\n-            \", sequencer=\" + sequencer +\n+            \"sequencer=\" + sequencer +\n             \"}\";\n     }\n }",
      "parent_sha": "83aba8388fcfa86942eef3bb7f4f905f2b43aa0a"
    }
  },
  {
    "oid": "110c76c57fb050889f9aedbdef88f26a5375c576",
    "message": "Small performance optimisation on the MultithreadedClaimStrategy",
    "date": "2012-04-08T07:55:03Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/110c76c57fb050889f9aedbdef88f26a5375c576",
    "details": {
      "sha": "f54ba372a0847ec81e08fcf593acfdd2e9069e48",
      "filename": "code/src/main/com/lmax/disruptor/MultiThreadedClaimStrategy.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/110c76c57fb050889f9aedbdef88f26a5375c576/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FMultiThreadedClaimStrategy.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/110c76c57fb050889f9aedbdef88f26a5375c576/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FMultiThreadedClaimStrategy.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FMultiThreadedClaimStrategy.java?ref=110c76c57fb050889f9aedbdef88f26a5375c576",
      "patch": "@@ -78,10 +78,11 @@ public void serialisePublishing(final long sequence, final Sequence cursor, fina\n         }\n \n         long expectedSequence = sequence - batchSize;\n-        for (long pendingSequence = expectedSequence + 1; pendingSequence <= sequence; pendingSequence++)\n+        for (long pendingSequence = expectedSequence + 1; pendingSequence < sequence; pendingSequence++)\n         {\n-            pendingPublication.set((int) pendingSequence & pendingMask, pendingSequence);\n+            pendingPublication.lazySet((int) pendingSequence & pendingMask, pendingSequence);\n         }\n+        pendingPublication.set((int) sequence & pendingMask, sequence);\n \n         long cursorSequence = cursor.get();\n         if (cursorSequence >= sequence)",
      "parent_sha": "766b00821bad41d8c4e1f00bc3cd8b5f36273811"
    }
  },
  {
    "oid": "f6d4bf94a802926de9d6ed7f0f7ac9de254a167e",
    "message": "Use the manual memory-barrier version of Sequence in the main code",
    "date": "2021-01-08T17:18:02Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/f6d4bf94a802926de9d6ed7f0f7ac9de254a167e",
    "details": {
      "sha": "3315536b405761f0c2dd97b4a86a275a7464b83c",
      "filename": "src/main/java/com/lmax/disruptor/Sequence.java",
      "status": "modified",
      "additions": 48,
      "deletions": 36,
      "changes": 84,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/f6d4bf94a802926de9d6ed7f0f7ac9de254a167e/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSequence.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/f6d4bf94a802926de9d6ed7f0f7ac9de254a167e/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSequence.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSequence.java?ref=f6d4bf94a802926de9d6ed7f0f7ac9de254a167e",
      "patch": "@@ -1,24 +1,8 @@\n-/*\n- * Copyright 2012 LMAX Ltd.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n package com.lmax.disruptor;\n \n-import sun.misc.Unsafe;\n-\n-import com.lmax.disruptor.util.Util;\n \n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n \n class LhsPadding\n {\n@@ -27,7 +11,7 @@ class LhsPadding\n \n class Value extends LhsPadding\n {\n-    protected volatile long value;\n+    protected long value;\n }\n \n class RhsPadding extends Value\n@@ -46,20 +30,20 @@ class RhsPadding extends Value\n public class Sequence extends RhsPadding\n {\n     static final long INITIAL_VALUE = -1L;\n-    private static final Unsafe UNSAFE;\n-    private static final long VALUE_OFFSET;\n+    private static final VarHandle VALUE_FIELD;\n \n     static\n     {\n-        UNSAFE = Util.getUnsafe();\n         try\n         {\n-            VALUE_OFFSET = UNSAFE.objectFieldOffset(Value.class.getDeclaredField(\"value\"));\n+            VALUE_FIELD = MethodHandles.lookup().in(Sequence.class)\n+                    .findVarHandle(Sequence.class, \"value\", long.class);\n         }\n         catch (final Exception e)\n         {\n             throw new RuntimeException(e);\n         }\n+\n     }\n \n     /**\n@@ -77,7 +61,8 @@ public Sequence()\n      */\n     public Sequence(final long initialValue)\n     {\n-        UNSAFE.putOrderedLong(this, VALUE_OFFSET, initialValue);\n+        this.value = initialValue;\n+        VarHandle.releaseFence();\n     }\n \n     /**\n@@ -87,6 +72,8 @@ public Sequence(final long initialValue)\n      */\n     public long get()\n     {\n+        long value = this.value;\n+        VarHandle.acquireFence();\n         return value;\n     }\n \n@@ -99,7 +86,8 @@ public long get()\n      */\n     public void set(final long value)\n     {\n-        UNSAFE.putOrderedLong(this, VALUE_OFFSET, value);\n+        this.value = value;\n+        VarHandle.releaseFence();\n     }\n \n     /**\n@@ -112,55 +100,79 @@ public void set(final long value)\n      */\n     public void setVolatile(final long value)\n     {\n-        UNSAFE.putLongVolatile(this, VALUE_OFFSET, value);\n+        this.value = value;\n+        VarHandle.fullFence();\n     }\n \n     /**\n      * Perform a compare and set operation on the sequence.\n      *\n      * @param expectedValue The expected current value.\n-     * @param newValue The value to update to.\n+     * @param newValue      The value to update to.\n      * @return true if the operation succeeds, false otherwise.\n      */\n     public boolean compareAndSet(final long expectedValue, final long newValue)\n     {\n-        return UNSAFE.compareAndSwapLong(this, VALUE_OFFSET, expectedValue, newValue);\n+        return (boolean) VALUE_FIELD.compareAndSet(this, expectedValue, newValue);\n     }\n \n     /**\n      * Atomically increment the sequence by one.\n      *\n      * @return The value after the increment\n+     * @deprecated Naming is inconsistent with the rest of the JVM, should use getAndIncrement instead\n      */\n+    @Deprecated\n     public long incrementAndGet()\n     {\n-        return addAndGet(1L);\n+        return getAndIncrement();\n+    }\n+\n+    /**\n+     * Atomically increment the sequence by one.\n+     *\n+     * @return The value after the increment\n+     */\n+    public long getAndIncrement()\n+    {\n+        return getAndAdd(1L);\n     }\n \n     /**\n      * Atomically add the supplied value.\n      *\n      * @param increment The value to add to the sequence.\n      * @return The value after the increment.\n+     * @deprecated Naming is inconsistent with the rest of the JVM, should use getAndAdd instead\n      */\n+    @Deprecated\n     public long addAndGet(final long increment)\n     {\n-        long currentValue;\n-        long newValue;\n+        return getAndAdd(increment);\n+    }\n \n+    /**\n+     * Atomically add the supplied value.\n+     *\n+     * @param increment The value to add to the sequence.\n+     * @return The value after the increment.\n+     */\n+    public long getAndAdd(final long increment)\n+    {\n+        long v;\n         do\n         {\n-            currentValue = get();\n-            newValue = currentValue + increment;\n+            v = value;\n+            VarHandle.fullFence();\n         }\n-        while (!compareAndSet(currentValue, newValue));\n+        while (!compareAndSet(v, v + increment));\n \n-        return newValue;\n+        return v;\n     }\n \n     @Override\n     public String toString()\n     {\n         return Long.toString(get());\n     }\n-}\n+}\n\\ No newline at end of file",
      "parent_sha": "dd28b51b167b888618d3c70323fe3242a97b6991"
    }
  },
  {
    "oid": "bffdad84b620c7a1c88493667502cd29941e580b",
    "message": "Check for validity  before usage.",
    "date": "2011-06-20T21:10:08Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/bffdad84b620c7a1c88493667502cd29941e580b",
    "details": {
      "sha": "4f2a52d0c9a6805f9a3ac3c1318866840d67a56c",
      "filename": "code/src/main/com/lmax/disruptor/collections/Histogram.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/bffdad84b620c7a1c88493667502cd29941e580b/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2Fcollections%2FHistogram.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/bffdad84b620c7a1c88493667502cd29941e580b/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2Fcollections%2FHistogram.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2Fcollections%2FHistogram.java?ref=bffdad84b620c7a1c88493667502cd29941e580b",
      "patch": "@@ -24,12 +24,13 @@ public final class Histogram\n      */\n     public Histogram(final long[] upperBounds)\n     {\n+        validateBounds(upperBounds);\n+\n         this.upperBounds = Arrays.copyOf(upperBounds, upperBounds.length);\n         this.counts = new long[upperBounds.length];\n-        validateBounds();\n     }\n \n-    private void validateBounds()\n+    private void validateBounds(final long[] upperBounds)\n     {\n         long lastBound = -1L;\n         for (final long bound : upperBounds)",
      "parent_sha": "a6f915bf134aa58fdb40f537f90f953d6266c418"
    }
  },
  {
    "oid": "45a1dd248a482a255f0dd2c4866333d62c009400",
    "message": "Set claim sequence when the claim happens and not on publish.",
    "date": "2011-09-06T12:02:55Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/45a1dd248a482a255f0dd2c4866333d62c009400",
    "details": {
      "sha": "245c4fcf5fc3efdf966164ff05deec5056e68a54",
      "filename": "code/src/main/com/lmax/disruptor/Sequencer.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/45a1dd248a482a255f0dd2c4866333d62c009400/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FSequencer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/45a1dd248a482a255f0dd2c4866333d62c009400/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FSequencer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FSequencer.java?ref=45a1dd248a482a255f0dd2c4866333d62c009400",
      "patch": "@@ -160,6 +160,7 @@ public void publish(final SequenceBatch sequenceBatch)\n      */\n     public void claim(final long sequence)\n     {\n+        claimStrategy.setSequence(sequence);\n         claimStrategy.ensureCapacity(sequence, gatingSequences);\n     }\n \n@@ -173,7 +174,6 @@ public void claim(final long sequence)\n      */\n     public void forcePublish(final long sequence)\n     {\n-        claimStrategy.setSequence(sequence);\n         cursor.set(sequence);\n         waitStrategy.signalAllWhenBlocking();\n     }",
      "parent_sha": "6383e8d5a727980b3b2e5f2202399380d76c1a07"
    }
  },
  {
    "oid": "6ed9cace66652c86ea885e05f07280736e7dd66c",
    "message": "Deprecate ThreadHints class\n\nIt is only one method which is already marked deprecated",
    "date": "2021-04-08T12:26:14Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/6ed9cace66652c86ea885e05f07280736e7dd66c",
    "details": {
      "sha": "2b09212e77c0e98dace8dafa7aff1fd8734a70d7",
      "filename": "src/main/java/com/lmax/disruptor/util/ThreadHints.java",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/6ed9cace66652c86ea885e05f07280736e7dd66c/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Futil%2FThreadHints.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/6ed9cace66652c86ea885e05f07280736e7dd66c/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Futil%2FThreadHints.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Futil%2FThreadHints.java?ref=6ed9cace66652c86ea885e05f07280736e7dd66c",
      "patch": "@@ -21,7 +21,10 @@\n  * behaviours that are implemented in or anticipated to be spec'ed under the\n  * {@link java.lang.Thread} class in some Java SE versions, but missing in prior\n  * versions.\n+ * @deprecated Use Thread.onSpinWait() directly. This class previously existed to accommodate\n+ * Java versions which do not have Thread.onSpinWait().\n  */\n+@Deprecated\n public final class ThreadHints\n {\n \n@@ -36,7 +39,7 @@ private ThreadHints()\n      * the calling thread indicates to the runtime that it is busy-waiting. The runtime\n      * may take action to improve the performance of invoking spin-wait loop constructions.\n      *\n-     * @deprecated Use Thread.onSpinWait() directly. This method previously existed to accomodate\n+     * @deprecated Use Thread.onSpinWait() directly. This method previously existed to accommodate\n      * Java versions which do not have Thread.onSpinWait().\n      */\n     @Deprecated",
      "parent_sha": "7c9480ea6681879ffed38067d5322cc9032d3b97"
    }
  },
  {
    "oid": "14daff3db8284619c30d9378a5ad9e3b8756426f",
    "message": "Rewrite AggregateEventHandlerTest in spirit of JUnit 5",
    "date": "2020-12-04T16:36:32Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/14daff3db8284619c30d9378a5ad9e3b8756426f",
    "details": {
      "sha": "9074632a5d44d8e0ad9c3ec4f9aa0d68592f7ea5",
      "filename": "src/test/java/com/lmax/disruptor/AggregateEventHandlerTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/14daff3db8284619c30d9378a5ad9e3b8756426f/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FAggregateEventHandlerTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/14daff3db8284619c30d9378a5ad9e3b8756426f/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FAggregateEventHandlerTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FAggregateEventHandlerTest.java?ref=14daff3db8284619c30d9378a5ad9e3b8756426f",
      "patch": "@@ -16,10 +16,10 @@\n package com.lmax.disruptor;\n \n import com.lmax.disruptor.support.DummyEventHandler;\n-import org.junit.Test;\n+import org.junit.jupiter.api.Test;\n \n+import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.core.Is.is;\n-import static org.junit.Assert.assertThat;\n \n @SuppressWarnings(\"unchecked\")\n public final class AggregateEventHandlerTest",
      "parent_sha": "e00bd68a7b3a103038ee349ee9cad08523b66cf0"
    }
  },
  {
    "oid": "bfa29e8535e3280d7917c14b1d3612adc166fdca",
    "message": "Rename Torture test to Stress test.",
    "date": "2015-01-27T03:07:34Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/bfa29e8535e3280d7917c14b1d3612adc166fdca",
    "details": {
      "sha": "a31a11c1eb172026d9dd2a17167f66d01e365905",
      "filename": "src/test/java/com/lmax/disruptor/DisruptorStressTest.java",
      "status": "renamed",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/bfa29e8535e3280d7917c14b1d3612adc166fdca/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FDisruptorStressTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/bfa29e8535e3280d7917c14b1d3612adc166fdca/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FDisruptorStressTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FDisruptorStressTest.java?ref=bfa29e8535e3280d7917c14b1d3612adc166fdca",
      "patch": "@@ -16,7 +16,7 @@\n import com.lmax.disruptor.dsl.Disruptor;\n import com.lmax.disruptor.dsl.ProducerType;\n \n-public class TortureTest\n+public class DisruptorStressTest\n {\n     private final ExecutorService executor = Executors.newCachedThreadPool();\n \n@@ -172,7 +172,7 @@ private static class TestEvent\n         public long b;\n         public String s;\n \n-        public static final EventFactory<TestEvent> FACTORY = new EventFactory<TortureTest.TestEvent>()\n+        public static final EventFactory<TestEvent> FACTORY = new EventFactory<DisruptorStressTest.TestEvent>()\n         {\n             @Override\n             public TestEvent newInstance()",
      "previous_filename": "src/test/java/com/lmax/disruptor/TortureTest.java",
      "parent_sha": "03a05904b30f4905835573a727153b98a2afa181"
    }
  },
  {
    "oid": "319882b9cacbffa0f17b382012dcf47c7c68946b",
    "message": "Update AggregateEventHandlerTest.java\n\nrename function name",
    "date": "2022-03-16T07:48:52Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/319882b9cacbffa0f17b382012dcf47c7c68946b",
    "details": {
      "sha": "dee923c64ccb4a5b1f1bb303ed46c5b1db3f739c",
      "filename": "src/test/java/com/lmax/disruptor/AggregateEventHandlerTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/319882b9cacbffa0f17b382012dcf47c7c68946b/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FAggregateEventHandlerTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/319882b9cacbffa0f17b382012dcf47c7c68946b/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FAggregateEventHandlerTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FAggregateEventHandlerTest.java?ref=319882b9cacbffa0f17b382012dcf47c7c68946b",
      "patch": "@@ -61,7 +61,7 @@ public void shouldCallOnShutdownInSequence()\n \n         aggregateEventHandler.onShutdown();\n \n-        assertShutoownCalls(1, eh1, eh2, eh3);\n+        assertShutdownCalls(1, eh1, eh2, eh3);\n     }\n \n     @Test\n@@ -91,7 +91,7 @@ private static void assertStartCalls(final int startCalls, final DummyEventHandl\n         }\n     }\n \n-    private static void assertShutoownCalls(final int startCalls, final DummyEventHandler<int[]>... handlers)\n+    private static void assertShutdownCalls(final int startCalls, final DummyEventHandler<int[]>... handlers)\n     {\n         for (DummyEventHandler<int[]> handler : handlers)\n         {",
      "parent_sha": "ea78402656af6f6d1fc1d8b2497273fee267d148"
    }
  },
  {
    "oid": "33fc963b3662b4a25edc32e17974b1f275cc080b",
    "message": "remove misplaced millis suffix",
    "date": "2013-12-07T07:13:33Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/33fc963b3662b4a25edc32e17974b1f275cc080b",
    "details": {
      "sha": "cd352efecea2cabf3e667b243e0c35f17ed9133f",
      "filename": "src/main/java/com/lmax/disruptor/PhasedBackoffWaitStrategy.java",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/33fc963b3662b4a25edc32e17974b1f275cc080b/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FPhasedBackoffWaitStrategy.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/33fc963b3662b4a25edc32e17974b1f275cc080b/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FPhasedBackoffWaitStrategy.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FPhasedBackoffWaitStrategy.java?ref=33fc963b3662b4a25edc32e17974b1f275cc080b",
      "patch": "@@ -34,35 +34,35 @@ public final class PhasedBackoffWaitStrategy implements WaitStrategy\n     private final long yieldTimeoutNanos;\n     private final BlockingStrategy lockingStrategy;\n \n-    public PhasedBackoffWaitStrategy(long spinTimeoutMillis,\n-                                     long yieldTimeoutMillis,\n+    public PhasedBackoffWaitStrategy(long spinTimeout,\n+                                     long yieldTimeout,\n                                      TimeUnit units,\n                                      BlockingStrategy lockingStrategy)\n     {\n-        this.spinTimeoutNanos = units.toNanos(spinTimeoutMillis);\n-        this.yieldTimeoutNanos = spinTimeoutNanos + units.toNanos(yieldTimeoutMillis);\n+        this.spinTimeoutNanos = units.toNanos(spinTimeout);\n+        this.yieldTimeoutNanos = spinTimeoutNanos + units.toNanos(yieldTimeout);\n         this.lockingStrategy = lockingStrategy;\n     }\n \n     /**\n      * Block with wait/notifyAll semantics\n      */\n-    public static PhasedBackoffWaitStrategy withLock(long spinTimeoutMillis,\n-                                                     long yieldTimeoutMillis,\n+    public static PhasedBackoffWaitStrategy withLock(long spinTimeout,\n+                                                     long yieldTimeout,\n                                                      TimeUnit units)\n     {\n-        return new PhasedBackoffWaitStrategy(spinTimeoutMillis, yieldTimeoutMillis,\n+        return new PhasedBackoffWaitStrategy(spinTimeout, yieldTimeout,\n                                              units, new LockBlockingStrategy());\n     }\n \n     /**\n      * Block by sleeping in a loop\n      */\n-    public static PhasedBackoffWaitStrategy withSleep(long spinTimeoutMillis,\n-                                                      long yieldTimeoutMillis,\n+    public static PhasedBackoffWaitStrategy withSleep(long spinTimeout,\n+                                                      long yieldTimeout,\n                                                       TimeUnit units)\n     {\n-        return new PhasedBackoffWaitStrategy(spinTimeoutMillis, yieldTimeoutMillis,\n+        return new PhasedBackoffWaitStrategy(spinTimeout, yieldTimeout,\n                                              units, new SleepBlockingStrategy());\n     }\n ",
      "parent_sha": "129150c937daea5a35fbf3ff8381293169a3a352"
    }
  },
  {
    "oid": "138090c48e2286c6aa8da3531d9bb35e04717afa",
    "message": "cached value does not need to be volatile",
    "date": "2011-06-29T21:01:16Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/138090c48e2286c6aa8da3531d9bb35e04717afa",
    "details": {
      "sha": "951760712b124f74556e726621e238baa617b661",
      "filename": "code/src/main/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/138090c48e2286c6aa8da3531d9bb35e04717afa/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/138090c48e2286c6aa8da3531d9bb35e04717afa/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=138090c48e2286c6aa8da3531d9bb35e04717afa",
      "patch": "@@ -201,10 +201,10 @@ public void clearAlert()\n      * {@link ProducerBarrier} that tracks multiple {@link Consumer}s when trying to claim\n      * a {@link AbstractEntry} in the {@link RingBuffer}.\n      */\n-    final class ConsumerTrackingProducerBarrier implements ProducerBarrier<T>\n+    private final class ConsumerTrackingProducerBarrier implements ProducerBarrier<T>\n     {\n-        private volatile long lastConsumerMinimum = 0L;\n         private final Consumer[] consumers;\n+        private long lastConsumerMinimum = 0L;\n \n         public ConsumerTrackingProducerBarrier(final Consumer... consumers)\n         {\n@@ -263,10 +263,10 @@ private void ensureConsumersAreInRange(final long sequence)\n      * {@link ForceFillProducerBarrier} that tracks multiple {@link Consumer}s when trying to claim\n      * a {@link AbstractEntry} in the {@link RingBuffer}.\n      */\n-    final class ForceFillConsumerTrackingProducerBarrier implements ForceFillProducerBarrier<T>\n+    private final class ForceFillConsumerTrackingProducerBarrier implements ForceFillProducerBarrier<T>\n     {\n-        private long lastConsumerMinimum = 0L;\n         private final Consumer[] consumers;\n+        private long lastConsumerMinimum = 0L;\n \n         public ForceFillConsumerTrackingProducerBarrier(final Consumer... consumers)\n         {",
      "parent_sha": "05c0a15ed683bf5a3e9985337f7ca7a79683ab73"
    }
  },
  {
    "oid": "f875fa906118f33bff5a09a8d8cd1d3971408096",
    "message": "expose batchsize on batch event publication.",
    "date": "2013-04-15T09:34:53Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/f875fa906118f33bff5a09a8d8cd1d3971408096",
    "details": {
      "sha": "4ab9242c9d299bdff60f36df22243e070c3509fc",
      "filename": "src/main/java/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 241,
      "deletions": 97,
      "changes": 338,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/f875fa906118f33bff5a09a8d8cd1d3971408096/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/f875fa906118f33bff5a09a8d8cd1d3971408096/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=f875fa906118f33bff5a09a8d8cd1d3971408096",
      "patch": "@@ -534,17 +534,22 @@ public boolean tryPublishEvent(EventTranslatorVararg<E> translator, Object...arg\n      * @param translators The user specified translation for each event\n      */\n     public void publishEvents(EventTranslator<E>[] translators) {\n-        final long initialSequence = sequencer.getCursor() == -1 ? sequencer.next() : sequencer.getCursor();\n-        final long finalSequence = sequencer.next(translators.length);\n-        try {\n-            for (int i = 0; i < translators.length; i++) {\n-                final EventTranslator<E> translator = translators[i];\n-                final long sequence = initialSequence + i;\n-                translator.translateTo(getPreallocated(sequence), sequence);\n-            }\n-        } finally {\n-            sequencer.publish(finalSequence);\n-        }\n+        publishEvents(translators, translators.length);\n+    }\n+\n+    /**\n+     * Publishes multiple events to the ring buffer.  It handles\n+     * claiming the next sequence, getting the current (uninitialised)\n+     * event from the ring buffer and publishing the claimed sequence\n+     * after translation.\n+     *\n+     * @param translators The user specified translation for each event\n+     * @param batchSize The actual size of the batch\n+     */\n+    public void publishEvents(EventTranslator<E>[] translators, int batchSize) {\n+        final long initialSequence = getInitialSequenceForBatchUsingNext();\n+        final long finalSequence = sequencer.next(batchSize);\n+        translateAndPublishBatch(translators, batchSize, initialSequence, finalSequence);\n     }\n \n     /**\n@@ -559,15 +564,26 @@ public void publishEvents(EventTranslator<E>[] translators) {\n      *         capacity.\n      */\n     public boolean tryPublishEvents(EventTranslator<E>[] translators) {\n+        return tryPublishEvents(translators, translators.length);\n+    }\n+\n+    /**\n+     * Attempts to publish multiple events to the ring buffer.  It handles\n+     * claiming the next sequence, getting the current (uninitialised)\n+     * event from the ring buffer and publishing the claimed sequence\n+     * after translation.  Will return false if specified capacity\n+     * was not available.\n+     *\n+     * @param translators The user specified translation for the event\n+     * @param batchSize The actual size of the batch\n+     * @return true if all the values were published, false if there was insufficient\n+     *         capacity.\n+     */\n+    public boolean tryPublishEvents(EventTranslator<E>[] translators, int batchSize) {\n         try {\n             final long initialSequence = getInitialSequenceForBatchUsingTryNext();\n-            final long finalSequence = sequencer.tryNext(translators.length);\n-            for (int i = 0; i < translators.length; i++) {\n-                final EventTranslator<E> translator = translators[i];\n-                final long sequence = initialSequence + i;\n-                translator.translateTo(getPreallocated(sequence), sequence);\n-            }\n-            sequencer.publish(initialSequence, finalSequence);\n+            final long finalSequence = sequencer.tryNext(batchSize);\n+            translateAndPublishBatch(translators, batchSize, initialSequence, finalSequence);\n             return true;\n         } catch (InsufficientCapacityException e) {\n             return false;\n@@ -579,39 +595,54 @@ public boolean tryPublishEvents(EventTranslator<E>[] translators) {\n      *\n      * @param translator The user specified translation for the event\n      * @param arg0       A user supplied argument.\n-     * @see #publishEvents(EventTranslator[])\n+     * @see #publishEvents(com.lmax.disruptor.EventTranslator[])\n      */\n     public <A> void publishEvents(EventTranslatorOneArg<E, A> translator, A[] arg0) {\n-        final long initialCursor = getInitialSequenceForBatchUsingNext();\n-        final long finalSequence = sequencer.next(arg0.length);\n-        try {\n-            for (int i = 0; i < arg0.length; i++) {\n-                final long sequence = finalSequence - (arg0.length - i);\n-                translator.translateTo(getPreallocated(sequence), sequence, arg0[i]);\n-            }\n-        } finally {\n-            sequencer.publish(initialCursor, finalSequence);\n-        }\n+        publishEvents(translator, arg0, arg0.length);\n+    }\n+\n+    /**\n+     * Allows one user supplied argument per event.\n+     *\n+     * @param translator The user specified translation for each event\n+     * @param arg0       An array of user supplied arguments, one element per event.\n+     * @param batchSize The actual size of the batch\n+     * @see #publishEvents(EventTranslator[])\n+     */\n+    public <A> void publishEvents(EventTranslatorOneArg<E, A> translator, A[] arg0, int batchSize) {\n+        final long initialSequence = getInitialSequenceForBatchUsingNext();\n+        final long finalSequence = sequencer.next(batchSize);\n+        translateAndPublishBatch(translator, arg0, batchSize, initialSequence, finalSequence);\n     }\n \n     /**\n      * Allows one user supplied argument.\n      *\n-     * @param translator The user specified translation for the event\n-     * @param arg0       A user supplied argument.\n+     * @param translator The user specified translation for each event\n+     * @param arg0       An array of user supplied arguments, one element per event.\n      * @return true if the value was published, false if there was insufficient\n      *         capacity.\n-     * @see #tryPublishEvents(EventTranslator[])\n+     * @see #tryPublishEvents(com.lmax.disruptor.EventTranslator[])\n      */\n     public <A> boolean tryPublishEvents(EventTranslatorOneArg<E, A> translator, A[] arg0) {\n+        return tryPublishEvents(translator, arg0, arg0.length);\n+    }\n+\n+    /**\n+     * Allows one user supplied argument.\n+     *\n+     * @param translator The user specified translation for each event\n+     * @param arg0       An array of user supplied arguments, one element per event.\n+     * @param batchSize The actual size of the batch\n+     * @return true if the value was published, false if there was insufficient\n+     *         capacity.\n+     * @see #tryPublishEvents(EventTranslator[])\n+     */\n+    public <A> boolean tryPublishEvents(EventTranslatorOneArg<E, A> translator, A[] arg0, int batchSize) {\n         try {\n             final long initialSequence = getInitialSequenceForBatchUsingTryNext();\n-            final long finalSequence = sequencer.tryNext(arg0.length);\n-            for (int i = 0; i < arg0.length; i++) {\n-                final long sequence = initialSequence + i;\n-                translator.translateTo(getPreallocated(sequence), sequence, arg0[i]);\n-            }\n-            sequencer.publish(initialSequence, finalSequence);\n+            final long finalSequence = sequencer.tryNext(batchSize);\n+            translateAndPublishBatch(translator, arg0, batchSize, initialSequence, finalSequence);\n             return true;\n         } catch (InsufficientCapacityException e) {\n             return false;\n@@ -622,39 +653,59 @@ public <A> boolean tryPublishEvents(EventTranslatorOneArg<E, A> translator, A[]\n      * Allows two user supplied arguments per event.\n      *\n      * @param translator The user specified translation for the event\n-     * @param arg0       A user supplied argument.\n-     * @param arg1       A user supplied argument.\n-     * @see #publishEvents(EventTranslator[])\n+     * @param arg0       An array of user supplied arguments, one element per event.\n+     * @param arg1       An array of user supplied arguments, one element per event.\n+     * @see #publishEvents(com.lmax.disruptor.EventTranslator[])\n      */\n     public <A, B> void publishEvents(EventTranslatorTwoArg<E, A, B> translator, A[] arg0, B[] arg1) {\n+        publishEvents(translator, arg0, arg1, arg0.length);\n+    }\n+\n+    /**\n+     * Allows two user supplied arguments per event.\n+     *\n+     * @param translator The user specified translation for the event\n+     * @param arg0       An array of user supplied arguments, one element per event.\n+     * @param arg1       An array of user supplied arguments, one element per event.\n+     * @param batchSize The actual size of the batch.\n+     * @see #publishEvents(EventTranslator[])\n+     */\n+    public <A, B> void publishEvents(EventTranslatorTwoArg<E, A, B> translator, A[] arg0, B[] arg1, int batchSize) {\n         final long initialSequence = getInitialSequenceForBatchUsingNext();\n-        final long finalSequence = sequencer.next(arg0.length);\n-        for (int i = 0; i < arg0.length; i++) {\n-            final long sequence = finalSequence - (arg0.length - i);\n-            translator.translateTo(getPreallocated(sequence), sequence, arg0[i], arg1[i]);\n-        }\n-        sequencer.publish(initialSequence, finalSequence);\n+        final long finalSequence = sequencer.next(batchSize);\n+        translateAndPublishBatch(translator, arg0, arg1, batchSize, initialSequence, finalSequence);\n     }\n \n     /**\n      * Allows two user supplied arguments per event.\n      *\n      * @param translator The user specified translation for the event\n-     * @param arg0       A user supplied argument.\n-     * @param arg1       A user supplied argument.\n+     * @param arg0       An array of user supplied arguments, one element per event.\n+     * @param arg1       An array of user supplied arguments, one element per event.\n      * @return true if the value was published, false if there was insufficient\n      *         capacity.\n-     * @see #tryPublishEvents(EventTranslator[])\n+     * @see #tryPublishEvents(com.lmax.disruptor.EventTranslator[])\n      */\n     public <A, B> boolean tryPublishEvents(EventTranslatorTwoArg<E, A, B> translator, A[] arg0, B[] arg1) {\n+        return tryPublishEvents(translator, arg0, arg1, arg0.length);\n+    }\n+\n+    /**\n+     * Allows two user supplied arguments per event.\n+     *\n+     * @param translator The user specified translation for the event\n+     * @param arg0       An array of user supplied arguments, one element per event.\n+     * @param arg1       An array of user supplied arguments, one element per event.\n+     * @param batchSize  The actual size of the batch.\n+     * @return true if the value was published, false if there was insufficient\n+     *         capacity.\n+     * @see #tryPublishEvents(EventTranslator[])\n+     */\n+    public <A, B> boolean tryPublishEvents(EventTranslatorTwoArg<E, A, B> translator, A[] arg0, B[] arg1, int batchSize) {\n         try {\n             final long initialSequence = getInitialSequenceForBatchUsingTryNext();\n-            final long finalSequence = sequencer.tryNext(arg0.length);\n-            for (int i = 0; i < arg0.length; i++) {\n-                final long sequence = finalSequence - (arg0.length - i);\n-                translator.translateTo(getPreallocated(sequence), sequence, arg0[i], arg1[i]);\n-            }\n-            sequencer.publish(initialSequence, finalSequence);\n+            final long finalSequence = sequencer.tryNext(batchSize);\n+            translateAndPublishBatch(translator, arg0, arg1, batchSize, initialSequence, finalSequence);\n             return true;\n         } catch (InsufficientCapacityException e) {\n             return false;\n@@ -665,44 +716,63 @@ public <A, B> boolean tryPublishEvents(EventTranslatorTwoArg<E, A, B> translator\n      * Allows three user supplied arguments per event.\n      *\n      * @param translator The user specified translation for the event\n-     * @param arg0       A user supplied argument.\n-     * @param arg1       A user supplied argument.\n-     * @param arg2       A user supplied argument.\n-     * @see #publishEvents(EventTranslator[])\n+     * @param arg0       An array of user supplied arguments, one element per event.\n+     * @param arg1       An array of user supplied arguments, one element per event.\n+     * @param arg2       An array of user supplied arguments, one element per event.\n+     * @see #publishEvents(com.lmax.disruptor.EventTranslator[])\n      */\n     public <A, B, C> void publishEvents(EventTranslatorThreeArg<E, A, B, C> translator, A[] arg0, B[] arg1, C[] arg2) {\n+        publishEvents(translator, arg0, arg1, arg2, arg0.length);\n+    }\n+\n+    /**\n+     * Allows three user supplied arguments per event.\n+     *\n+     * @param translator The user specified translation for the event\n+     * @param arg0       An array of user supplied arguments, one element per event.\n+     * @param arg1       An array of user supplied arguments, one element per event.\n+     * @param arg2       An array of user supplied arguments, one element per event.\n+     * @param batchSize\n+     * @see #publishEvents(EventTranslator[])\n+     */\n+    public <A, B, C> void publishEvents(EventTranslatorThreeArg<E, A, B, C> translator, A[] arg0, B[] arg1, C[] arg2, int batchSize) {\n         final long initialSequence = getInitialSequenceForBatchUsingNext();\n-        final long finalSequence = sequencer.next(arg0.length);\n-        try {\n-            for (int i = 0; i < arg0.length; i++) {\n-                final long sequence = initialSequence + i;\n-                translator.translateTo(getPreallocated(sequence), sequence, arg0[i], arg1[i], arg2[i]);\n-            }\n-        } finally {\n-            sequencer.publish(initialSequence, finalSequence);\n-        }\n+        final long finalSequence = sequencer.next(batchSize);\n+        translateAndPublishBatch(translator, arg0, arg1, arg2, batchSize, initialSequence, finalSequence);\n     }\n \n     /**\n      * Allows three user supplied arguments per event.\n      *\n      * @param translator The user specified translation for the event\n-     * @param arg0       A user supplied argument.\n-     * @param arg1       A user supplied argument.\n-     * @param arg2       A user supplied argument.\n+     * @param arg0       An array of user supplied arguments, one element per event.\n+     * @param arg1       An array of user supplied arguments, one element per event.\n+     * @param arg2       An array of user supplied arguments, one element per event.\n      * @return true if the value was published, false if there was insufficient\n      *         capacity.\n-     * @see #publishEvents(EventTranslator[])\n+     * @see #publishEvents(com.lmax.disruptor.EventTranslator[])\n      */\n     public <A, B, C> boolean tryPublishEvents(EventTranslatorThreeArg<E, A, B, C> translator, A[] arg0, B[] arg1, C[] arg2) {\n+        return tryPublishEvents(translator, arg0, arg1, arg2, arg0.length);\n+    }\n+\n+    /**\n+     * Allows three user supplied arguments per event.\n+     *\n+     * @param translator The user specified translation for the event\n+     * @param arg0       An array of user supplied arguments, one element per event.\n+     * @param arg1       An array of user supplied arguments, one element per event.\n+     * @param arg2       An array of user supplied arguments, one element per event.\n+     * @param batchSize  The actual size of the batch.\n+     * @return true if the value was published, false if there was insufficient\n+     *         capacity.\n+     * @see #publishEvents(EventTranslator[])\n+     */\n+    public <A, B, C> boolean tryPublishEvents(EventTranslatorThreeArg<E, A, B, C> translator, A[] arg0, B[] arg1, C[] arg2, int batchSize) {\n         try {\n             final long initialSequence = getInitialSequenceForBatchUsingTryNext();\n-            final long finalSequence = sequencer.tryNext(arg0.length);\n-            for (int i = 0; i < arg0.length; i++) {\n-                final long sequence = initialSequence + i;\n-                translator.translateTo(getPreallocated(sequence), sequence, arg0[i], arg1[i], arg2[i]);\n-            }\n-            sequencer.publish(initialSequence, finalSequence);\n+            final long finalSequence = sequencer.tryNext(batchSize);\n+            translateAndPublishBatch(translator, arg0, arg1, arg2, batchSize, initialSequence, finalSequence);\n             return true;\n         } catch (InsufficientCapacityException e) {\n             return false;\n@@ -713,38 +783,56 @@ public <A, B, C> boolean tryPublishEvents(EventTranslatorThreeArg<E, A, B, C> tr\n      * Allows a variable number of user supplied arguments per event.\n      *\n      * @param translator The user specified translation for the event\n-     * @param args       User supplied arguments.\n-     * @see #publishEvents(EventTranslator[])\n+     * @param args       User supplied arguments, one Object[] per event.\n+     * @see #publishEvents(com.lmax.disruptor.EventTranslator[])\n      */\n     public void publishEvents(EventTranslatorVararg<E> translator, Object[]... args) {\n+        publishEvents(translator, args.length, args);\n+    }\n+\n+    /**\n+     * Allows a variable number of user supplied arguments per event.\n+     *\n+     * @param translator The user specified translation for the event\n+     * @param batchSize  The actual size of the batch\n+     * @param args       User supplied arguments, one Object[] per event.\n+     * @see #publishEvents(EventTranslator[])\n+     */\n+    public void publishEvents(EventTranslatorVararg<E> translator, int batchSize, Object[]... args) {\n         final long initialSequence = getInitialSequenceForBatchUsingNext();\n-        final long finalSequence = sequencer.next(args.length);\n-        try {\n-            for (int i = 0; i < args.length; i++) {\n-                final long sequence = initialSequence + i;\n-                translator.translateTo(getPreallocated(sequence), sequence, args[i]);\n-            }\n-        } finally {\n-            sequencer.publish(initialSequence, finalSequence);\n-        }\n+        final long finalSequence = sequencer.next(batchSize);\n+        translateAndPublishBatch(translator, batchSize, initialSequence, finalSequence, args);\n     }\n \n     /**\n      * Allows a variable number of user supplied arguments per event.\n      *\n      * @param translator The user specified translation for the event\n-     * @param args       User supplied arguments.\n+     * @param args       User supplied arguments, one Object[] per event.\n      * @return true if the value was published, false if there was insufficient\n      *         capacity.\n-     * @see #publishEvents(EventTranslator[])\n+     * @see #publishEvents(com.lmax.disruptor.EventTranslator[])\n      */\n     public boolean tryPublishEvents(EventTranslatorVararg<E> translator, Object[]... args) {\n+        return tryPublishEvents(translator, args.length, args);\n+    }\n+\n+    /**\n+     * Allows a variable number of user supplied arguments per event.\n+     *\n+     * @param translator The user specified translation for the event\n+     * @param batchSize  The actual size of the batch.\n+     * @param args       User supplied arguments, one Object[] per event.\n+     *\n+     * @return true if the value was published, false if there was insufficient\n+     *         capacity.\n+     * @see #publishEvents(EventTranslator[])\n+     */\n+    public boolean tryPublishEvents(EventTranslatorVararg<E> translator, int batchSize, Object[]... args) {\n         try {\n-            final long finalSequence = sequencer.tryNext(args.length);\n-            for (int i = 0; i < args.length; i++) {\n-                final long sequence = finalSequence - (args.length - i);\n-                translator.translateTo(getPreallocated(sequence), sequence, args[i]);\n-            }\n+            final long finalSequence = sequencer.tryNext(batchSize);\n+            final long initialSequence = getInitialSequenceForBatchUsingTryNext();\n+            translateAndPublishBatch(translator, batchSize, initialSequence, finalSequence, args);\n             return true;\n         } catch (InsufficientCapacityException e) {\n             return false;\n@@ -847,6 +935,62 @@ private <A> void translateAndPublish(EventTranslatorVararg<E> translator, long s\n         }\n     }\n \n+    private void translateAndPublishBatch(final EventTranslator<E>[] translators, final int batchSize, final long initialSequence, final long finalSequence) {\n+        try {\n+            for (int i = 0; i < batchSize; i++) {\n+                final EventTranslator<E> translator = translators[i];\n+                final long sequence = initialSequence + i;\n+                translator.translateTo(getPreallocated(sequence), sequence);\n+            }\n+        } finally {\n+            sequencer.publish(finalSequence);\n+        }\n+    }\n+\n+    private <A> void translateAndPublishBatch(final EventTranslatorOneArg<E, A> translator, final A[] arg0, final int batchSize, final long initialSequence, final long finalSequence) {\n+        try {\n+            for (int i = 0; i < batchSize; i++) {\n+                final long sequence = initialSequence + i;\n+                translator.translateTo(getPreallocated(sequence), sequence, arg0[i]);\n+            }\n+        } finally {\n+            sequencer.publish(initialSequence, finalSequence);\n+        }\n+    }\n+\n+    private <A, B> void translateAndPublishBatch(final EventTranslatorTwoArg<E, A, B> translator, final A[] arg0, final B[] arg1, int batchSize, long initialSequence, final long finalSequence) {\n+        try {\n+            for (int i = 0; i < batchSize; i++) {\n+                final long sequence = initialSequence + i;\n+                translator.translateTo(getPreallocated(sequence), sequence, arg0[i], arg1[i]);\n+            }\n+        } finally {\n+            sequencer.publish(initialSequence, finalSequence);\n+        }\n+    }\n+\n+    private <A, B, C> void translateAndPublishBatch(final EventTranslatorThreeArg<E, A, B, C> translator, final A[] arg0, final B[] arg1, final C[] arg2, final int batchSize, final long initialSequence, final long finalSequence) {\n+        try {\n+            for (int i = 0; i < batchSize; i++) {\n+                final long sequence = initialSequence + i;\n+                translator.translateTo(getPreallocated(sequence), sequence, arg0[i], arg1[i], arg2[i]);\n+            }\n+        } finally {\n+            sequencer.publish(initialSequence, finalSequence);\n+        }\n+    }\n+\n+    private void translateAndPublishBatch(final EventTranslatorVararg<E> translator, final int batchSize, final long initialSequence, final long finalSequence, final Object[][] args) {\n+        try {\n+            for (int i = 0; i < batchSize; i++) {\n+                final long sequence = initialSequence + i;\n+                translator.translateTo(getPreallocated(sequence), sequence, args[i]);\n+            }\n+        } finally {\n+            sequencer.publish(initialSequence, finalSequence);\n+        }\n+    }\n+\n     private void fill(EventFactory<E> eventFactory)\n     {\n         for (int i = 0; i < entries.length; i++)",
      "parent_sha": "e555dbfcd015e524ff5ca8cab86a7bef10de0a20"
    }
  },
  {
    "oid": "110ffa21d2a44cd77ec71aaa81c66b41fcc13419",
    "message": "Javadoc for RingBuffer get method",
    "date": "2012-11-09T09:07:15Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/110ffa21d2a44cd77ec71aaa81c66b41fcc13419",
    "details": {
      "sha": "868acf45282a78c3ef578edbd43fc36faafe5dc6",
      "filename": "src/main/java/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 8,
      "deletions": 2,
      "changes": 10,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/110ffa21d2a44cd77ec71aaa81c66b41fcc13419/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/110ffa21d2a44cd77ec71aaa81c66b41fcc13419/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=110ffa21d2a44cd77ec71aaa81c66b41fcc13419",
      "patch": "@@ -146,10 +146,16 @@ public static <E> RingBuffer<E> createSingleProducer(EventFactory<E> factory, in\n     }\n \n     /**\n-     * Get the event for a given sequence in the RingBuffer.\n+     * <p>Get the event for a given sequence in the RingBuffer.  This method will wait until the\n+     * value is published before returning.  This method should only be used by {@link EventProcessor}s\n+     * that are reading values out of the ring buffer.  Publishing code should use the \n+     * {@link RingBuffer#getPreallocated(long)} call to get a handle onto the preallocated event.\n+     * \n+     * <p>The call implements the appropriate load fence to ensure that the data within the event\n+     * is visible after this call completes.\n      *\n      * @param sequence for the event\n-     * @return event for the sequence\n+     * @return the published event that\n      */\n     @SuppressWarnings(\"unchecked\")\n     public E get(final long sequence)",
      "parent_sha": "fa16fd84d786a7c4e3a6325f8d451850950fb973"
    }
  },
  {
    "oid": "1255aafb5ecb7da3842f302afb8218b4b8fd82ac",
    "message": "Fixed bug in YieldingStrategy that was busy spinning more than yielding and introduced SleepingStrategy.",
    "date": "2011-08-31T07:32:19Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/1255aafb5ecb7da3842f302afb8218b4b8fd82ac",
    "details": {
      "sha": "2a1536889cc25f02d29da64e585bcb6f1191f53f",
      "filename": "code/src/main/com/lmax/disruptor/WaitStrategy.java",
      "status": "modified",
      "additions": 171,
      "deletions": 57,
      "changes": 228,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/1255aafb5ecb7da3842f302afb8218b4b8fd82ac/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FWaitStrategy.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/1255aafb5ecb7da3842f302afb8218b4b8fd82ac/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FWaitStrategy.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FWaitStrategy.java?ref=1255aafb5ecb7da3842f302afb8218b4b8fd82ac",
      "patch": "@@ -68,8 +68,10 @@ long waitFor(Sequence[] dependents, Sequence cursor, DependencyBarrier barrier,\n      */\n     enum Option\n     {\n-        /** This strategy uses a condition variable inside a lock to block the event processor\n-         * which saves CPU resource as the expense of lock contention. */\n+        /**\n+         * This strategy uses a condition variable inside a lock to block the event processor\n+         * which saves CPU resource as the expense of lock contention.\n+         */\n         BLOCKING\n         {\n             @Override\n@@ -79,7 +81,23 @@ public WaitStrategy newInstance()\n             }\n         },\n \n-        /** This strategy calls Thread.yield() in a loop as a waiting strategy which reduces contention at the expense of CPU resource. */\n+        /**\n+         * This strategy uses a progressive back off strategy by first spinning, then yielding, then sleeping for 1ms periods.\n+         * This is a good strategy for burst traffic then quiet periods when latency is not critical.\n+         */\n+        SLEEPING\n+        {\n+            @Override\n+            public SleepingStrategy newInstance()\n+            {\n+                return new SleepingStrategy();\n+            }\n+        },\n+\n+        /**\n+         * This strategy calls Thread.yield() in a loop as a waiting strategy which reduces contention\n+         * at the expense of CPU resource.\n+         */\n         YIELDING\n         {\n             @Override\n@@ -89,7 +107,10 @@ public WaitStrategy newInstance()\n             }\n         },\n \n-        /** This strategy call spins in a loop as a waiting strategy which is lowest and most consistent latency but ties up a CPU */\n+        /**\n+         * This strategy call spins in a loop as a waiting strategy which is lowest\n+         * and most consistent latency but ties up a CPU\n+         */\n         BUSY_SPIN\n         {\n             @Override\n@@ -216,13 +237,14 @@ public void signalAll()\n     }\n \n     /**\n-     * Yielding strategy that uses a Thread.yield() for {@link EventProcessor}s waiting on a barrier.\n+     * Yielding strategy that uses a Thread.yield() for {@link EventProcessor}s waiting on a barrier\n+     * after an initially spinning.\n      *\n      * This strategy is a good compromise between performance and CPU resource.\n      */\n-    static final class YieldingStrategy implements WaitStrategy\n+    static final class SleepingStrategy implements WaitStrategy\n     {\n-        private static final int SPIN_TRIES = 100;\n+        private static final int SPIN_TRIES = 200;\n \n         @Override\n         public long waitFor(final Sequence[] dependents, final Sequence cursor, final DependencyBarrier barrier, final long sequence)\n@@ -235,32 +257,14 @@ public long waitFor(final Sequence[] dependents, final Sequence cursor, final De\n             {\n                 while ((availableSequence = cursor.get()) < sequence)\n                 {\n-                    if (barrier.isAlerted())\n-                    {\n-                        throw ALERT_EXCEPTION;\n-                    }\n-\n-                    if (0 == --counter)\n-                    {\n-                        counter = SPIN_TRIES;\n-                        Thread.yield();\n-                    }\n+                    counter = applyWaitMethod(barrier, counter);\n                 }\n             }\n             else\n             {\n                 while ((availableSequence = getMinimumSequence(dependents)) < sequence)\n                 {\n-                    if (barrier.isAlerted())\n-                    {\n-                        throw ALERT_EXCEPTION;\n-                    }\n-\n-                    if (0 == --counter)\n-                    {\n-                        counter = SPIN_TRIES;\n-                        Thread.yield();\n-                    }\n+                    counter = applyWaitMethod(barrier, counter);\n                 }\n             }\n \n@@ -281,37 +285,130 @@ public long waitFor(final Sequence[] dependents, final Sequence cursor, final De\n             {\n                 while ((availableSequence = cursor.get()) < sequence)\n                 {\n-                    if (barrier.isAlerted())\n-                    {\n-                        throw ALERT_EXCEPTION;\n-                    }\n+                    counter = applyWaitMethod(barrier, counter);\n \n-                    if (0 == --counter)\n+                    if (timeoutMs < (System.currentTimeMillis() - currentTime))\n                     {\n-                        counter = SPIN_TRIES;\n-                        Thread.yield();\n+                        break;\n                     }\n+                }\n+            }\n+            else\n+            {\n+                while ((availableSequence = getMinimumSequence(dependents)) < sequence)\n+                {\n+                    counter = applyWaitMethod(barrier, counter);\n \n                     if (timeoutMs < (System.currentTimeMillis() - currentTime))\n                     {\n                         break;\n                     }\n                 }\n             }\n+\n+            return availableSequence;\n+        }\n+\n+        @Override\n+        public void signalAll()\n+        {\n+        }\n+\n+        private int applyWaitMethod(final DependencyBarrier barrier, int counter)\n+            throws AlertException\n+        {\n+            if (barrier.isAlerted())\n+            {\n+                throw ALERT_EXCEPTION;\n+            }\n+\n+            if (counter > 100)\n+            {\n+                --counter;\n+            }\n+            else if (counter > 0)\n+            {\n+                --counter;\n+                Thread.yield();\n+            }\n+            else\n+            {\n+                try\n+                {\n+                    Thread.sleep(1L);\n+                }\n+                catch (InterruptedException ex)\n+                {\n+                    // do nothing\n+                }\n+            }\n+\n+            return counter;\n+        }\n+    }\n+\n+    /**\n+     * Yielding strategy that uses a Thread.yield() for {@link EventProcessor}s waiting on a barrier\n+     * after an initially spinning.\n+     *\n+     * This strategy is a good compromise between performance and CPU resource.\n+     */\n+    static final class YieldingStrategy implements WaitStrategy\n+    {\n+        private static final int SPIN_TRIES = 100;\n+\n+        @Override\n+        public long waitFor(final Sequence[] dependents, final Sequence cursor, final DependencyBarrier barrier, final long sequence)\n+            throws AlertException, InterruptedException\n+        {\n+            long availableSequence;\n+\n+            int counter = SPIN_TRIES;\n+            if (0 == dependents.length)\n+            {\n+                while ((availableSequence = cursor.get()) < sequence)\n+                {\n+                    counter = applyWaitMethod(barrier, counter);\n+                }\n+            }\n             else\n             {\n                 while ((availableSequence = getMinimumSequence(dependents)) < sequence)\n                 {\n-                    if (barrier.isAlerted())\n-                    {\n-                        throw ALERT_EXCEPTION;\n-                    }\n+                    counter = applyWaitMethod(barrier, counter);\n+                }\n+            }\n \n-                    if (0 == --counter)\n+            return availableSequence;\n+        }\n+\n+        @Override\n+        public long waitFor(final Sequence[] dependents, final Sequence cursor, final DependencyBarrier barrier,\n+                            final long sequence, final long timeout, final TimeUnit units)\n+            throws AlertException, InterruptedException\n+        {\n+            final long timeoutMs = units.convert(timeout, TimeUnit.MILLISECONDS);\n+            final long currentTime = System.currentTimeMillis();\n+            long availableSequence;\n+\n+            int counter = SPIN_TRIES;\n+            if (0 == dependents.length)\n+            {\n+                while ((availableSequence = cursor.get()) < sequence)\n+                {\n+                    counter = applyWaitMethod(barrier, counter);\n+\n+                    if (timeoutMs < (System.currentTimeMillis() - currentTime))\n                     {\n-                        counter = SPIN_TRIES;\n-                        Thread.yield();\n+                        break;\n                     }\n+                }\n+            }\n+            else\n+            {\n+                while ((availableSequence = getMinimumSequence(dependents)) < sequence)\n+                {\n+                    counter = applyWaitMethod(barrier, counter);\n \n                     if (timeoutMs < (System.currentTimeMillis() - currentTime))\n                     {\n@@ -327,6 +424,26 @@ public long waitFor(final Sequence[] dependents, final Sequence cursor, final De\n         public void signalAll()\n         {\n         }\n+\n+        private int applyWaitMethod(final DependencyBarrier barrier, int counter)\n+            throws AlertException\n+        {\n+            if (barrier.isAlerted())\n+            {\n+                throw ALERT_EXCEPTION;\n+            }\n+\n+            if (0 == counter)\n+            {\n+                Thread.yield();\n+            }\n+            else\n+            {\n+                --counter;\n+            }\n+\n+            return counter;\n+        }\n     }\n \n     /**\n@@ -347,20 +464,14 @@ public long waitFor(final Sequence[] dependents, final Sequence cursor, final De\n             {\n                 while ((availableSequence = cursor.get()) < sequence)\n                 {\n-                    if (barrier.isAlerted())\n-                    {\n-                        throw ALERT_EXCEPTION;\n-                    }\n+                    applyWaitMethod(barrier);\n                 }\n             }\n             else\n             {\n                 while ((availableSequence = getMinimumSequence(dependents)) < sequence)\n                 {\n-                    if (barrier.isAlerted())\n-                    {\n-                        throw ALERT_EXCEPTION;\n-                    }\n+                    applyWaitMethod(barrier);\n                 }\n             }\n \n@@ -380,10 +491,7 @@ public long waitFor(final Sequence[] dependents, final Sequence cursor, final De\n             {\n                 while ((availableSequence = cursor.get()) < sequence)\n                 {\n-                    if (barrier.isAlerted())\n-                    {\n-                        throw ALERT_EXCEPTION;\n-                    }\n+                    applyWaitMethod(barrier);\n \n                     if (timeoutMs < (System.currentTimeMillis() - currentTime))\n                     {\n@@ -395,10 +503,7 @@ public long waitFor(final Sequence[] dependents, final Sequence cursor, final De\n             {\n                 while ((availableSequence = getMinimumSequence(dependents)) < sequence)\n                 {\n-                    if (barrier.isAlerted())\n-                    {\n-                        throw ALERT_EXCEPTION;\n-                    }\n+                    applyWaitMethod(barrier);\n \n                     if (timeoutMs < (System.currentTimeMillis() - currentTime))\n                     {\n@@ -414,5 +519,14 @@ public long waitFor(final Sequence[] dependents, final Sequence cursor, final De\n         public void signalAll()\n         {\n         }\n+\n+        private void applyWaitMethod(final DependencyBarrier barrier)\n+            throws AlertException\n+        {\n+            if (barrier.isAlerted())\n+            {\n+                throw ALERT_EXCEPTION;\n+            }\n+        }\n     }\n }",
      "parent_sha": "b12c66023b8d06f569bb5c2a4a182a0e9d4e2302"
    }
  },
  {
    "oid": "75d1f7cc692d3791ceca6da39e300eb41f4663e7",
    "message": "avoid signalling empty batch to BatchStartAware handler",
    "date": "2019-03-11T16:09:14Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/75d1f7cc692d3791ceca6da39e300eb41f4663e7",
    "details": {
      "sha": "7eedd48910df11e88683773e330dedbb9ea5fd60",
      "filename": "src/main/java/com/lmax/disruptor/BatchEventProcessor.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/75d1f7cc692d3791ceca6da39e300eb41f4663e7/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FBatchEventProcessor.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/75d1f7cc692d3791ceca6da39e300eb41f4663e7/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FBatchEventProcessor.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FBatchEventProcessor.java?ref=75d1f7cc692d3791ceca6da39e300eb41f4663e7",
      "patch": "@@ -157,7 +157,7 @@ private void processEvents()\n             try\n             {\n                 final long availableSequence = sequenceBarrier.waitFor(nextSequence);\n-                if (batchStartAware != null)\n+                if (batchStartAware != null && availableSequence >= nextSequence)\n                 {\n                     batchStartAware.onBatchStart(availableSequence - nextSequence + 1);\n                 }",
      "parent_sha": "79a430a86da9690fbf8f68370ff9b82cca36f7bb"
    }
  },
  {
    "oid": "c7503c7c1d2619e389c94e1b22ea15c88159d450",
    "message": "perf benchmark for false-sharing in RingBuffer - ah. where to put the brackets... that old chestnut.",
    "date": "2021-02-16T15:26:55Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/c7503c7c1d2619e389c94e1b22ea15c88159d450",
    "details": {
      "sha": "07a506cf75817cfc0b99ae5347e357928856ec55",
      "filename": "src/jmh/java/com/lmax/disruptor/RingBufferFalseSharingBenchmark.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/c7503c7c1d2619e389c94e1b22ea15c88159d450/src%2Fjmh%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBufferFalseSharingBenchmark.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/c7503c7c1d2619e389c94e1b22ea15c88159d450/src%2Fjmh%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBufferFalseSharingBenchmark.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fjmh%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBufferFalseSharingBenchmark.java?ref=c7503c7c1d2619e389c94e1b22ea15c88159d450",
      "patch": "@@ -278,7 +278,8 @@ public PaddedRingBuffer()\n Space losses: 0 bytes internal + 4 bytes external = 4 bytes total\n      */\n     @State(Scope.Group)\n-    public static class PaddedRingBufferWithNoisyNeighbour extends PaddedRingBuffer {\n+    public static class PaddedRingBufferWithNoisyNeighbour extends PaddedRingBuffer\n+    {\n         int writeOnly;\n     }\n ",
      "parent_sha": "d29c84079fdff5f0f47339e53788c5e38952430f"
    }
  },
  {
    "oid": "95c705f60c1833b07f1fed6e08a08d7bee7f0971",
    "message": "Use a monotonic clock for checking timeout on shutdown",
    "date": "2023-09-29T13:48:46Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/95c705f60c1833b07f1fed6e08a08d7bee7f0971",
    "details": {
      "sha": "f202d333a1331130c25eab255c8304ce9a7f2da4",
      "filename": "src/main/java/com/lmax/disruptor/dsl/Disruptor.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/95c705f60c1833b07f1fed6e08a08d7bee7f0971/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fdsl%2FDisruptor.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/95c705f60c1833b07f1fed6e08a08d7bee7f0971/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fdsl%2FDisruptor.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fdsl%2FDisruptor.java?ref=95c705f60c1833b07f1fed6e08a08d7bee7f0971",
      "patch": "@@ -404,10 +404,10 @@ public void shutdown()\n      */\n     public void shutdown(final long timeout, final TimeUnit timeUnit) throws TimeoutException\n     {\n-        final long timeOutAt = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+        final long timeOutAt = System.nanoTime() + timeUnit.toNanos(timeout);\n         while (hasBacklog())\n         {\n-            if (timeout >= 0 && System.currentTimeMillis() > timeOutAt)\n+            if (timeout >= 0 && System.nanoTime() > timeOutAt)\n             {\n                 throw TimeoutException.INSTANCE;\n             }",
      "parent_sha": "8192ba72b34f68ecd8810f4985062504c2804b3c"
    }
  },
  {
    "oid": "613bc4a918c7189cb632f56c708db307088e5860",
    "message": "Rewrite RingBufferWithAssertingStubTest in spirit of JUnit 5",
    "date": "2020-12-04T15:43:40Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/613bc4a918c7189cb632f56c708db307088e5860",
    "details": {
      "sha": "e081128493c8eb1aa078879d780f8fa679a1c996",
      "filename": "src/test/java/com/lmax/disruptor/RingBufferWithAssertingStubTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/613bc4a918c7189cb632f56c708db307088e5860/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBufferWithAssertingStubTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/613bc4a918c7189cb632f56c708db307088e5860/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBufferWithAssertingStubTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBufferWithAssertingStubTest.java?ref=613bc4a918c7189cb632f56c708db307088e5860",
      "patch": "@@ -1,20 +1,20 @@\n package com.lmax.disruptor;\n \n import com.lmax.disruptor.support.StubEvent;\n-import org.junit.Before;\n-import org.junit.Test;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n \n import java.util.concurrent.ThreadLocalRandom;\n \n+import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.core.Is.is;\n-import static org.junit.Assert.assertThat;\n \n public class RingBufferWithAssertingStubTest\n {\n     private RingBuffer<StubEvent> ringBuffer;\n     private Sequencer sequencer;\n \n-    @Before\n+    @BeforeEach\n     public void setUp()\n     {\n         sequencer = new AssertingSequencer(16);",
      "parent_sha": "1187a862ace0a00b26b35e874a2bd8f028c776ce"
    }
  },
  {
    "oid": "89f3a82fa3deb087ac9c894b9b3142d350273a09",
    "message": "update notes",
    "date": "2020-02-11T13:45:25Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/89f3a82fa3deb087ac9c894b9b3142d350273a09",
    "details": {
      "sha": "dada3dbee00c7ba959f788fc09f81d41063b2069",
      "filename": "src/test/java/com/lmax/disruptor/RemoveWorkHandlerTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/89f3a82fa3deb087ac9c894b9b3142d350273a09/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRemoveWorkHandlerTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/89f3a82fa3deb087ac9c894b9b3142d350273a09/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRemoveWorkHandlerTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRemoveWorkHandlerTest.java?ref=89f3a82fa3deb087ac9c894b9b3142d350273a09",
      "patch": "@@ -135,7 +135,7 @@ public void removeWorkHandlerLaterTest() throws InterruptedException\n \n         ringBuffer.removeGatingSequence(processor1.getSequence());\n \n-        //waiting handler consume event(Because there is a event lost, it will be blocked here)\n+        //waiting handler consume event\n         Assert.assertTrue(countDownLatch.await(3, TimeUnit.SECONDS));\n     }\n ",
      "parent_sha": "b16d950c67a94608e0267477f65650cbb05204b4"
    }
  },
  {
    "oid": "cf2dd0f8e9c649dc170d92bc34af6c662d38654b",
    "message": "Track minProcessorSequence in a Sequence.",
    "date": "2011-08-14T10:00:55Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/cf2dd0f8e9c649dc170d92bc34af6c662d38654b",
    "details": {
      "sha": "8880294237b739245b9eb38a92b98aab55c9f8ee",
      "filename": "code/src/main/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 9,
      "deletions": 5,
      "changes": 14,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/cf2dd0f8e9c649dc170d92bc34af6c662d38654b/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/cf2dd0f8e9c649dc170d92bc34af6c662d38654b/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=cf2dd0f8e9c649dc170d92bc34af6c662d38654b",
      "patch": "@@ -33,7 +33,7 @@ public final class RingBuffer<T extends AbstractEvent>\n     private final int ringModMask;\n     private final AbstractEvent[] events;\n \n-    private final long[] minProcessorSequence = new long[5]; // padded to prevent false sharing.\n+    private final Sequence minProcessorSequence = new Sequence(INITIAL_CURSOR_VALUE);\n     private Sequence[] processorSequencesToTrack;\n \n     private final ClaimStrategy.Option claimStrategyOption;\n@@ -52,7 +52,6 @@ public RingBuffer(final EventFactory<T> eventFactory, final int size,\n                       final ClaimStrategy.Option claimStrategyOption,\n                       final WaitStrategy.Option waitStrategyOption)\n     {\n-        minProcessorSequence[0] = INITIAL_CURSOR_VALUE;\n         int sizeAsPowerOfTwo = ceilingNextPowerOfTwo(size);\n         ringModMask = sizeAsPowerOfTwo - 1;\n         events = new AbstractEvent[sizeAsPowerOfTwo];\n@@ -221,10 +220,15 @@ public void publishWithForce(final T event)\n     private void ensureProcessorsAreInRange(final long sequence)\n     {\n         final long wrapPoint = sequence - events.length;\n-        while (wrapPoint > minProcessorSequence[0] &&\n-               wrapPoint > (minProcessorSequence[0] = getMinimumSequence(processorSequencesToTrack)))\n+        if (wrapPoint > minProcessorSequence.get())\n         {\n-            Thread.yield();\n+            long minSequence;\n+            while (wrapPoint > (minSequence = getMinimumSequence(processorSequencesToTrack)))\n+            {\n+                Thread.yield();\n+            }\n+\n+            minProcessorSequence.set(minSequence);\n         }\n     }\n ",
      "parent_sha": "32014d600ec1b876d90d1d152f83c8824098e26a"
    }
  },
  {
    "oid": "d0d760a8966e75749b6b701132c4beca2a443157",
    "message": "Added Javadoc to RingBuffer.java",
    "date": "2012-11-13T22:00:23Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/d0d760a8966e75749b6b701132c4beca2a443157",
    "details": {
      "sha": "a5c46ca3d61b14886de52a5bbfda9841b97378aa",
      "filename": "src/main/java/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/d0d760a8966e75749b6b701132c4beca2a443157/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/d0d760a8966e75749b6b701132c4beca2a443157/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=d0d760a8966e75749b6b701132c4beca2a443157",
      "patch": "@@ -301,7 +301,7 @@ public void publishEvent(final EventTranslator<E> translator)\n \n     /**\n      * Attempts to publish an event to the ring buffer.  It handles\n-     * claiming the next sequence, getting the current (uninitialized)\n+     * claiming the next sequence, getting the current (uninitialised)\n      * event from the ring buffer and publishing the claimed sequence\n      * after translation.  Will return false if specified capacity\n      * was not available.\n@@ -495,6 +495,12 @@ public E getPreallocated(final long sequence)\n         return (E)entries[(int)sequence & indexMask];\n     }\n     \n+    /**\n+     * Publish the specified sequence.  This action marks this particular\n+     * message as being available to be read.\n+     * \n+     * @param sequence the sequence to publish.\n+     */\n     public void publish(long sequence)\n     {\n         assert (sequence - bufferSize) <= sequencer.getWrapPoint();",
      "parent_sha": "a9d2ca24b409f09e853632d82aa6b358d00b1790"
    }
  },
  {
    "oid": "c2e4fc1413449ed2238552f1a2a9cdf54780d489",
    "message": "return without assigning to unused variable.",
    "date": "2011-05-22T21:49:34Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/c2e4fc1413449ed2238552f1a2a9cdf54780d489",
    "details": {
      "sha": "6544a268c4979d97ec1dd3b5c9ed1cc53209f33d",
      "filename": "code/src/main/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 2,
      "deletions": 6,
      "changes": 8,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/c2e4fc1413449ed2238552f1a2a9cdf54780d489/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/c2e4fc1413449ed2238552f1a2a9cdf54780d489/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=c2e4fc1413449ed2238552f1a2a9cdf54780d489",
      "patch": "@@ -152,19 +152,15 @@ public long waitFor(final long sequence)\n             throws AlertException, InterruptedException\n         {\n             long availableSequence = waitStrategy.waitFor(RingBuffer.this, this, sequence);\n-            availableSequence = waitOnConsumers(sequence, availableSequence);\n-\n-            return availableSequence;\n+            return waitOnConsumers(sequence, availableSequence);\n         }\n \n         @Override\n         public long waitFor(final long sequence, final long timeout, final TimeUnit units)\n             throws AlertException, InterruptedException\n         {\n             long availableSequence = waitStrategy.waitFor(RingBuffer.this, this, sequence, timeout, units);\n-            availableSequence = waitOnConsumers(sequence, availableSequence);\n-\n-            return availableSequence;\n+            return waitOnConsumers(sequence, availableSequence);\n         }\n \n         @Override",
      "parent_sha": "06e16305a7d8f2110dd3e4ac9706ed9764cbef49"
    }
  },
  {
    "oid": "2a66a1d880694ae17d96b10edcb7db1992de9760",
    "message": "Make isPublished method as deprecated.",
    "date": "2017-09-27T03:02:25Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/2a66a1d880694ae17d96b10edcb7db1992de9760",
    "details": {
      "sha": "667b545a334a36d33de7ce7505670ad135676cff",
      "filename": "src/main/java/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 7,
      "deletions": 2,
      "changes": 9,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/2a66a1d880694ae17d96b10edcb7db1992de9760/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/2a66a1d880694ae17d96b10edcb7db1992de9760/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=2a66a1d880694ae17d96b10edcb7db1992de9760",
      "patch": "@@ -336,11 +336,16 @@ public E claimAndGetPreallocated(long sequence)\n     }\n \n     /**\n-     * Determines if a particular entry has been published.\n+     * Determines if a particular entry is available.  Note that using this when not within a context that is\n+     * maintaining a sequence barrier, it is likely that using this to determine if you can read a value is likely\n+     * to result in a race condition and broken code.\n      *\n      * @param sequence The sequence to identify the entry.\n-     * @return If the value has been published or not.\n+     * @return If the value can be read or not.\n+     * @deprecated Please don't use this method.  It probably won't\n+     * do what you think that it does.\n      */\n+    @Deprecated\n     public boolean isPublished(long sequence)\n     {\n         return sequencer.isAvailable(sequence);",
      "parent_sha": "990e8fe38e021b0aa26e08035b042e73d6510f20"
    }
  },
  {
    "oid": "b9cf5f289c31bda7b896356f0b386f6dfb34e237",
    "message": "Rename mask to indexMask",
    "date": "2011-10-24T05:34:24Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/b9cf5f289c31bda7b896356f0b386f6dfb34e237",
    "details": {
      "sha": "167330468d6e4a0fbc6612540762ffae5f6d0818",
      "filename": "code/src/perf/com/lmax/disruptor/OnePublisherToOneProcessorUniCastRawThroughputTest.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/b9cf5f289c31bda7b896356f0b386f6dfb34e237/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FOnePublisherToOneProcessorUniCastRawThroughputTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/b9cf5f289c31bda7b896356f0b386f6dfb34e237/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FOnePublisherToOneProcessorUniCastRawThroughputTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FOnePublisherToOneProcessorUniCastRawThroughputTest.java?ref=b9cf5f289c31bda7b896356f0b386f6dfb34e237",
      "patch": "@@ -31,7 +31,7 @@\n public class OnePublisherToOneProcessorUniCastRawThroughputTest extends AbstractPerfTestQueueVsDisruptor\n {\n     private static final int BUFFER_SIZE = 1024 * 8;\n-    private static final int mask = BUFFER_SIZE - 1;\n+    private static final int indexMask = BUFFER_SIZE - 1;\n     private static final long ITERATIONS = 1000L * 1000L * 100L;\n     private final ExecutorService EXECUTOR = Executors.newSingleThreadExecutor();\n     private final long expectedResult = PerfTestUtil.accumulatedAddition(ITERATIONS);\n@@ -73,7 +73,7 @@ protected long runDisruptorPass() throws InterruptedException\n         for (long i = 0; i < ITERATIONS; i++)\n         {\n             long sequence = sequencer.next();\n-            values[(int)sequence & mask] = i;\n+            values[(int)sequence & indexMask] = i;\n             sequencer.publish(sequence);\n         }\n \n@@ -142,7 +142,7 @@ public void run()\n                     final long availableSequence = barrier.waitFor(nextSequence);\n                     while (nextSequence <= availableSequence)\n                     {\n-                        value.set(value.get() + values[(int)nextSequence & mask]);\n+                        value.set(value.get() + values[(int)nextSequence & indexMask]);\n                         nextSequence++;\n                     }\n ",
      "parent_sha": "485c567df9d1c01b7d04ed5055e8b2b10f72b47f"
    }
  },
  {
    "oid": "ab2efff7f7a52432fc5bcf94f9d961e3203061bd",
    "message": "Padded ClaimStrategy cache lines to prevent false sharing.",
    "date": "2011-08-14T06:14:54Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/ab2efff7f7a52432fc5bcf94f9d961e3203061bd",
    "details": {
      "sha": "1ea1bec540be08f299134921054274c0c05446ed",
      "filename": "code/src/main/com/lmax/disruptor/ClaimStrategy.java",
      "status": "modified",
      "additions": 20,
      "deletions": 10,
      "changes": 30,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/ab2efff7f7a52432fc5bcf94f9d961e3203061bd/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FClaimStrategy.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/ab2efff7f7a52432fc5bcf94f9d961e3203061bd/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FClaimStrategy.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FClaimStrategy.java?ref=ab2efff7f7a52432fc5bcf94f9d961e3203061bd",
      "patch": "@@ -15,7 +15,7 @@\n  */\n package com.lmax.disruptor;\n \n-import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicLongArray;\n \n /**\n  * Strategies employed for claiming the sequence of {@link AbstractEvent}s in the {@link RingBuffer} by publishers.\n@@ -83,24 +83,29 @@ public ClaimStrategy newInstance()\n     static final class MultiThreadedStrategy\n         implements ClaimStrategy\n     {\n-        private final AtomicLong sequence = new AtomicLong(RingBuffer.INITIAL_CURSOR_VALUE);\n+        private final AtomicLongArray sequence = new AtomicLongArray(5); // cache line padded\n+\n+        public MultiThreadedStrategy()\n+        {\n+            sequence.set(0, RingBuffer.INITIAL_CURSOR_VALUE);\n+        }\n \n         @Override\n         public long incrementAndGet()\n         {\n-            return sequence.incrementAndGet();\n+            return sequence.incrementAndGet(0);\n         }\n \n         @Override\n         public long incrementAndGet(final int delta)\n         {\n-            return sequence.addAndGet(delta);\n+            return sequence.addAndGet(0, delta);\n         }\n \n         @Override\n         public void setSequence(final long sequence)\n         {\n-            this.sequence.set(sequence);\n+            this.sequence.lazySet(0, sequence);\n         }\n     }\n \n@@ -110,25 +115,30 @@ public void setSequence(final long sequence)\n     static final class SingleThreadedStrategy\n         implements ClaimStrategy\n     {\n-        private long sequence = RingBuffer.INITIAL_CURSOR_VALUE;\n+        private final long[] sequence = new long[5]; // cache line padded\n+\n+        public SingleThreadedStrategy()\n+        {\n+            sequence[0] = RingBuffer.INITIAL_CURSOR_VALUE;\n+        }\n \n         @Override\n         public long incrementAndGet()\n         {\n-            return ++sequence;\n+            return ++sequence[0];\n         }\n \n         @Override\n         public long incrementAndGet(final int delta)\n         {\n-            sequence += delta;\n-            return sequence;\n+            sequence[0] += delta;\n+            return sequence[0];\n         }\n \n         @Override\n         public void setSequence(final long sequence)\n         {\n-            this.sequence = sequence;\n+            this.sequence[0] = sequence;\n         }\n     }\n }",
      "parent_sha": "430a50f3005ff64001edd10026066638414101ee"
    }
  },
  {
    "oid": "7a34926b2965448e6e80eae9300101ebecdf66a4",
    "message": "Missed use of latch.",
    "date": "2011-05-02T08:58:42Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/7a34926b2965448e6e80eae9300101ebecdf66a4",
    "details": {
      "sha": "469701684c9f5ba1358ccd1bee151a3f49a9ceb7",
      "filename": "code/src/test/com/lmax/disruptor/BatchEntryConsumerTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 4,
      "changes": 5,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/7a34926b2965448e6e80eae9300101ebecdf66a4/code%2Fsrc%2Ftest%2Fcom%2Flmax%2Fdisruptor%2FBatchEntryConsumerTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/7a34926b2965448e6e80eae9300101ebecdf66a4/code%2Fsrc%2Ftest%2Fcom%2Flmax%2Fdisruptor%2FBatchEntryConsumerTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Ftest%2Fcom%2Flmax%2Fdisruptor%2FBatchEntryConsumerTest.java?ref=7a34926b2965448e6e80eae9300101ebecdf66a4",
      "patch": "@@ -59,10 +59,7 @@ public void shouldCallMethodsInLifecycleOrder()\n         Claimer<StubEntry> claimer = ringBuffer.createClaimer(0, batchEntryConsumer);\n         claimer.claimNext().commit();\n \n-        while (batchEntryConsumer.getSequence() != 0)\n-        {\n-            Thread.yield();\n-        }\n+        latch.await();\n \n         batchEntryConsumer.halt();\n         thread.join();",
      "parent_sha": "93b117ccc2f40a97d952f67a7f19d0a587bbe1b9"
    }
  },
  {
    "oid": "9e45677f8779c859bff6fed3cba3ea666bde0b03",
    "message": "Removed unused imports.",
    "date": "2011-11-03T20:07:50Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/9e45677f8779c859bff6fed3cba3ea666bde0b03",
    "details": {
      "sha": "01685f958546abbae5e9e7d8aa7ccf49cf9446d5",
      "filename": "code/src/test/com/lmax/disruptor/MultiThreadedClaimStrategyTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/9e45677f8779c859bff6fed3cba3ea666bde0b03/code%2Fsrc%2Ftest%2Fcom%2Flmax%2Fdisruptor%2FMultiThreadedClaimStrategyTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/9e45677f8779c859bff6fed3cba3ea666bde0b03/code%2Fsrc%2Ftest%2Fcom%2Flmax%2Fdisruptor%2FMultiThreadedClaimStrategyTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Ftest%2Fcom%2Flmax%2Fdisruptor%2FMultiThreadedClaimStrategyTest.java?ref=9e45677f8779c859bff6fed3cba3ea666bde0b03",
      "patch": "@@ -24,8 +24,7 @@\n \n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n+\n import java.util.concurrent.atomic.AtomicReferenceArray;\n \n import static junit.framework.Assert.*;",
      "parent_sha": "7a16f27746ff76ed3a2536744a0b3a4d1847bbd0"
    }
  },
  {
    "oid": "7c95b0e1f3990cb926ac2fe1dac02b8109ec95f2",
    "message": "More accurate exception message when attempting to use setDefaultExceptionHandler after handleExceptionsWith.",
    "date": "2015-09-07T21:11:49Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/7c95b0e1f3990cb926ac2fe1dac02b8109ec95f2",
    "details": {
      "sha": "ca6c6fb7a481ccd956e265e9f60172bdacf9b94a",
      "filename": "src/main/java/com/lmax/disruptor/dsl/Disruptor.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/7c95b0e1f3990cb926ac2fe1dac02b8109ec95f2/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fdsl%2FDisruptor.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/7c95b0e1f3990cb926ac2fe1dac02b8109ec95f2/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fdsl%2FDisruptor.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fdsl%2FDisruptor.java?ref=7c95b0e1f3990cb926ac2fe1dac02b8109ec95f2",
      "patch": "@@ -248,7 +248,7 @@ public void setDefaultExceptionHandler(final ExceptionHandler<? super T> excepti\n         checkNotStarted();\n         if (!(this.exceptionHandler instanceof ExceptionHandlerWrapper))\n         {\n-            throw new IllegalStateException(\"Mixing calls to handleExceptionsWith and setDefaultExceptionHandler is not supported.\");\n+            throw new IllegalStateException(\"setDefaultExceptionHandler can not be used after handleExceptionsWith\");\n         }\n         ((ExceptionHandlerWrapper<T>)this.exceptionHandler).switchTo(exceptionHandler);\n     }",
      "parent_sha": "951a3ebfc97e2766c7350afc4cb13bacdcf8c33b"
    }
  },
  {
    "oid": "fae436e42fff1c3fe1f0d106b1c427fd69a6c6d5",
    "message": "Rewrite SleepingWaitStrategyTest in spirit of JUnit 5",
    "date": "2020-12-04T16:29:53Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/fae436e42fff1c3fe1f0d106b1c427fd69a6c6d5",
    "details": {
      "sha": "b9aa09ba92912c8e65e285cf45a13f855eeba59a",
      "filename": "src/test/java/com/lmax/disruptor/SleepingWaitStrategyTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/fae436e42fff1c3fe1f0d106b1c427fd69a6c6d5/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSleepingWaitStrategyTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/fae436e42fff1c3fe1f0d106b1c427fd69a6c6d5/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSleepingWaitStrategyTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSleepingWaitStrategyTest.java?ref=fae436e42fff1c3fe1f0d106b1c427fd69a6c6d5",
      "patch": "@@ -15,9 +15,10 @@\n  */\n package com.lmax.disruptor;\n \n+import org.junit.jupiter.api.Test;\n+\n import static com.lmax.disruptor.support.WaitStrategyTestUtil.assertWaitForWithDelayOf;\n \n-import org.junit.Test;\n \n public class SleepingWaitStrategyTest\n {",
      "parent_sha": "37d08917661f1a293ede04af7ee5649c9d986c12"
    }
  },
  {
    "oid": "6bc23e908e488898f55efd7c77deeea7fce74c74",
    "message": "Update SingleProducerSequencer.java\n\nnext(n) method will be parked forever when n > bufferSize",
    "date": "2018-10-20T06:53:25Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/6bc23e908e488898f55efd7c77deeea7fce74c74",
    "details": {
      "sha": "d5a7ae0cf1b19b92d68175c9b40df136eeb0b211",
      "filename": "src/main/java/com/lmax/disruptor/SingleProducerSequencer.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/6bc23e908e488898f55efd7c77deeea7fce74c74/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSingleProducerSequencer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/6bc23e908e488898f55efd7c77deeea7fce74c74/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSingleProducerSequencer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSingleProducerSequencer.java?ref=6bc23e908e488898f55efd7c77deeea7fce74c74",
      "patch": "@@ -116,9 +116,9 @@ public long next()\n     @Override\n     public long next(int n)\n     {\n-        if (n < 1)\n+        if (n < 1 || n > bufferSize)\n         {\n-            throw new IllegalArgumentException(\"n must be > 0\");\n+            throw new IllegalArgumentException(\"n must be > 0 and < bufferSize\");\n         }\n \n         long nextValue = this.nextValue;",
      "parent_sha": "78c8618b2eca094d3e7c3c15a33597d67da284e9"
    }
  },
  {
    "oid": "fb8311b272f03ce1058e064747d2f0cf58522266",
    "message": "tidy up idea warnings",
    "date": "2013-04-16T09:51:13Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/fb8311b272f03ce1058e064747d2f0cf58522266",
    "details": {
      "sha": "c15d665d3c1cde1b2099abd2c28e7d27dd619db9",
      "filename": "src/main/java/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 5,
      "deletions": 9,
      "changes": 14,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/fb8311b272f03ce1058e064747d2f0cf58522266/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/fb8311b272f03ce1058e064747d2f0cf58522266/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=fb8311b272f03ce1058e064747d2f0cf58522266",
      "patch": "@@ -75,9 +75,7 @@ public static <E> RingBuffer<E> createMultiProducer(EventFactory<E> factory,\n     {\n         MultiProducerSequencer sequencer = new MultiProducerSequencer(bufferSize, waitStrategy);\n \n-        RingBuffer<E> ringBuffer = new RingBuffer<E>(factory, sequencer);\n-\n-        return ringBuffer;\n+        return new RingBuffer<E>(factory, sequencer);\n     }\n \n     /**\n@@ -108,9 +106,7 @@ public static <E> RingBuffer<E> createSingleProducer(EventFactory<E> factory,\n     {\n         SingleProducerSequencer sequencer = new SingleProducerSequencer(bufferSize, waitStrategy);\n \n-        RingBuffer<E> ringBuffer = new RingBuffer<E>(factory, sequencer);\n-\n-        return ringBuffer;\n+        return new RingBuffer<E>(factory, sequencer);\n     }\n \n     /**\n@@ -294,7 +290,7 @@ public boolean removeGatingSequence(Sequence sequence)\n      * are available to be read from the ring buffer given a list of sequences to track.\n      *\n      * @see SequenceBarrier\n-     * @param sequencesToTrack\n+     * @param sequencesToTrack zero or more sequences to track.\n      * @return A sequence barrier that will track the specified sequences.\n      */\n     public SequenceBarrier newBarrier(Sequence... sequencesToTrack)\n@@ -732,7 +728,7 @@ public <A, B, C> void publishEvents(EventTranslatorThreeArg<E, A, B, C> translat\n      * @param arg0       An array of user supplied arguments, one element per event.\n      * @param arg1       An array of user supplied arguments, one element per event.\n      * @param arg2       An array of user supplied arguments, one element per event.\n-     * @param batchSize\n+     * @param batchSize  The number of elements in the batch.\n      * @see #publishEvents(EventTranslator[])\n      */\n     public <A, B, C> void publishEvents(EventTranslatorThreeArg<E, A, B, C> translator, A[] arg0, B[] arg1, C[] arg2, int batchSize) {\n@@ -923,7 +919,7 @@ private <A, B, C> void translateAndPublish(EventTranslatorThreeArg<E, A, B, C> t\n         }\n     }\n \n-    private <A> void translateAndPublish(EventTranslatorVararg<E> translator, long sequence, Object...args)\n+    private void translateAndPublish(EventTranslatorVararg<E> translator, long sequence, Object...args)\n     {\n         try\n         {",
      "parent_sha": "f875fa906118f33bff5a09a8d8cd1d3971408096"
    }
  },
  {
    "oid": "df7c854535dea724628b7adbec0cc02e7d97ef2e",
    "message": "Generalise queue references.",
    "date": "2011-10-25T16:20:35Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/df7c854535dea724628b7adbec0cc02e7d97ef2e",
    "details": {
      "sha": "224536196bdfdb42429fc80937d2b6f88b565919",
      "filename": "code/src/perf/com/lmax/disruptor/OnePublisherToThreeProcessorMultiCastThroughputTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/df7c854535dea724628b7adbec0cc02e7d97ef2e/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FOnePublisherToThreeProcessorMultiCastThroughputTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/df7c854535dea724628b7adbec0cc02e7d97ef2e/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FOnePublisherToThreeProcessorMultiCastThroughputTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FOnePublisherToThreeProcessorMultiCastThroughputTest.java?ref=df7c854535dea724628b7adbec0cc02e7d97ef2e",
      "patch": "@@ -109,7 +109,7 @@ public final class OnePublisherToThreeProcessorMultiCastThroughputTest extends A\n     ///////////////////////////////////////////////////////////////////////////////////////////////\n \n     @SuppressWarnings(\"unchecked\")\n-    private final ArrayBlockingQueue<Long>[] blockingQueues = new ArrayBlockingQueue[NUM_EVENT_PROCESSORS];\n+    private final BlockingQueue<Long>[] blockingQueues = new BlockingQueue[NUM_EVENT_PROCESSORS];\n     {\n         blockingQueues[0] = new ArrayBlockingQueue<Long>(SIZE_BUFFER);\n         blockingQueues[1] = new ArrayBlockingQueue<Long>(SIZE_BUFFER);\n@@ -144,6 +144,7 @@ public final class OnePublisherToThreeProcessorMultiCastThroughputTest extends A\n         batchEventProcessors[0] = new BatchEventProcessor<ValueEvent>(ringBuffer, sequenceBarrier, handlers[0]);\n         batchEventProcessors[1] = new BatchEventProcessor<ValueEvent>(ringBuffer, sequenceBarrier, handlers[1]);\n         batchEventProcessors[2] = new BatchEventProcessor<ValueEvent>(ringBuffer, sequenceBarrier, handlers[2]);\n+\n         ringBuffer.setGatingSequences(batchEventProcessors[0].getSequence(),\n                                       batchEventProcessors[1].getSequence(),\n                                       batchEventProcessors[2].getSequence());",
      "parent_sha": "18cf4ff1acb481c2dac8308341a8217e2d958213"
    }
  },
  {
    "oid": "1088d18b737d669bb16ee3cc6bd439adcfb3a0e4",
    "message": "Fix warning and add perf test documentation for PingPongLatencyTest",
    "date": "2013-08-12T08:45:24Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/1088d18b737d669bb16ee3cc6bd439adcfb3a0e4",
    "details": {
      "sha": "a07a1893ec74da5aea0051353aed1bb2936b7ab0",
      "filename": "src/perftest/java/com/lmax/disruptor/PingPongLatencyTest.java",
      "status": "modified",
      "additions": 17,
      "deletions": 2,
      "changes": 19,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/1088d18b737d669bb16ee3cc6bd439adcfb3a0e4/src%2Fperftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FPingPongLatencyTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/1088d18b737d669bb16ee3cc6bd439adcfb3a0e4/src%2Fperftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FPingPongLatencyTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fperftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FPingPongLatencyTest.java?ref=1088d18b737d669bb16ee3cc6bd439adcfb3a0e4",
      "patch": "@@ -27,7 +27,6 @@\n import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.locks.LockSupport;\n \n import org.HdrHistogram.Histogram;\n import org.junit.Test;\n@@ -43,8 +42,24 @@\n  *\n  * Queue Based:\n  * ============\n+ *               +---take---+\n+ *               |          |\n+ *               |          V\n+ *            +====+      +====+\n+ *    +------>| Q1 |      | P2 |-------+\n+ *    |       +====+      +====+       |\n+ *   put                              put\n+ *    |       +====+      +====+       |\n+ *    +-------| P1 |      | Q2 |<------+\n+ *            +====+      +====+\n+ *               ^          |\n+ *               |          |\n+ *               +---take---+\n  *\n- * TODO\n+ * P1 - QueuePinger\n+ * P2 - QueuePonger\n+ * Q1 - PingQueue\n+ * Q2 - PongQueue\n  *\n  * Disruptor:\n  * ==========",
      "parent_sha": "a528e045b8af4731d39fe303b98c7f3688428fd4"
    }
  },
  {
    "oid": "ae1d3ec1ffc67b8ab3abead1155630847c1e194a",
    "message": "Naming clean up",
    "date": "2011-05-21T12:57:48Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/ae1d3ec1ffc67b8ab3abead1155630847c1e194a",
    "details": {
      "sha": "320e743fff00c395e7c92d034d1057ea334c4fac",
      "filename": "code/src/main/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/ae1d3ec1ffc67b8ab3abead1155630847c1e194a/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/ae1d3ec1ffc67b8ab3abead1155630847c1e194a/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=ae1d3ec1ffc67b8ab3abead1155630847c1e194a",
      "patch": "@@ -65,12 +65,12 @@ public RingBuffer(final EntryFactory<T> entryFactory, final int size)\n     /**\n      * Create a {@link ConsumerBarrier} that gates on the RingBuffer and a list of {@link Consumer}s\n      *\n-     * @param consumers this barrier will track\n+     * @param consumersToTrack this barrier will track\n      * @return the barrier gated as required\n      */\n-    public ConsumerBarrier<T> createConsumerBarrier(final Consumer... consumers)\n+    public ConsumerBarrier<T> createConsumerBarrier(final Consumer... consumersToTrack)\n     {\n-        return new MultiConsumerConsumerBarrier<T>(consumers);\n+        return new ConsumerTrackingConsumerBarrier<T>(consumersToTrack);\n     }\n \n     /**\n@@ -79,12 +79,12 @@ public ConsumerBarrier<T> createConsumerBarrier(final Consumer... consumers)\n      * The bufferReserve should be at least the number of producing threads.\n      *\n      * @param bufferReserve size of of the buffer to be reserved.\n-     * @param consumers to be tracked to prevent wrapping.\n+     * @param consumersToTrack to be tracked to prevent wrapping.\n      * @return a {@link ProducerBarrier} with the above configuration.\n      */\n-    public ProducerBarrier<T> createProducerBarrier(final int bufferReserve, final Consumer... consumers)\n+    public ProducerBarrier<T> createProducerBarrier(final int bufferReserve, final Consumer... consumersToTrack)\n     {\n-        return new MultiConsumerProducerBarrier(bufferReserve, consumers);\n+        return new ConsumerTrackingProducerBarrier(bufferReserve, consumersToTrack);\n     }\n \n     /**\n@@ -130,12 +130,12 @@ private void fill(final EntryFactory<T> entryEntryFactory)\n     /**\n      * ConsumerBarrier handed out for gating consumers of the RingBuffer and dependent {@link Consumer}(s)\n      */\n-    private final class MultiConsumerConsumerBarrier<T extends Entry> implements ConsumerBarrier<T>\n+    private final class ConsumerTrackingConsumerBarrier<T extends Entry> implements ConsumerBarrier<T>\n     {\n         private final Consumer[] consumers;\n         private volatile boolean alerted = false;\n \n-        public MultiConsumerConsumerBarrier(final Consumer... consumers)\n+        public ConsumerTrackingConsumerBarrier(final Consumer... consumers)\n         {\n             this.consumers = consumers;\n         }\n@@ -208,12 +208,12 @@ private long waitOnConsumers(final long sequence, long availableSequence)\n      * ProducerBarrier that tracks multiple {@link Consumer}s when trying to claim\n      * a {@link Entry} in the {@link RingBuffer}.\n      */\n-    private final class MultiConsumerProducerBarrier implements ProducerBarrier<T>\n+    private final class ConsumerTrackingProducerBarrier implements ProducerBarrier<T>\n     {\n         private final Consumer[] consumers;\n         private final int threshold;\n \n-        public MultiConsumerProducerBarrier(final int bufferReserve, final Consumer... consumers)\n+        public ConsumerTrackingProducerBarrier(final int bufferReserve, final Consumer... consumers)\n         {\n             this.consumers = consumers;\n             this.threshold = entries.length - bufferReserve;",
      "parent_sha": "ba03a35411ed425cf84bb8bc81263fc25bf8e751"
    }
  },
  {
    "oid": "4e11bd1ac799f960ba102a46d02492984750b9b6",
    "message": "Small fix to Disruptor DSL for WorkPool shutdown",
    "date": "2013-02-19T21:05:26Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/4e11bd1ac799f960ba102a46d02492984750b9b6",
    "details": {
      "sha": "4a7e4551886010ad23108c10b8fe94bfd20db408",
      "filename": "src/main/java/com/lmax/disruptor/dsl/Disruptor.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/4e11bd1ac799f960ba102a46d02492984750b9b6/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fdsl%2FDisruptor.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/4e11bd1ac799f960ba102a46d02492984750b9b6/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fdsl%2FDisruptor.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fdsl%2FDisruptor.java?ref=4e11bd1ac799f960ba102a46d02492984750b9b6",
      "patch": "@@ -322,7 +322,7 @@ private boolean hasBacklog()\n         final long cursor = ringBuffer.getCursor();\n         for (Sequence consumer : consumerRepository.getLastSequenceInChain())\n         {\n-            if (cursor != consumer.get())\n+            if (cursor > consumer.get())\n             {\n                 return true;\n             }",
      "parent_sha": "d867c3336efb72e0b70e649c3916f3778e431d74"
    }
  },
  {
    "oid": "c1117d311dfb2273457b53c124475f6898df67bc",
    "message": "Make nextSequence a local variable again",
    "date": "2013-08-03T07:57:48Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/c1117d311dfb2273457b53c124475f6898df67bc",
    "details": {
      "sha": "3d2bd3dffe34c4997afc7e8b9684939c59d93654",
      "filename": "src/main/java/com/lmax/disruptor/WorkProcessor.java",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/c1117d311dfb2273457b53c124475f6898df67bc/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FWorkProcessor.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/c1117d311dfb2273457b53c124475f6898df67bc/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FWorkProcessor.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FWorkProcessor.java?ref=c1117d311dfb2273457b53c124475f6898df67bc",
      "patch": "@@ -36,8 +36,6 @@ public final class WorkProcessor<T>\n     private final ExceptionHandler exceptionHandler;\n     private final Sequence workSequence;\n \n-    private long nextSequence;\n-\n     private final EventReleaser eventReleaser = new EventReleaser()\n     {\n         @Override\n@@ -112,7 +110,7 @@ public void run()\n \n         boolean processedSequence = true;\n         long cachedAvailableSequence = Long.MIN_VALUE;\n-        nextSequence = sequence.get();\n+        long nextSequence = sequence.get();\n         T event = null;\n         while (true)\n         {",
      "parent_sha": "45d38a57f824228711830583d706225812977bff"
    }
  },
  {
    "oid": "2d92fb01f4bed160cf67ca3e288c36c9b59be54c",
    "message": "Revert change for limit of batch size.",
    "date": "2011-09-04T21:53:13Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/2d92fb01f4bed160cf67ca3e288c36c9b59be54c",
    "details": {
      "sha": "2f38b3186a8812fa18584287108613702aea7049",
      "filename": "code/src/main/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/2d92fb01f4bed160cf67ca3e288c36c9b59be54c/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/2d92fb01f4bed160cf67ca3e288c36c9b59be54c/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=2d92fb01f4bed160cf67ca3e288c36c9b59be54c",
      "patch": "@@ -141,7 +141,7 @@ public void publish(final long sequence)\n     public SequenceBatch nextSequenceBatch(final SequenceBatch sequenceBatch)\n     {\n         final int batchSize = sequenceBatch.getSize();\n-        if (batchSize >= events.length)\n+        if (batchSize > events.length)\n         {\n             final String msg = \"Batch size \" + batchSize + \" is greater than buffer size of \" + events.length;\n             throw new IllegalArgumentException(msg);",
      "parent_sha": "c9ef507d6b2db703cceed6c08d162c785882bcfe"
    }
  },
  {
    "oid": "7d6f6ac933e1d73cfcf49f66b62a8e2c04b1977f",
    "message": "Rename of inner Claimer",
    "date": "2011-05-03T20:09:47Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/7d6f6ac933e1d73cfcf49f66b62a8e2c04b1977f",
    "details": {
      "sha": "783dee0513f6380f49eaabeaf36929553458348e",
      "filename": "code/src/main/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/7d6f6ac933e1d73cfcf49f66b62a8e2c04b1977f/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/7d6f6ac933e1d73cfcf49f66b62a8e2c04b1977f/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=7d6f6ac933e1d73cfcf49f66b62a8e2c04b1977f",
      "patch": "@@ -84,7 +84,7 @@ public Barrier<T> createBarrier(final EntryConsumer... entryConsumers)\n      */\n     public Claimer<T> createClaimer(final int bufferReserve, final EntryConsumer... entryConsumers)\n     {\n-        return new YieldingClaimer<T>(this, bufferReserve, entryConsumers);\n+        return new RingBufferClaimer<T>(this, bufferReserve, entryConsumers);\n     }\n \n     /**\n@@ -277,20 +277,20 @@ public void alert()\n      *\n      * @param <T> {@link Entry} implementation stored in the {@link RingBuffer}\n      */\n-    private final class YieldingClaimer<T extends Entry>\n+    private final class RingBufferClaimer<T extends Entry>\n         implements Claimer<T>\n     {\n         private final RingBuffer<? extends T> ringBuffer;\n         private final int bufferReserve;\n-        private final EntryConsumer[] gatingEntryConsumers;\n+        private final EntryConsumer[] entryConsumers;\n \n-        public YieldingClaimer(final RingBuffer<? extends T> ringBuffer,\n-                               final int bufferReserve,\n-                               final EntryConsumer... gatingEntryConsumers)\n+        public RingBufferClaimer(final RingBuffer<? extends T> ringBuffer,\n+                                 final int bufferReserve,\n+                                 final EntryConsumer... entryConsumers)\n         {\n             this.bufferReserve = bufferReserve;\n             this.ringBuffer = ringBuffer;\n-            this.gatingEntryConsumers = gatingEntryConsumers;\n+            this.entryConsumers = entryConsumers;\n         }\n \n         @Override\n@@ -328,7 +328,7 @@ public long getConsumedSequence()\n         {\n             long minimum = ringBuffer.getCursor();\n \n-            for (EntryConsumer consumer : gatingEntryConsumers)\n+            for (EntryConsumer consumer : entryConsumers)\n             {\n                 long sequence = consumer.getSequence();\n                 minimum = minimum < sequence ? minimum : sequence;",
      "parent_sha": "24c496803f1aa52a0dae4931bfe239623a834cd7"
    }
  },
  {
    "oid": "c325acecde824a045729db2a995014cb353ff1f2",
    "message": "Added detailed comments for MultiProducerPublisher\n\nExplains the availability flag check logic",
    "date": "2013-01-11T07:57:47Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/c325acecde824a045729db2a995014cb353ff1f2",
    "details": {
      "sha": "8fda457b413c32f3735f295561adc210354d7c3b",
      "filename": "src/main/java/com/lmax/disruptor/MultiProducerPublisher.java",
      "status": "modified",
      "additions": 21,
      "deletions": 1,
      "changes": 22,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/c325acecde824a045729db2a995014cb353ff1f2/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FMultiProducerPublisher.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/c325acecde824a045729db2a995014cb353ff1f2/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FMultiProducerPublisher.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FMultiProducerPublisher.java?ref=c325acecde824a045729db2a995014cb353ff1f2",
      "patch": "@@ -31,7 +31,8 @@ class MultiProducerPublisher implements Publisher\n     private static final long scale = UNSAFE.arrayIndexScale(int[].class);\n     \n     private final WaitStrategy waitStrategy;\n-    // int[] tracks the state of each ringbuffer slot\n+    // availableBuffer tracks the state of each ringbuffer slot\n+    // see below for more details on the approach\n     private final int[] availableBuffer;\n     private final int indexMask;\n     private final int indexShift;\n@@ -63,6 +64,25 @@ public void publish(final long sequence)\n         waitStrategy.signalAllWhenBlocking();\n     }\n \n+    /** \n+     * The below methods work on the availableBuffer flag.\n+     * \n+     * The prime reason is to avoid a shared sequence object between publisher threads.\n+     * (Keeping single pointers tracking start and end would require coordination \n+     * between the threads). \n+     * \n+     * --  Firstly we have the constraint that the delta between the cursor and minimum\n+     * gating sequence will never be larger than the buffer size (the code in \n+     * next/tryNext in the Sequence takes care of that).\n+     * -- Given that; take the sequence value and mask off the lower portion of the\n+     * sequence as the index into the buffer (indexMask). (aka modulo operator)\n+     * -- The upper portion of the sequence becomes the value to check for availability.\n+     * ie: it tells us how many times around the ring buffer we've been (aka division)\n+     * -- Beause we can't wrap without the gating sequences moving forward (i.e. the\n+     * minimum gating sequence is effectively our last available position in the\n+     * buffer), when we have new data and successfully claimed a slot we can simply\n+     * write over the top.\n+     */\n     private void setAvailable(final long sequence)\n     {\n         setAvailableBufferValue(calculateIndex(sequence), calculateAvailabilityFlag(sequence));",
      "parent_sha": "d9c194202e4f59420b53809d314660e50eccaeee"
    }
  },
  {
    "oid": "7a40d4efb67b7e51d7c190ebf4830dfa24760929",
    "message": "Remove trailing whitespace from LiteBlockingWaitStrategy.\n\nThis was causing checkstyle to complain.",
    "date": "2013-11-23T14:42:03Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/7a40d4efb67b7e51d7c190ebf4830dfa24760929",
    "details": {
      "sha": "f690f054690cba79da34ceb0a4efd12175847991",
      "filename": "src/main/java/com/lmax/disruptor/LiteBlockingWaitStrategy.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/7a40d4efb67b7e51d7c190ebf4830dfa24760929/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FLiteBlockingWaitStrategy.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/7a40d4efb67b7e51d7c190ebf4830dfa24760929/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FLiteBlockingWaitStrategy.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FLiteBlockingWaitStrategy.java?ref=7a40d4efb67b7e51d7c190ebf4830dfa24760929",
      "patch": "@@ -39,18 +39,18 @@ public long waitFor(long sequence, Sequence cursorSequence, Sequence dependentSe\n         if ((availableSequence = cursorSequence.get()) < sequence)\n         {\n             lock.lock();\n-            \n+\n             try\n             {\n                 do\n                 {\n                     signalNeeded.set(true);\n-                    \n+\n                     if ((availableSequence = cursorSequence.get()) >= sequence)\n                     {\n                         break;\n                     }\n-                    \n+\n                     barrier.checkAlert();\n                     processorNotifyCondition.await();\n                 }",
      "parent_sha": "fdab02d2688621f66757de9f375d174bccb804a8"
    }
  },
  {
    "oid": "3a49717ffb83aff94f125a238182a6e92473f42f",
    "message": "Rewrite StubThreadFactory in spirit of JUnit 5",
    "date": "2020-12-04T15:43:54Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/3a49717ffb83aff94f125a238182a6e92473f42f",
    "details": {
      "sha": "0b1726921ce4f2b724d6b6940a041560a1a01cf6",
      "filename": "src/test/java/com/lmax/disruptor/dsl/stubs/StubThreadFactory.java",
      "status": "modified",
      "additions": 21,
      "deletions": 34,
      "changes": 55,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/3a49717ffb83aff94f125a238182a6e92473f42f/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fdsl%2Fstubs%2FStubThreadFactory.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/3a49717ffb83aff94f125a238182a6e92473f42f/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fdsl%2Fstubs%2FStubThreadFactory.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fdsl%2Fstubs%2FStubThreadFactory.java?ref=3a49717ffb83aff94f125a238182a6e92473f42f",
      "patch": "@@ -16,10 +16,8 @@\n package com.lmax.disruptor.dsl.stubs;\n \n import com.lmax.disruptor.util.DaemonThreadFactory;\n-import org.junit.Assert;\n-import org.junit.rules.TestRule;\n-import org.junit.runner.Description;\n-import org.junit.runners.model.Statement;\n+import org.junit.jupiter.api.extension.AfterEachCallback;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n \n import java.util.ArrayList;\n import java.util.Collection;\n@@ -31,7 +29,9 @@\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.logging.Logger;\n \n-public final class StubThreadFactory implements ThreadFactory, TestRule\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+\n+public final class StubThreadFactory implements ThreadFactory, AfterEachCallback\n {\n     private static final Logger LOGGER = Logger.getLogger(StubThreadFactory.class.getName());\n \n@@ -84,7 +84,7 @@ public void joinAllThreads()\n                 }\n             }\n \n-            Assert.assertFalse(\"Failed to stop thread: \" + thread, thread.isAlive());\n+            assertFalse(thread.isAlive(), \"Failed to stop thread: \" + thread);\n         }\n \n         threads.clear();\n@@ -101,42 +101,29 @@ public int getExecutionCount()\n     }\n \n     @Override\n-    public Statement apply(final Statement base, final Description description)\n+    public void afterEach(final ExtensionContext context) throws Exception\n     {\n-        return new Statement()\n+        if (!threadErrors.isEmpty())\n         {\n-            @Override\n-            public void evaluate() throws Throwable\n+            for (final Throwable threadError : threadErrors)\n             {\n-                base.evaluate();\n-                if (!threadErrors.isEmpty())\n+                boolean ignored = false;\n+                for (final IgnoredException ignoredException : ignoredExceptions)\n                 {\n-                    for (final Throwable threadError : threadErrors)\n+                    if (threadError.getMessage().equalsIgnoreCase(ignoredException.exceptionMessage))\n                     {\n-                        boolean ignored = false;\n-                        for (final IgnoredException ignoredException : ignoredExceptions)\n-                        {\n-                            if (threadError.getMessage().equalsIgnoreCase(ignoredException.exceptionMessage))\n-                            {\n-                                LOGGER.info(\"Ignoring '\" + threadError.getMessage() + \"' \" +\n-                                        \"because: \" + ignoredException.reason);\n-                                ignored = true;\n-                                break;\n-                            }\n-                        }\n-                        if (!ignored)\n-                        {\n-                            throw threadError;\n-                        }\n+                        LOGGER.info(\"Ignoring '\" + threadError.getMessage() + \"' \" +\n+                                \"because: \" + ignoredException.reason);\n+                        ignored = true;\n+                        break;\n                     }\n                 }\n+                if (!ignored)\n+                {\n+                    throw new Exception(threadError);\n+                }\n             }\n-        };\n-    }\n-\n-    public void ignoreException(final String exceptionMessage, final String reason)\n-    {\n-        ignoredExceptions.add(new IgnoredException(exceptionMessage, reason));\n+        }\n     }\n \n     private static final class IgnoredException",
      "parent_sha": "a7548f5fe6a03232fbc184e235db2d04f87bdb13"
    }
  },
  {
    "oid": "6e33b762291a1807669fdfd72a13fb1f7af465e6",
    "message": "Small change to accuracy of java doc\n\nChanged 'and' to 'or' when describing the circumstances that an IllegalArgumentException will be thrown, and it will occur if either condition is met.",
    "date": "2013-05-15T02:39:37Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/6e33b762291a1807669fdfd72a13fb1f7af465e6",
    "details": {
      "sha": "700008dc875a6672e2819e3ed0e627d8db65e321",
      "filename": "src/main/java/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/6e33b762291a1807669fdfd72a13fb1f7af465e6/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/6e33b762291a1807669fdfd72a13fb1f7af465e6/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=6e33b762291a1807669fdfd72a13fb1f7af465e6",
      "patch": "@@ -38,7 +38,7 @@ public final class RingBuffer<E> implements Cursored, DataProvider<E>\n      *\n      * @param eventFactory to newInstance entries for filling the RingBuffer\n      * @param sequencer sequencer to handle the ordering of events moving through the RingBuffer.\n-     * @throws IllegalArgumentException if bufferSize is less than 1 and not a power of 2\n+     * @throws IllegalArgumentException if bufferSize is less than 1 or not a power of 2\n      */\n     RingBuffer(EventFactory<E> eventFactory,\n                Sequencer       sequencer)\n@@ -67,7 +67,7 @@ public final class RingBuffer<E> implements Cursored, DataProvider<E>\n      * @param factory used to create the events within the ring buffer.\n      * @param bufferSize number of elements to create within the ring buffer.\n      * @param waitStrategy used to determine how to wait for new elements to become available.\n-     * @throws IllegalArgumentException if bufferSize is less than 1 and not a power of 2\n+     * @throws IllegalArgumentException if bufferSize is less than 1 or not a power of 2\n      */\n     public static <E> RingBuffer<E> createMultiProducer(EventFactory<E> factory,\n                                                         int             bufferSize,\n@@ -84,7 +84,7 @@ public static <E> RingBuffer<E> createMultiProducer(EventFactory<E> factory,\n      * @see MultiProducerSequencer\n      * @param factory used to create the events within the ring buffer.\n      * @param bufferSize number of elements to create within the ring buffer.\n-     * @throws IllegalArgumentException if <tt>bufferSize</tt> is less than 1 and not a power of 2\n+     * @throws IllegalArgumentException if <tt>bufferSize</tt> is less than 1 or not a power of 2\n      */\n     public static <E> RingBuffer<E> createMultiProducer(EventFactory<E> factory, int bufferSize)\n     {\n@@ -98,7 +98,7 @@ public static <E> RingBuffer<E> createMultiProducer(EventFactory<E> factory, int\n      * @param factory used to create the events within the ring buffer.\n      * @param bufferSize number of elements to create within the ring buffer.\n      * @param waitStrategy used to determine how to wait for new elements to become available.\n-     * @throws IllegalArgumentException if bufferSize is less than 1 and not a power of 2\n+     * @throws IllegalArgumentException if bufferSize is less than 1 or not a power of 2\n      */\n     public static <E> RingBuffer<E> createSingleProducer(EventFactory<E> factory,\n                                                          int             bufferSize,\n@@ -115,7 +115,7 @@ public static <E> RingBuffer<E> createSingleProducer(EventFactory<E> factory,\n      * @see MultiProducerSequencer\n      * @param factory used to create the events within the ring buffer.\n      * @param bufferSize number of elements to create within the ring buffer.\n-     * @throws IllegalArgumentException if <tt>bufferSize</tt> is less than 1 and not a power of 2\n+     * @throws IllegalArgumentException if <tt>bufferSize</tt> is less than 1 or not a power of 2\n      */\n     public static <E> RingBuffer<E> createSingleProducer(EventFactory<E> factory, int bufferSize)\n     {\n@@ -129,7 +129,7 @@ public static <E> RingBuffer<E> createSingleProducer(EventFactory<E> factory, in\n      * @param factory used to create events within the ring buffer.\n      * @param bufferSize number of elements to create within the ring buffer.\n      * @param waitStrategy used to determine how to wait for new elements to become available.\n-     * @throws IllegalArgumentException if bufferSize is less than 1 and not a power of 2\n+     * @throws IllegalArgumentException if bufferSize is less than 1 or not a power of 2\n      */\n     public static <E> RingBuffer<E> create(ProducerType    producerType,\n                                            EventFactory<E> factory,",
      "parent_sha": "2f6af9bad539094cf378d1cb8f6f657caf7f0376"
    }
  },
  {
    "oid": "7c9480ea6681879ffed38067d5322cc9032d3b97",
    "message": "Move `Sequence::getAndAdd` to be next to `Sequence::addAndGet`",
    "date": "2021-04-08T09:33:36Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/7c9480ea6681879ffed38067d5322cc9032d3b97",
    "details": {
      "sha": "eb563b0da1e400f4ba61fdcdc97f1e61da112c0f",
      "filename": "src/main/java/com/lmax/disruptor/Sequence.java",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/7c9480ea6681879ffed38067d5322cc9032d3b97/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSequence.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/7c9480ea6681879ffed38067d5322cc9032d3b97/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSequence.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSequence.java?ref=7c9480ea6681879ffed38067d5322cc9032d3b97",
      "patch": "@@ -103,17 +103,6 @@ public void set(final long value)\n         this.value = value;\n     }\n \n-    /**\n-     * Perform an atomic getAndAdd operation on the sequence.\n-     *\n-     * @param increment The value to add to the sequence.\n-     * @return the value before increment\n-     */\n-    public long getAndAdd(final long increment)\n-    {\n-        return (long) VALUE_FIELD.getAndAdd(this, increment);\n-    }\n-\n     /**\n      * Performs a volatile write of this sequence.  The intent is\n      * a Store/Store barrier between this write and any previous\n@@ -162,6 +151,17 @@ public long addAndGet(final long increment)\n         return (long) VALUE_FIELD.getAndAdd(this, increment) + increment;\n     }\n \n+    /**\n+     * Perform an atomic getAndAdd operation on the sequence.\n+     *\n+     * @param increment The value to add to the sequence.\n+     * @return the value before increment\n+     */\n+    public long getAndAdd(final long increment)\n+    {\n+        return (long) VALUE_FIELD.getAndAdd(this, increment);\n+    }\n+\n     @Override\n     public String toString()\n     {",
      "parent_sha": "fb5b8a046c26c85f032bd011b3900f8f67d196b6"
    }
  },
  {
    "oid": "204135ecdd2226d1176cf95b58038d891ba7f895",
    "message": "Javadoc correction.",
    "date": "2011-04-27T13:32:16Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/204135ecdd2226d1176cf95b58038d891ba7f895",
    "details": {
      "sha": "cf293871326246689f174d24476210f22ca41b5d",
      "filename": "code/src/main/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/204135ecdd2226d1176cf95b58038d891ba7f895/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/204135ecdd2226d1176cf95b58038d891ba7f895/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=204135ecdd2226d1176cf95b58038d891ba7f895",
      "patch": "@@ -8,7 +8,7 @@\n import static com.lmax.disruptor.Util.ceilingNextPowerOfTwo;\n \n /**\n- * Ring based store of reusable entries that are at items being exchanged between producers and consumers.\n+ * Ring based store of reusable entries that are items containing the data being exchanged between producers and consumers representing an event.\n  *\n  * @param <T> Entry implementation storing the data for sharing during exchange or parallel coordination of an event.\n  */",
      "parent_sha": "60eff7ed582f3a23f52afc062e2f8d1e3babe9c3"
    }
  },
  {
    "oid": "27de34b973bd0efbc5dafb0c06ef09e7579c1a0e",
    "message": "Cleaner handling of serialisationPublishing test for MultiThreadedClaimStrategy.",
    "date": "2011-11-02T23:41:35Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/27de34b973bd0efbc5dafb0c06ef09e7579c1a0e",
    "details": {
      "sha": "805c127f586e47e91f0dfcc36ee5813fc0841f8b",
      "filename": "code/src/test/com/lmax/disruptor/MultiThreadedClaimStrategyTest.java",
      "status": "modified",
      "additions": 5,
      "deletions": 23,
      "changes": 28,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/27de34b973bd0efbc5dafb0c06ef09e7579c1a0e/code%2Fsrc%2Ftest%2Fcom%2Flmax%2Fdisruptor%2FMultiThreadedClaimStrategyTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/27de34b973bd0efbc5dafb0c06ef09e7579c1a0e/code%2Fsrc%2Ftest%2Fcom%2Flmax%2Fdisruptor%2FMultiThreadedClaimStrategyTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Ftest%2Fcom%2Flmax%2Fdisruptor%2FMultiThreadedClaimStrategyTest.java?ref=27de34b973bd0efbc5dafb0c06ef09e7579c1a0e",
      "patch": "@@ -26,6 +26,7 @@\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.AtomicReferenceArray;\n \n import static junit.framework.Assert.*;\n \n@@ -205,35 +206,17 @@ public void shouldSerialisePublishingOnTheCursorWhenTwoThreadsArePublishing() th\n         final Sequence dependentSequence = new Sequence(Sequencer.INITIAL_CURSOR_VALUE);\n         final Sequence[] dependentSequences = { dependentSequence };\n \n-        final AtomicInteger tOneCounter = new AtomicInteger(0);\n-        final AtomicInteger tTwoCounter = new AtomicInteger(0);\n-        final AtomicReference<String> firstToUpdate = new AtomicReference<String>(\"init\");\n+        final AtomicReferenceArray<String> threadSequences = new AtomicReferenceArray<String>(2);\n \n         final Sequence cursor = new Sequence(Sequencer.INITIAL_CURSOR_VALUE)\n         {\n-            @Override\n-            public long get()\n-            {\n-                if (\"tOne\".equals(Thread.currentThread().getName()))\n-                {\n-                    tOneCounter.getAndIncrement();\n-                }\n-\n-                if (\"tTwo\".equals(Thread.currentThread().getName()))\n-                {\n-                    tTwoCounter.getAndIncrement();\n-                }\n-\n-                return super.get();\n-            }\n-\n             @Override\n             public void set(final long value)\n             {\n                 final String threadName = Thread.currentThread().getName();\n                 if (\"tOne\".equals(threadName) || \"tTwo\".equals(threadName))\n                 {\n-                    firstToUpdate.compareAndSet(\"init\", threadName);\n+                    threadSequences.set((int)value, threadName);\n                 }\n \n                 super.set(value);\n@@ -292,8 +275,7 @@ public void run()\n         tOne.join();\n         tTwo.join();\n \n-        assertEquals(1L, tOneCounter.get());\n-        assertTrue(tTwoCounter.get() > 1L);\n-        assertEquals(\"tOne\", firstToUpdate.get());\n+        assertEquals(\"tOne\", threadSequences.get(0));\n+        assertEquals(\"tTwo\", threadSequences.get(1));\n     }\n }",
      "parent_sha": "03c1b578b971c6ec8668eb7e657344b310063174"
    }
  },
  {
    "oid": "0981cadfae9e2d031f93c719e543a2cb14c13b8c",
    "message": "Cache line padding need one more for 32-bit.",
    "date": "2011-08-31T06:11:50Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/0981cadfae9e2d031f93c719e543a2cb14c13b8c",
    "details": {
      "sha": "808a47dafd7dd0b679ad8fcbbbcf835b010b6154",
      "filename": "code/src/main/com/lmax/disruptor/Sequence.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/0981cadfae9e2d031f93c719e543a2cb14c13b8c/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FSequence.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/0981cadfae9e2d031f93c719e543a2cb14c13b8c/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FSequence.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FSequence.java?ref=0981cadfae9e2d031f93c719e543a2cb14c13b8c",
      "patch": "@@ -12,7 +12,7 @@ public class Sequence\n     /**\n      * Size of a long array so the object header, value, and padding all fit in a 64 byte cache line.\n      */\n-    public static final int VALUE_PLUS_CACHE_LINE_PADDING = 5;\n+    public static final int VALUE_PLUS_CACHE_LINE_PADDING = 6;\n \n     private final AtomicLongArray value = new AtomicLongArray(VALUE_PLUS_CACHE_LINE_PADDING);\n ",
      "parent_sha": "824eba196caf79182e058a6d3cd0265b2255f5f5"
    }
  },
  {
    "oid": "f65260928de1a73d0baa9cc64dd3335f549c120b",
    "message": "Rewrite RingBufferTest in spirit of JUnit 5",
    "date": "2020-12-04T16:06:43Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/f65260928de1a73d0baa9cc64dd3335f549c120b",
    "details": {
      "sha": "d42f7a3e087483f422009330ed697e2789d4525d",
      "filename": "src/test/java/com/lmax/disruptor/RingBufferTest.java",
      "status": "modified",
      "additions": 712,
      "deletions": 577,
      "changes": 1289,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/f65260928de1a73d0baa9cc64dd3335f549c120b/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBufferTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/f65260928de1a73d0baa9cc64dd3335f549c120b/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBufferTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBufferTest.java?ref=f65260928de1a73d0baa9cc64dd3335f549c120b",
      "patch": "@@ -15,15 +15,10 @@\n  */\n package com.lmax.disruptor;\n \n-import static com.lmax.disruptor.RingBuffer.createMultiProducer;\n-import static com.lmax.disruptor.RingBufferEventMatcher.ringBufferWithEvents;\n-import static org.hamcrest.CoreMatchers.is;\n-import static org.hamcrest.CoreMatchers.nullValue;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertThat;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n+import com.lmax.disruptor.support.StubEvent;\n+import com.lmax.disruptor.support.TestWaiter;\n+import com.lmax.disruptor.util.DaemonThreadFactory;\n+import org.junit.jupiter.api.Test;\n \n import java.util.List;\n import java.util.concurrent.BrokenBarrierException;\n@@ -34,11 +29,16 @@\n import java.util.concurrent.Future;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n-import org.junit.Test;\n-\n-import com.lmax.disruptor.support.StubEvent;\n-import com.lmax.disruptor.support.TestWaiter;\n-import com.lmax.disruptor.util.DaemonThreadFactory;\n+import static com.lmax.disruptor.RingBuffer.createMultiProducer;\n+import static com.lmax.disruptor.RingBufferEventMatcher.ringBufferWithEvents;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n \n public class RingBufferTest\n {\n@@ -270,22 +270,25 @@ public void shouldPublishEvents() throws Exception\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsIfBatchIsLargerThanRingBuffer() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        final EventTranslator<Object[]> eventTranslator = new NoArgEventTranslator();\n-        final EventTranslator<Object[]>[] translators =\n-            new EventTranslator[]{eventTranslator, eventTranslator, eventTranslator, eventTranslator, eventTranslator};\n-\n-        try\n-        {\n-            ringBuffer.tryPublishEvents(translators);\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            final EventTranslator<Object[]> eventTranslator = new NoArgEventTranslator();\n+            final EventTranslator<Object[]>[] translators =\n+                    new EventTranslator[]{eventTranslator, eventTranslator, eventTranslator, eventTranslator, eventTranslator};\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(translators);\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n     @SuppressWarnings(\"unchecked\")\n@@ -333,20 +336,23 @@ public void shouldPublishEventsOneArg() throws Exception\n         assertThat(ringBuffer, ringBufferWithEvents(\"Foo-0\", \"Foo-1\", \"Foo-2\", \"Foo-3\"));\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsOneArgIfBatchIsLargerThanRingBuffer() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.tryPublishEvents(translator, new String[]{\"Foo\", \"Foo\", \"Foo\", \"Foo\", \"Foo\"});\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(translator, new String[]{\"Foo\", \"Foo\", \"Foo\", \"Foo\", \"Foo\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n     @Test\n@@ -388,23 +394,26 @@ public void shouldPublishEventsTwoArg() throws Exception\n         assertThat(ringBuffer, ringBufferWithEvents(\"FooBar-0\", \"FooBar-1\", \"FooBar-2\", \"FooBar-3\"));\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsITwoArgIfBatchSizeIsBiggerThanRingBuffer() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.tryPublishEvents(\n-                translator,\n-                new String[]{\"Foo\", \"Foo\", \"Foo\", \"Foo\", \"Foo\"},\n-                new String[]{\"Bar\", \"Bar\", \"Bar\", \"Bar\", \"Bar\"});\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(\n+                        translator,\n+                        new String[]{\"Foo\", \"Foo\", \"Foo\", \"Foo\", \"Foo\"},\n+                        new String[]{\"Bar\", \"Bar\", \"Bar\", \"Bar\", \"Bar\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n     @Test\n@@ -450,24 +459,27 @@ public void shouldPublishEventsThreeArg() throws Exception\n         assertThat(ringBuffer, ringBufferWithEvents(\"FooBarBaz-0\", \"FooBarBaz-1\", \"FooBarBaz-2\", \"FooBarBaz-3\"));\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsThreeArgIfBatchIsLargerThanRingBuffer() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();\n-\n-        try\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            ringBuffer.tryPublishEvents(\n-                translator,\n-                new String[]{\"Foo\", \"Foo\", \"Foo\", \"Foo\", \"Foo\"},\n-                new String[]{\"Bar\", \"Bar\", \"Bar\", \"Bar\", \"Bar\"},\n-                new String[]{\"Baz\", \"Baz\", \"Baz\", \"Baz\", \"Baz\"});\n-        }\n-        finally\n-        {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(\n+                        translator,\n+                        new String[]{\"Foo\", \"Foo\", \"Foo\", \"Foo\", \"Foo\"},\n+                        new String[]{\"Bar\", \"Bar\", \"Bar\", \"Bar\", \"Bar\"},\n+                        new String[]{\"Baz\", \"Baz\", \"Baz\", \"Baz\", \"Baz\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n     @Test\n@@ -524,26 +536,29 @@ ringBuffer, ringBufferWithEvents(\n                 \"FooBarBazBam-0\", \"FooBarBazBam-1\", \"FooBarBazBam-2\", \"FooBarBazBam-3\"));\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsVarArgIfBatchIsLargerThanRingBuffer() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorVararg<Object[]> translator = new VarArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.tryPublishEvents(\n-                translator,\n-                new String[]{\"Foo\", \"Bar\", \"Baz\", \"Bam\"},\n-                new String[]{\"Foo\", \"Bar\", \"Baz\", \"Bam\"},\n-                new String[]{\"Foo\", \"Bar\", \"Baz\", \"Bam\"},\n-                new String[]{\"Foo\", \"Bar\", \"Baz\", \"Bam\"},\n-                new String[]{\"Foo\", \"Bar\", \"Baz\", \"Bam\"});\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorVararg<Object[]> translator = new VarArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(\n+                        translator,\n+                        new String[]{\"Foo\", \"Bar\", \"Baz\", \"Bam\"},\n+                        new String[]{\"Foo\", \"Bar\", \"Baz\", \"Bam\"},\n+                        new String[]{\"Foo\", \"Bar\", \"Baz\", \"Bam\"},\n+                        new String[]{\"Foo\", \"Bar\", \"Baz\", \"Bam\"},\n+                        new String[]{\"Foo\", \"Bar\", \"Baz\", \"Bam\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n     @Test\n@@ -586,702 +601,822 @@ ringBuffer, ringBufferWithEvents(\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsWhenBatchSizeIs0() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslator<Object[]> translator = new NoArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.publishEvents(new EventTranslator[]{translator, translator, translator, translator}, 1, 0);\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslator<Object[]> translator = new NoArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.publishEvents(new EventTranslator[]{translator, translator, translator, translator}, 1, 0);\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotTryPublishEventsWhenBatchSizeIs0() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslator<Object[]> translator = new NoArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.tryPublishEvents(new EventTranslator[]{translator, translator, translator, translator}, 1, 0);\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslator<Object[]> translator = new NoArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(new EventTranslator[]{translator, translator, translator, translator}, 1, 0);\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsWhenBatchExtendsPastEndOfArray() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslator<Object[]> translator = new NoArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.publishEvents(new EventTranslator[]{translator, translator, translator}, 1, 3);\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslator<Object[]> translator = new NoArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.publishEvents(new EventTranslator[]{translator, translator, translator}, 1, 3);\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotTryPublishEventsWhenBatchExtendsPastEndOfArray() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslator<Object[]> translator = new NoArgEventTranslator();\n-\n-        try\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            ringBuffer.tryPublishEvents(new EventTranslator[]{translator, translator, translator}, 1, 3);\n-        }\n-        finally\n-        {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslator<Object[]> translator = new NoArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(new EventTranslator[]{translator, translator, translator}, 1, 3);\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsWhenBatchSizeIsNegative() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslator<Object[]> translator = new NoArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.publishEvents(new EventTranslator[]{translator, translator, translator, translator}, 1, -1);\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslator<Object[]> translator = new NoArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.publishEvents(new EventTranslator[]{translator, translator, translator, translator}, 1, -1);\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotTryPublishEventsWhenBatchSizeIsNegative() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslator<Object[]> translator = new NoArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.tryPublishEvents(new EventTranslator[]{translator, translator, translator, translator}, 1, -1);\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslator<Object[]> translator = new NoArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(new EventTranslator[]{translator, translator, translator, translator}, 1, -1);\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsWhenBatchStartsAtIsNegative() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslator<Object[]> translator = new NoArgEventTranslator();\n-        try\n-        {\n-            ringBuffer.publishEvents(new EventTranslator[]{translator, translator, translator, translator}, -1, 2);\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslator<Object[]> translator = new NoArgEventTranslator();\n+            try\n+            {\n+                ringBuffer.publishEvents(new EventTranslator[]{translator, translator, translator, translator}, -1, 2);\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotTryPublishEventsWhenBatchStartsAtIsNegative() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslator<Object[]> translator = new NoArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.tryPublishEvents(new EventTranslator[]{translator, translator, translator, translator}, -1, 2);\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslator<Object[]> translator = new NoArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(new EventTranslator[]{translator, translator, translator, translator}, -1, 2);\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsOneArgWhenBatchSizeIs0() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();\n-\n-        try\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            ringBuffer.publishEvents(translator, 1, 0, new String[]{\"Foo\", \"Foo\"});\n-        }\n-        finally\n-        {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.publishEvents(translator, 1, 0, new String[]{\"Foo\", \"Foo\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotTryPublishEventsOneArgWhenBatchSizeIs0() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.tryPublishEvents(translator, 1, 0, new String[]{\"Foo\", \"Foo\"});\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(translator, 1, 0, new String[]{\"Foo\", \"Foo\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsOneArgWhenBatchExtendsPastEndOfArray() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();\n-\n-        try\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            ringBuffer.publishEvents(translator, 1, 3, new String[]{\"Foo\", \"Foo\"});\n-        }\n-        finally\n-        {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.publishEvents(translator, 1, 3, new String[]{\"Foo\", \"Foo\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsOneArgWhenBatchSizeIsNegative() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.publishEvents(translator, 1, -1, new String[]{\"Foo\", \"Foo\"});\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.publishEvents(translator, 1, -1, new String[]{\"Foo\", \"Foo\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsOneArgWhenBatchStartsAtIsNegative() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();\n-        try\n-        {\n-            ringBuffer.publishEvents(translator, -1, 2, new String[]{\"Foo\", \"Foo\"});\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n-    }\n-\n-    @Test(expected = IllegalArgumentException.class)\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();\n+            try\n+            {\n+                ringBuffer.publishEvents(translator, -1, 2, new String[]{\"Foo\", \"Foo\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n+    }\n+\n+    @Test\n     public void shouldNotTryPublishEventsOneArgWhenBatchExtendsPastEndOfArray() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();\n-\n-        try\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            ringBuffer.tryPublishEvents(translator, 1, 3, new String[]{\"Foo\", \"Foo\"});\n-        }\n-        finally\n-        {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(translator, 1, 3, new String[]{\"Foo\", \"Foo\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotTryPublishEventsOneArgWhenBatchSizeIsNegative() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();\n-\n-        try\n-        {\n-            assertFalse(ringBuffer.tryPublishEvents(translator, 1, -1, new String[]{\"Foo\", \"Foo\"}));\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();\n+\n+            try\n+            {\n+                assertFalse(ringBuffer.tryPublishEvents(translator, 1, -1, new String[]{\"Foo\", \"Foo\"}));\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotTryPublishEventsOneArgWhenBatchStartsAtIsNegative() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();\n-\n-        try\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            ringBuffer.tryPublishEvents(translator, -1, 2, new String[]{\"Foo\", \"Foo\"});\n-        }\n-        finally\n-        {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorOneArg<Object[], String> translator = new OneArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(translator, -1, 2, new String[]{\"Foo\", \"Foo\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsTwoArgWhenBatchSizeIs0() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.publishEvents(translator, 1, 0, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"});\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.publishEvents(translator, 1, 0, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotTryPublishEventsTwoArgWhenBatchSizeIs0() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();\n-\n-        try\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            ringBuffer.tryPublishEvents(translator, 1, 0, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"});\n-        }\n-        finally\n-        {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(translator, 1, 0, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsTwoArgWhenBatchExtendsPastEndOfArray() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.publishEvents(translator, 1, 3, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"});\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.publishEvents(translator, 1, 3, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsTwoArgWhenBatchSizeIsNegative() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.publishEvents(translator, 1, -1, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"});\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.publishEvents(translator, 1, -1, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsTwoArgWhenBatchStartsAtIsNegative() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();\n-        try\n-        {\n-            ringBuffer.publishEvents(translator, -1, 2, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"});\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();\n+            try\n+            {\n+                ringBuffer.publishEvents(translator, -1, 2, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotTryPublishEventsTwoArgWhenBatchExtendsPastEndOfArray() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();\n-\n-        try\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            ringBuffer.tryPublishEvents(translator, 1, 3, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"});\n-        }\n-        finally\n-        {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(translator, 1, 3, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotTryPublishEventsTwoArgWhenBatchSizeIsNegative() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.tryPublishEvents(translator, 1, -1, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"});\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(translator, 1, -1, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotTryPublishEventsTwoArgWhenBatchStartsAtIsNegative() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();\n-\n-        try\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            ringBuffer.tryPublishEvents(translator, -1, 2, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"});\n-        }\n-        finally\n-        {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorTwoArg<Object[], String, String> translator = new TwoArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(translator, -1, 2, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsThreeArgWhenBatchSizeIs0() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.publishEvents(\n-                translator, 1, 0, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"},\n-                new String[]{\"Baz\", \"Baz\"});\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.publishEvents(\n+                        translator, 1, 0, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"},\n+                        new String[]{\"Baz\", \"Baz\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotTryPublishEventsThreeArgWhenBatchSizeIs0() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.tryPublishEvents(\n-                    translator, 1, 0, new String[]{\"Foo\", \"Foo\"},\n-                    new String[]{\"Bar\", \"Bar\"}, new String[]{\"Baz\", \"Baz\"});\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(\n+                        translator, 1, 0, new String[]{\"Foo\", \"Foo\"},\n+                        new String[]{\"Bar\", \"Bar\"}, new String[]{\"Baz\", \"Baz\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsThreeArgWhenBatchExtendsPastEndOfArray() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.publishEvents(\n-                translator, 1, 3, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"},\n-                new String[]{\"Baz\", \"Baz\"});\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.publishEvents(\n+                        translator, 1, 3, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"},\n+                        new String[]{\"Baz\", \"Baz\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsThreeArgWhenBatchSizeIsNegative() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();\n-\n-        try\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            ringBuffer.publishEvents(\n-                translator, 1, -1, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"},\n-                new String[]{\"Baz\", \"Baz\"});\n-        }\n-        finally\n-        {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.publishEvents(\n+                        translator, 1, -1, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"},\n+                        new String[]{\"Baz\", \"Baz\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsThreeArgWhenBatchStartsAtIsNegative() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.publishEvents(\n-                translator, -1, 2, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"},\n-                new String[]{\"Baz\", \"Baz\"});\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.publishEvents(\n+                        translator, -1, 2, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"},\n+                        new String[]{\"Baz\", \"Baz\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotTryPublishEventsThreeArgWhenBatchExtendsPastEndOfArray() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.tryPublishEvents(\n-                translator, 1, 3, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"},\n-                new String[]{\"Baz\", \"Baz\"});\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(\n+                        translator, 1, 3, new String[]{\"Foo\", \"Foo\"}, new String[]{\"Bar\", \"Bar\"},\n+                        new String[]{\"Baz\", \"Baz\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotTryPublishEventsThreeArgWhenBatchSizeIsNegative() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();\n-\n-        try\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            ringBuffer.tryPublishEvents(\n-                translator, 1, -1, new String[]{\"Foo\", \"Foo\"},\n-                new String[]{\"Bar\", \"Bar\"}, new String[]{\"Baz\", \"Baz\"});\n-        }\n-        finally\n-        {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(\n+                        translator, 1, -1, new String[]{\"Foo\", \"Foo\"},\n+                        new String[]{\"Bar\", \"Bar\"}, new String[]{\"Baz\", \"Baz\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotTryPublishEventsThreeArgWhenBatchStartsAtIsNegative() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.tryPublishEvents(\n-                translator, -1, 2, new String[]{\"Foo\", \"Foo\"},\n-                new String[]{\"Bar\", \"Bar\"}, new String[]{\"Baz\", \"Baz\"});\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            EventTranslatorThreeArg<Object[], String, String, String> translator = new ThreeArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(\n+                        translator, -1, 2, new String[]{\"Foo\", \"Foo\"},\n+                        new String[]{\"Bar\", \"Bar\"}, new String[]{\"Baz\", \"Baz\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsVarArgWhenBatchSizeIs0() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        VarArgEventTranslator translator = new VarArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.publishEvents(\n-                translator, 1, 0, new String[]{\"Foo0\", \"Bar0\", \"Baz0\", \"Bam0\"},\n-                new String[]{\"Foo1\", \"Bar1\", \"Baz1\", \"Bam1\"}, new String[]{\n-                    \"Foo2\", \"Bar2\",\n-                    \"Baz2\", \"Bam2\"\n-                });\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            VarArgEventTranslator translator = new VarArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.publishEvents(\n+                        translator, 1, 0, new String[]{\"Foo0\", \"Bar0\", \"Baz0\", \"Bam0\"},\n+                        new String[]{\"Foo1\", \"Bar1\", \"Baz1\", \"Bam1\"}, new String[]{\n+                                \"Foo2\", \"Bar2\",\n+                                \"Baz2\", \"Bam2\"\n+                        });\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotTryPublishEventsVarArgWhenBatchSizeIs0() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        VarArgEventTranslator translator = new VarArgEventTranslator();\n-\n-        try\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            ringBuffer.tryPublishEvents(\n-                    translator, 1, 0, new String[]{\"Foo0\", \"Bar0\", \"Baz0\", \"Bam0\"},\n-                    new String[]{\"Foo1\", \"Bar1\", \"Baz1\", \"Bam1\"},\n-                    new String[]{\"Foo2\", \"Bar2\", \"Baz2\", \"Bam2\"});\n-        }\n-        finally\n-        {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            VarArgEventTranslator translator = new VarArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(\n+                        translator, 1, 0, new String[]{\"Foo0\", \"Bar0\", \"Baz0\", \"Bam0\"},\n+                        new String[]{\"Foo1\", \"Bar1\", \"Baz1\", \"Bam1\"},\n+                        new String[]{\"Foo2\", \"Bar2\", \"Baz2\", \"Bam2\"});\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsVarArgWhenBatchExtendsPastEndOfArray() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        VarArgEventTranslator translator = new VarArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.publishEvents(\n-                translator, 1, 3, new String[]{\"Foo0\", \"Bar0\", \"Baz0\", \"Bam0\"},\n-                new String[]{\"Foo1\", \"Bar1\", \"Baz1\", \"Bam1\"}, new String[]{\n-                    \"Foo2\", \"Bar2\",\n-                    \"Baz2\", \"Bam2\"\n-                });\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            VarArgEventTranslator translator = new VarArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.publishEvents(\n+                        translator, 1, 3, new String[]{\"Foo0\", \"Bar0\", \"Baz0\", \"Bam0\"},\n+                        new String[]{\"Foo1\", \"Bar1\", \"Baz1\", \"Bam1\"}, new String[]{\n+                                \"Foo2\", \"Bar2\",\n+                                \"Baz2\", \"Bam2\"\n+                        });\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsVarArgWhenBatchSizeIsNegative() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        VarArgEventTranslator translator = new VarArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.publishEvents(\n-                translator, 1, -1, new String[]{\"Foo0\", \"Bar0\", \"Baz0\", \"Bam0\"},\n-                new String[]{\"Foo1\", \"Bar1\", \"Baz1\", \"Bam1\"}, new String[]{\n-                    \"Foo2\", \"Bar2\",\n-                    \"Baz2\", \"Bam2\"\n-                });\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            VarArgEventTranslator translator = new VarArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.publishEvents(\n+                        translator, 1, -1, new String[]{\"Foo0\", \"Bar0\", \"Baz0\", \"Bam0\"},\n+                        new String[]{\"Foo1\", \"Bar1\", \"Baz1\", \"Bam1\"}, new String[]{\n+                                \"Foo2\", \"Bar2\",\n+                                \"Baz2\", \"Bam2\"\n+                        });\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotPublishEventsVarArgWhenBatchStartsAtIsNegative() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        VarArgEventTranslator translator = new VarArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.publishEvents(\n-                translator, -1, 2, new String[]{\"Foo0\", \"Bar0\", \"Baz0\", \"Bam0\"},\n-                new String[]{\"Foo1\", \"Bar1\", \"Baz1\", \"Bam1\"}, new String[]{\n-                    \"Foo2\", \"Bar2\",\n-                    \"Baz2\", \"Bam2\"\n-                });\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            VarArgEventTranslator translator = new VarArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.publishEvents(\n+                        translator, -1, 2, new String[]{\"Foo0\", \"Bar0\", \"Baz0\", \"Bam0\"},\n+                        new String[]{\"Foo1\", \"Bar1\", \"Baz1\", \"Bam1\"}, new String[]{\n+                                \"Foo2\", \"Bar2\",\n+                                \"Baz2\", \"Bam2\"\n+                        });\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotTryPublishEventsVarArgWhenBatchExtendsPastEndOfArray() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        VarArgEventTranslator translator = new VarArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.tryPublishEvents(\n-                translator, 1, 3, new String[]{\"Foo0\", \"Bar0\", \"Baz0\", \"Bam0\"},\n-                new String[]{\"Foo1\", \"Bar1\", \"Baz1\", \"Bam1\"}, new String[]{\n-                    \"Foo2\", \"Bar2\",\n-                    \"Baz2\", \"Bam2\"\n-                });\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            VarArgEventTranslator translator = new VarArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(\n+                        translator, 1, 3, new String[]{\"Foo0\", \"Bar0\", \"Baz0\", \"Bam0\"},\n+                        new String[]{\"Foo1\", \"Bar1\", \"Baz1\", \"Bam1\"}, new String[]{\n+                                \"Foo2\", \"Bar2\",\n+                                \"Baz2\", \"Bam2\"\n+                        });\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotTryPublishEventsVarArgWhenBatchSizeIsNegative() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        VarArgEventTranslator translator = new VarArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.tryPublishEvents(\n-                translator, 1, -1, new String[]{\"Foo0\", \"Bar0\", \"Baz0\", \"Bam0\"},\n-                new String[]{\"Foo1\", \"Bar1\", \"Baz1\", \"Bam1\"}, new String[]{\n-                    \"Foo2\", \"Bar2\",\n-                    \"Baz2\", \"Bam2\"\n-                });\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            VarArgEventTranslator translator = new VarArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(\n+                        translator, 1, -1, new String[]{\"Foo0\", \"Bar0\", \"Baz0\", \"Bam0\"},\n+                        new String[]{\"Foo1\", \"Bar1\", \"Baz1\", \"Bam1\"}, new String[]{\n+                                \"Foo2\", \"Bar2\",\n+                                \"Baz2\", \"Bam2\"\n+                        });\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n     public void shouldNotTryPublishEventsVarArgWhenBatchStartsAtIsNegative() throws Exception\n     {\n-        RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n-        VarArgEventTranslator translator = new VarArgEventTranslator();\n-\n-        try\n-        {\n-            ringBuffer.tryPublishEvents(\n-                translator, -1, 2, new String[]{\"Foo0\", \"Bar0\", \"Baz0\", \"Bam0\"},\n-                new String[]{\"Foo1\", \"Bar1\", \"Baz1\", \"Bam1\"}, new String[]{\n-                    \"Foo2\", \"Bar2\",\n-                    \"Baz2\", \"Bam2\"\n-                });\n-        }\n-        finally\n+        assertThrows(IllegalArgumentException.class, () ->\n         {\n-            assertEmptyRingBuffer(ringBuffer);\n-        }\n+            RingBuffer<Object[]> ringBuffer = RingBuffer.createSingleProducer(new ArrayFactory(1), 4);\n+            VarArgEventTranslator translator = new VarArgEventTranslator();\n+\n+            try\n+            {\n+                ringBuffer.tryPublishEvents(\n+                        translator, -1, 2, new String[]{\"Foo0\", \"Bar0\", \"Baz0\", \"Bam0\"},\n+                        new String[]{\"Foo1\", \"Bar1\", \"Baz1\", \"Bam1\"}, new String[]{\n+                                \"Foo2\", \"Bar2\",\n+                                \"Baz2\", \"Bam2\"\n+                        });\n+            }\n+            finally\n+            {\n+                assertEmptyRingBuffer(ringBuffer);\n+            }\n+        });\n     }\n \n     @Test",
      "parent_sha": "3a49717ffb83aff94f125a238182a6e92473f42f"
    }
  },
  {
    "oid": "2444b7a4da91fec3f1ce3aabbad17085c509854a",
    "message": "Fix test",
    "date": "2014-03-10T01:06:26Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/2444b7a4da91fec3f1ce3aabbad17085c509854a",
    "details": {
      "sha": "b8eb1f3530be257cf0f7dc70d097f936c0c278cf",
      "filename": "src/test/java/com/lmax/disruptor/dsl/DisruptorTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/2444b7a4da91fec3f1ce3aabbad17085c509854a/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fdsl%2FDisruptorTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/2444b7a4da91fec3f1ce3aabbad17085c509854a/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fdsl%2FDisruptorTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fdsl%2FDisruptorTest.java?ref=2444b7a4da91fec3f1ce3aabbad17085c509854a",
      "patch": "@@ -361,10 +361,9 @@ public void shouldSupportUsingWorkerPoolAsDependency() throws Exception\n         publishEvent();\n         publishEvent();\n \n-        workHandler2.processEvent();\n-\n         assertThat(disruptor.getBarrierFor(delayedEventHandler).getCursor(), equalTo(-1L));\n-\n+        \n+        workHandler2.processEvent();\n         workHandler1.processEvent();\n \n         delayedEventHandler.processEvent();",
      "parent_sha": "01999ff9df5d6d800d2051f0e1135fa50d814492"
    }
  },
  {
    "oid": "3778522ce2d47c106a38c2310829f30a654241e7",
    "message": "Javadoc correction",
    "date": "2011-09-10T08:34:35Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/3778522ce2d47c106a38c2310829f30a654241e7",
    "details": {
      "sha": "6dd45297d94b4f47fa245c73df06fa98800605c4",
      "filename": "code/src/main/com/lmax/disruptor/SequenceGroup.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/3778522ce2d47c106a38c2310829f30a654241e7/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FSequenceGroup.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/3778522ce2d47c106a38c2310829f30a654241e7/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FSequenceGroup.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FSequenceGroup.java?ref=3778522ce2d47c106a38c2310829f30a654241e7",
      "patch": "@@ -18,7 +18,7 @@\n import java.util.concurrent.CopyOnWriteArrayList;\n \n /**\n- * Group {@link Sequence} that can dynamically have {@link Sequence}s added and removed while being\n+ * {@link Sequence} group that can dynamically have {@link Sequence}s added and removed while being\n  * thread safe.\n  * <p>\n  * The {@link SequenceGroup#get()} and {@link SequenceGroup#set(long)} methods are lock free and can be",
      "parent_sha": "5dd974067159378d8d527cbb657614de713e38f8"
    }
  },
  {
    "oid": "8315de0472e5a647318c0ec6dd27ad6849619430",
    "message": "Code consistency tweaks.",
    "date": "2011-05-03T20:52:35Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/8315de0472e5a647318c0ec6dd27ad6849619430",
    "details": {
      "sha": "3a2bcd1b272b9468a26ed797378461afe05d4338",
      "filename": "code/src/main/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/8315de0472e5a647318c0ec6dd27ad6849619430/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/8315de0472e5a647318c0ec6dd27ad6849619430/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=8315de0472e5a647318c0ec6dd27ad6849619430",
      "patch": "@@ -221,7 +221,7 @@ public long waitFor(final long sequence)\n         {\n             long availableSequence = waitStrategy.waitFor(ringBuffer, sequence);\n \n-            if (0 != entryConsumers.length)\n+            if (entryConsumers.length != 0)\n             {\n                 while ((availableSequence = getAvailableSequence()) < sequence)\n                 {\n@@ -234,11 +234,11 @@ public long waitFor(final long sequence)\n \n         @Override\n         public long waitFor(final long sequence, final long timeout, final TimeUnit units)\n-            throws InterruptedException, AlertException\n+            throws AlertException, InterruptedException\n         {\n             long availableSequence = waitStrategy.waitFor(ringBuffer, sequence, timeout, units);\n \n-            if (0 != entryConsumers.length)\n+            if (entryConsumers.length != 0)\n             {\n                 while ((availableSequence = getAvailableSequence()) < sequence)\n                 {",
      "parent_sha": "0ecf4cf3b08effeffe8f9be2ce2394f4b666118c"
    }
  },
  {
    "oid": "18105e0ec1d1154f1e7092b06d34b47da85f34b3",
    "message": "Revert multi-threaded claim strategy because of race conditions on Apple Macs",
    "date": "2011-10-31T18:30:56Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/18105e0ec1d1154f1e7092b06d34b47da85f34b3",
    "details": {
      "sha": "052e4c188036f1e82223f7697aaa9a754ae87810",
      "filename": "code/src/main/com/lmax/disruptor/ClaimStrategy.java",
      "status": "modified",
      "additions": 6,
      "deletions": 56,
      "changes": 62,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/18105e0ec1d1154f1e7092b06d34b47da85f34b3/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FClaimStrategy.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/18105e0ec1d1154f1e7092b06d34b47da85f34b3/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FClaimStrategy.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FClaimStrategy.java?ref=18105e0ec1d1154f1e7092b06d34b47da85f34b3",
      "patch": "@@ -19,7 +19,6 @@\n import com.lmax.disruptor.util.PaddedAtomicLong;\n import com.lmax.disruptor.util.PaddedLong;\n \n-import java.util.concurrent.atomic.AtomicLongArray;\n import java.util.concurrent.locks.LockSupport;\n \n import static com.lmax.disruptor.util.Util.getMinimumSequence;\n@@ -112,10 +111,7 @@ public static final class MultiThreadedStrategy\n         implements ClaimStrategy\n     {\n         private final int bufferSize;\n-        private final int indexMask;\n-        private final AtomicLongArray pendingPublications;\n         private final PaddedAtomicLong claimSequence = new PaddedAtomicLong(Sequencer.INITIAL_CURSOR_VALUE);\n-        private final PaddedAtomicLong csLock = new PaddedAtomicLong(0L);\n \n         private final ThreadLocal<MutableLong> minGatingSequenceThreadLocal = new ThreadLocal<MutableLong>()\n         {\n@@ -128,18 +124,7 @@ protected MutableLong initialValue()\n \n         public MultiThreadedStrategy(final int bufferSize)\n         {\n-            if (Integer.bitCount(bufferSize) != 1)\n-            {\n-                throw new IllegalArgumentException(\"bufferSize must be a power of 2\");\n-            }\n-\n             this.bufferSize = bufferSize;\n-            indexMask = bufferSize - 1;\n-            pendingPublications = new AtomicLongArray(bufferSize);\n-            for (int i = 0, size = pendingPublications.length(); i < size; i++)\n-            {\n-                pendingPublications.lazySet(i, Sequencer.INITIAL_CURSOR_VALUE);\n-            }\n         }\n \n         @Override\n@@ -193,47 +178,12 @@ public void setSequence(final long sequence, final Sequence[] dependentSequences\n         public void serialisePublishing(final long sequence, final Sequence cursor, final int batchSize)\n         {\n             final long expectedSequence = sequence - batchSize;\n-            if (expectedSequence == cursor.get())\n-            {\n-                cursor.set(sequence);\n-                if (sequence == claimSequence.get())\n-                {\n-                    return;\n-                }\n-            }\n-            else\n+            while (expectedSequence != cursor.get())\n             {\n-                for (long i = expectedSequence + 1; i < sequence; i++)\n-                {\n-                    pendingPublications.lazySet((int)i & indexMask, i);\n-                }\n-\n-                pendingPublications.set((int)sequence & indexMask, sequence);\n+                // busy spin\n             }\n \n-            if (csLock.compareAndSet(0L, 1L))\n-            {\n-                long initialCursor = cursor.get();\n-                long currentCursor = initialCursor;\n-\n-                while (currentCursor < claimSequence.get())\n-                {\n-                    long nextSequence = currentCursor + 1L;\n-                    if (nextSequence != pendingPublications.get((int)nextSequence & indexMask))\n-                    {\n-                        break;\n-                    }\n-\n-                    currentCursor = nextSequence;\n-                }\n-\n-                if (currentCursor > initialCursor)\n-                {\n-                    cursor.set(currentCursor);\n-                }\n-\n-                csLock.set(0L);\n-            }\n+            cursor.set(sequence);\n         }\n \n         private void waitForCapacity(final Sequence[] dependentSequences, final MutableLong minGatingSequence)\n@@ -244,7 +194,7 @@ private void waitForCapacity(final Sequence[] dependentSequences, final MutableL\n                 long minSequence;\n                 while (wrapPoint > (minSequence = getMinimumSequence(dependentSequences)))\n                 {\n-                    LockSupport.parkNanos(1000L);\n+                    LockSupport.parkNanos(1L);\n                 }\n \n                 minGatingSequence.set(minSequence);\n@@ -259,7 +209,7 @@ private void waitForFreeSlotAt(final long sequence, final Sequence[] dependentSe\n                 long minSequence;\n                 while (wrapPoint > (minSequence = getMinimumSequence(dependentSequences)))\n                 {\n-                    LockSupport.parkNanos(1000L);\n+                    LockSupport.parkNanos(1L);\n                 }\n \n                 minGatingSequence.set(minSequence);\n@@ -341,7 +291,7 @@ private void waitForFreeSlotAt(final long sequence, final Sequence[] dependentSe\n                 long minSequence;\n                 while (wrapPoint > (minSequence = getMinimumSequence(dependentSequences)))\n                 {\n-                    LockSupport.parkNanos(1000L);\n+                    LockSupport.parkNanos(1L);\n                 }\n \n                 minGatingSequence.set(minSequence);",
      "parent_sha": "f88dedadba4d99a902790665396216305201cf14"
    }
  },
  {
    "oid": "1325a8d9e29079474f4f8ce8520a6cd7613403e6",
    "message": "Improved Javadoc",
    "date": "2011-05-03T16:42:48Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/1325a8d9e29079474f4f8ce8520a6cd7613403e6",
    "details": {
      "sha": "7fbe2223e257a25c31cdc4db8dfc7283d15d8b40",
      "filename": "code/src/main/com/lmax/disruptor/ClaimStrategy.java",
      "status": "modified",
      "additions": 7,
      "deletions": 2,
      "changes": 9,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/1325a8d9e29079474f4f8ce8520a6cd7613403e6/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FClaimStrategy.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/1325a8d9e29079474f4f8ce8520a6cd7613403e6/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FClaimStrategy.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FClaimStrategy.java?ref=1325a8d9e29079474f4f8ce8520a6cd7613403e6",
      "patch": "@@ -3,8 +3,7 @@\n import java.util.concurrent.atomic.AtomicLong;\n \n /**\n- * Implementations of this strategy can handled the necessary threading requirements\n- * for claiming {@link Entry}s in the {@link RingBuffer}.\n+ * Strategies employed for claiming the sequence of {@link Entry}s in the {@link RingBuffer} by producers.\n  *\n  * The {@link Entry} index is a the sequence value mod the {@link RingBuffer} capacity.\n  */\n@@ -65,6 +64,9 @@ public ClaimStrategy newInstance()\n         abstract ClaimStrategy newInstance();\n     }\n \n+    /**\n+     * Strategy to be used when there are multiple producer threads claiming {@link Entry}s.\n+     */\n     static final class MultiThreadedStrategy\n         implements ClaimStrategy\n     {\n@@ -92,6 +94,9 @@ public void waitForCursor(final long sequence, final RingBuffer ringBuffer)\n         }\n     }\n \n+    /**\n+     * Optimised strategy can be used when there is a single producer thread claiming {@link Entry}s.\n+     */\n     static final class SingleThreadedStrategy\n         implements ClaimStrategy\n     {",
      "parent_sha": "55f528e962cfc72fb1b0bbb06bf9a7c18ae6d2e5"
    }
  },
  {
    "oid": "6ed79e211815cf9d9d81c7391d6a84d25f338cc2",
    "message": "Added some clarity to operator precedence.",
    "date": "2011-06-04T10:40:52Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/6ed79e211815cf9d9d81c7391d6a84d25f338cc2",
    "details": {
      "sha": "786f41da8c3b008a92c74b7de47a0a581287fa2a",
      "filename": "code/src/perf/com/lmax/disruptor/Pipeline3StepLatencyPerfTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/6ed79e211815cf9d9d81c7391d6a84d25f338cc2/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FPipeline3StepLatencyPerfTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/6ed79e211815cf9d9d81c7391d6a84d25f338cc2/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FPipeline3StepLatencyPerfTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FPipeline3StepLatencyPerfTest.java?ref=6ed79e211815cf9d9d81c7391d6a84d25f338cc2",
      "patch": "@@ -181,7 +181,7 @@ private void runDisruptorPass()\n             producerBarrier.commit(entry);\n \n             long pauseStart = System.nanoTime();\n-            while (PAUSE_NANOS > System.nanoTime() -  pauseStart)\n+            while (PAUSE_NANOS > (System.nanoTime() -  pauseStart))\n             {\n                 // busy spin\n             }\n@@ -212,7 +212,7 @@ private void runQueuePass() throws Exception\n             stepOneQueue.put(Long.valueOf(System.nanoTime()));\n \n             long pauseStart = System.nanoTime();\n-            while (PAUSE_NANOS > System.nanoTime() -  pauseStart)\n+            while (PAUSE_NANOS > (System.nanoTime() -  pauseStart))\n             {\n                 // busy spin\n             }",
      "parent_sha": "795cf16c88a51d9f1b770227f5e851d66eae303d"
    }
  },
  {
    "oid": "9a256c6288ba4b4dd00c5e9272b21d0933a2c424",
    "message": "Fix spelling mistake",
    "date": "2012-11-14T13:56:11Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/9a256c6288ba4b4dd00c5e9272b21d0933a2c424",
    "details": {
      "sha": "d13000478ed6b6d1da36a8c3cece1fdd6d3557c8",
      "filename": "src/main/java/com/lmax/disruptor/SequenceGroups.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/9a256c6288ba4b4dd00c5e9272b21d0933a2c424/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSequenceGroups.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/9a256c6288ba4b4dd00c5e9272b21d0933a2c424/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSequenceGroups.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSequenceGroups.java?ref=9a256c6288ba4b4dd00c5e9272b21d0933a2c424",
      "patch": "@@ -93,7 +93,7 @@ private static <T> int countMatching(T[] values, final T toMatch)\n         int numToRemove = 0;\n         for (T value : values)\n         {\n-            if (value == toMatch) // Specificly uses identity\n+            if (value == toMatch) // Specifically uses identity\n             {\n                 numToRemove++;\n             }",
      "parent_sha": "1826188aa4e9256b565f7be5874ab1957367d5fe"
    }
  },
  {
    "oid": "fdab02d2688621f66757de9f375d174bccb804a8",
    "message": "Back to using an AtomicBoolean for LiteBlockingWaitStrategy",
    "date": "2013-11-16T00:41:58Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/fdab02d2688621f66757de9f375d174bccb804a8",
    "details": {
      "sha": "fccd9802cfa56f746b26a4c80cd7f75381831f5b",
      "filename": "src/main/java/com/lmax/disruptor/LiteBlockingWaitStrategy.java",
      "status": "modified",
      "additions": 13,
      "deletions": 8,
      "changes": 21,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/fdab02d2688621f66757de9f375d174bccb804a8/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FLiteBlockingWaitStrategy.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/fdab02d2688621f66757de9f375d174bccb804a8/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FLiteBlockingWaitStrategy.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FLiteBlockingWaitStrategy.java?ref=fdab02d2688621f66757de9f375d174bccb804a8",
      "patch": "@@ -15,7 +15,7 @@\n  */\n package com.lmax.disruptor;\n \n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.locks.Condition;\n import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantLock;\n@@ -29,7 +29,7 @@ public final class LiteBlockingWaitStrategy implements WaitStrategy\n {\n     private final Lock lock = new ReentrantLock();\n     private final Condition processorNotifyCondition = lock.newCondition();\n-    private final AtomicInteger waiters = new AtomicInteger(0);\n+    private final AtomicBoolean signalNeeded = new AtomicBoolean(false);\n \n     @Override\n     public long waitFor(long sequence, Sequence cursorSequence, Sequence dependentSequence, SequenceBarrier barrier)\n@@ -39,20 +39,25 @@ public long waitFor(long sequence, Sequence cursorSequence, Sequence dependentSe\n         if ((availableSequence = cursorSequence.get()) < sequence)\n         {\n             lock.lock();\n-            int currentWaiters = waiters.get();\n-            waiters.set(currentWaiters + 1);\n-\n+            \n             try\n             {\n-                while ((availableSequence = cursorSequence.get()) < sequence)\n+                do\n                 {\n+                    signalNeeded.set(true);\n+                    \n+                    if ((availableSequence = cursorSequence.get()) >= sequence)\n+                    {\n+                        break;\n+                    }\n+                    \n                     barrier.checkAlert();\n                     processorNotifyCondition.await();\n                 }\n+                while ((availableSequence = cursorSequence.get()) < sequence);\n             }\n             finally\n             {\n-                waiters.lazySet(currentWaiters);\n                 lock.unlock();\n             }\n         }\n@@ -68,7 +73,7 @@ public long waitFor(long sequence, Sequence cursorSequence, Sequence dependentSe\n     @Override\n     public void signalAllWhenBlocking()\n     {\n-        if (!waiters.compareAndSet(0, 0))\n+        if (signalNeeded.getAndSet(false))\n         {\n             lock.lock();\n             try",
      "parent_sha": "9d906bac4b1ff6e01d3fd10c85d5cd77c85f14af"
    }
  },
  {
    "oid": "d45962085f8d3ec447db0edf016f37c6ff45f89a",
    "message": "Allow the number of publishers to be altered by changing a single variable.",
    "date": "2011-09-16T11:54:57Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/d45962085f8d3ec447db0edf016f37c6ff45f89a",
    "details": {
      "sha": "5fb8dd8011939f8575390d18f36035464e4f18dc",
      "filename": "code/src/perf/com/lmax/disruptor/ThreePublisherToOneProcessorSequencedThroughputTest.java",
      "status": "modified",
      "additions": 8,
      "deletions": 6,
      "changes": 14,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/d45962085f8d3ec447db0edf016f37c6ff45f89a/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FThreePublisherToOneProcessorSequencedThroughputTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/d45962085f8d3ec447db0edf016f37c6ff45f89a/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FThreePublisherToOneProcessorSequencedThroughputTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FThreePublisherToOneProcessorSequencedThroughputTest.java?ref=d45962085f8d3ec447db0edf016f37c6ff45f89a",
      "patch": "@@ -101,9 +101,10 @@ public final class ThreePublisherToOneProcessorSequencedThroughputTest extends A\n     private final ValueAdditionQueueProcessor queueProcessor = new ValueAdditionQueueProcessor(blockingQueue);\n     private final ValueQueuePublisher[] valueQueuePublishers = new ValueQueuePublisher[NUM_PUBLISHERS];\n     {\n-        valueQueuePublishers[0] = new ValueQueuePublisher(cyclicBarrier, blockingQueue, ITERATIONS);\n-        valueQueuePublishers[1] = new ValueQueuePublisher(cyclicBarrier, blockingQueue, ITERATIONS);\n-        valueQueuePublishers[2] = new ValueQueuePublisher(cyclicBarrier, blockingQueue, ITERATIONS);\n+        for (int i = 0; i < NUM_PUBLISHERS; i++)\n+        {\n+            valueQueuePublishers[i] = new ValueQueuePublisher(cyclicBarrier, blockingQueue, ITERATIONS);\n+        }\n     }\n \n     ///////////////////////////////////////////////////////////////////////////////////////////////\n@@ -118,9 +119,10 @@ public final class ThreePublisherToOneProcessorSequencedThroughputTest extends A\n     private final BatchEventProcessor<ValueEvent> batchEventProcessor = new BatchEventProcessor<ValueEvent>(ringBuffer, sequenceBarrier, handler);\n     private final ValuePublisher[] valuePublishers = new ValuePublisher[NUM_PUBLISHERS];\n     {\n-        valuePublishers[0] = new ValuePublisher(cyclicBarrier, ringBuffer, ITERATIONS);\n-        valuePublishers[1] = new ValuePublisher(cyclicBarrier, ringBuffer, ITERATIONS);\n-        valuePublishers[2] = new ValuePublisher(cyclicBarrier, ringBuffer, ITERATIONS);\n+        for (int i = 0; i < NUM_PUBLISHERS; i++)\n+        {\n+            valuePublishers[i] = new ValuePublisher(cyclicBarrier, ringBuffer, ITERATIONS);\n+        }\n \n         ringBuffer.setGatingSequences(batchEventProcessor.getSequence());\n     }",
      "parent_sha": "2d21234b799bc8ee199da1ef09bfd2119518a364"
    }
  },
  {
    "oid": "6e1fe90a6074667a7191dfa9c39028b6bd9fb760",
    "message": "Javadoc improvements",
    "date": "2011-09-10T09:15:49Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/6e1fe90a6074667a7191dfa9c39028b6bd9fb760",
    "details": {
      "sha": "905c8c58bb1a8780ffb6c403ba9f32a039fd6222",
      "filename": "code/src/main/com/lmax/disruptor/WaitStrategy.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/6e1fe90a6074667a7191dfa9c39028b6bd9fb760/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FWaitStrategy.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/6e1fe90a6074667a7191dfa9c39028b6bd9fb760/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FWaitStrategy.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FWaitStrategy.java?ref=6e1fe90a6074667a7191dfa9c39028b6bd9fb760",
      "patch": "@@ -70,7 +70,7 @@ enum Option\n     {\n         /**\n          * This strategy uses a condition variable inside a lock to block the event processor\n-         * which saves CPU resource as the expense of lock contention.\n+         * which saves CPU resource at the expense of lock contention.\n          */\n         BLOCKING\n         {\n@@ -131,7 +131,7 @@ public WaitStrategy newInstance()\n     /**\n      * Blocking strategy that uses a lock and condition variable for {@link EventProcessor}s waiting on a barrier.\n      *\n-     * This strategy should be used when performance and low-latency are not as important as CPU resource.\n+     * This strategy can be used when throughput and low-latency are not as important as CPU resource.\n      */\n     static final class BlockingStrategy implements WaitStrategy\n     {\n@@ -359,7 +359,7 @@ else if (counter > 0)\n      * Yielding strategy that uses a Thread.yield() for {@link EventProcessor}s waiting on a barrier\n      * after an initially spinning.\n      *\n-     * This strategy is a good compromise between performance and CPU resource without significant latency spikes.\n+     * This strategy is a good compromise between performance and CPU resource without incurring significant latency spikes.\n      */\n     static final class YieldingStrategy implements WaitStrategy\n     {",
      "parent_sha": "1a598e992d7ad3593a86fc34ca7e72bdc0d04b70"
    }
  },
  {
    "oid": "3b79e5eea3926bf810561f0ad7263be22d3da529",
    "message": "Rename size to bufferSize",
    "date": "2011-10-24T07:02:26Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/3b79e5eea3926bf810561f0ad7263be22d3da529",
    "details": {
      "sha": "4785e9de1d079cbf2ccc5fac1b8cd3c203a02005",
      "filename": "code/src/main/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/3b79e5eea3926bf810561f0ad7263be22d3da529/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/3b79e5eea3926bf810561f0ad7263be22d3da529/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=3b79e5eea3926bf810561f0ad7263be22d3da529",
      "patch": "@@ -29,20 +29,20 @@ public final class RingBuffer<T> extends Sequencer\n      * Construct a RingBuffer with the full option set.\n      *\n      * @param eventFactory to newInstance entries for filling the RingBuffer\n-     * @param size of the RingBuffer that will be rounded up to the next power of 2\n+     * @param bufferSize of the RingBuffer that will be rounded up to the next power of 2\n      * @param claimStrategyOption threading strategy for publisher claiming entries in the ring.\n      * @param waitStrategyOption waiting strategy employed by processorsToTrack waiting on entries becoming available.\n      *\n      * @throws IllegalArgumentException if bufferSize is not a power of 2\n      */\n     public RingBuffer(final EventFactory<T> eventFactory,\n-                      final int size,\n+                      final int bufferSize,\n                       final ClaimStrategy.Option claimStrategyOption,\n                       final WaitStrategy.Option waitStrategyOption)\n     {\n-        super(size, claimStrategyOption, waitStrategyOption);\n+        super(bufferSize, claimStrategyOption, waitStrategyOption);\n \n-        if (Integer.bitCount(size) != 1)\n+        if (Integer.bitCount(bufferSize) != 1)\n         {\n             throw new IllegalArgumentException(\"bufferSize must be a power of 2\");\n         }",
      "parent_sha": "b6cc627d3cda93584872c46d4f8ac22d01c777b2"
    }
  },
  {
    "oid": "822c41f5485e235ae6bc3b1afa5c8808780ef680",
    "message": "Change latency test to be more like new throughput tests.",
    "date": "2011-10-29T12:15:29Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/822c41f5485e235ae6bc3b1afa5c8808780ef680",
    "details": {
      "sha": "4ea507985dc4d48af5622565bbd3173cce411c69",
      "filename": "code/src/perf/com/lmax/disruptor/ThrottledOnePublisherToThreeProcessorPipelineLatencyTest.java",
      "status": "modified",
      "additions": 35,
      "deletions": 14,
      "changes": 49,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/822c41f5485e235ae6bc3b1afa5c8808780ef680/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FThrottledOnePublisherToThreeProcessorPipelineLatencyTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/822c41f5485e235ae6bc3b1afa5c8808780ef680/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FThrottledOnePublisherToThreeProcessorPipelineLatencyTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FThrottledOnePublisherToThreeProcessorPipelineLatencyTest.java?ref=822c41f5485e235ae6bc3b1afa5c8808780ef680",
      "patch": "@@ -169,30 +169,51 @@ public final class ThrottledOnePublisherToThreeProcessorPipelineLatencyTest\n     public void shouldCompareDisruptorVsQueues() throws Exception\n     {\n         final int RUNS = 3;\n-        final boolean runQueueTests = \"true\".equalsIgnoreCase(System.getProperty(\"com.lmax.runQueueTests\", \"true\"));\n+\n+        BigDecimal queueMeanLatency[] = new BigDecimal[RUNS];\n+        BigDecimal disruptorMeanLatency[] = new BigDecimal[RUNS];\n+\n+        if (\"true\".equalsIgnoreCase(System.getProperty(\"com.lmax.runQueueTests\", \"true\")))\n+        {\n+            for (int i = 0; i < RUNS; i++)\n+            {\n+                System.gc();\n+                histogram.clear();\n+\n+                runQueuePass();\n+\n+                assertThat(Long.valueOf(histogram.getCount()), is(Long.valueOf(ITERATIONS)));\n+                queueMeanLatency[i] = histogram.getMean();\n+\n+                System.out.format(\"%s run %d BlockingQueue %s\\n\", getClass().getSimpleName(), Long.valueOf(i), histogram);\n+                dumpHistogram(System.out);\n+            }\n+        }\n+        else\n+        {\n+            for (int i = 0; i < RUNS; i++)\n+            {\n+                queueMeanLatency[i] = new BigDecimal(Long.MAX_VALUE);\n+            }\n+        }\n \n         for (int i = 0; i < RUNS; i++)\n         {\n             System.gc();\n-\n             histogram.clear();\n+\n             runDisruptorPass();\n+\n             assertThat(Long.valueOf(histogram.getCount()), is(Long.valueOf(ITERATIONS)));\n-            final BigDecimal disruptorMeanLatency = histogram.getMean();\n+            disruptorMeanLatency[i] = histogram.getMean();\n+\n             System.out.format(\"%s run %d Disruptor %s\\n\", getClass().getSimpleName(), Long.valueOf(i), histogram);\n             dumpHistogram(System.out);\n+        }\n \n-            if (runQueueTests)\n-            {\n-                histogram.clear();\n-                runQueuePass();\n-                assertThat(Long.valueOf(histogram.getCount()), is(Long.valueOf(ITERATIONS)));\n-                final BigDecimal queueMeanLatency = histogram.getMean();\n-                System.out.format(\"%s run %d Queues %s\\n\", getClass().getSimpleName(), Long.valueOf(i), histogram);\n-                dumpHistogram(System.out);\n-\n-                assertTrue(queueMeanLatency.compareTo(disruptorMeanLatency) > 0);\n-            }\n+        for (int i = 0; i < RUNS; i++)\n+        {\n+            assertTrue(queueMeanLatency[i].compareTo(disruptorMeanLatency[i]) > 0);\n         }\n     }\n ",
      "parent_sha": "3e10f3b0197d813213ece69d716977b15b5a3a89"
    }
  },
  {
    "oid": "a7548f5fe6a03232fbc184e235db2d04f87bdb13",
    "message": "Rewrite SequenceBarrierTest in spirit of JUnit 5",
    "date": "2020-12-04T15:43:47Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/a7548f5fe6a03232fbc184e235db2d04f87bdb13",
    "details": {
      "sha": "a74891ac0dd6c879d506b97d84526f334f4b9839",
      "filename": "src/test/java/com/lmax/disruptor/SequenceBarrierTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/a7548f5fe6a03232fbc184e235db2d04f87bdb13/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSequenceBarrierTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/a7548f5fe6a03232fbc184e235db2d04f87bdb13/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSequenceBarrierTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSequenceBarrierTest.java?ref=a7548f5fe6a03232fbc184e235db2d04f87bdb13",
      "patch": "@@ -18,14 +18,14 @@\n import com.lmax.disruptor.support.DummyEventProcessor;\n import com.lmax.disruptor.support.StubEvent;\n import com.lmax.disruptor.util.Util;\n-import org.junit.Test;\n+import org.junit.jupiter.api.Test;\n \n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n \n import static com.lmax.disruptor.RingBuffer.createMultiProducer;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n \n \n public final class SequenceBarrierTest\n@@ -126,7 +126,7 @@ public void shouldInterruptDuringBusySpin() throws Exception\n         sequenceBarrier.alert();\n         t.join();\n \n-        assertTrue(\"Thread was not interrupted\", alerted[0]);\n+        assertTrue(alerted[0], \"Thread was not interrupted\");\n     }\n \n     @Test",
      "parent_sha": "613bc4a918c7189cb632f56c708db307088e5860"
    }
  },
  {
    "oid": "67462c1a22ad4ce028b28141fdd9bb4a0d087bca",
    "message": "Tighten up scope of suppressed warnings.",
    "date": "2011-09-16T08:15:55Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/67462c1a22ad4ce028b28141fdd9bb4a0d087bca",
    "details": {
      "sha": "f0de7368cd50c503b3718e3a1dbc825019c6f407",
      "filename": "code/src/perf/com/lmax/disruptor/OnePublisherToThreeProcessorMultiCastThroughputTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/67462c1a22ad4ce028b28141fdd9bb4a0d087bca/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FOnePublisherToThreeProcessorMultiCastThroughputTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/67462c1a22ad4ce028b28141fdd9bb4a0d087bca/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FOnePublisherToThreeProcessorMultiCastThroughputTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FOnePublisherToThreeProcessorMultiCastThroughputTest.java?ref=67462c1a22ad4ce028b28141fdd9bb4a0d087bca",
      "patch": "@@ -90,7 +90,6 @@\n  *\n  * </pre>\n  */\n-@SuppressWarnings(\"unchecked\")\n public final class OnePublisherToThreeProcessorMultiCastThroughputTest extends AbstractPerfTestQueueVsDisruptor\n {\n     private static final int NUM_EVENT_PROCESSORS = 3;\n@@ -110,6 +109,7 @@ public final class OnePublisherToThreeProcessorMultiCastThroughputTest extends A\n \n     ///////////////////////////////////////////////////////////////////////////////////////////////\n \n+    @SuppressWarnings(\"unchecked\")\n     private final ArrayBlockingQueue<Long>[] blockingQueues = new ArrayBlockingQueue[NUM_EVENT_PROCESSORS];\n     {\n         blockingQueues[0] = new ArrayBlockingQueue<Long>(SIZE);",
      "parent_sha": "f9b035bd8b032eb043a9e9da137a848b79c1b407"
    }
  },
  {
    "oid": "f8866cc1dd11dfd01aa7bb8fec0735d7d9cffc10",
    "message": "Do not allow a batch size greater than the ring buffer size.",
    "date": "2011-09-03T16:12:47Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/f8866cc1dd11dfd01aa7bb8fec0735d7d9cffc10",
    "details": {
      "sha": "2f38b3186a8812fa18584287108613702aea7049",
      "filename": "code/src/main/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/f8866cc1dd11dfd01aa7bb8fec0735d7d9cffc10/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/f8866cc1dd11dfd01aa7bb8fec0735d7d9cffc10/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=f8866cc1dd11dfd01aa7bb8fec0735d7d9cffc10",
      "patch": "@@ -140,7 +140,14 @@ public void publish(final long sequence)\n     @Override\n     public SequenceBatch nextSequenceBatch(final SequenceBatch sequenceBatch)\n     {\n-        final long sequence = claimStrategy.incrementAndGet(sequenceBatch.getSize());\n+        final int batchSize = sequenceBatch.getSize();\n+        if (batchSize > events.length)\n+        {\n+            final String msg = \"Batch size \" + batchSize + \" is greater than buffer size of \" + events.length;\n+            throw new IllegalArgumentException(msg);\n+        }\n+\n+        final long sequence = claimStrategy.incrementAndGet(batchSize);\n         sequenceBatch.setEnd(sequence);\n         claimStrategy.ensureSequencesAreInRange(sequence, sequencesToTrack);\n         return sequenceBatch;",
      "parent_sha": "d72a74f8c6788ee6dd4385983317afd59fe73fba"
    }
  },
  {
    "oid": "37920d6d711c3a6b075b8c3eddb2de3cc0418080",
    "message": "Javadoc",
    "date": "2011-05-01T20:44:50Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/37920d6d711c3a6b075b8c3eddb2de3cc0418080",
    "details": {
      "sha": "bfc25799b4b4763cb248fd0425fca6b8cfe9d8e2",
      "filename": "code/src/main/com/lmax/disruptor/EntryConsumer.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/37920d6d711c3a6b075b8c3eddb2de3cc0418080/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FEntryConsumer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/37920d6d711c3a6b075b8c3eddb2de3cc0418080/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FEntryConsumer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FEntryConsumer.java?ref=37920d6d711c3a6b075b8c3eddb2de3cc0418080",
      "patch": "@@ -21,7 +21,8 @@ public interface EntryConsumer<T extends  Entry> extends Runnable\n \n     /**\n      * Signal that this EntryConsumer should stop when it has finished consuming at the next clean break.\n-     * If thread is waiting on a {@link ThresholdBarrier} is it necessary to alert the thread to check status.\n+     * If thread is waiting on a {@link ThresholdBarrier} is it necessary to call {@link ThresholdBarrier#alert()}\n+     * to notify the thread to check status.\n      */\n     void halt();\n }",
      "parent_sha": "00826d4d4194fc8eb1b75eb2cd36b1ef0481fa7f"
    }
  },
  {
    "oid": "a9803666e018f756f3d3033f8f0573ab517abcb0",
    "message": "Yet another run at fixing the race condition around start.  Should now work for 3+ threads starting/halting, by ensuring exclusive access to the processEvents method.",
    "date": "2018-03-14T07:16:04Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/a9803666e018f756f3d3033f8f0573ab517abcb0",
    "details": {
      "sha": "0e175054019673433ffa44495a9dc0a537ee0bd8",
      "filename": "src/main/java/com/lmax/disruptor/BatchEventProcessor.java",
      "status": "modified",
      "additions": 68,
      "deletions": 44,
      "changes": 112,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/a9803666e018f756f3d3033f8f0573ab517abcb0/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FBatchEventProcessor.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/a9803666e018f756f3d3033f8f0573ab517abcb0/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FBatchEventProcessor.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FBatchEventProcessor.java?ref=a9803666e018f756f3d3033f8f0573ab517abcb0",
      "patch": "@@ -66,9 +66,9 @@ public BatchEventProcessor(\n         }\n \n         batchStartAware =\n-                (eventHandler instanceof BatchStartAware) ? (BatchStartAware) eventHandler : null;\n+            (eventHandler instanceof BatchStartAware) ? (BatchStartAware) eventHandler : null;\n         timeoutHandler =\n-                (eventHandler instanceof TimeoutHandler) ? (TimeoutHandler) eventHandler : null;\n+            (eventHandler instanceof TimeoutHandler) ? (TimeoutHandler) eventHandler : null;\n     }\n \n     @Override\n@@ -113,69 +113,93 @@ public void setExceptionHandler(final ExceptionHandler<? super T> exceptionHandl\n     @Override\n     public void run()\n     {\n-        if (!running.compareAndSet(IDLE, RUNNING))\n+        if (running.compareAndSet(IDLE, RUNNING))\n         {\n-            if (running.get() == RUNNING)\n+            sequenceBarrier.clearAlert();\n+\n+            notifyStart();\n+            try\n             {\n-                throw new IllegalStateException(\"Thread is already running\");\n+                if (running.get() == RUNNING)\n+                {\n+                    processEvents();\n+                }\n+            }\n+            finally\n+            {\n+                notifyShutdown();\n+                running.set(IDLE);\n             }\n         }\n-        sequenceBarrier.clearAlert();\n-\n-        notifyStart();\n-\n-        try\n+        else\n         {\n-            if (running.get() == HALTED)\n+            // This is a little bit of guess work.  The running state could of changed to HALTED by\n+            // this point.  However, Java does not have compareAndExchange which is the only way\n+            // to get it exactly correct.\n+            if (running.get() == RUNNING)\n+            {\n+                throw new IllegalStateException(\"Thread is already running\");\n+            }\n+            else\n             {\n-                return;\n+                earlyExit();\n             }\n+        }\n+    }\n \n-            T event = null;\n-            long nextSequence = sequence.get() + 1L;\n+    private void processEvents()\n+    {\n+        T event = null;\n+        long nextSequence = sequence.get() + 1L;\n \n-            while (true)\n+        while (true)\n+        {\n+            try\n             {\n-                try\n+                final long availableSequence = sequenceBarrier.waitFor(nextSequence);\n+                if (batchStartAware != null)\n                 {\n-                    final long availableSequence = sequenceBarrier.waitFor(nextSequence);\n-                    if (batchStartAware != null)\n-                    {\n-                        batchStartAware.onBatchStart(availableSequence - nextSequence + 1);\n-                    }\n-\n-                    while (nextSequence <= availableSequence)\n-                    {\n-                        event = dataProvider.get(nextSequence);\n-                        eventHandler.onEvent(event, nextSequence, nextSequence == availableSequence);\n-                        nextSequence++;\n-                    }\n-\n-                    sequence.set(availableSequence);\n+                    batchStartAware.onBatchStart(availableSequence - nextSequence + 1);\n                 }\n-                catch (final TimeoutException e)\n-                {\n-                    notifyTimeout(sequence.get());\n-                }\n-                catch (final AlertException ex)\n+\n+                while (nextSequence <= availableSequence)\n                 {\n-                    if (running.get() != RUNNING)\n-                    {\n-                        break;\n-                    }\n+                    event = dataProvider.get(nextSequence);\n+                    eventHandler.onEvent(event, nextSequence, nextSequence == availableSequence);\n+                    nextSequence++;\n                 }\n-                catch (final Throwable ex)\n+\n+                sequence.set(availableSequence);\n+            }\n+            catch (final TimeoutException e)\n+            {\n+                notifyTimeout(sequence.get());\n+            }\n+            catch (final AlertException ex)\n+            {\n+                if (running.get() != RUNNING)\n                 {\n-                    exceptionHandler.handleEventException(ex, nextSequence, event);\n-                    sequence.set(nextSequence);\n-                    nextSequence++;\n+                    break;\n                 }\n             }\n+            catch (final Throwable ex)\n+            {\n+                exceptionHandler.handleEventException(ex, nextSequence, event);\n+                sequence.set(nextSequence);\n+                nextSequence++;\n+            }\n+        }\n+    }\n+\n+    private void earlyExit()\n+    {\n+        try\n+        {\n+            notifyStart();\n         }\n         finally\n         {\n             notifyShutdown();\n-            running.set(IDLE);\n         }\n     }\n ",
      "parent_sha": "0873e30e6a84dc691096e5c560fcf86b3597a359"
    }
  },
  {
    "oid": "4574ea2f4d6368b83c3e99ce62a883b7c86e6e02",
    "message": "Small formatting changes.",
    "date": "2015-05-14T21:32:38Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/4574ea2f4d6368b83c3e99ce62a883b7c86e6e02",
    "details": {
      "sha": "60dbe95a2371be935d3d14a3a59e6969ce66759a",
      "filename": "src/test/java/com/lmax/disruptor/example/PullWithBatchedPoller.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/4574ea2f4d6368b83c3e99ce62a883b7c86e6e02/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fexample%2FPullWithBatchedPoller.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/4574ea2f4d6368b83c3e99ce62a883b7c86e6e02/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fexample%2FPullWithBatchedPoller.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fexample%2FPullWithBatchedPoller.java?ref=4574ea2f4d6368b83c3e99ce62a883b7c86e6e02",
      "patch": "@@ -59,9 +59,8 @@ public T poll() throws Exception\n     }\n \n     private EventPoller.PollState loadNextValues(EventPoller<BatchedPoller.DataEvent<T>> poller, final BatchedData<T> batch)\n-                                                                                                              throws Exception\n+            throws Exception\n     {\n-\n         return poller.poll(new EventPoller.Handler<BatchedPoller.DataEvent<T>>()\n         {\n             @Override",
      "parent_sha": "c3c5df82be6d739ea82b9fa7e63d05af5f2d713a"
    }
  },
  {
    "oid": "1a0379dd576974e658da41bb2c3c0f1258aee822",
    "message": "close #233\n\nuse 128 instead of (BUFFER_PAD << REF_ELEMENT_SHIFT)",
    "date": "2018-12-17T09:17:13Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/1a0379dd576974e658da41bb2c3c0f1258aee822",
    "details": {
      "sha": "5913e09aa56b4ca72418a689acd567a5ceae3df6",
      "filename": "src/main/java/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/1a0379dd576974e658da41bb2c3c0f1258aee822/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/1a0379dd576974e658da41bb2c3c0f1258aee822/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=1a0379dd576974e658da41bb2c3c0f1258aee822",
      "patch": "@@ -50,7 +50,7 @@ else if (8 == scale)\n         }\n         BUFFER_PAD = 128 / scale;\n         // Including the buffer pad in the array base offset\n-        REF_ARRAY_BASE = UNSAFE.arrayBaseOffset(Object[].class) + (BUFFER_PAD << REF_ELEMENT_SHIFT);\n+        REF_ARRAY_BASE = UNSAFE.arrayBaseOffset(Object[].class) + 128;\n     }\n \n     private final long indexMask;",
      "parent_sha": "0f3f827d937b65f7fbeef137b9f21713b59dc6b4"
    }
  },
  {
    "oid": "b8b72f398eb742a5f2f44c9099be2c6906ebf230",
    "message": "Remove use of Optional form benchmark",
    "date": "2021-01-16T10:01:50Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/b8b72f398eb742a5f2f44c9099be2c6906ebf230",
    "details": {
      "sha": "9bb2a77015704ff69946b0d22b4985d735d52c55",
      "filename": "src/jmh/java/com/lmax/disruptor/SequenceBenchmark.java",
      "status": "modified",
      "additions": 9,
      "deletions": 10,
      "changes": 19,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/b8b72f398eb742a5f2f44c9099be2c6906ebf230/src%2Fjmh%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSequenceBenchmark.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/b8b72f398eb742a5f2f44c9099be2c6906ebf230/src%2Fjmh%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSequenceBenchmark.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fjmh%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSequenceBenchmark.java?ref=b8b72f398eb742a5f2f44c9099be2c6906ebf230",
      "patch": "@@ -24,8 +24,8 @@\n import org.openjdk.jmh.runner.options.Options;\n import org.openjdk.jmh.runner.options.OptionsBuilder;\n \n+import java.util.Collections;\n import java.util.List;\n-import java.util.Optional;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n@@ -39,9 +39,8 @@\n public class SequenceBenchmark\n {\n     // To run this on a tuned system with benchmark threads pinned to isolated cpus:\n-    // Put a list of cpu ids in the field below, e.g. Optional.of(Arrays.asList(38, 40, 42, 44, 46))\n-    @SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\")\n-    private static final Optional<List<Integer>> ISOLATED_CPUS = Optional.empty();\n+    // Put a list of cpu ids in the field below, e.g. Arrays.asList(38, 40, 42, 44, 46)\n+    private static final List<Integer> ISOLATED_CPUS = Collections.emptyList();\n \n     private static final AtomicInteger THREAD_COUNTER = new AtomicInteger();\n \n@@ -54,31 +53,31 @@ public static class ThreadPinningState\n         @Setup\n         public void setup()\n         {\n-            ISOLATED_CPUS.ifPresent(isolcpus ->\n+            if (ISOLATED_CPUS.size() > 0)\n             {\n-                if (threadId > isolcpus.size())\n+                if (threadId > ISOLATED_CPUS.size())\n                 {\n                     throw new IllegalArgumentException(\n                             String.format(\"Benchmark uses at least %d threads, only defined %d isolated cpus\",\n                                     threadId,\n-                                    isolcpus.size()\n+                                    ISOLATED_CPUS.size()\n                             ));\n                 }\n \n-                final Integer cpuId = isolcpus.get(threadId);\n+                final Integer cpuId = ISOLATED_CPUS.get(threadId);\n                 affinityLock = AffinityLock.acquireLock(cpuId);\n                 System.out.printf(\"Attempted to set thread affinity for %s to %d, success = %b%n\",\n                         Thread.currentThread().getName(),\n                         cpuId,\n                         affinityLock.isAllocated()\n                 );\n-            });\n+            }\n         }\n \n         @TearDown\n         public void teardown()\n         {\n-            if (ISOLATED_CPUS.isPresent())\n+            if (ISOLATED_CPUS.size() > 0)\n             {\n                 affinityLock.release();\n             }",
      "parent_sha": "341fd196151e45ed7e81aa5ee758007f571869a1"
    }
  },
  {
    "oid": "a93d89f0d9171b601726ccd4954a5108bd159175",
    "message": "Fix javadoc",
    "date": "2013-04-16T09:27:38Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/a93d89f0d9171b601726ccd4954a5108bd159175",
    "details": {
      "sha": "e258f85136c75a1a0f8301e83261fb6a04fcd9fe",
      "filename": "src/main/java/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 10,
      "deletions": 7,
      "changes": 17,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/a93d89f0d9171b601726ccd4954a5108bd159175/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/a93d89f0d9171b601726ccd4954a5108bd159175/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=a93d89f0d9171b601726ccd4954a5108bd159175",
      "patch": "@@ -152,16 +152,19 @@ public static <E> RingBuffer<E> create(ProducerType    producerType,\n     }\n \n     /**\n-     * <p>Get the event for a given sequence in the RingBuffer.  This method will wait until the\n-     * value is published before returning.  This method should only be used by {@link EventProcessor}s\n-     * that are reading values out of the ring buffer.  Publishing code should use the \n-     * {@link RingBuffer#get(long)} call to get a handle onto the preallocated event.\n+     * <p>Get the event for a given sequence in the RingBuffer.</p>\n      * \n-     * <p>The call implements the appropriate load fence to ensure that the data within the event\n-     * is visible after this call completes.\n+     * <p>This call has 2 uses.  Firstly use this call when publishing to a ring buffer.\n+     * After calling {@link RingBuffer#next()} use this call to get hold of the\n+     * preallocated event to fill with data before calling {@link RingBuffer#publish(long)}.</p>\n+     * \n+     * <p>Secondly use this call when consuming data from the ring buffer.  After calling\n+     * {@link SequenceBarrier#waitFor(long)} call this method with any value greater than\n+     * that your current consumer sequence and less than or equal to the value returned from\n+     * the {@link SequenceBarrier#waitFor(long)} method.</p>\n      *\n      * @param sequence for the event\n-     * @return the event that visibily published by the producer\n+     * @return the event for the given sequence\n      */\n     @SuppressWarnings(\"unchecked\")\n     public E get(long sequence)",
      "parent_sha": "e00c79a9c58ac2107de7083058ab733864a30dd8"
    }
  },
  {
    "oid": "f88dedadba4d99a902790665396216305201cf14",
    "message": "only memory barrier pending publications at end of batch.",
    "date": "2011-10-29T16:15:35Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/f88dedadba4d99a902790665396216305201cf14",
    "details": {
      "sha": "d226cf30276406d4f6b8e1db09f3e51c1b972fca",
      "filename": "code/src/main/com/lmax/disruptor/ClaimStrategy.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/f88dedadba4d99a902790665396216305201cf14/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FClaimStrategy.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/f88dedadba4d99a902790665396216305201cf14/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FClaimStrategy.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FClaimStrategy.java?ref=f88dedadba4d99a902790665396216305201cf14",
      "patch": "@@ -203,10 +203,12 @@ public void serialisePublishing(final long sequence, final Sequence cursor, fina\n             }\n             else\n             {\n-                for (long i = expectedSequence + 1; i <= sequence; i++)\n+                for (long i = expectedSequence + 1; i < sequence; i++)\n                 {\n-                    pendingPublications.set((int)i & indexMask, i);\n+                    pendingPublications.lazySet((int)i & indexMask, i);\n                 }\n+\n+                pendingPublications.set((int)sequence & indexMask, sequence);\n             }\n \n             if (csLock.compareAndSet(0L, 1L))",
      "parent_sha": "822c41f5485e235ae6bc3b1afa5c8808780ef680"
    }
  },
  {
    "oid": "346ad6df8d8bfc69a3560b68e0e5f4d72238208e",
    "message": "Fix a broken rename/refactoring",
    "date": "2013-04-16T00:41:09Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/346ad6df8d8bfc69a3560b68e0e5f4d72238208e",
    "details": {
      "sha": "6d653b105e2ded64cd8a7525cf0808884ad591af",
      "filename": "src/main/java/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/346ad6df8d8bfc69a3560b68e0e5f4d72238208e/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/346ad6df8d8bfc69a3560b68e0e5f4d72238208e/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=346ad6df8d8bfc69a3560b68e0e5f4d72238208e",
      "patch": "@@ -255,7 +255,7 @@ public void resetTo(long sequence)\n      * @param sequence The sequence to claim.\n      * @return The preallocated event.\n      */\n-    public E claimAndget(long sequence)\n+    public E claimAndGetPreallocated(long sequence)\n     {\n         sequencer.claim(sequence);\n         return get(sequence);",
      "parent_sha": "06fc05a8b9c8c240b2aaa05a0d627e6270e6a31c"
    }
  },
  {
    "oid": "62f32aa13d7ea832bcd53a0ee29c156c65091e43",
    "message": "Inline cache fields and pre/post pad",
    "date": "2014-06-02T15:20:27Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/62f32aa13d7ea832bcd53a0ee29c156c65091e43",
    "details": {
      "sha": "ab649ec5b1142c4c5fdcc3c8748f4082fc6bd230",
      "filename": "src/main/java/com/lmax/disruptor/SingleProducerSequencer.java",
      "status": "modified",
      "additions": 31,
      "deletions": 19,
      "changes": 50,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/62f32aa13d7ea832bcd53a0ee29c156c65091e43/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSingleProducerSequencer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/62f32aa13d7ea832bcd53a0ee29c156c65091e43/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSingleProducerSequencer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSingleProducerSequencer.java?ref=62f32aa13d7ea832bcd53a0ee29c156c65091e43",
      "patch": "@@ -19,22 +19,34 @@\n \n import com.lmax.disruptor.util.Util;\n \n+abstract class SingleProducerSequencerPad extends AbstractSequencer\n+{\n+    protected long p1, p2, p3, p4, p5, p6, p7;\n+    public SingleProducerSequencerPad(int bufferSize, WaitStrategy waitStrategy)\n+    {\n+        super(bufferSize, waitStrategy);\n+    }\n+}\n+abstract class SingleProducerSequencerFields extends SingleProducerSequencerPad\n+{\n+    public SingleProducerSequencerFields(int bufferSize, WaitStrategy waitStrategy)\n+    {\n+        super(bufferSize, waitStrategy);\n+    }\n \n+    /** Set to -1 as sequence starting point */\n+    protected long nextValue = Sequence.INITIAL_VALUE;\n+    protected long cachedValue = Sequence.INITIAL_VALUE;\n+}\n /**\n  * <p>Coordinator for claiming sequences for access to a data structure while tracking dependent {@link Sequence}s.<p>\n  *\n  * <p>Generally not safe for use from multiple threads as it does not implement any barriers.</p>\n  */\n-public final class SingleProducerSequencer extends AbstractSequencer\n-{\n-    @SuppressWarnings(\"unused\")\n-    private static class Padding\n-    {\n-        /** Set to -1 as sequence starting point */\n-        public long nextValue = Sequence.INITIAL_VALUE, cachedValue = Sequence.INITIAL_VALUE, p2, p3, p4, p5, p6, p7;\n-    }\n \n-    private final Padding pad = new Padding();\n+public final class SingleProducerSequencer extends SingleProducerSequencerFields\n+{\n+    protected long p1, p2, p3, p4, p5, p6, p7;\n \n     /**\n      * Construct a Sequencer with the selected wait strategy and buffer size.\n@@ -53,15 +65,15 @@ public SingleProducerSequencer(int bufferSize, final WaitStrategy waitStrategy)\n     @Override\n     public boolean hasAvailableCapacity(final int requiredCapacity)\n     {\n-        long nextValue = pad.nextValue;\n+        long nextValue = this.nextValue;\n \n         long wrapPoint = (nextValue + requiredCapacity) - bufferSize;\n-        long cachedGatingSequence = pad.cachedValue;\n+        long cachedGatingSequence = this.cachedValue;\n \n         if (wrapPoint > cachedGatingSequence || cachedGatingSequence > nextValue)\n         {\n             long minSequence = Util.getMinimumSequence(gatingSequences, nextValue);\n-            pad.cachedValue = minSequence;\n+            this.cachedValue = minSequence;\n \n             if (wrapPoint > minSequence)\n             {\n@@ -92,11 +104,11 @@ public long next(int n)\n             throw new IllegalArgumentException(\"n must be > 0\");\n         }\n \n-        long nextValue = pad.nextValue;\n+        long nextValue = this.nextValue;\n \n         long nextSequence = nextValue + n;\n         long wrapPoint = nextSequence - bufferSize;\n-        long cachedGatingSequence = pad.cachedValue;\n+        long cachedGatingSequence = this.cachedValue;\n \n         if (wrapPoint > cachedGatingSequence || cachedGatingSequence > nextValue)\n         {\n@@ -106,10 +118,10 @@ public long next(int n)\n                 LockSupport.parkNanos(1L); // TODO: Use waitStrategy to spin?\n             }\n \n-            pad.cachedValue = minSequence;\n+            this.cachedValue = minSequence;\n         }\n \n-        pad.nextValue = nextSequence;\n+        this.nextValue = nextSequence;\n \n         return nextSequence;\n     }\n@@ -139,7 +151,7 @@ public long tryNext(int n) throws InsufficientCapacityException\n             throw InsufficientCapacityException.INSTANCE;\n         }\n \n-        long nextSequence = pad.nextValue += n;\n+        long nextSequence = this.nextValue += n;\n \n         return nextSequence;\n     }\n@@ -150,7 +162,7 @@ public long tryNext(int n) throws InsufficientCapacityException\n     @Override\n     public long remainingCapacity()\n     {\n-        long nextValue = pad.nextValue;\n+        long nextValue = this.nextValue;\n \n         long consumed = Util.getMinimumSequence(gatingSequences, nextValue);\n         long produced = nextValue;\n@@ -163,7 +175,7 @@ public long remainingCapacity()\n     @Override\n     public void claim(long sequence)\n     {\n-        pad.nextValue = sequence;\n+        this.nextValue = sequence;\n     }\n \n     /**",
      "parent_sha": "7ec1acbcbd1c9c194875d5ee86981d0743423f4a"
    }
  },
  {
    "oid": "766bb3fe55cd9155159f911c14b0bbf7de1e0504",
    "message": "Removed synchronized from fillInStackTrace",
    "date": "2011-04-27T12:34:07Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/766bb3fe55cd9155159f911c14b0bbf7de1e0504",
    "details": {
      "sha": "f3001ee6ec379395797c96e585d31fc6168f0631",
      "filename": "code/src/main/com/lmax/disruptor/AlertException.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/766bb3fe55cd9155159f911c14b0bbf7de1e0504/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FAlertException.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/766bb3fe55cd9155159f911c14b0bbf7de1e0504/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FAlertException.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FAlertException.java?ref=766bb3fe55cd9155159f911c14b0bbf7de1e0504",
      "patch": "@@ -14,7 +14,7 @@ public class AlertException extends Exception\n      * @return this instance.\n      */\n     @Override\n-    public synchronized Throwable fillInStackTrace()\n+    public Throwable fillInStackTrace()\n     {\n         return this;\n     }",
      "parent_sha": "42d6c2920ff2385582fc7ae3df0fd0f940125cca"
    }
  },
  {
    "oid": "3e10f3b0197d813213ece69d716977b15b5a3a89",
    "message": "Set rather than lazySet pending publications.",
    "date": "2011-10-29T11:29:17Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/3e10f3b0197d813213ece69d716977b15b5a3a89",
    "details": {
      "sha": "1ca5ee5953a3cdee54ddd2108c67a0b217562010",
      "filename": "code/src/main/com/lmax/disruptor/ClaimStrategy.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/3e10f3b0197d813213ece69d716977b15b5a3a89/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FClaimStrategy.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/3e10f3b0197d813213ece69d716977b15b5a3a89/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FClaimStrategy.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FClaimStrategy.java?ref=3e10f3b0197d813213ece69d716977b15b5a3a89",
      "patch": "@@ -205,7 +205,7 @@ public void serialisePublishing(final long sequence, final Sequence cursor, fina\n             {\n                 for (long i = expectedSequence + 1; i <= sequence; i++)\n                 {\n-                    pendingPublications.lazySet((int)i & indexMask, i);\n+                    pendingPublications.set((int)i & indexMask, i);\n                 }\n             }\n ",
      "parent_sha": "324bff58c92e0b57d49d5114048da473d090389d"
    }
  },
  {
    "oid": "42d6c2920ff2385582fc7ae3df0fd0f940125cca",
    "message": "Added javadoc",
    "date": "2011-04-27T08:39:05Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/42d6c2920ff2385582fc7ae3df0fd0f940125cca",
    "details": {
      "sha": "1322a56ba07ca119a313d2758268064cf180b629",
      "filename": "code/src/main/com/lmax/disruptor/SlotClaimStrategy.java",
      "status": "modified",
      "additions": 18,
      "deletions": 1,
      "changes": 19,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/42d6c2920ff2385582fc7ae3df0fd0f940125cca/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FSlotClaimStrategy.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/42d6c2920ff2385582fc7ae3df0fd0f940125cca/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FSlotClaimStrategy.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FSlotClaimStrategy.java?ref=42d6c2920ff2385582fc7ae3df0fd0f940125cca",
      "patch": "@@ -1,7 +1,24 @@\n package com.lmax.disruptor;\n \n-public interface SlotClaimStrategy\n+/**\n+ * Implementations of this strategy can handled the necessary threading requirements\n+ * for claiming slots in the {@link RingBuffer}.\n+ *\n+ * The slot index is a the sequence value mod the {@link RingBuffer} capacity.\n+ */\n+interface SlotClaimStrategy\n {\n+    /**\n+     * Claim the next sequence index in the {@link RingBuffer} and increment.\n+     *\n+     * @return the slot index to be used for the producer.\n+     */\n     long getAndIncrement();\n+\n+    /**\n+     * Set the current sequence value for claiming slots in the {@link RingBuffer}\n+     *\n+     * @param sequence to be set as the current value.\n+     */\n     void setSequence(long sequence);\n }",
      "parent_sha": "53aecff922129476818b7b9e799d057c417dac8b"
    }
  },
  {
    "oid": "47cc109d3939b19c725fe27213cf67c63a3dfd5f",
    "message": "Use Math.min instead of ternary expression",
    "date": "2013-01-13T21:59:28Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/47cc109d3939b19c725fe27213cf67c63a3dfd5f",
    "details": {
      "sha": "e1336d5d365a5fe556ef33d54f012b13c17ad1c7",
      "filename": "src/main/java/com/lmax/disruptor/util/Util.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/47cc109d3939b19c725fe27213cf67c63a3dfd5f/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Futil%2FUtil.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/47cc109d3939b19c725fe27213cf67c63a3dfd5f/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Futil%2FUtil.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Futil%2FUtil.java?ref=47cc109d3939b19c725fe27213cf67c63a3dfd5f",
      "patch": "@@ -67,7 +67,7 @@ public static long getMinimumSequence(final Sequence[] sequences, long minimum)\n         for (int i = 0, n = sequences.length; i < n; i++)\n         {\n             long value = sequences[i].get();\n-            minimum = minimum < value ? minimum : value;\n+            minimum = Math.min(minimum, value);\n         }\n \n         return minimum;",
      "parent_sha": "c7130366be747d02f7f5ab42f81df63670d27050"
    }
  },
  {
    "oid": "d39d7eda50b4794868793064494896c7b18fd578",
    "message": "Factored out sequence to be like non-batch case.",
    "date": "2011-07-09T15:17:04Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/d39d7eda50b4794868793064494896c7b18fd578",
    "details": {
      "sha": "5fbde4cc7ad0cdb7c7fa938c87475b46c29a8548",
      "filename": "code/src/perf/com/lmax/disruptor/UniCast1P1CBatchPerfTest.java",
      "status": "modified",
      "additions": 3,
      "deletions": 5,
      "changes": 8,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/d39d7eda50b4794868793064494896c7b18fd578/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FUniCast1P1CBatchPerfTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/d39d7eda50b4794868793064494896c7b18fd578/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FUniCast1P1CBatchPerfTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FUniCast1P1CBatchPerfTest.java?ref=d39d7eda50b4794868793064494896c7b18fd578",
      "patch": "@@ -70,7 +70,7 @@\n public final class UniCast1P1CBatchPerfTest extends AbstractPerfTestQueueVsDisruptor\n {\n     private static final int SIZE = 1024 * 32;\n-    private static final long ITERATIONS = 1000L * 1000L * 500L;\n+    private static final long ITERATIONS = 1000L * 1000L * 50L;\n     private final ExecutorService EXECUTOR = Executors.newSingleThreadExecutor();\n \n     private final long expectedResult;\n@@ -148,17 +148,15 @@ protected long runDisruptorPass(final int passNumber) throws InterruptedExceptio\n \n         long start = System.currentTimeMillis();\n \n+        long offset = 0;\n         for (long i = 0; i < ITERATIONS; i += batchSize)\n         {\n             producerBarrier.nextEntries(sequenceBatch);\n-\n-            int offset = 0;\n             for (long c = sequenceBatch.getStart(), end = sequenceBatch.getEnd(); c <= end; c++)\n             {\n                 ValueEntry entry = producerBarrier.getEntry(c);\n-                entry.setValue(i + offset++);\n+                entry.setValue(offset++);\n             }\n-\n             producerBarrier.commit(sequenceBatch);\n         }\n ",
      "parent_sha": "7135ac6e9727d32ee6d018657e62ed9619ff34a1"
    }
  },
  {
    "oid": "3055f3c248a7ef99e1eeb69107eb0ab91896e87b",
    "message": "Add a better test for tryNext()",
    "date": "2013-01-01T20:02:23Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/3055f3c248a7ef99e1eeb69107eb0ab91896e87b",
    "details": {
      "sha": "fe208effbba9690d7da6cf55717a0ac215d0b1fd",
      "filename": "src/test/java/com/lmax/disruptor/RingBufferTest.java",
      "status": "modified",
      "additions": 19,
      "deletions": 5,
      "changes": 24,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/3055f3c248a7ef99e1eeb69107eb0ab91896e87b/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBufferTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/3055f3c248a7ef99e1eeb69107eb0ab91896e87b/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBufferTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBufferTest.java?ref=3055f3c248a7ef99e1eeb69107eb0ab91896e87b",
      "patch": "@@ -139,17 +139,31 @@ public void shouldPreventWrapping() throws Exception\n         assertFalse(ringBuffer.tryPublishEvent(StubEvent.TRANSLATOR, 1, 3, \"3\"));\n     }\n     \n-    @Test(expected = InsufficientCapacityException.class)\n+    @Test\n     public void shouldThrowExceptionIfBufferIsFull() throws Exception\n     {\n-        ringBuffer.addGatingSequences(new Sequence(-1));\n+        ringBuffer.addGatingSequences(new Sequence(ringBuffer.getBufferSize()));\n         \n-        for (int i = 0; i < ringBuffer.getBufferSize(); i++)\n+        try\n         {\n-            ringBuffer.publish(ringBuffer.next());\n+            for (int i = 0; i < ringBuffer.getBufferSize(); i++)\n+            {\n+                ringBuffer.publish(ringBuffer.tryNext());\n+            }\n+        }\n+        catch (Exception e)\n+        {\n+            fail(\"Should not of thrown exception\");\n         }\n         \n-        ringBuffer.tryNext();\n+        try\n+        {   \n+            ringBuffer.tryNext();\n+            fail(\"Exception should have been thrown\");\n+        }\n+        catch (InsufficientCapacityException e)\n+        {\n+        }\n     }\n \n     @Test",
      "parent_sha": "eeb86ae808074caf35715b1cacb3dc9398f584cd"
    }
  },
  {
    "oid": "9d204e93ed3bf05b4216e10d11d157d2a91bb82a",
    "message": "Rewrite TimeoutBlockingWaitStrategyTest in spirit of JUnit 5",
    "date": "2020-12-04T16:37:04Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/9d204e93ed3bf05b4216e10d11d157d2a91bb82a",
    "details": {
      "sha": "8c3d97edbf7174734eee7c8155addb40cdf8d6ec",
      "filename": "src/test/java/com/lmax/disruptor/TimeoutBlockingWaitStrategyTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/9d204e93ed3bf05b4216e10d11d157d2a91bb82a/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FTimeoutBlockingWaitStrategyTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/9d204e93ed3bf05b4216e10d11d157d2a91bb82a/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FTimeoutBlockingWaitStrategyTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FTimeoutBlockingWaitStrategyTest.java?ref=9d204e93ed3bf05b4216e10d11d157d2a91bb82a",
      "patch": "@@ -1,12 +1,13 @@\n package com.lmax.disruptor;\n \n import com.lmax.disruptor.support.DummySequenceBarrier;\n-import org.junit.Test;\n+import org.junit.jupiter.api.Test;\n \n import java.util.concurrent.TimeUnit;\n \n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n \n public class TimeoutBlockingWaitStrategyTest\n {",
      "parent_sha": "812b134bd44550a723353ce147492ec2a83462b3"
    }
  },
  {
    "oid": "2b1fd1ef6a30850a1f55ceed52277d73bef5eb4b",
    "message": "Rename of availableCapacity to requiredCapacity to reflect that the parameter is a statement of what is required.",
    "date": "2012-05-24T07:31:02Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/2b1fd1ef6a30850a1f55ceed52277d73bef5eb4b",
    "details": {
      "sha": "063a069ce341dd330616d1ce2495d14cfdeff804",
      "filename": "code/src/main/com/lmax/disruptor/Sequencer.java",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/2b1fd1ef6a30850a1f55ceed52277d73bef5eb4b/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FSequencer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/2b1fd1ef6a30850a1f55ceed52277d73bef5eb4b/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FSequencer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FSequencer.java?ref=2b1fd1ef6a30850a1f55ceed52277d73bef5eb4b",
      "patch": "@@ -129,26 +129,26 @@ public long next()\n     \n     /**\n      * Attempt to claim the next event in sequence for publishing.  Will return the\n-     * number of the slot if there is at least <code>availableCapacity</code> slots\n+     * number of the slot if there is at least <code>requiredCapacity</code> slots\n      * available.  \n      * \n-     * @param availableCapacity\n+     * @param requiredCapacity as slots in the data structure\n      * @return the claimed sequence value\n-     * @throws InsufficientCapacityException\n+     * @throws InsufficientCapacityException when the requiredCapacity is not available\n      */\n-    public long tryNext(int availableCapacity) throws InsufficientCapacityException\n+    public long tryNext(int requiredCapacity) throws InsufficientCapacityException\n     {\n         if (null == gatingSequences)\n         {\n             throw new NullPointerException(\"gatingSequences must be set before claiming sequences\");\n         }\n         \n-        if (availableCapacity < 1)\n+        if (requiredCapacity < 1)\n         {\n-            throw new IllegalArgumentException(\"Available capacity must be greater than 0\");\n+            throw new IllegalArgumentException(\"Required capacity must be greater than 0\");\n         }\n         \n-        return claimStrategy.checkAndIncrement(availableCapacity, 1, gatingSequences);\n+        return claimStrategy.checkAndIncrement(requiredCapacity, 1, gatingSequences);\n     }\n \n     /**",
      "parent_sha": "38a551d34471271faf0447ec061ce7a9d36b06b6"
    }
  },
  {
    "oid": "f14631552c9affea2ac487166f2f47255ddef8fa",
    "message": "Javadoc",
    "date": "2011-09-06T12:10:04Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/f14631552c9affea2ac487166f2f47255ddef8fa",
    "details": {
      "sha": "02c218e6e50c0c0caff0bf427e9fbe189856d962",
      "filename": "code/src/main/com/lmax/disruptor/Sequencer.java",
      "status": "modified",
      "additions": 36,
      "deletions": 19,
      "changes": 55,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/f14631552c9affea2ac487166f2f47255ddef8fa/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FSequencer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/f14631552c9affea2ac487166f2f47255ddef8fa/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FSequencer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FSequencer.java?ref=f14631552c9affea2ac487166f2f47255ddef8fa",
      "patch": "@@ -92,7 +92,8 @@ public long getCursor()\n     }\n \n     /**\n-     * Has the buffer got capacity to allocate another sequence.\n+     * Has the buffer got capacity to allocate another sequence.  This is a concurrent\n+     * method so the response should only be taken as an indication of available capacity.\n      *\n      * @return true if the buffer has the capacity to allocate the next sequence otherwise false.\n      */\n@@ -108,20 +109,16 @@ public boolean hasAvailableCapacity()\n      */\n     public long next()\n     {\n+        if (null == gatingSequences)\n+        {\n+            throw new NullPointerException(\"gatingSequences must be set before claim sequences\");\n+        }\n+\n         final long sequence = claimStrategy.incrementAndGet();\n         claimStrategy.ensureCapacity(sequence, gatingSequences);\n         return sequence;\n     }\n \n-    /**\n-     * Publish an event and make it visible to {@link EventProcessor}s\n-     * @param sequence to be published\n-     */\n-    public void publish(final long sequence)\n-    {\n-        publish(sequence, 1);\n-    }\n-\n     /**\n      * Claim the next batch sequence numbers for publishing.\n      *\n@@ -130,6 +127,11 @@ public void publish(final long sequence)\n      */\n     public SequenceBatch next(final SequenceBatch sequenceBatch)\n     {\n+        if (null == gatingSequences)\n+        {\n+            throw new NullPointerException(\"gatingSequences must be set before claim sequences\");\n+        }\n+\n         final int batchSize = sequenceBatch.getSize();\n         if (batchSize > bufferSize)\n         {\n@@ -144,24 +146,39 @@ public SequenceBatch next(final SequenceBatch sequenceBatch)\n     }\n \n     /**\n-     * Publish the batch of events in sequence.\n+     * Claim a specific sequence when only one publisher is involved.\n      *\n-     * @param sequenceBatch to be published.\n+     * @param sequence to be claimed.\n      */\n-    public void publish(final SequenceBatch sequenceBatch)\n+    public void claim(final long sequence)\n     {\n-        publish(sequenceBatch.getEnd(), sequenceBatch.getSize());\n+        if (null == gatingSequences)\n+        {\n+            throw new NullPointerException(\"gatingSequences must be set before claim sequences\");\n+        }\n+\n+        claimStrategy.setSequence(sequence);\n+        claimStrategy.ensureCapacity(sequence, gatingSequences);\n     }\n \n     /**\n-     * Claim a specific sequence when only one publisher is involved.\n+     * Publish an event and make it visible to {@link EventProcessor}s\n      *\n-     * @param sequence to be claimed.\n+     * @param sequence to be published\n      */\n-    public void claim(final long sequence)\n+    public void publish(final long sequence)\n     {\n-        claimStrategy.setSequence(sequence);\n-        claimStrategy.ensureCapacity(sequence, gatingSequences);\n+        publish(sequence, 1);\n+    }\n+\n+    /**\n+     * Publish the batch of events in sequence.\n+     *\n+     * @param sequenceBatch to be published.\n+     */\n+    public void publish(final SequenceBatch sequenceBatch)\n+    {\n+        publish(sequenceBatch.getEnd(), sequenceBatch.getSize());\n     }\n \n     /**",
      "parent_sha": "45a1dd248a482a255f0dd2c4866333d62c009400"
    }
  },
  {
    "oid": "6105d201ce71f2dd59314a3f19c284729e69aab6",
    "message": "Tidy up RewindBatchEventProcessorTest",
    "date": "2023-04-27T12:09:32Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/6105d201ce71f2dd59314a3f19c284729e69aab6",
    "details": {
      "sha": "af4b16331ad34582379e41ae27ebf07c3903f79a",
      "filename": "src/test/java/com/lmax/disruptor/RewindBatchEventProcessorTest.java",
      "status": "modified",
      "additions": 5,
      "deletions": 6,
      "changes": 11,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/6105d201ce71f2dd59314a3f19c284729e69aab6/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRewindBatchEventProcessorTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/6105d201ce71f2dd59314a3f19c284729e69aab6/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRewindBatchEventProcessorTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRewindBatchEventProcessorTest.java?ref=6105d201ce71f2dd59314a3f19c284729e69aab6",
      "patch": "@@ -38,7 +38,7 @@ public void shouldRewindOnFirstEventOfBatchSizeOfOne()\n     {\n         fill(ringBuffer, 1);\n \n-        final TestEventHandler eventHandler = new TestEventHandler(values, asList(rewind(0, 1)), 0, -1);\n+        final TestEventHandler eventHandler = new TestEventHandler(values, List.of(rewind(0, 1)), 0, -1);\n         final BatchEventProcessor<LongEvent> eventProcessor = create(eventHandler);\n         eventHandler.setRewindable(eventProcessor);\n \n@@ -441,7 +441,7 @@ private BatchEventProcessor<LongEvent> create(final TestEventHandler eventHandle\n                 batchRewindStrategy);\n     }\n \n-    private final class TestEventHandler implements RewindableEventHandler<LongEvent>\n+    private static final class TestEventHandler implements RewindableEventHandler<LongEvent>\n     {\n         private final List<EventResult> values;\n         private BatchEventProcessor<LongEvent> processor;\n@@ -468,7 +468,7 @@ public void setRewindable(final BatchEventProcessor<LongEvent> processor)\n         }\n \n         @Override\n-        public void onEvent(final LongEvent event, final long sequence, final boolean endOfBatch) throws RewindableException, Exception\n+        public void onEvent(final LongEvent event, final long sequence, final boolean endOfBatch) throws RewindableException\n         {\n \n             if (sequence == nonRewindableErrorSequence)\n@@ -512,7 +512,7 @@ private static void fill(final RingBuffer<LongEvent> ringBuffer, final int batch\n \n     private static Matcher<List<EventResult>> containsExactSequence(final EventRangeExpectation... ranges)\n     {\n-        return new TypeSafeMatcher<List<EventResult>>()\n+        return new TypeSafeMatcher<>()\n         {\n             @Override\n             public void describeTo(final Description description)\n@@ -524,9 +524,8 @@ public void describeTo(final Description description)\n             public boolean matchesSafely(final List<EventResult> item)\n             {\n                 int index = 0;\n-                for (int i = 0; i < ranges.length; i++)\n+                for (final EventRangeExpectation range : ranges)\n                 {\n-                    final EventRangeExpectation range = ranges[i];\n                     for (long v = range.sequenceStart, end = range.sequenceEnd; v <= end; v++)\n                     {\n                         final EventResult eventResult = item.get(index++);",
      "parent_sha": "5cda5d56115bdaa05c5237201762513b590f7c2c"
    }
  },
  {
    "oid": "8de6af50890808a4ad499881452b962c6fd2fbe1",
    "message": "dynamic remove handler without message lost",
    "date": "2019-11-19T02:31:10Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/8de6af50890808a4ad499881452b962c6fd2fbe1",
    "details": {
      "sha": "e67617f6053cba8a9b92e4c3d6039c550435ad0b",
      "filename": "src/main/java/com/lmax/disruptor/WorkProcessor.java",
      "status": "modified",
      "additions": 5,
      "deletions": 4,
      "changes": 9,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/8de6af50890808a4ad499881452b962c6fd2fbe1/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FWorkProcessor.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/8de6af50890808a4ad499881452b962c6fd2fbe1/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FWorkProcessor.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FWorkProcessor.java?ref=8de6af50890808a4ad499881452b962c6fd2fbe1",
      "patch": "@@ -125,9 +125,13 @@ public void run()\n                 // typically, this will be true\n                 // this prevents the sequence getting too far forward if an exception\n                 // is thrown from the WorkHandler\n-                sequenceBarrier.clearAlert();\n+\n                 if (processedSequence)\n                 {\n+                    if (!running.get()){\n+                        sequenceBarrier.alert();\n+                        sequenceBarrier.checkAlert();\n+                    }\n                     processedSequence = false;\n                     do\n                     {\n@@ -142,9 +146,6 @@ public void run()\n                     event = ringBuffer.get(nextSequence);\n                     workHandler.onEvent(event);\n                     processedSequence = true;\n-                    if (!running.get()){\n-                        sequenceBarrier.alert();\n-                    }\n                 }\n                 else\n                 {",
      "parent_sha": "2b4b39ee8a3ab674a7966cadf76c2c0c864cd2f6"
    }
  },
  {
    "oid": "81e9d462ec0e807600b55fa8160c78a0f01db06b",
    "message": "Moved worker pool test to YieldingWaitStrategy",
    "date": "2013-02-07T18:37:15Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/81e9d462ec0e807600b55fa8160c78a0f01db06b",
    "details": {
      "sha": "26b1e4e5e202a69cdf18b2b277138fabbd406422",
      "filename": "src/perftest/java/com/lmax/disruptor/OnePublisherToThreeWorkerPoolThroughputTest.java",
      "status": "modified",
      "additions": 10,
      "deletions": 4,
      "changes": 14,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/81e9d462ec0e807600b55fa8160c78a0f01db06b/src%2Fperftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FOnePublisherToThreeWorkerPoolThroughputTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/81e9d462ec0e807600b55fa8160c78a0f01db06b/src%2Fperftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FOnePublisherToThreeWorkerPoolThroughputTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fperftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FOnePublisherToThreeWorkerPoolThroughputTest.java?ref=81e9d462ec0e807600b55fa8160c78a0f01db06b",
      "patch": "@@ -60,10 +60,16 @@ public final class OnePublisherToThreeWorkerPoolThroughputTest\n         }\n     }\n \n-    private final WorkerPool<ValueEvent> workerPool\n-        = new WorkerPool<ValueEvent>(ValueEvent.EVENT_FACTORY,\n-                                     new FatalExceptionHandler(),\n-                                     handlers);\n+    private final RingBuffer<ValueEvent> ringBuffer = \n+            RingBuffer.createSingleProducer(ValueEvent.EVENT_FACTORY, \n+                                            BUFFER_SIZE,\n+                                            new YieldingWaitStrategy());\n+    \n+    private final WorkerPool<ValueEvent> workerPool = \n+            new WorkerPool<ValueEvent>(ringBuffer,\n+                                       ringBuffer.newBarrier(),\n+                                       new FatalExceptionHandler(),\n+                                       handlers);\n \n     ///////////////////////////////////////////////////////////////////////////////////////////////\n ",
      "parent_sha": "8d2df2f17a3e66560b12940fe76aa5277265bcc2"
    }
  },
  {
    "oid": "bbd99a38269e1a01ecabb8bdb3544016c27c310f",
    "message": "Should clear alert before re-using running tests with the Sequencer directly.",
    "date": "2011-09-16T12:27:33Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/bbd99a38269e1a01ecabb8bdb3544016c27c310f",
    "details": {
      "sha": "489c6916eabfb3bb8083f2b8c7471c70399e7ebd",
      "filename": "code/src/perf/com/lmax/disruptor/OnePublisherToOneProcessorUniCastRawThroughputTest.java",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/bbd99a38269e1a01ecabb8bdb3544016c27c310f/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FOnePublisherToOneProcessorUniCastRawThroughputTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/bbd99a38269e1a01ecabb8bdb3544016c27c310f/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FOnePublisherToOneProcessorUniCastRawThroughputTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FOnePublisherToOneProcessorUniCastRawThroughputTest.java?ref=bbd99a38269e1a01ecabb8bdb3544016c27c310f",
      "patch": "@@ -132,6 +132,8 @@ public void halt()\n         public void run()\n         {\n             running = true;\n+            barrier.clearAlert();\n+\n             long nextSequence = sequence.get() + 1L;\n             while (true)\n             {\n@@ -148,10 +150,10 @@ public void run()\n                 }\n                 catch (final AlertException ex)\n                 {\n-                   if (!running)\n-                   {\n-                       break;\n-                   }\n+                    if (!running)\n+                    {\n+                        break;\n+                    }\n                 }\n                 catch (Exception ex)\n                 {",
      "parent_sha": "d45962085f8d3ec447db0edf016f37c6ff45f89a"
    }
  },
  {
    "oid": "e03fa44cd441ad028fe8e92fddb861deaa896b5d",
    "message": "Add finals",
    "date": "2017-05-16T18:27:34Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/e03fa44cd441ad028fe8e92fddb861deaa896b5d",
    "details": {
      "sha": "4dd08e6fecf02480c1c2568fd145127cbd771ed1",
      "filename": "src/main/java/com/lmax/disruptor/dsl/Disruptor.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/e03fa44cd441ad028fe8e92fddb861deaa896b5d/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fdsl%2FDisruptor.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/e03fa44cd441ad028fe8e92fddb861deaa896b5d/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fdsl%2FDisruptor.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fdsl%2FDisruptor.java?ref=e03fa44cd441ad028fe8e92fddb861deaa896b5d",
      "patch": "@@ -207,7 +207,7 @@ public EventHandlerGroup<T> handleEventsWith(final EventProcessor... processors)\n             consumerRepository.add(processor);\n         }\n \n-        Sequence[] sequences = new Sequence[processors.length];\n+        final Sequence[] sequences = new Sequence[processors.length];\n         for (int i = 0; i < processors.length; i++)\n         {\n             sequences[i] = processors[i].getSequence();\n@@ -511,7 +511,7 @@ public SequenceBarrier getBarrierFor(final EventHandler<T> handler)\n      * @param b1\n      * @return\n      */\n-    public long getSequenceValueFor(EventHandler<T> b1)\n+    public long getSequenceValueFor(final EventHandler<T> b1)\n     {\n         return consumerRepository.getSequenceFor(b1).get();\n     }\n@@ -562,7 +562,7 @@ EventHandlerGroup<T> createEventProcessors(\n         return new EventHandlerGroup<T>(this, consumerRepository, processorSequences);\n     }\n \n-    private void updateGatingSequencesForNextInChain(Sequence[] barrierSequences, Sequence[] processorSequences)\n+    private void updateGatingSequencesForNextInChain(final Sequence[] barrierSequences, final Sequence[] processorSequences)\n     {\n         if (processorSequences.length > 0)\n         {\n@@ -596,7 +596,7 @@ EventHandlerGroup<T> createWorkerPool(\n \n         consumerRepository.add(workerPool, sequenceBarrier);\n \n-        Sequence[] workerSequences = workerPool.getWorkerSequences();\n+        final Sequence[] workerSequences = workerPool.getWorkerSequences();\n \n         updateGatingSequencesForNextInChain(barrierSequences, workerSequences);\n ",
      "parent_sha": "885a6f6683666acc615d6aabdafd13c015021d9a"
    }
  },
  {
    "oid": "02a0a0300e3cd80420b74097900f9e60509e422e",
    "message": "Make sleep time a construction parameter, #219.",
    "date": "2018-02-20T16:50:03Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/02a0a0300e3cd80420b74097900f9e60509e422e",
    "details": {
      "sha": "7dbdf4b554b4bc856c479adf7016c8170f24cd66",
      "filename": "src/main/java/com/lmax/disruptor/SleepingWaitStrategy.java",
      "status": "modified",
      "additions": 10,
      "deletions": 51,
      "changes": 61,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/02a0a0300e3cd80420b74097900f9e60509e422e/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSleepingWaitStrategy.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/02a0a0300e3cd80420b74097900f9e60509e422e/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSleepingWaitStrategy.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSleepingWaitStrategy.java?ref=02a0a0300e3cd80420b74097900f9e60509e422e",
      "patch": "@@ -29,23 +29,31 @@\n public final class SleepingWaitStrategy implements WaitStrategy\n {\n     private static final int DEFAULT_RETRIES = 200;\n+    private static final long DEFAULT_SLEEP = 100;\n \n     private final int retries;\n+    private final long sleepTimeNs;\n \n     public SleepingWaitStrategy()\n     {\n-        this(DEFAULT_RETRIES);\n+        this(DEFAULT_RETRIES, DEFAULT_SLEEP);\n     }\n \n     public SleepingWaitStrategy(int retries)\n+    {\n+        this(retries, DEFAULT_SLEEP);\n+    }\n+\n+    public SleepingWaitStrategy(int retries, long sleepTimeNs)\n     {\n         this.retries = retries;\n+        this.sleepTimeNs = sleepTimeNs;\n     }\n \n     @Override\n     public long waitFor(\n         final long sequence, Sequence cursor, final Sequence dependentSequence, final SequenceBarrier barrier)\n-        throws AlertException, InterruptedException\n+        throws AlertException\n     {\n         long availableSequence;\n         int counter = retries;\n@@ -84,53 +92,4 @@ else if (counter > 0)\n \n         return counter;\n     }\n-\n-    public static void main(String[] args) throws AlertException\n-    {\n-        final SequenceBarrier sequenceBarrier = new SequenceBarrier()\n-        {\n-\n-            @Override\n-            public long waitFor(long sequence) throws AlertException, InterruptedException, TimeoutException\n-            {\n-                return 0;\n-            }\n-\n-            @Override\n-            public long getCursor()\n-            {\n-                return 0;\n-            }\n-\n-            @Override\n-            public boolean isAlerted()\n-            {\n-                return false;\n-            }\n-\n-            @Override\n-            public void alert()\n-            {\n-\n-            }\n-\n-            @Override\n-            public void clearAlert()\n-            {\n-\n-            }\n-\n-            @Override\n-            public void checkAlert() throws AlertException\n-            {\n-\n-            }\n-        };\n-\n-        final SleepingWaitStrategy sleepingWaitStrategy = new SleepingWaitStrategy();\n-        for (;;)\n-        {\n-            sleepingWaitStrategy.applyWaitMethod(sequenceBarrier, 0);\n-        }\n-    }\n }",
      "parent_sha": "6ca210f2bcd23f703c479804d583718e16f43c07"
    }
  },
  {
    "oid": "00b995dbacf8a195883114326a9b60d53e131221",
    "message": "Reset iteration count for performance test.",
    "date": "2011-08-14T08:16:48Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/00b995dbacf8a195883114326a9b60d53e131221",
    "details": {
      "sha": "6be2bd635f24c2b1bb34c388e71ec1be002f207a",
      "filename": "code/src/perf/com/lmax/disruptor/Pipeline3StepPerfTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/00b995dbacf8a195883114326a9b60d53e131221/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FPipeline3StepPerfTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/00b995dbacf8a195883114326a9b60d53e131221/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FPipeline3StepPerfTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fperf%2Fcom%2Flmax%2Fdisruptor%2FPipeline3StepPerfTest.java?ref=00b995dbacf8a195883114326a9b60d53e131221",
      "patch": "@@ -81,7 +81,7 @@ public final class Pipeline3StepPerfTest extends AbstractPerfTestQueueVsDisrupto\n {\n     private static final int NUM_EVENT_PROCESSORS = 3;\n     private static final int SIZE = 1024 * 32;\n-    private static final long ITERATIONS = 1000 * 1000 * 50;\n+    private static final long ITERATIONS = 1000L * 1000L * 300L;\n     private final ExecutorService EXECUTOR = Executors.newFixedThreadPool(NUM_EVENT_PROCESSORS);\n \n     private static final long OPERAND_TWO_INITIAL_VALUE = 777L;",
      "parent_sha": "b632cafbefb18fb5fd0200852e440aa317335aa2"
    }
  },
  {
    "oid": "06e16305a7d8f2110dd3e4ac9706ed9764cbef49",
    "message": "Track consumers after claim to prevent wrap when multiple producers exist.",
    "date": "2011-05-21T16:30:09Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/06e16305a7d8f2110dd3e4ac9706ed9764cbef49",
    "details": {
      "sha": "8499757fedbb1d16652550ccfe07c60f2c220fc4",
      "filename": "code/src/main/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/06e16305a7d8f2110dd3e4ac9706ed9764cbef49/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/06e16305a7d8f2110dd3e4ac9706ed9764cbef49/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=06e16305a7d8f2110dd3e4ac9706ed9764cbef49",
      "patch": "@@ -76,7 +76,7 @@ public ConsumerBarrier<T> createConsumerBarrier(final Consumer... consumersToTra\n     /**\n      * Create a {@link ProducerBarrier} on this RingBuffer that tracks dependent {@link Consumer}s.\n      *\n-     * The bufferReserve should be at least the number of producing threads.\n+     * The bufferReserve can be used situations were {@link Consumer}s may not be available for a while.\n      *\n      * @param bufferReserve size of of the buffer to be reserved.\n      * @param consumersToTrack to be tracked to prevent wrapping.\n@@ -211,7 +211,7 @@ private long waitOnConsumers(final long sequence, long availableSequence)\n     private final class ConsumerTrackingProducerBarrier implements ProducerBarrier<T>\n     {\n         private final Consumer[] consumers;\n-        private final int threshold;\n+        private final long threshold;\n \n         public ConsumerTrackingProducerBarrier(final int bufferReserve, final Consumer... consumers)\n         {\n@@ -223,9 +223,9 @@ public ConsumerTrackingProducerBarrier(final int bufferReserve, final Consumer..\n         @SuppressWarnings(\"unchecked\")\n         public T claimNext()\n         {\n-            gateOnConsumers();\n-\n             long sequence = claimStrategy.getAndIncrement();\n+            ensureConsumersAreInRange(sequence);\n+\n             T entry = (T)entries[(int)sequence & ringModMask];\n             entry.setSequence(sequence);\n \n@@ -236,7 +236,7 @@ public T claimNext()\n         @SuppressWarnings(\"unchecked\")\n         public T claimSequence(final long sequence)\n         {\n-            gateOnConsumers();\n+            ensureConsumersAreInRange(sequence);\n \n             T entry = (T)entries[(int)sequence & ringModMask];\n             entry.setSequence(sequence);\n@@ -262,9 +262,9 @@ public void commitSequence(final Entry entry)\n             waitStrategy.signalAll();\n         }\n \n-        private void gateOnConsumers()\n+        private void ensureConsumersAreInRange(final long sequence)\n         {\n-            while ((cursor - getMinimumSequence(consumers)) >= threshold)\n+            while ((sequence - getMinimumSequence(consumers)) >= threshold)\n             {\n                 Thread.yield();\n             }",
      "parent_sha": "ae1d3ec1ffc67b8ab3abead1155630847c1e194a"
    }
  },
  {
    "oid": "465c24334bb8b7d4e42e9b444ff87cf5842f003f",
    "message": "No point spinning when there is insufficient capacity for publishing.",
    "date": "2011-09-16T08:35:59Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/465c24334bb8b7d4e42e9b444ff87cf5842f003f",
    "details": {
      "sha": "11964ae6cf753ec7c53c5bfc36f97722731943cb",
      "filename": "code/src/main/com/lmax/disruptor/ClaimStrategy.java",
      "status": "modified",
      "additions": 4,
      "deletions": 15,
      "changes": 19,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/465c24334bb8b7d4e42e9b444ff87cf5842f003f/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FClaimStrategy.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/465c24334bb8b7d4e42e9b444ff87cf5842f003f/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FClaimStrategy.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FClaimStrategy.java?ref=465c24334bb8b7d4e42e9b444ff87cf5842f003f",
      "patch": "@@ -149,7 +149,7 @@ public boolean hasAvailableCapacity(final Sequence[] dependentSequences)\n         public long incrementAndGet(final Sequence[] dependentSequences)\n         {\n             final MutableLong minGatingSequence = minGatingSequenceThreadLocal.get();\n-            checkCapacity(dependentSequences, minGatingSequence);\n+            pauseForCapacity(dependentSequences, minGatingSequence);\n             final long value = sequence.incrementAndGet();\n             ensureCapacity(value, dependentSequences, minGatingSequence);\n             return value;\n@@ -185,7 +185,7 @@ public void serialisePublishing(final long sequence, final Sequence cursor, fina\n             }\n         }\n \n-        private void checkCapacity(final Sequence[] dependentSequences, final MutableLong minGatingSequence)\n+        private void pauseForCapacity(final Sequence[] dependentSequences, final MutableLong minGatingSequence)\n         {\n             final long wrapPoint = (sequence.get() + 1L) - bufferSize;\n             if (wrapPoint > minGatingSequence.get())\n@@ -206,15 +206,10 @@ private void ensureCapacity(final long sequence, final Sequence[] dependentSeque\n             final long wrapPoint = sequence - bufferSize;\n             if (wrapPoint > minGatingSequence.get())\n             {\n-                int counter = RETRIES;\n                 long minSequence;\n                 while (wrapPoint > (minSequence = getMinimumSequence(dependentSequences)))\n                 {\n-                    if (--counter == 0)\n-                    {\n-                        counter = RETRIES;\n-                        Thread.yield();\n-                    }\n+                    Thread.yield();\n                 }\n \n                 minGatingSequence.set(minSequence);\n@@ -250,7 +245,6 @@ private int applyBackPressure(int counter)\n     static final class SingleThreadedStrategy\n         implements ClaimStrategy\n     {\n-        private static final int RETRIES = 100;\n         private final int bufferSize;\n         private final PaddedLong minGatingSequence = new PaddedLong(Sequencer.INITIAL_CURSOR_VALUE);\n         private final PaddedLong sequence = new PaddedLong(Sequencer.INITIAL_CURSOR_VALUE);\n@@ -314,14 +308,9 @@ private void ensureCapacity(final long sequence, final Sequence[] dependentSeque\n             if (wrapPoint > minGatingSequence.get())\n             {\n                 long minSequence;\n-                int counter = RETRIES;\n                 while (wrapPoint > (minSequence = getMinimumSequence(dependentSequences)))\n                 {\n-                    if (--counter == 0)\n-                    {\n-                        counter = RETRIES;\n-                        Thread.yield();\n-                    }\n+                    Thread.yield();\n                 }\n \n                 minGatingSequence.set(minSequence);",
      "parent_sha": "67462c1a22ad4ce028b28141fdd9bb4a0d087bca"
    }
  },
  {
    "oid": "1187a862ace0a00b26b35e874a2bd8f028c776ce",
    "message": "Rewrite BatchEventProcessorTest in spirit of JUnit 5",
    "date": "2020-12-04T15:43:31Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/1187a862ace0a00b26b35e874a2bd8f028c776ce",
    "details": {
      "sha": "2beadddfc40b19032ed6acdbc598f846544cbfa6",
      "filename": "src/test/java/com/lmax/disruptor/BatchEventProcessorTest.java",
      "status": "modified",
      "additions": 17,
      "deletions": 7,
      "changes": 24,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/1187a862ace0a00b26b35e874a2bd8f028c776ce/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FBatchEventProcessorTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/1187a862ace0a00b26b35e874a2bd8f028c776ce/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FBatchEventProcessorTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FBatchEventProcessorTest.java?ref=1187a862ace0a00b26b35e874a2bd8f028c776ce",
      "patch": "@@ -16,28 +16,38 @@\n package com.lmax.disruptor;\n \n import com.lmax.disruptor.support.StubEvent;\n-import org.junit.Test;\n+import org.junit.jupiter.api.Test;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n \n import static com.lmax.disruptor.RingBuffer.createMultiProducer;\n import static org.hamcrest.CoreMatchers.not;\n import static org.hamcrest.CoreMatchers.nullValue;\n-import static org.junit.Assert.*;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n \n public final class BatchEventProcessorTest\n {\n     private final RingBuffer<StubEvent> ringBuffer = createMultiProducer(StubEvent.EVENT_FACTORY, 16);\n     private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();\n \n-    @Test(expected = NullPointerException.class)\n+    @Test\n     public void shouldThrowExceptionOnSettingNullExceptionHandler()\n     {\n-        final BatchEventProcessor<StubEvent> batchEventProcessor = new BatchEventProcessor<>(\n-                ringBuffer, sequenceBarrier, new ExceptionEventHandler());\n-        batchEventProcessor.setExceptionHandler(null);\n+        assertThrows(NullPointerException.class, () ->\n+        {\n+            final BatchEventProcessor<StubEvent> batchEventProcessor = new BatchEventProcessor<>(\n+                    ringBuffer, sequenceBarrier, new ExceptionEventHandler());\n+            batchEventProcessor.setExceptionHandler(null);\n+        });\n     }\n \n     @Test",
      "parent_sha": "1a12c3136e474ca5d0d94ab05ab1b41c3a4c9523"
    }
  },
  {
    "oid": "ebe0ca106e7a772de7118a679c44f09fb653f7ec",
    "message": "Generalise to support Sequencers.",
    "date": "2011-09-10T09:22:36Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/ebe0ca106e7a772de7118a679c44f09fb653f7ec",
    "details": {
      "sha": "8cd4d78b9f2b34d4fe3049a2bc5298182fe6c9ee",
      "filename": "code/src/main/com/lmax/disruptor/NoOpEventProcessor.java",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/ebe0ca106e7a772de7118a679c44f09fb653f7ec/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FNoOpEventProcessor.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/ebe0ca106e7a772de7118a679c44f09fb653f7ec/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FNoOpEventProcessor.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FNoOpEventProcessor.java?ref=ebe0ca106e7a772de7118a679c44f09fb653f7ec",
      "patch": "@@ -16,21 +16,21 @@\n package com.lmax.disruptor;\n \n /**\n- * No operation version of a {@link EventProcessor} that simply tracks a {@link RingBuffer}.\n+ * No operation version of a {@link EventProcessor} that simply tracks a {@link Sequencer}.\n  * This is useful in tests or for pre-filling a {@link RingBuffer} from a publisher.\n  */\n public final class NoOpEventProcessor implements EventProcessor\n {\n-    private final RingBufferTrackingSequence sequence;\n+    private final SequencerFollowingSequence sequence;\n \n     /**\n-     * Construct a {@link EventProcessor} that simply tracks a {@link RingBuffer}.\n+     * Construct a {@link EventProcessor} that simply tracks a {@link Sequencer}.\n      *\n-     * @param ringBuffer to track.\n+     * @param sequencer to track.\n      */\n-    public NoOpEventProcessor(final RingBuffer ringBuffer)\n+    public NoOpEventProcessor(final Sequencer sequencer)\n     {\n-        sequence = new RingBufferTrackingSequence(ringBuffer);\n+        sequence = new SequencerFollowingSequence(sequencer);\n     }\n \n     @Override\n@@ -49,20 +49,20 @@ public void run()\n     {\n     }\n \n-    private static final class RingBufferTrackingSequence extends Sequence\n+    private static final class SequencerFollowingSequence extends Sequence\n     {\n-        private final RingBuffer ringBuffer;\n+        private final Sequencer sequencer;\n \n-        private RingBufferTrackingSequence(final RingBuffer ringBuffer)\n+        private SequencerFollowingSequence(final Sequencer sequencer)\n         {\n             super(Sequencer.INITIAL_CURSOR_VALUE);\n-            this.ringBuffer = ringBuffer;\n+            this.sequencer = sequencer;\n         }\n \n         @Override\n         public long get()\n         {\n-            return ringBuffer.getCursor();\n+            return sequencer.getCursor();\n         }\n     }\n }",
      "parent_sha": "6e1fe90a6074667a7191dfa9c39028b6bd9fb760"
    }
  },
  {
    "oid": "d44e7a98c25ed9a07f1d6acbfed0ff33c3bd7a31",
    "message": "Add SuppressWarnings(\"varargs\") to at least avoid overzealous warning from javac when using JDK7.",
    "date": "2011-08-14T10:36:42Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/d44e7a98c25ed9a07f1d6acbfed0ff33c3bd7a31",
    "details": {
      "sha": "c9f4a1390166d9dfec61fe3d453b2cedb60b9d5d",
      "filename": "code/src/main/com/lmax/disruptor/wizard/DisruptorWizard.java",
      "status": "modified",
      "additions": 12,
      "deletions": 5,
      "changes": 17,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/d44e7a98c25ed9a07f1d6acbfed0ff33c3bd7a31/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2Fwizard%2FDisruptorWizard.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/d44e7a98c25ed9a07f1d6acbfed0ff33c3bd7a31/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2Fwizard%2FDisruptorWizard.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2Fwizard%2FDisruptorWizard.java?ref=d44e7a98c25ed9a07f1d6acbfed0ff33c3bd7a31",
      "patch": "@@ -89,6 +89,7 @@ private DisruptorWizard(final RingBuffer<T> ringBuffer, final Executor executor)\n      * @param handlers the event handlers that will process events.\n      * @return a {@link EventHandlerGroup} that can be used to chain dependencies.\n      */\n+    @SuppressWarnings(\"varargs\")\n     public EventHandlerGroup<T> handleEventsWith(final EventHandler<T>... handlers)\n     {\n         return createEventProcessors(new EventProcessor[0], handlers);\n@@ -123,8 +124,9 @@ public ExceptionHandlerSetting handleExceptionsFor(final EventHandler<T> eventHa\n      *\n      * @param handlers the event handlers, previously set up with {@link #handleEventsWith(com.lmax.disruptor.EventHandler[])},\n      *                 that will form the barrier for subsequent handlers.\n-     * @return a {@link EventHandlerGroup} that can be used to setup a handler barrier over the specified eventprocessors.\n+     * @return an {@link EventHandlerGroup} that can be used to setup a handler barrier over the specified event handlers.\n      */\n+    @SuppressWarnings(\"varargs\")\n     public EventHandlerGroup<T> after(final EventHandler<T>... handlers)\n     {\n         EventProcessor[] selectedEventProcessors = new EventProcessor[handlers.length];\n@@ -181,10 +183,7 @@ public void halt()\n \n     EventHandlerGroup<T> createEventProcessors(final EventProcessor[] barrierEventProcessors, final EventHandler<T>[] eventHandlers)\n     {\n-        if (started.get())\n-        {\n-            throw new IllegalStateException(\"All event handlers must be added before calling start.\");\n-        }\n+        ensureNotStarted();\n \n         final EventProcessor[] createdEventProcessors = new EventProcessor[eventHandlers.length];\n         final DependencyBarrier barrier = ringBuffer.newDependencyBarrier(barrierEventProcessors);\n@@ -205,6 +204,14 @@ EventHandlerGroup<T> createEventProcessors(final EventProcessor[] barrierEventPr\n         return new EventHandlerGroup<T>(this, createdEventProcessors);\n     }\n \n+    private void ensureNotStarted()\n+    {\n+        if (started.get())\n+        {\n+            throw new IllegalStateException(\"All event handlers must be added before calling start.\");\n+        }\n+    }\n+\n     private void startEventProcessors()\n     {\n         for (EventProcessorInfo<T> eventProcessorInfo : eventProcessorRepository)",
      "parent_sha": "2b4ba26c1e507d3719a0f32f32ee9caa5ed170f9"
    }
  },
  {
    "oid": "019c8246e1bf9a925dd2d4ad5dcbb0a7a889adf7",
    "message": "Remove padding from ring buffer array.",
    "date": "2020-02-10T21:48:09Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/019c8246e1bf9a925dd2d4ad5dcbb0a7a889adf7",
    "details": {
      "sha": "75b8369fd845fbc6638ca8649f922ebc3916caa8",
      "filename": "src/main/java/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 10,
      "deletions": 43,
      "changes": 53,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/019c8246e1bf9a925dd2d4ad5dcbb0a7a889adf7/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/019c8246e1bf9a925dd2d4ad5dcbb0a7a889adf7/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=019c8246e1bf9a925dd2d4ad5dcbb0a7a889adf7",
      "patch": "@@ -16,10 +16,7 @@\n package com.lmax.disruptor;\n \n \n-import sun.misc.Unsafe;\n-\n import com.lmax.disruptor.dsl.ProducerType;\n-import com.lmax.disruptor.util.Util;\n \n abstract class RingBufferPad\n {\n@@ -28,69 +25,40 @@ abstract class RingBufferPad\n \n abstract class RingBufferFields<E> extends RingBufferPad\n {\n-    private static final int BUFFER_PAD;\n-    private static final long REF_ARRAY_BASE;\n-    private static final int REF_ELEMENT_SHIFT;\n-    private static final Unsafe UNSAFE = Util.getUnsafe();\n-\n-    static\n-    {\n-        final int scale = UNSAFE.arrayIndexScale(Object[].class);\n-        if (4 == scale)\n-        {\n-            REF_ELEMENT_SHIFT = 2;\n-        }\n-        else if (8 == scale)\n-        {\n-            REF_ELEMENT_SHIFT = 3;\n-        }\n-        else\n-        {\n-            throw new IllegalStateException(\"Unknown pointer size\");\n-        }\n-        BUFFER_PAD = 128 / scale;\n-        // Including the buffer pad in the array base offset\n-        REF_ARRAY_BASE = UNSAFE.arrayBaseOffset(Object[].class) + 128;\n-    }\n-\n-    private final long indexMask;\n     private final Object[] entries;\n-    protected final int bufferSize;\n     protected final Sequencer sequencer;\n \n     RingBufferFields(\n         EventFactory<E> eventFactory,\n         Sequencer sequencer)\n     {\n         this.sequencer = sequencer;\n-        this.bufferSize = sequencer.getBufferSize();\n \n-        if (bufferSize < 1)\n+        if (sequencer.getBufferSize() < 1)\n         {\n             throw new IllegalArgumentException(\"bufferSize must not be less than 1\");\n         }\n-        if (Integer.bitCount(bufferSize) != 1)\n+        if (Integer.bitCount(sequencer.getBufferSize()) != 1)\n         {\n             throw new IllegalArgumentException(\"bufferSize must be a power of 2\");\n         }\n \n-        this.indexMask = bufferSize - 1;\n-        this.entries = new Object[sequencer.getBufferSize() + 2 * BUFFER_PAD];\n+        this.entries = new Object[sequencer.getBufferSize()];\n         fill(eventFactory);\n     }\n \n     private void fill(EventFactory<E> eventFactory)\n     {\n-        for (int i = 0; i < bufferSize; i++)\n+        for (int i = 0; i < entries.length; i++)\n         {\n-            entries[BUFFER_PAD + i] = eventFactory.newInstance();\n+            entries[i] = eventFactory.newInstance();\n         }\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     protected final E elementAt(long sequence)\n     {\n-        return (E) UNSAFE.getObject(entries, REF_ARRAY_BASE + ((sequence & indexMask) << REF_ELEMENT_SHIFT));\n+        return (E) entries[(int) (sequence & (entries.length - 1))];\n     }\n }\n \n@@ -437,7 +405,7 @@ public long getCursor()\n      */\n     public int getBufferSize()\n     {\n-        return bufferSize;\n+        return sequencer.getBufferSize();\n     }\n \n     /**\n@@ -910,9 +878,9 @@ private void checkBatchSizing(int batchStartsAt, int batchSize)\n         {\n             throw new IllegalArgumentException(\"Both batchStartsAt and batchSize must be positive but got: batchStartsAt \" + batchStartsAt + \" and batchSize \" + batchSize);\n         }\n-        else if (batchSize > bufferSize)\n+        else if (batchSize > sequencer.getBufferSize())\n         {\n-            throw new IllegalArgumentException(\"The ring buffer cannot accommodate \" + batchSize + \" it only has space for \" + bufferSize + \" entities.\");\n+            throw new IllegalArgumentException(\"The ring buffer cannot accommodate \" + batchSize + \" it only has space for \" + sequencer.getBufferSize() + \" entities.\");\n         }\n     }\n \n@@ -1124,8 +1092,7 @@ private void translateAndPublishBatch(\n     public String toString()\n     {\n         return \"RingBuffer{\" +\n-            \"bufferSize=\" + bufferSize +\n-            \", sequencer=\" + sequencer +\n+            \"sequencer=\" + sequencer +\n             \"}\";\n     }\n }",
      "parent_sha": "b000a81014f7e49348bc63b8e78f4f9f3f92134a"
    }
  },
  {
    "oid": "a51c11eba460c552e53fa066dbfd35e14b69258c",
    "message": "Remove unnecessary try/finally from earlyExit to match main path.",
    "date": "2018-03-15T02:34:59Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/a51c11eba460c552e53fa066dbfd35e14b69258c",
    "details": {
      "sha": "26ece993be568531da243367be601809ac6e3c36",
      "filename": "src/main/java/com/lmax/disruptor/BatchEventProcessor.java",
      "status": "modified",
      "additions": 3,
      "deletions": 8,
      "changes": 11,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/a51c11eba460c552e53fa066dbfd35e14b69258c/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FBatchEventProcessor.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/a51c11eba460c552e53fa066dbfd35e14b69258c/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FBatchEventProcessor.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FBatchEventProcessor.java?ref=a51c11eba460c552e53fa066dbfd35e14b69258c",
      "patch": "@@ -120,6 +120,7 @@ public void run()\n             notifyStart();\n             try\n             {\n+\n                 if (running.get() == RUNNING)\n                 {\n                     processEvents();\n@@ -193,14 +194,8 @@ private void processEvents()\n \n     private void earlyExit()\n     {\n-        try\n-        {\n-            notifyStart();\n-        }\n-        finally\n-        {\n-            notifyShutdown();\n-        }\n+        notifyStart();\n+        notifyShutdown();\n     }\n \n     private void notifyTimeout(final long availableSequence)",
      "parent_sha": "a9803666e018f756f3d3033f8f0573ab517abcb0"
    }
  },
  {
    "oid": "838d5a57018b4b746edb444346cea825e1893914",
    "message": "Rewrite SequenceGroupTest in spirit of JUnit 5",
    "date": "2020-12-04T16:07:21Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/838d5a57018b4b746edb444346cea825e1893914",
    "details": {
      "sha": "de307c7394382965aa88bccd3a28f96320c35a7b",
      "filename": "src/test/java/com/lmax/disruptor/SequenceGroupTest.java",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/838d5a57018b4b746edb444346cea825e1893914/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSequenceGroupTest.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/838d5a57018b4b746edb444346cea825e1893914/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSequenceGroupTest.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Ftest%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FSequenceGroupTest.java?ref=838d5a57018b4b746edb444346cea825e1893914",
      "patch": "@@ -15,12 +15,13 @@\n  */\n package com.lmax.disruptor;\n \n-import static org.hamcrest.CoreMatchers.is;\n-import static org.junit.Assert.*;\n-\n-import org.junit.Test;\n-\n import com.lmax.disruptor.support.TestEvent;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n \n public final class SequenceGroupTest\n {",
      "parent_sha": "012833c5ad843b7761db1322b50ae9265f4c7971"
    }
  },
  {
    "oid": "fa16fd84d786a7c4e3a6325f8d451850950fb973",
    "message": "More javadoc for the RingBuffer",
    "date": "2012-11-09T08:23:26Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/fa16fd84d786a7c4e3a6325f8d451850950fb973",
    "details": {
      "sha": "cee75aff1a4e8e07fa0018b0de7eb374e64a8d0c",
      "filename": "src/main/java/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 36,
      "deletions": 2,
      "changes": 38,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/fa16fd84d786a7c4e3a6325f8d451850950fb973/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/fa16fd84d786a7c4e3a6325f8d451850950fb973/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=fa16fd84d786a7c4e3a6325f8d451850950fb973",
      "patch": "@@ -158,6 +158,22 @@ public E get(final long sequence)\n         return (E)entries[(int)sequence & indexMask];\n     }\n     \n+    /**\n+     * Increment and return the next sequence for the ring buffer.  Calls of this\n+     * method should ensure that they always publish the sequence afterward.  E.g.\n+     * <pre>\n+     * long sequence = ringBuffer.next();\n+     * try {\n+     *     Event e = ringBuffer.getPreallocated(sequence);\n+     *     // Do some work with the event.\n+     * } finally {\n+     *     ringBuffer.publish(sequence);\n+     * }\n+     * </pre>\n+     * @see RingBuffer#publish(long)\n+     * @see RingBuffer#getPreallocated(long)\n+     * @return The next sequence to publish to.\n+     */\n     public long next()\n     {\n         return sequencer.next(gatingSequences);\n@@ -236,16 +252,34 @@ public SequenceBarrier newBarrier(Sequence... sequencesToTrack)\n         return new ProcessingSequenceBarrier(waitStrategy, cursor, sequencesToTrack);\n     }\n \n+    /**\n+     * Get the current cursor value for the ring buffer.  The cursor value is\n+     * the last value that was published, or the highest available sequence\n+     * that can be consumed.\n+     */\n     public final long getCursor()\n     {\n         return cursor.get();\n     }\n-    \n+\n+    /**\n+     * The size of the buffer.\n+     */\n     public int getBufferSize()\n     {\n         return bufferSize;\n     }\n     \n+    /**\n+     * Given specified <tt>requiredCapacity</tt> determines if that amount of space\n+     * is available.  Note, you can not assume that if this method returns <tt>true</tt>\n+     * that a call to {@link RingBuffer#next()} will not block.  Especially true if this\n+     * ring buffer is set up to handle multiple producers.\n+     * \n+     * @param requiredCapacity The capacity to check for.\n+     * @return <tt>true</tt> If the specified <tt>requiredCapacity</tt> is available\n+     * <tt>false</tt> if now.\n+     */\n     public boolean hasAvilableCapacity(final int requiredCapacity)\n     {\n         return sequencer.hasAvailableCapacity(gatingSequences, requiredCapacity);\n@@ -254,7 +288,7 @@ public boolean hasAvilableCapacity(final int requiredCapacity)\n \n     /**\n      * Publishes an event to the ring buffer.  It handles\n-     * claiming the next sequence, getting the current (uninitialized)\n+     * claiming the next sequence, getting the current (uninitialised)\n      * event from the ring buffer and publishing the claimed sequence\n      * after translation.\n      *",
      "parent_sha": "bb36012353f4277aaae5afa9f71e49480a9dd9e9"
    }
  },
  {
    "oid": "3888c6c944b955b636be1235036536b7f98a78ac",
    "message": "Fix javadoc header level\n\nJDK17 javadoc apparently won't let us use a h3 under a h1",
    "date": "2021-10-09T19:37:33Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/3888c6c944b955b636be1235036536b7f98a78ac",
    "details": {
      "sha": "9ea8bd7b6f2dbd5353996f3bd89f7e04dcd5dcfc",
      "filename": "src/main/java/com/lmax/disruptor/package-info.java",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/3888c6c944b955b636be1235036536b7f98a78ac/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fpackage-info.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/3888c6c944b955b636be1235036536b7f98a78ac/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fpackage-info.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fpackage-info.java?ref=3888c6c944b955b636be1235036536b7f98a78ac",
      "patch": "@@ -9,7 +9,7 @@\n  *\n  * <p>Almost any graph or pipeline structure can be composed via one or more Disruptor patterns.\n  *\n- * <h3>UniCast a series of items between 1 publisher and 1 EventProcessor.</h3>\n+ * <h2>UniCast a series of items between 1 publisher and 1 EventProcessor.</h2>\n  *\n  * <pre>{@code\n  *                                           track to prevent wrap\n@@ -25,7 +25,7 @@\n  *                                                       waitFor\n  * }</pre>\n  *\n- * <h3>Sequence a series of messages from multiple publishers</h3>\n+ * <h2>Sequence a series of messages from multiple publishers</h2>\n  * <pre>{@code\n  *                                          track to prevent wrap\n  *                                          +--------------------+\n@@ -44,7 +44,7 @@\n  * +----+                       +----+\n  * }</pre>\n  *\n- * <h3>Pipeline a series of messages</h3>\n+ * <h2>Pipeline a series of messages</h2>\n  * <pre>{@code\n  *                           +----+    +-----+    +-----+    +-----+\n  *                           | P1 |--->| EP1 |--->| EP2 |--->| EP3 |\n@@ -64,7 +64,7 @@\n  *              +---------+---------------------+---------------------+\n  * }</pre>\n  *\n- * <h3>Multicast a series of messages to multiple EventProcessors</h3>\n+ * <h2>Multicast a series of messages to multiple EventProcessors</h2>\n  * <pre>{@code\n  *           +-----+                                        track to prevent wrap\n  *    +----->| EP1 |                        +--------------------+----------+----------+\n@@ -79,7 +79,7 @@\n  *           +-----+                                                 waitFor\n  * }</pre>\n  *\n- * <h3>Replicate a message then fold back the results</h3>\n+ * <h2>Replicate a message then fold back the results</h2>\n  * <pre>{@code\n  *           +-----+                               track to prevent wrap\n  *    +----->| EP1 |-----+                   +-------------------------------+",
      "parent_sha": "641c2078bb6a246748ae56e4f5367a1ad55b015f"
    }
  },
  {
    "oid": "392117e61ca17480b46d2f95cf63a61d21024e0a",
    "message": "parameter rename.",
    "date": "2011-07-04T06:33:36Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/392117e61ca17480b46d2f95cf63a61d21024e0a",
    "details": {
      "sha": "2608c39172bd88f2b391db5383c685ab12ce23a7",
      "filename": "code/src/main/com/lmax/disruptor/RingBuffer.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/392117e61ca17480b46d2f95cf63a61d21024e0a/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/392117e61ca17480b46d2f95cf63a61d21024e0a/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/code%2Fsrc%2Fmain%2Fcom%2Flmax%2Fdisruptor%2FRingBuffer.java?ref=392117e61ca17480b46d2f95cf63a61d21024e0a",
      "patch": "@@ -142,11 +142,11 @@ public T getEntry(final long sequence)\n         return (T)entries[(int)sequence & ringModMask];\n     }\n \n-    private void fill(final EntryFactory<T> entryEntryFactory)\n+    private void fill(final EntryFactory<T> entryFactory)\n     {\n         for (int i = 0; i < entries.length; i++)\n         {\n-            entries[i] = entryEntryFactory.create();\n+            entries[i] = entryFactory.create();\n         }\n     }\n ",
      "parent_sha": "1970ea88d96733e8cd19d235088d7c5593187ce5"
    }
  },
  {
    "oid": "bb0df14002bb7933beaa86bdd0d97ea13015019c",
    "message": "Use compareAndExchange in BatchEventProcessor",
    "date": "2021-01-24T02:03:59Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/bb0df14002bb7933beaa86bdd0d97ea13015019c",
    "details": {
      "sha": "f93397a0406c8a5c1632de261500776e82731519",
      "filename": "src/main/java/com/lmax/disruptor/BatchEventProcessor.java",
      "status": "modified",
      "additions": 3,
      "deletions": 5,
      "changes": 8,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/bb0df14002bb7933beaa86bdd0d97ea13015019c/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FBatchEventProcessor.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/bb0df14002bb7933beaa86bdd0d97ea13015019c/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FBatchEventProcessor.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2FBatchEventProcessor.java?ref=bb0df14002bb7933beaa86bdd0d97ea13015019c",
      "patch": "@@ -113,7 +113,8 @@ public void setExceptionHandler(final ExceptionHandler<? super T> exceptionHandl\n     @Override\n     public void run()\n     {\n-        if (running.compareAndSet(IDLE, RUNNING))\n+        int witnessValue = running.compareAndExchange(IDLE, RUNNING);\n+        if (witnessValue == IDLE) // Successful CAS\n         {\n             sequenceBarrier.clearAlert();\n \n@@ -133,10 +134,7 @@ public void run()\n         }\n         else\n         {\n-            // This is a little bit of guess work.  The running state could of changed to HALTED by\n-            // this point.  However, Java does not have compareAndExchange which is the only way\n-            // to get it exactly correct.\n-            if (running.get() == RUNNING)\n+            if (witnessValue == RUNNING)\n             {\n                 throw new IllegalStateException(\"Thread is already running\");\n             }",
      "parent_sha": "73ec60d43d504bbbc0b57ec2abf87e7913740c57"
    }
  },
  {
    "oid": "923cccb9bbf13acb5b1b99084ec63c48264e2644",
    "message": "Fix #102, checkstyle failures.",
    "date": "2014-11-13T01:33:26Z",
    "url": "https://github.com/LMAX-Exchange/disruptor/commit/923cccb9bbf13acb5b1b99084ec63c48264e2644",
    "details": {
      "sha": "cb696c2785aac0d671d9b89b3a22b7f09fdeac49",
      "filename": "src/main/java/com/lmax/disruptor/dsl/Disruptor.java",
      "status": "modified",
      "additions": 21,
      "deletions": 22,
      "changes": 43,
      "blob_url": "https://github.com/LMAX-Exchange/disruptor/blob/923cccb9bbf13acb5b1b99084ec63c48264e2644/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fdsl%2FDisruptor.java",
      "raw_url": "https://github.com/LMAX-Exchange/disruptor/raw/923cccb9bbf13acb5b1b99084ec63c48264e2644/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fdsl%2FDisruptor.java",
      "contents_url": "https://api.github.com/repos/LMAX-Exchange/disruptor/contents/src%2Fmain%2Fjava%2Fcom%2Flmax%2Fdisruptor%2Fdsl%2FDisruptor.java?ref=923cccb9bbf13acb5b1b99084ec63c48264e2644",
      "patch": "@@ -20,7 +20,6 @@\n import java.util.concurrent.atomic.AtomicBoolean;\n \n import com.lmax.disruptor.BatchEventProcessor;\n-import com.lmax.disruptor.BlockingWaitStrategy;\n import com.lmax.disruptor.EventFactory;\n import com.lmax.disruptor.EventHandler;\n import com.lmax.disruptor.EventProcessor;\n@@ -66,16 +65,16 @@ public class Disruptor<T>\n     private ExceptionHandler exceptionHandler;\n \n     /**\n-\t * Create a new Disruptor. Will default to {@link BlockingWaitStrategy} and\n-\t * {@link ProducerType}.MULTI\n-\t *\n-\t * @param eventFactory\n-\t *            the factory to create events in the ring buffer.\n-\t * @param ringBufferSize\n-\t *            the size of the ring buffer.\n-\t * @param executor\n-\t *            an {@link Executor} to execute event processors.\n-\t */\n+     * Create a new Disruptor. Will default to {@link com.lmax.disruptor.BlockingWaitStrategy} and\n+     * {@link ProducerType}.MULTI\n+     *\n+     * @param eventFactory\n+     *            the factory to create events in the ring buffer.\n+     * @param ringBufferSize\n+     *            the size of the ring buffer.\n+     * @param executor\n+     *            an {@link Executor} to execute event processors.\n+     */\n     public Disruptor(final EventFactory<T> eventFactory, final int ringBufferSize, final Executor executor)\n     {\n         this(RingBuffer.createMultiProducer(eventFactory, ringBufferSize), executor);\n@@ -161,7 +160,7 @@ public EventHandlerGroup<T> handleEventsWith(final EventProcessorFactory<T>... e\n      */\n     public EventHandlerGroup<T> handleEventsWith(final EventProcessor... processors)\n     {\n-        for (EventProcessor processor : processors)\n+        for (final EventProcessor processor : processors)\n         {\n             consumerRepository.add(processor);\n         }\n@@ -220,7 +219,7 @@ public ExceptionHandlerSetting<?> handleExceptionsFor(final EventHandler<T> even\n     @SuppressWarnings(\"varargs\")\n     public EventHandlerGroup<T> after(final EventHandler<T>... handlers)\n     {\n-        Sequence[] sequences = new Sequence[handlers.length];\n+        final Sequence[] sequences = new Sequence[handlers.length];\n         for (int i = 0, handlersLength = handlers.length; i < handlersLength; i++)\n         {\n             sequences[i] = consumerRepository.getSequenceFor(handlers[i]);\n@@ -239,7 +238,7 @@ public EventHandlerGroup<T> after(final EventHandler<T>... handlers)\n      */\n     public EventHandlerGroup<T> after(final EventProcessor... processors)\n     {\n-        for (EventProcessor processor : processors)\n+        for (final EventProcessor processor : processors)\n         {\n             consumerRepository.add(processor);\n         }\n@@ -263,7 +262,7 @@ public void publishEvent(final EventTranslator<T> eventTranslator)\n      * @param eventTranslator the translator that will load data into the event.\n      * @param arg A single argument to load into the event\n      */\n-    public <A> void publishEvent(final EventTranslatorOneArg<T, A> eventTranslator, A arg)\n+    public <A> void publishEvent(final EventTranslatorOneArg<T, A> eventTranslator, final A arg)\n     {\n         ringBuffer.publishEvent(eventTranslator, arg);\n     }\n@@ -274,7 +273,7 @@ public <A> void publishEvent(final EventTranslatorOneArg<T, A> eventTranslator,\n      * @param eventTranslator the translator that will load data into the event.\n      * @param arg An array single arguments to load into the events. One Per event.\n      */\n-    public <A> void publishEvents(final EventTranslatorOneArg<T, A> eventTranslator, A[] arg)\n+    public <A> void publishEvents(final EventTranslatorOneArg<T, A> eventTranslator, final A[] arg)\n     {\n         ringBuffer.publishEvents(eventTranslator, arg);\n     }\n@@ -291,11 +290,11 @@ public <A> void publishEvents(final EventTranslatorOneArg<T, A> eventTranslator,\n      */\n     public RingBuffer<T> start()\n     {\n-        Sequence[] gatingSequences = consumerRepository.getLastSequenceInChain(true);\n+        final Sequence[] gatingSequences = consumerRepository.getLastSequenceInChain(true);\n         ringBuffer.addGatingSequences(gatingSequences);\n \n         checkOnlyStartedOnce();\n-        for (ConsumerInfo consumerInfo : consumerRepository)\n+        for (final ConsumerInfo consumerInfo : consumerRepository)\n         {\n             consumerInfo.start(executor);\n         }\n@@ -308,7 +307,7 @@ public RingBuffer<T> start()\n      */\n     public void halt()\n     {\n-        for (ConsumerInfo consumerInfo : consumerRepository)\n+        for (final ConsumerInfo consumerInfo : consumerRepository)\n         {\n             consumerInfo.halt();\n         }\n@@ -328,7 +327,7 @@ public void shutdown()\n         {\n             shutdown(-1, TimeUnit.MILLISECONDS);\n         }\n-        catch (TimeoutException e)\n+        catch (final TimeoutException e)\n         {\n             exceptionHandler.handleOnShutdownException(e);\n         }\n@@ -346,7 +345,7 @@ public void shutdown()\n      */\n     public void shutdown(final long timeout, final TimeUnit timeUnit) throws TimeoutException\n     {\n-        long timeOutAt = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+        final long timeOutAt = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n         while (hasBacklog())\n         {\n             if (timeout >= 0 && System.currentTimeMillis() > timeOutAt)\n@@ -420,7 +419,7 @@ public SequenceBarrier getBarrierFor(final EventHandler<T> handler)\n     private boolean hasBacklog()\n     {\n         final long cursor = ringBuffer.getCursor();\n-        for (Sequence consumer : consumerRepository.getLastSequenceInChain(false))\n+        for (final Sequence consumer : consumerRepository.getLastSequenceInChain(false))\n         {\n             if (cursor > consumer.get())\n             {",
      "parent_sha": "24ec7f75c18e5cdf6180aebe78d667b87b966d76"
    }
  }
]