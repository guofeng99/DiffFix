[
  {
    "oid": "a213d1bda5efb0d3a7d6d7eda854355908487361",
    "message": "\"wiki-\" prefix no longer required for anchor names in github wiki pages\nalso: correct one parameter name in javadoc comments",
    "date": "2014-06-12T18:44:32Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/a213d1bda5efb0d3a7d6d7eda854355908487361",
    "details": {
      "sha": "2a683f11ac56f3337436f5a569290561222b6c67",
      "filename": "rxjava-core/src/main/java/rx/Observable.java",
      "status": "modified",
      "additions": 282,
      "deletions": 282,
      "changes": 564,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/a213d1bda5efb0d3a7d6d7eda854355908487361/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/a213d1bda5efb0d3a7d6d7eda854355908487361/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java?ref=a213d1bda5efb0d3a7d6d7eda854355908487361",
      "parent_sha": "83f78c46f2781da37bca071f841bc507e1d8d916"
    }
  },
  {
    "oid": "e4eee64bf7b1e78a75b712130bdec12f340bb443",
    "message": "Fix issue #6576 - ObservableBlockingSubscribe compares BlockingObserver.TERMINATED with wrong object (#6577)",
    "date": "2019-07-19T13:01:20Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/e4eee64bf7b1e78a75b712130bdec12f340bb443",
    "details": {
      "sha": "589b71c5f944e0232a7a253c529c408dff08ec2f",
      "filename": "src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/e4eee64bf7b1e78a75b712130bdec12f340bb443/src%2Fmain%2Fjava%2Fio%2Freactivex%2Finternal%2Foperators%2Fobservable%2FObservableBlockingSubscribe.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/e4eee64bf7b1e78a75b712130bdec12f340bb443/src%2Fmain%2Fjava%2Fio%2Freactivex%2Finternal%2Foperators%2Fobservable%2FObservableBlockingSubscribe.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Fio%2Freactivex%2Finternal%2Foperators%2Fobservable%2FObservableBlockingSubscribe.java?ref=e4eee64bf7b1e78a75b712130bdec12f340bb443",
      "patch": "@@ -61,7 +61,7 @@ public static <T> void subscribe(ObservableSource<? extends T> o, Observer<? sup\n                 }\n             }\n             if (bs.isDisposed()\n-                    || o == BlockingObserver.TERMINATED\n+                    || v == BlockingObserver.TERMINATED\n                     || NotificationLite.acceptFull(v, observer)) {\n                 break;\n             }",
      "parent_sha": "a38268c738af7ae1ca50dc4af2bfbb5713361411"
    }
  },
  {
    "oid": "6ef2530749fe3ee3dac36ffca218e884b988721f",
    "message": "BugFix: unsubscribe was not propagating to parent Observable on merge(Observable<Observable<T>>)",
    "date": "2013-10-16T06:20:28Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/6ef2530749fe3ee3dac36ffca218e884b988721f",
    "details": {
      "sha": "2e5655b38ff263914d81b0023f361bb0928b0af9",
      "filename": "rxjava-core/src/main/java/rx/operators/OperationMerge.java",
      "status": "modified",
      "additions": 76,
      "deletions": 4,
      "changes": 80,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/6ef2530749fe3ee3dac36ffca218e884b988721f/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationMerge.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/6ef2530749fe3ee3dac36ffca218e884b988721f/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationMerge.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationMerge.java?ref=6ef2530749fe3ee3dac36ffca218e884b988721f",
      "patch": "@@ -24,6 +24,7 @@\n import java.util.List;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n \n@@ -36,6 +37,10 @@\n import rx.Observable.OnSubscribeFunc;\n import rx.Observer;\n import rx.Subscription;\n+import rx.subscriptions.CompositeSubscription;\n+import rx.subscriptions.Subscriptions;\n+import rx.util.functions.Action0;\n+import rx.util.functions.Action1;\n \n /**\n  * Flattens a list of Observables into one Observable sequence, without any transformation.\n@@ -93,6 +98,7 @@ public Subscription onSubscribe(Observer<? super Observable<? extends T>> observ\n \n                     @Override\n                     public void unsubscribe() {\n+                        System.out.println(\"unsubscribe from merge\");\n                         unsubscribed = true;\n                     }\n \n@@ -125,6 +131,7 @@ private MergeObservable(Observable<? extends Observable<? extends T>> sequences)\n         }\n \n         public Subscription onSubscribe(Observer<? super T> actualObserver) {\n+            CompositeSubscription completeSubscription = new CompositeSubscription();\n \n             /**\n              * We must synchronize a merge because we subscribe to multiple sequences in parallel that will each be emitting.\n@@ -134,15 +141,16 @@ public Subscription onSubscribe(Observer<? super T> actualObserver) {\n              * Bug report: https://github.com/Netflix/RxJava/issues/200\n              */\n             SafeObservableSubscription subscription = new SafeObservableSubscription(ourSubscription);\n+            completeSubscription.add(subscription);\n             SynchronizedObserver<T> synchronizedObserver = new SynchronizedObserver<T>(actualObserver, subscription);\n \n             /**\n              * Subscribe to the parent Observable to get to the children Observables\n              */\n-            sequences.subscribe(new ParentObserver(synchronizedObserver));\n+            completeSubscription.add(sequences.subscribe(new ParentObserver(synchronizedObserver)));\n \n             /* return our subscription to allow unsubscribing */\n-            return subscription;\n+            return completeSubscription;\n         }\n \n         /**\n@@ -380,6 +388,70 @@ public void testUnSubscribe() {\n             verify(stringObserver, never()).onCompleted();\n         }\n \n+        @Test\n+        public void testUnSubscribeObservableOfObservables() throws InterruptedException {\n+\n+            final AtomicBoolean unsubscribed = new AtomicBoolean();\n+            final CountDownLatch latch = new CountDownLatch(1);\n+\n+            Observable<Observable<Long>> source = Observable.create(new OnSubscribeFunc<Observable<Long>>() {\n+\n+                @Override\n+                public Subscription onSubscribe(final Observer<? super Observable<Long>> observer) {\n+                    // verbose on purpose so I can track the inside of it\n+                    final Subscription s = Subscriptions.create(new Action0() {\n+\n+                        @Override\n+                        public void call() {\n+                            System.out.println(\"*** unsubscribed\");\n+                            unsubscribed.set(true);\n+                        }\n+\n+                    });\n+\n+                    new Thread(new Runnable() {\n+\n+                        @Override\n+                        public void run() {\n+\n+                            while (!unsubscribed.get()) {\n+                                observer.onNext(Observable.from(1L, 2L));\n+                            }\n+                            System.out.println(\"Done looping after unsubscribe: \" + unsubscribed.get());\n+                            observer.onCompleted();\n+\n+                            // mark that the thread is finished\n+                            latch.countDown();\n+                        }\n+                    }).start();\n+\n+                    return s;\n+                };\n+\n+            });\n+\n+            final AtomicInteger count = new AtomicInteger();\n+            Observable.create(merge(source)).take(6).toBlockingObservable().forEach(new Action1<Long>() {\n+\n+                @Override\n+                public void call(Long v) {\n+                    System.out.println(\"Value: \" + v);\n+                    int c = count.incrementAndGet();\n+                    if (c > 6) {\n+                        fail(\"Should be only 6\");\n+                    }\n+\n+                }\n+            });\n+\n+            latch.await(1000, TimeUnit.MILLISECONDS);\n+\n+            System.out.println(\"unsubscribed: \" + unsubscribed.get());\n+\n+            assertTrue(unsubscribed.get());\n+\n+        }\n+\n         @Test\n         public void testMergeArrayWithThreading() {\n             final TestASynchronousObservable o1 = new TestASynchronousObservable();\n@@ -453,9 +525,9 @@ public void onNext(String v) {\n             // so I'm unfortunately reverting to using a Thread.sleep to allow the process scheduler time\n             // to make sure after o1.onNextBeingSent and o2.onNextBeingSent are hit that the following\n             // onNext is invoked.\n-            \n+\n             Thread.sleep(300);\n-            \n+\n             try { // in try/finally so threads are released via latch countDown even if assertion fails\n                 assertEquals(1, concurrentCounter.get());\n             } finally {",
      "parent_sha": "dc7a3f8f575edc28d86daa2039715866059a574d"
    }
  },
  {
    "oid": "0977f040a403bec9f5818247a9dc29fa649b2e19",
    "message": "Fix Deprecated Method Call",
    "date": "2013-12-31T04:30:43Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/0977f040a403bec9f5818247a9dc29fa649b2e19",
    "details": {
      "sha": "a4cc789cd47a5be765901c6be8d4e5e00c2a2e13",
      "filename": "rxjava-core/src/main/java/rx/Scheduler.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/0977f040a403bec9f5818247a9dc29fa649b2e19/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FScheduler.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/0977f040a403bec9f5818247a9dc29fa649b2e19/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FScheduler.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FScheduler.java?ref=0977f040a403bec9f5818247a9dc29fa649b2e19",
      "patch": "@@ -165,7 +165,7 @@ public Subscription call(final Scheduler scheduler, final Func2 parentAction) {\n                     @Override\n                     public void call() {\n                         if (!parentSubscription.isUnsubscribed()) {\n-                            childSubscription.setSubscription(scheduler.schedule(parentAction, parentAction));\n+                            childSubscription.set(scheduler.schedule(parentAction, parentAction));\n                         }\n                     }\n ",
      "parent_sha": "93d4e693194973c93e2f7e6fc0f4ca72208f8c24"
    }
  },
  {
    "oid": "95efbff863bc20bcfd49da00db5bca95d5c059d7",
    "message": "Ensure time is always updated",
    "date": "2013-07-21T10:08:14Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/95efbff863bc20bcfd49da00db5bca95d5c059d7",
    "details": {
      "sha": "739c6cb6b45c8fc4fb05e541feaca87060db1141",
      "filename": "rxjava-core/src/main/java/rx/concurrency/TestScheduler.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/95efbff863bc20bcfd49da00db5bca95d5c059d7/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fconcurrency%2FTestScheduler.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/95efbff863bc20bcfd49da00db5bca95d5c059d7/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fconcurrency%2FTestScheduler.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fconcurrency%2FTestScheduler.java?ref=95efbff863bc20bcfd49da00db5bca95d5c059d7",
      "patch": "@@ -80,14 +80,14 @@ private void triggerActions(long targetTimeInNanos) {\n         while (!queue.isEmpty()) {\n             TimedAction<?> current = queue.peek();\n             if (current.time > targetTimeInNanos) {\n-                time = targetTimeInNanos;\n                 break;\n             }\n             time = current.time;\n             queue.remove();\n             // because the queue can have wildcards we have to ignore the type T for the state\n             ((Func2<Scheduler, Object, Subscription>) current.action).call(current.scheduler, current.state);\n         }\n+        time = targetTimeInNanos;\n     }\n \n     @Override",
      "parent_sha": "0adf8e24335b46ab9c00851d36e37558e5099f51"
    }
  },
  {
    "oid": "9520d6328687bb3ab259097c4b203bfc0ec262df",
    "message": "Remove line break",
    "date": "2014-02-07T04:07:27Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/9520d6328687bb3ab259097c4b203bfc0ec262df",
    "details": {
      "sha": "7355a538ad1bd3f0181401ece4997fce22a328f9",
      "filename": "rxjava-core/src/main/java/rx/operators/OperatorSubscribeOn.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/9520d6328687bb3ab259097c4b203bfc0ec262df/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperatorSubscribeOn.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/9520d6328687bb3ab259097c4b203bfc0ec262df/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperatorSubscribeOn.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperatorSubscribeOn.java?ref=9520d6328687bb3ab259097c4b203bfc0ec262df",
      "patch": "@@ -38,8 +38,7 @@ public OperatorSubscribeOn(Scheduler scheduler) {\n     }\n \n     @Override\n-    public Subscriber<? super Observable<T>> call(\n-            final Subscriber<? super T> subscriber) {\n+    public Subscriber<? super Observable<T>> call(final Subscriber<? super T> subscriber) {\n         return new Subscriber<Observable<T>>() {\n \n             @Override",
      "parent_sha": "53e102d5182de8f182ee440fe98d725e31162125"
    }
  },
  {
    "oid": "be81b70ba7434cfb1af3d855d0b6c9b600c0c4ac",
    "message": "Change @coded tag to @code tag (#7463)\n\nCo-authored-by: Ruben Novelli <rnovelli@redhat.com>",
    "date": "2022-08-17T08:20:13Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/be81b70ba7434cfb1af3d855d0b6c9b600c0c4ac",
    "details": {
      "sha": "6944611a899204df15ef687addcb71601bb293f1",
      "filename": "src/main/java/io/reactivex/rxjava3/core/Flowable.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/be81b70ba7434cfb1af3d855d0b6c9b600c0c4ac/src%2Fmain%2Fjava%2Fio%2Freactivex%2Frxjava3%2Fcore%2FFlowable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/be81b70ba7434cfb1af3d855d0b6c9b600c0c4ac/src%2Fmain%2Fjava%2Fio%2Freactivex%2Frxjava3%2Fcore%2FFlowable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Fio%2Freactivex%2Frxjava3%2Fcore%2FFlowable.java?ref=be81b70ba7434cfb1af3d855d0b6c9b600c0c4ac",
      "patch": "@@ -15816,7 +15816,7 @@ public final Disposable subscribe(@NonNull Consumer<? super T> onNext, @NonNull\n      * terminates or this particular {@code Disposable} is disposed, the {@code Subscriber} is removed\n      * from the given container.\n      * <p>\n-     * The {@coded Subscriber} will be removed after the callback for the terminal event has been invoked.\n+     * The {@code Subscriber} will be removed after the callback for the terminal event has been invoked.\n      * <dl>\n      *  <dt><b>Backpressure:</b></dt>\n      *  <dd>The operator consumes the current {@code Flowable} in an unbounded manner (i.e., no",
      "parent_sha": "fb5b694dccedb51465becdc6d1a2567859a986b5"
    }
  },
  {
    "oid": "1f47d1180fcda01ecbcc53084d523658c5651793",
    "message": "startWith(observable) marble diagram",
    "date": "2014-03-06T17:59:40Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/1f47d1180fcda01ecbcc53084d523658c5651793",
    "details": {
      "sha": "33d64089fa23fcca5ff5c0fdeb1a02acaf491ba9",
      "filename": "rxjava-core/src/main/java/rx/Observable.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/1f47d1180fcda01ecbcc53084d523658c5651793/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/1f47d1180fcda01ecbcc53084d523658c5651793/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java?ref=1f47d1180fcda01ecbcc53084d523658c5651793",
      "patch": "@@ -6449,10 +6449,10 @@ public final Observable<T> skipWhileWithIndex(Func2<? super T, Integer, Boolean>\n     }\n \n     /**\n-     * Returns an Observable that emits the items in a specified {@link Observable} before it begins to emit items\n-     * emitted by the source Observable. \n+     * Returns an Observable that emits the items in a specified {@link Observable} before it begins to emit\n+     * items emitted by the source Observable. \n      * <p>\n-     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/startWith.png\">\n+     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/startWith.o.png\">\n      * \n      * @param values\n      *            an Observable that contains the items you want the modified Observable to emit first",
      "parent_sha": "18916d14c32d6db33be372259aba5c3e799696d5"
    }
  },
  {
    "oid": "bdfd9fe1191ca9620c365e830b16ca3ad7414c6f",
    "message": "TestSubscriber: Default onError and Terminal Latch Behavior",
    "date": "2014-02-25T22:11:29Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/bdfd9fe1191ca9620c365e830b16ca3ad7414c6f",
    "details": {
      "sha": "97966b8ebd508f11acc65b5855e09c33f8460db8",
      "filename": "rxjava-core/src/main/java/rx/observers/TestSubscriber.java",
      "status": "modified",
      "additions": 28,
      "deletions": 5,
      "changes": 33,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/bdfd9fe1191ca9620c365e830b16ca3ad7414c6f/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fobservers%2FTestSubscriber.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/bdfd9fe1191ca9620c365e830b16ca3ad7414c6f/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fobservers%2FTestSubscriber.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fobservers%2FTestSubscriber.java?ref=bdfd9fe1191ca9620c365e830b16ca3ad7414c6f",
      "patch": "@@ -41,13 +41,33 @@ public TestSubscriber(Observer<T> delegate) {\n     }\n \n     public TestSubscriber() {\n-        this.testObserver = new TestObserver<T>(Subscribers.<T> empty());\n+        this.testObserver = new TestObserver<T>(new Observer<T>() {\n+\n+            @Override\n+            public void onCompleted() {\n+                // do nothing\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+                // do nothing\n+            }\n+\n+            @Override\n+            public void onNext(T t) {\n+                // do nothing\n+            }\n+\n+        });\n     }\n \n     @Override\n     public void onCompleted() {\n-        testObserver.onCompleted();\n-        latch.countDown();\n+        try {\n+            testObserver.onCompleted();\n+        } finally {\n+            latch.countDown();\n+        }\n     }\n \n     public List<Notification<T>> getOnCompletedEvents() {\n@@ -56,8 +76,11 @@ public List<Notification<T>> getOnCompletedEvents() {\n \n     @Override\n     public void onError(Throwable e) {\n-        testObserver.onError(e);\n-        latch.countDown();\n+        try {\n+            testObserver.onError(e);\n+        } finally {\n+            latch.countDown();\n+        }\n     }\n \n     public List<Throwable> getOnErrorEvents() {",
      "parent_sha": "886caeb4e968dd4e6b327fae26186910fd938946"
    }
  },
  {
    "oid": "1f2ece0b87643506a9d88175b23b513ea60e148b",
    "message": "add unit test to ensure that range with count of 0 sends onComplete even when initial request is 0",
    "date": "2015-04-20T11:23:27Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/1f2ece0b87643506a9d88175b23b513ea60e148b",
    "details": {
      "sha": "aea7a367304bd4ea448ad549419d08b4cea22cea",
      "filename": "src/test/java/rx/internal/operators/OnSubscribeRangeTest.java",
      "status": "modified",
      "additions": 30,
      "deletions": 1,
      "changes": 31,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/1f2ece0b87643506a9d88175b23b513ea60e148b/src%2Ftest%2Fjava%2Frx%2Finternal%2Foperators%2FOnSubscribeRangeTest.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/1f2ece0b87643506a9d88175b23b513ea60e148b/src%2Ftest%2Fjava%2Frx%2Finternal%2Foperators%2FOnSubscribeRangeTest.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Ftest%2Fjava%2Frx%2Finternal%2Foperators%2FOnSubscribeRangeTest.java?ref=1f2ece0b87643506a9d88175b23b513ea60e148b",
      "patch": "@@ -17,6 +17,7 @@\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.times;\n@@ -26,6 +27,7 @@\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.junit.Test;\n@@ -77,7 +79,7 @@ public void call(Integer t1) {\n     }\n \n     @Test\n-    public void testRangeWithOverflow() {\n+    public void testRangeWithZero() {\n         Observable.range(1, 0);\n     }\n \n@@ -220,4 +222,31 @@ public void onNext(Integer t) {\n             }});\n         assertEquals(n, count.get());\n     }\n+    \n+    @Test\n+    public void testEmptyRangeSendsOnCompleteEagerlyWithRequestZero() {\n+        final AtomicBoolean completed = new AtomicBoolean(false);\n+        Observable.range(1, 0).subscribe(new Subscriber<Integer>() {\n+\n+            @Override\n+            public void onStart() {\n+                request(0);\n+            }\n+            \n+            @Override\n+            public void onCompleted() {\n+                completed.set(true);\n+            }\n+\n+            @Override\n+            public void onError(Throwable e) {\n+                \n+            }\n+\n+            @Override\n+            public void onNext(Integer t) {\n+                \n+            }});\n+        assertTrue(completed.get());\n+    }\n }",
      "parent_sha": "aefdebb49b657eb698d2cb77681495611bd8e72e"
    }
  },
  {
    "oid": "581b19f0fef9fbd7f4a5e2d6569b8eca09bf28e1",
    "message": "Fix multiple subscription bug on operation filter\n\nA new subscription must be created on every subscribe call, otherwise any\nsubscribe call after the first directly fails.",
    "date": "2013-05-01T20:13:12Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/581b19f0fef9fbd7f4a5e2d6569b8eca09bf28e1",
    "details": {
      "sha": "64cd70d1ffc3ed04d4fb6d7eecb8e3856de23c4a",
      "filename": "rxjava-core/src/main/java/rx/operators/OperationFilter.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/581b19f0fef9fbd7f4a5e2d6569b8eca09bf28e1/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationFilter.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/581b19f0fef9fbd7f4a5e2d6569b8eca09bf28e1/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationFilter.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationFilter.java?ref=581b19f0fef9fbd7f4a5e2d6569b8eca09bf28e1",
      "patch": "@@ -37,14 +37,14 @@ private static class Filter<T> implements Func1<Observer<T>, Subscription> {\n \n         private final Observable<T> that;\n         private final Func1<T, Boolean> predicate;\n-        private final AtomicObservableSubscription subscription = new AtomicObservableSubscription();\n \n         public Filter(Observable<T> that, Func1<T, Boolean> predicate) {\n             this.that = that;\n             this.predicate = predicate;\n         }\n \n         public Subscription call(final Observer<T> observer) {\n+            final AtomicObservableSubscription subscription = new AtomicObservableSubscription();\n             return subscription.wrap(that.subscribe(new Observer<T>() {\n                 public void onNext(T value) {\n                     try {",
      "parent_sha": "bc3b13bc875b486fcaddcbd2a8aca9e3817e47a2"
    }
  },
  {
    "oid": "b9d5a4db85b88250e52666a08155af5bff312a2e",
    "message": "Mark VolatileSizeArrayList as RandomAccess list (#5324)",
    "date": "2017-05-01T11:54:16Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/b9d5a4db85b88250e52666a08155af5bff312a2e",
    "details": {
      "sha": "45744c991fef8b43a51b2b6edfc757c6a80deca0",
      "filename": "src/main/java/io/reactivex/internal/util/VolatileSizeArrayList.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/b9d5a4db85b88250e52666a08155af5bff312a2e/src%2Fmain%2Fjava%2Fio%2Freactivex%2Finternal%2Futil%2FVolatileSizeArrayList.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/b9d5a4db85b88250e52666a08155af5bff312a2e/src%2Fmain%2Fjava%2Fio%2Freactivex%2Finternal%2Futil%2FVolatileSizeArrayList.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Fio%2Freactivex%2Finternal%2Futil%2FVolatileSizeArrayList.java?ref=b9d5a4db85b88250e52666a08155af5bff312a2e",
      "patch": "@@ -22,7 +22,7 @@\n  * @param <T> the element type\n  * @since 2.0.7\n  */\n-public final class VolatileSizeArrayList<T> extends AtomicInteger implements List<T> {\n+public final class VolatileSizeArrayList<T> extends AtomicInteger implements List<T>, RandomAccess {\n \n     private static final long serialVersionUID = 3972397474470203923L;\n ",
      "parent_sha": "3c0e82429081f0bc534dbb5d76e3240ce58a8480"
    }
  },
  {
    "oid": "8e27cdcf85eb07e2417a37947c8708980b83845c",
    "message": "Fixed up SafeObserverTest w.r.t. CompositeException changes",
    "date": "2014-06-25T23:19:52Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/8e27cdcf85eb07e2417a37947c8708980b83845c",
    "details": {
      "sha": "584c6ee11745262afce45c6043a20dbcfea82b7a",
      "filename": "rxjava-core/src/test/java/rx/observers/SafeObserverTest.java",
      "status": "modified",
      "additions": 36,
      "deletions": 31,
      "changes": 67,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/8e27cdcf85eb07e2417a37947c8708980b83845c/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Fobservers%2FSafeObserverTest.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/8e27cdcf85eb07e2417a37947c8708980b83845c/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Fobservers%2FSafeObserverTest.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Fobservers%2FSafeObserverTest.java?ref=8e27cdcf85eb07e2417a37947c8708980b83845c",
      "patch": "@@ -21,6 +21,7 @@\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n \n+import java.util.List;\n import java.util.concurrent.atomic.AtomicReference;\n \n import org.junit.Test;\n@@ -109,15 +110,16 @@ public void onErrorFailureSafe() {\n \n             Throwable e2 = e.getCause();\n             assertTrue(e2 instanceof CompositeException);\n-            assertEquals(\"Chain of Causes for CompositeException In Order Received =>\", e2.getCause().getMessage());\n+            List<Throwable> innerExceptions = ((CompositeException) e2).getExceptions();\n+            assertEquals(2, innerExceptions.size());\n \n-            Throwable e3 = e2.getCause();\n-            assertTrue(e3.getCause() instanceof SafeObserverTestException);\n-            assertEquals(\"error!\", e3.getCause().getMessage());\n+            Throwable e3 = innerExceptions.get(0);\n+            assertTrue(e3 instanceof SafeObserverTestException);\n+            assertEquals(\"error!\", e3.getMessage());\n \n-            Throwable e4 = e3.getCause();\n-            assertTrue(e4.getCause() instanceof SafeObserverTestException);\n-            assertEquals(\"onErrorFail\", e4.getCause().getMessage());\n+            Throwable e4 = innerExceptions.get(1);\n+            assertTrue(e4 instanceof SafeObserverTestException);\n+            assertEquals(\"onErrorFail\", e4.getMessage());\n         }\n     }\n \n@@ -157,15 +159,16 @@ public void onNextOnErrorFailureSafe() {\n \n             Throwable e2 = e.getCause();\n             assertTrue(e2 instanceof CompositeException);\n-            assertEquals(\"Chain of Causes for CompositeException In Order Received =>\", e2.getCause().getMessage());\n+            List<Throwable> innerExceptions = ((CompositeException) e2).getExceptions();\n+            assertEquals(2, innerExceptions.size());\n \n-            Throwable e3 = e2.getCause();\n-            assertTrue(e3.getCause() instanceof SafeObserverTestException);\n-            assertEquals(\"onNextFail\", e3.getCause().getMessage());\n+            Throwable e3 = innerExceptions.get(0);\n+            assertTrue(e3 instanceof SafeObserverTestException);\n+            assertEquals(\"onNextFail\", e3.getMessage());\n \n-            Throwable e4 = e3.getCause();\n-            assertTrue(e4.getCause() instanceof SafeObserverTestException);\n-            assertEquals(\"onErrorFail\", e4.getCause().getMessage());\n+            Throwable e4 = innerExceptions.get(1);\n+            assertTrue(e4 instanceof SafeObserverTestException);\n+            assertEquals(\"onErrorFail\", e4.getMessage());\n         }\n     }\n \n@@ -251,19 +254,20 @@ public void call() {\n \n             Throwable e2 = e.getCause();\n             assertTrue(e2 instanceof CompositeException);\n-            assertEquals(\"Chain of Causes for CompositeException In Order Received =>\", e2.getCause().getMessage());\n+            List<Throwable> innerExceptions = ((CompositeException) e2).getExceptions();\n+            assertEquals(3, innerExceptions.size());\n \n-            Throwable e3 = e2.getCause();\n-            assertTrue(e3.getCause() instanceof SafeObserverTestException);\n-            assertEquals(\"onError failure\", e3.getCause().getMessage());\n+            Throwable e3 = innerExceptions.get(0);\n+            assertTrue(e3 instanceof SafeObserverTestException);\n+            assertEquals(\"onError failure\", e3.getMessage());\n \n-            Throwable e4 = e3.getCause();\n-            assertTrue(e4.getCause() instanceof SafeObserverTestException);\n-            assertEquals(\"onErrorFail\", e4.getCause().getMessage());\n+            Throwable e4 = innerExceptions.get(1);\n+            assertTrue(e4 instanceof SafeObserverTestException);\n+            assertEquals(\"onErrorFail\", e4.getMessage());\n \n-            Throwable e5 = e4.getCause();\n-            assertTrue(e5.getCause() instanceof SafeObserverTestException);\n-            assertEquals(\"failure from unsubscribe\", e5.getCause().getMessage());\n+            Throwable e5 = innerExceptions.get(2);\n+            assertTrue(e5 instanceof SafeObserverTestException);\n+            assertEquals(\"failure from unsubscribe\", e5.getMessage());\n         }\n     }\n \n@@ -292,15 +296,16 @@ public void call() {\n \n             Throwable e2 = e.getCause();\n             assertTrue(e2 instanceof CompositeException);\n-            assertEquals(\"Chain of Causes for CompositeException In Order Received =>\", e2.getCause().getMessage());\n+            List<Throwable> innerExceptions = ((CompositeException) e2).getExceptions();\n+            assertEquals(2, innerExceptions.size());\n \n-            Throwable e3 = e2.getCause();\n-            assertTrue(e3.getCause() instanceof SafeObserverTestException);\n-            assertEquals(\"error!\", e3.getCause().getMessage());\n+            Throwable e3 = innerExceptions.get(0);\n+            assertTrue(e3 instanceof SafeObserverTestException);\n+            assertEquals(\"error!\", e3.getMessage());\n \n-            Throwable e4 = e3.getCause();\n-            assertTrue(e4.getCause() instanceof SafeObserverTestException);\n-            assertEquals(\"failure from unsubscribe\", e4.getCause().getMessage());\n+            Throwable e4 = innerExceptions.get(1);\n+            assertTrue(e4 instanceof SafeObserverTestException);\n+            assertEquals(\"failure from unsubscribe\", e4.getMessage());\n         }\n     }\n ",
      "parent_sha": "3b95e2fb1f2b1e7db3330acae8725e3aad9539da"
    }
  },
  {
    "oid": "77ac15bb78fd9bc4f698edd44bbd88a55907a2b8",
    "message": "No longer using Notification<T> for scheduling throttled events.",
    "date": "2013-05-05T09:23:24Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/77ac15bb78fd9bc4f698edd44bbd88a55907a2b8",
    "details": {
      "sha": "5badf0858c2866484c283fb352c995e7691aec9b",
      "filename": "rxjava-core/src/main/java/rx/operators/OperationThrottle.java",
      "status": "modified",
      "additions": 47,
      "deletions": 21,
      "changes": 68,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/77ac15bb78fd9bc4f698edd44bbd88a55907a2b8/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationThrottle.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/77ac15bb78fd9bc4f698edd44bbd88a55907a2b8/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationThrottle.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationThrottle.java?ref=77ac15bb78fd9bc4f698edd44bbd88a55907a2b8",
      "patch": "@@ -15,8 +15,13 @@\n  */\n package rx.operators;\n \n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n \n import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n@@ -27,7 +32,6 @@\n import org.junit.Test;\n import org.mockito.InOrder;\n \n-import rx.Notification;\n import rx.Observable;\n import rx.Observer;\n import rx.Scheduler;\n@@ -119,25 +123,25 @@ public ThrottledObserver(Observer<T> observer, long timeout, TimeUnit unit, Sche\n \n         @Override\n         public void onCompleted() {\n-            throttle(new Notification<T>());\n+            throttle(new ThrottledOnComplete<T>(observer));\n         }\n \n         @Override\n         public void onError(Exception e) {\n-            throttle(new Notification<T>(e));\n+            throttle(new ThrottledOnError<T>(observer, e));\n         }\n \n         @Override\n         public void onNext(final T args) {\n-            throttle(new Notification<T>(args));\n+            throttle(new ThrottledOnNext<T>(observer, args));\n         }\n \n-        private void throttle(final Notification<T> args) {\n+        private void throttle(Action0 action) {\n             synchronized (subscription) {\n                 if (!timerHasExpired()) {\n                     subscription.get().unsubscribe();\n                 }\n-                subscription.set(scheduler.schedule(new ThrottleAction<T>(observer, args), timeout, unit));\n+                subscription.set(scheduler.schedule(action, timeout, unit));\n             }\n         }\n \n@@ -149,27 +153,49 @@ private boolean timerHasExpired() {\n         }\n     }\n \n-    private static final class ThrottleAction<T> implements Action0 {\n+    private static final class ThrottledOnNext<T> implements Action0 {\n \n         private final Observer<T> observer;\n-        private final Notification<T> notification;\n+        private final T value;\n \n-        public ThrottleAction(Observer<T> observer, Notification<T> notification) {\n+        public ThrottledOnNext(Observer<T> observer, T value) {\n             this.observer = observer;\n-            this.notification = notification;\n+            this.value = value;\n         }\n \n         @Override\n         public void call() {\n-            if (notification.isOnNext()) {\n-                observer.onNext(notification.getValue());\n-            }\n-            else if (notification.isOnError()) {\n-                observer.onError(notification.getException());\n-            }\n-            else if (notification.isOnCompleted()) {\n-                observer.onCompleted();\n-            }\n+            observer.onNext(value);\n+        }\n+    }\n+\n+    private static final class ThrottledOnError<T> implements Action0 {\n+\n+        private final Observer<T> observer;\n+        private final Exception error;\n+\n+        public ThrottledOnError(Observer<T> observer, Exception error) {\n+            this.observer = observer;\n+            this.error = error;\n+        }\n+\n+        @Override\n+        public void call() {\n+            observer.onError(error);\n+        }\n+    }\n+\n+    private static final class ThrottledOnComplete<T> implements Action0 {\n+\n+        private final Observer<T> observer;\n+\n+        public ThrottledOnComplete(Observer<T> observer) {\n+            this.observer = observer;\n+        }\n+\n+        @Override\n+        public void call() {\n+            observer.onCompleted();\n         }\n     }\n ",
      "parent_sha": "622d861efea555e98600f165f6521afd7f4084c0"
    }
  },
  {
    "oid": "3c244fbc0c3782e318f36fbfe0bec91c0fcf0fe1",
    "message": "Set setDaemon on NewThreadScheduler",
    "date": "2014-02-06T13:19:35Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/3c244fbc0c3782e318f36fbfe0bec91c0fcf0fe1",
    "details": {
      "sha": "00639b93c0c8eba910cda5c00d43d156d853cbbe",
      "filename": "rxjava-core/src/main/java/rx/schedulers/NewThreadScheduler.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/3c244fbc0c3782e318f36fbfe0bec91c0fcf0fe1/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fschedulers%2FNewThreadScheduler.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/3c244fbc0c3782e318f36fbfe0bec91c0fcf0fe1/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fschedulers%2FNewThreadScheduler.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fschedulers%2FNewThreadScheduler.java?ref=3c244fbc0c3782e318f36fbfe0bec91c0fcf0fe1",
      "patch": "@@ -40,7 +40,9 @@ public class NewThreadScheduler extends Scheduler {\n \n         @Override\n         public Thread newThread(Runnable r) {\n-            return new Thread(r, \"RxNewThreadScheduler-\" + count.incrementAndGet());\n+            Thread t = new Thread(r, \"RxNewThreadScheduler-\" + count.incrementAndGet());\n+            t.setDaemon(true);\n+            return t;\n         }\n     };\n ",
      "parent_sha": "a797c56757090db854f0a446cc3364d6a6e8d4d5"
    }
  },
  {
    "oid": "17529d01162b56024c571200b2e4f27744d03fef",
    "message": "(#1230) javadocs for serialize()\nalso some improvements to javadocs for share()",
    "date": "2014-05-20T18:12:32Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/17529d01162b56024c571200b2e4f27744d03fef",
    "details": {
      "sha": "0e6818ff912fec983aaf0d079bfc59ce1048901e",
      "filename": "rxjava-core/src/main/java/rx/Observable.java",
      "status": "modified",
      "additions": 16,
      "deletions": 4,
      "changes": 20,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/17529d01162b56024c571200b2e4f27744d03fef/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/17529d01162b56024c571200b2e4f27744d03fef/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java?ref=17529d01162b56024c571200b2e4f27744d03fef",
      "patch": "@@ -5318,24 +5318,36 @@ public final <R> Observable<R> scan(R initialValue, Func2<R, ? super T, R> accum\n     }\n \n     /*\n+     * Forces an Observable to make synchronous calls and to be well-behaved.\n+     * <p>\n+     * It is possible for an Observable to invoke its Subscribers' methods asynchronously, perhaps in different\n+     * threads. This could make an Observable poorly-behaved, in that it might invoke {@code onCompleted} or\n+     * {@code onError} before one of its {@code onNext} invocations. You can force such an Observable to be\n+     * well-behaved and synchronous by applying the {@code serialize()} method to it.\n+     * <p>\n+     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/synchronize.png\">\n+     *\n+     * @return a {@link Observable} that is guaranteed to be well-behaved and synchronous\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#serialize\">RxJava Wiki: serialize()</a>\n      * @since 0.17\n      */\n     public final Observable<T> serialize() {\n         return lift(new OperatorSerialize<T>());\n     }\n \n     /**\n-     * Returns a new {@link Observable} that multicasts (shares) the original {@link Observable}. \n-     * As long as there is more than 1 {@link Subscriber} this {@link Observable} will be subscribed and emitting data. \n+     * Returns a new {@link Observable} that multicasts (shares) the original {@link Observable}. As long as\n+     * there is more than 1 {@link Subscriber} this {@link Observable} will be subscribed and emitting data. \n      * When all subscribers have unsubscribed it will unsubscribe from the source {@link Observable}. \n      * <p>\n      * This is an alias for {@link #publish().refCount()}.\n      * <p>\n-     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/publishConnect.png\">\n+     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/publishRefCount.png\">\n      * \n      * @return a {@link Observable} that upon connection causes the source Observable to emit items\n      *         to its {@link Observer}s\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#wiki-observablepublish-and-observablemulticast\">RxJava Wiki: publish()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#connectableobservablerefcount\">RxJava Wiki: refCount()</a>\n+     * @since 0.19\n      */\n     public final Observable<T> share() {\n         return publish().refCount();",
      "parent_sha": "1e07ccc2bc95eb43b734f505b808c0f41d7cd344"
    }
  },
  {
    "oid": "387c765e345c46a74a403aa2b8e3b7c634864087",
    "message": "Switch to AtomicIntegerFieldUpdater and volatile int, instead of AtomicBoolean",
    "date": "2014-05-28T19:44:47Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/387c765e345c46a74a403aa2b8e3b7c634864087",
    "details": {
      "sha": "2feba948fb7a05247fd4ab773afcfcb8ebf4b059",
      "filename": "rxjava-core/src/main/java/rx/schedulers/CachedThreadScheduler.java",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/387c765e345c46a74a403aa2b8e3b7c634864087/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fschedulers%2FCachedThreadScheduler.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/387c765e345c46a74a403aa2b8e3b7c634864087/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fschedulers%2FCachedThreadScheduler.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fschedulers%2FCachedThreadScheduler.java?ref=387c765e345c46a74a403aa2b8e3b7c634864087",
      "patch": "@@ -23,7 +23,7 @@\n \n import java.util.Iterator;\n import java.util.concurrent.*;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n \n /* package */class CachedThreadScheduler extends Scheduler {\n     private static final String WORKER_THREAD_NAME_PREFIX = \"RxCachedThreadScheduler-\";\n@@ -109,15 +109,17 @@ public Worker createWorker() {\n     private static class EventLoopWorker extends Scheduler.Worker {\n         private final CompositeSubscription innerSubscription = new CompositeSubscription();\n         private final PoolWorker poolWorker;\n-        private final AtomicBoolean releasePoolWorkerOnce = new AtomicBoolean(false);\n+        volatile int once;\n+        static final AtomicIntegerFieldUpdater<EventLoopWorker> ONCE_UPDATER\n+                = AtomicIntegerFieldUpdater.newUpdater(EventLoopWorker.class, \"once\");\n \n         EventLoopWorker(PoolWorker poolWorker) {\n             this.poolWorker = poolWorker;\n         }\n \n         @Override\n         public void unsubscribe() {\n-            if (releasePoolWorkerOnce.compareAndSet(false, true)) {\n+            if (ONCE_UPDATER.compareAndSet(this, 0, 1)) {\n                 // unsubscribe should be idempotent, so only do this once\n                 CachedWorkerPool.INSTANCE.release(poolWorker);\n             }",
      "parent_sha": "564ce4a1d26504324df384a4437ddb8107e9786a"
    }
  },
  {
    "oid": "60656e53c955e70bacd773f540c151b4aa36c188",
    "message": "Restore timeout on the test.",
    "date": "2014-11-25T11:13:22Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/60656e53c955e70bacd773f540c151b4aa36c188",
    "details": {
      "sha": "747d022c4f2374a2ba88bfb8d8d440fe01f4b6d9",
      "filename": "src/test/java/rx/internal/operators/OperatorRetryTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/60656e53c955e70bacd773f540c151b4aa36c188/src%2Ftest%2Fjava%2Frx%2Finternal%2Foperators%2FOperatorRetryTest.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/60656e53c955e70bacd773f540c151b4aa36c188/src%2Ftest%2Fjava%2Frx%2Finternal%2Foperators%2FOperatorRetryTest.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Ftest%2Fjava%2Frx%2Finternal%2Foperators%2FOperatorRetryTest.java?ref=60656e53c955e70bacd773f540c151b4aa36c188",
      "patch": "@@ -730,7 +730,7 @@ public Observable<String> call(GroupedObservable<String, String> t1) {\n         inOrder.verify(observer, times(1)).onCompleted();\n         inOrder.verifyNoMoreInteractions();\n     }\n-    @Test/*(timeout = 3000)*/\n+    @Test(timeout = 3000)\n     public void testIssue1900SourceNotSupportingBackpressure() {\n         @SuppressWarnings(\"unchecked\")\n         Observer<String> observer = mock(Observer.class);",
      "parent_sha": "a2556443f808f3a517eae7bc4ea32db92a863a3b"
    }
  },
  {
    "oid": "1d0d90c0e595490b0944a7eaf11e6e317c998267",
    "message": "Remove Validation of Ordering\n\n- this test does a flatMap which uses merge which has non-deterministic ordering since the Observable.from can be on a new thread each time",
    "date": "2014-01-02T04:55:43Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/1d0d90c0e595490b0944a7eaf11e6e317c998267",
    "details": {
      "sha": "ddf4f959a63761b0360c995828abefcf8942d2e9",
      "filename": "rxjava-core/src/test/java/rx/schedulers/AbstractSchedulerTests.java",
      "status": "modified",
      "additions": 5,
      "deletions": 4,
      "changes": 9,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/1d0d90c0e595490b0944a7eaf11e6e317c998267/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Fschedulers%2FAbstractSchedulerTests.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/1d0d90c0e595490b0944a7eaf11e6e317c998267/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Fschedulers%2FAbstractSchedulerTests.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Fschedulers%2FAbstractSchedulerTests.java?ref=1d0d90c0e595490b0944a7eaf11e6e317c998267",
      "patch": "@@ -198,10 +198,11 @@ public String call(String s) {\n         List<String> strings = m.toList().toBlockingObservable().last();\n \n         assertEquals(4, strings.size());\n-        assertEquals(\"names=>a-1\", strings.get(0));\n-        assertEquals(\"names=>b-1\", strings.get(1));\n-        assertEquals(\"names=>a-2\", strings.get(2));\n-        assertEquals(\"names=>b-2\", strings.get(3));\n+        // because flatMap does a merge there is no guarantee of order\n+        assertTrue(strings.contains(\"names=>a-1\"));\n+        assertTrue(strings.contains(\"names=>a-2\"));\n+        assertTrue(strings.contains(\"names=>b-1\"));\n+        assertTrue(strings.contains(\"names=>b-2\"));\n     }\n \n     @SuppressWarnings(\"rawtypes\")",
      "parent_sha": "9b3a838c02b433ed8fbed014a5565fcb5b800891"
    }
  },
  {
    "oid": "cf02e7190bab536b704e2f3c562dfaaabec83c4a",
    "message": "moved SwingObservable into the rx.observables package",
    "date": "2013-05-07T15:02:00Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/cf02e7190bab536b704e2f3c562dfaaabec83c4a",
    "details": {
      "sha": "90ddcbcfae32b494492097fb26f3257f758eb716",
      "filename": "rxjava-contrib/rxjava-swing/src/main/java/rx/observables/SwingObservable.java",
      "status": "renamed",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/cf02e7190bab536b704e2f3c562dfaaabec83c4a/rxjava-contrib%2Frxjava-swing%2Fsrc%2Fmain%2Fjava%2Frx%2Fobservables%2FSwingObservable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/cf02e7190bab536b704e2f3c562dfaaabec83c4a/rxjava-contrib%2Frxjava-swing%2Fsrc%2Fmain%2Fjava%2Frx%2Fobservables%2FSwingObservable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-contrib%2Frxjava-swing%2Fsrc%2Fmain%2Fjava%2Frx%2Fobservables%2FSwingObservable.java?ref=cf02e7190bab536b704e2f3c562dfaaabec83c4a",
      "patch": "@@ -13,7 +13,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package rx;\n+package rx.observables;\n \n import static rx.Observable.filter;\n \n@@ -25,6 +25,7 @@\n import javax.swing.AbstractButton;\n import javax.swing.JComponent;\n \n+import rx.Observable;\n import rx.swing.sources.AbstractButtonSource;\n import rx.swing.sources.KeyEventSource;\n import rx.swing.sources.MouseEventSource;",
      "previous_filename": "rxjava-contrib/rxjava-swing/src/main/java/rx/SwingObservable.java",
      "parent_sha": "7c400d4d9eab6457838da2c10aaff82a90d820d5"
    }
  },
  {
    "oid": "5ca76e032a66f77e3ea7ec2b793f50d1627572d3",
    "message": "Restore use of messagePrefix\n\nas per https://github.com/Netflix/RxJava/issues/1266",
    "date": "2014-07-24T07:30:50Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/5ca76e032a66f77e3ea7ec2b793f50d1627572d3",
    "details": {
      "sha": "60be66394302adcb343b8e87c495c3e980821bb1",
      "filename": "rxjava-core/src/main/java/rx/exceptions/CompositeException.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/5ca76e032a66f77e3ea7ec2b793f50d1627572d3/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fexceptions%2FCompositeException.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/5ca76e032a66f77e3ea7ec2b793f50d1627572d3/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fexceptions%2FCompositeException.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fexceptions%2FCompositeException.java?ref=5ca76e032a66f77e3ea7ec2b793f50d1627572d3",
      "patch": "@@ -45,7 +45,7 @@ public CompositeException(String messagePrefix, Collection<Throwable> errors) {\n             _exceptions.add(e);\n         }\n         this.exceptions = Collections.unmodifiableList(_exceptions);\n-        this.message = count + \" exceptions occurred. See them in causal chain below.\";\n+        this.message = messagePrefix + \" \" + count + \" exceptions occurred. See them in causal chain below.\";\n         this.cause = _cause;\n     }\n ",
      "parent_sha": "0f2cd15d6fa93bdbc337f2f2c235d56df168105d"
    }
  },
  {
    "oid": "ad1fbc2d108eccaa21ba11975dda8b25e4446fea",
    "message": "eliminate javadoc compiler warnings, add \"since\" stub",
    "date": "2015-08-07T22:59:03Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/ad1fbc2d108eccaa21ba11975dda8b25e4446fea",
    "details": {
      "sha": "79825d622b4dd5815b01e356e93a634e9c309495",
      "filename": "src/main/java/rx/Observable.java",
      "status": "modified",
      "additions": 5,
      "deletions": 4,
      "changes": 9,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/ad1fbc2d108eccaa21ba11975dda8b25e4446fea/src%2Fmain%2Fjava%2Frx%2FObservable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/ad1fbc2d108eccaa21ba11975dda8b25e4446fea/src%2Fmain%2Fjava%2Frx%2FObservable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Frx%2FObservable.java?ref=ad1fbc2d108eccaa21ba11975dda8b25e4446fea",
      "patch": "@@ -110,12 +110,13 @@ public interface Operator<R, T> extends Func1<Subscriber<? super R>, Subscriber<\n     }\n \n     /**\n-     * Passes all emitted values from {@code this} Observable to the provided {@link ConversionFunc} to be \n-     * collected and returned as a single value. Note that it is legal for a {@link ConversionFunc} to \n-     * return an Observable (enabling chaining). \n+     * Passes all emitted values from this Observable to the provided conversion function to be collected and\n+     * returned as a single value. Note that it is legal for a conversion function to return an Observable\n+     * (enabling chaining). \n      * \n      * @param conversion a function that converts from this {@code Observable<T>} to an {@code R}\n-     * @return an instance of R created by the provided Conversion\n+     * @return an instance of R created by the provided conversion function\n+     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)\n      */\n     @Experimental\n     public <R> R x(Func1<? super OnSubscribe<T>, ? extends R> conversion) {",
      "parent_sha": "97747fbf6abddcbd554e2158b352b3e1fef25725"
    }
  },
  {
    "oid": "dba41f09f5d3ec8460c5bded08f1558e3d3e7156",
    "message": "Simplify code; Junits",
    "date": "2013-12-05T18:15:38Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/dba41f09f5d3ec8460c5bded08f1558e3d3e7156",
    "details": {
      "sha": "563744ca818554f8bb4a5134c9c84d3227d18921",
      "filename": "rxjava-core/src/test/java/rx/subscriptions/SerialSubscriptionTests.java",
      "status": "modified",
      "additions": 27,
      "deletions": 4,
      "changes": 31,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/dba41f09f5d3ec8460c5bded08f1558e3d3e7156/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Fsubscriptions%2FSerialSubscriptionTests.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/dba41f09f5d3ec8460c5bded08f1558e3d3e7156/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Fsubscriptions%2FSerialSubscriptionTests.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Fsubscriptions%2FSerialSubscriptionTests.java?ref=dba41f09f5d3ec8460c5bded08f1558e3d3e7156",
      "patch": "@@ -18,31 +18,54 @@\n import static org.junit.Assert.fail;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n \n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.CountDownLatch;\n \n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.MockitoAnnotations;\n+import org.junit.runner.RunWith;\n+import org.mockito.runners.MockitoJUnitRunner;\n \n import rx.Subscription;\n \n+@RunWith(MockitoJUnitRunner.class)\n public class SerialSubscriptionTests {\n     private SerialSubscription serialSubscription;\n \n     @Before\n     public void setUp() {\n-        MockitoAnnotations.initMocks(this);\n-\n         serialSubscription = new SerialSubscription();\n     }\n \n     @Test\n     public void unsubscribingWithoutUnderlyingDoesNothing() {\n         serialSubscription.unsubscribe();\n     }\n+    \n+    @Test\n+    public void unsubscribingTwiceDoesUnsubscribeOnce() {\n+    \t Subscription underlying = mock(Subscription.class);\n+         serialSubscription.setSubscription(underlying);\n+         \n+         serialSubscription.unsubscribe();\n+         verify(underlying).unsubscribe();\n+         \n+         serialSubscription.unsubscribe();\n+         verifyNoMoreInteractions(underlying);\n+    }\n+    \n+    @Test\n+    public void settingSameSubscriptionTwiceDoesUnsubscribeIt() {\n+    \t Subscription underlying = mock(Subscription.class);\n+         serialSubscription.setSubscription(underlying);\n+         verifyZeroInteractions(underlying);\n+         serialSubscription.setSubscription(underlying);\n+         verify(underlying).unsubscribe();;\n+    }\n \n     @Test\n     public void unsubscribingWithSingleUnderlyingUnsubscribes() {\n@@ -117,7 +140,7 @@ public void run() {\n         verify(underlying).unsubscribe();\n \n         for (final Thread t : threads) {\n-            t.interrupt();\n+            t.join();\n         }\n     }\n }",
      "parent_sha": "d7bd8268c743a99e893d2239ad0919201f112e41"
    }
  },
  {
    "oid": "c694a2adaafa52514e88cfdf6379516c9494379a",
    "message": "Revert the change in recursiveAction",
    "date": "2015-02-09T12:51:14Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/c694a2adaafa52514e88cfdf6379516c9494379a",
    "details": {
      "sha": "9f9fa91a3c2a508478090be0f613b3a77c81285f",
      "filename": "src/main/java/rx/Scheduler.java",
      "status": "modified",
      "additions": 1,
      "deletions": 4,
      "changes": 5,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/c694a2adaafa52514e88cfdf6379516c9494379a/src%2Fmain%2Fjava%2Frx%2FScheduler.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/c694a2adaafa52514e88cfdf6379516c9494379a/src%2Fmain%2Fjava%2Frx%2FScheduler.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Frx%2FScheduler.java?ref=c694a2adaafa52514e88cfdf6379516c9494379a",
      "patch": "@@ -120,10 +120,7 @@ public void call() {\n                     if (!mas.isUnsubscribed()) {\n                         action.call();\n                         long nextTick = startInNanos + (++count * periodInNanos);\n-                        SerialSubscription s = new SerialSubscription();\n-                        // Should call `mas.set` before `schedule`, or the new Subscription may replace the old one.\n-                        mas.set(s);\n-                        s.set(schedule(this, nextTick - TimeUnit.MILLISECONDS.toNanos(now()), TimeUnit.NANOSECONDS));\n+                        mas.set(schedule(this, nextTick - TimeUnit.MILLISECONDS.toNanos(now()), TimeUnit.NANOSECONDS));\n                     }\n                 }\n             };",
      "parent_sha": "faf9d65f61ed0958e896c600198836ee1eb856f4"
    }
  },
  {
    "oid": "9979fa7438f4cf93951d98febba25b81938649d3",
    "message": "* corrects grammar of sequenceEqual() javadoc\n* updates link to wiki description of count()\n* adds sample(sampler) marble diagram/wiki link\n* adds longCount() marble diagram/wiki link",
    "date": "2013-12-09T21:04:58Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/9979fa7438f4cf93951d98febba25b81938649d3",
    "details": {
      "sha": "33e451d3d1184e245924185583c497ec3642f8c4",
      "filename": "rxjava-core/src/main/java/rx/Observable.java",
      "status": "modified",
      "additions": 12,
      "deletions": 10,
      "changes": 22,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/9979fa7438f4cf93951d98febba25b81938649d3/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/9979fa7438f4cf93951d98febba25b81938649d3/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java?ref=9979fa7438f4cf93951d98febba25b81938649d3",
      "patch": "@@ -2297,16 +2297,16 @@ public static <T> Observable<T> from(Future<? extends T> future, long timeout, T\n     }\n \n     /**\n-     * Returns an Observable that emits a Boolean value that indicate\n+     * Returns an Observable that emits a Boolean value that indicates\n      * whether two sequences are equal by comparing the elements pairwise.\n      * <p>\n      * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/sequenceEqual.png\">\n      * \n      * @param first the first Observable to compare\n      * @param second the second Observable to compare\n      * @param <T> the type of items emitted by each Observable\n-     * @return an Observable that emits a Boolean value that indicate\n-     *         whether two sequences are equal by comparing the elements pairwise.\n+     * @return an Observable that emits a Boolean value that indicates\n+     *         whether two sequences are equal by comparing the elements pairwise\n      * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#sequenceequal\">RxJava Wiki: sequenceEqual()</a>\n      */\n     public static <T> Observable<Boolean> sequenceEqual(Observable<? extends T> first, Observable<? extends T> second) {\n@@ -2322,7 +2322,7 @@ public Boolean call(T first, T second) {\n     }\n \n     /**\n-     * Returns an Observable that emits a Boolean value that indicate\n+     * Returns an Observable that emits a Boolean value that indicates\n      * whether two sequences are equal by comparing the elements pairwise\n      * based on the results of a specified equality function.\n      * <p>\n@@ -2333,8 +2333,8 @@ public Boolean call(T first, T second) {\n      * @param equality a function used to compare items emitted by both\n      *                 Observables\n      * @param <T> the type of items emitted by each Observable\n-     * @return an Observable that emits a Boolean value that indicate\n-     *         whether two sequences are equal by comparing the elements pairwise.\n+     * @return an Observable that emits a Boolean value that indicates\n+     *         whether two sequences are equal by comparing the elements pairwise\n      * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#sequenceequal\">RxJava Wiki: sequenceEqual()</a>\n      */\n     public static <T> Observable<Boolean> sequenceEqual(Observable<? extends T> first, Observable<? extends T> second, Func2<? super T, ? super T, Boolean> equality) {\n@@ -3871,7 +3871,7 @@ public Observable<T> reduce(Func2<T, T, T> accumulator) {\n      * \n      * @return an Observable that emits the number of counted elements of the\n      *         source Observable as its single item\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-Operators#count\">RxJava Wiki: count()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-Operators#count-and-longcount\">RxJava Wiki: count()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229470.aspx\">MSDN: Observable.Count</a>\n      * @see #longCount()\n      */\n@@ -4475,12 +4475,14 @@ public Observable<T> sample(long period, TimeUnit unit, Scheduler scheduler) {\n      * Return an Observable that emits the results of sampling the items\n      * emitted by this Observable when the <code>sampler</code>\n      * Observable produces an item or completes.\n+     * <p>\n+     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/sample.o.png\">\n      * \n      * @param sampler the Observable to use for sampling this\n-     * \n      * @return an Observable that emits the results of sampling the items\n      *         emitted by this Observable when the <code>sampler</code>\n      *         Observable produces an item or completes.\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Filtering-Observables#sample-or-throttlelast\">RxJava Wiki: sample()</a>\n      */\n     public <U> Observable<T> sample(Observable<U> sampler) {\n         return create(new OperationSample.SampleWithObservable<T, U>(this, sampler));\n@@ -5198,11 +5200,11 @@ public Observable<T> last() {\n      * Returns an Observable that counts the total number of items in the\n      * source Observable as a 64 bit long.\n      * <p>\n-     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/count.png\">\n+     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/longCount.png\">\n      * \n      * @return an Observable that emits the number of counted elements of the\n      *         source Observable as its single, 64 bit long item \n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-Operators#count\">RxJava Wiki: count()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-Operators#count-and-longcount\">RxJava Wiki: count()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229120.aspx\">MSDN: Observable.LongCount</a>\n      * @see #count()\n      */",
      "parent_sha": "a67d8a12cb4adab039c71de6a5865a49c439e292"
    }
  },
  {
    "oid": "2fa35e5569d0919c98178dbf4d26f1fb07b8d7d7",
    "message": "Updated ObservableBenchmark to follow better benchmarking practices",
    "date": "2014-03-13T20:26:05Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/2fa35e5569d0919c98178dbf4d26f1fb07b8d7d7",
    "details": {
      "sha": "5de2a022d7f9bd67560f4d112d5e91ece375369f",
      "filename": "rxjava-core/src/perf/java/rx/operators/ObservableBenchmark.java",
      "status": "modified",
      "additions": 62,
      "deletions": 87,
      "changes": 149,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/2fa35e5569d0919c98178dbf4d26f1fb07b8d7d7/rxjava-core%2Fsrc%2Fperf%2Fjava%2Frx%2Foperators%2FObservableBenchmark.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/2fa35e5569d0919c98178dbf4d26f1fb07b8d7d7/rxjava-core%2Fsrc%2Fperf%2Fjava%2Frx%2Foperators%2FObservableBenchmark.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fperf%2Fjava%2Frx%2Foperators%2FObservableBenchmark.java?ref=2fa35e5569d0919c98178dbf4d26f1fb07b8d7d7",
      "patch": "@@ -1,14 +1,12 @@\n package rx.operators;\n \n+import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.atomic.AtomicInteger;\n \n-import org.openjdk.jmh.annotations.GenerateMicroBenchmark;\n-import org.openjdk.jmh.runner.Runner;\n-import org.openjdk.jmh.runner.RunnerException;\n-import org.openjdk.jmh.runner.options.Options;\n-import org.openjdk.jmh.runner.options.OptionsBuilder;\n+import org.openjdk.jmh.annotations.*;\n \n+import org.openjdk.jmh.logic.BlackHole;\n import rx.Observable;\n import rx.Observable.OnSubscribe;\n import rx.Observable.Operator;\n@@ -19,107 +17,84 @@\n public class ObservableBenchmark {\n \n     @GenerateMicroBenchmark\n-    public void timeBaseline() {\n-        observableOfInts.subscribe(newObserver());\n-        awaitAllObservers();\n-    }\n-\n-    @GenerateMicroBenchmark\n-    public int timeMapIterate() {\n-        int x = 0;\n-        for (int j = 0; j < intValues.length; j++) {\n-            // use hash code to make sure the JIT doesn't optimize too much and remove all of\n-            // our code.\n-            x |= ident.call(intValues[j]).hashCode();\n+    public void measureBaseline(BlackHole bh, Input input) {\n+        for (Integer value : input.values) {\n+            bh.consume(IDENTITY_FUNCTION.call(value));\n         }\n-        return x;\n     }\n \n     @GenerateMicroBenchmark\n-    public void timeMap() {\n-        timeOperator(new OperatorMap<Integer, Object>(ident));\n+    public void measureMap(Input input) throws InterruptedException {\n+        input.observable.lift(MAP_OPERATOR).subscribe(input.observer);\n+\n+        input.awaitCompletion();\n     }\n \n-    /**************************************************************************\n-     * Below is internal stuff to avoid object allocation and time overhead of anything that isn't\n-     * being tested.\n-     * \n-     * @throws RunnerException\n-     **************************************************************************/\n+    private static final Func1<Integer, Integer> IDENTITY_FUNCTION = new Func1<Integer, Integer>() {\n+        @Override\n+        public Integer call(Integer value) {\n+            return value;\n+        }\n+    };\n \n-    public static void main(String[] args) throws RunnerException {\n-        Options opt = new OptionsBuilder()\n-                .include(ObservableBenchmark.class.getName()+\".*\")\n-                .forks(1)\n-                .build();\n+    private static final Operator<Integer, Integer> MAP_OPERATOR = new OperatorMap<Integer, Integer>(IDENTITY_FUNCTION);\n \n-        new Runner(opt).run();\n-    }\n+    @State(Scope.Thread)\n+    public static class Input {\n \n-    private void timeOperator(Operator<Object, Integer> op) {\n-        observableOfInts.lift(op).subscribe(newObserver());\n-        awaitAllObservers();\n-    }\n+        @Param({\"1\", \"1024\", \"1048576\"})\n+        public int size;\n \n-    private final static AtomicInteger outstanding = new AtomicInteger(0);\n-    private final static CountDownLatch latch = new CountDownLatch(1);\n+        public Collection<Integer> values;\n+        public Observable<Integer> observable;\n+        public Observer<Integer> observer;\n \n-    private static <T> Observer<T> newObserver() {\n-        outstanding.incrementAndGet();\n-        return new Observer<T>() {\n-            @Override\n-            public void onCompleted() {\n-                int left = outstanding.decrementAndGet();\n-                if (left == 0) {\n-                    latch.countDown();\n-                }\n+        private CountDownLatch latch;\n+\n+        @Setup\n+        public void setup() {\n+            values = new ArrayList<Integer>();\n+            for(int i = 0; i < size; i ++) {\n+                values.add(i);\n             }\n \n-            @Override\n-            public void onError(Throwable e) {\n-                int left = outstanding.decrementAndGet();\n-                if (left == 0) {\n+            observable = Observable.create(new OnSubscribe<Integer>() {\n+                @Override\n+                public void call(Subscriber<? super Integer> o) {\n+                    for (Integer value : values) {\n+                        if (o.isUnsubscribed())\n+                            return;\n+                        o.onNext(value);\n+                    }\n+                    o.onCompleted();\n+                }\n+            });\n+\n+            final BlackHole bh = new BlackHole();\n+            latch = new CountDownLatch(1);\n+\n+            observer = new Observer<Integer>() {\n+                @Override\n+                public void onCompleted() {\n                     latch.countDown();\n                 }\n-            }\n \n-            @Override\n-            public void onNext(T t) {\n-                // do nothing\n-            }\n-        };\n-    }\n+                @Override\n+                public void onError(Throwable e) {\n+                    throw new RuntimeException(e);\n+                }\n+\n+                @Override\n+                public void onNext(Integer value) {\n+                    bh.consume(value);\n+                }\n+            };\n \n-    private static void awaitAllObservers() {\n-        try {\n-            latch.await();\n-        } catch (InterruptedException e) {\n-            return;\n         }\n-    }\n \n-    private static final Integer[] intValues = new Integer[1000];\n-    static {\n-        for (int i = 0; i < intValues.length; i++) {\n-            intValues[i] = i;\n+        public void awaitCompletion() throws InterruptedException {\n+            latch.await();\n         }\n     }\n \n-    private static final Observable<Integer> observableOfInts = Observable.create(new OnSubscribe<Integer>() {\n-        @Override\n-        public void call(Subscriber<? super Integer> o) {\n-            for (int i = 0; i < intValues.length; i++) {\n-                if (o.isUnsubscribed())\n-                    return;\n-                o.onNext(intValues[i]);\n-            }\n-            o.onCompleted();\n-        }\n-    });\n-    private static final Func1<Integer, Object> ident = new Func1<Integer, Object>() {\n-        @Override\n-        public Object call(Integer t) {\n-            return t;\n-        }\n-    };\n }",
      "parent_sha": "2052da32e8596431da58eb6d70113c2fadfb5c75"
    }
  },
  {
    "oid": "2de214cec5e44dc8af134ccb08a5da9df7c87278",
    "message": "Fix OperationSwitch so that it does not onComplete() before inner and\nouter subscription completes.",
    "date": "2013-10-21T19:15:39Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/2de214cec5e44dc8af134ccb08a5da9df7c87278",
    "details": {
      "sha": "b59a35d88b1aeae465bbecd4d8310d2b5c1b7c3e",
      "filename": "rxjava-core/src/main/java/rx/operators/OperationSwitch.java",
      "status": "modified",
      "additions": 29,
      "deletions": 21,
      "changes": 50,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/2de214cec5e44dc8af134ccb08a5da9df7c87278/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationSwitch.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/2de214cec5e44dc8af134ccb08a5da9df7c87278/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationSwitch.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationSwitch.java?ref=2de214cec5e44dc8af134ccb08a5da9df7c87278",
      "patch": "@@ -34,6 +34,7 @@\n import rx.Observer;\n import rx.Subscription;\n import rx.concurrency.TestScheduler;\n+import rx.subscriptions.CompositeSubscription;\n import rx.subscriptions.MultipleAssignmentSubscription;\n import rx.subscriptions.Subscriptions;\n import rx.util.functions.Action0;\n@@ -78,9 +79,15 @@ public Switch(Observable<? extends Observable<? extends T>> sequences) {\n \n         @Override\n         public Subscription onSubscribe(Observer<? super T> observer) {\n-            SafeObservableSubscription subscription = new SafeObservableSubscription();\n-            subscription.wrap(sequences.subscribe(new SwitchObserver<T>(observer, subscription)));\n-            return subscription;\n+            SafeObservableSubscription parent;\n+            parent = new SafeObservableSubscription();\n+\n+            MultipleAssignmentSubscription child;\n+            child = new MultipleAssignmentSubscription();\n+\n+            parent.wrap(sequences.subscribe(new SwitchObserver<T>(observer, parent, child)));\n+\n+            return new CompositeSubscription(parent, child);\n         }\n     }\n \n@@ -89,24 +96,25 @@ private static class SwitchObserver<T> implements Observer<Observable<? extends\n         private final Object                         gate;\n         private final Observer<? super T>            observer;\n         private final SafeObservableSubscription     parent;\n-        private final MultipleAssignmentSubscription innerSubscription;\n+        private final MultipleAssignmentSubscription child;\n         private long                                 latest;\n         private boolean                              stopped;\n         private boolean                              hasLatest;\n \n-        public SwitchObserver(Observer<? super T> observer, SafeObservableSubscription parent) {\n+        public SwitchObserver(Observer<? super T> observer, SafeObservableSubscription parent,\n+                MultipleAssignmentSubscription child) {\n             this.observer = observer;\n             this.parent = parent;\n+            this.child = child;\n             this.gate = new Object();\n-            this.innerSubscription = new MultipleAssignmentSubscription();\n         }\n \n         @Override\n         public void onNext(Observable<? extends T> args) {\n             final long id;\n             synchronized (gate) {\n                 id = ++latest;\n-                hasLatest = true;\n+                this.hasLatest = true;\n             }\n \n             final SafeObservableSubscription sub;\n@@ -116,7 +124,7 @@ public void onNext(Observable<? extends T> args) {\n                 public void onNext(T args) {\n                     synchronized (gate) {\n                         if (latest == id) {\n-                            observer.onNext(args);\n+                            SwitchObserver.this.observer.onNext(args);\n                         }\n                     }\n                 }\n@@ -126,8 +134,8 @@ public void onError(Throwable e) {\n                     synchronized (gate) {\n                         sub.unsubscribe();\n                         if (latest == id) {\n-                            observer.onError(e);\n-                            parent.unsubscribe();\n+                            SwitchObserver.this.observer.onError(e);\n+                            SwitchObserver.this.parent.unsubscribe();\n                         }\n                     }\n                 }\n@@ -137,39 +145,39 @@ public void onCompleted() {\n                     synchronized (gate) {\n                         sub.unsubscribe();\n                         if (latest == id) {\n-                            hasLatest = false;\n+                            SwitchObserver.this.hasLatest = false;\n                         }\n \n                         if (stopped) {\n-                            observer.onCompleted();\n-                            parent.unsubscribe();\n+                            SwitchObserver.this.observer.onCompleted();\n+                            SwitchObserver.this.parent.unsubscribe();\n                         }\n \n                     }\n                 }\n \n             }));\n \n-            innerSubscription.setSubscription(sub);\n+            this.child.setSubscription(sub);\n         }\n \n         @Override\n         public void onError(Throwable e) {\n             synchronized (gate) {\n-                observer.onError(e);\n+                this.observer.onError(e);\n             }\n \n-            parent.unsubscribe();\n+            this.parent.unsubscribe();\n         }\n \n         @Override\n         public void onCompleted() {\n             synchronized (gate) {\n-                innerSubscription.unsubscribe();\n-                stopped = true;\n-                if (!hasLatest) {\n-                    observer.onCompleted();\n-                    parent.unsubscribe();\n+                this.child.unsubscribe();\n+                this.stopped = true;\n+                if (!this.hasLatest) {\n+                    this.observer.onCompleted();\n+                    this.parent.unsubscribe();\n                 }\n             }\n         }",
      "parent_sha": "41ebe38fe80989472430f19cc7bb713c115eeb7a"
    }
  },
  {
    "oid": "0c4f59aabc380a579c611f7d6623fc141527a52b",
    "message": "Merge branch 'master' into multisubscribe\n\nConflicts:\n\trxjava-core/src/main/java/rx/operators/OperatorGroupBy.java",
    "date": "2013-04-23T11:29:02Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/0c4f59aabc380a579c611f7d6623fc141527a52b",
    "details": {
      "sha": "35123d704eb3882235184f25c8deab385ac26236",
      "filename": "rxjava-core/src/main/java/rx/operators/OperationGroupBy.java",
      "status": "modified",
      "additions": 25,
      "deletions": 19,
      "changes": 44,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/0c4f59aabc380a579c611f7d6623fc141527a52b/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationGroupBy.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/0c4f59aabc380a579c611f7d6623fc141527a52b/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationGroupBy.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationGroupBy.java?ref=0c4f59aabc380a579c611f7d6623fc141527a52b",
      "patch": "@@ -56,37 +56,43 @@ public static <K, T> Func1<Observer<GroupedObservable<K, T>>, Subscription> grou\n \n     private static class GroupBy<K, V> implements Func1<Observer<GroupedObservable<K, V>>, Subscription> {\n         private final Observable<KeyValue<K, V>> source;\n-        private final ConcurrentHashMap<K, Boolean> keys = new ConcurrentHashMap<K, Boolean>();\n \n         private GroupBy(Observable<KeyValue<K, V>> source) {\n             this.source = source;\n         }\n \n         @Override\n         public Subscription call(final Observer<GroupedObservable<K, V>> observer) {\n+            return source.subscribe(new GroupByObserver(observer));\n+        }\n \n-            return source.subscribe(new Observer<KeyValue<K, V>>() {\n+        private class GroupByObserver implements Observer<KeyValue<K, V>> {\n+            private final Observer<GroupedObservable<K, V>> underlying;\n \n-                @Override\n-                public void onCompleted() {\n-                    observer.onCompleted();\n-                }\n+            private final ConcurrentHashMap<K, Boolean> keys = new ConcurrentHashMap<K, Boolean>();\n \n-                @Override\n-                public void onError(Exception e) {\n-                    observer.onError(e);\n-                }\n+            private GroupByObserver(Observer<GroupedObservable<K, V>> underlying) {\n+                this.underlying = underlying;\n+            }\n \n-                @Override\n-                public void onNext(final KeyValue<K, V> args) {\n-                    K key = args.key;\n-                    boolean newGroup = keys.putIfAbsent(key, true) == null;\n-                    if (newGroup) {\n-                        observer.onNext(buildObservableFor(source, key));\n-                    }\n-                }\n+            @Override\n+            public void onCompleted() {\n+                underlying.onCompleted();\n+            }\n+\n+            @Override\n+            public void onError(Exception e) {\n+                underlying.onError(e);\n+            }\n \n-            });\n+            @Override\n+            public void onNext(final KeyValue<K, V> args) {\n+                K key = args.key;\n+                boolean newGroup = keys.putIfAbsent(key, true) == null;\n+                if (newGroup) {\n+                    underlying.onNext(buildObservableFor(source, key));\n+                }\n+            }\n         }\n     }\n ",
      "parent_sha": "7674374ecb42529aafe8267bf963419fb551600b"
    }
  },
  {
    "oid": "0155b69866f07f02902674c1d57311d273f4325c",
    "message": "Fixing javadoc's code example of Observable#lift. (#6104)",
    "date": "2018-07-22T11:26:52Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/0155b69866f07f02902674c1d57311d273f4325c",
    "details": {
      "sha": "a3f204206bf37dfd99b326699579ec0b82aafb8b",
      "filename": "src/main/java/io/reactivex/Observable.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/0155b69866f07f02902674c1d57311d273f4325c/src%2Fmain%2Fjava%2Fio%2Freactivex%2FObservable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/0155b69866f07f02902674c1d57311d273f4325c/src%2Fmain%2Fjava%2Fio%2Freactivex%2FObservable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Fio%2Freactivex%2FObservable.java?ref=0155b69866f07f02902674c1d57311d273f4325c",
      "patch": "@@ -9414,7 +9414,7 @@ public final Single<T> lastOrError() {\n      *     &#64;Override\n      *     public void onSubscribe(Disposable s) {\n      *         if (upstream != null) {\n-     *             s.cancel();\n+     *             s.dispose();\n      *         } else {\n      *             upstream = s;\n      *             downstream.onSubscribe(this);\n@@ -9473,10 +9473,10 @@ public final Single<T> lastOrError() {\n      * //         Such class may define additional parameters to be submitted to\n      * //         the custom consumer type.\n      *\n-     * final class CustomOperator&lt;T&gt; implements ObservableOperator&lt;String&gt; {\n+     * final class CustomOperator&lt;T&gt; implements ObservableOperator&lt;String, T&gt; {\n      *     &#64;Override\n-     *     public Observer&lt;? super String&gt; apply(Observer&lt;? super T&gt; upstream) {\n-     *         return new CustomObserver&lt;T&gt;(upstream);\n+     *     public Observer&lt;T&gt; apply(Observer&lt;? super String&gt; downstream) {\n+     *         return new CustomObserver&lt;T&gt;(downstream);\n      *     }\n      * }\n      *",
      "parent_sha": "c5a42a273836c4d1f87d07843bef2789354ac710"
    }
  },
  {
    "oid": "43b75a9c73d367664f0e824307295b061e3d1fde",
    "message": "DebugHook got miswired before",
    "date": "2014-06-17T18:30:59Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/43b75a9c73d367664f0e824307295b061e3d1fde",
    "details": {
      "sha": "ba195aa3842285e34e82a62e46cca64fc371a90a",
      "filename": "rxjava-contrib/rxjava-debug/src/main/java/rx/plugins/DebugNotification.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/43b75a9c73d367664f0e824307295b061e3d1fde/rxjava-contrib%2Frxjava-debug%2Fsrc%2Fmain%2Fjava%2Frx%2Fplugins%2FDebugNotification.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/43b75a9c73d367664f0e824307295b061e3d1fde/rxjava-contrib%2Frxjava-debug%2Fsrc%2Fmain%2Fjava%2Frx%2Fplugins%2FDebugNotification.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-contrib%2Frxjava-debug%2Fsrc%2Fmain%2Fjava%2Frx%2Fplugins%2FDebugNotification.java?ref=43b75a9c73d367664f0e824307295b061e3d1fde",
      "patch": "@@ -37,7 +37,7 @@ public static <T, C> DebugNotification<T> createSubscribe(Observer<? super T> o,\n             o = ds.getActual();\n         }\n         if (sourceFunc instanceof DebugHook.DebugOnSubscribe) {\n-            sourceFunc = (OnSubscribe<T>) ((SafeSubscriber<T>) sourceFunc).getActual();\n+            sourceFunc = ((DebugHook.DebugOnSubscribe) sourceFunc).getActual();\n         }\n         return new DebugNotification<T>(o, from, Kind.Subscribe, null, null, to, source, sourceFunc);\n     }",
      "parent_sha": "92e11ea0f8bbaf955f2a74911e76bf536812fe10"
    }
  },
  {
    "oid": "3eae70842efc313601ce47d1cd9b960e910b28c8",
    "message": "Move cast to parent function",
    "date": "2014-07-12T00:47:35Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/3eae70842efc313601ce47d1cd9b960e910b28c8",
    "details": {
      "sha": "cd561a9b4087c37d74d2cac2dc80351241ab30bb",
      "filename": "rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/3eae70842efc313601ce47d1cd9b960e910b28c8/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Finternal%2Foperators%2FOperatorMerge.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/3eae70842efc313601ce47d1cd9b960e910b28c8/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Finternal%2Foperators%2FOperatorMerge.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Finternal%2Foperators%2FOperatorMerge.java?ref=3eae70842efc313601ce47d1cd9b960e910b28c8",
      "patch": "@@ -98,7 +98,7 @@ public void onStart() {\n         @Override\n         public void onNext(Observable<? extends T> t) {\n             if (t instanceof ScalarSynchronousObservable) {\n-                handleScalarSynchronousObservable(t);\n+                handleScalarSynchronousObservable((ScalarSynchronousObservable)t);\n             } else {\n                 if (t == null || isUnsubscribed()) {\n                     return;\n@@ -128,7 +128,7 @@ private void handleNewSource(Observable<? extends T> t) {\n             request(1);\n         }\n \n-        private void handleScalarSynchronousObservable(Observable<? extends T> t) {\n+        private void handleScalarSynchronousObservable(ScalarSynchronousObservable<? extends T> t) {\n             // fast-path for scalar, synchronous values such as Observable.from(int)\n             /**\n              * Without this optimization:\n@@ -154,8 +154,8 @@ private void handleScalarSynchronousObservable(Observable<? extends T> t) {\n             }\n         }\n \n-        private void handleScalarSynchronousObservableWithoutRequestLimits(Observable<? extends T> t) {\n-            T value = ((ScalarSynchronousObservable<T>) t).get();\n+        private void handleScalarSynchronousObservableWithoutRequestLimits(ScalarSynchronousObservable<? extends T> t) {\n+            T value = t.get();\n             if (getEmitLock()) {\n                 try {\n                     actual.onNext(value);\n@@ -177,14 +177,14 @@ private void handleScalarSynchronousObservableWithoutRequestLimits(Observable<?\n             }\n         }\n \n-        private void handleScalarSynchronousObservableWithRequestLimits(Observable<? extends T> t) {\n+        private void handleScalarSynchronousObservableWithRequestLimits(ScalarSynchronousObservable<? extends T> t) {\n             if (getEmitLock()) {\n                 boolean emitted = false;\n                 try {\n                     long r = mergeProducer.requested;\n                     if (r > 0) {\n                         emitted = true;\n-                        actual.onNext(((ScalarSynchronousObservable<T>) t).get());\n+                        actual.onNext(t.get());\n                         mergeProducer.REQUESTED.decrementAndGet(mergeProducer);\n                         // we handle this Observable without ever incrementing the wip or touching other machinery so just return here\n                         return;\n@@ -203,7 +203,7 @@ private void handleScalarSynchronousObservableWithRequestLimits(Observable<? ext\n             // enqueue the values for later delivery\n             initScalarValueQueueIfNeeded();\n             try {\n-                scalarValueQueue.onNext(((ScalarSynchronousObservable<T>) t).get());\n+                scalarValueQueue.onNext(t.get());\n             } catch (MissingBackpressureException e) {\n                 onError(e);\n             }",
      "parent_sha": "7caf5e170349bfe70faefdeb9f6b26a3a7da3a48"
    }
  },
  {
    "oid": "ce9c6b5e28a38c9bcb1500f9ce1448a2122aa0b0",
    "message": "Also added aggregate (alias for reduce, see issue #20).",
    "date": "2013-05-04T13:09:40Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/ce9c6b5e28a38c9bcb1500f9ce1448a2122aa0b0",
    "details": {
      "sha": "7bd8be01a431bd9d320b855d698d70b4a42b5538",
      "filename": "rxjava-core/src/main/java/rx/Observable.java",
      "status": "modified",
      "additions": 30,
      "deletions": 2,
      "changes": 32,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/ce9c6b5e28a38c9bcb1500f9ce1448a2122aa0b0/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/ce9c6b5e28a38c9bcb1500f9ce1448a2122aa0b0/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java?ref=ce9c6b5e28a38c9bcb1500f9ce1448a2122aa0b0",
      "patch": "@@ -3220,6 +3220,13 @@ public Observable<T> reduce(Func2<T, T, T> accumulator) {\n         return reduce(this, accumulator);\n     }\n \n+    /**\n+     * @see #reduce(Func2)\n+     */\n+    public Observable<T> aggregate(Func2<T, T, T> accumulator) {\n+        return reduce(accumulator);\n+    }\n+    \n     /**\n      * Returns an Observable that applies a function of your choosing to the first item emitted by a\n      * source Observable, then feeds the result of that function along with the second item emitted\n@@ -3246,6 +3253,13 @@ public Observable<T> reduce(Object accumulator) {\n         return reduce(this, accumulator);\n     }\n \n+    /**\n+     * @see #reduce(Object)\n+     */\n+    public Observable<T> aggregate(Object accumulator) {\n+        return reduce(accumulator);\n+    }\n+    \n     /**\n      * Returns an Observable that applies a function of your choosing to the first item emitted by a\n      * source Observable, then feeds the result of that function along with the second item emitted\n@@ -3270,10 +3284,17 @@ public Observable<T> reduce(Object accumulator) {\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229154(v%3Dvs.103).aspx\">MSDN: Observable.Aggregate</a>\n      * @see <a href=\"http://en.wikipedia.org/wiki/Fold_(higher-order_function)\">Wikipedia: Fold (higher-order function)</a>\n      */\n-    public Observable<T> reduce(T initialValue, Func2<T, T, T> accumulator) {\n+    public <R> Observable<R> reduce(R initialValue, Func2<R, T, R> accumulator) {\n         return reduce(this, initialValue, accumulator);\n     }\n \n+    /**\n+     * @see #reduce(R, Func2)\n+     */\n+    public <R> Observable<R> aggregate(R initialValue, Func2<R, T, R> accumulator) {\n+        return reduce(initialValue, accumulator);\n+    }\n+\n     /**\n      * Returns an Observable that applies a function of your choosing to the first item emitted by a\n      * source Observable, then feeds the result of that function along with the second item emitted\n@@ -3297,10 +3318,17 @@ public Observable<T> reduce(T initialValue, Func2<T, T, T> accumulator) {\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229154(v%3Dvs.103).aspx\">MSDN: Observable.Aggregate</a>\n      * @see <a href=\"http://en.wikipedia.org/wiki/Fold_(higher-order_function)\">Wikipedia: Fold (higher-order function)</a>\n      */\n-    public Observable<T> reduce(T initialValue, Object accumulator) {\n+    public <R> Observable<R> reduce(R initialValue, Object accumulator) {\n         return reduce(this, initialValue, accumulator);\n     }\n \n+    /**\n+     * @see #reduce(R, Object)\n+     */\n+    public <R> Observable<R> aggregate(R initialValue, Object accumulator) {\n+        return reduce(initialValue, accumulator);\n+    }\n+    \n     /**\n      * Returns an Observable that applies a function of your choosing to the first item emitted by a\n      * source Observable, then feeds the result of that function along with the second item emitted",
      "parent_sha": "bbaf1bcc05469f4c45646cc348ea2a91348364b0"
    }
  },
  {
    "oid": "7337bb8f4fb2bcc49404e2fa96afb5f5e1d2cfa5",
    "message": "Remove ActionSubscription",
    "date": "2014-12-11T12:09:46Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/7337bb8f4fb2bcc49404e2fa96afb5f5e1d2cfa5",
    "details": {
      "sha": "86dd9c78a6d9ac66d974daf733d22e7ac0e6aa84",
      "filename": "src/main/java/rx/subscriptions/Subscriptions.java",
      "status": "modified",
      "additions": 1,
      "deletions": 31,
      "changes": 32,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/7337bb8f4fb2bcc49404e2fa96afb5f5e1d2cfa5/src%2Fmain%2Fjava%2Frx%2Fsubscriptions%2FSubscriptions.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/7337bb8f4fb2bcc49404e2fa96afb5f5e1d2cfa5/src%2Fmain%2Fjava%2Frx%2Fsubscriptions%2FSubscriptions.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Frx%2Fsubscriptions%2FSubscriptions.java?ref=7337bb8f4fb2bcc49404e2fa96afb5f5e1d2cfa5",
      "patch": "@@ -46,38 +46,8 @@ public static Subscription empty() {\n      * @return {@link Subscription}\n      */\n     public static Subscription create(final Action0 unsubscribe) {\n-        return new ActionSubscription(unsubscribe);\n+        return BooleanSubscription.create(unsubscribe);\n     }\n-    /**\n-     * Subscription that delegates the unsubscription action to an Action0 instance\n-     */\n-    private static final class ActionSubscription implements Subscription {\n-        volatile Action0 actual;\n-        static final AtomicReferenceFieldUpdater<ActionSubscription, Action0> ACTUAL_UPDATER\n-                = AtomicReferenceFieldUpdater.newUpdater(ActionSubscription.class, Action0.class, \"actual\");\n-        public ActionSubscription(Action0 action) {\n-            this.actual = action != null ? action : Actions.empty();\n-        }\n-        @Override\n-        public boolean isUnsubscribed() {\n-            return actual == UNSUBSCRIBED_ACTION;\n-        }\n-        @Override\n-        public void unsubscribe() {\n-            Action0 a = ACTUAL_UPDATER.getAndSet(this, UNSUBSCRIBED_ACTION);\n-            a.call();\n-        }\n-        /** The no-op unique action indicating an unsubscribed state. */\n-        private static final Unsubscribed UNSUBSCRIBED_ACTION = new Unsubscribed();\n-        /** Naming classes helps with debugging. */\n-        private static final class Unsubscribed implements Action0 {\n-            @Override\n-            public void call() {\n-\n-            }\n-        }\n-    }\n-    \n \n     /**\n      * Converts a {@link Future} into a {@link Subscription} and cancels it when unsubscribed.",
      "parent_sha": "57156e364b1fabdd55b4d9c853e2cc9ef6edb70d"
    }
  },
  {
    "oid": "4d05c9cd1688f129930666e0b2c134da80bd7743",
    "message": "Git Reformats This File",
    "date": "2014-05-20T17:25:40Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/4d05c9cd1688f129930666e0b2c134da80bd7743",
    "details": {
      "sha": "6e32b8f6cf2ba71cd17ed2a406839e225ead5de5",
      "filename": "rxjava-core/src/test/java/rx/subjects/ReplaySubjectBoundedConcurrencyTest.java",
      "status": "modified",
      "additions": 339,
      "deletions": 339,
      "changes": 678,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/4d05c9cd1688f129930666e0b2c134da80bd7743/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Fsubjects%2FReplaySubjectBoundedConcurrencyTest.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/4d05c9cd1688f129930666e0b2c134da80bd7743/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Fsubjects%2FReplaySubjectBoundedConcurrencyTest.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Fsubjects%2FReplaySubjectBoundedConcurrencyTest.java?ref=4d05c9cd1688f129930666e0b2c134da80bd7743",
      "patch": "@@ -1,340 +1,340 @@\n-/**\r\n- * Copyright 2014 Netflix, Inc.\r\n- * \r\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n- * you may not use this file except in compliance with the License.\r\n- * You may obtain a copy of the License at\r\n- * \r\n- * http://www.apache.org/licenses/LICENSE-2.0\r\n- * \r\n- * Unless required by applicable law or agreed to in writing, software\r\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n- * See the License for the specific language governing permissions and\r\n- * limitations under the License.\r\n- */\r\n-package rx.subjects;\r\n-\r\n-import static org.junit.Assert.assertEquals;\r\n-\r\n-import java.util.ArrayList;\r\n-import java.util.Arrays;\r\n-import java.util.Collections;\r\n-import java.util.List;\r\n-import java.util.concurrent.CountDownLatch;\r\n-import java.util.concurrent.TimeUnit;\r\n-import java.util.concurrent.atomic.AtomicReference;\r\n-\r\n-import org.junit.Test;\r\n-\r\n-import rx.Observable;\r\n-import rx.Observable.OnSubscribe;\r\n-import rx.Subscriber;\r\n-import rx.functions.Action1;\r\n-import rx.observers.TestSubscriber;\r\n-import rx.schedulers.Schedulers;\r\n-\r\n-public class ReplaySubjectBoundedConcurrencyTest {\r\n-\r\n-    public static void main(String args[]) {\r\n-        try {\r\n-            for (int i = 0; i < 100; i++) {\r\n-                new ReplaySubjectConcurrencyTest().testSubscribeCompletionRaceCondition();\r\n-                new ReplaySubjectConcurrencyTest().testReplaySubjectConcurrentSubscriptions();\r\n-                new ReplaySubjectConcurrencyTest().testReplaySubjectConcurrentSubscribersDoingReplayDontBlockEachOther();\r\n-            }\r\n-        } catch (InterruptedException e) {\r\n-            e.printStackTrace();\r\n-        }\r\n-    }\r\n-\r\n-    @Test(timeout = 4000)\r\n-    public void testReplaySubjectConcurrentSubscribersDoingReplayDontBlockEachOther() throws InterruptedException {\r\n-        final ReplaySubject<Long> replay = ReplaySubject.createUnbounded();\r\n-        Thread source = new Thread(new Runnable() {\r\n-\r\n-            @Override\r\n-            public void run() {\r\n-                Observable.create(new OnSubscribe<Long>() {\r\n-\r\n-                    @Override\r\n-                    public void call(Subscriber<? super Long> o) {\r\n-                        System.out.println(\"********* Start Source Data ***********\");\r\n-                        for (long l = 1; l <= 10000; l++) {\r\n-                            o.onNext(l);\r\n-                        }\r\n-                        System.out.println(\"********* Finished Source Data ***********\");\r\n-                        o.onCompleted();\r\n-                    }\r\n-                }).subscribe(replay);\r\n-            }\r\n-        });\r\n-        source.start();\r\n-\r\n-        long v = replay.toBlockingObservable().last();\r\n-        assertEquals(10000, v);\r\n-\r\n-        // it's been played through once so now it will all be replays\r\n-        final CountDownLatch slowLatch = new CountDownLatch(1);\r\n-        Thread slowThread = new Thread(new Runnable() {\r\n-\r\n-            @Override\r\n-            public void run() {\r\n-                Subscriber<Long> slow = new Subscriber<Long>() {\r\n-\r\n-                    @Override\r\n-                    public void onCompleted() {\r\n-                        System.out.println(\"*** Slow Observer completed\");\r\n-                        slowLatch.countDown();\r\n-                    }\r\n-\r\n-                    @Override\r\n-                    public void onError(Throwable e) {\r\n-                    }\r\n-\r\n-                    @Override\r\n-                    public void onNext(Long args) {\r\n-                        if (args == 1) {\r\n-                            System.out.println(\"*** Slow Observer STARTED\");\r\n-                        }\r\n-                        try {\r\n-                            if (args % 10 == 0) {\r\n-                                Thread.sleep(1);\r\n-                            }\r\n-                        } catch (InterruptedException e) {\r\n-                            e.printStackTrace();\r\n-                        }\r\n-                    }\r\n-                };\r\n-                replay.subscribe(slow);\r\n-                try {\r\n-                    slowLatch.await();\r\n-                } catch (InterruptedException e1) {\r\n-                    e1.printStackTrace();\r\n-                }\r\n-            }\r\n-        });\r\n-        slowThread.start();\r\n-\r\n-        Thread fastThread = new Thread(new Runnable() {\r\n-\r\n-            @Override\r\n-            public void run() {\r\n-                final CountDownLatch fastLatch = new CountDownLatch(1);\r\n-                Subscriber<Long> fast = new Subscriber<Long>() {\r\n-\r\n-                    @Override\r\n-                    public void onCompleted() {\r\n-                        System.out.println(\"*** Fast Observer completed\");\r\n-                        fastLatch.countDown();\r\n-                    }\r\n-\r\n-                    @Override\r\n-                    public void onError(Throwable e) {\r\n-                    }\r\n-\r\n-                    @Override\r\n-                    public void onNext(Long args) {\r\n-                        if (args == 1) {\r\n-                            System.out.println(\"*** Fast Observer STARTED\");\r\n-                        }\r\n-                    }\r\n-                };\r\n-                replay.subscribe(fast);\r\n-                try {\r\n-                    fastLatch.await();\r\n-                } catch (InterruptedException e1) {\r\n-                    e1.printStackTrace();\r\n-                }\r\n-            }\r\n-        });\r\n-        fastThread.start();\r\n-        fastThread.join();\r\n-\r\n-        // slow should not yet be completed when fast completes\r\n-        assertEquals(1, slowLatch.getCount());\r\n-\r\n-        slowThread.join();\r\n-    }\r\n-\r\n-    @Test\r\n-    public void testReplaySubjectConcurrentSubscriptions() throws InterruptedException {\r\n-        final ReplaySubject<Long> replay = ReplaySubject.createUnbounded();\r\n-        Thread source = new Thread(new Runnable() {\r\n-\r\n-            @Override\r\n-            public void run() {\r\n-                Observable.create(new OnSubscribe<Long>() {\r\n-\r\n-                    @Override\r\n-                    public void call(Subscriber<? super Long> o) {\r\n-                        System.out.println(\"********* Start Source Data ***********\");\r\n-                        for (long l = 1; l <= 10000; l++) {\r\n-                            o.onNext(l);\r\n-                        }\r\n-                        System.out.println(\"********* Finished Source Data ***********\");\r\n-                        o.onCompleted();\r\n-                    }\r\n-                }).subscribe(replay);\r\n-            }\r\n-        });\r\n-\r\n-        // used to collect results of each thread\r\n-        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<List<Long>>());\r\n-        final List<Thread> threads = Collections.synchronizedList(new ArrayList<Thread>());\r\n-\r\n-        for (int i = 1; i <= 200; i++) {\r\n-            final int count = i;\r\n-            if (count == 20) {\r\n-                // start source data after we have some already subscribed\r\n-                // and while others are in process of subscribing\r\n-                source.start();\r\n-            }\r\n-            if (count == 100) {\r\n-                // wait for source to finish then keep adding after it's done\r\n-                source.join();\r\n-            }\r\n-            Thread t = new Thread(new Runnable() {\r\n-\r\n-                @Override\r\n-                public void run() {\r\n-                    List<Long> values = replay.toList().toBlockingObservable().last();\r\n-                    listOfListsOfValues.add(values);\r\n-                    System.out.println(\"Finished thread: \" + count);\r\n-                }\r\n-            });\r\n-            t.start();\r\n-            System.out.println(\"Started thread: \" + i);\r\n-            threads.add(t);\r\n-        }\r\n-\r\n-        // wait for all threads to complete\r\n-        for (Thread t : threads) {\r\n-            t.join();\r\n-        }\r\n-\r\n-        // assert all threads got the same results\r\n-        List<Long> sums = new ArrayList<Long>();\r\n-        for (List<Long> values : listOfListsOfValues) {\r\n-            long v = 0;\r\n-            for (long l : values) {\r\n-                v += l;\r\n-            }\r\n-            sums.add(v);\r\n-        }\r\n-\r\n-        long expected = sums.get(0);\r\n-        boolean success = true;\r\n-        for (long l : sums) {\r\n-            if (l != expected) {\r\n-                success = false;\r\n-                System.out.println(\"FAILURE => Expected \" + expected + \" but got: \" + l);\r\n-            }\r\n-        }\r\n-\r\n-        if (success) {\r\n-            System.out.println(\"Success! \" + sums.size() + \" each had the same sum of \" + expected);\r\n-        } else {\r\n-            throw new RuntimeException(\"Concurrency Bug\");\r\n-        }\r\n-\r\n-    }\r\n-\r\n-    /**\r\n-     * Can receive timeout if subscribe never receives an onError/onCompleted ... which reveals a race condition.\r\n-     */\r\n-    @Test(timeout = 10000)\r\n-    public void testSubscribeCompletionRaceCondition() {\r\n-        for (int i = 0; i < 50; i++) {\r\n-            final ReplaySubject<String> subject = ReplaySubject.createUnbounded();\r\n-            final AtomicReference<String> value1 = new AtomicReference<String>();\r\n-\r\n-            subject.subscribe(new Action1<String>() {\r\n-\r\n-                @Override\r\n-                public void call(String t1) {\r\n-                    try {\r\n-                        // simulate a slow observer\r\n-                        Thread.sleep(50);\r\n-                    } catch (InterruptedException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    value1.set(t1);\r\n-                }\r\n-\r\n-            });\r\n-\r\n-            Thread t1 = new Thread(new Runnable() {\r\n-\r\n-                @Override\r\n-                public void run() {\r\n-                    subject.onNext(\"value\");\r\n-                    subject.onCompleted();\r\n-                }\r\n-            });\r\n-\r\n-            SubjectObserverThread t2 = new SubjectObserverThread(subject);\r\n-            SubjectObserverThread t3 = new SubjectObserverThread(subject);\r\n-            SubjectObserverThread t4 = new SubjectObserverThread(subject);\r\n-            SubjectObserverThread t5 = new SubjectObserverThread(subject);\r\n-\r\n-            t2.start();\r\n-            t3.start();\r\n-            t1.start();\r\n-            t4.start();\r\n-            t5.start();\r\n-            try {\r\n-                t1.join();\r\n-                t2.join();\r\n-                t3.join();\r\n-                t4.join();\r\n-                t5.join();\r\n-            } catch (InterruptedException e) {\r\n-                throw new RuntimeException(e);\r\n-            }\r\n-\r\n-            assertEquals(\"value\", value1.get());\r\n-            assertEquals(\"value\", t2.value.get());\r\n-            assertEquals(\"value\", t3.value.get());\r\n-            assertEquals(\"value\", t4.value.get());\r\n-            assertEquals(\"value\", t5.value.get());\r\n-        }\r\n-\r\n-    }\r\n-    \r\n-    /**\r\n-     * https://github.com/Netflix/RxJava/issues/1147\r\n-     */\r\n-    @Test\r\n-    public void testRaceForTerminalState() {\r\n-        final List<Integer> expected = Arrays.asList(1);\r\n-        for (int i = 0; i < 100000; i++) {\r\n-            TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\r\n-            Observable.just(1).subscribeOn(Schedulers.computation()).cache().subscribe(ts);\r\n-            ts.awaitTerminalEvent();\r\n-            ts.assertReceivedOnNext(expected);\r\n-            ts.assertTerminalEvent();\r\n-        }\r\n-    }\r\n-\r\n-    private static class SubjectObserverThread extends Thread {\r\n-\r\n-        private final ReplaySubject<String> subject;\r\n-        private final AtomicReference<String> value = new AtomicReference<String>();\r\n-\r\n-        public SubjectObserverThread(ReplaySubject<String> subject) {\r\n-            this.subject = subject;\r\n-        }\r\n-\r\n-        @Override\r\n-        public void run() {\r\n-            try {\r\n-                // a timeout exception will happen if we don't get a terminal state \r\n-                String v = subject.timeout(2000, TimeUnit.MILLISECONDS).toBlockingObservable().single();\r\n-                value.set(v);\r\n-            } catch (Exception e) {\r\n-                e.printStackTrace();\r\n-            }\r\n-        }\r\n-    }\r\n+/**\n+ * Copyright 2014 Netflix, Inc.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package rx.subjects;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.junit.Test;\n+\n+import rx.Observable;\n+import rx.Observable.OnSubscribe;\n+import rx.Subscriber;\n+import rx.functions.Action1;\n+import rx.observers.TestSubscriber;\n+import rx.schedulers.Schedulers;\n+\n+public class ReplaySubjectBoundedConcurrencyTest {\n+\n+    public static void main(String args[]) {\n+        try {\n+            for (int i = 0; i < 100; i++) {\n+                new ReplaySubjectConcurrencyTest().testSubscribeCompletionRaceCondition();\n+                new ReplaySubjectConcurrencyTest().testReplaySubjectConcurrentSubscriptions();\n+                new ReplaySubjectConcurrencyTest().testReplaySubjectConcurrentSubscribersDoingReplayDontBlockEachOther();\n+            }\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    @Test(timeout = 4000)\n+    public void testReplaySubjectConcurrentSubscribersDoingReplayDontBlockEachOther() throws InterruptedException {\n+        final ReplaySubject<Long> replay = ReplaySubject.createUnbounded();\n+        Thread source = new Thread(new Runnable() {\n+\n+            @Override\n+            public void run() {\n+                Observable.create(new OnSubscribe<Long>() {\n+\n+                    @Override\n+                    public void call(Subscriber<? super Long> o) {\n+                        System.out.println(\"********* Start Source Data ***********\");\n+                        for (long l = 1; l <= 10000; l++) {\n+                            o.onNext(l);\n+                        }\n+                        System.out.println(\"********* Finished Source Data ***********\");\n+                        o.onCompleted();\n+                    }\n+                }).subscribe(replay);\n+            }\n+        });\n+        source.start();\n+\n+        long v = replay.toBlockingObservable().last();\n+        assertEquals(10000, v);\n+\n+        // it's been played through once so now it will all be replays\n+        final CountDownLatch slowLatch = new CountDownLatch(1);\n+        Thread slowThread = new Thread(new Runnable() {\n+\n+            @Override\n+            public void run() {\n+                Subscriber<Long> slow = new Subscriber<Long>() {\n+\n+                    @Override\n+                    public void onCompleted() {\n+                        System.out.println(\"*** Slow Observer completed\");\n+                        slowLatch.countDown();\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable e) {\n+                    }\n+\n+                    @Override\n+                    public void onNext(Long args) {\n+                        if (args == 1) {\n+                            System.out.println(\"*** Slow Observer STARTED\");\n+                        }\n+                        try {\n+                            if (args % 10 == 0) {\n+                                Thread.sleep(1);\n+                            }\n+                        } catch (InterruptedException e) {\n+                            e.printStackTrace();\n+                        }\n+                    }\n+                };\n+                replay.subscribe(slow);\n+                try {\n+                    slowLatch.await();\n+                } catch (InterruptedException e1) {\n+                    e1.printStackTrace();\n+                }\n+            }\n+        });\n+        slowThread.start();\n+\n+        Thread fastThread = new Thread(new Runnable() {\n+\n+            @Override\n+            public void run() {\n+                final CountDownLatch fastLatch = new CountDownLatch(1);\n+                Subscriber<Long> fast = new Subscriber<Long>() {\n+\n+                    @Override\n+                    public void onCompleted() {\n+                        System.out.println(\"*** Fast Observer completed\");\n+                        fastLatch.countDown();\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable e) {\n+                    }\n+\n+                    @Override\n+                    public void onNext(Long args) {\n+                        if (args == 1) {\n+                            System.out.println(\"*** Fast Observer STARTED\");\n+                        }\n+                    }\n+                };\n+                replay.subscribe(fast);\n+                try {\n+                    fastLatch.await();\n+                } catch (InterruptedException e1) {\n+                    e1.printStackTrace();\n+                }\n+            }\n+        });\n+        fastThread.start();\n+        fastThread.join();\n+\n+        // slow should not yet be completed when fast completes\n+        assertEquals(1, slowLatch.getCount());\n+\n+        slowThread.join();\n+    }\n+\n+    @Test\n+    public void testReplaySubjectConcurrentSubscriptions() throws InterruptedException {\n+        final ReplaySubject<Long> replay = ReplaySubject.createUnbounded();\n+        Thread source = new Thread(new Runnable() {\n+\n+            @Override\n+            public void run() {\n+                Observable.create(new OnSubscribe<Long>() {\n+\n+                    @Override\n+                    public void call(Subscriber<? super Long> o) {\n+                        System.out.println(\"********* Start Source Data ***********\");\n+                        for (long l = 1; l <= 10000; l++) {\n+                            o.onNext(l);\n+                        }\n+                        System.out.println(\"********* Finished Source Data ***********\");\n+                        o.onCompleted();\n+                    }\n+                }).subscribe(replay);\n+            }\n+        });\n+\n+        // used to collect results of each thread\n+        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<List<Long>>());\n+        final List<Thread> threads = Collections.synchronizedList(new ArrayList<Thread>());\n+\n+        for (int i = 1; i <= 200; i++) {\n+            final int count = i;\n+            if (count == 20) {\n+                // start source data after we have some already subscribed\n+                // and while others are in process of subscribing\n+                source.start();\n+            }\n+            if (count == 100) {\n+                // wait for source to finish then keep adding after it's done\n+                source.join();\n+            }\n+            Thread t = new Thread(new Runnable() {\n+\n+                @Override\n+                public void run() {\n+                    List<Long> values = replay.toList().toBlockingObservable().last();\n+                    listOfListsOfValues.add(values);\n+                    System.out.println(\"Finished thread: \" + count);\n+                }\n+            });\n+            t.start();\n+            System.out.println(\"Started thread: \" + i);\n+            threads.add(t);\n+        }\n+\n+        // wait for all threads to complete\n+        for (Thread t : threads) {\n+            t.join();\n+        }\n+\n+        // assert all threads got the same results\n+        List<Long> sums = new ArrayList<Long>();\n+        for (List<Long> values : listOfListsOfValues) {\n+            long v = 0;\n+            for (long l : values) {\n+                v += l;\n+            }\n+            sums.add(v);\n+        }\n+\n+        long expected = sums.get(0);\n+        boolean success = true;\n+        for (long l : sums) {\n+            if (l != expected) {\n+                success = false;\n+                System.out.println(\"FAILURE => Expected \" + expected + \" but got: \" + l);\n+            }\n+        }\n+\n+        if (success) {\n+            System.out.println(\"Success! \" + sums.size() + \" each had the same sum of \" + expected);\n+        } else {\n+            throw new RuntimeException(\"Concurrency Bug\");\n+        }\n+\n+    }\n+\n+    /**\n+     * Can receive timeout if subscribe never receives an onError/onCompleted ... which reveals a race condition.\n+     */\n+    @Test(timeout = 10000)\n+    public void testSubscribeCompletionRaceCondition() {\n+        for (int i = 0; i < 50; i++) {\n+            final ReplaySubject<String> subject = ReplaySubject.createUnbounded();\n+            final AtomicReference<String> value1 = new AtomicReference<String>();\n+\n+            subject.subscribe(new Action1<String>() {\n+\n+                @Override\n+                public void call(String t1) {\n+                    try {\n+                        // simulate a slow observer\n+                        Thread.sleep(50);\n+                    } catch (InterruptedException e) {\n+                        e.printStackTrace();\n+                    }\n+                    value1.set(t1);\n+                }\n+\n+            });\n+\n+            Thread t1 = new Thread(new Runnable() {\n+\n+                @Override\n+                public void run() {\n+                    subject.onNext(\"value\");\n+                    subject.onCompleted();\n+                }\n+            });\n+\n+            SubjectObserverThread t2 = new SubjectObserverThread(subject);\n+            SubjectObserverThread t3 = new SubjectObserverThread(subject);\n+            SubjectObserverThread t4 = new SubjectObserverThread(subject);\n+            SubjectObserverThread t5 = new SubjectObserverThread(subject);\n+\n+            t2.start();\n+            t3.start();\n+            t1.start();\n+            t4.start();\n+            t5.start();\n+            try {\n+                t1.join();\n+                t2.join();\n+                t3.join();\n+                t4.join();\n+                t5.join();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            assertEquals(\"value\", value1.get());\n+            assertEquals(\"value\", t2.value.get());\n+            assertEquals(\"value\", t3.value.get());\n+            assertEquals(\"value\", t4.value.get());\n+            assertEquals(\"value\", t5.value.get());\n+        }\n+\n+    }\n+    \n+    /**\n+     * https://github.com/Netflix/RxJava/issues/1147\n+     */\n+    @Test\n+    public void testRaceForTerminalState() {\n+        final List<Integer> expected = Arrays.asList(1);\n+        for (int i = 0; i < 100000; i++) {\n+            TestSubscriber<Integer> ts = new TestSubscriber<Integer>();\n+            Observable.just(1).subscribeOn(Schedulers.computation()).cache().subscribe(ts);\n+            ts.awaitTerminalEvent();\n+            ts.assertReceivedOnNext(expected);\n+            ts.assertTerminalEvent();\n+        }\n+    }\n+\n+    private static class SubjectObserverThread extends Thread {\n+\n+        private final ReplaySubject<String> subject;\n+        private final AtomicReference<String> value = new AtomicReference<String>();\n+\n+        public SubjectObserverThread(ReplaySubject<String> subject) {\n+            this.subject = subject;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                // a timeout exception will happen if we don't get a terminal state \n+                String v = subject.timeout(2000, TimeUnit.MILLISECONDS).toBlockingObservable().single();\n+                value.set(v);\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n }\n\\ No newline at end of file",
      "parent_sha": "1c76782282f500013d6ae363693bf8fd2276663a"
    }
  },
  {
    "oid": "b1effc786b6281c2adfa704228c07a31ea6c64b0",
    "message": "Modified BufferUntilSubscriber to onError for any subscriber but the first",
    "date": "2014-05-05T05:26:22Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/b1effc786b6281c2adfa704228c07a31ea6c64b0",
    "details": {
      "sha": "1392bb6de6e7f189a898476d62aaa198c274bcb6",
      "filename": "rxjava-core/src/main/java/rx/operators/BufferUntilSubscriber.java",
      "status": "modified",
      "additions": 3,
      "deletions": 83,
      "changes": 86,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/b1effc786b6281c2adfa704228c07a31ea6c64b0/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FBufferUntilSubscriber.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/b1effc786b6281c2adfa704228c07a31ea6c64b0/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FBufferUntilSubscriber.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FBufferUntilSubscriber.java?ref=b1effc786b6281c2adfa704228c07a31ea6c64b0",
      "patch": "@@ -15,8 +15,6 @@\n  */\n package rx.operators;\n \n-import java.util.LinkedHashSet;\n-import java.util.Set;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n@@ -59,14 +57,8 @@ static final class State<T> {\n         final NotificationLite<T> nl = NotificationLite.instance();\n         /** The first observer or the one which buffers until the first arrives. */\n         final AtomicReference<Observer<? super T>> observerRef = new AtomicReference<Observer<? super T>>(new BufferedObserver<T>());\n-        /** How many subscribers. */\n+        /** Allow a single subscriber only. */\n         final AtomicBoolean first = new AtomicBoolean();\n-        /** The rest of the subscribers without buffering. Guarded by this. */\n-        final Set<Subscriber<? super T>> subscribers = new LinkedHashSet<Subscriber<? super T>>();\n-        /** Guarded by this. */\n-        boolean done;\n-        /** Guarded by this. */\n-        Throwable exception;\n     }\n     \n     static final class OnSubscribeAction<T> implements OnSubscribe<T> {\n@@ -95,33 +87,7 @@ public void call() {\n                     }\n                 }));\n             } else {\n-                Throwable e = null;\n-                boolean done;\n-                synchronized (state) {\n-                    done = state.done;\n-                    if (!done) {\n-                        state.subscribers.add(s);\n-                    } else {\n-                        e = state.exception;\n-                    }\n-                }\n-                if (done) {\n-                    if (e != null) {\n-                        s.onError(e);\n-                    } else {\n-                        s.onCompleted();\n-                    }\n-                    return;\n-                }\n-                s.add(Subscriptions.create(new Action0() { \n-\n-                    @Override\n-                    public void call() {\n-                        synchronized (state) {\n-                            state.subscribers.remove(s);\n-                        }\n-                    }\n-                }));\n+                s.onError(new IllegalStateException(\"Only one subscriber allowed!\"));\n             }\n         }\n         \n@@ -136,64 +102,17 @@ private BufferUntilSubscriber(State<T> state) {\n     @Override\n     public void onCompleted() {\n         state.observerRef.get().onCompleted();\n-        // notify the rest\n-        Subscriber<?>[] list;\n-        synchronized (state) {\n-            if (!state.done) {\n-                return;\n-            }\n-            state.done = true;\n-            if (state.subscribers.isEmpty()) {\n-                return;\n-            }\n-            list = state.subscribers.toArray(new Subscriber<?>[state.subscribers.size()]);\n-            state.subscribers.clear();\n-        }\n-        for (Subscriber<?> s : list) {\n-            s.onCompleted();\n-        }\n     }\n \n     @Override\n     public void onError(Throwable e) {\n         state.observerRef.get().onError(e);\n-        // notify the rest\n-        Subscriber<?>[] list;\n-        synchronized (state) {\n-            if (!state.done) {\n-                return;\n-            }\n-            state.done = true;\n-            state.exception = e;\n-            if (state.subscribers.isEmpty()) {\n-                return;\n-            }\n-            list = state.subscribers.toArray(new Subscriber<?>[state.subscribers.size()]);\n-            state.subscribers.clear();\n-        }\n-        for (Subscriber<?> s : list) {\n-            s.onError(e);\n-        }\n     }\n \n     @Override\n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n     public void onNext(T t) {\n         state.observerRef.get().onNext(t);\n-        // notify the rest\n-        Subscriber[] list;\n-        synchronized (state) {\n-            if (state.done) {\n-                return;\n-            }\n-            if (state.subscribers.isEmpty()) {\n-                return;\n-            }\n-            list = state.subscribers.toArray(new Subscriber[state.subscribers.size()]);\n-        }\n-        for (Subscriber s : list) {\n-            s.onNext(t);\n-        }\n     }\n \n     /**\n@@ -242,6 +161,7 @@ private void drainIfNeededAndSwitchToActual() {\n                 nl.accept(this, o);\n             }\n             // now we can safely change over to the actual and get rid of the pass-thru\n+            // but only if not unsubscribed\n             observerRef.compareAndSet(this, actual);\n         }\n ",
      "parent_sha": "21578d5d06523542516b027e6927faa569a33ffd"
    }
  },
  {
    "oid": "338f2a11350480cef409f64eff4a2d307be7e05a",
    "message": "Update BlockingFlowableIterable.onNext() to set error before cancel (#7789)\n\nTo avoid race with hasNext(), which checks for cancel first before checking for error. For example, in the following case, hasNext() may return false to the caller, making the caller assume the iterable finished successfully.\r\n1. onNext() called cancel\r\n2. hasNext() found the iterable is cancelled\r\n3. hasNext() found that error is null thus returned false to the caller, without throwing the error\r\n4. onNext() set error",
    "date": "2024-11-21T17:10:11Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/338f2a11350480cef409f64eff4a2d307be7e05a",
    "details": {
      "sha": "11239d04a7aad70b5c6e126dc28d8be0b3b1e5c7",
      "filename": "src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableIterable.java",
      "status": "modified",
      "additions": 5,
      "deletions": 2,
      "changes": 7,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/338f2a11350480cef409f64eff4a2d307be7e05a/src%2Fmain%2Fjava%2Fio%2Freactivex%2Frxjava3%2Finternal%2Foperators%2Fflowable%2FBlockingFlowableIterable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/338f2a11350480cef409f64eff4a2d307be7e05a/src%2Fmain%2Fjava%2Fio%2Freactivex%2Frxjava3%2Finternal%2Foperators%2Fflowable%2FBlockingFlowableIterable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Fio%2Freactivex%2Frxjava3%2Finternal%2Foperators%2Fflowable%2FBlockingFlowableIterable.java?ref=338f2a11350480cef409f64eff4a2d307be7e05a",
      "patch": "@@ -138,9 +138,12 @@ public void onSubscribe(Subscription s) {\n         @Override\n         public void onNext(T t) {\n             if (!queue.offer(t)) {\n+                // Error must be set first before calling cancel to avoid race\n+                // with hasNext(), which checks for cancel first before checking\n+                // for error.\n+                error = new QueueOverflowException();\n                 SubscriptionHelper.cancel(this);\n-\n-                onError(new QueueOverflowException());\n+                onComplete();\n             } else {\n                 signalConsumer();\n             }",
      "parent_sha": "e46ea36e0743b04601a9e8763820da81293dd3b3"
    }
  },
  {
    "oid": "50cef72953db9067cdcc57c201d52446fb649d69",
    "message": "OperationAnyTest -> OperatorAnyTest\n\nMatch new naming convention.",
    "date": "2014-04-23T04:08:02Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/50cef72953db9067cdcc57c201d52446fb649d69",
    "details": {
      "sha": "94c0f768248330b4381455524f519d56cbfbb83e",
      "filename": "rxjava-core/src/test/java/rx/operators/OperatorAnyTest.java",
      "status": "renamed",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/50cef72953db9067cdcc57c201d52446fb649d69/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Foperators%2FOperatorAnyTest.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/50cef72953db9067cdcc57c201d52446fb649d69/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Foperators%2FOperatorAnyTest.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Foperators%2FOperatorAnyTest.java?ref=50cef72953db9067cdcc57c201d52446fb649d69",
      "patch": "@@ -27,7 +27,7 @@\n import rx.functions.Func1;\n import rx.functions.Functions;\n \n-public class OperationAnyTest {\n+public class OperatorAnyTest {\n \n     @Test\n     public void testAnyWithTwoItems() {",
      "previous_filename": "rxjava-core/src/test/java/rx/operators/OperationAnyTest.java",
      "parent_sha": "61defdeb04b9ede1620db3f8e4a5fb9a6f2eac7f"
    }
  },
  {
    "oid": "8c4e92258d5d2b34fbee7d402d70892b02dddf78",
    "message": "CurrentThreadScheduler updates.\n\nUnit test that mixes delayed and immediate scheduling.\nAdded counter to resolve conflicts in case in time between enqueueing took less than 1 ms.",
    "date": "2013-04-18T18:01:28Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/8c4e92258d5d2b34fbee7d402d70892b02dddf78",
    "details": {
      "sha": "dd45102fd1b3b142f0da5da64502d6a2bd5aae48",
      "filename": "rxjava-core/src/main/java/rx/concurrency/CurrentThreadScheduler.java",
      "status": "modified",
      "additions": 42,
      "deletions": 4,
      "changes": 46,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/8c4e92258d5d2b34fbee7d402d70892b02dddf78/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fconcurrency%2FCurrentThreadScheduler.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/8c4e92258d5d2b34fbee7d402d70892b02dddf78/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fconcurrency%2FCurrentThreadScheduler.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fconcurrency%2FCurrentThreadScheduler.java?ref=8c4e92258d5d2b34fbee7d402d70892b02dddf78",
      "patch": "@@ -19,6 +19,7 @@\n \n import java.util.PriorityQueue;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n import org.junit.Test;\n import org.mockito.InOrder;\n@@ -43,6 +44,8 @@ public static CurrentThreadScheduler getInstance() {\n     private CurrentThreadScheduler() {\n     }\n \n+    private final AtomicInteger counter = new AtomicInteger(0);\n+\n     @Override\n     public <T> Subscription schedule(T state, Func2<Scheduler, T, Subscription> action) {\n         DiscardableAction<T> discardableAction = new DiscardableAction<T>(state, action);\n@@ -68,7 +71,7 @@ private void enqueue(DiscardableAction<?> action, long execTime) {\n             QUEUE.set(queue);\n         }\n \n-        queue.add(new TimedAction(action, execTime));\n+        queue.add(new TimedAction(action, execTime, counter.incrementAndGet()));\n \n         if (exec) {\n             while (!queue.isEmpty()) {\n@@ -82,15 +85,21 @@ private void enqueue(DiscardableAction<?> action, long execTime) {\n     private static class TimedAction implements Comparable<TimedAction> {\n         final DiscardableAction<?> action;\n         final Long execTime;\n+        final Integer count; // In case if time between enqueueing took less than 1ms\n \n-        private TimedAction(DiscardableAction<?> action, Long execTime) {\n+        private TimedAction(DiscardableAction<?> action, Long execTime, Integer count) {\n             this.action = action;\n             this.execTime = execTime;\n+            this.count = count;\n         }\n \n         @Override\n-        public int compareTo(TimedAction timedAction) {\n-            return execTime.compareTo(timedAction.execTime);\n+        public int compareTo(TimedAction that) {\n+            int result = execTime.compareTo(that.execTime);\n+            if (result == 0) {\n+                return count.compareTo(that.count);\n+            }\n+            return result;\n         }\n     }\n \n@@ -184,6 +193,35 @@ public void call() {\n \n         }\n \n+        @Test\n+        public void testMixOfDelayedAndNonDelayedActions() {\n+            final CurrentThreadScheduler scheduler = new CurrentThreadScheduler();\n+\n+            final Action0 first = mock(Action0.class);\n+            final Action0 second = mock(Action0.class);\n+            final Action0 third = mock(Action0.class);\n+            final Action0 fourth = mock(Action0.class);\n+\n+            scheduler.schedule(new Action0() {\n+                @Override\n+                public void call() {\n+                    scheduler.schedule(first);\n+                    scheduler.schedule(second, 300, TimeUnit.MILLISECONDS);\n+                    scheduler.schedule(third, 100, TimeUnit.MILLISECONDS);\n+                    scheduler.schedule(fourth);\n+                }\n+            });\n+\n+            InOrder inOrder = inOrder(first, second, third, fourth);\n+\n+            inOrder.verify(first, times(1)).call();\n+            inOrder.verify(fourth, times(1)).call();\n+            inOrder.verify(third, times(1)).call();\n+            inOrder.verify(second, times(1)).call();\n+\n+\n+        }\n+\n     }\n \n }",
      "parent_sha": "8d3e766dc35fbb3531446ede4e216ea83270b358"
    }
  },
  {
    "oid": "6da4b03afbe5e621eddf1dd8ad867a0c967be0ed",
    "message": "Use a PBQ instead of a PQ on the trampoline. Moves counter inside to worker class and ditches the separate field updater.",
    "date": "2015-01-21T17:10:22Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/6da4b03afbe5e621eddf1dd8ad867a0c967be0ed",
    "details": {
      "sha": "e7ad0d8b45182a2a96e09249f98a026efb827c34",
      "filename": "src/main/java/rx/schedulers/TrampolineScheduler.java",
      "status": "modified",
      "additions": 9,
      "deletions": 16,
      "changes": 25,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/6da4b03afbe5e621eddf1dd8ad867a0c967be0ed/src%2Fmain%2Fjava%2Frx%2Fschedulers%2FTrampolineScheduler.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/6da4b03afbe5e621eddf1dd8ad867a0c967be0ed/src%2Fmain%2Fjava%2Frx%2Fschedulers%2FTrampolineScheduler.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Frx%2Fschedulers%2FTrampolineScheduler.java?ref=6da4b03afbe5e621eddf1dd8ad867a0c967be0ed",
      "patch": "@@ -15,7 +15,7 @@\n  */\n package rx.schedulers;\n \n-import java.util.PriorityQueue;\n+import java.util.concurrent.PriorityBlockingQueue;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n@@ -45,14 +45,12 @@ public Worker createWorker() {\n     /* package accessible for unit tests */TrampolineScheduler() {\n     }\n \n-    volatile int counter;\n-    static final AtomicIntegerFieldUpdater<TrampolineScheduler> COUNTER_UPDATER = AtomicIntegerFieldUpdater.newUpdater(TrampolineScheduler.class, \"counter\");\n-\n     private class InnerCurrentThreadScheduler extends Scheduler.Worker implements Subscription {\n \n-        final PriorityQueue<TimedAction> queue = new PriorityQueue<TimedAction>();\n+        private final PriorityBlockingQueue<TimedAction> queue = new PriorityBlockingQueue<TimedAction>();\n         private final BooleanSubscription innerSubscription = new BooleanSubscription();\n         private final AtomicInteger wip = new AtomicInteger();\n+        private final AtomicInteger counter = new AtomicInteger();\n \n         @Override\n         public Subscription schedule(Action0 action) {\n@@ -70,18 +68,15 @@ private Subscription enqueue(Action0 action, long execTime) {\n             if (innerSubscription.isUnsubscribed()) {\n                 return Subscriptions.unsubscribed();\n             }\n-            final TimedAction timedAction = new TimedAction(action, execTime, COUNTER_UPDATER.incrementAndGet(TrampolineScheduler.this));\n-            synchronized (queue) {\n-                queue.add(timedAction);\n-            }\n+            final TimedAction timedAction = new TimedAction(action, execTime, counter.incrementAndGet());\n+            queue.add(timedAction);\n \n             if (wip.getAndIncrement() == 0) {\n                 do {\n-                    TimedAction polled;\n-                    synchronized (queue) {\n-                        polled = queue.poll();\n+                    final TimedAction polled = queue.poll();\n+                    if (polled != null) {\n+                      polled.action.call();\n                     }\n-                    polled.action.call();\n                 } while (wip.decrementAndGet() > 0);\n                 return Subscriptions.unsubscribed();\n             } else {\n@@ -90,9 +85,7 @@ private Subscription enqueue(Action0 action, long execTime) {\n \n                     @Override\n                     public void call() {\n-                        synchronized (queue) {\n-                            queue.remove(timedAction);\n-                        }\n+                        queue.remove(timedAction);\n                     }\n \n                 });",
      "parent_sha": "28ec4c794a8cb7d1f86c9725403d29b2e6130396"
    }
  },
  {
    "oid": "11fe816ffde92253a94da8f72e59b35cd5eb6326",
    "message": "adding Func5-9 and N to the wrapper",
    "date": "2013-09-06T17:43:08Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/11fe816ffde92253a94da8f72e59b35cd5eb6326",
    "details": {
      "sha": "9937ae1a9a5f36dbdc122467d53244999f2b87d0",
      "filename": "language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyFunctionWrapper.java",
      "status": "modified",
      "additions": 48,
      "deletions": 2,
      "changes": 50,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/11fe816ffde92253a94da8f72e59b35cd5eb6326/language-adaptors%2Frxjava-groovy%2Fsrc%2Fmain%2Fjava%2Frx%2Flang%2Fgroovy%2FGroovyFunctionWrapper.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/11fe816ffde92253a94da8f72e59b35cd5eb6326/language-adaptors%2Frxjava-groovy%2Fsrc%2Fmain%2Fjava%2Frx%2Flang%2Fgroovy%2FGroovyFunctionWrapper.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/language-adaptors%2Frxjava-groovy%2Fsrc%2Fmain%2Fjava%2Frx%2Flang%2Fgroovy%2FGroovyFunctionWrapper.java?ref=11fe816ffde92253a94da8f72e59b35cd5eb6326",
      "patch": "@@ -21,6 +21,12 @@\n import rx.util.functions.Func2;\n import rx.util.functions.Func3;\n import rx.util.functions.Func4;\n+import rx.util.functions.Func5;\n+import rx.util.functions.Func6;\n+import rx.util.functions.Func7;\n+import rx.util.functions.Func8;\n+import rx.util.functions.Func9;\n+import rx.util.functions.FuncN;\n import rx.util.functions.Function;\n \n /**\n@@ -32,11 +38,21 @@\n  * @param <T4>\n  * @param <R>\n  */\n-public class GroovyFunctionWrapper<T1, T2, T3, T4, R> implements Func0<R>, Func1<T1, R>, Func2<T1, T2, R>, Func3<T1, T2, T3, R>, Func4<T1, T2, T3, T4, R> {\n+public class GroovyFunctionWrapper<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> implements\n+        Func0<R>,\n+        Func1<T1, R>,\n+        Func2<T1, T2, R>,\n+        Func3<T1, T2, T3, R>,\n+        Func4<T1, T2, T3, T4, R>,\n+        Func5<T1, T2, T3, T4, T5, R>,\n+        Func6<T1, T2, T3, T4, T5, T6, R>,\n+        Func7<T1, T2, T3, T4, T5, T6, T7, R>,\n+        Func8<T1, T2, T3, T4, T5, T6, T7, T8, R>,\n+        Func9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>,\n+        FuncN<R> {\n \n     private final Closure<R> closure;\n \n-    \n     public GroovyFunctionWrapper(Closure<R> closure) {\n         this.closure = closure;\n     }\n@@ -65,4 +81,34 @@ public R call(T1 t1, T2 t2, T3 t3) {\n     public R call(T1 t1, T2 t2, T3 t3, T4 t4) {\n         return (R) closure.call(t1, t2, t3, t4);\n     }\n+\n+    @Override\n+    public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) {\n+        return (R) closure.call(t1, t2, t3, t4, t5);\n+    }\n+\n+    @Override\n+    public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) {\n+        return (R) closure.call(t1, t2, t3, t4, t5, t6);\n+    }\n+\n+    @Override\n+    public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7) {\n+        return (R) closure.call(t1, t2, t3, t4, t5, t6, t7);\n+    }\n+\n+    @Override\n+    public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8) {\n+        return (R) closure.call(t1, t2, t3, t4, t5, t6, t7, t8);\n+    }\n+\n+    @Override\n+    public R call(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9) {\n+        return (R) closure.call(t1, t2, t3, t4, t5, t6, t7, t8, t9);\n+    }\n+\n+    @Override\n+    public R call(Object... args) {\n+        return (R) closure.call(args);\n+    }\n }\n\\ No newline at end of file",
      "parent_sha": "abaa9d73e04472d69f3edde8363fda62a9af6ff0"
    }
  },
  {
    "oid": "d764c1b09de4470e98cb36d7e7300536fc8d9ef7",
    "message": "Optimize Swing-RelativeMouseMotion pipeline",
    "date": "2014-02-12T12:41:25Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/d764c1b09de4470e98cb36d7e7300536fc8d9ef7",
    "details": {
      "sha": "ebf5e5cd6218858c949138850ed66c1e75e00733",
      "filename": "rxjava-contrib/rxjava-swing/src/main/java/rx/swing/sources/MouseEventSource.java",
      "status": "modified",
      "additions": 5,
      "deletions": 28,
      "changes": 33,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/d764c1b09de4470e98cb36d7e7300536fc8d9ef7/rxjava-contrib%2Frxjava-swing%2Fsrc%2Fmain%2Fjava%2Frx%2Fswing%2Fsources%2FMouseEventSource.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/d764c1b09de4470e98cb36d7e7300536fc8d9ef7/rxjava-contrib%2Frxjava-swing%2Fsrc%2Fmain%2Fjava%2Frx%2Fswing%2Fsources%2FMouseEventSource.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-contrib%2Frxjava-swing%2Fsrc%2Fmain%2Fjava%2Frx%2Fswing%2Fsources%2FMouseEventSource.java?ref=d764c1b09de4470e98cb36d7e7300536fc8d9ef7",
      "patch": "@@ -120,36 +120,13 @@ public void call() {\n      * @see rx.observables.SwingObservable#fromRelativeMouseMotion\n      */\n     public static Observable<Point> fromRelativeMouseMotion(final Component component) {\n-        class OldAndRelative {\n-            public final Point old;\n-            public final Point relative;\n-\n-            private OldAndRelative(Point old, Point relative) {\n-                this.old = old;\n-                this.relative = relative;\n-            }\n-        }\n-        \n-        class Relativize implements Func2<OldAndRelative, MouseEvent, OldAndRelative> {\n+        final Observable<MouseEvent> events = fromMouseMotionEventsOf(component);\n+        return Observable.zip(events, events.skip(1), new Func2<MouseEvent, MouseEvent, Point>() {\n             @Override\n-            public OldAndRelative call(OldAndRelative last, MouseEvent event) {\n-                Point current = new Point(event.getX(), event.getY());\n-                Point relative = new Point(current.x - last.old.x, current.y - last.old.y);\n-                return new OldAndRelative(current, relative);\n+            public Point call(MouseEvent ev1, MouseEvent ev2) {\n+                return new Point(ev2.getX() - ev1.getX(), ev2.getY() - ev1.getY());\n             }\n-        }\n-        \n-        class OnlyRelative implements Func1<OldAndRelative, Point> {\n-            @Override\n-            public Point call(OldAndRelative oar) {\n-                return oar.relative;\n-            }\n-        }\n-        \n-        return fromMouseMotionEventsOf(component)\n-                    .scan(new OldAndRelative(new Point(0, 0), new Point(0, 0)), new Relativize())\n-                    .map(new OnlyRelative())\n-                    .skip(2); // skip the useless initial value and the invalid first computation\n+        });\n     }\n     \n     public static class UnitTest {",
      "parent_sha": "1a86347cdd4e79fa7cf80c08f1361e8e6ff979b7"
    }
  },
  {
    "oid": "db627720e5518845677dff536e6b0f2d9e5c2ea3",
    "message": "Fix JavaDoc image for Single#flatMapObservable (#5297)\n\n`Single.flatMapObservable.png` should be used for `Single#flatMapObservable` instead of `Single.flatMap.png`.",
    "date": "2017-04-20T09:09:46Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/db627720e5518845677dff536e6b0f2d9e5c2ea3",
    "details": {
      "sha": "2944c741bd3ab8f72a9bc80a3029d93d1a6232ed",
      "filename": "src/main/java/io/reactivex/Single.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/db627720e5518845677dff536e6b0f2d9e5c2ea3/src%2Fmain%2Fjava%2Fio%2Freactivex%2FSingle.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/db627720e5518845677dff536e6b0f2d9e5c2ea3/src%2Fmain%2Fjava%2Fio%2Freactivex%2FSingle.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Fio%2Freactivex%2FSingle.java?ref=db627720e5518845677dff536e6b0f2d9e5c2ea3",
      "patch": "@@ -2097,7 +2097,7 @@ public final <U> Observable<U> flattenAsObservable(final Function<? super T, ? e\n      * Returns an Observable that is based on applying a specified function to the item emitted by the source Single,\n      * where that function returns a SingleSource.\n      * <p>\n-     * <img width=\"640\" height=\"300\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMap.png\" alt=\"\">\n+     * <img width=\"640\" height=\"300\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMapObservable.png\" alt=\"\">\n      * <dl>\n      * <dt><b>Scheduler:</b></dt>\n      * <dd>{@code flatMapObservable} does not operate by default on a particular {@link Scheduler}.</dd>",
      "parent_sha": "67a951b655b73d2222b8ddc6b93532688c487b77"
    }
  },
  {
    "oid": "31b41f8d4b0d0534a883a71491ad39f326ebff36",
    "message": "2.x: fix periodic scheduler purging config not honored (#5441)",
    "date": "2017-06-27T13:11:50Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/31b41f8d4b0d0534a883a71491ad39f326ebff36",
    "details": {
      "sha": "7aa5bb6a19bc16846de4a5c61043e460429bbb15",
      "filename": "src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java",
      "status": "modified",
      "additions": 11,
      "deletions": 5,
      "changes": 16,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/31b41f8d4b0d0534a883a71491ad39f326ebff36/src%2Fmain%2Fjava%2Fio%2Freactivex%2Finternal%2Fschedulers%2FSchedulerPoolFactory.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/31b41f8d4b0d0534a883a71491ad39f326ebff36/src%2Fmain%2Fjava%2Fio%2Freactivex%2Finternal%2Fschedulers%2FSchedulerPoolFactory.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Fio%2Freactivex%2Finternal%2Fschedulers%2FSchedulerPoolFactory.java?ref=31b41f8d4b0d0534a883a71491ad39f326ebff36",
      "patch": "@@ -57,6 +57,9 @@ private SchedulerPoolFactory() {\n      * Starts the purge thread if not already started.\n      */\n     public static void start() {\n+        if (!PURGE_ENABLED) {\n+            return;\n+        }\n         for (;;) {\n             ScheduledExecutorService curr = PURGE_THREAD.get();\n             if (curr != null && !curr.isShutdown()) {\n@@ -78,7 +81,10 @@ public static void start() {\n      * Stops the purge thread.\n      */\n     public static void shutdown() {\n-        PURGE_THREAD.get().shutdownNow();\n+        ScheduledExecutorService exec = PURGE_THREAD.get();\n+        if (exec != null) {\n+            exec.shutdownNow();\n+        }\n         POOLS.clear();\n     }\n \n@@ -90,10 +96,10 @@ public static void shutdown() {\n \n         if (properties.containsKey(PURGE_ENABLED_KEY)) {\n             purgeEnable = Boolean.getBoolean(PURGE_ENABLED_KEY);\n+        }\n \n-            if (purgeEnable && properties.containsKey(PURGE_PERIOD_SECONDS_KEY)) {\n-                purgePeriod = Integer.getInteger(PURGE_PERIOD_SECONDS_KEY, purgePeriod);\n-            }\n+        if (purgeEnable && properties.containsKey(PURGE_PERIOD_SECONDS_KEY)) {\n+            purgePeriod = Integer.getInteger(PURGE_PERIOD_SECONDS_KEY, purgePeriod);\n         }\n \n         PURGE_ENABLED = purgeEnable;\n@@ -109,7 +115,7 @@ public static void shutdown() {\n      */\n     public static ScheduledExecutorService create(ThreadFactory factory) {\n         final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, factory);\n-        if (exec instanceof ScheduledThreadPoolExecutor) {\n+        if (PURGE_ENABLED && exec instanceof ScheduledThreadPoolExecutor) {\n             ScheduledThreadPoolExecutor e = (ScheduledThreadPoolExecutor) exec;\n             POOLS.put(e, exec);\n         }",
      "parent_sha": "39e5d91fc936124fa9ac32f3289b3cd37351e576"
    }
  },
  {
    "oid": "939f172b5fd39fdc83e353fa0b4626a8a61e3ee4",
    "message": "Fix wrong javadoc tag.",
    "date": "2016-09-08T13:39:42Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/939f172b5fd39fdc83e353fa0b4626a8a61e3ee4",
    "details": {
      "sha": "7cc195bac82915d1125019b180118da52592c8ea",
      "filename": "src/main/java/io/reactivex/MaybeObserver.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/939f172b5fd39fdc83e353fa0b4626a8a61e3ee4/src%2Fmain%2Fjava%2Fio%2Freactivex%2FMaybeObserver.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/939f172b5fd39fdc83e353fa0b4626a8a61e3ee4/src%2Fmain%2Fjava%2Fio%2Freactivex%2FMaybeObserver.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Fio%2Freactivex%2FMaybeObserver.java?ref=939f172b5fd39fdc83e353fa0b4626a8a61e3ee4",
      "patch": "@@ -21,7 +21,7 @@\n  * first the Maybe calls {@link #onSubscribe(Disposable)} with a {@link Disposable} that allows\n  * cancelling the sequence at any time, then the\n  * {@code Maybe} calls only one of the MaybeObserver's {@link #onSuccess}, {@link #onError} or\n- * {@lingk onComplete} methods to provide notifications.\n+ * {@link #onComplete} methods to provide notifications.\n  *\n  * @see <a href=\"http://reactivex.io/documentation/observable.html\">ReactiveX documentation: Observable</a>\n  * @param <T>",
      "parent_sha": "34a0c6c0ff5191d4cb9e516bfda07e987498e380"
    }
  },
  {
    "oid": "70bd7099ec082958928b821e89fbb7c76b1ed01c",
    "message": "Switched to a default scheduler that actually works together with this\noperator.",
    "date": "2013-04-08T21:58:15Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/70bd7099ec082958928b821e89fbb7c76b1ed01c",
    "details": {
      "sha": "0e03b7fe7576a20751ce9617fa44a05f8cc38101",
      "filename": "rxjava-core/src/main/java/rx/operators/OperationInterval.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/70bd7099ec082958928b821e89fbb7c76b1ed01c/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationInterval.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/70bd7099ec082958928b821e89fbb7c76b1ed01c/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationInterval.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationInterval.java?ref=70bd7099ec082958928b821e89fbb7c76b1ed01c",
      "patch": "@@ -18,6 +18,7 @@\n import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n \n+import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n@@ -45,7 +46,7 @@ public final class OperationInterval {\n      * Creates an event each time interval.\n      */\n     public static Func1<Observer<Long>, Subscription> interval(long interval, TimeUnit unit) {\n-        return new Interval(interval, unit, Schedulers.currentThread());\n+        return new Interval(interval, unit, Schedulers.executor(Executors.newSingleThreadScheduledExecutor()));\n     }\n \n     /**",
      "parent_sha": "0181f0ef2b7564fbca01435449c0cbb879deaaaa"
    }
  },
  {
    "oid": "50d38b72bdb091aba97e030f6143ee56e49c9708",
    "message": "Add guards around log statements",
    "date": "2013-10-14T08:23:18Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/50d38b72bdb091aba97e030f6143ee56e49c9708",
    "details": {
      "sha": "b2ce5b0bf67fb364f200dd7fa8b769bb0e3e6c69",
      "filename": "rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperationObserveFromAndroidComponent.java",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/50d38b72bdb091aba97e030f6143ee56e49c9708/rxjava-contrib%2Frxjava-android%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationObserveFromAndroidComponent.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/50d38b72bdb091aba97e030f6143ee56e49c9708/rxjava-contrib%2Frxjava-android%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationObserveFromAndroidComponent.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-contrib%2Frxjava-android%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationObserveFromAndroidComponent.java?ref=50d38b72bdb091aba97e030f6143ee56e49c9708",
      "patch": "@@ -61,9 +61,11 @@ private OnSubscribeBase(Observable<T> source, AndroidComponent component) {\n         }\n \n         private void log(String message) {\n-            Log.d(LOG_TAG, \"componentRef = \" + componentRef);\n-            Log.d(LOG_TAG, \"observerRef = \" + observerRef);\n-            Log.d(LOG_TAG, message);\n+            if (Log.isLoggable(LOG_TAG, Log.DEBUG)) {\n+                Log.d(LOG_TAG, \"componentRef = \" + componentRef);\n+                Log.d(LOG_TAG, \"observerRef = \" + observerRef);\n+                Log.d(LOG_TAG, message);\n+            }\n         }\n \n         protected abstract boolean isComponentValid(AndroidComponent component);",
      "parent_sha": "8e0343e6cbdbb861b44b1982769145f3d9686d69"
    }
  },
  {
    "oid": "fcfa4e83845ca21a5a622a726d346b46c487dce0",
    "message": "ensure this does not escape from ObserveOnSubscriber constructor by moving code to an init() method and calling after construction",
    "date": "2015-04-29T07:34:54Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/fcfa4e83845ca21a5a622a726d346b46c487dce0",
    "details": {
      "sha": "13a78ca14c6ca0178a40eac4064a8337076d40a7",
      "filename": "src/main/java/rx/internal/operators/OperatorObserveOn.java",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/fcfa4e83845ca21a5a622a726d346b46c487dce0/src%2Fmain%2Fjava%2Frx%2Finternal%2Foperators%2FOperatorObserveOn.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/fcfa4e83845ca21a5a622a726d346b46c487dce0/src%2Fmain%2Fjava%2Frx%2Finternal%2Foperators%2FOperatorObserveOn.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Frx%2Finternal%2Foperators%2FOperatorObserveOn.java?ref=fcfa4e83845ca21a5a622a726d346b46c487dce0",
      "patch": "@@ -61,7 +61,9 @@ public Subscriber<? super T> call(Subscriber<? super T> child) {\n             // avoid overhead, execute directly\n             return child;\n         } else {\n-            return new ObserveOnSubscriber<T>(scheduler, child);\n+            ObserveOnSubscriber<T> parent = new ObserveOnSubscriber<T>(scheduler, child);\n+            parent.init();\n+            return parent;\n         }\n     }\n \n@@ -98,6 +100,11 @@ public ObserveOnSubscriber(Scheduler scheduler, Subscriber<? super T> child) {\n                 queue = new SynchronizedQueue<Object>(RxRingBuffer.SIZE);\n             }\n             this.scheduledUnsubscribe = new ScheduledUnsubscribe(recursiveScheduler);\n+        }\n+        \n+        void init() {\n+            // don't want this code in the constructor because `this` can escape through the \n+            // setProducer call\n             child.add(scheduledUnsubscribe);\n             child.setProducer(new Producer() {\n ",
      "parent_sha": "f6ca9ee01c835a5be384ca5dfecf97dc740e2ad6"
    }
  },
  {
    "oid": "5f452559382bab37efd181071c047f260fd26fd1",
    "message": "enhance test for groupBy with evicting map factory (#5867)",
    "date": "2018-02-26T23:22:45Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/5f452559382bab37efd181071c047f260fd26fd1",
    "details": {
      "sha": "cccfb38a0f93fd05ab95a19b35078d9851766ca4",
      "filename": "src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/5f452559382bab37efd181071c047f260fd26fd1/src%2Ftest%2Fjava%2Fio%2Freactivex%2Finternal%2Foperators%2Fflowable%2FFlowableGroupByTest.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/5f452559382bab37efd181071c047f260fd26fd1/src%2Ftest%2Fjava%2Fio%2Freactivex%2Finternal%2Foperators%2Fflowable%2FFlowableGroupByTest.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Ftest%2Fjava%2Fio%2Freactivex%2Finternal%2Foperators%2Fflowable%2FFlowableGroupByTest.java?ref=5f452559382bab37efd181071c047f260fd26fd1",
      "patch": "@@ -1996,7 +1996,7 @@ public V put(K key, V value) {\n                 //remove first\n                 K k = list.get(0);\n                 list.remove(0);\n-                v = map.get(k);\n+                v = map.remove(k);\n             } else {\n                 v = null;\n             }\n@@ -2014,16 +2014,20 @@ public V put(K key, V value) {\n \n         @Override\n         public V remove(Object key) {\n+            list.remove(key);\n             return map.remove(key);\n         }\n \n         @Override\n         public void putAll(Map<? extends K, ? extends V> m) {\n-            map.putAll(m);\n+           for (Entry<? extends K, ? extends V> entry: m.entrySet()) {\n+               put(entry.getKey(), entry.getValue()); \n+           }\n         }\n \n         @Override\n         public void clear() {\n+            list.clear();\n             map.clear();\n         }\n ",
      "parent_sha": "3346ff9a868b74ae767905e5e4185e81d58f4a98"
    }
  },
  {
    "oid": "21201034b66220709b9b65b43a1e1fa85b628955",
    "message": "Give unit test some room for scheduler variability\n\n- I specifically want to be testing with real threads here and not virtual time or a synchronous sequence so am giving it a range of counts that are acceptable",
    "date": "2013-06-05T04:34:59Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/21201034b66220709b9b65b43a1e1fa85b628955",
    "details": {
      "sha": "270c2de96f967588d5a7821d1aa8bd229fe49c97",
      "filename": "rxjava-core/src/main/java/rx/operators/OperationGroupBy.java",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/21201034b66220709b9b65b43a1e1fa85b628955/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationGroupBy.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/21201034b66220709b9b65b43a1e1fa85b628955/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationGroupBy.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationGroupBy.java?ref=21201034b66220709b9b65b43a1e1fa85b628955",
      "patch": "@@ -464,7 +464,7 @@ public void testUnsubscribe() throws InterruptedException {\n                 @Override\n                 public Subscription call(final Observer<Event> observer) {\n                     final BooleanSubscription s = new BooleanSubscription();\n-                    System.out.println(\"*** Subscribing to EventStream ***\");\n+                    System.out.println(\"testUnsubscribe => *** Subscribing to EventStream ***\");\n                     subscribeCounter.incrementAndGet();\n                     new Thread(new Runnable() {\n \n@@ -501,7 +501,7 @@ public Integer call(Event e) {\n \n                         @Override\n                         public Observable<String> call(GroupedObservable<Integer, Event> eventGroupedObservable) {\n-                            System.out.println(\"GroupedObservable Key: \" + eventGroupedObservable.getKey());\n+                            System.out.println(\"testUnsubscribe => GroupedObservable Key: \" + eventGroupedObservable.getKey());\n                             groupCounter.incrementAndGet();\n \n                             return eventGroupedObservable\n@@ -510,7 +510,7 @@ public Observable<String> call(GroupedObservable<Integer, Event> eventGroupedObs\n \n                                         @Override\n                                         public String call(Event event) {\n-                                            return \"Source: \" + event.source + \"  Message: \" + event.message;\n+                                            return \"testUnsubscribe => Source: \" + event.source + \"  Message: \" + event.message;\n                                         }\n                                     });\n \n@@ -540,10 +540,10 @@ public void onNext(String outputMessage) {\n             assertEquals(1, groupCounter.get());\n             assertEquals(20, eventCounter.get());\n             // sentEvents will go until 'eventCounter' hits 20 and then unsubscribes\n-            // which means it will also send (but ignore) the 19 events for the other group\n+            // which means it will also send (but ignore) the 19/20 events for the other group\n             // It will not however send all 100 events.\n-            assertEquals(39, sentEventCounter.get());\n-\n+            assertEquals(39, sentEventCounter.get(), 2);\n+            // gave it a delta of 2 so the threading/unsubscription race has wiggle \n         }\n \n         private static class Event {",
      "parent_sha": "eb932d8a9eacb6517cf18c68edbb722fe98ec505"
    }
  },
  {
    "oid": "bdf70f5716276c6cfd173db8b167644dee226b86",
    "message": "replay() and timer() javadocs: diagrams & wiki links",
    "date": "2013-12-13T00:57:18Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/bdf70f5716276c6cfd173db8b167644dee226b86",
    "details": {
      "sha": "5d98df26b9172655ae12566b6628a0a2ecccbea4",
      "filename": "rxjava-core/src/main/java/rx/Observable.java",
      "status": "modified",
      "additions": 180,
      "deletions": 120,
      "changes": 300,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/bdf70f5716276c6cfd173db8b167644dee226b86/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/bdf70f5716276c6cfd173db8b167644dee226b86/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java?ref=bdf70f5716276c6cfd173db8b167644dee226b86",
      "patch": "@@ -532,13 +532,14 @@ public <R> ConnectableObservable<R> multicast(Subject<? super T, ? extends R> su\n      * produced by multicasting the source sequence within a selector function.\n      * \n      * @param subjectFactory the subject factory\n-     * @param selector The selector function which can use the multicasted \n+     * @param selector the selector function which can use the multicasted \n      *                 source sequence subject to the policies enforced by the \n-     *                 created subject.\n+     *                 created subject\n      * @return the Observable sequence that contains the elements of a sequence\n-     *         produced by multicasting the source sequence within a selector function.\n-     * \n-     * @see <a href='http://msdn.microsoft.com/en-us/library/hh229708.aspx'>MSDN: Observable.Multicast</a>\n+     *         produced by multicasting the source sequence within a selector\n+     *         function\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablepublish-and-observablemulticast\">RxJava: Observable.publish() and Observable.multicast()</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229708.aspx\">MSDN: Observable.Multicast</a>\n      */\n     public <TIntermediate, TResult> Observable<TResult> multicast(\n             final Func0<? extends Subject<? super T, ? extends TIntermediate>> subjectFactory, \n@@ -2044,31 +2045,44 @@ public static Observable<Long> timer(long delay, TimeUnit unit, Scheduler schedu\n     }\n     \n     /**\n-     * Return an Observable which emits a 0L after the initialDelay and ever increasing\n-     * numbers after each period.\n+     * Return an Observable which emits a 0L after the {@code initialDelay} and\n+     * ever increasing numbers after each {@code period}.\n+     * <p>\n+     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timer.p.png\">\n      * \n-     * @param initialDelay the initial delay time to wait before emitting the first value of 0L\n+     * @param initialDelay the initial delay time to wait before emitting the\n+     *                     first value of 0L\n      * @param period the time period after emitting the subsequent numbers\n-     * @param unit the time unit for both <code>initialDelay</code> and <code>period</code>\n-     * @return an Observable which emits a 0L after the initialDelay and ever increasing\n-     *         numbers after each period\n-     * @see <a href='http://msdn.microsoft.com/en-us/library/hh229435.aspx'>MSDN: Observable.Timer</a>\n+     * @param unit the time unit for both <code>initialDelay</code> and\n+     *             <code>period</code>\n+     * @return an Observable which emits a 0L after the {@code initialDelay} and\n+     *         ever increasing numbers after each {@code period}\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Creating-Observables#timer\">RxJava Wiki: timer()</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229435.aspx\">MSDN: Observable.Timer</a>\n      */\n     public static Observable<Long> timer(long initialDelay, long period, TimeUnit unit) {\n         return timer(initialDelay, period, unit, Schedulers.threadPoolForComputation());\n     }\n     \n     /**\n-     * Return an Observable which emits a 0L after the initialDelay and ever increasing\n-     * numbers after each period while running on the given scheduler.\n+     * Return an Observable which emits a 0L after the {@code initialDelay} and\n+     * ever increasing numbers after each {@code period} while running on the\n+     * given {@code scheduler}.\n+     * <p>\n+     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timer.ps.png\">\n      * \n-     * @param initialDelay the initial delay time to wait before emitting the first value of 0L\n+     * @param initialDelay the initial delay time to wait before emitting the\n+     *                     first value of 0L\n      * @param period the time period after emitting the subsequent numbers\n-     * @param unit the time unit for both <code>initialDelay</code> and <code>period</code>\n-     * @param scheduler the scheduler where the waiting happens and value emissions run.\n-     * @return an Observable which emits a 0L after the initialDelay and ever increasing\n-     *         numbers after each period while running on the given scheduler\n-     * @see <a href='http://msdn.microsoft.com/en-us/library/hh229652.aspx'>MSDN: Observable.Timer</a>\n+     * @param unit the time unit for both <code>initialDelay</code> and\n+     *             <code>period</code>\n+     * @param scheduler the scheduler on which the waiting happens and value\n+     *                  emissions run\n+     * @return an Observable that emits a 0L after the {@code initialDelay} and\n+     *         ever increasing numbers after each {@code period} while running\n+     *         on the given {@code scheduler}\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Creating-Observables#timer\">RxJava Wiki: timer()</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229652.aspx\">MSDN: Observable.Timer</a>\n      */\n     public static Observable<Long> timer(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {\n         return create(new OperationTimer.TimerPeriodically(initialDelay, period, unit, scheduler));\n@@ -4332,42 +4346,55 @@ public ConnectableObservable<T> replay() {\n      * Returns a {@link ConnectableObservable} that shares a single subscription\n      * to the underlying Observable that will replay all of its items and\n      * notifications to any future {@link Observer} on the given scheduler.\n+     * <p>\n+     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.s.png\">\n      *\n-     * @param scheduler the scheduler where the Observers will receive the events\n+     * @param scheduler the scheduler on which the Observers will observe the\n+     *                  emitted items\n      * @return a {@link ConnectableObservable} that shares a single subscription\n-     *         to the underlying Observable that will replay all of its items and\n-     *         notifications to any future {@link Observer} on the given scheduler\n-     * \n-     * @see <a href='http://msdn.microsoft.com/en-us/library/hh211699.aspx'>MSDN: Observable.Replay</a>\n+     *         to the source Observable that will replay all of its items and\n+     *         notifications to any future {@link Observer} on the given\n+     *         scheduler\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay\">RxJava Wiki: replay()</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh211699.aspx\">MSDN: Observable.Replay</a>\n      */\n     public ConnectableObservable<T> replay(Scheduler scheduler) {\n          return OperationMulticast.multicast(this, OperationReplay.createScheduledSubject(ReplaySubject.<T>create(), scheduler));\n     }\n \n     /**\n-     * Returns a connectable observable sequence that shares a single subscription \n-     * to the underlying sequence replaying bufferSize notifications.\n+     * Returns a connectable observable sequence that shares a single\n+     * subscription to the source Observable that replays at most\n+     * {@code bufferSize} items emitted by that Observable.\n+     * <p>\n+     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.n.png\">\n      * \n      * @param bufferSize the buffer size\n-     * @return a connectable observable sequence that shares a single subscription \n-     *         to the underlying sequence replaying bufferSize notifications\n-     * \n-     * @see <a href='http://msdn.microsoft.com/en-us/library/hh211976.aspx'>MSDN: Observable.Replay</a>\n+     * @return a connectable observable sequence that shares a single \n+     *         subscription to the source Observable and replays at most\n+     *         {@code bufferSize} items emitted by that Observable\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay\">RxJava Wiki: replay()</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh211976.aspx\">MSDN: Observable.Replay</a>\n      */\n     public ConnectableObservable<T> replay(int bufferSize) {\n         return OperationMulticast.multicast(this, OperationReplay.<T>replayBuffered(bufferSize));\n     }\n \n     /**\n      * Returns a connectable observable sequence that shares a single \n-     * subscription to the underlying sequence replaying bufferSize notifications.\n+     * subscription to the source Observable and replays at most\n+     * {@code bufferSize} items emitted by that Observable.\n+     * <p>\n+     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.ns.png\">\n      * \n      * @param bufferSize the buffer size\n-     * @param scheduler the scheduler where the Observers will receive the events\n+     * @param scheduler the scheduler on which the Observers will observe the\n+     *                  emitted items\n      * @return a connectable observable sequence that shares a single \n-     *         subscription to the underlying sequence replaying bufferSize notifications\n-     * \n-     * @see <a href='http://msdn.microsoft.com/en-us/library/hh229814.aspx'>MSDN: Observable.Replay</a>\n+     *         subscription to the source Observable and replays at most\n+     *         {@code bufferSize} items emitted by that Observable\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay\">RxJava Wiki: replay()</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229814.aspx\">MSDN: Observable.Replay</a>\n      */\n     public ConnectableObservable<T> replay(int bufferSize, Scheduler scheduler) {\n         return OperationMulticast.multicast(this, \n@@ -4377,61 +4404,84 @@ public ConnectableObservable<T> replay(int bufferSize, Scheduler scheduler) {\n     \n     /**\n      * Returns a connectable observable sequence that shares a single \n-     * subscription to the underlying sequence replaying all notifications within window.\n+     * subscription to the source Observable and replays all items emitted by\n+     * that Observable within a time window.\n+     * <p>\n+     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.t.png\">\n      * \n      * @param time the window length\n      * @param unit the window length time unit\n      * @return a connectable observable sequence that shares a single \n-     *         subscription to the underlying sequence replaying all notifications within window\n-     * @see <a href='http://msdn.microsoft.com/en-us/library/hh229232.aspx'>MSDN: Observable.Replay</a>\n+     *         subscription to the source Observable and that replays all items\n+     *         emitted by that Observable during the window defined by\n+     *         {@code time} and {@code unit}\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay\">RxJava Wiki: replay()</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229232.aspx\">MSDN: Observable.Replay</a>\n      */\n     public ConnectableObservable<T> replay(long time, TimeUnit unit) {\n         return replay(time, unit, Schedulers.threadPoolForComputation());\n     }\n \n     /**\n      * Returns a connectable observable sequence that shares a single \n-     * subscription to the underlying sequence replaying all notifications within window.\n+     * subscription to the source Observable and replays all items emitted by\n+     * that Observable within a time window.\n+     * <p>\n+     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.ts.png\">\n      * \n      * @param time the window length\n      * @param unit the window length time unit\n-     * @param scheduler the scheduler which is used as a time source for the window\n+     * @param scheduler the scheduler that is used as a time source for the\n+     *                  window\n      * @return a connectable observable sequence that shares a single \n-     *         subscription to the underlying sequence replaying all notifications within window\n-     * @see <a href='http://msdn.microsoft.com/en-us/library/hh211811.aspx'>MSDN: Observable.Replay</a>\n+     *         subscription to the source Observable and replays all items\n+     *         emitted by that Observable within the window defined by\n+     *         {@code time} and {@code unit}\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay\">RxJava Wiki: replay()</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh211811.aspx\">MSDN: Observable.Replay</a>\n      */\n     public ConnectableObservable<T> replay(long time, TimeUnit unit, Scheduler scheduler) {\n         return OperationMulticast.multicast(this, OperationReplay.<T>replayWindowed(time, unit, -1, scheduler));\n     }\n \n     /**\n      * Returns a connectable observable sequence that shares a single \n-     * subscription to the underlying sequence replaying bufferSize notifications within window.\n+     * subscription to the underlying sequence replaying {@code bufferSize}\n+     * notifications within window.\n+     * <p>\n+     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.nt.png\">\n      * \n      * @param bufferSize the buffer size\n      * @param time the window length\n      * @param unit the window length time unit\n      * @return Returns a connectable observable sequence that shares a single \n      *         subscription to the underlying sequence replaying bufferSize notifications within window\n-     * \n-     * @see <a href='http://msdn.microsoft.com/en-us/library/hh229874.aspx'>MSDN: Observable.Replay</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay\">RxJava Wiki: replay()</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229874.aspx\">MSDN: Observable.Replay</a>\n      */\n     public ConnectableObservable<T> replay(int bufferSize, long time, TimeUnit unit) {\n          return replay(bufferSize, time, unit, Schedulers.threadPoolForComputation());\n     }\n \n     /**\n      * Returns a connectable observable sequence that shares a single \n-     * subscription to the underlying sequence replaying bufferSize notifications within window.\n+     * subscription to the underlying sequence and that replays a maximum of\n+     * {@code bufferSize} items that are emitted within the window defined by\n+     * {@code time} and {@code unit}.\n+     * <p>\n+     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/replay.nts.png\">\n      * \n      * @param bufferSize the buffer size\n      * @param time the window length\n      * @param unit the window length time unit\n-     * @param scheduler the scheduler which is used as a time source for the window\n+     * @param scheduler the scheduler that is used as a time source for the\n+     *                  window\n      * @return a connectable observable sequence that shares a single \n-     *         subscription to the underlying sequence replaying bufferSize notifications within window\n-     * \n-     * @see <a href='http://msdn.microsoft.com/en-us/library/hh211759.aspx'>MSDN: Observable.Replay</a>\n+     *         subscription to the underlying sequence that replays a maximum of\n+     *         {@code bufferSize} items that are emitted within the window\n+     *         defined by {@code time} and {@code unit}\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay\">RxJava Wiki: replay()</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh211759.aspx\">MSDN: Observable.Replay</a>\n      */\n     public ConnectableObservable<T> replay(int bufferSize, long time, TimeUnit unit, Scheduler scheduler) {\n         if (bufferSize < 0) {\n@@ -4441,19 +4491,20 @@ public ConnectableObservable<T> replay(int bufferSize, long time, TimeUnit unit,\n     }\n     \n     /**\n-     * Returns an observable sequence that is the result of invoking the selector \n-     * on a connectable observable sequence that shares a single subscription to \n-     * the underlying sequence and starts with initial value.\n+     * Returns an observable sequence that is the result of invoking the\n+     * selector on a connectable observable sequence that shares a single\n+     * subscription to the underlying sequence and starts with initial value.\n      * \n      * @param <R> the return element type\n-     * @param selector The selector function which can use the multicasted \n+     * @param selector the selector function which can use the multicasted \n      *                 this sequence as many times as needed, without causing \n-     *                 multiple subscriptions to this sequence.\n-     * @return an observable sequence that is the result of invoking the selector \n-     *         on a connectable observable sequence that shares a single subscription to \n-     *         the underlying sequence and starts with initial value\n-     * \n-     * @see <a href='http://msdn.microsoft.com/en-us/library/hh229653.aspx'>MSDN: Observable.Replay</a>\n+     *                 multiple subscriptions to this sequence\n+     * @return an observable sequence that is the result of invoking the\n+     *         selector on a connectable observable sequence that shares a\n+     *         single subscription to the underlying sequence and starts with\n+     *         initial value\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay\">RxJava Wiki: replay()</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229653.aspx\">MSDN: Observable.Replay</a>\n      */\n     public <R> Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector) {\n         return OperationMulticast.multicast(this, new Func0<Subject<T, T>>() {\n@@ -4470,15 +4521,16 @@ public Subject<T, T> call() {\n      * subscription to the underlying sequence replaying all notifications.\n      * \n      * @param <R> the return element type\n-     * @param selector The selector function which can use the multicasted \n+     * @param selector the selector function which can use the multicasted \n      *                 this sequence as many times as needed, without causing \n-     *                 multiple subscriptions to this sequence.\n+     *                 multiple subscriptions to this sequence\n      * @param scheduler the scheduler where the replay is observed\n      * @return an observable sequence that is the result of invoking the \n-     *         selector on a connectable observable sequence that shares a single \n-     *         subscription to the underlying sequence replaying all notifications\n-     * \n-     * @see <a href='http://msdn.microsoft.com/en-us/library/hh211644.aspx'>MSDN: Observable.Replay</a>\n+     *         selector on a connectable observable sequence that shares a\n+     *         single subscription to the underlying sequence replaying all\n+     *         notifications\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay\">RxJava Wiki: replay()</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh211644.aspx\">MSDN: Observable.Replay</a>\n      */\n     public <R> Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, final Scheduler scheduler) {\n         return OperationMulticast.multicast(this, new Func0<Subject<T, T>>() {\n@@ -4492,18 +4544,20 @@ public Subject<T, T> call() {\n     /**\n      * Returns an observable sequence that is the result of invoking the \n      * selector on a connectable observable sequence that shares a single \n-     * subscription to the underlying sequence replaying bufferSize notifications.\n+     * subscription to the underlying sequence replaying {@code bufferSize}\n+     * notifications.\n      * \n      * @param <R> the return element type\n-     * @param selector The selector function which can use the multicasted \n+     * @param selector the selector function which can use the multicasted \n      *                 this sequence as many times as needed, without causing \n-     *                 multiple subscriptions to this sequence.\n+     *                 multiple subscriptions to this sequence\n      * @param bufferSize the buffer size\n      * @return an observable sequence that is the result of invoking the \n-     *         selector on a connectable observable sequence that shares a single \n-     *         subscription to the underlying sequence replaying bufferSize notifications\n-     * \n-     * @see <a href='http://msdn.microsoft.com/en-us/library/hh211675.aspx'>MSDN: Observable.Replay</a>\n+     *         selector on a connectable observable sequence that shares a\n+     *         single subscription to the underlying sequence replaying\n+     *         {@code bufferSize} notifications\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay\">RxJava Wiki: replay()</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh211675.aspx\">MSDN: Observable.Replay</a>\n      */\n     public <R> Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, final int bufferSize) {\n         return OperationMulticast.multicast(this, new Func0<Subject<T, T>>() {\n@@ -4517,19 +4571,21 @@ public Subject<T, T> call() {\n     /**\n      * Returns an observable sequence that is the result of invoking the \n      * selector on a connectable observable sequence that shares a single \n-     * subscription to the underlying sequence replaying bufferSize notifications.\n+     * subscription to the underlying sequence replaying {@code bufferSize}\n+     * notifications.\n      * \n      * @param <R> the return element type\n-     * @param selector The selector function which can use the multicasted \n+     * @param selector the selector function which can use the multicasted \n      *                 this sequence as many times as needed, without causing \n-     *                 multiple subscriptions to this sequence.\n+     *                 multiple subscriptions to this sequence\n      * @param bufferSize the buffer size\n      * @param scheduler the scheduler where the replay is observed\n      * @return an observable sequence that is the result of invoking the \n-     *         selector on a connectable observable sequence that shares a single \n-     *         subscription to the underlying sequence replaying bufferSize notifications\n-     * \n-     * @see <a href='http://msdn.microsoft.com/en-us/library/hh229928.aspx'>MSDN: Observable.Replay</a>\n+     *         selector on a connectable observable sequence that shares a\n+     *         single subscription to the underlying sequence replaying\n+     *         {@code bufferSize} notifications\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay\">RxJava Wiki: replay()</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229928.aspx\">MSDN: Observable.Replay</a>\n      */\n     public <R> Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, final int bufferSize, final Scheduler scheduler) {\n         return OperationMulticast.multicast(this, new Func0<Subject<T, T>>() {\n@@ -4541,21 +4597,23 @@ public Subject<T, T> call() {\n     }\n \n     /**\n-     * Returns an observable sequence that is the result of invoking \n-     * the selector on a connectable observable sequence that shares a single \n-     * subscription to the underlying sequence replaying all notifications within window.\n+     * Returns an observable sequence that is the result of invoking the\n+     * selector on a connectable observable sequence that shares a single \n+     * subscription to the underlying sequence replaying all notifications\n+     * within window.\n      * \n      * @param <R> the return element type\n-     * @param selector The selector function which can use the multicasted \n+     * @param selector the selector function which can use the multicasted \n      *                 this sequence as many times as needed, without causing \n-     *                 multiple subscriptions to this sequence.\n+     *                 multiple subscriptions to this sequence\n      * @param time the window length\n      * @param unit the window length time unit\n-     * @return an observable sequence that is the result of invoking \n-     *         the selector on a connectable observable sequence that shares a single \n-     *         subscription to the underlying sequence replaying all notifications within window\n-     * \n-     * @see <a href='http://msdn.microsoft.com/en-us/library/hh229526.aspx'>MSDN: Observable.Replay</a>\n+     * @return an observable sequence that is the result of invoking the\n+     *         selector on a connectable observable sequence that shares a\n+     *         single subscription to the underlying sequence replaying all\n+     *         notifications within window\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay\">RxJava Wiki: replay()</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229526.aspx\">MSDN: Observable.Replay</a>\n      */\n     public <R> Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, long time, TimeUnit unit) {\n         return replay(selector, time, unit, Schedulers.threadPoolForComputation());\n@@ -4564,20 +4622,23 @@ public <R> Observable<R> replay(Func1<? super Observable<T>, ? extends Observabl\n     /**\n      * Returns an observable sequence that is the result of invoking the \n      * selector on a connectable observable sequence that shares a single \n-     * subscription to the underlying sequence replaying all notifications within window.\n+     * subscription to the underlying sequence replaying all notifications\n+     * within window.\n      * \n      * @param <R> the return element type\n-     * @param selector The selector function which can use the multicasted \n+     * @param selector the selector function which can use the multicasted \n      *                 this sequence as many times as needed, without causing \n-     *                 multiple subscriptions to this sequence.\n+     *                 multiple subscriptions to this sequence\n      * @param time the window length\n      * @param unit the window length time unit\n-     * @param scheduler the scheduler which is used as a time source for the window\n+     * @param scheduler the scheduler that is used as a time source for the\n+     *                  window\n      * @return an observable sequence that is the result of invoking the \n-     *         selector on a connectable observable sequence that shares a single \n-     *         subscription to the underlying sequence replaying all notifications within window\n-     * \n-     * @see <a href='http://msdn.microsoft.com/en-us/library/hh244327.aspx'>MSDN: Observable.Replay</a>\n+     *         selector on a connectable observable sequence that shares a\n+     *         single subscription to the underlying sequence replaying all\n+     *         notifications within window\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay\">RxJava Wiki: replay()</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh244327.aspx\">MSDN: Observable.Replay</a>\n      */\n     public <R> Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, final long time, final TimeUnit unit, final Scheduler scheduler) {\n         return OperationMulticast.multicast(this, new Func0<Subject<T, T>>() {\n@@ -4591,23 +4652,22 @@ public Subject<T, T> call() {\n     /**\n      * Returns an observable sequence that is the result of invoking the \n      * selector on a connectable observable sequence that shares a single \n-     * subscription to the underlying sequence replaying bufferSize notifications \n-     * within window.\n+     * subscription to the underlying sequence replaying {@code bufferSize}\n+     * notifications within window.\n      * \n      * @param <R> the return element type\n-     * @param selector The selector function which can use the multicasted \n+     * @param selector the selector function which can use the multicasted \n      *                 this sequence as many times as needed, without causing \n-     *                 multiple subscriptions to this sequence.\n+     *                 multiple subscriptions to this sequence\n      * @param bufferSize the buffer size\n      * @param time the window length\n      * @param unit the window length time unit\n-     * \n      * @return an observable sequence that is the result of invoking the \n-     *         selector on a connectable observable sequence that shares a single \n-     *         subscription to the underlying sequence replaying bufferSize notifications \n-     *         within window\n-     * \n-     * @see <a href='http://msdn.microsoft.com/en-us/library/hh228952.aspx'>MSDN: Observable.Replay</a>\n+     *         selector on a connectable observable sequence that shares a\n+     *         single subscription to the underlying sequence replaying\n+     *         {@code bufferSize} notifications within window\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay\">RxJava Wiki: replay()</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh228952.aspx\">MSDN: Observable.Replay</a>\n      */\n     public <R> Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, int bufferSize, long time, TimeUnit unit) {\n         return replay(selector, bufferSize, time, unit, Schedulers.threadPoolForComputation());\n@@ -4617,24 +4677,24 @@ public <R> Observable<R> replay(Func1<? super Observable<T>, ? extends Observabl\n     /**\n      * Returns an observable sequence that is the result of invoking the \n      * selector on a connectable observable sequence that shares a single \n-     * subscription to the underlying sequence replaying bufferSize notifications \n-     * within window.\n+     * subscription to the underlying sequence replaying {@code bufferSize}\n+     * notifications within window.\n      * \n      * @param <R> the return element type\n-     * @param selector The selector function which can use the multicasted \n+     * @param selector the selector function which can use the multicasted \n      *                 this sequence as many times as needed, without causing \n-     *                 multiple subscriptions to this sequence.\n+     *                 multiple subscriptions to this sequence\n      * @param bufferSize the buffer size\n      * @param time the window length\n      * @param unit the window length time unit\n-     * @param scheduler the scheduler which is used as a time source for the window\n-     * \n+     * @param scheduler the scheduler which is used as a time source for the\n+     *                  window\n      * @return an observable sequence that is the result of invoking the \n-     *         selector on a connectable observable sequence that shares a single \n-     *         subscription to the underlying sequence replaying bufferSize notifications \n-     *         within window\n-     * \n-     * @see <a href='http://msdn.microsoft.com/en-us/library/hh229404.aspx'>MSDN: Observable.Replay</a>\n+     *         selector on a connectable observable sequence that shares a\n+     *         single subscription to the underlying sequence replaying\n+     *         {@code bufferSize} notifications within window\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Connectable-Observable-Operators#observablereplay\">RxJava Wiki: replay()</a>\n+     * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229404.aspx\">MSDN: Observable.Replay</a>\n      */\n     public <R> Observable<R> replay(Func1<? super Observable<T>, ? extends Observable<R>> selector, final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {\n         if (bufferSize < 0) {",
      "parent_sha": "6374bc8e03a450e5141861fefe4ae6f41f210c61"
    }
  },
  {
    "oid": "513a6b7d7d7b6035de395b0881b4cbc0cac81122",
    "message": "correcting typo causing build failure",
    "date": "2013-12-27T00:06:55Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/513a6b7d7d7b6035de395b0881b4cbc0cac81122",
    "details": {
      "sha": "87f5fe63b2b1497d2fb2229f35449e697a602bc6",
      "filename": "rxjava-core/src/main/java/rx/observables/BlockingObservable.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/513a6b7d7d7b6035de395b0881b4cbc0cac81122/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fobservables%2FBlockingObservable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/513a6b7d7d7b6035de395b0881b4cbc0cac81122/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fobservables%2FBlockingObservable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fobservables%2FBlockingObservable.java?ref=513a6b7d7d7b6035de395b0881b4cbc0cac81122",
      "patch": "@@ -1,4 +1,4 @@\n-**\n+/**\n  * Copyright 2013 Netflix, Inc.\n  * \n  * Licensed under the Apache License, Version 2.0 (the \"License\");",
      "parent_sha": "97f2b979dbf2ab278bb442233920461fb9348337"
    }
  },
  {
    "oid": "2d7b9660ef2825c25f2f3fbeda9acb96c3712575",
    "message": "Adding missing javadocs to TestSubject (#1322)",
    "date": "2014-06-24T16:53:20Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/2d7b9660ef2825c25f2f3fbeda9acb96c3712575",
    "details": {
      "sha": "2145be6f7b9e7f854553f493b37014e3d5b32e1e",
      "filename": "rxjava-core/src/main/java/rx/subjects/TestSubject.java",
      "status": "modified",
      "additions": 22,
      "deletions": 26,
      "changes": 48,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/2d7b9660ef2825c25f2f3fbeda9acb96c3712575/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fsubjects%2FTestSubject.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/2d7b9660ef2825c25f2f3fbeda9acb96c3712575/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fsubjects%2FTestSubject.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fsubjects%2FTestSubject.java?ref=2d7b9660ef2825c25f2f3fbeda9acb96c3712575",
      "patch": "@@ -26,35 +26,20 @@\n import rx.subjects.SubjectSubscriptionManager.SubjectObserver;\n \n /**\n- * Subject that, once an {@link Observer} has subscribed, publishes all subsequent events to the subscriber.\n- * <p>\n- * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/S.PublishSubject.png\">\n- * <p>\n- * Example usage:\n- * <p>\n- * <pre> {@code\n-\n-  PublishSubject<Object> subject = PublishSubject.create();\n-  // observer1 will receive all onNext and onCompleted events\n-  subject.subscribe(observer1);\n-  subject.onNext(\"one\");\n-  subject.onNext(\"two\");\n-  // observer2 will only receive \"three\" and onCompleted\n-  subject.subscribe(observer2);\n-  subject.onNext(\"three\");\n-  subject.onCompleted();\n-\n-  } </pre>\n- * \n+ * A variety of Subject that is useful for testing purposes. It operates on a {@link TestScheduler} and allows\n+ * you to precisely time emissions and notifications to the Subject's subscribers.\n+ *\n  * @param <T>\n  *          the type of item observed by and emitted by the subject\n- * @warn javadoc seems misleading\n  */\n public final class TestSubject<T> extends Subject<T, T> {\n \n     /**\n-     * @warn javadoc missing\n-     * @return\n+     * Creates and returns a new {@code TestSubject}.\n+     *\n+     * @param <T> the value type\n+     * @param scheduler a {@link TestScheduler} on which to operate this Subject\n+     * @return the new {@code TestSubject}\n      */\n     public static <T> TestSubject<T> create(TestScheduler scheduler) {\n         final SubjectSubscriptionManager<T> state = new SubjectSubscriptionManager<T>();\n@@ -95,8 +80,11 @@ private void _onCompleted() {\n     }\n \n     /**\n-     * @warn javadoc missing\n+     * Schedule a call to the {@code onCompleted} methods of all of the subscribers to this Subject to begin at\n+     * a particular time.\n+     * \n      * @param timeInMilliseconds\n+     *         the time at which to begin calling the {@code onCompleted} methods of the subscribers\n      */\n     public void onCompleted(long timeInMilliseconds) {\n         innerScheduler.schedule(new Action0() {\n@@ -123,9 +111,13 @@ private void _onError(final Throwable e) {\n     }\n \n     /**\n-     * @warn javadoc missing\n+     * Schedule a call to the {@code onError} methods of all of the subscribers to this Subject to begin at\n+     * a particular time.\n+     * \n      * @param e\n+     *         the {@code Throwable} to pass to the {@code onError} methods of the subscribers\n      * @param timeInMilliseconds\n+     *         the time at which to begin calling the {@code onError} methods of the subscribers\n      */\n     public void onError(final Throwable e, long timeInMilliseconds) {\n         innerScheduler.schedule(new Action0() {\n@@ -150,9 +142,13 @@ private void _onNext(T v) {\n     }\n \n     /**\n-     * @warn javadoc missing\n+     * Emit an item to all of the subscribers to this Subject at a particular time.\n+     * \n      * @param v\n+     *         the item to emit\n      * @param timeInMilliseconds\n+     *         the time at which to begin calling the {@code onNext} methods of the subscribers in order to emit\n+     *         the item\n      */\n     public void onNext(final T v, long timeInMilliseconds) {\n         innerScheduler.schedule(new Action0() {",
      "parent_sha": "bf29c611065894e9d383c739b93dcc48bb3bf9cb"
    }
  },
  {
    "oid": "109572d78b41a1f872b9688a76b174841e6a6750",
    "message": "Refactor RefCountSubscription\n\n- simplified logic\n- remove unnecessary busy spins and state changes",
    "date": "2013-12-23T20:02:59Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/109572d78b41a1f872b9688a76b174841e6a6750",
    "details": {
      "sha": "091b9dcb1e274415c06bff006b605fb4dc58cdcd",
      "filename": "rxjava-core/src/main/java/rx/subscriptions/RefCountSubscription.java",
      "status": "modified",
      "additions": 56,
      "deletions": 73,
      "changes": 129,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/109572d78b41a1f872b9688a76b174841e6a6750/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fsubscriptions%2FRefCountSubscription.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/109572d78b41a1f872b9688a76b174841e6a6750/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fsubscriptions%2FRefCountSubscription.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fsubscriptions%2FRefCountSubscription.java?ref=109572d78b41a1f872b9688a76b174841e6a6750",
      "patch": "@@ -16,8 +16,8 @@\n package rx.subscriptions;\n \n import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n+\n import rx.Subscription;\n \n /**\n@@ -27,21 +27,33 @@\n  * @see <a href='http://msdn.microsoft.com/en-us/library/system.reactive.disposables.refcountdisposable.aspx'>MSDN RefCountDisposable</a>\n  */\n public class RefCountSubscription implements Subscription {\n-    /** The state for the atomic operations. */\n-    private enum State {\n-        ACTIVE,\n-        MUTATING,\n-        UNSUBSCRIBED\n-    }\n-\n     /** The reference to the actual subscription. */\n-    private volatile Subscription main;\n-    /** The current state. */\n-    private final AtomicReference<State> state = new AtomicReference<State>();\n-    /** Counts the number of sub-subscriptions. */\n-    private final AtomicInteger count = new AtomicInteger();\n-    /** Indicate the request to unsubscribe from the main. */\n-    private final AtomicBoolean mainDone = new AtomicBoolean();\n+    private final Subscription actual;\n+    /** Counts the number of subscriptions (1 parent + multiple children) */\n+    private final AtomicReference<State> state = new AtomicReference<State>(new State(false, 0));\n+\n+    private static final class State {\n+        final boolean isUnsubscribed;\n+        final int children;\n+\n+        State(boolean u, int c) {\n+            this.isUnsubscribed = u;\n+            this.children = c;\n+        }\n+\n+        State addChild() {\n+            return new State(isUnsubscribed, children + 1);\n+        }\n+\n+        State removeChild() {\n+            return new State(isUnsubscribed, children - 1);\n+        }\n+\n+        State unsubscribe() {\n+            return new State(true, children);\n+        }\n+\n+    }\n \n     /**\n      * Create a RefCountSubscription by wrapping the given non-null Subscription.\n@@ -52,87 +64,52 @@ public RefCountSubscription(Subscription s) {\n         if (s == null) {\n             throw new IllegalArgumentException(\"s\");\n         }\n-        this.main = s;\n+        this.actual = s;\n     }\n \n     /**\n      * Returns a new sub-subscription.\n      */\n     public Subscription getSubscription() {\n+        State current;\n+        State newState;\n         do {\n-            State s = state.get();\n-            if (s == State.UNSUBSCRIBED) {\n+            current = state.get();\n+            if (current.isUnsubscribed) {\n                 return Subscriptions.empty();\n+            } else {\n+                newState = current.addChild();\n             }\n-            if (s == State.MUTATING) {\n-                continue;\n-            }\n-            if (state.compareAndSet(s, State.MUTATING)) {\n-                count.incrementAndGet();\n-                state.set(State.ACTIVE);\n-                return new InnerSubscription();\n-            }\n-        } while (true);\n+        } while (!state.compareAndSet(current, newState));\n+\n+        return new InnerSubscription();\n     }\n \n     /**\n      * Check if this subscription is already unsubscribed.\n      */\n     public boolean isUnsubscribed() {\n-        return state.get() == State.UNSUBSCRIBED;\n+        return state.get().isUnsubscribed;\n     }\n \n     @Override\n     public void unsubscribe() {\n+        State current;\n+        State newState;\n         do {\n-            State s = state.get();\n-            if (s == State.UNSUBSCRIBED) {\n+            current = state.get();\n+            if (current.isUnsubscribed) {\n                 return;\n             }\n-            if (s == State.MUTATING) {\n-                continue;\n-            }\n-            if (state.compareAndSet(s, State.MUTATING)) {\n-                if (mainDone.compareAndSet(false, true) && count.get() == 0) {\n-                    terminate();\n-                    return;\n-                }\n-                state.set(State.ACTIVE);\n-                break;\n-            }\n-        } while (true);\n-    }\n-\n-    /**\n-     * Terminate this subscription by unsubscribing from main and setting the\n-     * state to UNSUBSCRIBED.\n-     */\n-    private void terminate() {\n-        state.set(State.UNSUBSCRIBED);\n-        Subscription r = main;\n-        main = null;\n-        r.unsubscribe();\n+            newState = current.unsubscribe();\n+        } while (!state.compareAndSet(current, newState));\n+        unsubscribeActualIfApplicable(newState);\n     }\n \n-    /** Remove an inner subscription. */\n-    void innerDone() {\n-        do {\n-            State s = state.get();\n-            if (s == State.UNSUBSCRIBED) {\n-                return;\n-            }\n-            if (s == State.MUTATING) {\n-                continue;\n-            }\n-            if (state.compareAndSet(s, State.MUTATING)) {\n-                if (count.decrementAndGet() == 0 && mainDone.get()) {\n-                    terminate();\n-                    return;\n-                }\n-                state.set(State.ACTIVE);\n-                break;\n-            }\n-        } while (true);\n+    private void unsubscribeActualIfApplicable(State state) {\n+        if (state.isUnsubscribed && state.children == 0) {\n+            actual.unsubscribe();\n+        }\n     }\n \n     /** The individual sub-subscriptions. */\n@@ -142,7 +119,13 @@ class InnerSubscription implements Subscription {\n         @Override\n         public void unsubscribe() {\n             if (innerDone.compareAndSet(false, true)) {\n-                innerDone();\n+                State current;\n+                State newState;\n+                do {\n+                    current = state.get();\n+                    newState = current.removeChild();\n+                } while (!state.compareAndSet(current, newState));\n+                unsubscribeActualIfApplicable(newState);\n             }\n         }\n     };",
      "parent_sha": "dccbc6baa53c9c8714d70067cb5c97fed023e472"
    }
  },
  {
    "oid": "effc08d548518df5a54c916e1b50daadb8bf4228",
    "message": "Synchronize Observer on OperationMerge\n\nfixes https://github.com/Netflix/RxJava/issues/200\n\nThis is necessary because by definition Merge is subscribing to multiple sequences in parallel and is supposed to serialize them into a single Observable.",
    "date": "2013-03-19T23:23:50Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/effc08d548518df5a54c916e1b50daadb8bf4228",
    "details": {
      "sha": "1e6e6e7568f9994bec98f8ec84d797483c3926a0",
      "filename": "rxjava-core/src/main/java/rx/operators/OperationMerge.java",
      "status": "modified",
      "additions": 79,
      "deletions": 1,
      "changes": 80,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/effc08d548518df5a54c916e1b50daadb8bf4228/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationMerge.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/effc08d548518df5a54c916e1b50daadb8bf4228/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationMerge.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationMerge.java?ref=effc08d548518df5a54c916e1b50daadb8bf4228",
      "patch": "@@ -23,7 +23,9 @@\n import java.util.Arrays;\n import java.util.List;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n import org.junit.Before;\n import org.junit.Test;\n@@ -33,6 +35,8 @@\n import rx.Observable;\n import rx.Observer;\n import rx.Subscription;\n+import rx.util.AtomicObservableSubscription;\n+import rx.util.SynchronizedObserver;\n import rx.util.functions.Func1;\n \n public final class OperationMerge {\n@@ -115,10 +119,20 @@ private MergeObservable(Observable<Observable<T>> sequences) {\n         }\n \n         public MergeSubscription call(Observer<T> actualObserver) {\n+\n+            /**\n+             * We must synchronize a merge because we subscribe to multiple sequences in parallel that will each be emitting.\n+             * <p>\n+             * The calls from each sequence must be serialized.\n+             * <p>\n+             * Bug report: https://github.com/Netflix/RxJava/issues/200\n+             */\n+            SynchronizedObserver<T> synchronizedObserver = new SynchronizedObserver<T>(actualObserver, new AtomicObservableSubscription(ourSubscription));\n+\n             /**\n              * Subscribe to the parent Observable to get to the children Observables\n              */\n-            sequences.subscribe(new ParentObserver(actualObserver));\n+            sequences.subscribe(new ParentObserver(synchronizedObserver));\n \n             /* return our subscription to allow unsubscribing */\n             return ourSubscription;\n@@ -380,6 +394,68 @@ public void testMergeArrayWithThreading() {\n             verify(stringObserver, times(1)).onCompleted();\n         }\n \n+        @Test\n+        public void testSynchronizationOfMultipleSequences() throws Exception {\n+            final TestASynchronousObservable o1 = new TestASynchronousObservable();\n+            final TestASynchronousObservable o2 = new TestASynchronousObservable();\n+\n+            // use this latch to cause onNext to wait until we're ready to let it go\n+            final CountDownLatch endLatch = new CountDownLatch(1);\n+\n+            final AtomicInteger concurrentCounter = new AtomicInteger();\n+            final AtomicInteger totalCounter = new AtomicInteger();\n+\n+            @SuppressWarnings(\"unchecked\")\n+            Observable<String> m = Observable.create(merge(o1, o2));\n+            m.subscribe(new Observer<String>() {\n+\n+                @Override\n+                public void onCompleted() {\n+\n+                }\n+\n+                @Override\n+                public void onError(Exception e) {\n+                    throw new RuntimeException(\"failed\", e);\n+                }\n+\n+                @Override\n+                public void onNext(String v) {\n+                    totalCounter.incrementAndGet();\n+                    concurrentCounter.incrementAndGet();\n+                    try {\n+                        // wait here until we're done asserting\n+                        endLatch.await();\n+                    } catch (InterruptedException e) {\n+                        e.printStackTrace();\n+                        throw new RuntimeException(\"failed\", e);\n+                    } finally {\n+                        concurrentCounter.decrementAndGet();\n+                    }\n+                }\n+\n+            });\n+\n+            // wait for both observables to send (one should be blocked)\n+            o1.onNextBeingSent.await();\n+            o2.onNextBeingSent.await();\n+            \n+            assertEquals(1, concurrentCounter.get());\n+\n+            // release so it can finish\n+            endLatch.countDown();\n+\n+            try {\n+                o1.t.join();\n+                o2.t.join();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            assertEquals(2, totalCounter.get());\n+            assertEquals(0, concurrentCounter.get());\n+        }\n+\n         /**\n          * unit test from OperationMergeDelayError backported here to show how these use cases work with normal merge\n          */\n@@ -452,13 +528,15 @@ public void unsubscribe() {\n \n         private static class TestASynchronousObservable extends Observable<String> {\n             Thread t;\n+            final CountDownLatch onNextBeingSent = new CountDownLatch(1);\n \n             @Override\n             public Subscription subscribe(final Observer<String> observer) {\n                 t = new Thread(new Runnable() {\n \n                     @Override\n                     public void run() {\n+                        onNextBeingSent.countDown();\n                         observer.onNext(\"hello\");\n                         observer.onCompleted();\n                     }",
      "parent_sha": "f4968d6fc6bc9561025ab1c8fea6dc42d0d71ea5"
    }
  },
  {
    "oid": "56123c9e9f0152922efd31badfde22a690e5159b",
    "message": "Upcast ConcurrentHashMap to Map to avoid compatibility issue (#4654)\n\n* Upcast ConcurrentHashMap to Map to avoid compatibility issue\r\n\r\nResovles #4653\r\n\r\nSee http://stackoverflow.com/a/32955708/61158\r\n\r\n* Fix imports, remove now-unnecessary animalsniffer suppression",
    "date": "2016-10-01T09:42:59Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/56123c9e9f0152922efd31badfde22a690e5159b",
    "details": {
      "sha": "5124b34a6fe345b911170fd65336573f01916b61",
      "filename": "src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/56123c9e9f0152922efd31badfde22a690e5159b/src%2Fmain%2Fjava%2Fio%2Freactivex%2Finternal%2Fschedulers%2FSchedulerPoolFactory.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/56123c9e9f0152922efd31badfde22a690e5159b/src%2Fmain%2Fjava%2Fio%2Freactivex%2Finternal%2Fschedulers%2FSchedulerPoolFactory.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Fio%2Freactivex%2Finternal%2Fschedulers%2FSchedulerPoolFactory.java?ref=56123c9e9f0152922efd31badfde22a690e5159b",
      "patch": "@@ -20,7 +20,6 @@\n import java.util.concurrent.*;\n import java.util.concurrent.atomic.AtomicReference;\n \n-import io.reactivex.internal.util.SuppressAnimalSniffer;\n import io.reactivex.plugins.RxJavaPlugins;\n \n /**\n@@ -46,7 +45,9 @@ public enum SchedulerPoolFactory {\n     static final AtomicReference<ScheduledExecutorService> PURGE_THREAD =\n             new AtomicReference<ScheduledExecutorService>();\n \n-    static final ConcurrentHashMap<ScheduledThreadPoolExecutor, Object> POOLS =\n+    // Upcast to the Map interface here to avoid 8.x compatibility issues.\n+    // See http://stackoverflow.com/a/32955708/61158\n+    static final Map<ScheduledThreadPoolExecutor, Object> POOLS =\n             new ConcurrentHashMap<ScheduledThreadPoolExecutor, Object>();\n \n     /**\n@@ -63,10 +64,9 @@ public static void start() {\n \n                 next.scheduleAtFixedRate(new Runnable() {\n                     @Override\n-                    @SuppressAnimalSniffer\n                     public void run() {\n                         try {\n-                            for (ScheduledThreadPoolExecutor e : new ArrayList<ScheduledThreadPoolExecutor>(POOLS.keySet())) {  // CHM.keySet returns KeySetView in Java 8+; false positive here\n+                            for (ScheduledThreadPoolExecutor e : new ArrayList<ScheduledThreadPoolExecutor>(POOLS.keySet())) {\n                                 if (e.isShutdown()) {\n                                     POOLS.remove(e);\n                                 } else {",
      "parent_sha": "5ad1c046da45a69817b643eb0c6602ddab1b112c"
    }
  },
  {
    "oid": "53d5a235f63ca143c11571cd538ad927c0f8f3ad",
    "message": "2.x: fix javadoc link in observables/package-info",
    "date": "2017-12-05T15:17:55Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/53d5a235f63ca143c11571cd538ad927c0f8f3ad",
    "details": {
      "sha": "1cfff8c8896e19a73a668d0f0ceb32cc4ffeaef1",
      "filename": "src/main/java/io/reactivex/observables/package-info.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/53d5a235f63ca143c11571cd538ad927c0f8f3ad/src%2Fmain%2Fjava%2Fio%2Freactivex%2Fobservables%2Fpackage-info.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/53d5a235f63ca143c11571cd538ad927c0f8f3ad/src%2Fmain%2Fjava%2Fio%2Freactivex%2Fobservables%2Fpackage-info.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Fio%2Freactivex%2Fobservables%2Fpackage-info.java?ref=53d5a235f63ca143c11571cd538ad927c0f8f3ad",
      "patch": "@@ -16,7 +16,7 @@\n \n /**\n  * Classes supporting the Observable base reactive class:\n- * {@link io.reactivex.observable.ConnectableObservable} and\n- * {@link io.reactivex.observable.GroupedObservable}.\n+ * {@link io.reactivex.observables.ConnectableObservable} and\n+ * {@link io.reactivex.observables.GroupedObservable}.\n  */\n package io.reactivex.observables;",
      "parent_sha": "4d2e8212ac97f0c6c380802cec92764e8d8bbde1"
    }
  },
  {
    "oid": "3abd86a52446b1c82115329e43f4b5fc840bec50",
    "message": "2.x: update Obs.just(2..10) & switchOnNextDelayError marbles (#5651)",
    "date": "2017-10-09T12:19:01Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/3abd86a52446b1c82115329e43f4b5fc840bec50",
    "details": {
      "sha": "f1b28fde2e0052f4753b4a8873dbbe11d29cf80a",
      "filename": "src/main/java/io/reactivex/Observable.java",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/3abd86a52446b1c82115329e43f4b5fc840bec50/src%2Fmain%2Fjava%2Fio%2Freactivex%2FObservable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/3abd86a52446b1c82115329e43f4b5fc840bec50/src%2Fmain%2Fjava%2Fio%2Freactivex%2FObservable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Fio%2Freactivex%2FObservable.java?ref=3abd86a52446b1c82115329e43f4b5fc840bec50",
      "patch": "@@ -2265,7 +2265,7 @@ public static <T> Observable<T> just(T item) {\n     /**\n      * Converts two items into an ObservableSource that emits those items.\n      * <p>\n-     * <img width=\"640\" height=\"315\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png\" alt=\"\">\n+     * <img width=\"640\" height=\"186\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.2.png\" alt=\"\">\n      * <dl>\n      *  <dt><b>Scheduler:</b></dt>\n      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>\n@@ -2293,7 +2293,7 @@ public static <T> Observable<T> just(T item1, T item2) {\n     /**\n      * Converts three items into an ObservableSource that emits those items.\n      * <p>\n-     * <img width=\"640\" height=\"315\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png\" alt=\"\">\n+     * <img width=\"640\" height=\"186\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.3.png\" alt=\"\">\n      * <dl>\n      *  <dt><b>Scheduler:</b></dt>\n      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>\n@@ -2324,7 +2324,7 @@ public static <T> Observable<T> just(T item1, T item2, T item3) {\n     /**\n      * Converts four items into an ObservableSource that emits those items.\n      * <p>\n-     * <img width=\"640\" height=\"315\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png\" alt=\"\">\n+     * <img width=\"640\" height=\"186\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.4.png\" alt=\"\">\n      * <dl>\n      *  <dt><b>Scheduler:</b></dt>\n      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>\n@@ -2358,7 +2358,7 @@ public static <T> Observable<T> just(T item1, T item2, T item3, T item4) {\n     /**\n      * Converts five items into an ObservableSource that emits those items.\n      * <p>\n-     * <img width=\"640\" height=\"315\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png\" alt=\"\">\n+     * <img width=\"640\" height=\"186\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.5.png\" alt=\"\">\n      * <dl>\n      *  <dt><b>Scheduler:</b></dt>\n      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>\n@@ -2395,7 +2395,7 @@ public static <T> Observable<T> just(T item1, T item2, T item3, T item4, T item5\n     /**\n      * Converts six items into an ObservableSource that emits those items.\n      * <p>\n-     * <img width=\"640\" height=\"315\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png\" alt=\"\">\n+     * <img width=\"640\" height=\"186\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.6.png\" alt=\"\">\n      * <dl>\n      *  <dt><b>Scheduler:</b></dt>\n      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>\n@@ -2435,7 +2435,7 @@ public static <T> Observable<T> just(T item1, T item2, T item3, T item4, T item5\n     /**\n      * Converts seven items into an ObservableSource that emits those items.\n      * <p>\n-     * <img width=\"640\" height=\"315\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png\" alt=\"\">\n+     * <img width=\"640\" height=\"186\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.7.png\" alt=\"\">\n      * <dl>\n      *  <dt><b>Scheduler:</b></dt>\n      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>\n@@ -2478,7 +2478,7 @@ public static <T> Observable<T> just(T item1, T item2, T item3, T item4, T item5\n     /**\n      * Converts eight items into an ObservableSource that emits those items.\n      * <p>\n-     * <img width=\"640\" height=\"315\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png\" alt=\"\">\n+     * <img width=\"640\" height=\"186\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.8.png\" alt=\"\">\n      * <dl>\n      *  <dt><b>Scheduler:</b></dt>\n      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>\n@@ -2524,7 +2524,7 @@ public static <T> Observable<T> just(T item1, T item2, T item3, T item4, T item5\n     /**\n      * Converts nine items into an ObservableSource that emits those items.\n      * <p>\n-     * <img width=\"640\" height=\"315\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png\" alt=\"\">\n+     * <img width=\"640\" height=\"186\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.9.png\" alt=\"\">\n      * <dl>\n      *  <dt><b>Scheduler:</b></dt>\n      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>\n@@ -2573,7 +2573,7 @@ public static <T> Observable<T> just(T item1, T item2, T item3, T item4, T item5\n     /**\n      * Converts ten items into an ObservableSource that emits those items.\n      * <p>\n-     * <img width=\"640\" height=\"315\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png\" alt=\"\">\n+     * <img width=\"640\" height=\"186\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.10.png\" alt=\"\">\n      * <dl>\n      *  <dt><b>Scheduler:</b></dt>\n      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>\n@@ -3582,7 +3582,7 @@ public static <T> Observable<T> switchOnNext(ObservableSource<? extends Observab\n      * Converts an ObservableSource that emits ObservableSources into an ObservableSource that emits the items emitted by the\n      * most recently emitted of those ObservableSources and delays any exception until all ObservableSources terminate.\n      * <p>\n-     * <img width=\"640\" height=\"370\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchDo.png\" alt=\"\">\n+     * <img width=\"640\" height=\"370\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchOnNextDelayError.png\" alt=\"\">\n      * <p>\n      * {@code switchOnNext} subscribes to an ObservableSource that emits ObservableSources. Each time it observes one of\n      * these emitted ObservableSources, the ObservableSource returned by {@code switchOnNext} begins emitting the items\n@@ -3615,7 +3615,7 @@ public static <T> Observable<T> switchOnNextDelayError(ObservableSource<? extend\n      * Converts an ObservableSource that emits ObservableSources into an ObservableSource that emits the items emitted by the\n      * most recently emitted of those ObservableSources and delays any exception until all ObservableSources terminate.\n      * <p>\n-     * <img width=\"640\" height=\"370\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchDo.png\" alt=\"\">\n+     * <img width=\"640\" height=\"370\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchOnNextDelayError.png\" alt=\"\">\n      * <p>\n      * {@code switchOnNext} subscribes to an ObservableSource that emits ObservableSources. Each time it observes one of\n      * these emitted ObservableSources, the ObservableSource returned by {@code switchOnNext} begins emitting the items",
      "parent_sha": "e1cb606ab23590c6537af7f6c53dd72d01618dc1"
    }
  },
  {
    "oid": "57fd568007272f457b2ee60a6077771eb8c424af",
    "message": "Renamed variable",
    "date": "2013-03-01T18:53:45Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/57fd568007272f457b2ee60a6077771eb8c424af",
    "details": {
      "sha": "a3d637ec12fe2ae299119459359aeea0d5e85d8e",
      "filename": "rxjava-core/src/main/java/rx/operators/OperationNext.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/57fd568007272f457b2ee60a6077771eb8c424af/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationNext.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/57fd568007272f457b2ee60a6077771eb8c424af/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationNext.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationNext.java?ref=57fd568007272f457b2ee60a6077771eb8c424af",
      "patch": "@@ -108,11 +108,11 @@ public void onNext(Notification<T> args) {\n             if (waiting.getAndSet(false) || !args.isOnNext()) {\n                 Notification<T> toOffer = args;\n                 while (!buf.offer(toOffer)) {\n-                    Notification<T> poll = buf.poll();\n+                    Notification<T> concurrentItem = buf.poll();\n \n                     // in case if we won race condition with onComplete/onError method\n-                    if (!poll.isOnNext()) {\n-                        toOffer = poll;\n+                    if (!concurrentItem.isOnNext()) {\n+                        toOffer = concurrentItem;\n                     }\n                 }\n             }",
      "parent_sha": "fde1416758b41b6a3962d3950d88ae18acc4d31d"
    }
  },
  {
    "oid": "61e6eb97e8d7141e41b40222a8eb4b2f0508b9ba",
    "message": "1.  Update javadoc on subscribe() blocking if observables are running on the same thread.\n2.  Add test case with infinity observable.\n3.  Add test case to unsubscribe() with all observables running in different thread (non-blocking).",
    "date": "2013-04-04T00:22:23Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/61e6eb97e8d7141e41b40222a8eb4b2f0508b9ba",
    "details": {
      "sha": "93c14b2acf416765428f22171e9476255a8a36e9",
      "filename": "rxjava-core/src/main/java/rx/operators/OperationConcat.java",
      "status": "modified",
      "additions": 159,
      "deletions": 57,
      "changes": 216,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/61e6eb97e8d7141e41b40222a8eb4b2f0508b9ba/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationConcat.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/61e6eb97e8d7141e41b40222a8eb4b2f0508b9ba/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationConcat.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationConcat.java?ref=61e6eb97e8d7141e41b40222a8eb4b2f0508b9ba",
      "patch": "@@ -25,8 +25,6 @@\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n \n-import org.junit.Assert;\n-import org.junit.Before;\n import org.junit.Test;\n \n import org.mockito.InOrder;\n@@ -58,7 +56,7 @@ public final class OperationConcat {\n      * <p/>\n      *\n      * Beware that concat(o1,o2).subscribe() is a blocking call from\n-     * which it is impossible to unsubscribe.\n+     * which it is impossible to unsubscribe if observables are running on same thread.\n      *\n      * @param sequences An observable sequence of elements to project.\n      * @return An observable sequence whose elements are the result of combining the output from the list of Observables.\n@@ -182,55 +180,7 @@ public void testConcatWithList() {\n         }\n \n         @Test\n-        public void testConcatUnsubscribe() {\n-            final CountDownLatch callOnce = new CountDownLatch(1);\n-            final CountDownLatch okToContinue = new CountDownLatch(1);\n-            final TestObservable<String> w1 = new TestObservable<String>(\"one\", \"two\", \"three\");\n-            final TestObservable<String> w2 = new TestObservable<String>(callOnce, okToContinue, \"four\", \"five\", \"six\");\n-\n-            @SuppressWarnings(\"unchecked\")\n-            final Observer<String> aObserver = mock(Observer.class);\n-            @SuppressWarnings(\"unchecked\")\n-            final Observable<String> concat = Observable.create(concat(w1, w2));\n-            final AtomicObservableSubscription s1 = new AtomicObservableSubscription();\n-            Thread t = new Thread() {\n-                    @Override\n-                    public void run() {\n-                        // NB: this statement does not complete until after \"six\" has been delivered.\n-                        s1.wrap(concat.subscribe(aObserver));\n-                    }\n-                };\n-            t.start();\n-            try {\n-                //Block main thread to allow observable \"w1\" to complete and observable \"w2\" to call onNext once.\n-                callOnce.await();\n-                // NB: This statement has no effect, since s1 cannot possibly\n-                // wrap anything until \"six\" has been delivered, which cannot\n-                // happen until we okToContinue.countDown()\n-                s1.unsubscribe();\n-                //Unblock the observable to continue.\n-                okToContinue.countDown();\n-                w1.t.join();\n-                w2.t.join();\n-            } catch (Exception e) {\n-                e.printStackTrace();\n-                fail(e.getMessage());\n-            }\n-\n-            InOrder inOrder = inOrder(aObserver);\n-            inOrder.verify(aObserver, times(1)).onNext(\"one\");\n-            inOrder.verify(aObserver, times(1)).onNext(\"two\");\n-            inOrder.verify(aObserver, times(1)).onNext(\"three\");\n-            inOrder.verify(aObserver, times(1)).onNext(\"four\");\n-            // NB: you might hope that five and six are not delivered, but see above.\n-            inOrder.verify(aObserver, times(1)).onNext(\"five\");\n-            inOrder.verify(aObserver, times(1)).onNext(\"six\");\n-            inOrder.verify(aObserver, times(1)).onCompleted();\n-\n-        }\n-\n-        @Test\n-        public void testMergeObservableOfObservables() {\n+        public void testConcatObservableOfObservables() {\n             @SuppressWarnings(\"unchecked\")\n             Observer<String> observer = mock(Observer.class);\n \n@@ -260,8 +210,10 @@ public void unsubscribe() {\n                     }\n \n                 });\n-            Observable<String> concat = Observable.create(concat(observableOfObservables));\n+            Observable<String> concat = Observable.create(concat(observableOfObservables));           \n+            \n             concat.subscribe(observer);\n+  \n             verify(observer, times(7)).onNext(anyString());\n         }\n \n@@ -454,7 +406,141 @@ public void testBlockedObservableOfObservables() {\n             verify(observer, times(1)).onNext(\"4\");\n             verify(observer, times(1)).onNext(\"6\");\n         }\n+        \n+        @Test\n+\t\tpublic void testConcatConcurrentWithInfinity() {\n+            final TestObservable<String> w1 = new TestObservable<String>(\"one\", \"two\", \"three\");\n+            //This observable will send \"hello\" MAX_VALUE time.\n+            final TestObservable<String> w2 = new TestObservable<String>(\"hello\", Integer.MAX_VALUE);\n \n+            @SuppressWarnings(\"unchecked\")\n+            Observer<String> aObserver = mock(Observer.class);\n+            @SuppressWarnings(\"unchecked\")\n+ \t\t\tTestObservable<Observable<String>> observableOfObservables = new TestObservable<Observable<String>>(w1, w2);\n+            Func1<Observer<String>, Subscription> concatF = concat(observableOfObservables);\n+            \n+            Observable<String> concat = Observable.create(concatF);\n+            \n+            concat.take(50).subscribe(aObserver);\n+\n+            //Wait for the thread to start up.\n+            try {\n+\t\t\t\tThread.sleep(25);\n+\t\t\t\tw1.t.join();\n+\t\t\t\tw2.t.join();\n+\t\t\t} catch (InterruptedException e) {\n+\t\t\t\t// TODO Auto-generated catch block\n+\t\t\t\te.printStackTrace();\n+\t\t\t}\n+            \n+            InOrder inOrder = inOrder(aObserver);\n+            inOrder.verify(aObserver, times(1)).onNext(\"one\");   \n+            inOrder.verify(aObserver, times(1)).onNext(\"two\");\n+            inOrder.verify(aObserver, times(1)).onNext(\"three\");\n+            inOrder.verify(aObserver, times(47)).onNext(\"hello\");\n+            verify(aObserver, times(1)).onCompleted();\n+            verify(aObserver, never()).onError(any(Exception.class));\n+            \n+ \t\t}\n+        \n+        \n+        /**\n+         * The outer observable is running on the same thread and subscribe() in this case is a blocking call. Calling unsubscribe() is no-op because the sequence is complete. \n+         */\n+        @Test\n+        public void testConcatUnsubscribe() {\n+            final CountDownLatch callOnce = new CountDownLatch(1);\n+            final CountDownLatch okToContinue = new CountDownLatch(1);\n+            final TestObservable<String> w1 = new TestObservable<String>(\"one\", \"two\", \"three\");\n+            final TestObservable<String> w2 = new TestObservable<String>(callOnce, okToContinue, \"four\", \"five\", \"six\");\n+\n+            @SuppressWarnings(\"unchecked\")\n+            final Observer<String> aObserver = mock(Observer.class);\n+            @SuppressWarnings(\"unchecked\")\n+            final Observable<String> concat = Observable.create(concat(w1, w2));\n+            final AtomicObservableSubscription s1 = new AtomicObservableSubscription();\n+            Thread t = new Thread() {\n+                    @Override\n+                    public void run() {\n+                        // NB: this statement does not complete until after \"six\" has been delivered.\n+                        s1.wrap(concat.subscribe(aObserver));\n+                    }\n+                };\n+            t.start();\n+            try {\n+                //Block main thread to allow observable \"w1\" to complete and observable \"w2\" to call onNext once.\n+                callOnce.await();\n+                // NB: This statement has no effect, since s1 cannot possibly\n+                // wrap anything until \"six\" has been delivered, which cannot\n+                // happen until we okToContinue.countDown()\n+                s1.unsubscribe();\n+                //Unblock the observable to continue.\n+                okToContinue.countDown();\n+                w1.t.join();\n+                w2.t.join();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+                fail(e.getMessage());\n+            }\n+\n+            InOrder inOrder = inOrder(aObserver);\n+            inOrder.verify(aObserver, times(1)).onNext(\"one\");\n+            inOrder.verify(aObserver, times(1)).onNext(\"two\");\n+            inOrder.verify(aObserver, times(1)).onNext(\"three\");\n+            inOrder.verify(aObserver, times(1)).onNext(\"four\");\n+            // NB: you might hope that five and six are not delivered, but see above.\n+            inOrder.verify(aObserver, times(1)).onNext(\"five\");\n+            inOrder.verify(aObserver, times(1)).onNext(\"six\");\n+            inOrder.verify(aObserver, times(1)).onCompleted();\n+\n+        }\n+       \n+        /**\n+         * All observables will be running in different threads so subscribe() is unblocked.  CountDownLatch is only used in order to call unsubscribe() in a predictable manner.  \n+         */\n+        @Test\n+\t\tpublic void testConcatUnsubscribeConcurrent() {\n+            final CountDownLatch callOnce = new CountDownLatch(1);\n+            final CountDownLatch okToContinue = new CountDownLatch(1);\n+            final TestObservable<String> w1 = new TestObservable<String>(\"one\", \"two\", \"three\");\n+            final TestObservable<String> w2 = new TestObservable<String>(callOnce, okToContinue, \"four\", \"five\", \"six\");\n+\n+            @SuppressWarnings(\"unchecked\")\n+            Observer<String> aObserver = mock(Observer.class);\n+            @SuppressWarnings(\"unchecked\")\n+ \t\t\tTestObservable<Observable<String>> observableOfObservables = new TestObservable<Observable<String>>(w1, w2);\n+            Func1<Observer<String>, Subscription> concatF = concat(observableOfObservables);\n+            \n+            Observable<String> concat = Observable.create(concatF);\n+           \n+            Subscription s1 = concat.subscribe(aObserver);\n+            \n+            try {\n+                //Block main thread to allow observable \"w1\" to complete and observable \"w2\" to call onNext exactly once.\n+            \tcallOnce.await();\n+            \t//\"four\" from w2 has been processed by onNext()\n+                s1.unsubscribe();\n+                //\"five\" and \"six\" will NOT be processed by onNext()\n+                //Unblock the observable to continue.\n+                okToContinue.countDown();\n+                w1.t.join();   \n+                w2.t.join();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+                fail(e.getMessage());\n+            }\n+\n+            InOrder inOrder = inOrder(aObserver);\n+            inOrder.verify(aObserver, times(1)).onNext(\"one\");\n+            inOrder.verify(aObserver, times(1)).onNext(\"two\");\n+            inOrder.verify(aObserver, times(1)).onNext(\"three\");\n+            inOrder.verify(aObserver, times(1)).onNext(\"four\");\n+            inOrder.verify(aObserver, never()).onNext(\"five\");\n+            inOrder.verify(aObserver, never()).onNext(\"six\");\n+            verify(aObserver, never()).onCompleted();\n+            verify(aObserver, never()).onError(any(Exception.class));\n+        }\n+        \n         private static class TestObservable<T> extends Observable<T> {\n \n             private final Subscription s = new Subscription() {\n@@ -471,32 +557,48 @@ public void unsubscribe() {\n             private boolean subscribed = true;\n             private final CountDownLatch once;\n             private final CountDownLatch okToContinue;\n-\n+            private final T seed;\n+            private final int size;\n+            \n             public TestObservable(T... values) {\n                 this(null, null, values);\n             }\n \n             public TestObservable(CountDownLatch once, CountDownLatch okToContinue, T... values) {\n                 this.values = Arrays.asList(values);\n+                this.size = this.values.size();\n                 this.once = once;\n                 this.okToContinue = okToContinue;\n+                this.seed = null;\n             }\n \n+            public TestObservable(T seed, int size) {\n+            \tvalues = null;\n+            \tonce = null;\n+            \tokToContinue = null;\n+            \tthis.seed = seed;\n+            \tthis.size = size;\n+            }\n+            \n+            \n             @Override\n             public Subscription subscribe(final Observer<T> observer) {\n                 t = new Thread(new Runnable() {\n \n                         @Override\n                         public void run() {\n                             try {\n-                                while (count < values.size() && subscribed) {\n-                                    observer.onNext(values.get(count));\n+                                while (count < size && subscribed) {\n+                                \tif (null != values)\n+                                \t\tobserver.onNext(values.get(count));\n+                                \telse\n+                                \t\tobserver.onNext(seed);\n                                     count++;\n                                     //Unblock the main thread to call unsubscribe.\n                                     if (null != once)\n                                         once.countDown();\n                                     //Block until the main thread has called unsubscribe.\n-                                    if (null != once)\n+                                    if (null != okToContinue)\n                                         okToContinue.await();\n                                 }\n                                 if (subscribed)",
      "parent_sha": "f2e4e8188c3148a72c512487b3c837b12d96203b"
    }
  },
  {
    "oid": "d21720938426e6612ec026c2bd2d80395fbd3f07",
    "message": "Take Unsubscribes Before OnNext\n\nTo prevent issues such as https://github.com/ReactiveX/RxJava/issues/1791",
    "date": "2014-10-23T21:20:12Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/d21720938426e6612ec026c2bd2d80395fbd3f07",
    "details": {
      "sha": "b2c62e3920d1adacab4e3a7ccc9fb0bdedb3f6af",
      "filename": "src/main/java/rx/internal/operators/OperatorTake.java",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/d21720938426e6612ec026c2bd2d80395fbd3f07/src%2Fmain%2Fjava%2Frx%2Finternal%2Foperators%2FOperatorTake.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/d21720938426e6612ec026c2bd2d80395fbd3f07/src%2Fmain%2Fjava%2Frx%2Finternal%2Foperators%2FOperatorTake.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Frx%2Finternal%2Foperators%2FOperatorTake.java?ref=d21720938426e6612ec026c2bd2d80395fbd3f07",
      "patch": "@@ -61,12 +61,16 @@ public void onError(Throwable e) {\n             @Override\n             public void onNext(T i) {\n                 if (!isUnsubscribed()) {\n-                    child.onNext(i);\n                     if (++count >= limit) {\n                         completed = true;\n-                        child.onCompleted();\n+                        // unsubscribe before emitting onNext so shutdown happens before possible effects\n+                        // of onNext such as product.request(n) calls be sent upstream. \n                         unsubscribe();\n                     }\n+                    child.onNext(i);\n+                    if (completed) {\n+                        child.onCompleted();\n+                    }\n                 }\n             }\n ",
      "parent_sha": "bf1a4f3c449afb1aac438563f523960fefedcc20"
    }
  },
  {
    "oid": "18a47ea64f2510c4685427a1a64a991028048447",
    "message": "window() behavior changed, so did marble diagram & thus its size",
    "date": "2015-07-21T19:43:36Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/18a47ea64f2510c4685427a1a64a991028048447",
    "details": {
      "sha": "dd83aaf5e03d12a4919757a69bc8bb3e4b7d2079",
      "filename": "src/main/java/rx/Observable.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/18a47ea64f2510c4685427a1a64a991028048447/src%2Fmain%2Fjava%2Frx%2FObservable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/18a47ea64f2510c4685427a1a64a991028048447/src%2Fmain%2Fjava%2Frx%2FObservable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Frx%2FObservable.java?ref=18a47ea64f2510c4685427a1a64a991028048447",
      "patch": "@@ -9152,7 +9152,7 @@ public final <U, R> Observable<R> withLatestFrom(Observable<? extends U> other,\n      * Observable emits connected, non-overlapping windows. It emits the current window and opens a new one\n      * whenever the Observable produced by the specified {@code closingSelector} emits an item.\n      * <p>\n-     * <img width=\"640\" height=\"485\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window1.png\" alt=\"\">\n+     * <img width=\"640\" height=\"460\" src=\"https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window1.png\" alt=\"\">\n      * <dl>\n      *  <dt><b>Backpressure Support:</b></dt>\n      *  <dd>This operator does not support backpressure as it uses the {@code closingSelector} to control data",
      "parent_sha": "00fc1afe254547596b1f9d7893cd1199874b27c2"
    }
  },
  {
    "oid": "1fabd4252e703c2195ffd1c0bcc00cc356bdf555",
    "message": "An attempt at implementing the correct combineLatest semantics. The\ntests do pass again now (they had to be adapted too).",
    "date": "2013-03-25T19:40:58Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/1fabd4252e703c2195ffd1c0bcc00cc356bdf555",
    "details": {
      "sha": "3cf2a410c42853ecb754616bec3f7db8614f596f",
      "filename": "rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java",
      "status": "modified",
      "additions": 44,
      "deletions": 59,
      "changes": 103,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/1fabd4252e703c2195ffd1c0bcc00cc356bdf555/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationCombineLatest.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/1fabd4252e703c2195ffd1c0bcc00cc356bdf555/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationCombineLatest.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationCombineLatest.java?ref=1fabd4252e703c2195ffd1c0bcc00cc356bdf555",
      "patch": "@@ -21,9 +21,10 @@\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.LinkedHashMap;\n import java.util.LinkedList;\n+import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.junit.Test;\n@@ -110,26 +111,22 @@ private static class Aggregator<R> implements Func1<Observer<R>, Subscription> {\n         private Observer<R> Observer;\n         private AtomicBoolean running = new AtomicBoolean(true);\n \n-        /**\n-         * Use LinkedHashMap to retain the order we receive the CombineLatestObserver objects in.\n-         * <p>\n-         * Note that access to this LinkedList inside MUST BE SYNCHRONIZED\n-         */\n-        private Map<CombineObserver<R, ?>, LinkedList<Object>> receivedValuesPerObserver = new LinkedHashMap<CombineObserver<R, ?>, LinkedList<Object>>();\n-\n         /**\n          * store when a Observer completes\n          * <p>\n          * Note that access to this set MUST BE SYNCHRONIZED\n          * */\n-        private HashSet<CombineObserver<R, ?>> completed = new HashSet<CombineObserver<R, ?>>();\n+        private Set<CombineObserver<R, ?>> completed = new HashSet<CombineObserver<R, ?>>();\n \n         /**\n          * The last value from a Observer\n          * <p>\n          * Note that access to this set MUST BE SYNCHRONIZED\n          * */\n-        private HashMap<CombineObserver<R, ?>, Object> lastValue = new HashMap<CombineObserver<R, ?>, Object>();\n+        private Map<CombineObserver<R, ?>, Object> lastValue = new HashMap<CombineObserver<R, ?>, Object>();\n+        \n+        private Set<CombineObserver<R, ?>> hasLastValue = new HashSet<CombineObserver<R, ?>>();\n+        private List<CombineObserver<R, ?>> observers = new LinkedList<CombineObserver<R, ?>>();\n \n         public Aggregator(FuncN<R> combineLatestFunction) {\n             this.combineLatestFunction = combineLatestFunction;\n@@ -140,21 +137,20 @@ public Aggregator(FuncN<R> combineLatestFunction) {\n          * \n          * @param w\n          */\n-        synchronized void addObserver(CombineObserver<R, ?> w) {\n-            // initialize this CombineLatestObserver\n-            receivedValuesPerObserver.put(w, new LinkedList<Object>());\n+        synchronized <T> void addObserver(CombineObserver<R, T> w) {\n+          observers.add(w);\n         }\n \n         /**\n          * Receive notification of a Observer completing its iterations.\n          * \n          * @param w\n          */\n-        synchronized void complete(CombineObserver<R, ?> w) {\n-            // store that this ZipObserver is completed\n+        synchronized <T> void complete(CombineObserver<R, T> w) {\n+            // store that this CombineLatestObserver is completed\n             completed.add(w);\n             // if all CombineObservers are completed, we mark the whole thing as completed\n-            if (completed.size() == receivedValuesPerObserver.size()) {\n+            if (completed.size() == observers.size()) {\n                 if (running.get()) {\n                     // mark ourselves as done\n                     Observer.onCompleted();\n@@ -169,7 +165,7 @@ synchronized void complete(CombineObserver<R, ?> w) {\n          * \n          * @param w\n          */\n-        synchronized void error(CombineObserver<R, ?> w, Exception e) {\n+        synchronized <T> void error(CombineObserver<R, T> w, Exception e) {\n             Observer.onError(e);\n             /* tell ourselves to stop processing onNext events, event if the Observers don't obey the unsubscribe we're about to send */\n             running.set(false);\n@@ -196,39 +192,25 @@ <T> void next(CombineObserver<R, T> w, T arg) {\n             }\n \n             // define here so the variable is out of the synchronized scope\n-            Object[] argsToCombineLatest = new Object[receivedValuesPerObserver.size()];\n+            Object[] argsToCombineLatest = new Object[observers.size()];\n \n             // we synchronize everything that touches receivedValues and the internal LinkedList objects\n             synchronized (this) {\n-                // add this value to the queue of the CombineLatestObserver for values received\n-                receivedValuesPerObserver.get(w).add(arg);\n                 // remember this as the last value for this Observer\n                 lastValue.put(w, arg);\n+                hasLastValue.add(w);\n \n                 // if all CombineLatestObservers in 'receivedValues' map have a value, invoke the combineLatestFunction\n-                for (CombineObserver<R, ?> rw : receivedValuesPerObserver.keySet()) {\n-                    if (receivedValuesPerObserver.get(rw).peek() == null && !completed.contains(rw)) {\n-                        // we have a null (and the Observer isn't completed) meaning the queues aren't all populated so won't do anything\n+                for (CombineObserver<R, ?> rw : observers) {\n+                    if (!hasLastValue.contains(rw)) {\n+                        // we don't have a value yet for each observer to combine, so we don't have a combined value yet either\n                         return;\n                     }\n                 }\n-                // if we get to here this means all the queues have data (or some are completed)\n+                // if we get to here this means all the queues have data\n                 int i = 0;\n-                boolean foundData = false;\n-                for (CombineObserver<R, ?> _w : receivedValuesPerObserver.keySet()) {\n-                    LinkedList<Object> q = receivedValuesPerObserver.get(_w);\n-                    if (q.peek() == null) {\n-                        // this is a completed Observer\n-                        // we rely on the check above looking at completed.contains to mean that NULL here represents a completed Observer\n-                        argsToCombineLatest[i++] = lastValue.get(_w);\n-                    } else {\n-                        foundData = true;\n-                        argsToCombineLatest[i++] = q.remove();\n-                    }\n-                }\n-                if (completed.size() == receivedValuesPerObserver.size() && !foundData) {\n-                    // all are completed and queues have run out of data, so return and don't send empty data\n-                    return;\n+                for (CombineObserver<R, ?> _w : observers) {\n+                    argsToCombineLatest[i++] = lastValue.get(_w);\n                 }\n             }\n             // if we did not return above from the synchronized block we can now invoke the combineLatestFunction with all of the args\n@@ -245,7 +227,7 @@ public Subscription call(Observer<R> Observer) {\n             this.Observer = Observer;\n \n             /* start the Observers */\n-            for (CombineObserver<R, ?> rw : receivedValuesPerObserver.keySet()) {\n+            for (CombineObserver<R, ?> rw : observers) {\n                 rw.startWatching();\n             }\n \n@@ -263,7 +245,7 @@ private void stop() {\n             /* tell ourselves to stop processing onNext events */\n             running.set(false);\n             /* propogate to all Observers to unsubscribe */\n-            for (CombineObserver<R, ?> rw : receivedValuesPerObserver.keySet()) {\n+            for (CombineObserver<R, ?> rw : observers) {\n                 if (rw.subscription != null) {\n                     rw.subscription.unsubscribe();\n                 }\n@@ -290,25 +272,26 @@ public void testCombineLatestDifferentLengthObservableSequences1() {\n             /* simulate sending data */\n             // once for w1\n             w1.Observer.onNext(\"1a\");\n+            w2.Observer.onNext(\"2a\");\n+            w3.Observer.onNext(\"3a\");\n             w1.Observer.onCompleted();\n             // twice for w2\n-            w2.Observer.onNext(\"2a\");\n             w2.Observer.onNext(\"2b\");\n             w2.Observer.onCompleted();\n             // 4 times for w3\n-            w3.Observer.onNext(\"3a\");\n             w3.Observer.onNext(\"3b\");\n             w3.Observer.onNext(\"3c\");\n             w3.Observer.onNext(\"3d\");\n             w3.Observer.onCompleted();\n \n             /* we should have been called 4 times on the Observer */\n             InOrder inOrder = inOrder(w);\n+            inOrder.verify(w).onNext(\"1a2a3a\");\n             inOrder.verify(w).onNext(\"1a2b3a\");\n             inOrder.verify(w).onNext(\"1a2b3b\");\n             inOrder.verify(w).onNext(\"1a2b3c\");\n             inOrder.verify(w).onNext(\"1a2b3d\");\n-\n+            inOrder.verify(w, never()).onNext(anyString());\n             inOrder.verify(w, times(1)).onCompleted();\n         }\n \n@@ -341,17 +324,16 @@ public void testCombineLatestDifferentLengthObservableSequences2() {\n \n             /* we should have been called 1 time only on the Observer since we only combine the \"latest\" we don't go back and loop through others once completed */\n             InOrder inOrder = inOrder(w);\n-            inOrder.verify(w, times(1)).onNext(\"1a2a3a\");\n+            inOrder.verify(w, times(1)).onNext(\"1d2b3a\");\n             inOrder.verify(w, never()).onNext(anyString());\n \n             inOrder.verify(w, times(1)).onCompleted();\n \n         }\n \n-        @SuppressWarnings(\"unchecked\")\n-        /* mock calls don't do generics */\n         @Test\n         public void testCombineLatestWithInterleavingSequences() {\n+            @SuppressWarnings(\"unchecked\")\n             Observer<String> w = mock(Observer.class);\n \n             TestObservable w1 = new TestObservable();\n@@ -383,7 +365,8 @@ public void testCombineLatestWithInterleavingSequences() {\n             inOrder.verify(w).onNext(\"1b2c3a\");\n             inOrder.verify(w).onNext(\"1b2d3a\");\n             inOrder.verify(w).onNext(\"1b2d3b\");\n-\n+            \n+            inOrder.verify(w, never()).onNext(anyString());\n             inOrder.verify(w, times(1)).onCompleted();\n         }\n         \n@@ -568,14 +551,14 @@ public void testAggregatorsWithDifferentSizesAndTiming() {\n \n             verify(aObserver, never()).onError(any(Exception.class));\n             verify(aObserver, never()).onCompleted();\n-            verify(aObserver, times(1)).onNext(\"oneA\");\n+            verify(aObserver, times(1)).onNext(\"threeA\");\n \n             a.next(r1, \"four\");\n             a.complete(r1);\n             a.next(r2, \"B\");\n-            verify(aObserver, times(1)).onNext(\"twoB\");\n+            verify(aObserver, times(1)).onNext(\"fourB\");\n             a.next(r2, \"C\");\n-            verify(aObserver, times(1)).onNext(\"threeC\");\n+            verify(aObserver, times(1)).onNext(\"fourC\");\n             a.next(r2, \"D\");\n             verify(aObserver, times(1)).onNext(\"fourD\");\n             a.next(r2, \"E\");\n@@ -688,16 +671,18 @@ public void testAggregatorEarlyCompletion() {\n             a.complete(r1);\n             a.next(r2, \"A\");\n \n-            verify(aObserver, never()).onError(any(Exception.class));\n-            verify(aObserver, never()).onCompleted();\n-            verify(aObserver, times(1)).onNext(\"oneA\");\n+            InOrder inOrder = inOrder(aObserver);\n+            \n+            inOrder.verify(aObserver, never()).onError(any(Exception.class));\n+            inOrder.verify(aObserver, never()).onCompleted();\n+            inOrder.verify(aObserver, times(1)).onNext(\"twoA\");\n \n             a.complete(r2);\n \n-            verify(aObserver, never()).onError(any(Exception.class));\n-            verify(aObserver, times(1)).onCompleted();\n+            inOrder.verify(aObserver, never()).onError(any(Exception.class));\n+            inOrder.verify(aObserver, times(1)).onCompleted();\n             // we shouldn't get this since completed is called before any other onNext calls could trigger this\n-            verify(aObserver, never()).onNext(\"twoA\");\n+            inOrder.verify(aObserver, never()).onNext(anyString());\n         }\n \n         @SuppressWarnings(\"unchecked\")\n@@ -714,7 +699,7 @@ public void testCombineLatest2Types() {\n \n             verify(aObserver, never()).onError(any(Exception.class));\n             verify(aObserver, times(1)).onCompleted();\n-            verify(aObserver, times(1)).onNext(\"one2\");\n+            verify(aObserver, times(1)).onNext(\"two2\");\n             verify(aObserver, times(1)).onNext(\"two3\");\n             verify(aObserver, times(1)).onNext(\"two4\");\n         }\n@@ -733,7 +718,7 @@ public void testCombineLatest3TypesA() {\n \n             verify(aObserver, never()).onError(any(Exception.class));\n             verify(aObserver, times(1)).onCompleted();\n-            verify(aObserver, times(1)).onNext(\"one2[4, 5, 6]\");\n+            verify(aObserver, times(1)).onNext(\"two2[4, 5, 6]\");\n         }\n \n         @SuppressWarnings(\"unchecked\")",
      "parent_sha": "bc0a089686b721149a962e6c409b8719a44872a4"
    }
  },
  {
    "oid": "12ca280008885611dc342b888c29cbbd11708c82",
    "message": "Replace all occurrences 'TestSubscriber'  by 'TestObserver' in TestObserver class (#4478)",
    "date": "2016-09-05T17:54:28Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/12ca280008885611dc342b888c29cbbd11708c82",
    "details": {
      "sha": "c465d3ce7ed2961495b4fd88666bb8412ad9d810",
      "filename": "src/main/java/io/reactivex/observers/TestObserver.java",
      "status": "modified",
      "additions": 29,
      "deletions": 29,
      "changes": 58,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/12ca280008885611dc342b888c29cbbd11708c82/src%2Fmain%2Fjava%2Fio%2Freactivex%2Fobservers%2FTestObserver.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/12ca280008885611dc342b888c29cbbd11708c82/src%2Fmain%2Fjava%2Fio%2Freactivex%2Fobservers%2FTestObserver.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Fio%2Freactivex%2Fobservers%2FTestObserver.java?ref=12ca280008885611dc342b888c29cbbd11708c82",
      "patch": "@@ -32,7 +32,7 @@\n  * <p>You can override the onSubscribe, onNext, onError, onComplete and\n  * cancel methods but not the others (this is by design).\n  * \n- * <p>The TestSubscriber implements Disposable for convenience where dispose calls cancel.\n+ * <p>The TestObserver implements Disposable for convenience where dispose calls cancel.\n  * \n  * @param <T> the value type\n  */\n@@ -218,8 +218,8 @@ public void onComplete() {\n     }\n     \n     /**\n-     * Returns true if this TestSubscriber has been cancelled.\n-     * @return true if this TestSubscriber has been cancelled\n+     * Returns true if this TestObserver has been cancelled.\n+     * @return true if this TestObserver has been cancelled\n      */\n     public final boolean isCancelled() {\n         return isDisposed();\n@@ -247,7 +247,7 @@ public final boolean isDisposed() {\n     // state retrieval methods\n     \n     /**\n-     * Returns the last thread which called the onXXX methods of this TestSubscriber.\n+     * Returns the last thread which called the onXXX methods of this TestObserver.\n      * @return the last thread which called the onXXX methods\n      */\n     public final Thread lastThread() {\n@@ -279,8 +279,8 @@ public final long completions() {\n     }\n \n     /**\n-     * Returns true if TestSubscriber received any onError or onComplete events.\n-     * @return true if TestSubscriber received any onError or onComplete events\n+     * Returns true if TestObserver received any onError or onComplete events.\n+     * @return true if TestObserver received any onError or onComplete events\n      */\n     public final boolean isTerminated() {\n         return done.getCount() == 0;\n@@ -303,15 +303,15 @@ public final int errorCount() {\n     }\n \n     /**\n-     * Returns true if this TestSubscriber received a subscription.\n-     * @return true if this TestSubscriber received a subscription\n+     * Returns true if this TestObserver received a subscription.\n+     * @return true if this TestObserver received a subscription\n      */\n     public final boolean hasSubscription() {\n         return subscription.get() != null;\n     }\n     \n     /**\n-     * Awaits until this TestSubscriber receives an onError or onComplete events.\n+     * Awaits until this TestObserver receives an onError or onComplete events.\n      * @return this\n      * @throws InterruptedException if the current thread is interrupted while waiting\n      * @see #awaitTerminalEvent()\n@@ -326,11 +326,11 @@ public final TestObserver<T> await() throws InterruptedException {\n     }\n     \n     /**\n-     * Awaits the specified amount of time or until this TestSubscriber \n+     * Awaits the specified amount of time or until this TestObserver \n      * receives an onError or onComplete events, whichever happens first.\n      * @param time the waiting time\n      * @param unit the time unit of the waiting time\n-     * @return true if the TestSubscriber terminated, false if timeout happened\n+     * @return true if the TestObserver terminated, false if timeout happened\n      * @throws InterruptedException if the current thread is interrupted while waiting\n      * @see #awaitTerminalEvent(long, TimeUnit)\n      */\n@@ -372,7 +372,7 @@ private AssertionError fail(String message) {\n     }\n     \n     /**\n-     * Assert that this TestSubscriber received exactly one onComplete event.\n+     * Assert that this TestObserver received exactly one onComplete event.\n      * @return this;\n      */\n     public final TestObserver<T> assertComplete() {\n@@ -387,7 +387,7 @@ public final TestObserver<T> assertComplete() {\n     }\n     \n     /**\n-     * Assert that this TestSubscriber has not received any onComplete event.\n+     * Assert that this TestObserver has not received any onComplete event.\n      * @return this;\n      */\n     public final TestObserver<T> assertNotComplete() {\n@@ -402,7 +402,7 @@ public final TestObserver<T> assertNotComplete() {\n     }\n     \n     /**\n-     * Assert that this TestSubscriber has not received any onError event.\n+     * Assert that this TestObserver has not received any onError event.\n      * @return this;\n      */\n     public final TestObserver<T> assertNoErrors() {\n@@ -414,7 +414,7 @@ public final TestObserver<T> assertNoErrors() {\n     }\n     \n     /**\n-     * Assert that this TestSubscriber received exactly the specified onError event value.\n+     * Assert that this TestObserver received exactly the specified onError event value.\n      * \n      * <p>The comparison is performed via Objects.equals(); since most exceptions don't\n      * implement equals(), this assertion may fail. Use the {@link #assertError(Class)}\n@@ -439,7 +439,7 @@ public final TestObserver<T> assertError(Throwable error) {\n     }\n     \n     /**\n-     * Asserts that this TestSubscriber received exactly one onError event which is an\n+     * Asserts that this TestObserver received exactly one onError event which is an\n      * instance of the specified errorClass class.\n      * @param errorClass the error class to expect\n      * @return this;\n@@ -470,7 +470,7 @@ public final TestObserver<T> assertError(Class<? extends Throwable> errorClass)\n     }\n     \n     /**\n-     * Assert that this TestSubscriber received exactly one onNext value which is equal to\n+     * Assert that this TestObserver received exactly one onNext value which is equal to\n      * the given value with respect to Objects.equals.\n      * @param value the value to expect\n      * @return this;\n@@ -496,7 +496,7 @@ static String valueAndClass(Object o) {\n     }\n     \n     /**\n-     * Assert that this TestSubscriber received the specified number onNext events.\n+     * Assert that this TestObserver received the specified number onNext events.\n      * @param count the expected number of onNext events\n      * @return this;\n      */\n@@ -509,15 +509,15 @@ public final TestObserver<T> assertValueCount(int count) {\n     }\n     \n     /**\n-     * Assert that this TestSubscriber has not received any onNext events.\n+     * Assert that this TestObserver has not received any onNext events.\n      * @return this;\n      */\n     public final TestObserver<T> assertNoValues() {\n         return assertValueCount(0);\n     }\n     \n     /**\n-     * Assert that the TestSubscriber received only the specified values in the specified order.\n+     * Assert that the TestObserver received only the specified values in the specified order.\n      * @param values the values expected\n      * @return this;\n      * @see #assertValueSet(Collection)\n@@ -539,7 +539,7 @@ public final TestObserver<T> assertValues(T... values) {\n     }\n     \n     /**\n-     * Assert that the TestSubscriber received only the specified values in any order.\n+     * Assert that the TestObserver received only the specified values in any order.\n      * <p>This helps asserting when the order of the values is not guaranteed, i.e., when merging\n      * asynchronous streams.\n      * \n@@ -560,7 +560,7 @@ public final TestObserver<T> assertValueSet(Collection<? extends T> expected) {\n     }\n     \n     /**\n-     * Assert that the TestSubscriber received only the specified sequence of values in the same order.\n+     * Assert that the TestObserver received only the specified sequence of values in the same order.\n      * @param sequence the sequence of expected values in order\n      * @return this;\n      */\n@@ -599,7 +599,7 @@ public final TestObserver<T> assertValueSequence(Iterable<? extends T> sequence)\n     }\n     \n     /**\n-     * Assert that the TestSubscriber terminated (i.e., the terminal latch reached zero).\n+     * Assert that the TestObserver terminated (i.e., the terminal latch reached zero).\n      * @return this;\n      */\n     public final TestObserver<T> assertTerminated() {\n@@ -622,7 +622,7 @@ public final TestObserver<T> assertTerminated() {\n     }\n     \n     /**\n-     * Assert that the TestSubscriber has not terminated (i.e., the terminal latch is still non-zero).\n+     * Assert that the TestObserver has not terminated (i.e., the terminal latch is still non-zero).\n      * @return this;\n      */\n     public final TestObserver<T> assertNotTerminated() {\n@@ -658,9 +658,9 @@ public final TestObserver<T> assertNotSubscribed() {\n     }\n     \n     /**\n-     * Waits until the any terminal event has been received by this TestSubscriber\n+     * Waits until the any terminal event has been received by this TestObserver\n      * or returns false if the wait has been interrupted.\n-     * @return true if the TestSubscriber terminated, false if the wait has been interrupted\n+     * @return true if the TestObserver terminated, false if the wait has been interrupted\n      */\n     public final boolean awaitTerminalEvent() {\n         try {\n@@ -673,11 +673,11 @@ public final boolean awaitTerminalEvent() {\n     }\n     \n     /**\n-     * Awaits the specified amount of time or until this TestSubscriber \n+     * Awaits the specified amount of time or until this TestObserver \n      * receives an onError or onComplete events, whichever happens first.\n      * @param duration the waiting time\n      * @param unit the time unit of the waiting time\n-     * @return true if the TestSubscriber terminated, false if timeout or interrupt happened\n+     * @return true if the TestObserver terminated, false if timeout or interrupt happened\n      */\n     public final boolean awaitTerminalEvent(long duration, TimeUnit unit) {\n         try {\n@@ -864,7 +864,7 @@ public final TestObserver<T> assertFailureAndMessage(Class<? extends Throwable>\n \n     /**\n      * Awaits until the internal latch is counted down.\n-     * <p>If the wait times out or gets interrupted, the TestSubscriber is cancelled.\n+     * <p>If the wait times out or gets interrupted, the TestObserver is cancelled.\n      * @param time the waiting time\n      * @param unit the time unit of the waiting time\n      * @return this",
      "parent_sha": "ebaeee5e169063462c1bc55c9b18fe9fa942af57"
    }
  },
  {
    "oid": "d06c7d6e978fda3c2eb206899c616bc94e01d924",
    "message": "Formatting",
    "date": "2014-06-24T03:00:05Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/d06c7d6e978fda3c2eb206899c616bc94e01d924",
    "details": {
      "sha": "ccd977152cd5c667c18a6810d2abd8ae14244600",
      "filename": "rxjava-core/src/test/java/rx/internal/operators/OperatorMergeMapTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/d06c7d6e978fda3c2eb206899c616bc94e01d924/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Finternal%2Foperators%2FOperatorMergeMapTest.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/d06c7d6e978fda3c2eb206899c616bc94e01d924/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Finternal%2Foperators%2FOperatorMergeMapTest.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Finternal%2Foperators%2FOperatorMergeMapTest.java?ref=d06c7d6e978fda3c2eb206899c616bc94e01d924",
      "patch": "@@ -29,6 +29,7 @@\n import rx.Observable;\n import rx.Observer;\n import rx.exceptions.TestException;\n+import rx.functions.Action1;\n import rx.functions.Func0;\n import rx.functions.Func1;\n import rx.functions.Func2;\n@@ -204,9 +205,10 @@ public void testFlatMapTransformsException() {\n         Observable<Integer> onError = Observable.from(Arrays.asList(5));\n \n         Observable<Integer> source = Observable.concat(\n-                Observable.from(Arrays.asList(10, 20, 30))\n-                , Observable.<Integer> error(new RuntimeException(\"Forced failure!\"))\n+                Observable.from(Arrays.asList(10, 20, 30)),\n+                Observable.<Integer> error(new RuntimeException(\"Forced failure!\"))\n                 );\n+        \n \n         @SuppressWarnings(\"unchecked\")\n         Observer<Object> o = mock(Observer.class);",
      "parent_sha": "59b59b27f72956812c1f10b099b9f69d0a9147a2"
    }
  },
  {
    "oid": "3346ff9a868b74ae767905e5e4185e81d58f4a98",
    "message": "2.x: Expand the documentation of the Flowable.lift() operator (#5863)",
    "date": "2018-02-26T11:45:35Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/3346ff9a868b74ae767905e5e4185e81d58f4a98",
    "details": {
      "sha": "c4486b81edf1210ceee00bb57f7cde2721c98a78",
      "filename": "src/main/java/io/reactivex/Flowable.java",
      "status": "modified",
      "additions": 133,
      "deletions": 17,
      "changes": 150,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/3346ff9a868b74ae767905e5e4185e81d58f4a98/src%2Fmain%2Fjava%2Fio%2Freactivex%2FFlowable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/3346ff9a868b74ae767905e5e4185e81d58f4a98/src%2Fmain%2Fjava%2Fio%2Freactivex%2FFlowable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Fio%2Freactivex%2FFlowable.java?ref=3346ff9a868b74ae767905e5e4185e81d58f4a98",
      "patch": "@@ -10063,34 +10063,150 @@ public final Single<T> lastOrError() {\n     }\n \n     /**\n-     * <strong>This method requires advanced knowledge about building operators; please consider\n+     * <strong>This method requires advanced knowledge about building operators, please consider\n      * other standard composition methods first;</strong>\n-     * Lifts a function to the current Publisher and returns a new Publisher that when subscribed to will pass\n-     * the values of the current Publisher through the Operator function.\n+     * Returns a {@code Flowable} which, when subscribed to, invokes the {@link FlowableOperator#apply(Subscriber) apply(Subscriber)} method\n+     * of the provided {@link FlowableOperator} for each individual downstream {@link Subscriber} and allows the\n+     * insertion of a custom operator by accessing the downstream's {@link Subscriber} during this subscription phase\n+     * and providing a new {@code Subscriber}, containing the custom operator's intended business logic, that will be \n+     * used in the subscription process going further upstream.\n+     * <p>\n+     * Generally, such a new {@code Subscriber} will wrap the downstream's {@code Subscriber} and forwards the\n+     * {@code onNext}, {@code onError} and {@code onComplete} events from the upstream directly or according to the\n+     * emission pattern the custom operator's business logic requires. In addition, such operator can intercept the \n+     * flow control calls of {@code cancel} and {@code request} that would have travelled upstream and perform\n+     * additional actions depending on the same business logic requirements.\n      * <p>\n-     * In other words, this allows chaining Subscribers together on a Publisher for acting on the values within\n-     * the Publisher.\n-     * <p> {@code\n-     * Publisher.map(...).filter(...).take(5).lift(new OperatorA()).lift(new OperatorB(...)).subscribe()\n+     * Example:\n+     * <pre><code>\n+     * // Step 1: Create the consumer type that will be returned by the FlowableOperator.apply():\n+     * \n+     * public final class CustomSubscriber&lt;T&gt; implements FlowableSubscriber&lt;T&gt;, Subscription {\n+     *\n+     *     // The donstream's Subscriber that will receive the onXXX events\n+     *     final Subscriber&lt;? super String&gt; downstream;\n+     *\n+     *     // The connection to the upstream source that will call this class' onXXX methods\n+     *     Subscription upstream;\n+     *\n+     *     // The constructor takes the downstream subscriber and usually any other parameters\n+     *     public CustomSubscriber(Subscriber&lt;? super String&gt; downstream) {\n+     *         this.downstream = downstream;\n+     *     }\n+     *\n+     *     // In the subscription phase, the upstream sends a Subscription to this class\n+     *     // and subsequently this class has to send a Subscription to the downstream.\n+     *     // Note that relaying the upstream's Subscription directly is not allowed in RxJava\n+     *     &#64;Override\n+     *     public void onSubscribe(Subscription s) {\n+     *         if (upstream != null) {\n+     *             s.cancel();\n+     *         } else {\n+     *             upstream = s;\n+     *             downstream.onSubscribe(this);\n+     *         }\n+     *     }\n+     *\n+     *     // The upstream calls this with the next item and the implementation's\n+     *     // responsibility is to emit an item to the downstream based on the intended\n+     *     // business logic, or if it can't do so for the particular item,\n+     *     // request more from the upstream\n+     *     &#64;Override\n+     *     public void onNext(T item) {\n+     *         String str = item.toString();\n+     *         if (str.length() &lt; 2) {\n+     *             downstream.onNext(str);\n+     *         } else {\n+     *             upstream.request(1);\n+     *         }\n+     *     }\n+     *\n+     *     // Some operators may handle the upstream's error while others\n+     *     // could just forward it to the downstream.\n+     *     &#64;Override\n+     *     public void onError(Throwable throwable) {\n+     *         downstream.onError(throwable);\n+     *     }\n+     *\n+     *     // When the upstream completes, usually the downstream should complete as well.\n+     *     &#64;Override\n+     *     public void onComplete() {\n+     *         downstream.onComplete();\n+     *     }\n+     *\n+     *     // Some operators have to intercept the downstream's request calls to trigger\n+     *     // the emission of queued items while others can simply forward the request\n+     *     // amount as is.\n+     *     &#64;Override\n+     *     public void request(long n) {\n+     *         upstream.request(n);\n+     *     }\n+     *\n+     *     // Some operators may use their own resources which should be cleaned up if\n+     *     // the downstream cancels the flow before it completed. Operators without\n+     *     // resources can simply forward the cancellation to the upstream.\n+     *     // In some cases, a cancelled flag may be set by this method so that other parts\n+     *     // of this class may detect the cancellation and stop sending events\n+     *     // to the downstream.\n+     *     &#64;Override\n+     *     public void cancel() {\n+     *         upstream.cancel();\n+     *     }\n      * }\n+     *\n+     * // Step 2: Create a class that implements the FlowableOperator interface and\n+     * //         returns the custom consumer type from above in its apply() method.\n+     * //         Such class may define additional parameters to be submitted to\n+     * //         the custom consumer type.\n+     *\n+     * final class CustomOperator&lt;T&gt; implements FlowableOperator&lt;String&gt; {\n+     *     &#64;Override\n+     *     public Subscriber&lt;? super String&gt; apply(Subscriber&lt;? super T&gt; upstream) {\n+     *         return new CustomSubscriber&lt;T&gt;(upstream);\n+     *     }\n+     * }\n+     *\n+     * // Step 3: Apply the custom operator via lift() in a flow by creating an instance of it\n+     * //         or reusing an existing one.\n+     *\n+     * Flowable.range(5, 10)\n+     * .lift(new CustomOperator&lt;Integer&gt;())\n+     * .test()\n+     * .assertResult(\"5\", \"6\", \"7\", \"8\", \"9\");\n+     * </code></pre>\n      * <p>\n-     * If the operator you are creating is designed to act on the individual items emitted by a source\n-     * Publisher, use {@code lift}. If your operator is designed to transform the source Publisher as a whole\n-     * (for instance, by applying a particular set of existing RxJava operators to it) use {@link #compose}.\n+     * Creating custom operators can be complicated and it is recommended one consults the\n+     * <a href=\"https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0\">RxJava wiki: Writing operators</a> page about\n+     * the tools, requirements, rules, considerations and pitfalls of implementing them.\n+     * <p>\n+     * Note that implementing custom operators via this {@code lift()} method adds slightly more overhead by requiring\n+     * an additional allocation and indirection per assembled flows. Instead, extending the abstract {@code Flowable}\n+     * class and creating a {@link FlowableTransformer} with it is recommended.\n+     * <p>\n+     * Note also that it is not possible to stop the subscription phase in {@code lift()} as the {@code apply()} method\n+     * requires a non-null {@code Subscriber} instance to be returned, which is then unconditionally subscribed to\n+     * the upstream {@code Flowable}. For example, if the operator decided there is no reason to subscribe to the\n+     * upstream source because of some optimization possibility or a failure to prepare the operator, it still has to\n+     * return a {@code Subscriber} that should immediately cancel the upstream's {@code Subscription} in its\n+     * {@code onSubscribe} method. Again, using a {@code FlowableTransformer} and extending the {@code Flowable} is\n+     * a better option as {@link #subscribeActual} can decide to not subscribe to its upstream after all.\n      * <dl>\n      *  <dt><b>Backpressure:</b></dt>\n-     *  <dd>The {@code Operator} instance provided is responsible to be backpressure-aware or\n-     *  document the fact that the consumer of the returned {@code Publisher} has to apply one of\n+     *  <dd>The {@code Subscriber} instance returned by the {@link FlowableOperator} is responsible to be \n+     *  backpressure-aware or document the fact that the consumer of the returned {@code Publisher} has to apply one of\n      *  the {@code onBackpressureXXX} operators.</dd>\n      *  <dt><b>Scheduler:</b></dt>\n-     *  <dd>{@code lift} does not operate by default on a particular {@link Scheduler}.</dd>\n+     *  <dd>{@code lift} does not operate by default on a particular {@link Scheduler}, however, the\n+     *  {@link FlowableOperator} may use a {@code Scheduler} to support its own asynchronous behavior.</dd>\n      * </dl>\n      *\n      * @param <R> the output value type\n-     * @param lifter the Operator that implements the Publisher-operating function to be applied to the source\n-     *             Publisher\n-     * @return a Flowable that is the result of applying the lifted Operator to the source Publisher\n-     * @see <a href=\"https://github.com/ReactiveX/RxJava/wiki/Implementing-Your-Own-Operators\">RxJava wiki: Implementing Your Own Operators</a>\n+     * @param lifter the {@link FlowableOperator} that receives the downstream's {@code Subscriber} and should return\n+     *               a {@code Subscriber} with custom behavior to be used as the consumer for the current\n+     *               {@code Flowable}.\n+     * @return the new Flowable instance\n+     * @see <a href=\"https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0\">RxJava wiki: Writing operators</a>\n+     * @see #compose(FlowableTransformer)\n      */\n     @CheckReturnValue\n     @BackpressureSupport(BackpressureKind.SPECIAL)",
      "parent_sha": "569c5abe4a7f21f1a986829e43df206216c98521"
    }
  },
  {
    "oid": "334de61dd3f4bdab684cf253772a9da225bcc147",
    "message": "Fix the unbounded check for merge",
    "date": "2014-07-29T13:44:54Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/334de61dd3f4bdab684cf253772a9da225bcc147",
    "details": {
      "sha": "c4860532b1b7e9d706309b3f25ed50c92890bb1b",
      "filename": "rxjava-core/src/main/java/rx/internal/operators/OperatorMerge.java",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/334de61dd3f4bdab684cf253772a9da225bcc147/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Finternal%2Foperators%2FOperatorMerge.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/334de61dd3f4bdab684cf253772a9da225bcc147/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Finternal%2Foperators%2FOperatorMerge.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Finternal%2Foperators%2FOperatorMerge.java?ref=334de61dd3f4bdab684cf253772a9da225bcc147",
      "patch": "@@ -210,7 +210,7 @@ private void handleScalarSynchronousObservable(ScalarSynchronousObservable<? ext\n              * } </pre>\n              * \n              */\n-            if (mergeProducer.requested < 0) {\n+            if (mergeProducer.requested == Long.MAX_VALUE) {\n                 handleScalarSynchronousObservableWithoutRequestLimits(t);\n             } else {\n                 handleScalarSynchronousObservableWithRequestLimits(t);\n@@ -489,6 +489,9 @@ public MergeProducer(MergeSubscriber<T> ms) {\n \n         @Override\n         public void request(long n) {\n+            if (requested == Long.MAX_VALUE) {\n+                return;\n+            }\n             if (n == Long.MAX_VALUE) {\n                 requested = Long.MAX_VALUE;\n             } else {",
      "parent_sha": "08bf50f51c6a919197526a5f0d1ff7a5ee111b0f"
    }
  },
  {
    "oid": "c799bc08ade4fb981a2a5b2ad983a0adf1445c23",
    "message": "2.x: Fix typo in error message. (#5354)",
    "date": "2017-05-18T15:01:49Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/c799bc08ade4fb981a2a5b2ad983a0adf1445c23",
    "details": {
      "sha": "a7f9bf5008da353b6a38ec6a4c5cd1fad8dae833",
      "filename": "src/main/java/io/reactivex/observers/BaseTestConsumer.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/c799bc08ade4fb981a2a5b2ad983a0adf1445c23/src%2Fmain%2Fjava%2Fio%2Freactivex%2Fobservers%2FBaseTestConsumer.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/c799bc08ade4fb981a2a5b2ad983a0adf1445c23/src%2Fmain%2Fjava%2Fio%2Freactivex%2Fobservers%2FBaseTestConsumer.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Fio%2Freactivex%2Fobservers%2FBaseTestConsumer.java?ref=c799bc08ade4fb981a2a5b2ad983a0adf1445c23",
      "patch": "@@ -549,7 +549,7 @@ public final U assertValueSequence(Iterable<? extends T> sequence) {\n             throw fail(\"More values received than expected (\" + i + \")\");\n         }\n         if (expectedNext) {\n-            throw fail(\"Fever values received than expected (\" + i + \")\");\n+            throw fail(\"Fewer values received than expected (\" + i + \")\");\n         }\n         return (U)this;\n     }",
      "parent_sha": "96b8d585c137b13e083afb5aba77eb772e3f8513"
    }
  },
  {
    "oid": "84d1ed91bd0f9d3051ff38f7e0a1e79aa867ab1e",
    "message": "Set unsubscribed true\n\n... should probably set it to true when unsubscribed :-$",
    "date": "2013-03-12T04:04:09Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/84d1ed91bd0f9d3051ff38f7e0a1e79aa867ab1e",
    "details": {
      "sha": "0ad92e1d06a2b1befddba4f1a3731366e0658616",
      "filename": "rxjava-core/src/main/java/rx/subscriptions/BooleanSubscription.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/84d1ed91bd0f9d3051ff38f7e0a1e79aa867ab1e/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fsubscriptions%2FBooleanSubscription.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/84d1ed91bd0f9d3051ff38f7e0a1e79aa867ab1e/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fsubscriptions%2FBooleanSubscription.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fsubscriptions%2FBooleanSubscription.java?ref=84d1ed91bd0f9d3051ff38f7e0a1e79aa867ab1e",
      "patch": "@@ -20,7 +20,7 @@ public boolean isUnsubscribed() {\n \n     @Override\n     public void unsubscribe() {\n-        unsubscribed.set(false);\n+        unsubscribed.set(true);\n     }\n \n }",
      "parent_sha": "10d8ca9e14cb966971f5511cd8bcd2d97ee499c6"
    }
  },
  {
    "oid": "5fa92556138097cf7f4c217818a8db8c1491e6f8",
    "message": "Make retryWhen the same with the Scheduler as the retryWhen without the Scheduler.",
    "date": "2014-08-18T05:07:54Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/5fa92556138097cf7f4c217818a8db8c1491e6f8",
    "details": {
      "sha": "6d0438c3ee08aede1236cb564fcf0bf907426ed9",
      "filename": "rxjava-core/src/main/java/rx/Observable.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/5fa92556138097cf7f4c217818a8db8c1491e6f8/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/5fa92556138097cf7f4c217818a8db8c1491e6f8/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java?ref=5fa92556138097cf7f4c217818a8db8c1491e6f8",
      "patch": "@@ -7435,7 +7435,7 @@ public final Observable<T> retryWhen(Func1<? super Observable<? extends Notifica\n      * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Error-Handling-Operators#retrywhen\">RxJava Wiki: retryWhen()</a>\n      * @since 0.20\n      */\n-    public final Observable<T> retryWhen(Func1<? super Observable<? extends Notification<?>>, ? extends Observable<? extends Notification<?>>> notificationHandler, Scheduler scheduler) {\n+    public final Observable<T> retryWhen(Func1<? super Observable<? extends Notification<?>>, ? extends Observable<?>> notificationHandler, Scheduler scheduler) {\n         return OnSubscribeRedo.<T> retry(this, notificationHandler, scheduler);\n     }\n ",
      "parent_sha": "83cc1c1b984655eb87b5e2cf71629974ef680e3d"
    }
  },
  {
    "oid": "573f756f6747b4dfab8d61c0cedb1fab3a0173a3",
    "message": "and... the inevitable javadoc enhancements (for the new doOnUnsubscribe method)...",
    "date": "2014-08-15T19:14:05Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/573f756f6747b4dfab8d61c0cedb1fab3a0173a3",
    "details": {
      "sha": "f035272ceed44ef93468232a3d25ec18226dfe0e",
      "filename": "rxjava-core/src/main/java/rx/Observable.java",
      "status": "modified",
      "additions": 9,
      "deletions": 4,
      "changes": 13,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/573f756f6747b4dfab8d61c0cedb1fab3a0173a3/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/573f756f6747b4dfab8d61c0cedb1fab3a0173a3/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java?ref=573f756f6747b4dfab8d61c0cedb1fab3a0173a3",
      "patch": "@@ -10363,11 +10363,16 @@ public void call(Subscriber<? super T> observer) {\n      * its subscribers. Each un-subscription will result in an invocation of the given action except when the\n      * source {@code Observable} is reference counted, in which case the source {@code Observable} will invoke\n      * the given action for the very last un-subscription.\n+     * <p>\n+     * <img width=\"640\" height=\"310\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/doOnUnsubscribe.png\" alt=\"\">\n+     * <dl>\n+     *  <dt><b>Scheduler:</b></dt>\n+     *  <dd>{@code doOnUnsubscribe} does not operate by default on a particular {@link Scheduler}.</dd>\n+     * </dl>\n      *\n-     *\n-     * @param unsubscribe The action that gets called when this {@code Observable} is unsubscribed.\n-     *\n-     * @return That modified {@code Observable}\n+     * @param unsubscribe the action that gets called when this {@code Observable} is unsubscribed\n+     * @return the source {@code Observable} modified so as to call this Action when appropriate\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#doonunsubscribe\">RxJava wiki: doOnUnsubscribe</a>\n      */\n     public final Observable<T> doOnUnsubscribe(final Action0 unsubscribe) {\n         return lift(new OperatorDoOnUnsubscribe<T>(unsubscribe));",
      "parent_sha": "db50430328fef69602f7a503607b4fa4d5a76ffa"
    }
  },
  {
    "oid": "02ee6fae45e5b6c2c90af88f6479fb130c87cbe7",
    "message": "Cleaned up imports and removed unnecessary final keywords in the OperationThrottle class.",
    "date": "2013-05-05T22:48:53Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/02ee6fae45e5b6c2c90af88f6479fb130c87cbe7",
    "details": {
      "sha": "282347a38e80689afb0b6312ddc605adf41aef71",
      "filename": "rxjava-core/src/main/java/rx/operators/OperationThrottle.java",
      "status": "modified",
      "additions": 9,
      "deletions": 14,
      "changes": 23,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/02ee6fae45e5b6c2c90af88f6479fb130c87cbe7/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationThrottle.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/02ee6fae45e5b6c2c90af88f6479fb130c87cbe7/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationThrottle.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationThrottle.java?ref=02ee6fae45e5b6c2c90af88f6479fb130c87cbe7",
      "patch": "@@ -15,13 +15,8 @@\n  */\n package rx.operators;\n \n-import static org.mockito.Matchers.any;\n-import static org.mockito.Matchers.anyString;\n-import static org.mockito.Mockito.inOrder;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.never;\n-import static org.mockito.Mockito.times;\n-import static org.mockito.Mockito.verify;\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n \n import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n@@ -60,7 +55,7 @@ public final class OperationThrottle {\n      * @param unit       The unit of time for the specified timeout.\n      * @return A {@link Func1} which performs the throttle operation.\n      */\n-    public static <T> Func1<Observer<T>, Subscription> throttle(final Observable<T> items, long timeout, TimeUnit unit) {\n+    public static <T> Func1<Observer<T>, Subscription> throttle(Observable<T> items, long timeout, TimeUnit unit) {\n         return throttle(items, timeout, unit, Schedulers.executor(Executors.newSingleThreadScheduledExecutor()));\n     }\n \n@@ -132,7 +127,7 @@ public void onError(Exception e) {\n         }\n \n         @Override\n-        public void onNext(final T args) {\n+        public void onNext(T args) {\n             throttle(new ThrottledOnNext<T>(observer, args));\n         }\n \n@@ -215,7 +210,7 @@ public void before() {\n         public void testThrottlingWithCompleted() {\n             Observable<String> source = Observable.create(new Func1<Observer<String>, Subscription>() {\n                 @Override\n-                public Subscription call(final Observer<String> observser) {\n+                public Subscription call(Observer<String> observser) {\n                     publishNext(observser, 100, \"one\");    // Should be skipped since \"two\" will arrive before the timeout expires.\n                     publishNext(observser, 400, \"two\");    // Should be published since \"three\" will arrive after the timeout expires.\n                     publishNext(observser, 900, \"four\");   // Should be skipped since onCompleted will arrive before the timeout expires.\n@@ -250,7 +245,7 @@ public Subscription call(final Observer<String> observser) {\n         public void testThrottlingWithError() {\n             Observable<String> source = Observable.create(new Func1<Observer<String>, Subscription>() {\n                 @Override\n-                public Subscription call(final Observer<String> observser) {\n+                public Subscription call(Observer<String> observser) {\n                     Exception error = new TestException();\n                     publishNext(observser, 100, \"one\");    // Should be published since \"two\" will arrive after the timeout expires.\n                     publishNext(observser, 600, \"two\");    // Should be skipped since onError will arrive before the timeout expires.\n@@ -281,7 +276,7 @@ public Subscription call(final Observer<String> observser) {\n             verify(observer, times(1)).onError(any(TestException.class));\n         }\n \n-        private void publishCompleted(final Observer<String> observer, long delay) {\n+        private <T> void publishCompleted(final Observer<T> observer, long delay) {\n             scheduler.schedule(new Action0() {\n                 @Override\n                 public void call() {\n@@ -290,7 +285,7 @@ public void call() {\n             }, delay, TimeUnit.MILLISECONDS);\n         }\n \n-        private void publishError(final Observer<String> observer, long delay, final Exception error) {\n+        private <T> void publishError(final Observer<T> observer, long delay, final Exception error) {\n             scheduler.schedule(new Action0() {\n                 @Override\n                 public void call() {\n@@ -299,7 +294,7 @@ public void call() {\n             }, delay, TimeUnit.MILLISECONDS);\n         }\n \n-        private void publishNext(final Observer<String> observer, long delay, final String value) {\n+        private <T> void publishNext(final Observer<T> observer, long delay, final T value) {\n             scheduler.schedule(new Action0() {\n                 @Override\n                 public void call() {",
      "parent_sha": "77ac15bb78fd9bc4f698edd44bbd88a55907a2b8"
    }
  },
  {
    "oid": "624c4fb55bcbf0489a00db370154738c7d89408b",
    "message": "Update Schedulers.java (#7453)\n\nFix wording about cancellation",
    "date": "2022-07-22T05:57:41Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/624c4fb55bcbf0489a00db370154738c7d89408b",
    "details": {
      "sha": "cb2565240482cb79897f1ba8de8cc066cdfcb12a",
      "filename": "src/main/java/io/reactivex/rxjava3/schedulers/Schedulers.java",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/624c4fb55bcbf0489a00db370154738c7d89408b/src%2Fmain%2Fjava%2Fio%2Freactivex%2Frxjava3%2Fschedulers%2FSchedulers.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/624c4fb55bcbf0489a00db370154738c7d89408b/src%2Fmain%2Fjava%2Fio%2Freactivex%2Frxjava3%2Fschedulers%2FSchedulers.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Fio%2Freactivex%2Frxjava3%2Fschedulers%2FSchedulers.java?ref=624c4fb55bcbf0489a00db370154738c7d89408b",
      "patch": "@@ -318,7 +318,7 @@ public static Scheduler single() {\n      * calls to it.\n      * <p>\n      * If the provided executor doesn't support any of the more specific standard Java executor\n-     * APIs, cancelling tasks scheduled by this scheduler can't be interrupted when they are\n+     * APIs, tasks scheduled by this scheduler can't be interrupted when they are\n      * executing but only prevented from running prior to that. In addition, tasks scheduled with\n      * a time delay or periodically will use the {@link #single()} scheduler for the timed waiting\n      * before posting the actual task to the given executor.\n@@ -327,13 +327,13 @@ public static Scheduler single() {\n      * {@link #from(Executor, boolean)} overload to enable task interruption via this wrapper.\n      * <p>\n      * If the provided executor supports the standard Java {@link ExecutorService} API,\n-     * cancelling tasks scheduled by this scheduler can be cancelled/interrupted by calling\n+     * tasks scheduled by this scheduler can be cancelled/interrupted by calling\n      * {@link io.reactivex.rxjava3.disposables.Disposable#dispose()}. In addition, tasks scheduled with\n      * a time delay or periodically will use the {@link #single()} scheduler for the timed waiting\n      * before posting the actual task to the given executor.\n      * <p>\n      * If the provided executor supports the standard Java {@link ScheduledExecutorService} API,\n-     * cancelling tasks scheduled by this scheduler can be cancelled/interrupted by calling\n+     * tasks scheduled by this scheduler can be cancelled/interrupted by calling\n      * {@link io.reactivex.rxjava3.disposables.Disposable#dispose()}. In addition, tasks scheduled with\n      * a time delay or periodically will use the provided executor. Note, however, if the provided\n      * {@code ScheduledExecutorService} instance is not single threaded, tasks scheduled\n@@ -405,13 +405,13 @@ public static Scheduler from(@NonNull Executor executor) {\n      * before posting the actual task to the given executor.\n      * <p>\n      * If the provided executor supports the standard Java {@link ExecutorService} API,\n-     * canceling tasks scheduled by this scheduler can be cancelled/interrupted by calling\n+     * tasks scheduled by this scheduler can be cancelled/interrupted by calling\n      * {@link io.reactivex.rxjava3.disposables.Disposable#dispose()}. In addition, tasks scheduled with\n      * a time delay or periodically will use the {@link #single()} scheduler for the timed waiting\n      * before posting the actual task to the given executor.\n      * <p>\n      * If the provided executor supports the standard Java {@link ScheduledExecutorService} API,\n-     * canceling tasks scheduled by this scheduler can be cancelled/interrupted by calling\n+     * tasks scheduled by this scheduler can be cancelled/interrupted by calling\n      * {@link io.reactivex.rxjava3.disposables.Disposable#dispose()}. In addition, tasks scheduled with\n      * a time delay or periodically will use the provided executor. Note, however, if the provided\n      * {@code ScheduledExecutorService} instance is not single threaded, tasks scheduled\n@@ -487,13 +487,13 @@ public static Scheduler from(@NonNull Executor executor, boolean interruptibleWo\n      * before posting the actual task to the given executor.\n      * <p>\n      * If the provided executor supports the standard Java {@link ExecutorService} API,\n-     * canceling tasks scheduled by this scheduler can be cancelled/interrupted by calling\n+     * tasks scheduled by this scheduler can be cancelled/interrupted by calling\n      * {@link io.reactivex.rxjava3.disposables.Disposable#dispose()}. In addition, tasks scheduled with\n      * a time delay or periodically will use the {@link #single()} scheduler for the timed waiting\n      * before posting the actual task to the given executor.\n      * <p>\n      * If the provided executor supports the standard Java {@link ScheduledExecutorService} API,\n-     * canceling tasks scheduled by this scheduler can be cancelled/interrupted by calling\n+     * tasks scheduled by this scheduler can be cancelled/interrupted by calling\n      * {@link io.reactivex.rxjava3.disposables.Disposable#dispose()}. In addition, tasks scheduled with\n      * a time delay or periodically will use the provided executor. Note, however, if the provided\n      * {@code ScheduledExecutorService} instance is not single threaded, tasks scheduled",
      "parent_sha": "84736107209babc762ddd4394115afbe65a961c8"
    }
  },
  {
    "oid": "ab0c59094d11142cea4fef70169f053e062d85ec",
    "message": "Fix a small typo in ParallelFlowable",
    "date": "2017-03-20T19:40:33Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/ab0c59094d11142cea4fef70169f053e062d85ec",
    "details": {
      "sha": "45efe0a864fb1bcfcde39965a4bb4ad24eac7e45",
      "filename": "src/main/java/io/reactivex/parallel/ParallelFlowable.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/ab0c59094d11142cea4fef70169f053e062d85ec/src%2Fmain%2Fjava%2Fio%2Freactivex%2Fparallel%2FParallelFlowable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/ab0c59094d11142cea4fef70169f053e062d85ec/src%2Fmain%2Fjava%2Fio%2Freactivex%2Fparallel%2FParallelFlowable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Fio%2Freactivex%2Fparallel%2FParallelFlowable.java?ref=ab0c59094d11142cea4fef70169f053e062d85ec",
      "patch": "@@ -32,7 +32,7 @@\n  * Abstract base class for Parallel publishers that take an array of Subscribers.\n  * <p>\n  * Use {@code from()} to start processing a regular Publisher in 'rails'.\n- * Use {@code runOn()} to introduce where each 'rail' shoud run on thread-vise.\n+ * Use {@code runOn()} to introduce where each 'rail' should run on thread-vise.\n  * Use {@code sequential()} to merge the sources back into a single Flowable.\n  *\n  * @param <T> the value type",
      "parent_sha": "21a7a0567a51193734e21b234fa3ed925e65d0ec"
    }
  },
  {
    "oid": "0da74ba59f780a5986859e3e7204169bc1da1e6f",
    "message": "Manual Merge of Pull #616\n\nManual merge of https://github.com/Netflix/RxJava/pull/616\n\n- remove use of SingleAssignmentSubscription\n- suppress warnings",
    "date": "2013-12-30T18:17:16Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/0da74ba59f780a5986859e3e7204169bc1da1e6f",
    "details": {
      "sha": "272ac6af7f3b202e1006bdc303efcebdc0aaebcf",
      "filename": "rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java",
      "status": "modified",
      "additions": 33,
      "deletions": 14,
      "changes": 47,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/0da74ba59f780a5986859e3e7204169bc1da1e6f/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationCombineLatest.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/0da74ba59f780a5986859e3e7204169bc1da1e6f/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationCombineLatest.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationCombineLatest.java?ref=0da74ba59f780a5986859e3e7204169bc1da1e6f",
      "patch": "@@ -27,7 +27,6 @@\n import rx.Observer;\n import rx.Subscription;\n import rx.subscriptions.CompositeSubscription;\n-import rx.subscriptions.SingleAssignmentSubscription;\n import rx.util.functions.Func2;\n import rx.util.functions.Func3;\n import rx.util.functions.Func4;\n@@ -61,37 +60,42 @@ public class OperationCombineLatest {\n      *            The aggregation function used to combine the source observable values.\n      * @return A function from an observer to a subscription. This can be used to create an observable from.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public static <T0, T1, R> OnSubscribeFunc<R> combineLatest(Observable<? extends T0> w0, Observable<T1> w1, Func2<? super T0, ? super T1, ? extends R> combineLatestFunction) {\n         return new CombineLatest<Object, R>(Arrays.asList(w0, w1), Functions.fromFunc(combineLatestFunction));\n     }\n \n     /**\n      * @see #combineLatest(Observable w0, Observable w1, Func2 combineLatestFunction)\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public static <T0, T1, T2, R> OnSubscribeFunc<R> combineLatest(Observable<? extends T0> w0, Observable<? extends T1> w1, Observable<? extends T2> w2,\n             Func3<? super T0, ? super T1, ? super T2, ? extends R> combineLatestFunction) {\n-        return new CombineLatest<Object, R>(Arrays.asList(w0, w1, w2), Functions.fromFunc(combineLatestFunction));    \n+        return new CombineLatest<Object, R>(Arrays.asList(w0, w1, w2), Functions.fromFunc(combineLatestFunction));\n     }\n \n     /**\n      * @see #combineLatest(Observable w0, Observable w1, Func2 combineLatestFunction)\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public static <T0, T1, T2, T3, R> OnSubscribeFunc<R> combineLatest(Observable<? extends T0> w0, Observable<? extends T1> w1, Observable<? extends T2> w2, Observable<? extends T3> w3,\n             Func4<? super T0, ? super T1, ? super T2, ? super T3, ? extends R> combineLatestFunction) {\n-                return new CombineLatest<Object, R>(Arrays.asList(w0, w1, w2, w3), Functions.fromFunc(combineLatestFunction));\n+        return new CombineLatest<Object, R>(Arrays.asList(w0, w1, w2, w3), Functions.fromFunc(combineLatestFunction));\n     }\n \n     /**\n      * @see #combineLatest(Observable w0, Observable w1, Func2 combineLatestFunction)\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public static <T0, T1, T2, T3, T4, R> OnSubscribeFunc<R> combineLatest(Observable<? extends T0> w0, Observable<? extends T1> w1, Observable<? extends T2> w2, Observable<? extends T3> w3, Observable<? extends T4> w4,\n             Func5<? super T0, ? super T1, ? super T2, ? super T3, ? super T4, ? extends R> combineLatestFunction) {\n-                return new CombineLatest<Object, R>(Arrays.asList(w0, w1, w2, w3, w4), Functions.fromFunc(combineLatestFunction));\n+        return new CombineLatest<Object, R>(Arrays.asList(w0, w1, w2, w3, w4), Functions.fromFunc(combineLatestFunction));\n     }\n \n     /**\n      * @see #combineLatest(Observable w0, Observable w1, Func2 combineLatestFunction)\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public static <T0, T1, T2, T3, T4, T5, R> OnSubscribeFunc<R> combineLatest(Observable<? extends T0> w0, Observable<? extends T1> w1, Observable<? extends T2> w2, Observable<? extends T3> w3, Observable<? extends T4> w4, Observable<? extends T5> w5,\n             Func6<? super T0, ? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R> combineLatestFunction) {\n         return new CombineLatest<Object, R>(Arrays.asList(w0, w1, w2, w3, w4, w5), Functions.fromFunc(combineLatestFunction));\n@@ -100,6 +104,7 @@ public static <T0, T1, T2, T3, T4, T5, R> OnSubscribeFunc<R> combineLatest(Obser\n     /**\n      * @see #combineLatest(Observable w0, Observable w1, Func2 combineLatestFunction)\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public static <T0, T1, T2, T3, T4, T5, T6, R> OnSubscribeFunc<R> combineLatest(Observable<? extends T0> w0, Observable<? extends T1> w1, Observable<? extends T2> w2, Observable<? extends T3> w3, Observable<? extends T4> w4, Observable<? extends T5> w5, Observable<? extends T6> w6,\n             Func7<? super T0, ? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R> combineLatestFunction) {\n         return new CombineLatest<Object, R>(Arrays.asList(w0, w1, w2, w3, w4, w5, w6), Functions.fromFunc(combineLatestFunction));\n@@ -108,6 +113,7 @@ public static <T0, T1, T2, T3, T4, T5, T6, R> OnSubscribeFunc<R> combineLatest(O\n     /**\n      * @see #combineLatest(Observable w0, Observable w1, Func2 combineLatestFunction)\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public static <T0, T1, T2, T3, T4, T5, T6, T7, R> OnSubscribeFunc<R> combineLatest(Observable<? extends T0> w0, Observable<? extends T1> w1, Observable<? extends T2> w2, Observable<? extends T3> w3, Observable<? extends T4> w4, Observable<? extends T5> w5, Observable<? extends T6> w6, Observable<? extends T7> w7,\n             Func8<? super T0, ? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R> combineLatestFunction) {\n         return new CombineLatest<Object, R>(Arrays.asList(w0, w1, w2, w3, w4, w5, w6, w7), Functions.fromFunc(combineLatestFunction));\n@@ -116,6 +122,7 @@ public static <T0, T1, T2, T3, T4, T5, T6, T7, R> OnSubscribeFunc<R> combineLate\n     /**\n      * @see #combineLatest(Observable w0, Observable w1, Func2 combineLatestFunction)\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public static <T0, T1, T2, T3, T4, T5, T6, T7, T8, R> OnSubscribeFunc<R> combineLatest(Observable<? extends T0> w0, Observable<? extends T1> w1, Observable<? extends T2> w2, Observable<? extends T3> w3, Observable<? extends T4> w4, Observable<? extends T5> w5, Observable<? extends T6> w6, Observable<? extends T7> w7,\n             Observable<? extends T8> w8,\n             Func9<? super T0, ? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R> combineLatestFunction) {\n@@ -125,6 +132,7 @@ public static <T0, T1, T2, T3, T4, T5, T6, T7, T8, R> OnSubscribeFunc<R> combine\n     static final class CombineLatest<T, R> implements OnSubscribeFunc<R> {\n         final List<Observable<? extends T>> sources;\n         final FuncN<? extends R> combiner;\n+\n         public CombineLatest(Iterable<? extends Observable<? extends T>> sources, FuncN<? extends R> combiner) {\n             this.sources = new ArrayList<Observable<? extends T>>();\n             this.combiner = combiner;\n@@ -136,27 +144,28 @@ public CombineLatest(Iterable<? extends Observable<? extends T>> sources, FuncN<\n         @Override\n         public Subscription onSubscribe(Observer<? super R> t1) {\n             CompositeSubscription csub = new CompositeSubscription();\n-            \n+\n             Collector collector = new Collector(t1, csub, sources.size());\n-            \n+\n             int index = 0;\n             List<SourceObserver> observers = new ArrayList<SourceObserver>(sources.size() + 1);\n             for (Observable<? extends T> source : sources) {\n-                SingleAssignmentSubscription sas = new SingleAssignmentSubscription();\n+                SafeObservableSubscription sas = new SafeObservableSubscription();\n                 csub.add(sas);\n                 observers.add(new SourceObserver(collector, sas, index, source));\n                 index++;\n             }\n-            \n+\n             for (SourceObserver so : observers) {\n                 // if we run to completion, don't bother any further\n                 if (!csub.isUnsubscribed()) {\n                     so.connect();\n                 }\n             }\n-            \n+\n             return csub;\n         }\n+\n         /**\n          * The collector that combines the latest values from many sources.\n          */\n@@ -173,6 +182,7 @@ final class Collector {\n             int hasCount;\n             /** Number of completed source observers. */\n             int completedCount;\n+\n             public Collector(Observer<? super R> observer, Subscription cancel, int count) {\n                 this.observer = observer;\n                 this.cancel = cancel;\n@@ -181,6 +191,7 @@ public Collector(Observer<? super R> observer, Subscription cancel, int count) {\n                 this.completed = new BitSet(count);\n                 this.lock = new ReentrantLock();\n             }\n+\n             public void next(int index, T value) {\n                 Throwable err = null;\n                 lock.lock();\n@@ -210,6 +221,7 @@ public void next(int index, T value) {\n                     cancel.unsubscribe();\n                 }\n             }\n+\n             public void error(int index, Throwable e) {\n                 boolean unsub = false;\n                 lock.lock();\n@@ -226,13 +238,16 @@ public void error(int index, Throwable e) {\n                     cancel.unsubscribe();\n                 }\n             }\n+\n             boolean isTerminated() {\n                 return completedCount == values.length + 1;\n             }\n+\n             void terminate() {\n                 completedCount = values.length + 1;\n                 Arrays.fill(values, null);\n             }\n+\n             public void completed(int index) {\n                 boolean unsub = false;\n                 lock.lock();\n@@ -256,22 +271,25 @@ public void completed(int index) {\n                 }\n             }\n         }\n+\n         /**\n          * Observes a specific source and communicates with the collector.\n          */\n-        final class SourceObserver implements Observer<T>  {\n-            final SingleAssignmentSubscription self;\n+        final class SourceObserver implements Observer<T> {\n+            final SafeObservableSubscription self;\n             final Collector collector;\n             final int index;\n             Observable<? extends T> source;\n-            public SourceObserver(Collector collector, \n-                    SingleAssignmentSubscription self, int index,\n+\n+            public SourceObserver(Collector collector,\n+                    SafeObservableSubscription self, int index,\n                     Observable<? extends T> source) {\n                 this.self = self;\n                 this.collector = collector;\n                 this.index = index;\n                 this.source = source;\n             }\n+\n             @Override\n             public void onNext(T args) {\n                 collector.next(index, args);\n@@ -287,9 +305,10 @@ public void onCompleted() {\n                 collector.completed(index);\n                 self.unsubscribe();\n             }\n+\n             /** Connect to the source. */\n             void connect() {\n-                self.set(source.subscribe(this));\n+                self.wrap(source.subscribe(this));\n                 source = null;\n             }\n         }",
      "parent_sha": "b3ac574b16c0243e992e8008c7339f9ca4b4bb67"
    }
  },
  {
    "oid": "1aadf040db872403ae5ffe4a23392f29b43c932e",
    "message": "Increased the interval time to 100ms.",
    "date": "2014-10-17T12:46:13Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/1aadf040db872403ae5ffe4a23392f29b43c932e",
    "details": {
      "sha": "e53915d6ae63c12015941681577ed6781ab44aa4",
      "filename": "src/test/java/rx/internal/operators/BlockingOperatorNextTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/1aadf040db872403ae5ffe4a23392f29b43c932e/src%2Ftest%2Fjava%2Frx%2Finternal%2Foperators%2FBlockingOperatorNextTest.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/1aadf040db872403ae5ffe4a23392f29b43c932e/src%2Ftest%2Fjava%2Frx%2Finternal%2Foperators%2FBlockingOperatorNextTest.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Ftest%2Fjava%2Frx%2Finternal%2Foperators%2FBlockingOperatorNextTest.java?ref=1aadf040db872403ae5ffe4a23392f29b43c932e",
      "patch": "@@ -296,7 +296,7 @@ public void run() {\n \n     @Test /* (timeout = 8000) */\n     public void testSingleSourceManyIterators() throws InterruptedException {\n-        Observable<Long> o = Observable.interval(10, TimeUnit.MILLISECONDS);\n+        Observable<Long> o = Observable.interval(100, TimeUnit.MILLISECONDS);\n         PublishSubject<Void> terminal = PublishSubject.create();\n         BlockingObservable<Long> source = o.takeUntil(terminal).toBlocking();\n ",
      "parent_sha": "502405d7ad5e469dffacd06ca0461e19769bb44a"
    }
  },
  {
    "oid": "c530fe575d706163ec525fa0058524bbf8e82915",
    "message": "Change in wiki page from \"Mathematical Operators\" to \"Mathematical and Aggregate Operators\"\nmove toList, reduce, concat, toSortedList, toMap, and toMultiMap to that page\ndeprecate aggregate in favor of reduce\n[should I move takeLast, last, and takeLastBuffer to the Aggregate operators page? they don't operate on the aggregate, exactly, but they do wait until the source completes before emitting anything]",
    "date": "2013-12-26T19:30:17Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/c530fe575d706163ec525fa0058524bbf8e82915",
    "details": {
      "sha": "44e4436ab48d3eae4eeaea49e88d522858876cf7",
      "filename": "rxjava-core/src/main/java/rx/Observable.java",
      "status": "modified",
      "additions": 40,
      "deletions": 40,
      "changes": 80,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/c530fe575d706163ec525fa0058524bbf8e82915/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/c530fe575d706163ec525fa0058524bbf8e82915/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java?ref=c530fe575d706163ec525fa0058524bbf8e82915",
      "patch": "@@ -1388,7 +1388,7 @@ public static <T> Observable<T> merge(Observable<? extends T> t1, Observable<? e\n      * @return an Observable that emits items that are the result of combining\n      *         the items emitted by the {@code source} Observables, one after\n      *         the other\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Combining-Observables#concat\">RxJava Wiki: concat()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#concat\">RxJava Wiki: concat()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.concat.aspx\">MSDN: Observable.Concat Method</a>\n      */\n     public static <T> Observable<T> concat(Observable<? extends Observable<? extends T>> observables) {\n@@ -1406,7 +1406,7 @@ public static <T> Observable<T> concat(Observable<? extends Observable<? extends\n      * @return an Observable that emits items that are the result of combining\n      *         the items emitted by the {@code source} Observables, one after\n      *         the other\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Combining-Observables#concat\">RxJava Wiki: concat()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#concat\">RxJava Wiki: concat()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.concat.aspx\">MSDN: Observable.Concat Method</a>\n      */\n     @SuppressWarnings(\"unchecked\")\n@@ -1427,7 +1427,7 @@ public static <T> Observable<T> concat(Observable<? extends T> t1, Observable<?\n      * @return an Observable that emits items that are the result of combining\n      *         the items emitted by the {@code source} Observables, one after\n      *         the other\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Combining-Observables#concat\">RxJava Wiki: concat()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#concat\">RxJava Wiki: concat()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.concat.aspx\">MSDN: Observable.Concat Method</a>\n      */\n     @SuppressWarnings(\"unchecked\")\n@@ -1449,7 +1449,7 @@ public static <T> Observable<T> concat(Observable<? extends T> t1, Observable<?\n      * @return an Observable that emits items that are the result of combining\n      *         the items emitted by the {@code source} Observables, one after\n      *         the other\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Combining-Observables#concat\">RxJava Wiki: concat()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#concat\">RxJava Wiki: concat()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.concat.aspx\">MSDN: Observable.Concat Method</a>\n      */\n     @SuppressWarnings(\"unchecked\")\n@@ -1472,7 +1472,7 @@ public static <T> Observable<T> concat(Observable<? extends T> t1, Observable<?\n      * @return an Observable that emits items that are the result of combining\n      *         the items emitted by the {@code source} Observables, one after\n      *         the other\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Combining-Observables#concat\">RxJava Wiki: concat()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#concat\">RxJava Wiki: concat()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.concat.aspx\">MSDN: Observable.Concat Method</a>\n      */\n     @SuppressWarnings(\"unchecked\")\n@@ -1496,7 +1496,7 @@ public static <T> Observable<T> concat(Observable<? extends T> t1, Observable<?\n      * @return an Observable that emits items that are the result of combining\n      *         the items emitted by the {@code source} Observables, one after\n      *         the other\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Combining-Observables#concat\">RxJava Wiki: concat()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#concat\">RxJava Wiki: concat()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.concat.aspx\">MSDN: Observable.Concat Method</a>\n      */\n     @SuppressWarnings(\"unchecked\")\n@@ -1521,7 +1521,7 @@ public static <T> Observable<T> concat(Observable<? extends T> t1, Observable<?\n      * @return an Observable that emits items that are the result of combining\n      *         the items emitted by the {@code source} Observables, one after\n      *         the other\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Combining-Observables#concat\">RxJava Wiki: concat()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#concat\">RxJava Wiki: concat()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.concat.aspx\">MSDN: Observable.Concat Method</a>\n      */\n     @SuppressWarnings(\"unchecked\")\n@@ -1547,7 +1547,7 @@ public static <T> Observable<T> concat(Observable<? extends T> t1, Observable<?\n      * @return an Observable that emits items that are the result of combining\n      *         the items emitted by the {@code source} Observables, one after\n      *         the other\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Combining-Observables#concat\">RxJava Wiki: concat()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#concat\">RxJava Wiki: concat()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.concat.aspx\">MSDN: Observable.Concat Method</a>\n      */\n     @SuppressWarnings(\"unchecked\")\n@@ -1574,7 +1574,7 @@ public static <T> Observable<T> concat(Observable<? extends T> t1, Observable<?\n      * @return an Observable that emits items that are the result of combining\n      *         the items emitted by the {@code source} Observables, one after\n      *         the other\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Combining-Observables#concat\">RxJava Wiki: concat()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#concat\">RxJava Wiki: concat()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.concat.aspx\">MSDN: Observable.Concat Method</a>\n      */\n     @SuppressWarnings(\"unchecked\")\n@@ -4298,7 +4298,7 @@ public Observable<T> onErrorReturn(Func1<Throwable, ? extends T> resumeFunction)\n      * @return an Observable that emits a single item that is the result of\n      *         accumulating the output from the source Observable\n      * @throws IllegalArgumentException if the source Observable emits no items\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Transforming-Observables#reduce-or-aggregate\">RxJava Wiki: reduce()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#reduce\">RxJava Wiki: reduce()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229154.aspx\">MSDN: Observable.Aggregate</a>\n      * @see <a href=\"http://en.wikipedia.org/wiki/Fold_(higher-order_function)\">Wikipedia: Fold (higher-order function)</a>\n      */\n@@ -4319,7 +4319,7 @@ public Observable<T> reduce(Func2<T, T, T> accumulator) {\n      * \n      * @return an Observable that emits the number of elements emitted by the\n      *         source Observable as its single item\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-Operators#count-and-longcount\">RxJava Wiki: count()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#count-and-longcount\">RxJava Wiki: count()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229470.aspx\">MSDN: Observable.Count</a>\n      * @see #longCount()\n      */\n@@ -4341,7 +4341,7 @@ public Integer call(Integer t1, T t2) {\n      * @param source source Observable to compute the sum of\n      * @return an Observable that emits the sum of all the Integers emitted by\n      *         the source Observable as its single item\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-Operators#sum\">RxJava Wiki: sum()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#sum\">RxJava Wiki: sum()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.sum.aspx\">MSDN: Observable.Sum</a>\n      */\n     public static Observable<Integer> sum(Observable<Integer> source) {\n@@ -4357,7 +4357,7 @@ public static Observable<Integer> sum(Observable<Integer> source) {\n      * @param source source Observable to compute the sum of\n      * @return an Observable that emits the sum of all the Longs emitted by the\n      *         source Observable as its single item\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-Operators#sum\">RxJava Wiki: sumLongs()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#sum\">RxJava Wiki: sumLongs()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.sum.aspx\">MSDN: Observable.Sum</a>\n      */\n     public static Observable<Long> sumLongs(Observable<Long> source) {\n@@ -4373,7 +4373,7 @@ public static Observable<Long> sumLongs(Observable<Long> source) {\n      * @param source source Observable to compute the sum of\n      * @return an Observable that emits the sum of all the Floats emitted by the\n      *         source Observable as its single item\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-Operators#sum\">RxJava Wiki: sumFloats()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#sum\">RxJava Wiki: sumFloats()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.sum.aspx\">MSDN: Observable.Sum</a>\n      */\n     public static Observable<Float> sumFloats(Observable<Float> source) {\n@@ -4389,7 +4389,7 @@ public static Observable<Float> sumFloats(Observable<Float> source) {\n      * @param source source Observable to compute the sum of\n      * @return an Observable that emits the sum of all the Doubles emitted by\n      *         the source Observable as its single item\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-Operators#sum\">RxJava Wiki: sumDoubles()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#sum\">RxJava Wiki: sumDoubles()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.sum.aspx\">MSDN: Observable.Sum</a>\n      */\n     public static Observable<Double> sumDoubles(Observable<Double> source) {\n@@ -4406,7 +4406,7 @@ public static Observable<Double> sumDoubles(Observable<Double> source) {\n      * @return an Observable that emits the average of all the Integers emitted\n      *         by the source Observable as its single item\n      * @throws IllegalArgumentException if the source Observable emits no items\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-Operators#average\">RxJava Wiki: average()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#average\">RxJava Wiki: average()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.average.aspx\">MSDN: Observable.Average</a>\n      */\n     public static Observable<Integer> average(Observable<Integer> source) {\n@@ -4422,7 +4422,7 @@ public static Observable<Integer> average(Observable<Integer> source) {\n      * @param source source Observable to compute the average of\n      * @return an Observable that emits the average of all the Longs emitted by\n      *         the source Observable as its single item\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-Operators#average\">RxJava Wiki: averageLongs()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#average\">RxJava Wiki: averageLongs()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.average.aspx\">MSDN: Observable.Average</a>\n      */\n     public static Observable<Long> averageLongs(Observable<Long> source) {\n@@ -4438,7 +4438,7 @@ public static Observable<Long> averageLongs(Observable<Long> source) {\n      * @param source source Observable to compute the average of\n      * @return an Observable that emits the average of all the Floats emitted by\n      *         the source Observable as its single item\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-Operators#average\">RxJava Wiki: averageFloats()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#average\">RxJava Wiki: averageFloats()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.average.aspx\">MSDN: Observable.Average</a>\n      */\n     public static Observable<Float> averageFloats(Observable<Float> source) {\n@@ -4454,7 +4454,7 @@ public static Observable<Float> averageFloats(Observable<Float> source) {\n      * @param source source Observable to compute the average of\n      * @return an Observable that emits the average of all the Doubles emitted\n      *         by the source Observable as its single item\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-Operators#average\">RxJava Wiki: averageDoubles()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#average\">RxJava Wiki: averageDoubles()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.average.aspx\">MSDN: Observable.Average</a>\n      */\n     public static Observable<Double> averageDoubles(Observable<Double> source) {\n@@ -4489,7 +4489,7 @@ public static <T extends Comparable<? super T>> Observable<T> min(Observable<T>\n      * @return an Observable that emits the minimum item according to the\n      *         specified comparator\n      * @throws IllegalArgumentException if the source is empty\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-Operators#min\">RxJava Wiki: min()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#min\">RxJava Wiki: min()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229095.aspx\">MSDN: Observable.Min</a>\n      */\n     public Observable<T> min(Comparator<? super T> comparator) {\n@@ -4506,7 +4506,7 @@ public Observable<T> min(Comparator<? super T> comparator) {\n      * @param selector the key selector function\n      * @return an Observable that emits a List of the items from the source\n      *         Observable that had the minimum key value\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-Operators#minby\">RxJava Wiki: minBy()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#minby\">RxJava Wiki: minBy()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh228970.aspx\">MSDN: Observable.MinBy</a>\n      */\n     public <R extends Comparable<? super R>> Observable<List<T>> minBy(Func1<T, R> selector) {\n@@ -4526,7 +4526,7 @@ public <R extends Comparable<? super R>> Observable<List<T>> minBy(Func1<T, R> s\n      * @return an Observable that emits a List of the items emitted by the\n      *         source Observable that had the minimum key value according to the\n      *         specified comparator\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-Operators#minby\">RxJava Wiki: minBy()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#minby\">RxJava Wiki: minBy()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh228970.aspx\">MSDN: Observable.MinBy</a>\n      */\n     public <R> Observable<List<T>> minBy(Func1<T, R> selector, Comparator<? super R> comparator) {\n@@ -4543,7 +4543,7 @@ public <R> Observable<List<T>> minBy(Func1<T, R> selector, Comparator<? super R>\n      * @param source an Observable to scan for the maximum emitted item\n      * @return an Observable that emits this maximum item from the source\n      * @throws IllegalArgumentException if the source is empty\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-Operators#max\">RxJava Wiki: max()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#max\">RxJava Wiki: max()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh211837.aspx\">MSDN: Observable.Max</a>\n      */\n     public static <T extends Comparable<? super T>> Observable<T> max(Observable<T> source) {\n@@ -4561,7 +4561,7 @@ public static <T extends Comparable<? super T>> Observable<T> max(Observable<T>\n      * @return an Observable that emits the maximum item emitted by the source\n      *         Observable, according to the specified comparator\n      * @throws IllegalArgumentException if the source is empty\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-Operators#max\">RxJava Wiki: max()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#max\">RxJava Wiki: max()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh211635.aspx\">MSDN: Observable.Max</a>\n      */\n     public Observable<T> max(Comparator<? super T> comparator) {\n@@ -4578,7 +4578,7 @@ public Observable<T> max(Comparator<? super T> comparator) {\n      * @param selector the key selector function\n      * @return an Observable that emits a List of those items emitted by the\n      *         source Observable that had the maximum key value\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-Operators#maxby\">RxJava Wiki: maxBy()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#maxby\">RxJava Wiki: maxBy()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229058.aspx\">MSDN: Observable.MaxBy</a>\n      */\n     public <R extends Comparable<? super R>> Observable<List<T>> maxBy(Func1<T, R> selector) {\n@@ -4598,7 +4598,7 @@ public <R extends Comparable<? super R>> Observable<List<T>> maxBy(Func1<T, R> s\n      * @return an Observable that emits a List of those items emitted by the\n      *         source Observable that had the maximum key value according to the\n      *         specified comparator\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-Operators#maxby\">RxJava Wiki: maxBy()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#maxby\">RxJava Wiki: maxBy()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh244330.aspx\">MSDN: Observable.MaxBy</a>\n      */\n     public <R> Observable<List<T>> maxBy(Func1<T, R> selector, Comparator<? super R> comparator) {\n@@ -5184,7 +5184,7 @@ public ConnectableObservable<T> publishLast() {\n      * <p>\n      * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/aggregate.png\">\n      *\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Transforming-Observables#reduce-or-aggregate\">RxJava Wiki: aggregate()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#reduce\">RxJava Wiki: reduce()</a>\n      * @see #reduce(Func2)\n      * @deprecated use #reduce(Func2)\n      */\n@@ -5214,7 +5214,7 @@ public Observable<T> aggregate(Func2<T, T, T> accumulator) {\n      * @return an Observable that emits a single item that is the result of\n      *         accumulating the output from the items emitted by the source\n      *         Observable\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Transforming-Observables#reduce-or-aggregate\">RxJava Wiki: reduce()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#reduce\">RxJava Wiki: reduce()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229154.aspx\">MSDN: Observable.Aggregate</a>\n      * @see <a href=\"http://en.wikipedia.org/wiki/Fold_(higher-order_function)\">Wikipedia: Fold (higher-order function)</a>\n      */\n@@ -5227,7 +5227,7 @@ public <R> Observable<R> reduce(R initialValue, Func2<R, ? super T, R> accumulat\n      * <p>\n      * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/aggregateSeed.png\">\n      * \n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Transforming-Observables#reduce-or-aggregate\">RxJava Wiki: aggregate()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#reduce\">RxJava Wiki: reduce()</a>\n      * @see #reduce(Object, Func2)\n      * @deprecated use #reduce(Object, Func2)\n      */\n@@ -5918,7 +5918,7 @@ public Observable<T> skipLast(int count) {\n      * \n      * @return an Observable that emits a single item: a List containing all of\n      *         the items emitted by the source Observable.\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#tolist\">RxJava Wiki: toList()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#tolist\">RxJava Wiki: toList()</a>\n      */\n     public Observable<List<T>> toList() {\n         return create(OperationToObservableList.toObservableList(this));\n@@ -5937,7 +5937,7 @@ public Observable<List<T>> toList() {\n      *                            all other items emitted by the Observable\n      * @return an Observable that emits the items from the source Observable in\n      *         sorted order\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#tosortedlist\">RxJava Wiki: toSortedList()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#tosortedlist\">RxJava Wiki: toSortedList()</a>\n      */\n     public Observable<List<T>> toSortedList() {\n         return create(OperationToObservableSortedList.toSortedList(this));\n@@ -5954,7 +5954,7 @@ public Observable<List<T>> toSortedList() {\n      *                     indicates their sort order\n      * @return an Observable that emits the items from the source Observable in\n      *         sorted order\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#tosortedlist\">RxJava Wiki: toSortedList()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#tosortedlist\">RxJava Wiki: toSortedList()</a>\n      */\n     public Observable<List<T>> toSortedList(Func2<? super T, ? super T, Integer> sortFunction) {\n         return create(OperationToObservableSortedList.toSortedList(this, sortFunction));\n@@ -6329,7 +6329,7 @@ public Observable<T> lastOrDefault(T defaultValue, Func1<? super T, Boolean> pre\n      * \n      * @return an Observable that emits the number of items emitted by the\n      *         source Observable as its single, 64-bit long item \n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-Operators#count-and-longcount\">RxJava Wiki: count()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#count-and-longcount\">RxJava Wiki: count()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229120.aspx\">MSDN: Observable.LongCount</a>\n      * @see #count()\n      */\n@@ -7173,7 +7173,7 @@ public <TRight, TLeftDuration, TRightDuration, R> Observable<R> join(Observable<\n      *                    items to be used as keys in the HashMap\n      * @return an Observable that emits a single HashMap containing the mapped\n      *         items from the source Observable\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#tomap-and-tomultimap\">RxJava Wiki: toMap()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#tomap-and-tomultimap\">RxJava Wiki: toMap()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229137.aspx\">MSDN: Observable.ToDictionary</a>\n      */\n     public <K> Observable<Map<K, T>> toMap(Func1<? super T, ? extends K> keySelector) {\n@@ -7195,7 +7195,7 @@ public <K> Observable<Map<K, T>> toMap(Func1<? super T, ? extends K> keySelector\n      *                      items to be used as value in the HashMap\n      * @return an Observable that emits a single HashMap containing the mapped\n      *         items from the source Observable\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#tomap-and-tomultimap\">RxJava Wiki: toMap()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#tomap-and-tomultimap\">RxJava Wiki: toMap()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh212075.aspx\">MSDN: Observable.ToDictionary</a>\n      */\n     public <K, V> Observable<Map<K, V>> toMap(Func1<? super T, ? extends K> keySelector, Func1<? super T, ? extends V> valueSelector) {\n@@ -7216,7 +7216,7 @@ public <K, V> Observable<Map<K, V>> toMap(Func1<? super T, ? extends K> keySelec\n      * @param mapFactory the function that returns an Map instance to be used\n      * @return an Observable that emits a single Map containing the mapped\n      *         items emitted by the source Observable\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#tomap-and-tomultimap\">RxJava Wiki: toMap()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#tomap-and-tomultimap\">RxJava Wiki: toMap()</a>\n      */\n     public <K, V> Observable<Map<K, V>> toMap(Func1<? super T, ? extends K> keySelector, Func1<? super T, ? extends V> valueSelector, Func0<? extends Map<K, V>> mapFactory) {\n         return create(OperationToMap.toMap(this, keySelector, valueSelector, mapFactory));\n@@ -7233,7 +7233,7 @@ public <K, V> Observable<Map<K, V>> toMap(Func1<? super T, ? extends K> keySelec\n      *                    items to be used as key in the HashMap\n      * @return an Observable that emits a single HashMap containing an ArrayList\n      *         of items mapped from the source Observable\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#tomap-and-tomultimap\">RxJava Wiki: toMultiMap()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#tomap-and-tomultimap\">RxJava Wiki: toMap()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh212098.aspx\">MSDN: Observable.ToLookup</a>\n      */\n     public <K> Observable<Map<K, Collection<T>>> toMultimap(Func1<? super T, ? extends K> keySelector) {\n@@ -7254,7 +7254,7 @@ public <K> Observable<Map<K, Collection<T>>> toMultimap(Func1<? super T, ? exten\n      *                      items to be used as value in the Map\n      * @return an Observable that emits a single HashMap containing an ArrayList\n      *         of items mapped from the source Observable\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#tomap-and-tomultimap\">RxJava Wiki: toMultiMap()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#tomap-and-tomultimap\">RxJava Wiki: toMap()</a>\n      * @see <a href=\"http://msdn.microsoft.com/en-us/library/hh229101.aspx\">MSDN: Observable.ToLookup</a>\n      */\n     public <K, V> Observable<Map<K, Collection<V>>> toMultimap(Func1<? super T, ? extends K> keySelector, Func1<? super T, ? extends V> valueSelector) {\n@@ -7276,7 +7276,7 @@ public <K, V> Observable<Map<K, Collection<V>>> toMultimap(Func1<? super T, ? ex\n      * @param mapFactory the function that returns an Map instance to be used\n      * @return an Observable that emits a single Map containing the list of\n      *         mapped items from the source Observable.\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#tomap-and-tomultimap\">RxJava Wiki: toMultiMap()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#tomap-and-tomultimap\">RxJava Wiki: toMap()</a>\n      */\n     public <K, V> Observable<Map<K, Collection<V>>> toMultimap(Func1<? super T, ? extends K> keySelector, Func1<? super T, ? extends V> valueSelector, Func0<? extends Map<K, Collection<V>>> mapFactory) {\n         return create(OperationToMultimap.toMultimap(this, keySelector, valueSelector, mapFactory));\n@@ -7299,7 +7299,7 @@ public <K, V> Observable<Map<K, Collection<V>>> toMultimap(Func1<? super T, ? ex\n      *                          for a particular key to be used in the Map\n      * @return an Observable that emits a single Map containing the collection\n      *         of mapped items from the source Observable.\n-     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#tomap-and-tomultimap\">RxJava Wiki: toMultiMap()</a>\n+     * @see <a href=\"https://github.com/Netflix/RxJava/wiki/Mathematical-and-Aggregate-Operators#tomap-and-tomultimap\">RxJava Wiki: toMap()</a>\n      */\n     public <K, V> Observable<Map<K, Collection<V>>> toMultimap(Func1<? super T, ? extends K> keySelector, Func1<? super T, ? extends V> valueSelector, Func0<? extends Map<K, Collection<V>>> mapFactory, Func1<? super K, ? extends Collection<V>> collectionFactory) {\n         return create(OperationToMultimap.toMultimap(this, keySelector, valueSelector, mapFactory, collectionFactory));",
      "parent_sha": "c9e4c150e21b0f3d45ca3041c7a40c4ef209b30d"
    }
  },
  {
    "oid": "dcb5d79b833fe7169421c6fbdef483527037103d",
    "message": "Updated the comments",
    "date": "2013-10-25T06:00:13Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/dcb5d79b833fe7169421c6fbdef483527037103d",
    "details": {
      "sha": "15ba94120b9a504caf10a37012a07d582bf5bf80",
      "filename": "rxjava-core/src/main/java/rx/Observable.java",
      "status": "modified",
      "additions": 3,
      "deletions": 11,
      "changes": 14,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/dcb5d79b833fe7169421c6fbdef483527037103d/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/dcb5d79b833fe7169421c6fbdef483527037103d/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java?ref=dcb5d79b833fe7169421c6fbdef483527037103d",
      "patch": "@@ -1013,25 +1013,17 @@ public static <T> Observable<T> just(T value) {\n     }\n \n     /**\n-     * Returns an Observable that emits a single item and then completes in a specified scheduler.\n+     * Returns an Observable that emits a single item and then completes on a specified scheduler.\n      * <p>\n-     * <img width=\"640\" src=\"https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/just.png\">\n-     * <p>\n-     * To convert any object into an Observable that emits that object, pass that object into the\n-     * <code>just</code> method.\n-     * <p>\n-     * This is similar to the {@link #from(java.lang.Object[])} method, except that\n-     * <code>from()</code> will convert an {@link Iterable} object into an Observable that emits\n-     * each of the items in the Iterable, one at a time, while the <code>just()</code> method\n-     * converts an Iterable into an Observable that emits the entire Iterable as a single item.\n+     * This is a scheduler version of {@link Observable#just(Object)}.\n      *\n      * @param value\n      *            the item to pass to the {@link Observer}'s {@link Observer#onNext onNext} method\n      * @param scheduler\n      *            the scheduler to send the single element on\n      * @param <T>\n      *            the type of that item\n-     * @return an Observable that emits a single item and then completes\n+     * @return an Observable that emits a single item and then completes on a specified scheduler.\n      */\n     public static <T> Observable<T> just(T value, Scheduler scheduler) {\n         return just(value).observeOn(scheduler);",
      "parent_sha": "7ef16c9da4ace88b260cb908884b3df8a799490b"
    }
  },
  {
    "oid": "5f34896edacff5834f34c06cd6c81e35ddc96264",
    "message": "Tested unsubscription, too",
    "date": "2013-04-26T13:03:44Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/5f34896edacff5834f34c06cd6c81e35ddc96264",
    "details": {
      "sha": "3898dd1c3ff294b224f02bfa70af8da41b66926e",
      "filename": "rxjava-core/src/main/java/rx/Scheduler.java",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/5f34896edacff5834f34c06cd6c81e35ddc96264/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FScheduler.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/5f34896edacff5834f34c06cd6c81e35ddc96264/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FScheduler.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FScheduler.java?ref=5f34896edacff5834f34c06cd6c81e35ddc96264",
      "patch": "@@ -107,7 +107,7 @@ public <T> Subscription schedulePeriodically(T state, final Func2<Scheduler, T,\n         final Func2<Scheduler, T, Subscription> recursiveAction = new Func2<Scheduler, T, Subscription>() {\n             @Override\n             public Subscription call(Scheduler scheduler, T state0) {\n-                if (! complete.get()) {\n+                if (!complete.get()) {\n                     long startedAt = now();\n                     final Subscription sub1 = action.call(scheduler, state0);\n                     long timeTakenByActionInNanos = TimeUnit.MILLISECONDS.toNanos(now() - startedAt);\n@@ -343,7 +343,7 @@ public void testPeriodicScheduling() {\n             final Func1<Long, Void> calledOp = mock(Func1.class);\n             \n             final TestScheduler scheduler = new TestScheduler();\n-            scheduler.schedulePeriodically(new Action0() {\n+            Subscription subscription = scheduler.schedulePeriodically(new Action0() {\n                 @Override public void call() {\n                     System.out.println(scheduler.now());\n                     calledOp.call(scheduler.now());\n@@ -369,6 +369,10 @@ public void testPeriodicScheduling() {\n             scheduler.advanceTimeBy(5L, TimeUnit.SECONDS);\n             inOrder.verify(calledOp, times(1)).call(5000L);\n             inOrder.verify(calledOp, times(1)).call(7000L);\n+            \n+            subscription.unsubscribe();\n+            scheduler.advanceTimeBy(11L, TimeUnit.SECONDS);\n+            inOrder.verify(calledOp, never()).call(anyLong());\n         }\n     }\n }",
      "parent_sha": "a372ee899aa342ddfd7f50d82d8d56fcd8ce6e57"
    }
  },
  {
    "oid": "50e74ebb6c1db0b7ac79a06f403a193f39066989",
    "message": "Split error conditions into separate test lines.",
    "date": "2015-01-29T10:44:09Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/50e74ebb6c1db0b7ac79a06f403a193f39066989",
    "details": {
      "sha": "32a3e8f8ed5325d86dabff7200759278b2b4eab5",
      "filename": "src/test/java/rx/internal/operators/OperatorRetryTest.java",
      "status": "modified",
      "additions": 24,
      "deletions": 25,
      "changes": 49,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/50e74ebb6c1db0b7ac79a06f403a193f39066989/src%2Ftest%2Fjava%2Frx%2Finternal%2Foperators%2FOperatorRetryTest.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/50e74ebb6c1db0b7ac79a06f403a193f39066989/src%2Ftest%2Fjava%2Frx%2Finternal%2Foperators%2FOperatorRetryTest.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Ftest%2Fjava%2Frx%2Finternal%2Foperators%2FOperatorRetryTest.java?ref=50e74ebb6c1db0b7ac79a06f403a193f39066989",
      "patch": "@@ -15,33 +15,22 @@\n  */\n package rx.internal.operators;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.fail;\n+import static org.junit.Assert.*;\n import static org.mockito.Matchers.any;\n import static org.mockito.Mockito.*;\n \n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.concurrent.atomic.*;\n \n import org.junit.Test;\n-import org.mockito.InOrder;\n-import org.mockito.Mockito;\n+import org.mockito.*;\n \n-import rx.Observable;\n+import rx.*;\n import rx.Observable.OnSubscribe;\n+import rx.Observable;\n import rx.Observer;\n-import rx.Producer;\n-import rx.Subscriber;\n-import rx.Subscription;\n-import rx.functions.Action0;\n-import rx.functions.Action1;\n-import rx.functions.Func1;\n-import rx.functions.Func2;\n+import rx.functions.*;\n import rx.internal.util.RxRingBuffer;\n import rx.observables.GroupedObservable;\n import rx.observers.TestSubscriber;\n@@ -722,7 +711,10 @@ public void testRetryWithBackpressureParallel() throws InterruptedException {\n         int ncpu = Runtime.getRuntime().availableProcessors();\n         ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 1));\n         final AtomicInteger timeouts = new AtomicInteger();\n-        final AtomicInteger data = new AtomicInteger();\n+        final Map<Integer, List<String>> data = new ConcurrentHashMap<Integer, List<String>>();\n+        final Map<Integer, List<Throwable>> exceptions = new ConcurrentHashMap<Integer, List<Throwable>>();\n+        final Map<Integer, Integer> completions = new ConcurrentHashMap<Integer, Integer>();\n+        \n         int m = 2000;\n         final CountDownLatch cdl = new CountDownLatch(m);\n         for (int i = 0; i < m; i++) {\n@@ -737,13 +729,13 @@ public void run() {\n                         origin.retry().observeOn(Schedulers.computation()).unsafeSubscribe(ts);\n                         ts.awaitTerminalEvent(2, TimeUnit.SECONDS);\n                         if (ts.getOnNextEvents().size() != NUM_RETRIES + 2) {\n-                            data.incrementAndGet();\n+                            data.put(j, ts.getOnNextEvents());\n                         }\n                         if (ts.getOnErrorEvents().size() != 0) {\n-                            data.incrementAndGet();\n+                            exceptions.put(j, ts.getOnErrorEvents());\n                         }\n                         if (ts.getOnCompletedEvents().size() != 1) {\n-                            data.incrementAndGet();\n+                            completions.put(j, ts.getOnCompletedEvents().size());\n                         }\n                     } catch (Throwable t) {\n                         timeouts.incrementAndGet();\n@@ -756,8 +748,15 @@ public void run() {\n         exec.shutdown();\n         cdl.await();\n         assertEquals(0, timeouts.get());\n-        assertEquals(0, data.get());\n-\n+        if (data.size() > 0) {\n+            fail(\"Data content mismatch: \" + data);\n+        }\n+        if (exceptions.size() > 0) {\n+            fail(\"Exceptions received: \" + exceptions);\n+        }\n+        if (completions.size() > 0) {\n+            fail(\"Multiple completions received: \" + completions);\n+        }\n     }\n     @Test(timeout = 3000)\n     public void testIssue1900() throws InterruptedException {",
      "parent_sha": "6a557389a3625fdf29ad96c94f12ea74d275e1a9"
    }
  },
  {
    "oid": "bd2d5fef9693f7ac86fb72f70c24dae3ed6e60c8",
    "message": "add and improve javadoc in Subscriber",
    "date": "2015-07-01T04:40:54Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/bd2d5fef9693f7ac86fb72f70c24dae3ed6e60c8",
    "details": {
      "sha": "67ac611e4cb1895ee6044618d802c536225ecce2",
      "filename": "src/main/java/rx/Subscriber.java",
      "status": "modified",
      "additions": 30,
      "deletions": 6,
      "changes": 36,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/bd2d5fef9693f7ac86fb72f70c24dae3ed6e60c8/src%2Fmain%2Fjava%2Frx%2FSubscriber.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/bd2d5fef9693f7ac86fb72f70c24dae3ed6e60c8/src%2Fmain%2Fjava%2Frx%2FSubscriber.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Frx%2FSubscriber.java?ref=bd2d5fef9693f7ac86fb72f70c24dae3ed6e60c8",
      "patch": "@@ -46,20 +46,34 @@ protected Subscriber() {\n         this(null, false);\n     }\n \n+    /**\n+     * Construct a Subscriber by using another Subscriber for backpressure and\n+     * for holding the subscription list (when <code>this.add(sub)</code> is\n+     * called this will in fact call <code>subscriber.add(sub)</code>).\n+     * \n+     * @param subscriber\n+     *            the other Subscriber\n+     */\n     protected Subscriber(Subscriber<?> subscriber) {\n         this(subscriber, true);\n     }\n \n     /**\n-     * Construct a Subscriber by using another Subscriber for backpressure and optionally sharing the\n-     * underlying subscriptions list.\n+     * Construct a Subscriber by using another Subscriber for backpressure and\n+     * optionally for holding the subscription list (if\n+     * <code>shareSubscriptions</code> is <code>true</code> then when\n+     * <code>this.add(sub)</code> is called this will in fact call\n+     * <code>subscriber.add(sub)</code>).\n      * <p>\n-     * To retain the chaining of subscribers, add the created instance to {@code op} via {@link #add}.\n+     * To retain the chaining of subscribers when setting\n+     * <code>shareSubscriptions</code> to <code>false</code>, add the created\n+     * instance to {@code subscriber} via {@link #add}.\n      * \n      * @param subscriber\n      *            the other Subscriber\n      * @param shareSubscriptions\n-     *            {@code true} to share the subscription list in {@code op} with this instance\n+     *            {@code true} to share the subscription list in {@code subscriber} with\n+     *            this instance\n      * @since 1.0.6\n      */\n     protected Subscriber(Subscriber<?> subscriber, boolean shareSubscriptions) {\n@@ -158,9 +172,19 @@ private void addToRequested(long n) {\n     }\n     \n     /**\n-     * @warn javadoc description missing\n-     * @warn param producer not described\n+     * If other subscriber is set (by calling constructor\n+     * {@link #Subscriber(Subscriber)} or\n+     * {@link #Subscriber(Subscriber, boolean)}) then this method calls\n+     * <code>setProducer</code> on the other subscriber. If the other subscriber\n+     * is not set and no requests have been made to this subscriber then\n+     * <code>p.request(Long.MAX_VALUE)</code> is called. If the other subscriber\n+     * is not set and some requests have been made to this subscriber then\n+     * <code>p.request(n)</code> is called where n is the accumulated requests\n+     * to this subscriber.\n+     * \n      * @param p\n+     *            producer to be used by this subscriber or the other subscriber\n+     *            (or recursively its other subscriber) to make requests from\n      */\n     public void setProducer(Producer p) {\n         long toRequest;",
      "parent_sha": "9549363c76d9201da38df90d9150d76d4398ada8"
    }
  },
  {
    "oid": "da987ed17e9b0dae68d382ec04e616a55e6e4ce2",
    "message": "javadocs: minor style, grammar changes; add @since annotation to new method",
    "date": "2014-12-15T20:03:48Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/da987ed17e9b0dae68d382ec04e616a55e6e4ce2",
    "details": {
      "sha": "0fe84240ceb08d0959ee80743a7c0c1dcdff5a7b",
      "filename": "src/main/java/rx/subscriptions/Subscriptions.java",
      "status": "modified",
      "additions": 9,
      "deletions": 8,
      "changes": 17,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/da987ed17e9b0dae68d382ec04e616a55e6e4ce2/src%2Fmain%2Fjava%2Frx%2Fsubscriptions%2FSubscriptions.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/da987ed17e9b0dae68d382ec04e616a55e6e4ce2/src%2Fmain%2Fjava%2Frx%2Fsubscriptions%2FSubscriptions.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Frx%2Fsubscriptions%2FSubscriptions.java?ref=da987ed17e9b0dae68d382ec04e616a55e6e4ce2",
      "patch": "@@ -31,9 +31,9 @@ private Subscriptions() {\n         throw new IllegalStateException(\"No instances!\");\n     }\n     /**\n-     * Returns a {@link Subscription} that <code>unsubscribe</code> does nothing except changing\n-     * <code>isUnsubscribed</code> to true. It's stateful and <code>isUnsubscribed</code>\n-     * indicates if <code>unsubscribe</code> is called, which is different from {@link #unsubscribed()}.\n+     * Returns a {@link Subscription} to which {@code unsubscribe} does nothing except to change\n+     * {@code isUnsubscribed} to {@code true}. It's stateful and {@code isUnsubscribed} indicates if\n+     * {@code unsubscribe} is called, which is different from {@link #unsubscribed()}.\n      *\n      * <pre><code>\n      * Subscription empty = Subscriptions.empty();\n@@ -42,23 +42,24 @@ private Subscriptions() {\n      * System.out.println(empty.isUnsubscribed()); // true\n      * </code></pre>\n      *\n-     * @return a {@link Subscription} that <code>unsubscribe</code> does nothing except changing\n-     *         <code>isUnsubscribed</code> to true.\n+     * @return a {@link Subscription} to which {@code unsubscribe} does nothing except to change\n+     *         {@code isUnsubscribed} to {@code true}\n      */\n     public static Subscription empty() {\n         return BooleanSubscription.create();\n     }\n \n     /**\n-     * Returns a {@link Subscription} that <code>unsubscribe</code> does nothing but is already unsubscribed.\n-     * Its <code>isUnsubscribed</code> always return true, which is different from {@link #empty()}.\n+     * Returns a {@link Subscription} to which {@code unsubscribe} does nothing, as it is already unsubscribed.\n+     * Its {@code isUnsubscribed} always returns {@code true}, which is different from {@link #empty()}.\n      *\n      * <pre><code>\n      * Subscription unsubscribed = Subscriptions.unsubscribed();\n      * System.out.println(unsubscribed.isUnsubscribed()); // true\n      * </code></pre>\n      *\n-     * @return a {@link Subscription} that <code>unsubscribe</code> does nothing but is already unsubscribed.\n+     * @return a {@link Subscription} to which {@code unsubscribe} does nothing, as it is already unsubscribed\n+     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)\n      */\n     @Experimental\n     public static Subscription unsubscribed() {",
      "parent_sha": "1d487a31c38554a61d7d747bce28f5f1363adc07"
    }
  },
  {
    "oid": "bc0a089686b721149a962e6c409b8719a44872a4",
    "message": "made 'next' more typesafe",
    "date": "2013-03-25T18:41:24Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/bc0a089686b721149a962e6c409b8719a44872a4",
    "details": {
      "sha": "d3dc7f3c660e1c3a02d5c3036f543376fb883e9c",
      "filename": "rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/bc0a089686b721149a962e6c409b8719a44872a4/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationCombineLatest.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/bc0a089686b721149a962e6c409b8719a44872a4/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationCombineLatest.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationCombineLatest.java?ref=bc0a089686b721149a962e6c409b8719a44872a4",
      "patch": "@@ -94,7 +94,7 @@ public void onError(Exception e) {\n         }\n \n         @Override\n-        public void onNext(Object args) {\n+        public void onNext(T args) {\n             a.next(this, args);\n         }\n     }\n@@ -185,7 +185,7 @@ synchronized void error(CombineObserver<R, ?> w, Exception e) {\n          * @param w\n          * @param arg\n          */\n-        void next(CombineObserver<R, ?> w, Object arg) {\n+        <T> void next(CombineObserver<R, T> w, T arg) {\n             if (Observer == null) {\n                 throw new RuntimeException(\"This shouldn't be running if a Observer isn't registered\");\n             }\n@@ -485,7 +485,7 @@ public void testAggregateMultipleTypes() {\n \n             /* mock the Observable Observers that are 'pushing' data for us */\n             CombineObserver<String, String> r1 = mock(CombineObserver.class);\n-            CombineObserver<String, Integer> r2 = mock(CombineObserver.class);\n+            CombineObserver<String, String> r2 = mock(CombineObserver.class);\n \n             /* pretend we're starting up */\n             a.addObserver(r1);",
      "parent_sha": "72d9872fffa2b8f6d534612436b1613ed062e026"
    }
  },
  {
    "oid": "ce45fc2eec103af5876723b167fb660da6af3a58",
    "message": "Fix missing nullability on Single.subscribe(BiConsumer) (#7331)",
    "date": "2021-09-06T08:17:47Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/ce45fc2eec103af5876723b167fb660da6af3a58",
    "details": {
      "sha": "ea6a610febe4e4a9a6085d456934cf17d6857c20",
      "filename": "src/main/java/io/reactivex/rxjava3/core/Single.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/ce45fc2eec103af5876723b167fb660da6af3a58/src%2Fmain%2Fjava%2Fio%2Freactivex%2Frxjava3%2Fcore%2FSingle.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/ce45fc2eec103af5876723b167fb660da6af3a58/src%2Fmain%2Fjava%2Fio%2Freactivex%2Frxjava3%2Fcore%2FSingle.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Fio%2Freactivex%2Frxjava3%2Fcore%2FSingle.java?ref=ce45fc2eec103af5876723b167fb660da6af3a58",
      "patch": "@@ -4735,7 +4735,7 @@ public final Disposable subscribe() {\n     @CheckReturnValue\n     @NonNull\n     @SchedulerSupport(SchedulerSupport.NONE)\n-    public final Disposable subscribe(@NonNull BiConsumer<? super T, ? super Throwable> onCallback) {\n+    public final Disposable subscribe(@NonNull BiConsumer<@Nullable ? super T, @Nullable ? super Throwable> onCallback) {\n         Objects.requireNonNull(onCallback, \"onCallback is null\");\n \n         BiConsumerSingleObserver<T> observer = new BiConsumerSingleObserver<>(onCallback);",
      "parent_sha": "b4769141435295fea36449998cffe6730ef24b56"
    }
  },
  {
    "oid": "d6e78d5ee5dc6c89910f945fac2907bec1b26946",
    "message": "Fixed NullPointerException that may happen on timeout",
    "date": "2014-02-19T13:22:41Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/d6e78d5ee5dc6c89910f945fac2907bec1b26946",
    "details": {
      "sha": "24671e7051042c3aec232d6f65d5e97488f95656",
      "filename": "rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseConsumerDelegate.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/d6e78d5ee5dc6c89910f945fac2907bec1b26946/rxjava-contrib%2Frxjava-apache-http%2Fsrc%2Fmain%2Fjava%2Frx%2Fapache%2Fhttp%2Fconsumers%2FResponseConsumerDelegate.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/d6e78d5ee5dc6c89910f945fac2907bec1b26946/rxjava-contrib%2Frxjava-apache-http%2Fsrc%2Fmain%2Fjava%2Frx%2Fapache%2Fhttp%2Fconsumers%2FResponseConsumerDelegate.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-contrib%2Frxjava-apache-http%2Fsrc%2Fmain%2Fjava%2Frx%2Fapache%2Fhttp%2Fconsumers%2FResponseConsumerDelegate.java?ref=d6e78d5ee5dc6c89910f945fac2907bec1b26946",
      "patch": "@@ -93,7 +93,9 @@ protected HttpResponse buildResult(HttpContext context) throws Exception {\n \n     @Override\n     protected void releaseResources() {\n-        consumer._releaseResources();\n+        if (consumer != null) {\n+            consumer._releaseResources();\n+        }\n     }\n \n }",
      "parent_sha": "1ac89df01dc2f02e13411503f9f24f0306956366"
    }
  },
  {
    "oid": "3ce5034658d9a8b4cf21b351055596c0e014dd6f",
    "message": "Copying javadoc enhancements for CompositException from 0.20",
    "date": "2014-08-28T17:08:57Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/3ce5034658d9a8b4cf21b351055596c0e014dd6f",
    "details": {
      "sha": "5b388477a1328de5b042172c3a2b1d34d2a33110",
      "filename": "rxjava/src/main/java/rx/exceptions/CompositeException.java",
      "status": "modified",
      "additions": 19,
      "deletions": 18,
      "changes": 37,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/3ce5034658d9a8b4cf21b351055596c0e014dd6f/rxjava%2Fsrc%2Fmain%2Fjava%2Frx%2Fexceptions%2FCompositeException.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/3ce5034658d9a8b4cf21b351055596c0e014dd6f/rxjava%2Fsrc%2Fmain%2Fjava%2Frx%2Fexceptions%2FCompositeException.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava%2Fsrc%2Fmain%2Fjava%2Frx%2Fexceptions%2FCompositeException.java?ref=3ce5034658d9a8b4cf21b351055596c0e014dd6f",
      "patch": "@@ -26,18 +26,18 @@\n import java.util.Set;\n \n /**\n- * Exception that is a composite of 1 or more other exceptions.\n- * A CompositeException does not modify the structure of any exception it wraps, but at print-time\n- * iterates through the list of contained Throwables to print them all.\n+ * An Exception that is a composite of one or more other Exceptions. A {@code CompositeException} does not\n+ * modify the structure of any exception it wraps, but at print-time it iterates through the list of\n+ * Throwables contained in the composit in order to print them all.\n  *\n- * Its invariant is to contains an immutable, ordered (by insertion order), unique list of non-composite exceptions.\n- * This list may be queried by {@code #getExceptions()}\n+ * Its invariant is to contain an immutable, ordered (by insertion order), unique list of non-composite\n+ * exceptions. You can retrieve individual exceptions in this list with {@link #getExceptions()}.\n  * \n- * The `printStackTrace()` implementation does custom handling of the StackTrace instead of using `getCause()` so it\n- * can avoid circular references.\n+ * The {@link #printStackTrace()} implementation handles the StackTrace in a customized way instead of using\n+ * {@code getCause()} so that it can avoid circular references.\n  * \n- * If `getCause()` is invoked, it will lazily create the causal chain but stop if it finds any Throwable in the chain\n- * that it has already seen.\n+ * If you invoke {@link #getCause()}, it will lazily create the causal chain but will stop if it finds any\n+ * Throwable in the chain that it has already seen.\n  */\n public final class CompositeException extends RuntimeException {\n \n@@ -124,13 +124,14 @@ public synchronized Throwable getCause() {\n     }\n \n     /**\n-     * All of the following printStackTrace functionality is derived from JDK Throwable printStackTrace.\n-     * In particular, the PrintStreamOrWriter abstraction is copied wholesale.\n+     * All of the following {@code printStackTrace} functionality is derived from JDK {@link Throwable}\n+     * {@code printStackTrace}. In particular, the {@code PrintStreamOrWriter} abstraction is copied wholesale.\n      *\n-     * Changes from the official JDK implementation:\n-     * * No infinite loop detection\n-     * * Smaller critical section holding printStream lock\n-     * * Explicit knowledge about exceptions List that this loops through\n+     * Changes from the official JDK implementation:<ul>\n+     * <li>no infinite loop detection</li>\n+     * <li>smaller critical section holding {@link PrintStream} lock</li>\n+     * <li>explicit knowledge about the exceptions {@link List} that this loops through</li>\n+     * </ul>\n      */\n     @Override\n     public void printStackTrace() {\n@@ -148,8 +149,8 @@ public void printStackTrace(PrintWriter s) {\n     }\n \n     /**\n-     * Special handling for printing out a CompositeException\n-     * Loop through all inner exceptions and print them out\n+     * Special handling for printing out a {@code CompositeException}.\n+     * Loops through all inner exceptions and prints them out.\n      * \n      * @param s\n      *            stream to print to\n@@ -251,4 +252,4 @@ private final List<Throwable> getListOfCauses(Throwable ex) {\n             }\n         }\n     }\n-}\n\\ No newline at end of file\n+}",
      "parent_sha": "5d8c8f92d83ceef4dea3eedae15211a4f2a8df5a"
    }
  },
  {
    "oid": "be7d6a704fab29418c3eeda6d5b1a1f2b852d753",
    "message": "Implemented GetIterator operation",
    "date": "2013-03-04T21:06:44Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/be7d6a704fab29418c3eeda6d5b1a1f2b852d753",
    "details": {
      "sha": "95399b87c008d0f2af05b0df175143f338a37d20",
      "filename": "rxjava-core/src/main/java/rx/Observable.java",
      "status": "modified",
      "additions": 27,
      "deletions": 8,
      "changes": 35,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/be7d6a704fab29418c3eeda6d5b1a1f2b852d753/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/be7d6a704fab29418c3eeda6d5b1a1f2b852d753/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2FObservable.java?ref=be7d6a704fab29418c3eeda6d5b1a1f2b852d753",
      "patch": "@@ -1645,6 +1645,23 @@ public static <T> Observable<List<T>> toList(final Observable<T> that) {\n      * @return Observable converted to Iterable.\n      */\n     public static <T> Iterable<T> toIterable(final Observable<T> that) {\n+\n+        return new Iterable<T>() {\n+            @Override\n+            public Iterator<T> iterator() {\n+                return getIterator(that);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Returns an iterator that iterates all values of the observable.\n+     *\n+     * @param that an observable sequence to get an iterator for.\n+     * @param <T> the type of source.\n+     * @return the iterator that could be used to iterate over the elements of the observable.\n+     */\n+    public static <T> Iterator<T> getIterator(Observable<T> that) {\n         final BlockingQueue<Notification<T>> notifications = new LinkedBlockingQueue<Notification<T>>();\n \n         materialize(that).subscribe(new Observer<Notification<T>>() {\n@@ -1664,7 +1681,7 @@ public void onNext(Notification<T> args) {\n             }\n         });\n \n-        final Iterator<T> it = new Iterator<T>() {\n+        return new Iterator<T>() {\n             private Notification<T> buf;\n \n             @Override\n@@ -1702,13 +1719,6 @@ public void remove() {\n                 throw new UnsupportedOperationException(\"Read-only iterator\");\n             }\n         };\n-\n-        return new Iterable<T>() {\n-            @Override\n-            public Iterator<T> iterator() {\n-                return it;\n-            }\n-        };\n     }\n \n     /**\n@@ -2904,6 +2914,15 @@ public Iterable<T> toIterable() {\n         return toIterable(this);\n     }\n \n+    /**\n+     * Returns an iterator that iterates all values of the observable.\n+     *\n+     * @return the iterator that could be used to iterate over the elements of the observable.\n+     */\n+    public Iterator<T> getIterator() {\n+        return getIterator(this);\n+    }\n+\n     /**\n      * Samples the next value (blocking without buffering) from in an observable sequence.\n      *",
      "parent_sha": "c87d120cb53d4ad84f196d54ae0ae4ef328ee8aa"
    }
  },
  {
    "oid": "2a08d800b11e0856a8cec7980660bb54ca5c408f",
    "message": "Make the chunk_test.clj work again for now",
    "date": "2014-05-23T22:03:42Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/2a08d800b11e0856a8cec7980660bb54ca5c408f",
    "details": {
      "sha": "20f2a31071a0d7a2766ca2a77cda7cc6df90c557",
      "filename": "rxjava-core/src/main/java/rx/operators/OperatorMerge.java",
      "status": "modified",
      "additions": 13,
      "deletions": 8,
      "changes": 21,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/2a08d800b11e0856a8cec7980660bb54ca5c408f/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperatorMerge.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/2a08d800b11e0856a8cec7980660bb54ca5c408f/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperatorMerge.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperatorMerge.java?ref=2a08d800b11e0856a8cec7980660bb54ca5c408f",
      "patch": "@@ -49,6 +49,7 @@ static final class MergeSubscriber<T> extends Subscriber<Observable<? extends T>\n         final Subscriber<T> actual;\n         final CompositeSubscription childrenSubscriptions;\n         volatile int wip;\n+        volatile boolean completed;\n         @SuppressWarnings(\"rawtypes\")\n         static final AtomicIntegerFieldUpdater<MergeSubscriber> WIP_UPDATER\n                 = AtomicIntegerFieldUpdater.newUpdater(MergeSubscriber.class, \"wip\");\n@@ -57,7 +58,6 @@ public MergeSubscriber(Subscriber<T> actual, CompositeSubscription childrenSubsc\n             super(actual);\n             this.actual = actual;\n             this.childrenSubscriptions = childrenSubscriptions;\n-            this.wip = 1;\n         }\n \n         @Override\n@@ -76,11 +76,20 @@ public void onError(Throwable e) {\n \n         @Override\n         public void onCompleted() {\n-            if (WIP_UPDATER.decrementAndGet(this) == 0) {\n+            completed = true;\n+            if (wip == 0) {\n                 actual.onCompleted();\n             }\n         }\n-        \n+        void completeInner(InnerSubscriber<T> s) {\n+            try {\n+                if (WIP_UPDATER.decrementAndGet(this) == 0 && completed) {\n+                    actual.onCompleted();\n+                }\n+            } finally {\n+                childrenSubscriptions.remove(s);\n+            }\n+        }\n     }\n     static final class InnerSubscriber<T> extends Subscriber<T> {\n         final Subscriber<? super T> actual;\n@@ -110,11 +119,7 @@ public void onError(Throwable e) {\n         @Override\n         public void onCompleted() {\n             if (ONCE_UPDATER.compareAndSet(this, 0, 1)) {\n-                try {\n-                    parent.onCompleted();\n-                } finally {\n-                    parent.childrenSubscriptions.remove(this);\n-                }\n+                parent.completeInner(this);\n             }\n         }\n         ",
      "parent_sha": "ccbd4832f3b3c5616d0fcf83be605c10f6dac6d9"
    }
  },
  {
    "oid": "5b8845d4cfdbc2d563b90ce27db978b7e383d9e0",
    "message": "Avoid potential NPE when onError throws. (#4398)\n\nt2 was only initialized if canceling threw an exception. In the happy path it would have never been initialized so when onError threw the call to suppress() would NPE.",
    "date": "2016-08-22T07:00:34Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/5b8845d4cfdbc2d563b90ce27db978b7e383d9e0",
    "details": {
      "sha": "d55d76ba877f19b4e05deb815486acab5aa1b1d6",
      "filename": "src/main/java/io/reactivex/subscribers/SafeSubscriber.java",
      "status": "modified",
      "additions": 5,
      "deletions": 2,
      "changes": 7,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/5b8845d4cfdbc2d563b90ce27db978b7e383d9e0/src%2Fmain%2Fjava%2Fio%2Freactivex%2Fsubscribers%2FSafeSubscriber.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/5b8845d4cfdbc2d563b90ce27db978b7e383d9e0/src%2Fmain%2Fjava%2Fio%2Freactivex%2Fsubscribers%2FSafeSubscriber.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Fio%2Freactivex%2Fsubscribers%2FSafeSubscriber.java?ref=5b8845d4cfdbc2d563b90ce27db978b7e383d9e0",
      "patch": "@@ -154,8 +154,11 @@ public void onError(Throwable t) {\n             }\n         } catch (Throwable e) {\n             Exceptions.throwIfFatal(e);\n-            t2.suppress(e);\n-            \n+            if (t2 == null) {\n+                t2 = new CompositeException(t, e);\n+            } else {\n+                t2.suppress(e);\n+            }\n             RxJavaPlugins.onError(t2);\n         }\n     }",
      "parent_sha": "e1cec337e0778adbc75efe6c226242cb7df62d61"
    }
  },
  {
    "oid": "0f2cd15d6fa93bdbc337f2f2c235d56df168105d",
    "message": "Fix typo\n\nas per https://github.com/Netflix/RxJava/issues/1266",
    "date": "2014-07-24T07:28:27Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/0f2cd15d6fa93bdbc337f2f2c235d56df168105d",
    "details": {
      "sha": "77e1dd504857abd34dce67c1f8e9cdda7b1bfb41",
      "filename": "rxjava-core/src/main/java/rx/plugins/RxJavaObservableExecutionHook.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/0f2cd15d6fa93bdbc337f2f2c235d56df168105d/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fplugins%2FRxJavaObservableExecutionHook.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/0f2cd15d6fa93bdbc337f2f2c235d56df168105d/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fplugins%2FRxJavaObservableExecutionHook.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Fplugins%2FRxJavaObservableExecutionHook.java?ref=0f2cd15d6fa93bdbc337f2f2c235d56df168105d",
      "patch": "@@ -66,7 +66,7 @@ public <T> OnSubscribe<T> onCreate(OnSubscribe<T> f) {\n      * @return {@link OnSubscribe}<{@code T}> function that can be modified, decorated, replaced or just\n      *         returned as a pass-thru\n      */\n-    public <T> OnSubscribe<T> onSubscribeStart(Observable<? extends T> observableInsance, final OnSubscribe<T> onSubscribe) {\n+    public <T> OnSubscribe<T> onSubscribeStart(Observable<? extends T> observableInstance, final OnSubscribe<T> onSubscribe) {\n         // pass-thru by default\n         return onSubscribe;\n     }",
      "parent_sha": "73b751846bc9c3b81353c90a6540aa8f9e9f496e"
    }
  },
  {
    "oid": "021a3f45cac5c440d4662608989d93e5d626f198",
    "message": "collect: javac is unable to select the right overload for some reason",
    "date": "2015-08-28T14:21:44Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/021a3f45cac5c440d4662608989d93e5d626f198",
    "details": {
      "sha": "eab3e77294aa09f72ba17f9511a43372dde69430",
      "filename": "src/main/java/io/reactivex/Observable.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/021a3f45cac5c440d4662608989d93e5d626f198/src%2Fmain%2Fjava%2Fio%2Freactivex%2FObservable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/021a3f45cac5c440d4662608989d93e5d626f198/src%2Fmain%2Fjava%2Fio%2Freactivex%2FObservable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Fio%2Freactivex%2FObservable.java?ref=021a3f45cac5c440d4662608989d93e5d626f198",
      "patch": "@@ -1262,7 +1262,7 @@ public final Observable<T> repeat(long times, Scheduler scheduler) {\n         return repeat(times).subscribeOn(scheduler);\n     }\n \n-    public final <U> Observable<U> collect(U initialValue, BiConsumer<? super U, ? super T> collector) {\n+    public final <U> Observable<U> collectInto(U initialValue, BiConsumer<? super U, ? super T> collector) {\n         return collect(() -> initialValue, collector);\n     }\n ",
      "parent_sha": "79a688eae5f8aa7e764fe3f4347368a6baa210df"
    }
  },
  {
    "oid": "0cc4ff2f8f7bea2a9b5d274a73770f078d0641bc",
    "message": "Improve asObservable() javadoc description (#1853)",
    "date": "2014-11-10T21:10:55Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/0cc4ff2f8f7bea2a9b5d274a73770f078d0641bc",
    "details": {
      "sha": "78f9cdb9ffc23a92ec836ab9e0caae6a62c0a0a4",
      "filename": "src/main/java/rx/Observable.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/0cc4ff2f8f7bea2a9b5d274a73770f078d0641bc/src%2Fmain%2Fjava%2Frx%2FObservable.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/0cc4ff2f8f7bea2a9b5d274a73770f078d0641bc/src%2Fmain%2Fjava%2Frx%2FObservable.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Frx%2FObservable.java?ref=0cc4ff2f8f7bea2a9b5d274a73770f078d0641bc",
      "patch": "@@ -3068,9 +3068,9 @@ public final Observable<T> ambWith(Observable<? extends T> t1) {\n     }\n \n     /**\n-     * Disguises a object of an Observable subclass as a simple Observable object. Useful for instance when you\n-     * have an implementation of a subclass of Observable but you want to hide the properties and methods of\n-     * this subclass from whomever you are passing the Observable to.\n+     * Portrays a object of an Observable subclass as a simple Observable object. This is useful, for instance,\n+     * when you have an implementation of a subclass of Observable but you want to hide the properties and\n+     * methods of this subclass from whomever you are passing the Observable to.\n      * <dl>\n      *  <dt><b>Scheduler:</b></dt>\n      *  <dd>{@code asObservable} does not operate by default on a particular {@link Scheduler}.</dd>",
      "parent_sha": "1dfcbf6450389df957aac4bd8bf979f1ace50c3c"
    }
  },
  {
    "oid": "b50a6647f923f9826dcabe2d3243098cc7207f34",
    "message": "Rename concat test",
    "date": "2014-04-23T15:00:27Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/b50a6647f923f9826dcabe2d3243098cc7207f34",
    "details": {
      "sha": "122610bbacb095f07f46982e141c5b17d737d403",
      "filename": "rxjava-core/src/test/java/rx/operators/OperatorConcatTest.java",
      "status": "renamed",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/b50a6647f923f9826dcabe2d3243098cc7207f34/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Foperators%2FOperatorConcatTest.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/b50a6647f923f9826dcabe2d3243098cc7207f34/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Foperators%2FOperatorConcatTest.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Foperators%2FOperatorConcatTest.java?ref=b50a6647f923f9826dcabe2d3243098cc7207f34",
      "patch": "@@ -43,7 +43,7 @@\n import rx.subscriptions.BooleanSubscription;\n import rx.subscriptions.Subscriptions;\n \n-public class OperationConcatTest {\n+public class OperatorConcatTest {\n \n     @Test\n     public void testConcat() {",
      "previous_filename": "rxjava-core/src/test/java/rx/operators/OperationConcatTest.java",
      "parent_sha": "a8c1e3c8ee14b612bfc086ee9cad2c78151837af"
    }
  },
  {
    "oid": "83d1a4f4eb66fbf6e2afd6045f96e31ced6aedfc",
    "message": "Remove @NonNull annotations in BiConsumer (#5257)",
    "date": "2017-04-02T08:46:55Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/83d1a4f4eb66fbf6e2afd6045f96e31ced6aedfc",
    "details": {
      "sha": "6b147ae0b02927efcfc3a8b561560adf3c212e06",
      "filename": "src/main/java/io/reactivex/functions/BiConsumer.java",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/83d1a4f4eb66fbf6e2afd6045f96e31ced6aedfc/src%2Fmain%2Fjava%2Fio%2Freactivex%2Ffunctions%2FBiConsumer.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/83d1a4f4eb66fbf6e2afd6045f96e31ced6aedfc/src%2Fmain%2Fjava%2Fio%2Freactivex%2Ffunctions%2FBiConsumer.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Fmain%2Fjava%2Fio%2Freactivex%2Ffunctions%2FBiConsumer.java?ref=83d1a4f4eb66fbf6e2afd6045f96e31ced6aedfc",
      "patch": "@@ -13,8 +13,6 @@\n \n package io.reactivex.functions;\n \n-import io.reactivex.annotations.NonNull;\n-\n /**\n  * A functional interface (callback) that accepts two values (of possibly different types).\n  * @param <T1> the first value type\n@@ -28,5 +26,5 @@ public interface BiConsumer<T1, T2> {\n      * @param t2 the second value\n      * @throws Exception on error\n      */\n-    void accept(@NonNull T1 t1, @NonNull T2 t2) throws Exception;\n+    void accept(T1 t1, T2 t2) throws Exception;\n }",
      "parent_sha": "fa58d36375ecc084b21bca299ca4780946b15dc5"
    }
  },
  {
    "oid": "35f2b2fa128cb9444dddaa00ddd994ee087901b2",
    "message": "Fixing UnitTest",
    "date": "2013-04-16T16:14:10Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/35f2b2fa128cb9444dddaa00ddd994ee087901b2",
    "details": {
      "sha": "4f94cda6d588f201bebf4e3bafe0a062fc2b4b7c",
      "filename": "rxjava-core/src/main/java/rx/operators/OperationObserveOn.java",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/35f2b2fa128cb9444dddaa00ddd994ee087901b2/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationObserveOn.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/35f2b2fa128cb9444dddaa00ddd994ee087901b2/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationObserveOn.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationObserveOn.java?ref=35f2b2fa128cb9444dddaa00ddd994ee087901b2",
      "patch": "@@ -69,14 +69,17 @@ public void testObserveOn() {\n \n         @Test\n         @SuppressWarnings(\"unchecked\")\n-        public void testOrdering() {\n+        public void testOrdering() throws InterruptedException {\n             Observable<String> obs = Observable.from(\"one\", null, \"two\", \"three\", \"four\");\n \n             Observer<String> observer = mock(Observer.class);\n \n             InOrder inOrder = inOrder(observer);\n \n             obs.observeOn(Schedulers.threadPoolForComputation()).subscribe(observer);\n+\n+            Thread.sleep(500); // !!! not a true unit test\n+\n             inOrder.verify(observer, times(1)).onNext(\"one\");\n             inOrder.verify(observer, times(1)).onNext(null);\n             inOrder.verify(observer, times(1)).onNext(\"two\");",
      "parent_sha": "429611e1dd7a661b9c4a6f125a16af73f8992844"
    }
  },
  {
    "oid": "ffed4300a7f7ca56f5cc3fd1b5986e4f6d121cb3",
    "message": "More Parallal Unit Tests\n\n- stressing it further while hunting down non-determism",
    "date": "2014-02-11T07:41:43Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/ffed4300a7f7ca56f5cc3fd1b5986e4f6d121cb3",
    "details": {
      "sha": "c8a114ba82b1173e3cd31d31f1698dae81b8ecac",
      "filename": "rxjava-core/src/test/java/rx/operators/OperatorParallelTest.java",
      "status": "modified",
      "additions": 51,
      "deletions": 3,
      "changes": 54,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/ffed4300a7f7ca56f5cc3fd1b5986e4f6d121cb3/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Foperators%2FOperatorParallelTest.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/ffed4300a7f7ca56f5cc3fd1b5986e4f6d121cb3/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Foperators%2FOperatorParallelTest.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Foperators%2FOperatorParallelTest.java?ref=ffed4300a7f7ca56f5cc3fd1b5986e4f6d121cb3",
      "patch": "@@ -17,6 +17,7 @@\n \n import static org.junit.Assert.*;\n \n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.junit.Test;\n@@ -31,6 +32,7 @@ public class OperatorParallelTest {\n     public void testParallel() {\n         int NUM = 1000;\n         final AtomicInteger count = new AtomicInteger();\n+        final AtomicInteger innerCount = new AtomicInteger();\n         Observable.range(1, NUM).parallel(\n                 new Func1<Observable<Integer>, Observable<Integer[]>>() {\n \n@@ -40,17 +42,63 @@ public Observable<Integer[]> call(Observable<Integer> o) {\n \n                             @Override\n                             public Integer[] call(Integer t) {\n+                                try {\n+                                    // randomize to try and force non-determinism\n+                                    // if we see these tests fail randomly then we have a problem with merging it all back together\n+                                    Thread.sleep((int) (Math.random() * 10));\n+                                } catch (InterruptedException e) {\n+                                    System.out.println(\"*********** error!!!!!!!\");\n+                                    e.printStackTrace();\n+                                    // TODO why is this exception not being thrown?\n+                                    throw new RuntimeException(e);\n+                                }\n+                                //                                System.out.println(\"V: \" + t  + \" Thread: \" + Thread.currentThread());\n+                                innerCount.incrementAndGet();\n                                 return new Integer[] { t, t * 99 };\n                             }\n \n                         });\n                     }\n-                }).toBlockingObservable().forEach(new Action1<Integer[]>() {\n+                })\n+                .toBlockingObservable().forEach(new Action1<Integer[]>() {\n+\n+                    @Override\n+                    public void call(Integer[] v) {\n+                        count.incrementAndGet();\n+                        //                System.out.println(\"V: \" + v[0] + \" R: \" + v[1] + \" Thread: \" + Thread.currentThread());\n+                    }\n+\n+                });\n+        System.out.println(\"parallel test completed ----------\");\n+\n+        // just making sure we finish and get the number we expect\n+        assertEquals(\"innerCount\", NUM, innerCount.get());\n+        assertEquals(\"finalCount\", NUM, count.get());\n+    }\n+\n+    @Test\n+    public void testParallelWithNestedAsyncWork() {\n+        int NUM = 20;\n+        final AtomicInteger count = new AtomicInteger();\n+        Observable.range(1, NUM).parallel(\n+                new Func1<Observable<Integer>, Observable<String>>() {\n+\n+                    @Override\n+                    public Observable<String> call(Observable<Integer> o) {\n+                        return o.flatMap(new Func1<Integer, Observable<String>>() {\n+\n+                            @Override\n+                            public Observable<String> call(Integer t) {\n+                                return Observable.from(String.valueOf(t)).delay(100, TimeUnit.MILLISECONDS);\n+                            }\n+\n+                        });\n+                    }\n+                }).toBlockingObservable().forEach(new Action1<String>() {\n \n             @Override\n-            public void call(Integer[] v) {\n+            public void call(String v) {\n                 count.incrementAndGet();\n-                System.out.println(\"V: \" + v[0] + \" R: \" + v[1] + \" Thread: \" + Thread.currentThread());\n             }\n \n         });",
      "parent_sha": "290b3afc5eaab659ab701acfeda4c1e5fc53f960"
    }
  },
  {
    "oid": "df7bf90803a686946e09d9ec175f8ab85277e989",
    "message": "GroupBy Test Improvement\n\nObserveOn was the wrong mechanism for delaying behavior as it was relying on the buffering of observeOn.\nNow using delay() to delay the group since observeOn no longer buffers.",
    "date": "2014-02-08T22:23:22Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/df7bf90803a686946e09d9ec175f8ab85277e989",
    "details": {
      "sha": "92b085ea0fd57025e56453f3d5fa8bcc1f4d7f93",
      "filename": "rxjava-core/src/test/java/rx/operators/OperatorGroupByTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 7,
      "changes": 9,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/df7bf90803a686946e09d9ec175f8ab85277e989/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Foperators%2FOperatorGroupByTest.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/df7bf90803a686946e09d9ec175f8ab85277e989/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Foperators%2FOperatorGroupByTest.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Ftest%2Fjava%2Frx%2Foperators%2FOperatorGroupByTest.java?ref=df7bf90803a686946e09d9ec175f8ab85277e989",
      "patch": "@@ -484,21 +484,16 @@ public Integer call(Integer i) {\n                     @Override\n                     public Observable<Integer> call(GroupedObservable<Integer, Integer> group) {\n                         if (group.getKey() == 0) {\n-                            return group.observeOn(Schedulers.newThread()).map(new Func1<Integer, Integer>() {\n+                            return group.delay(100, TimeUnit.MILLISECONDS).map(new Func1<Integer, Integer>() {\n \n                                 @Override\n                                 public Integer call(Integer t) {\n-                                    try {\n-                                        Thread.sleep(2);\n-                                    } catch (InterruptedException e) {\n-                                        e.printStackTrace();\n-                                    }\n                                     return t * 10;\n                                 }\n \n                             });\n                         } else {\n-                            return group.observeOn(Schedulers.newThread());\n+                            return group;\n                         }\n                     }\n                 })",
      "parent_sha": "ac83ed9b44d2e1ad7f066bd794b4c676c5a86adf"
    }
  },
  {
    "oid": "09c3b624955a8fded421a2ee325ef9021296f405",
    "message": "Adding ScheduledSubscription to parent in order to properly chain unsubscribe.\n\nSigned-off-by: David Marques <dpsmarques@gmail.com>",
    "date": "2014-06-05T13:52:36Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/09c3b624955a8fded421a2ee325ef9021296f405",
    "details": {
      "sha": "fec2eb80df5b8fa4c4e161cf6eab81fea4bbae2f",
      "filename": "rxjava-contrib/rxjava-android/src/main/java/rx/android/schedulers/HandlerThreadScheduler.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/09c3b624955a8fded421a2ee325ef9021296f405/rxjava-contrib%2Frxjava-android%2Fsrc%2Fmain%2Fjava%2Frx%2Fandroid%2Fschedulers%2FHandlerThreadScheduler.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/09c3b624955a8fded421a2ee325ef9021296f405/rxjava-contrib%2Frxjava-android%2Fsrc%2Fmain%2Fjava%2Frx%2Fandroid%2Fschedulers%2FHandlerThreadScheduler.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-contrib%2Frxjava-android%2Fsrc%2Fmain%2Fjava%2Frx%2Fandroid%2Fschedulers%2FHandlerThreadScheduler.java?ref=09c3b624955a8fded421a2ee325ef9021296f405",
      "patch": "@@ -72,13 +72,14 @@ public boolean isUnsubscribed() {\n         @Override\n         public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit) {\n             final ScheduledAction scheduledAction = new ScheduledAction(action);\n-            scheduledAction.addParent(mCompositeSubscription);\n             scheduledAction.add(Subscriptions.create(new Action0() {\n                 @Override\n                 public void call() {\n                     handler.removeCallbacks(scheduledAction);\n                 }\n             }));\n+            scheduledAction.addParent(mCompositeSubscription);\n+            mCompositeSubscription.add(scheduledAction);\n \n             handler.postDelayed(scheduledAction, unit.toMillis(delayTime));\n \n@@ -91,5 +92,4 @@ public Subscription schedule(final Action0 action) {\n         }\n \n     }\n-\n }",
      "parent_sha": "00459308557548fbd05f386048515d255ac53781"
    }
  },
  {
    "oid": "5b5aade918ea3d9cbc4aa993a23a21c1b3beda2f",
    "message": "Make Materialize.testMultipleSubscribes test deterministic\n\nRefactored to use BlockingObservable instead of non-blocking subscribe and waiting on the underlying thread (it was only waiting on one of two threads running).\nThis should resolve one of the issues reported in http://github.com/Netflix/RxJava/issues/329",
    "date": "2013-08-31T21:14:31Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/5b5aade918ea3d9cbc4aa993a23a21c1b3beda2f",
    "details": {
      "sha": "279bff006a2454ce7d42f284f41eb7490fe703da",
      "filename": "rxjava-core/src/main/java/rx/operators/OperationMaterialize.java",
      "status": "modified",
      "additions": 7,
      "deletions": 18,
      "changes": 25,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/5b5aade918ea3d9cbc4aa993a23a21c1b3beda2f/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationMaterialize.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/5b5aade918ea3d9cbc4aa993a23a21c1b3beda2f/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationMaterialize.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationMaterialize.java?ref=5b5aade918ea3d9cbc4aa993a23a21c1b3beda2f",
      "patch": "@@ -19,6 +19,7 @@\n \n import java.util.List;\n import java.util.Vector;\n+import java.util.concurrent.ExecutionException;\n \n import org.junit.Test;\n \n@@ -139,25 +140,13 @@ public void testMaterialize2() {\n         }\n \n         @Test\n-        public void testMultipleSubscribes() {\n-            final TestAsyncErrorObservable o1 = new TestAsyncErrorObservable(\"one\", \"two\", null, \"three\");\n-\n-            Observable<Notification<String>> m = Observable.create(materialize(o1));\n-\n-            TestObserver Observer1 = new TestObserver();\n-            m.subscribe(Observer1);\n-\n-            TestObserver Observer2 = new TestObserver();\n-            m.subscribe(Observer2);\n+        public void testMultipleSubscribes() throws InterruptedException, ExecutionException {\n+            final TestAsyncErrorObservable o = new TestAsyncErrorObservable(\"one\", \"two\", null, \"three\");\n \n-            try {\n-                o1.t.join();\n-            } catch (InterruptedException e) {\n-                throw new RuntimeException(e);\n-            }\n+            Observable<Notification<String>> m = Observable.create(materialize(o));\n \n-            assertEquals(3, Observer1.notifications.size());\n-            assertEquals(3, Observer2.notifications.size());\n+            assertEquals(3, m.toList().toBlockingObservable().toFuture().get().size());\n+            assertEquals(3, m.toList().toBlockingObservable().toFuture().get().size());\n         }\n \n     }\n@@ -193,7 +182,7 @@ private static class TestAsyncErrorObservable extends Observable<String> {\n             valuesToReturn = values;\n         }\n \n-        Thread t;\n+        volatile Thread t;\n \n         @Override\n         public Subscription subscribe(final Observer<String> observer) {",
      "parent_sha": "1cc2f6aebaa6138cca414c5b10a41f8dc974b010"
    }
  },
  {
    "oid": "78a0a1bfe66e56430cbdac0b6a418c46b140b85f",
    "message": "added an unnecessary explicit cast because the Jenkins java compiler is unhappy otherwise?",
    "date": "2013-09-01T08:34:49Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/78a0a1bfe66e56430cbdac0b6a418c46b140b85f",
    "details": {
      "sha": "c2ef17f312d5b2e74222cd166d191073e2fec06e",
      "filename": "rxjava-core/src/main/java/rx/operators/OperationToObservableFuture.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/78a0a1bfe66e56430cbdac0b6a418c46b140b85f/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationToObservableFuture.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/78a0a1bfe66e56430cbdac0b6a418c46b140b85f/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationToObservableFuture.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/rxjava-core%2Fsrc%2Fmain%2Fjava%2Frx%2Foperators%2FOperationToObservableFuture.java?ref=78a0a1bfe66e56430cbdac0b6a418c46b140b85f",
      "patch": "@@ -59,7 +59,7 @@ public ToObservableFuture(Future<? extends T> that, long time, TimeUnit unit) {\n         @Override\n         public Subscription call(Observer<? super T> observer) {\n             try {\n-                T value = (time == null) ? that.get() : that.get(time, unit);\n+                T value = (time == null) ? (T) that.get() : (T) that.get(time, unit);\n \n                 if (!that.isCancelled()) {\n                     observer.onNext(value);",
      "parent_sha": "29289d123bec4253b0e16d29c6ef6d3649cf9eec"
    }
  },
  {
    "oid": "5b408f6a09a2f72761005b72f2c06c70eef32fbb",
    "message": "3.x: Fix source locator code to support GitHub Actions folder layout (#7113)",
    "date": "2020-11-20T15:35:16Z",
    "url": "https://github.com/ReactiveX/RxJava/commit/5b408f6a09a2f72761005b72f2c06c70eef32fbb",
    "details": {
      "sha": "1963a38459c979942a2183481dec4dcd63ee8941",
      "filename": "src/test/java/io/reactivex/rxjava3/testsupport/TestHelper.java",
      "status": "modified",
      "additions": 18,
      "deletions": 10,
      "changes": 28,
      "blob_url": "https://github.com/ReactiveX/RxJava/blob/5b408f6a09a2f72761005b72f2c06c70eef32fbb/src%2Ftest%2Fjava%2Fio%2Freactivex%2Frxjava3%2Ftestsupport%2FTestHelper.java",
      "raw_url": "https://github.com/ReactiveX/RxJava/raw/5b408f6a09a2f72761005b72f2c06c70eef32fbb/src%2Ftest%2Fjava%2Fio%2Freactivex%2Frxjava3%2Ftestsupport%2FTestHelper.java",
      "contents_url": "https://api.github.com/repos/ReactiveX/RxJava/contents/src%2Ftest%2Fjava%2Fio%2Freactivex%2Frxjava3%2Ftestsupport%2FTestHelper.java?ref=5b408f6a09a2f72761005b72f2c06c70eef32fbb",
      "patch": "@@ -3503,18 +3503,26 @@ public static File findSource(String baseClassName, String parentPackage) throws\n         parentPackage = parentPackage.replace(\".\", \"/\");\n //        System.out.println(path);\n \n-        int i = path.toLowerCase().indexOf(\"/rxjava\");\n-        if (i < 0) {\n-            System.out.println(\"Can't find the base RxJava directory\");\n-            return null;\n-        }\n-\n-        // find end of any potential postfix to /RxJava\n-        int j = path.indexOf(\"/\", i + 6);\n+        // Locate the src/main/java directory\n+        String p = null;\n+        while (true) {\n+            int idx = path.lastIndexOf(\"/\");\n+            if (idx < 0) {\n+                break;\n+            }\n+            path = path.substring(0, idx);\n+            String check = path + \"/src/main/java\";\n \n-        String basePackage = path.substring(0, j + 1) + \"src/main/java\";\n+            if (new File(check).exists()) {\n+                p = check + \"/\" + parentPackage + \"/\" + baseClassName + \".java\";\n+                break;\n+            }\n+        }\n \n-        String p = basePackage + \"/\" + parentPackage + \"/\" + baseClassName + \".java\";\n+        if (p == null) {\n+            System.err.println(\"Unable to locate the RxJava sources\");\n+            return null;\n+        }\n \n         File f = new File(p);\n ",
      "parent_sha": "78b29f7967cd7589c3e53a4a8a73ad2aadb30eff"
    }
  }
]