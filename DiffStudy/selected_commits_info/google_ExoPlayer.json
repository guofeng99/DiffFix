[
  {
    "oid": "ce0e3a4fa3e829c987e541f30694a73d8abbc25b",
    "message": "Make MatrixTransformationsProcessor constructor to take in Lists.\n\n* Replace ImmutableLists to List interface for constructors\n\nPiperOrigin-RevId: 472433434",
    "date": "2022-10-19T21:03:27Z",
    "url": "https://github.com/google/ExoPlayer/commit/ce0e3a4fa3e829c987e541f30694a73d8abbc25b",
    "details": {
      "sha": "62c0490a84744020fd1c0bd61ad1398c8120102e",
      "filename": "google3/third_party/java_src/android_libs/media/libraries/effect/src/main/java/androidx/media3/effect/MatrixTransformationProcessor.java",
      "status": "modified",
      "additions": 29,
      "deletions": 12,
      "changes": 41,
      "blob_url": "https://github.com/google/ExoPlayer/blob/ce0e3a4fa3e829c987e541f30694a73d8abbc25b/google3%2Fthird_party%2Fjava_src%2Fandroid_libs%2Fmedia%2Flibraries%2Feffect%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Feffect%2FMatrixTransformationProcessor.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/ce0e3a4fa3e829c987e541f30694a73d8abbc25b/google3%2Fthird_party%2Fjava_src%2Fandroid_libs%2Fmedia%2Flibraries%2Feffect%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Feffect%2FMatrixTransformationProcessor.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/google3%2Fthird_party%2Fjava_src%2Fandroid_libs%2Fmedia%2Flibraries%2Feffect%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Feffect%2FMatrixTransformationProcessor.java?ref=ce0e3a4fa3e829c987e541f30694a73d8abbc25b",
      "patch": "@@ -31,6 +31,7 @@\n import com.google.common.collect.ImmutableList;\n import java.io.IOException;\n import java.util.Arrays;\n+import java.util.List;\n \n /**\n  * Applies a sequence of {@link MatrixTransformation MatrixTransformations} in the vertex shader and\n@@ -134,16 +135,20 @@\n    */\n   public static MatrixTransformationProcessor create(\n       Context context,\n-      ImmutableList<GlMatrixTransformation> matrixTransformations,\n-      ImmutableList<RgbMatrix> rgbMatrices,\n+      List<GlMatrixTransformation> matrixTransformations,\n+      List<RgbMatrix> rgbMatrices,\n       boolean useHdr)\n       throws FrameProcessingException {\n     GlProgram glProgram =\n         createGlProgram(\n             context, VERTEX_SHADER_TRANSFORMATION_PATH, FRAGMENT_SHADER_TRANSFORMATION_PATH);\n \n     // No transfer functions needed, because input and output are both optical colors.\n-    return new MatrixTransformationProcessor(glProgram, matrixTransformations, rgbMatrices, useHdr);\n+    return new MatrixTransformationProcessor(\n+        glProgram,\n+        ImmutableList.copyOf(matrixTransformations),\n+        ImmutableList.copyOf(rgbMatrices),\n+        useHdr);\n   }\n \n   /**\n@@ -171,8 +176,8 @@ public static MatrixTransformationProcessor create(\n    */\n   public static MatrixTransformationProcessor createWithExternalSamplerApplyingEotf(\n       Context context,\n-      ImmutableList<GlMatrixTransformation> matrixTransformations,\n-      ImmutableList<RgbMatrix> rgbMatrices,\n+      List<GlMatrixTransformation> matrixTransformations,\n+      List<RgbMatrix> rgbMatrices,\n       ColorInfo electricalColorInfo)\n       throws FrameProcessingException {\n     boolean useHdr = ColorInfo.isTransferHdr(electricalColorInfo);\n@@ -203,7 +208,11 @@ public static MatrixTransformationProcessor createWithExternalSamplerApplyingEot\n       glProgram.setIntUniform(\"uEotfColorTransfer\", colorTransfer);\n     }\n \n-    return new MatrixTransformationProcessor(glProgram, matrixTransformations, rgbMatrices, useHdr);\n+    return new MatrixTransformationProcessor(\n+        glProgram,\n+        ImmutableList.copyOf(matrixTransformations),\n+        ImmutableList.copyOf(rgbMatrices),\n+        useHdr);\n   }\n \n   /**\n@@ -227,8 +236,8 @@ public static MatrixTransformationProcessor createWithExternalSamplerApplyingEot\n    */\n   public static MatrixTransformationProcessor createApplyingOetf(\n       Context context,\n-      ImmutableList<GlMatrixTransformation> matrixTransformations,\n-      ImmutableList<RgbMatrix> rgbMatrices,\n+      List<GlMatrixTransformation> matrixTransformations,\n+      List<RgbMatrix> rgbMatrices,\n       ColorInfo electricalColorInfo)\n       throws FrameProcessingException {\n     boolean useHdr = ColorInfo.isTransferHdr(electricalColorInfo);\n@@ -246,7 +255,11 @@ public static MatrixTransformationProcessor createApplyingOetf(\n       glProgram.setIntUniform(\"uOetfColorTransfer\", colorTransfer);\n     }\n \n-    return new MatrixTransformationProcessor(glProgram, matrixTransformations, rgbMatrices, useHdr);\n+    return new MatrixTransformationProcessor(\n+        glProgram,\n+        ImmutableList.copyOf(matrixTransformations),\n+        ImmutableList.copyOf(rgbMatrices),\n+        useHdr);\n   }\n \n   /**\n@@ -270,8 +283,8 @@ public static MatrixTransformationProcessor createApplyingOetf(\n    */\n   public static MatrixTransformationProcessor createWithExternalSamplerApplyingEotfThenOetf(\n       Context context,\n-      ImmutableList<GlMatrixTransformation> matrixTransformations,\n-      ImmutableList<RgbMatrix> rgbMatrices,\n+      List<GlMatrixTransformation> matrixTransformations,\n+      List<RgbMatrix> rgbMatrices,\n       ColorInfo electricalColorInfo)\n       throws FrameProcessingException {\n     boolean useHdr = ColorInfo.isTransferHdr(electricalColorInfo);\n@@ -300,7 +313,11 @@ public static MatrixTransformationProcessor createWithExternalSamplerApplyingEot\n       glProgram.setIntUniform(\"uEotfColorTransfer\", Format.NO_VALUE);\n     }\n \n-    return new MatrixTransformationProcessor(glProgram, matrixTransformations, rgbMatrices, useHdr);\n+    return new MatrixTransformationProcessor(\n+        glProgram,\n+        ImmutableList.copyOf(matrixTransformations),\n+        ImmutableList.copyOf(rgbMatrices),\n+        useHdr);\n   }\n \n   /**",
      "parent_sha": "c0ad9f51faa5b61e281178666c2cad75329b37f6"
    }
  },
  {
    "oid": "de4ff4c5ec71698fb4d2ff9ce4572929d70d477a",
    "message": "Extend HostActivity for reuse and silent timeout.\n\nAdded option to fail on timeout. Also reset internals in all cases\nsuch that the activity can be used more than once.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=159419176",
    "date": "2017-06-22T18:59:48Z",
    "url": "https://github.com/google/ExoPlayer/commit/de4ff4c5ec71698fb4d2ff9ce4572929d70d477a",
    "details": {
      "sha": "831344aa8be8a017b077cfa1413b240848164179",
      "filename": "testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java",
      "status": "modified",
      "additions": 16,
      "deletions": 1,
      "changes": 17,
      "blob_url": "https://github.com/google/ExoPlayer/blob/de4ff4c5ec71698fb4d2ff9ce4572929d70d477a/testutils%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftestutil%2FHostActivity.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/de4ff4c5ec71698fb4d2ff9ce4572929d70d477a/testutils%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftestutil%2FHostActivity.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/testutils%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftestutil%2FHostActivity.java?ref=de4ff4c5ec71698fb4d2ff9ce4572929d70d477a",
      "patch": "@@ -101,6 +101,17 @@ public interface HostedTest {\n    *     is exceeded then the test will fail.\n    */\n   public void runTest(final HostedTest hostedTest, long timeoutMs) {\n+    runTest(hostedTest, timeoutMs, true);\n+  }\n+\n+  /**\n+   * Executes a {@link HostedTest} inside the host.\n+   *\n+   * @param hostedTest The test to execute.\n+   * @param timeoutMs The number of milliseconds to wait for the test to finish.\n+   * @param failOnTimeout Whether the test fails when the timeout is exceeded.\n+   */\n+  public void runTest(final HostedTest hostedTest, long timeoutMs, boolean failOnTimeout) {\n     Assertions.checkArgument(timeoutMs > 0);\n     Assertions.checkState(Thread.currentThread() != getMainLooper().getThread());\n \n@@ -131,7 +142,11 @@ public void run() {\n     } else {\n       String message = \"Test timed out after \" + timeoutMs + \" ms.\";\n       Log.e(TAG, message);\n-      fail(message);\n+      if (failOnTimeout) {\n+        fail(message);\n+      }\n+      maybeStopHostedTest();\n+      hostedTestStoppedCondition.block();\n     }\n   }\n ",
      "parent_sha": "56ff2ef598d1bcc2e5f78d2fe8e27b20f731b386"
    }
  },
  {
    "oid": "ec96e0c4950a536fc7fb5cbaef4e089dc543a6c8",
    "message": "Add MiTV devices requiring the output surface workaround\n\nIssue: #8014\nPiperOrigin-RevId: 337142176",
    "date": "2020-10-20T21:16:12Z",
    "url": "https://github.com/google/ExoPlayer/commit/ec96e0c4950a536fc7fb5cbaef4e089dc543a6c8",
    "details": {
      "sha": "89e2ef4fcd81c44ef41b2b7ee4615dad3aaa8565",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java",
      "status": "modified",
      "additions": 187,
      "deletions": 174,
      "changes": 361,
      "blob_url": "https://github.com/google/ExoPlayer/blob/ec96e0c4950a536fc7fb5cbaef4e089dc543a6c8/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fvideo%2FMediaCodecVideoRenderer.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/ec96e0c4950a536fc7fb5cbaef4e089dc543a6c8/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fvideo%2FMediaCodecVideoRenderer.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fvideo%2FMediaCodecVideoRenderer.java?ref=ec96e0c4950a536fc7fb5cbaef4e089dc543a6c8",
      "patch": "@@ -1551,180 +1551,7 @@ protected boolean codecNeedsSetOutputSurfaceWorkaround(String name) {\n     }\n     synchronized (MediaCodecVideoRenderer.class) {\n       if (!evaluatedDeviceNeedsSetOutputSurfaceWorkaround) {\n-        if (\"dangal\".equals(Util.DEVICE)) {\n-          // Workaround for MiTV devices:\n-          // https://github.com/google/ExoPlayer/issues/5169,\n-          // https://github.com/google/ExoPlayer/issues/6899.\n-          deviceNeedsSetOutputSurfaceWorkaround = true;\n-        } else if (Util.SDK_INT <= 27 && \"HWEML\".equals(Util.DEVICE)) {\n-          // Workaround for Huawei P20:\n-          // https://github.com/google/ExoPlayer/issues/4468#issuecomment-459291645.\n-          deviceNeedsSetOutputSurfaceWorkaround = true;\n-        } else if (Util.SDK_INT >= 27) {\n-          // In general, devices running API level 27 or later should be unaffected. Do nothing.\n-        } else {\n-          // Enable the workaround on a per-device basis. Works around:\n-          // https://github.com/google/ExoPlayer/issues/3236,\n-          // https://github.com/google/ExoPlayer/issues/3355,\n-          // https://github.com/google/ExoPlayer/issues/3439,\n-          // https://github.com/google/ExoPlayer/issues/3724,\n-          // https://github.com/google/ExoPlayer/issues/3835,\n-          // https://github.com/google/ExoPlayer/issues/4006,\n-          // https://github.com/google/ExoPlayer/issues/4084,\n-          // https://github.com/google/ExoPlayer/issues/4104,\n-          // https://github.com/google/ExoPlayer/issues/4134,\n-          // https://github.com/google/ExoPlayer/issues/4315,\n-          // https://github.com/google/ExoPlayer/issues/4419,\n-          // https://github.com/google/ExoPlayer/issues/4460,\n-          // https://github.com/google/ExoPlayer/issues/4468,\n-          // https://github.com/google/ExoPlayer/issues/5312,\n-          // https://github.com/google/ExoPlayer/issues/6503.\n-          switch (Util.DEVICE) {\n-            case \"1601\":\n-            case \"1713\":\n-            case \"1714\":\n-            case \"A10-70F\":\n-            case \"A10-70L\":\n-            case \"A1601\":\n-            case \"A2016a40\":\n-            case \"A7000-a\":\n-            case \"A7000plus\":\n-            case \"A7010a48\":\n-            case \"A7020a48\":\n-            case \"AquaPowerM\":\n-            case \"ASUS_X00AD_2\":\n-            case \"Aura_Note_2\":\n-            case \"BLACK-1X\":\n-            case \"BRAVIA_ATV2\":\n-            case \"BRAVIA_ATV3_4K\":\n-            case \"C1\":\n-            case \"ComioS1\":\n-            case \"CP8676_I02\":\n-            case \"CPH1609\":\n-            case \"CPY83_I00\":\n-            case \"cv1\":\n-            case \"cv3\":\n-            case \"deb\":\n-            case \"E5643\":\n-            case \"ELUGA_A3_Pro\":\n-            case \"ELUGA_Note\":\n-            case \"ELUGA_Prim\":\n-            case \"ELUGA_Ray_X\":\n-            case \"EverStar_S\":\n-            case \"F02H\":\n-            case \"F03H\":\n-            case \"F3111\":\n-            case \"F3113\":\n-            case \"F3116\":\n-            case \"F3211\":\n-            case \"F3213\":\n-            case \"F3215\":\n-            case \"F3311\":\n-            case \"flo\":\n-            case \"fugu\":\n-            case \"GiONEE_CBL7513\":\n-            case \"GiONEE_GBL7319\":\n-            case \"GIONEE_GBL7360\":\n-            case \"GIONEE_SWW1609\":\n-            case \"GIONEE_SWW1627\":\n-            case \"GIONEE_SWW1631\":\n-            case \"GIONEE_WBL5708\":\n-            case \"GIONEE_WBL7365\":\n-            case \"GIONEE_WBL7519\":\n-            case \"griffin\":\n-            case \"htc_e56ml_dtul\":\n-            case \"hwALE-H\":\n-            case \"HWBLN-H\":\n-            case \"HWCAM-H\":\n-            case \"HWVNS-H\":\n-            case \"HWWAS-H\":\n-            case \"i9031\":\n-            case \"iball8735_9806\":\n-            case \"Infinix-X572\":\n-            case \"iris60\":\n-            case \"itel_S41\":\n-            case \"j2xlteins\":\n-            case \"JGZ\":\n-            case \"K50a40\":\n-            case \"kate\":\n-            case \"l5460\":\n-            case \"le_x6\":\n-            case \"LS-5017\":\n-            case \"M5c\":\n-            case \"manning\":\n-            case \"marino_f\":\n-            case \"MEIZU_M5\":\n-            case \"mh\":\n-            case \"mido\":\n-            case \"MX6\":\n-            case \"namath\":\n-            case \"nicklaus_f\":\n-            case \"NX541J\":\n-            case \"NX573J\":\n-            case \"OnePlus5T\":\n-            case \"p212\":\n-            case \"P681\":\n-            case \"P85\":\n-            case \"panell_d\":\n-            case \"panell_dl\":\n-            case \"panell_ds\":\n-            case \"panell_dt\":\n-            case \"PB2-670M\":\n-            case \"PGN528\":\n-            case \"PGN610\":\n-            case \"PGN611\":\n-            case \"Phantom6\":\n-            case \"Pixi4-7_3G\":\n-            case \"Pixi5-10_4G\":\n-            case \"PLE\":\n-            case \"PRO7S\":\n-            case \"Q350\":\n-            case \"Q4260\":\n-            case \"Q427\":\n-            case \"Q4310\":\n-            case \"Q5\":\n-            case \"QM16XE_U\":\n-            case \"QX1\":\n-            case \"santoni\":\n-            case \"Slate_Pro\":\n-            case \"SVP-DTV15\":\n-            case \"s905x018\":\n-            case \"taido_row\":\n-            case \"TB3-730F\":\n-            case \"TB3-730X\":\n-            case \"TB3-850F\":\n-            case \"TB3-850M\":\n-            case \"tcl_eu\":\n-            case \"V1\":\n-            case \"V23GB\":\n-            case \"V5\":\n-            case \"vernee_M5\":\n-            case \"watson\":\n-            case \"whyred\":\n-            case \"woods_f\":\n-            case \"woods_fn\":\n-            case \"X3_HK\":\n-            case \"XE2X\":\n-            case \"XT1663\":\n-            case \"Z12_PRO\":\n-            case \"Z80\":\n-              deviceNeedsSetOutputSurfaceWorkaround = true;\n-              break;\n-            default:\n-              // Do nothing.\n-              break;\n-          }\n-          switch (Util.MODEL) {\n-            case \"AFTA\":\n-            case \"AFTN\":\n-            case \"JSN-L21\":\n-              deviceNeedsSetOutputSurfaceWorkaround = true;\n-              break;\n-            default:\n-              // Do nothing.\n-              break;\n-          }\n-        }\n+        deviceNeedsSetOutputSurfaceWorkaround = evaluateDeviceNeedsSetOutputSurfaceWorkaround();\n         evaluatedDeviceNeedsSetOutputSurfaceWorkaround = true;\n       }\n     }\n@@ -1746,7 +1573,193 @@ public CodecMaxValues(int width, int height, int inputSize) {\n       this.height = height;\n       this.inputSize = inputSize;\n     }\n+  }\n \n+  private static boolean evaluateDeviceNeedsSetOutputSurfaceWorkaround() {\n+    if (Util.SDK_INT <= 28) {\n+      // Workaround for MiTV devices which have been observed broken up to API 28.\n+      // https://github.com/google/ExoPlayer/issues/5169,\n+      // https://github.com/google/ExoPlayer/issues/6899.\n+      // https://github.com/google/ExoPlayer/issues/8014.\n+      switch (Util.DEVICE) {\n+        case \"dangal\":\n+        case \"dangalUHD\":\n+        case \"dangalFHD\":\n+        case \"magnolia\":\n+        case \"machuca\":\n+          return true;\n+        default:\n+          break; // Do nothing.\n+      }\n+    }\n+    if (Util.SDK_INT <= 27 && \"HWEML\".equals(Util.DEVICE)) {\n+      // Workaround for Huawei P20:\n+      // https://github.com/google/ExoPlayer/issues/4468#issuecomment-459291645.\n+      return true;\n+    }\n+    if (Util.SDK_INT <= 26) {\n+      // In general, devices running API level 27 or later should be unaffected unless observed\n+      // otherwise. Enable the workaround on a per-device basis. Works around:\n+      // https://github.com/google/ExoPlayer/issues/3236,\n+      // https://github.com/google/ExoPlayer/issues/3355,\n+      // https://github.com/google/ExoPlayer/issues/3439,\n+      // https://github.com/google/ExoPlayer/issues/3724,\n+      // https://github.com/google/ExoPlayer/issues/3835,\n+      // https://github.com/google/ExoPlayer/issues/4006,\n+      // https://github.com/google/ExoPlayer/issues/4084,\n+      // https://github.com/google/ExoPlayer/issues/4104,\n+      // https://github.com/google/ExoPlayer/issues/4134,\n+      // https://github.com/google/ExoPlayer/issues/4315,\n+      // https://github.com/google/ExoPlayer/issues/4419,\n+      // https://github.com/google/ExoPlayer/issues/4460,\n+      // https://github.com/google/ExoPlayer/issues/4468,\n+      // https://github.com/google/ExoPlayer/issues/5312,\n+      // https://github.com/google/ExoPlayer/issues/6503.\n+      // https://github.com/google/ExoPlayer/issues/8014.\n+      switch (Util.DEVICE) {\n+        case \"1601\":\n+        case \"1713\":\n+        case \"1714\":\n+        case \"A10-70F\":\n+        case \"A10-70L\":\n+        case \"A1601\":\n+        case \"A2016a40\":\n+        case \"A7000-a\":\n+        case \"A7000plus\":\n+        case \"A7010a48\":\n+        case \"A7020a48\":\n+        case \"AquaPowerM\":\n+        case \"ASUS_X00AD_2\":\n+        case \"Aura_Note_2\":\n+        case \"BLACK-1X\":\n+        case \"BRAVIA_ATV2\":\n+        case \"BRAVIA_ATV3_4K\":\n+        case \"C1\":\n+        case \"ComioS1\":\n+        case \"CP8676_I02\":\n+        case \"CPH1609\":\n+        case \"CPY83_I00\":\n+        case \"cv1\":\n+        case \"cv3\":\n+        case \"deb\":\n+        case \"E5643\":\n+        case \"ELUGA_A3_Pro\":\n+        case \"ELUGA_Note\":\n+        case \"ELUGA_Prim\":\n+        case \"ELUGA_Ray_X\":\n+        case \"EverStar_S\":\n+        case \"F02H\":\n+        case \"F03H\":\n+        case \"F3111\":\n+        case \"F3113\":\n+        case \"F3116\":\n+        case \"F3211\":\n+        case \"F3213\":\n+        case \"F3215\":\n+        case \"F3311\":\n+        case \"flo\":\n+        case \"fugu\":\n+        case \"GiONEE_CBL7513\":\n+        case \"GiONEE_GBL7319\":\n+        case \"GIONEE_GBL7360\":\n+        case \"GIONEE_SWW1609\":\n+        case \"GIONEE_SWW1627\":\n+        case \"GIONEE_SWW1631\":\n+        case \"GIONEE_WBL5708\":\n+        case \"GIONEE_WBL7365\":\n+        case \"GIONEE_WBL7519\":\n+        case \"griffin\":\n+        case \"htc_e56ml_dtul\":\n+        case \"hwALE-H\":\n+        case \"HWBLN-H\":\n+        case \"HWCAM-H\":\n+        case \"HWVNS-H\":\n+        case \"HWWAS-H\":\n+        case \"i9031\":\n+        case \"iball8735_9806\":\n+        case \"Infinix-X572\":\n+        case \"iris60\":\n+        case \"itel_S41\":\n+        case \"j2xlteins\":\n+        case \"JGZ\":\n+        case \"K50a40\":\n+        case \"kate\":\n+        case \"l5460\":\n+        case \"le_x6\":\n+        case \"LS-5017\":\n+        case \"M5c\":\n+        case \"manning\":\n+        case \"marino_f\":\n+        case \"MEIZU_M5\":\n+        case \"mh\":\n+        case \"mido\":\n+        case \"MX6\":\n+        case \"namath\":\n+        case \"nicklaus_f\":\n+        case \"NX541J\":\n+        case \"NX573J\":\n+        case \"OnePlus5T\":\n+        case \"p212\":\n+        case \"P681\":\n+        case \"P85\":\n+        case \"pacificrim\":\n+        case \"panell_d\":\n+        case \"panell_dl\":\n+        case \"panell_ds\":\n+        case \"panell_dt\":\n+        case \"PB2-670M\":\n+        case \"PGN528\":\n+        case \"PGN610\":\n+        case \"PGN611\":\n+        case \"Phantom6\":\n+        case \"Pixi4-7_3G\":\n+        case \"Pixi5-10_4G\":\n+        case \"PLE\":\n+        case \"PRO7S\":\n+        case \"Q350\":\n+        case \"Q4260\":\n+        case \"Q427\":\n+        case \"Q4310\":\n+        case \"Q5\":\n+        case \"QM16XE_U\":\n+        case \"QX1\":\n+        case \"santoni\":\n+        case \"Slate_Pro\":\n+        case \"SVP-DTV15\":\n+        case \"s905x018\":\n+        case \"taido_row\":\n+        case \"TB3-730F\":\n+        case \"TB3-730X\":\n+        case \"TB3-850F\":\n+        case \"TB3-850M\":\n+        case \"tcl_eu\":\n+        case \"V1\":\n+        case \"V23GB\":\n+        case \"V5\":\n+        case \"vernee_M5\":\n+        case \"watson\":\n+        case \"whyred\":\n+        case \"woods_f\":\n+        case \"woods_fn\":\n+        case \"X3_HK\":\n+        case \"XE2X\":\n+        case \"XT1663\":\n+        case \"Z12_PRO\":\n+        case \"Z80\":\n+          return true;\n+        default:\n+          break; // Do nothing.\n+      }\n+      switch (Util.MODEL) {\n+        case \"AFTA\":\n+        case \"AFTN\":\n+        case \"JSN-L21\":\n+          return true;\n+        default:\n+          break; // Do nothing.\n+      }\n+    }\n+    return false;\n   }\n \n   @RequiresApi(23)",
      "parent_sha": "2b6a9a346aa79ab410bbcdfdd305960fedf71071"
    }
  },
  {
    "oid": "b97ce44182ea61fc42584938c79a554c9891654c",
    "message": "Pass -1 not C.TIME_UNSET when duration is unknown\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=179165479",
    "date": "2017-12-15T16:25:10Z",
    "url": "https://github.com/google/ExoPlayer/commit/b97ce44182ea61fc42584938c79a554c9891654c",
    "details": {
      "sha": "e0bca20d38177c93c222840473ced689688bfbfc",
      "filename": "extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/google/ExoPlayer/blob/b97ce44182ea61fc42584938c79a554c9891654c/extensions%2Fima%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fext%2Fima%2FImaAdsLoader.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/b97ce44182ea61fc42584938c79a554c9891654c/extensions%2Fima%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fext%2Fima%2FImaAdsLoader.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/extensions%2Fima%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fext%2Fima%2FImaAdsLoader.java?ref=b97ce44182ea61fc42584938c79a554c9891654c",
      "patch": "@@ -151,6 +151,9 @@ public ImaAdsLoader buildForAdsResponse(String adsResponse) {\n   private static final String IMA_SDK_SETTINGS_PLAYER_TYPE = \"google/exo.ext.ima\";\n   private static final String IMA_SDK_SETTINGS_PLAYER_VERSION = ExoPlayerLibraryInfo.VERSION;\n \n+  /** The value used in {@link VideoProgressUpdate}s to indicate an unset duration. */\n+  private static final long IMA_DURATION_UNSET = -1L;\n+\n   /**\n    * Threshold before the end of content at which IMA is notified that content is complete if the\n    * player buffers, in milliseconds.\n@@ -533,6 +536,8 @@ public void onAdError(AdErrorEvent adErrorEvent) {\n \n   @Override\n   public VideoProgressUpdate getContentProgress() {\n+    boolean hasContentDuration = contentDurationMs != C.TIME_UNSET;\n+    long contentDurationMs = hasContentDuration ? this.contentDurationMs : IMA_DURATION_UNSET;\n     if (player == null) {\n       return lastContentProgress;\n     } else if (pendingContentPositionMs != C.TIME_UNSET) {\n@@ -542,7 +547,7 @@ public VideoProgressUpdate getContentProgress() {\n       long elapsedSinceEndMs = SystemClock.elapsedRealtime() - fakeContentProgressElapsedRealtimeMs;\n       long fakePositionMs = fakeContentProgressOffsetMs + elapsedSinceEndMs;\n       return new VideoProgressUpdate(fakePositionMs, contentDurationMs);\n-    } else if (playingAd || contentDurationMs == C.TIME_UNSET) {\n+    } else if (playingAd || !hasContentDuration) {\n       return VideoProgressUpdate.VIDEO_TIME_NOT_READY;\n     } else {\n       return new VideoProgressUpdate(player.getCurrentPosition(), contentDurationMs);",
      "parent_sha": "403f773f8703f013b129ef02336b881678f1311f"
    }
  },
  {
    "oid": "4289708323442f088258c67695b74eefa9a5fb83",
    "message": "Fix DefaultAudioSinkTest flakiness.\n\nSome calls to handleBuffer return false while a previous\nflush is still handled in the background.\n\nFix this by either asserting the method returns true if\nwe don't expect any delay, or calling it repeatedly until\nit returns true (within a timeout).\n\nPiperOrigin-RevId: 460474419",
    "date": "2022-07-13T17:37:19Z",
    "url": "https://github.com/google/ExoPlayer/commit/4289708323442f088258c67695b74eefa9a5fb83",
    "details": {
      "sha": "c4453b82a34e6e35cea6c38753bfda1faf8b09cb",
      "filename": "library/core/src/test/java/com/google/android/exoplayer2/audio/DefaultAudioSinkTest.java",
      "status": "modified",
      "additions": 119,
      "deletions": 44,
      "changes": 163,
      "blob_url": "https://github.com/google/ExoPlayer/blob/4289708323442f088258c67695b74eefa9a5fb83/library%2Fcore%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Faudio%2FDefaultAudioSinkTest.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/4289708323442f088258c67695b74eefa9a5fb83/library%2Fcore%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Faudio%2FDefaultAudioSinkTest.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Faudio%2FDefaultAudioSinkTest.java?ref=4289708323442f088258c67695b74eefa9a5fb83",
      "patch": "@@ -29,6 +29,7 @@\n import java.nio.ByteBuffer;\n import java.nio.ByteOrder;\n import java.util.Arrays;\n+import java.util.concurrent.TimeoutException;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n@@ -38,6 +39,9 @@\n /** Unit tests for {@link DefaultAudioSink}. */\n @RunWith(AndroidJUnit4.class)\n public final class DefaultAudioSinkTest {\n+\n+  private static final long TIMEOUT_MS = 10_000;\n+\n   private static final int CHANNEL_COUNT_MONO = 1;\n   private static final int CHANNEL_COUNT_STEREO = 2;\n   private static final int BYTES_PER_FRAME_16_BIT = 2;\n@@ -74,57 +78,89 @@ public void handlesSpecializedAudioProcessorArray() {\n   @Test\n   public void handlesBufferAfterReset() throws Exception {\n     configureDefaultAudioSink(CHANNEL_COUNT_STEREO);\n-    defaultAudioSink.handleBuffer(\n-        createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0, /* encodedAccessUnitCount= */ 1);\n+    assertThat(\n+            defaultAudioSink.handleBuffer(\n+                createDefaultSilenceBuffer(),\n+                /* presentationTimeUs= */ 0,\n+                /* encodedAccessUnitCount= */ 1))\n+        .isTrue();\n \n     // After reset and re-configure we can successfully queue more input.\n     defaultAudioSink.reset();\n     configureDefaultAudioSink(CHANNEL_COUNT_STEREO);\n-    defaultAudioSink.handleBuffer(\n-        createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0, /* encodedAccessUnitCount= */ 1);\n+    retryUntilTrue(\n+        () ->\n+            defaultAudioSink.handleBuffer(\n+                createDefaultSilenceBuffer(),\n+                /* presentationTimeUs= */ 0,\n+                /* encodedAccessUnitCount= */ 1));\n   }\n \n   @Test\n   public void handlesBufferAfterReset_withPlaybackSpeed() throws Exception {\n     defaultAudioSink.setPlaybackParameters(new PlaybackParameters(/* speed= */ 1.5f));\n     configureDefaultAudioSink(CHANNEL_COUNT_STEREO);\n-    defaultAudioSink.handleBuffer(\n-        createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0, /* encodedAccessUnitCount= */ 1);\n+    assertThat(\n+            defaultAudioSink.handleBuffer(\n+                createDefaultSilenceBuffer(),\n+                /* presentationTimeUs= */ 0,\n+                /* encodedAccessUnitCount= */ 1))\n+        .isTrue();\n \n     // After reset and re-configure we can successfully queue more input.\n     defaultAudioSink.reset();\n     configureDefaultAudioSink(CHANNEL_COUNT_STEREO);\n-    defaultAudioSink.handleBuffer(\n-        createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0, /* encodedAccessUnitCount= */ 1);\n+    retryUntilTrue(\n+        () ->\n+            defaultAudioSink.handleBuffer(\n+                createDefaultSilenceBuffer(),\n+                /* presentationTimeUs= */ 0,\n+                /* encodedAccessUnitCount= */ 1));\n     assertThat(defaultAudioSink.getPlaybackParameters())\n         .isEqualTo(new PlaybackParameters(/* speed= */ 1.5f));\n   }\n \n   @Test\n   public void handlesBufferAfterReset_withFormatChange() throws Exception {\n     configureDefaultAudioSink(CHANNEL_COUNT_STEREO);\n-    defaultAudioSink.handleBuffer(\n-        createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0, /* encodedAccessUnitCount= */ 1);\n+    assertThat(\n+            defaultAudioSink.handleBuffer(\n+                createDefaultSilenceBuffer(),\n+                /* presentationTimeUs= */ 0,\n+                /* encodedAccessUnitCount= */ 1))\n+        .isTrue();\n \n     // After reset and re-configure we can successfully queue more input.\n     defaultAudioSink.reset();\n     configureDefaultAudioSink(CHANNEL_COUNT_MONO);\n-    defaultAudioSink.handleBuffer(\n-        createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0, /* encodedAccessUnitCount= */ 1);\n+    retryUntilTrue(\n+        () ->\n+            defaultAudioSink.handleBuffer(\n+                createDefaultSilenceBuffer(),\n+                /* presentationTimeUs= */ 0,\n+                /* encodedAccessUnitCount= */ 1));\n   }\n \n   @Test\n   public void handlesBufferAfterReset_withFormatChangeAndPlaybackSpeed() throws Exception {\n     defaultAudioSink.setPlaybackParameters(new PlaybackParameters(/* speed= */ 1.5f));\n     configureDefaultAudioSink(CHANNEL_COUNT_STEREO);\n-    defaultAudioSink.handleBuffer(\n-        createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0, /* encodedAccessUnitCount= */ 1);\n+    assertThat(\n+            defaultAudioSink.handleBuffer(\n+                createDefaultSilenceBuffer(),\n+                /* presentationTimeUs= */ 0,\n+                /* encodedAccessUnitCount= */ 1))\n+        .isTrue();\n \n     // After reset and re-configure we can successfully queue more input.\n     defaultAudioSink.reset();\n     configureDefaultAudioSink(CHANNEL_COUNT_MONO);\n-    defaultAudioSink.handleBuffer(\n-        createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0, /* encodedAccessUnitCount= */ 1);\n+    retryUntilTrue(\n+        () ->\n+            defaultAudioSink.handleBuffer(\n+                createDefaultSilenceBuffer(),\n+                /* presentationTimeUs= */ 0,\n+                /* encodedAccessUnitCount= */ 1));\n     assertThat(defaultAudioSink.getPlaybackParameters())\n         .isEqualTo(new PlaybackParameters(/* speed= */ 1.5f));\n   }\n@@ -135,8 +171,12 @@ public void trimsStartFrames() throws Exception {\n         CHANNEL_COUNT_STEREO,\n         /* trimStartFrames= */ TRIM_100_MS_FRAME_COUNT,\n         /* trimEndFrames= */ 0);\n-    defaultAudioSink.handleBuffer(\n-        createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0, /* encodedAccessUnitCount= */ 1);\n+    assertThat(\n+            defaultAudioSink.handleBuffer(\n+                createDefaultSilenceBuffer(),\n+                /* presentationTimeUs= */ 0,\n+                /* encodedAccessUnitCount= */ 1))\n+        .isTrue();\n \n     assertThat(arrayAudioBufferSink.output)\n         .hasLength(\n@@ -151,8 +191,12 @@ public void trimsEndFrames() throws Exception {\n         CHANNEL_COUNT_STEREO,\n         /* trimStartFrames= */ 0,\n         /* trimEndFrames= */ TRIM_10_MS_FRAME_COUNT);\n-    defaultAudioSink.handleBuffer(\n-        createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0, /* encodedAccessUnitCount= */ 1);\n+    assertThat(\n+            defaultAudioSink.handleBuffer(\n+                createDefaultSilenceBuffer(),\n+                /* presentationTimeUs= */ 0,\n+                /* encodedAccessUnitCount= */ 1))\n+        .isTrue();\n \n     assertThat(arrayAudioBufferSink.output)\n         .hasLength(\n@@ -167,8 +211,12 @@ public void trimsStartAndEndFrames() throws Exception {\n         CHANNEL_COUNT_STEREO,\n         /* trimStartFrames= */ TRIM_100_MS_FRAME_COUNT,\n         /* trimEndFrames= */ TRIM_10_MS_FRAME_COUNT);\n-    defaultAudioSink.handleBuffer(\n-        createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0, /* encodedAccessUnitCount= */ 1);\n+    assertThat(\n+            defaultAudioSink.handleBuffer(\n+                createDefaultSilenceBuffer(),\n+                /* presentationTimeUs= */ 0,\n+                /* encodedAccessUnitCount= */ 1))\n+        .isTrue();\n \n     assertThat(arrayAudioBufferSink.output)\n         .hasLength(\n@@ -180,19 +228,23 @@ public void trimsStartAndEndFrames() throws Exception {\n   @Test\n   public void getCurrentPosition_returnsPositionFromFirstBuffer() throws Exception {\n     configureDefaultAudioSink(CHANNEL_COUNT_STEREO);\n-    defaultAudioSink.handleBuffer(\n-        createDefaultSilenceBuffer(),\n-        /* presentationTimeUs= */ 5 * C.MICROS_PER_SECOND,\n-        /* encodedAccessUnitCount= */ 1);\n+    assertThat(\n+            defaultAudioSink.handleBuffer(\n+                createDefaultSilenceBuffer(),\n+                /* presentationTimeUs= */ 5 * C.MICROS_PER_SECOND,\n+                /* encodedAccessUnitCount= */ 1))\n+        .isTrue();\n     assertThat(defaultAudioSink.getCurrentPositionUs(/* sourceEnded= */ false))\n         .isEqualTo(5 * C.MICROS_PER_SECOND);\n \n     defaultAudioSink.reset();\n     configureDefaultAudioSink(CHANNEL_COUNT_STEREO);\n-    defaultAudioSink.handleBuffer(\n-        createDefaultSilenceBuffer(),\n-        /* presentationTimeUs= */ 8 * C.MICROS_PER_SECOND,\n-        /* encodedAccessUnitCount= */ 1);\n+    retryUntilTrue(\n+        () ->\n+            defaultAudioSink.handleBuffer(\n+                createDefaultSilenceBuffer(),\n+                /* presentationTimeUs= */ 8 * C.MICROS_PER_SECOND,\n+                /* encodedAccessUnitCount= */ 1));\n     assertThat(defaultAudioSink.getCurrentPositionUs(/* sourceEnded= */ false))\n         .isEqualTo(8 * C.MICROS_PER_SECOND);\n   }\n@@ -269,24 +321,32 @@ public void handlesBufferAfterExperimentalFlush() throws Exception {\n     // This is demonstrating that no Exceptions are thrown as a result of handling a buffer after an\n     // experimental flush.\n     configureDefaultAudioSink(CHANNEL_COUNT_STEREO);\n-    defaultAudioSink.handleBuffer(\n-        createDefaultSilenceBuffer(), /* presentationTimeUs= */ 0, /* encodedAccessUnitCount= */ 1);\n+    assertThat(\n+            defaultAudioSink.handleBuffer(\n+                createDefaultSilenceBuffer(),\n+                /* presentationTimeUs= */ 0,\n+                /* encodedAccessUnitCount= */ 1))\n+        .isTrue();\n \n     // After the experimental flush we can successfully queue more input.\n     defaultAudioSink.experimentalFlushWithoutAudioTrackRelease();\n-    defaultAudioSink.handleBuffer(\n-        createDefaultSilenceBuffer(),\n-        /* presentationTimeUs= */ 5_000,\n-        /* encodedAccessUnitCount= */ 1);\n+    assertThat(\n+            defaultAudioSink.handleBuffer(\n+                createDefaultSilenceBuffer(),\n+                /* presentationTimeUs= */ 5_000,\n+                /* encodedAccessUnitCount= */ 1))\n+        .isTrue();\n   }\n \n   @Test\n   public void getCurrentPosition_returnsUnset_afterExperimentalFlush() throws Exception {\n     configureDefaultAudioSink(CHANNEL_COUNT_STEREO);\n-    defaultAudioSink.handleBuffer(\n-        createDefaultSilenceBuffer(),\n-        /* presentationTimeUs= */ 5 * C.MICROS_PER_SECOND,\n-        /* encodedAccessUnitCount= */ 1);\n+    assertThat(\n+            defaultAudioSink.handleBuffer(\n+                createDefaultSilenceBuffer(),\n+                /* presentationTimeUs= */ 5 * C.MICROS_PER_SECOND,\n+                /* encodedAccessUnitCount= */ 1))\n+        .isTrue();\n     defaultAudioSink.experimentalFlushWithoutAudioTrackRelease();\n     assertThat(defaultAudioSink.getCurrentPositionUs(/* sourceEnded= */ false))\n         .isEqualTo(CURRENT_POSITION_NOT_SET);\n@@ -310,10 +370,12 @@ public void setPlaybackParameters_doesNothingWhenTunnelingIsEnabled() throws Exc\n     defaultAudioSink.enableTunnelingV21();\n     defaultAudioSink.setPlaybackParameters(new PlaybackParameters(2));\n     configureDefaultAudioSink(/* channelCount= */ 2);\n-    defaultAudioSink.handleBuffer(\n-        createDefaultSilenceBuffer(),\n-        /* presentationTimeUs= */ 5 * C.MICROS_PER_SECOND,\n-        /* encodedAccessUnitCount= */ 1);\n+    assertThat(\n+            defaultAudioSink.handleBuffer(\n+                createDefaultSilenceBuffer(),\n+                /* presentationTimeUs= */ 5 * C.MICROS_PER_SECOND,\n+                /* encodedAccessUnitCount= */ 1))\n+        .isTrue();\n \n     assertThat(defaultAudioSink.getPlaybackParameters().speed).isEqualTo(1);\n   }\n@@ -343,6 +405,19 @@ private static ByteBuffer createDefaultSilenceBuffer() {\n         .order(ByteOrder.nativeOrder());\n   }\n \n+  private interface ThrowingBooleanMethod {\n+    boolean run() throws Exception;\n+  }\n+\n+  private static void retryUntilTrue(ThrowingBooleanMethod booleanMethod) throws Exception {\n+    long timeoutTimeMs = System.currentTimeMillis() + TIMEOUT_MS;\n+    while (!booleanMethod.run()) {\n+      if (System.currentTimeMillis() >= timeoutTimeMs) {\n+        throw new TimeoutException();\n+      }\n+    }\n+  }\n+\n   private static final class ArrayAudioBufferSink implements TeeAudioProcessor.AudioBufferSink {\n \n     private byte[] output;",
      "parent_sha": "4068833541e8be4e94f60bf88d62b0f6a829f9f0"
    }
  },
  {
    "oid": "121486738bf8e1ddde60290e46453926ab9f6937",
    "message": "10* was an experiment, not wanted.",
    "date": "2017-01-13T08:48:53Z",
    "url": "https://github.com/google/ExoPlayer/commit/121486738bf8e1ddde60290e46453926ab9f6937",
    "details": {
      "sha": "2a8d4245f06b7a6830af29aac6d14b62b72b4518",
      "filename": "library/src/main/java/com/google/android/exoplayer2/text/ssa/SSASubtitle.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/ExoPlayer/blob/121486738bf8e1ddde60290e46453926ab9f6937/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftext%2Fssa%2FSSASubtitle.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/121486738bf8e1ddde60290e46453926ab9f6937/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftext%2Fssa%2FSSASubtitle.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftext%2Fssa%2FSSASubtitle.java?ref=121486738bf8e1ddde60290e46453926ab9f6937",
      "patch": "@@ -101,7 +101,7 @@ protected void addEvent(Map<String,String> ev, Map<String,Style> styles) {\n         cueTimesUs.add(start);\n         cues.add(cue);\n         // add null cue to remove this cue after it's duration\n-        long end = 10*SSADecoder.parseTimecode(ev.get(\"end\"));\n+        long end = SSADecoder.parseTimecode(ev.get(\"end\"));\n         cueTimesUs.add(end);\n         cues.add(null);\n     }",
      "parent_sha": "ff64d2b382e68327db69c4e6df4e82be0c1884bc"
    }
  },
  {
    "oid": "6bc04082224daae7440e555ecc357abc9aecc99f",
    "message": "Make BasePlayer.get[Next/Previous]WindowIndex more useful\n\nWhen in REPEAT_MODE_ONE, it's unlikely apps want next/previous methods\non the player to keep them in the same window. Music apps in particular\ntend to implement next/previous functionality as though repeat mode were\noff when in this mode (i.e. current song loops forever during playback,\nbut next/previous navigation still navigates to next/previous items).\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=220469655",
    "date": "2018-11-07T18:05:25Z",
    "url": "https://github.com/google/ExoPlayer/commit/6bc04082224daae7440e555ecc357abc9aecc99f",
    "details": {
      "sha": "f1b54153a1117d232da77dbc8bc6e54c64f8b0f1",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java",
      "status": "modified",
      "additions": 8,
      "deletions": 2,
      "changes": 10,
      "blob_url": "https://github.com/google/ExoPlayer/blob/6bc04082224daae7440e555ecc357abc9aecc99f/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FBasePlayer.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/6bc04082224daae7440e555ecc357abc9aecc99f/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FBasePlayer.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FBasePlayer.java?ref=6bc04082224daae7440e555ecc357abc9aecc99f",
      "patch": "@@ -79,7 +79,7 @@ public final int getNextWindowIndex() {\n     return timeline.isEmpty()\n         ? C.INDEX_UNSET\n         : timeline.getNextWindowIndex(\n-            getCurrentWindowIndex(), getRepeatMode(), getShuffleModeEnabled());\n+            getCurrentWindowIndex(), getRepeatModeForNavigation(), getShuffleModeEnabled());\n   }\n \n   @Override\n@@ -88,7 +88,7 @@ public final int getPreviousWindowIndex() {\n     return timeline.isEmpty()\n         ? C.INDEX_UNSET\n         : timeline.getPreviousWindowIndex(\n-            getCurrentWindowIndex(), getRepeatMode(), getShuffleModeEnabled());\n+            getCurrentWindowIndex(), getRepeatModeForNavigation(), getShuffleModeEnabled());\n   }\n \n   @Override\n@@ -129,4 +129,10 @@ public final long getContentDuration() {\n         ? C.TIME_UNSET\n         : timeline.getWindow(getCurrentWindowIndex(), window).getDurationMs();\n   }\n+\n+  @RepeatMode\n+  private int getRepeatModeForNavigation() {\n+    @RepeatMode int repeatMode = getRepeatMode();\n+    return repeatMode == REPEAT_MODE_ONE ? REPEAT_MODE_OFF : repeatMode;\n+  }\n }",
      "parent_sha": "fd98d70a113baf67d173714ae781bc0315e2f2f6"
    }
  },
  {
    "oid": "28a7e59d7bb45ca9252c585bd239790881a90d08",
    "message": "Fix javadoc\n\nPiperOrigin-RevId: 316071392",
    "date": "2020-06-12T17:11:12Z",
    "url": "https://github.com/google/ExoPlayer/commit/28a7e59d7bb45ca9252c585bd239790881a90d08",
    "details": {
      "sha": "3a51d34e2060b70a05837b29d9ef5040c6e203e4",
      "filename": "library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/google/ExoPlayer/blob/28a7e59d7bb45ca9252c585bd239790881a90d08/library%2Fdash%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fdash%2Fmanifest%2FDashManifestParser.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/28a7e59d7bb45ca9252c585bd239790881a90d08/library%2Fdash%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fdash%2Fmanifest%2FDashManifestParser.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fdash%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fdash%2Fmanifest%2FDashManifestParser.java?ref=28a7e59d7bb45ca9252c585bd239790881a90d08",
      "patch": "@@ -841,9 +841,8 @@ protected SegmentTemplate buildSegmentTemplate(\n   }\n \n   /**\n-   * /**\n    * Parses a single EventStream node in the manifest.\n-   * <p>\n+   *\n    * @param xpp The current xml parser.\n    * @return The {@link EventStream} parsed from this EventStream node.\n    * @throws XmlPullParserException If there is any error parsing this node.",
      "parent_sha": "df86278289c64d1906437c9d5e8ede058a0cadaf"
    }
  },
  {
    "oid": "534cfc7968cee1a8469ac3c00ae53aae3e4b9553",
    "message": "Misc fix on parameter comment\n\nPiperOrigin-RevId: 446181877",
    "date": "2022-05-09T09:50:31Z",
    "url": "https://github.com/google/ExoPlayer/commit/534cfc7968cee1a8469ac3c00ae53aae3e4b9553",
    "details": {
      "sha": "575faf8c8b9d1af03124f6063a90cd0fe4488b79",
      "filename": "libraries/exoplayer_ima/src/test/java/androidx/media3/exoplayer/ima/ImaAdsLoaderTest.java",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/google/ExoPlayer/blob/534cfc7968cee1a8469ac3c00ae53aae3e4b9553/libraries%2Fexoplayer_ima%2Fsrc%2Ftest%2Fjava%2Fandroidx%2Fmedia3%2Fexoplayer%2Fima%2FImaAdsLoaderTest.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/534cfc7968cee1a8469ac3c00ae53aae3e4b9553/libraries%2Fexoplayer_ima%2Fsrc%2Ftest%2Fjava%2Fandroidx%2Fmedia3%2Fexoplayer%2Fima%2FImaAdsLoaderTest.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/libraries%2Fexoplayer_ima%2Fsrc%2Ftest%2Fjava%2Fandroidx%2Fmedia3%2Fexoplayer%2Fima%2FImaAdsLoaderTest.java?ref=534cfc7968cee1a8469ac3c00ae53aae3e4b9553",
      "patch": "@@ -296,8 +296,8 @@ public void playback_withPrerollAd_marksAdAsPlayed() {\n         /* periodIndex= */ 0,\n         /* adGroupIndex= */ 0,\n         /* adIndexInAdGroup= */ 0,\n-        /* position= */ 0,\n-        /* contentPosition= */ 0);\n+        /* positionMs= */ 0,\n+        /* contentPositionMs= */ 0);\n     fakePlayer.setState(Player.STATE_READY, /* playWhenReady= */ true);\n     adEventListener.onAdEvent(getAdEvent(AdEventType.STARTED, mockPrerollSingleAd));\n     adEventListener.onAdEvent(getAdEvent(AdEventType.FIRST_QUARTILE, mockPrerollSingleAd));\n@@ -1096,8 +1096,8 @@ public void playbackWithTwoAdsMediaSources_preloadsSecondAdTag() {\n         /* periodIndex= */ 0,\n         /* adGroupIndex= */ 0,\n         /* adIndexInAdGroup= */ 0,\n-        /* position= */ 0,\n-        /* contentPosition= */ 0);\n+        /* positionMs= */ 0,\n+        /* contentPositionMs= */ 0);\n     fakePlayer.setState(Player.STATE_READY, /* playWhenReady= */ true);\n     adEventListener.onAdEvent(getAdEvent(AdEventType.STARTED, mockPrerollSingleAd));\n     adEventListener.onAdEvent(getAdEvent(AdEventType.FIRST_QUARTILE, mockPrerollSingleAd));\n@@ -1155,8 +1155,8 @@ public void playbackWithTwoAdsMediaSources_preloadsSecondAdTagWithBackgroundResu\n         /* periodIndex= */ 0,\n         /* adGroupIndex= */ 0,\n         /* adIndexInAdGroup= */ 0,\n-        /* position= */ 0,\n-        /* contentPosition= */ 0);\n+        /* positionMs= */ 0,\n+        /* contentPositionMs= */ 0);\n     fakePlayer.setState(Player.STATE_READY, /* playWhenReady= */ true);\n     adEventListener.onAdEvent(getAdEvent(AdEventType.STARTED, mockPrerollSingleAd));\n     adEventListener.onAdEvent(getAdEvent(AdEventType.FIRST_QUARTILE, mockPrerollSingleAd));",
      "parent_sha": "e521a8cc900e26ab1d497e1ccc45f2bb489ef96e"
    }
  },
  {
    "oid": "9246fbbe7d838c02462408636d02a6fd1c2763a7",
    "message": "Add exception type for manifest load errors.",
    "date": "2015-10-26T15:33:53Z",
    "url": "https://github.com/google/ExoPlayer/commit/9246fbbe7d838c02462408636d02a6fd1c2763a7",
    "details": {
      "sha": "c34e0c4f8ecd8d006513a69733ff0e724bc79f6c",
      "filename": "library/src/main/java/com/google/android/exoplayer/util/ManifestFetcher.java",
      "status": "modified",
      "additions": 14,
      "deletions": 5,
      "changes": 19,
      "blob_url": "https://github.com/google/ExoPlayer/blob/9246fbbe7d838c02462408636d02a6fd1c2763a7/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer%2Futil%2FManifestFetcher.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/9246fbbe7d838c02462408636d02a6fd1c2763a7/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer%2Futil%2FManifestFetcher.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer%2Futil%2FManifestFetcher.java?ref=9246fbbe7d838c02462408636d02a6fd1c2763a7",
      "patch": "@@ -48,6 +48,14 @@\n  */\n public class ManifestFetcher<T> implements Loader.Callback {\n \n+  /**\n+   * Thrown when an error occurs trying to fetch a manifest.\n+   */\n+  public static final class ManifestIOException extends IOException{\n+    public ManifestIOException(Throwable cause) { super(cause); }\n+\n+  }\n+\n   /**\n    * Interface definition for a callback to be notified of {@link ManifestFetcher} events.\n    */\n@@ -112,7 +120,7 @@ public interface RedirectingManifest {\n \n   private int loadExceptionCount;\n   private long loadExceptionTimestamp;\n-  private IOException loadException;\n+  private ManifestIOException loadException;\n \n   private volatile T manifest;\n   private volatile long manifestLoadStartTimestamp;\n@@ -201,9 +209,10 @@ public long getManifestLoadCompleteTimestamp() {\n    * Throws the error that affected the most recent attempt to load the manifest. Does nothing if\n    * the most recent attempt was successful.\n    *\n-   * @throws IOException The error that affected the most recent attempt to load the manifest.\n+   * @throws ManifestIOException The error that affected the most recent attempt to load the\n+   *     manifest.\n    */\n-  public void maybeThrowError() throws IOException {\n+  public void maybeThrowError() throws ManifestIOException {\n     // Don't throw an exception until at least 1 retry attempt has been made.\n     if (loadException == null || loadExceptionCount <= 1) {\n       return;\n@@ -291,7 +300,7 @@ public void onLoadError(Loadable loadable, IOException exception) {\n \n     loadExceptionCount++;\n     loadExceptionTimestamp = SystemClock.elapsedRealtime();\n-    loadException = new IOException(exception);\n+    loadException = new ManifestIOException(exception);\n \n     notifyManifestError(loadException);\n   }\n@@ -376,7 +385,7 @@ public void onLoadCompleted(Loadable loadable) {\n     public void onLoadCanceled(Loadable loadable) {\n       // This shouldn't ever happen, but handle it anyway.\n       try {\n-        IOException exception = new IOException(\"Load cancelled\", new CancellationException());\n+        IOException exception = new ManifestIOException(new CancellationException());\n         wrappedCallback.onSingleManifestError(exception);\n       } finally {\n         releaseLoader();",
      "parent_sha": "f3113e7055bb2474d52f192a8fbacf752d35de22"
    }
  },
  {
    "oid": "e2fc5c21906aa17859a51a4b6b8baf38c5f6106a",
    "message": "Fix EventLogger audio underrun logging\n\nPiperOrigin-RevId: 327610950",
    "date": "2020-08-21T11:51:23Z",
    "url": "https://github.com/google/ExoPlayer/commit/e2fc5c21906aa17859a51a4b6b8baf38c5f6106a",
    "details": {
      "sha": "9c55248fea894f0d254b0a69f433cafb5162f859",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/ExoPlayer/blob/e2fc5c21906aa17859a51a4b6b8baf38c5f6106a/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Futil%2FEventLogger.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/e2fc5c21906aa17859a51a4b6b8baf38c5f6106a/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Futil%2FEventLogger.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Futil%2FEventLogger.java?ref=e2fc5c21906aa17859a51a4b6b8baf38c5f6106a",
      "patch": "@@ -322,7 +322,7 @@ public void onAudioUnderrun(\n     loge(\n         eventTime,\n         \"audioTrackUnderrun\",\n-        bufferSize + \", \" + bufferSizeMs + \", \" + elapsedSinceLastFeedMs + \"]\",\n+        bufferSize + \", \" + bufferSizeMs + \", \" + elapsedSinceLastFeedMs,\n         /* throwable= */ null);\n   }\n ",
      "parent_sha": "74f788afc35893a9d4a87defe6985ef1d792f9c6"
    }
  },
  {
    "oid": "9a1e7fbdf41e9de1f5d69590a305ebfafaa3ad07",
    "message": "Bind contrastFactor in constructor instead of drawFrame method.\n\nPiperOrigin-RevId: 469438747",
    "date": "2022-10-19T19:17:24Z",
    "url": "https://github.com/google/ExoPlayer/commit/9a1e7fbdf41e9de1f5d69590a305ebfafaa3ad07",
    "details": {
      "sha": "e267862ffe9a438234ee0acbb9582b7b5b3d6e7a",
      "filename": "google3/third_party/java_src/android_libs/media/libraries/effect/src/main/java/androidx/media3/effect/ContrastProcessor.java",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/google/ExoPlayer/blob/9a1e7fbdf41e9de1f5d69590a305ebfafaa3ad07/google3%2Fthird_party%2Fjava_src%2Fandroid_libs%2Fmedia%2Flibraries%2Feffect%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Feffect%2FContrastProcessor.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/9a1e7fbdf41e9de1f5d69590a305ebfafaa3ad07/google3%2Fthird_party%2Fjava_src%2Fandroid_libs%2Fmedia%2Flibraries%2Feffect%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Feffect%2FContrastProcessor.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/google3%2Fthird_party%2Fjava_src%2Fandroid_libs%2Fmedia%2Flibraries%2Feffect%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Feffect%2FContrastProcessor.java?ref=9a1e7fbdf41e9de1f5d69590a305ebfafaa3ad07",
      "patch": "@@ -31,13 +31,12 @@\n   private static final String FRAGMENT_SHADER_PATH = \"shaders/fragment_shader_contrast_es2.glsl\";\n \n   private final GlProgram glProgram;\n-  private final float contrastFactor;\n \n   public ContrastProcessor(Context context, Contrast contrastEffect, boolean useHdr)\n       throws FrameProcessingException {\n     super(useHdr);\n     // Use 1.0001f to avoid division by zero issues.\n-    contrastFactor = (1 + contrastEffect.contrast) / (1.0001f - contrastEffect.contrast);\n+    float contrastFactor = (1 + contrastEffect.contrast) / (1.0001f - contrastEffect.contrast);\n \n     try {\n       glProgram = new GlProgram(context, VERTEX_SHADER_PATH, FRAGMENT_SHADER_PATH);\n@@ -55,6 +54,7 @@ public ContrastProcessor(Context context, Contrast contrastEffect, boolean useHd\n     Matrix.setIdentityM(identityMatrix, /* smOffset= */ 0);\n     glProgram.setFloatsUniform(\"uTransformationMatrix\", identityMatrix);\n     glProgram.setFloatsUniform(\"uTexTransformationMatrix\", identityMatrix);\n+    glProgram.setFloatUniform(\"uContrastFactor\", contrastFactor);\n   }\n \n   @Override\n@@ -67,7 +67,6 @@ public void drawFrame(int inputTexId, long presentationTimeUs) throws FrameProce\n     try {\n       glProgram.use();\n       glProgram.setSamplerTexIdUniform(\"uTexSampler\", inputTexId, /* texUnitIndex= */ 0);\n-      glProgram.setFloatUniform(\"uContrastFactor\", contrastFactor);\n       glProgram.bindAttributesAndUniforms();\n \n       // The four-vertex triangle strip forms a quad.",
      "parent_sha": "f01896af156efdafeaef6a5eb13e9d251a2e1d57"
    }
  },
  {
    "oid": "aec3e458d8847678b67569aefb819288dfd4052c",
    "message": "Use onEvents in PlayerNotificationManager\n\nThis saves a few lines of code and is nicer. We already did make sure to update the notification only once by posting because of b/145521438.\n\n#exofixit\n\nPiperOrigin-RevId: 343852256",
    "date": "2020-11-24T16:01:49Z",
    "url": "https://github.com/google/ExoPlayer/commit/aec3e458d8847678b67569aefb819288dfd4052c",
    "details": {
      "sha": "939980e231ef64b4fc55d0c6f961faaba1aa16ce",
      "filename": "library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java",
      "status": "modified",
      "additions": 21,
      "deletions": 39,
      "changes": 60,
      "blob_url": "https://github.com/google/ExoPlayer/blob/aec3e458d8847678b67569aefb819288dfd4052c/library%2Fui%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FPlayerNotificationManager.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/aec3e458d8847678b67569aefb819288dfd4052c/library%2Fui%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FPlayerNotificationManager.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fui%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FPlayerNotificationManager.java?ref=aec3e458d8847678b67569aefb819288dfd4052c",
      "patch": "@@ -15,6 +15,15 @@\n  */\n package com.google.android.exoplayer2.ui;\n \n+import static com.google.android.exoplayer2.Player.EVENT_IS_PLAYING_CHANGED;\n+import static com.google.android.exoplayer2.Player.EVENT_PLAYBACK_PARAMETERS_CHANGED;\n+import static com.google.android.exoplayer2.Player.EVENT_PLAYBACK_STATE_CHANGED;\n+import static com.google.android.exoplayer2.Player.EVENT_PLAY_WHEN_READY_CHANGED;\n+import static com.google.android.exoplayer2.Player.EVENT_POSITION_DISCONTINUITY;\n+import static com.google.android.exoplayer2.Player.EVENT_REPEAT_MODE_CHANGED;\n+import static com.google.android.exoplayer2.Player.EVENT_SHUFFLE_MODE_ENABLED_CHANGED;\n+import static com.google.android.exoplayer2.Player.EVENT_TIMELINE_CHANGED;\n+\n import android.app.Notification;\n import android.app.NotificationChannel;\n import android.app.PendingIntent;\n@@ -38,7 +47,6 @@\n import com.google.android.exoplayer2.C;\n import com.google.android.exoplayer2.ControlDispatcher;\n import com.google.android.exoplayer2.DefaultControlDispatcher;\n-import com.google.android.exoplayer2.PlaybackParameters;\n import com.google.android.exoplayer2.PlaybackPreparer;\n import com.google.android.exoplayer2.Player;\n import com.google.android.exoplayer2.Timeline;\n@@ -1331,44 +1339,18 @@ private static void setLargeIcon(NotificationCompat.Builder builder, @Nullable B\n   private class PlayerListener implements Player.EventListener {\n \n     @Override\n-    public void onPlaybackStateChanged(@Player.State int playbackState) {\n-      postStartOrUpdateNotification();\n-    }\n-\n-    @Override\n-    public void onPlayWhenReadyChanged(\n-        boolean playWhenReady, @Player.PlayWhenReadyChangeReason int reason) {\n-      postStartOrUpdateNotification();\n-    }\n-\n-    @Override\n-    public void onIsPlayingChanged(boolean isPlaying) {\n-      postStartOrUpdateNotification();\n-    }\n-\n-    @Override\n-    public void onTimelineChanged(Timeline timeline, int reason) {\n-      postStartOrUpdateNotification();\n-    }\n-\n-    @Override\n-    public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {\n-      postStartOrUpdateNotification();\n-    }\n-\n-    @Override\n-    public void onPositionDiscontinuity(int reason) {\n-      postStartOrUpdateNotification();\n-    }\n-\n-    @Override\n-    public void onRepeatModeChanged(@Player.RepeatMode int repeatMode) {\n-      postStartOrUpdateNotification();\n-    }\n-\n-    @Override\n-    public void onShuffleModeEnabledChanged(boolean shuffleModeEnabled) {\n-      postStartOrUpdateNotification();\n+    public void onEvents(Player player, Player.Events events) {\n+      if (events.containsAny(\n+          EVENT_PLAYBACK_STATE_CHANGED,\n+          EVENT_PLAY_WHEN_READY_CHANGED,\n+          EVENT_IS_PLAYING_CHANGED,\n+          EVENT_TIMELINE_CHANGED,\n+          EVENT_PLAYBACK_PARAMETERS_CHANGED,\n+          EVENT_POSITION_DISCONTINUITY,\n+          EVENT_REPEAT_MODE_CHANGED,\n+          EVENT_SHUFFLE_MODE_ENABLED_CHANGED)) {\n+        postStartOrUpdateNotification();\n+      }\n     }\n   }\n ",
      "parent_sha": "b562adf26c2ef4dbebf14810bcd2ed010a98be3b"
    }
  },
  {
    "oid": "5d743000ec8ed37dc40e53fe1b51fc2a741ea494",
    "message": "Transformer GL: Explicitly label ignored values.\n\nRefactor GlUtil.java to be a bit more readable. Also, reorder, inline, and\nrename a few things. Refactoring change only. No functional changes intended.\n\nPiperOrigin-RevId: 415283874",
    "date": "2021-12-10T11:23:08Z",
    "url": "https://github.com/google/ExoPlayer/commit/5d743000ec8ed37dc40e53fe1b51fc2a741ea494",
    "details": {
      "sha": "b695cf1314e098786d0846fc268b6e64d117b459",
      "filename": "libraries/common/src/main/java/androidx/media3/common/util/GlUtil.java",
      "status": "modified",
      "additions": 23,
      "deletions": 35,
      "changes": 58,
      "blob_url": "https://github.com/google/ExoPlayer/blob/5d743000ec8ed37dc40e53fe1b51fc2a741ea494/libraries%2Fcommon%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fcommon%2Futil%2FGlUtil.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/5d743000ec8ed37dc40e53fe1b51fc2a741ea494/libraries%2Fcommon%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fcommon%2Futil%2FGlUtil.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/libraries%2Fcommon%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fcommon%2Futil%2FGlUtil.java?ref=5d743000ec8ed37dc40e53fe1b51fc2a741ea494",
      "patch": "@@ -315,8 +315,7 @@ public static void focusSurface(\n    * @param textureId The ID of the texture to delete.\n    */\n   public static void deleteTexture(int textureId) {\n-    int[] textures = new int[] {textureId};\n-    GLES20.glDeleteTextures(/* n= */ 1, textures, /* offset= */ 0);\n+    GLES20.glDeleteTextures(/* n= */ 1, new int[] {textureId}, /* offset= */ 0);\n     checkGlError();\n   }\n \n@@ -444,21 +443,17 @@ public static Attribute create(int programId, int index) {\n       int[] length = new int[1];\n       GLES20.glGetProgramiv(\n           programId, GLES20.GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, length, /* offset= */ 0);\n-\n-      int[] type = new int[1];\n-      int[] size = new int[1];\n       byte[] nameBytes = new byte[length[0]];\n-      int[] ignore = new int[1];\n \n       GLES20.glGetActiveAttrib(\n           programId,\n           index,\n           length[0],\n-          ignore,\n+          /* unusedLength */ new int[1],\n           /* lengthOffset= */ 0,\n-          size,\n+          /* unusedSize */ new int[1],\n           /* sizeOffset= */ 0,\n-          type,\n+          /* unusedType */ new int[1],\n           /* typeOffset= */ 0,\n           nameBytes,\n           /* nameOffset= */ 0);\n@@ -522,17 +517,15 @@ public static Uniform create(int programId, int index) {\n           programId, GLES20.GL_ACTIVE_UNIFORM_MAX_LENGTH, length, /* offset= */ 0);\n \n       int[] type = new int[1];\n-      int[] size = new int[1];\n       byte[] nameBytes = new byte[length[0]];\n-      int[] ignore = new int[1];\n \n       GLES20.glGetActiveUniform(\n           programId,\n           index,\n           length[0],\n-          ignore,\n+          /* unusedLength */ new int[1],\n           /* lengthOffset= */ 0,\n-          size,\n+          /* unusedSize */ new int[1],\n           /*sizeOffset= */ 0,\n           type,\n           /* typeOffset= */ 0,\n@@ -632,10 +625,12 @@ private Api17() {}\n     public static EGLDisplay createEglDisplay() {\n       EGLDisplay eglDisplay = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);\n       checkEglException(!eglDisplay.equals(EGL14.EGL_NO_DISPLAY), \"No EGL display.\");\n-      int[] major = new int[1];\n-      int[] minor = new int[1];\n       if (!EGL14.eglInitialize(\n-          eglDisplay, major, /* majorOffset= */ 0, minor, /* minorOffset= */ 0)) {\n+          eglDisplay,\n+          /* unusedMajor */ new int[1],\n+          /* majorOffset= */ 0,\n+          /* unusedMinor */ new int[1],\n+          /* minorOffset= */ 0)) {\n         throwGlException(\"Error in eglInitialize.\");\n       }\n       checkGlError();\n@@ -674,11 +669,11 @@ public static EGLSurface getEglSurface(EGLDisplay eglDisplay, Object surface) {\n     @DoNotInline\n     public static void focusSurface(\n         EGLDisplay eglDisplay, EGLContext eglContext, EGLSurface surface, int width, int height) {\n-      int[] fbos = new int[1];\n-      GLES20.glGetIntegerv(GLES20.GL_FRAMEBUFFER_BINDING, fbos, /* offset= */ 0);\n-      int noFbo = 0;\n-      if (fbos[0] != noFbo) {\n-        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, noFbo);\n+      int[] boundFrameBuffer = new int[1];\n+      GLES20.glGetIntegerv(GLES20.GL_FRAMEBUFFER_BINDING, boundFrameBuffer, /* offset= */ 0);\n+      int defaultFrameBuffer = 0;\n+      if (boundFrameBuffer[0] != defaultFrameBuffer) {\n+        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, defaultFrameBuffer);\n       }\n       EGL14.eglMakeCurrent(eglDisplay, surface, surface, eglContext);\n       GLES20.glViewport(/* x= */ 0, /* y= */ 0, width, height);\n@@ -709,24 +704,17 @@ public static void destroyEglContext(\n \n     @DoNotInline\n     private static EGLConfig getEglConfig(EGLDisplay eglDisplay) {\n-      int redSize = 8;\n-      int greenSize = 8;\n-      int blueSize = 8;\n-      int alphaSize = 8;\n-      int depthSize = 0;\n-      int stencilSize = 0;\n       int[] defaultConfiguration =\n           new int[] {\n             EGL14.EGL_RENDERABLE_TYPE, EGL14.EGL_OPENGL_ES2_BIT,\n-            EGL14.EGL_RED_SIZE, redSize,\n-            EGL14.EGL_GREEN_SIZE, greenSize,\n-            EGL14.EGL_BLUE_SIZE, blueSize,\n-            EGL14.EGL_ALPHA_SIZE, alphaSize,\n-            EGL14.EGL_DEPTH_SIZE, depthSize,\n-            EGL14.EGL_STENCIL_SIZE, stencilSize,\n+            EGL14.EGL_RED_SIZE, /* redSize= */ 8,\n+            EGL14.EGL_GREEN_SIZE, /* greenSize= */ 8,\n+            EGL14.EGL_BLUE_SIZE, /* blueSize= */ 8,\n+            EGL14.EGL_ALPHA_SIZE, /* alphaSize= */ 8,\n+            EGL14.EGL_DEPTH_SIZE, /* depthSize= */ 0,\n+            EGL14.EGL_STENCIL_SIZE, /* stencilSize= */ 0,\n             EGL14.EGL_NONE\n           };\n-      int[] configsCount = new int[1];\n       EGLConfig[] eglConfigs = new EGLConfig[1];\n       if (!EGL14.eglChooseConfig(\n           eglDisplay,\n@@ -735,7 +723,7 @@ private static EGLConfig getEglConfig(EGLDisplay eglDisplay) {\n           eglConfigs,\n           /* configsOffset= */ 0,\n           /* config_size= */ 1,\n-          configsCount,\n+          /* unusedNumConfig */ new int[1],\n           /* num_configOffset= */ 0)) {\n         throwGlException(\"eglChooseConfig failed.\");\n       }",
      "parent_sha": "422a003a033862ce0d9b7bf49c094b7a04cced2b"
    }
  },
  {
    "oid": "de641380dff07dc1d798d84c9a4f367e0c24ad7d",
    "message": "Improve WakeLock/AudioBecomingNoisy Javadoc\n\nPiperOrigin-RevId: 281764207",
    "date": "2019-11-22T15:39:10Z",
    "url": "https://github.com/google/ExoPlayer/commit/de641380dff07dc1d798d84c9a4f367e0c24ad7d",
    "details": {
      "sha": "52b686000a45191760cfec2fdf715d5c4a1bc84d",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java",
      "status": "modified",
      "additions": 16,
      "deletions": 9,
      "changes": 25,
      "blob_url": "https://github.com/google/ExoPlayer/blob/de641380dff07dc1d798d84c9a4f367e0c24ad7d/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FSimpleExoPlayer.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/de641380dff07dc1d798d84c9a4f367e0c24ad7d/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FSimpleExoPlayer.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FSimpleExoPlayer.java?ref=de641380dff07dc1d798d84c9a4f367e0c24ad7d",
      "patch": "@@ -801,7 +801,10 @@ public void removeAnalyticsListener(AnalyticsListener listener) {\n    * href=\"https://developer.android.com/guide/topics/media-apps/volume-and-earphones#becoming-noisy\">audio\n    * becoming noisy</a> documentation for more information.\n    *\n-   * @param handleAudioBecomingNoisy True if the player should handle audio becoming noisy.\n+   * <p>This feature is not enabled by default.\n+   *\n+   * @param handleAudioBecomingNoisy Whether the player should pause automatically when audio is\n+   *     rerouted from a headset to device speakers.\n    */\n   public void setHandleAudioBecomingNoisy(boolean handleAudioBecomingNoisy) {\n     verifyApplicationThread();\n@@ -1415,16 +1418,20 @@ public long getContentBufferedPosition() {\n   }\n \n   /**\n-   * Sets whether to enable the acquiring and releasing of a {@link\n-   * android.os.PowerManager.WakeLock}.\n+   * Sets whether the player should use a {@link android.os.PowerManager.WakeLock} to ensure the\n+   * device stays awake for playback, even when the screen is off.\n+   *\n+   * <p>Enabling this feature requires the {@link android.Manifest.permission#WAKE_LOCK} permission.\n+   * It should be used together with a foreground {@link android.app.Service} for use cases where\n+   * playback can occur when the screen is off (e.g. background audio playback). It is not useful if\n+   * the screen will always be on during playback (e.g. foreground video playback).\n    *\n-   * <p>By default, automatic wake lock handling is not enabled. Enabling this on will acquire the\n-   * WakeLock if necessary. Disabling this will release the WakeLock if it is held.\n+   * <p>This feature is not enabled by default. If enabled, a WakeLock is held whenever the player\n+   * is in the {@link #STATE_READY READY} or {@link #STATE_BUFFERING BUFFERING} states with {@code\n+   * playWhenReady = true}.\n    *\n-   * @param handleWakeLock True if the player should handle a {@link\n-   *     android.os.PowerManager.WakeLock}, false otherwise. This is for use with a foreground\n-   *     {@link android.app.Service}, for allowing audio playback with the screen off. Please note\n-   *     that enabling this requires the {@link android.Manifest.permission#WAKE_LOCK} permission.\n+   * @param handleWakeLock Whether the player should use a {@link android.os.PowerManager.WakeLock}\n+   *     to ensure the device stays awake for playback, even when the screen is off.\n    */\n   public void setHandleWakeLock(boolean handleWakeLock) {\n     wakeLockManager.setEnabled(handleWakeLock);",
      "parent_sha": "d82da93ec4e25e845b3c596fe32c489e5eb1c780"
    }
  },
  {
    "oid": "7c85ca08cfc982bb50b5c3a8ac8fbde4d23a9a57",
    "message": "Fix ExtractorAsserts Javadoc\n\nPiperOrigin-RevId: 294184891",
    "date": "2020-02-11T17:11:26Z",
    "url": "https://github.com/google/ExoPlayer/commit/7c85ca08cfc982bb50b5c3a8ac8fbde4d23a9a57",
    "details": {
      "sha": "d17ac939ee30b853b9110fd4cff500196a813730",
      "filename": "testutils/src/main/java/com/google/android/exoplayer2/testutil/ExtractorAsserts.java",
      "status": "modified",
      "additions": 3,
      "deletions": 5,
      "changes": 8,
      "blob_url": "https://github.com/google/ExoPlayer/blob/7c85ca08cfc982bb50b5c3a8ac8fbde4d23a9a57/testutils%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftestutil%2FExtractorAsserts.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/7c85ca08cfc982bb50b5c3a8ac8fbde4d23a9a57/testutils%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftestutil%2FExtractorAsserts.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/testutils%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftestutil%2FExtractorAsserts.java?ref=7c85ca08cfc982bb50b5c3a8ac8fbde4d23a9a57",
      "patch": "@@ -170,10 +170,8 @@ public static void assertOutput(\n   }\n \n   /**\n-   * Asserts that {@code extractor} consumes {@code sampleFile} successfully and its output equals\n-   * to a prerecorded output dump file with the name {@code sampleFile} + \"{@value\n-   * #DUMP_EXTENSION}\". If {@code simulateUnknownLength} is true and {@code sampleFile} + \"{@value\n-   * #UNKNOWN_LENGTH_EXTENSION}\" exists, it's preferred.\n+   * Asserts that {@code extractor} consumes {@code data} successfully and that its output for\n+   * various initial seek times and for a known and unknown length matches prerecorded dump files.\n    *\n    * @param extractor The {@link Extractor} to be tested.\n    * @param dumpFilesPrefix The dump files prefix appended to the dump files path.\n@@ -295,7 +293,7 @@ private static void assertThrows(\n   }\n \n   /**\n-   * Asserts {@code extractor} throws {@code expectedThrowable} while consuming {@code sampleFile}.\n+   * Asserts {@code extractor} throws {@code expectedThrowable} while consuming {@code fileData}.\n    *\n    * @param extractor The {@link Extractor} to be tested.\n    * @param fileData Content of the input file.",
      "parent_sha": "7d19a85c5936d61de0ab56cd6fd940c4aae1e23f"
    }
  },
  {
    "oid": "c1bfab3c23a6c6eafc5842ba13f59cff1df8b6ee",
    "message": "Fix a minor bug with AdaptiveTrackSelection.\n\nWhen updating track selection, we should only revert back from ideal\ntrack selection to current track selection if the currently selected\ntrack is not black-listed.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=158135644",
    "date": "2017-06-06T15:42:14Z",
    "url": "https://github.com/google/ExoPlayer/commit/c1bfab3c23a6c6eafc5842ba13f59cff1df8b6ee",
    "details": {
      "sha": "50eaaa02e3091efc4e2d477325c3c2c534b4b7f4",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/google/ExoPlayer/blob/c1bfab3c23a6c6eafc5842ba13f59cff1df8b6ee/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftrackselection%2FAdaptiveTrackSelection.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/c1bfab3c23a6c6eafc5842ba13f59cff1df8b6ee/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftrackselection%2FAdaptiveTrackSelection.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftrackselection%2FAdaptiveTrackSelection.java?ref=c1bfab3c23a6c6eafc5842ba13f59cff1df8b6ee",
      "patch": "@@ -156,13 +156,13 @@ public void updateSelectedTrack(long bufferedDurationUs) {\n     long nowMs = SystemClock.elapsedRealtime();\n     // Get the current and ideal selections.\n     int currentSelectedIndex = selectedIndex;\n-    Format currentFormat = getSelectedFormat();\n     int idealSelectedIndex = determineIdealSelectedIndex(nowMs);\n-    Format idealFormat = getFormat(idealSelectedIndex);\n     // Assume we can switch to the ideal selection.\n     selectedIndex = idealSelectedIndex;\n     // Revert back to the current selection if conditions are not suitable for switching.\n-    if (currentFormat != null && !isBlacklisted(selectedIndex, nowMs)) {\n+    if (!isBlacklisted(currentSelectedIndex, nowMs)) {\n+      Format currentFormat = getFormat(currentSelectedIndex);\n+      Format idealFormat = getFormat(idealSelectedIndex);\n       if (idealFormat.bitrate > currentFormat.bitrate\n           && bufferedDurationUs < minDurationForQualityIncreaseUs) {\n         // The ideal track is a higher quality, but we have insufficient buffer to safely switch",
      "parent_sha": "5c2c3c5c63aecfb8fe4b31db10aa7c48933cdfbb"
    }
  },
  {
    "oid": "cc24c4e38bd222f8b43efaba513c76d0a9effe4b",
    "message": "change to switch to avoid changing 4.0 tracks",
    "date": "2016-12-06T13:08:58Z",
    "url": "https://github.com/google/ExoPlayer/commit/cc24c4e38bd222f8b43efaba513c76d0a9effe4b",
    "details": {
      "sha": "a079c0df608ea03a177824f6271a7b71f283b615",
      "filename": "library/src/main/java/com/google/android/exoplayer2/audio/AudioTrack.java",
      "status": "modified",
      "additions": 11,
      "deletions": 4,
      "changes": 15,
      "blob_url": "https://github.com/google/ExoPlayer/blob/cc24c4e38bd222f8b43efaba513c76d0a9effe4b/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Faudio%2FAudioTrack.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/cc24c4e38bd222f8b43efaba513c76d0a9effe4b/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Faudio%2FAudioTrack.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Faudio%2FAudioTrack.java?ref=cc24c4e38bd222f8b43efaba513c76d0a9effe4b",
      "patch": "@@ -442,10 +442,17 @@ public void configure(String mimeType, int channelCount, int sampleRate,\n         throw new IllegalArgumentException(\"Unsupported channel count: \" + channelCount);\n     }\n     if (Util.SDK_INT <= 23 && \"foster\".equals(Util.DEVICE) && \"NVIDIA\".equals(Util.MANUFACTURER)) {\n-      if (channelCount == 7)\n-        channelConfig = C.CHANNEL_OUT_7POINT1_SURROUND;\n-      else if (channelCount >=3 && channelCount <= 5)\n-        channelConfig = AudioFormat.CHANNEL_OUT_5POINT1;\n+      switch(channelCount) {\n+        case 7:\n+          channelConfig = C.CHANNEL_OUT_7POINT1_SURROUND;\n+          break;\n+        case 3:\n+        case 5:\n+          channelConfig = AudioFormat.CHANNEL_OUT_5POINT1;\n+          break;\n+        default:\n+          break;\n+      }\n     }\n \n     boolean passthrough = !MimeTypes.AUDIO_RAW.equals(mimeType);",
      "parent_sha": "e22c42c7c22bcc4fa10d8282163ce1f6f5100c60"
    }
  },
  {
    "oid": "106294158abdc3efbd1cb041ae3cef6b4f40e445",
    "message": "Fix SimpleExoPlayer documentation\n\nI've removed the \"by default\" statements, since this now depends on how\nthe builder was configured.\n\nPiperOrigin-RevId: 366249995",
    "date": "2021-04-12T13:12:12Z",
    "url": "https://github.com/google/ExoPlayer/commit/106294158abdc3efbd1cb041ae3cef6b4f40e445",
    "details": {
      "sha": "67a12f05dccffc2950aba2b6409c08ad6548fca9",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java",
      "status": "modified",
      "additions": 1,
      "deletions": 7,
      "changes": 8,
      "blob_url": "https://github.com/google/ExoPlayer/blob/106294158abdc3efbd1cb041ae3cef6b4f40e445/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FSimpleExoPlayer.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/106294158abdc3efbd1cb041ae3cef6b4f40e445/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FSimpleExoPlayer.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FSimpleExoPlayer.java?ref=106294158abdc3efbd1cb041ae3cef6b4f40e445",
      "patch": "@@ -144,7 +144,7 @@ public static final class Builder {\n      *   <li>{@link PriorityTaskManager}: {@code null} (not used)\n      *   <li>{@link AudioAttributes}: {@link AudioAttributes#DEFAULT}, not handling audio focus\n      *   <li>{@link C.WakeMode}: {@link C#WAKE_MODE_NONE}\n-     *   <li>{@code handleAudioBecomingNoisy}: {@code true}\n+     *   <li>{@code handleAudioBecomingNoisy}: {@code false}\n      *   <li>{@code skipSilenceEnabled}: {@code false}\n      *   <li>{@link C.VideoScalingMode}: {@link C#VIDEO_SCALING_MODE_DEFAULT}\n      *   <li>{@code useLazyPreparation}: {@code true}\n@@ -1047,8 +1047,6 @@ public void removeAnalyticsListener(AnalyticsListener listener) {\n    * href=\"https://developer.android.com/guide/topics/media-apps/volume-and-earphones#becoming-noisy\">audio\n    * becoming noisy</a> documentation for more information.\n    *\n-   * <p>This feature is not enabled by default.\n-   *\n    * @param handleAudioBecomingNoisy Whether the player should pause automatically when audio is\n    *     rerouted from a headset to device speakers.\n    */\n@@ -1718,10 +1716,6 @@ public long getContentBufferedPosition() {\n    * playback can occur when the screen is off (e.g. background audio playback). It is not useful if\n    * the screen will always be on during playback (e.g. foreground video playback).\n    *\n-   * <p>This feature is not enabled by default. If enabled, a WakeLock is held whenever the player\n-   * is in the {@link #STATE_READY READY} or {@link #STATE_BUFFERING BUFFERING} states with {@code\n-   * playWhenReady = true}.\n-   *\n    * @param handleWakeLock Whether the player should use a {@link android.os.PowerManager.WakeLock}\n    *     to ensure the device stays awake for playback, even when the screen is off.\n    * @deprecated Use {@link #setWakeMode(int)} instead.",
      "parent_sha": "b93395e7a5932fbd443353e031ad23ab5ff176c9"
    }
  },
  {
    "oid": "4a942adbc629a53e6dfe9e5283280b224416b80b",
    "message": "Force AudioTrack-based speed changes when offload is enabled\n\nAudioProcessor-based speed changes are not supported with\noffload, so we should use the AudioTrack-based speed changes\nby default if the user requests a speed change.\n\nThis moves the decision of which speed change path is used\ninto the Configuration, so that it can change for each\nAudioTrack in a playlist.\n\nPiperOrigin-RevId: 505621911",
    "date": "2023-02-01T14:29:31Z",
    "url": "https://github.com/google/ExoPlayer/commit/4a942adbc629a53e6dfe9e5283280b224416b80b",
    "details": {
      "sha": "57b857f29cb89b7931ec05a2008cceaad134a3c0",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java",
      "status": "modified",
      "additions": 28,
      "deletions": 13,
      "changes": 41,
      "blob_url": "https://github.com/google/ExoPlayer/blob/4a942adbc629a53e6dfe9e5283280b224416b80b/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Faudio%2FDefaultAudioSink.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/4a942adbc629a53e6dfe9e5283280b224416b80b/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Faudio%2FDefaultAudioSink.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Faudio%2FDefaultAudioSink.java?ref=4a942adbc629a53e6dfe9e5283280b224416b80b",
      "patch": "@@ -463,7 +463,7 @@ public DefaultAudioSink build() {\n   private final ConditionVariable releasingConditionVariable;\n   private final AudioTrackPositionTracker audioTrackPositionTracker;\n   private final ArrayDeque<MediaPositionParameters> mediaPositionParametersCheckpoints;\n-  private final boolean enableAudioTrackPlaybackParams;\n+  private final boolean preferAudioTrackPlaybackParams;\n   private final @OffloadMode int offloadMode;\n   private @MonotonicNonNull StreamEventCallbackV29 offloadStreamEventCallbackV29;\n   private final PendingExceptionHolder<InitializationException>\n@@ -522,7 +522,7 @@ private DefaultAudioSink(Builder builder) {\n     audioCapabilities = builder.audioCapabilities;\n     audioProcessorChain = builder.audioProcessorChain;\n     enableFloatOutput = Util.SDK_INT >= 21 && builder.enableFloatOutput;\n-    enableAudioTrackPlaybackParams = Util.SDK_INT >= 23 && builder.enableAudioTrackPlaybackParams;\n+    preferAudioTrackPlaybackParams = Util.SDK_INT >= 23 && builder.enableAudioTrackPlaybackParams;\n     offloadMode = Util.SDK_INT >= 29 ? builder.offloadMode : OFFLOAD_MODE_DISABLED;\n     audioTrackBufferSizeProvider = builder.audioTrackBufferSizeProvider;\n     releasingConditionVariable = new ConditionVariable(Clock.DEFAULT);\n@@ -612,6 +612,7 @@ public void configure(Format inputFormat, int specifiedBufferSize, @Nullable int\n     int outputSampleRate;\n     int outputChannelConfig;\n     int outputPcmFrameSize;\n+    boolean enableAudioTrackPlaybackParams;\n \n     if (MimeTypes.AUDIO_RAW.equals(inputFormat.sampleMimeType)) {\n       Assertions.checkArgument(Util.isEncodingLinearPcm(inputFormat.pcmEncoding));\n@@ -660,6 +661,7 @@ public void configure(Format inputFormat, int specifiedBufferSize, @Nullable int\n       outputSampleRate = outputFormat.sampleRate;\n       outputChannelConfig = Util.getAudioTrackChannelConfig(outputFormat.channelCount);\n       outputPcmFrameSize = Util.getPcmFrameSize(outputEncoding, outputFormat.channelCount);\n+      enableAudioTrackPlaybackParams = preferAudioTrackPlaybackParams;\n     } else {\n       // Audio processing is not supported in offload or passthrough mode.\n       audioProcessingPipeline = new AudioProcessingPipeline(ImmutableList.of());\n@@ -671,6 +673,8 @@ public void configure(Format inputFormat, int specifiedBufferSize, @Nullable int\n         outputEncoding =\n             MimeTypes.getEncoding(checkNotNull(inputFormat.sampleMimeType), inputFormat.codecs);\n         outputChannelConfig = Util.getAudioTrackChannelConfig(inputFormat.channelCount);\n+        // Offload requires AudioTrack playback parameters to apply speed changes quickly.\n+        enableAudioTrackPlaybackParams = true;\n       } else {\n         outputMode = OUTPUT_MODE_PASSTHROUGH;\n         @Nullable\n@@ -682,6 +686,9 @@ public void configure(Format inputFormat, int specifiedBufferSize, @Nullable int\n         }\n         outputEncoding = encodingAndChannelConfig.first;\n         outputChannelConfig = encodingAndChannelConfig.second;\n+        // Passthrough only supports AudioTrack playback parameters, but we only enable it this was\n+        // specifically requested by the app.\n+        enableAudioTrackPlaybackParams = preferAudioTrackPlaybackParams;\n       }\n     }\n \n@@ -717,7 +724,8 @@ public void configure(Format inputFormat, int specifiedBufferSize, @Nullable int\n             outputChannelConfig,\n             outputEncoding,\n             bufferSize,\n-            audioProcessingPipeline);\n+            audioProcessingPipeline,\n+            enableAudioTrackPlaybackParams);\n     if (isAudioTrackInitialized()) {\n       this.pendingConfiguration = pendingConfiguration;\n     } else {\n@@ -1512,12 +1520,14 @@ private boolean shouldApplyAudioProcessorPlaybackParameters() {\n     //   would require decoding/re-encoding; and\n     // - when outputting float PCM audio, because SonicAudioProcessor outputs 16-bit integer PCM.\n     return !tunneling\n-        && MimeTypes.AUDIO_RAW.equals(configuration.inputFormat.sampleMimeType)\n+        && configuration.outputMode == OUTPUT_MODE_PCM\n         && !shouldUseFloatOutput(configuration.inputFormat.pcmEncoding);\n   }\n \n   private boolean useAudioTrackPlaybackParams() {\n-    return configuration != null && enableAudioTrackPlaybackParams && Util.SDK_INT >= 23;\n+    return configuration != null\n+        && configuration.enableAudioTrackPlaybackParams\n+        && Util.SDK_INT >= 23;\n   }\n \n   /**\n@@ -1955,6 +1965,7 @@ private static final class Configuration {\n     public final @C.Encoding int outputEncoding;\n     public final int bufferSize;\n     public final AudioProcessingPipeline audioProcessingPipeline;\n+    public final boolean enableAudioTrackPlaybackParams;\n \n     public Configuration(\n         Format inputFormat,\n@@ -1965,7 +1976,8 @@ public Configuration(\n         int outputChannelConfig,\n         int outputEncoding,\n         int bufferSize,\n-        AudioProcessingPipeline audioProcessingPipeline) {\n+        AudioProcessingPipeline audioProcessingPipeline,\n+        boolean enableAudioTrackPlaybackParams) {\n       this.inputFormat = inputFormat;\n       this.inputPcmFrameSize = inputPcmFrameSize;\n       this.outputMode = outputMode;\n@@ -1975,6 +1987,7 @@ public Configuration(\n       this.outputEncoding = outputEncoding;\n       this.bufferSize = bufferSize;\n       this.audioProcessingPipeline = audioProcessingPipeline;\n+      this.enableAudioTrackPlaybackParams = enableAudioTrackPlaybackParams;\n     }\n \n     public Configuration copyWithBufferSize(int bufferSize) {\n@@ -1987,16 +2000,18 @@ public Configuration copyWithBufferSize(int bufferSize) {\n           outputChannelConfig,\n           outputEncoding,\n           bufferSize,\n-          audioProcessingPipeline);\n+          audioProcessingPipeline,\n+          enableAudioTrackPlaybackParams);\n     }\n \n     /** Returns if the configurations are sufficiently compatible to reuse the audio track. */\n-    public boolean canReuseAudioTrack(Configuration audioTrackConfiguration) {\n-      return audioTrackConfiguration.outputMode == outputMode\n-          && audioTrackConfiguration.outputEncoding == outputEncoding\n-          && audioTrackConfiguration.outputSampleRate == outputSampleRate\n-          && audioTrackConfiguration.outputChannelConfig == outputChannelConfig\n-          && audioTrackConfiguration.outputPcmFrameSize == outputPcmFrameSize;\n+    public boolean canReuseAudioTrack(Configuration newConfiguration) {\n+      return newConfiguration.outputMode == outputMode\n+          && newConfiguration.outputEncoding == outputEncoding\n+          && newConfiguration.outputSampleRate == outputSampleRate\n+          && newConfiguration.outputChannelConfig == outputChannelConfig\n+          && newConfiguration.outputPcmFrameSize == outputPcmFrameSize\n+          && newConfiguration.enableAudioTrackPlaybackParams == enableAudioTrackPlaybackParams;\n     }\n \n     public long inputFramesToDurationUs(long frameCount) {",
      "parent_sha": "fef3e804a05de743946585357cea54b3cdfe49e9"
    }
  },
  {
    "oid": "bf9a919005a0968909f565e5a6840d8eb4b12e08",
    "message": "Propagate extras from queue item to metadata item.\n\nnorelnotes=true\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=178785377",
    "date": "2017-12-15T15:29:18Z",
    "url": "https://github.com/google/ExoPlayer/commit/bf9a919005a0968909f565e5a6840d8eb4b12e08",
    "details": {
      "sha": "1b1224273fb2b955654c184b60a2ea71f5468089",
      "filename": "extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java",
      "status": "modified",
      "additions": 36,
      "deletions": 9,
      "changes": 45,
      "blob_url": "https://github.com/google/ExoPlayer/blob/bf9a919005a0968909f565e5a6840d8eb4b12e08/extensions%2Fmediasession%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fext%2Fmediasession%2FMediaSessionConnector.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/bf9a919005a0968909f565e5a6840d8eb4b12e08/extensions%2Fmediasession%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fext%2Fmediasession%2FMediaSessionConnector.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/extensions%2Fmediasession%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fext%2Fmediasession%2FMediaSessionConnector.java?ref=bf9a919005a0968909f565e5a6840d8eb4b12e08",
      "patch": "@@ -15,6 +15,7 @@\n  */\n package com.google.android.exoplayer2.ext.mediasession;\n \n+import android.graphics.Bitmap;\n import android.net.Uri;\n import android.os.Bundle;\n import android.os.Handler;\n@@ -330,6 +331,7 @@ public interface CustomActionProvider {\n   private final ExoPlayerEventListener exoPlayerEventListener;\n   private final MediaSessionCallback mediaSessionCallback;\n   private final PlaybackController playbackController;\n+  private final String metadataExtrasPrefix;\n   private final Map<String, CommandReceiver> commandMap;\n \n   private Player player;\n@@ -356,33 +358,39 @@ public MediaSessionConnector(MediaSessionCompat mediaSession) {\n   /**\n    * Creates an instance. Must be called on the same thread that is used to construct the player\n    * instances passed to {@link #setPlayer(Player, PlaybackPreparer, CustomActionProvider...)}.\n-   * <p>\n-   * Equivalent to {@code MediaSessionConnector(mediaSession, playbackController, true)}.\n+   *\n+   * <p>Equivalent to {@code MediaSessionConnector(mediaSession, playbackController, true, null)}.\n    *\n    * @param mediaSession The {@link MediaSessionCompat} to connect to.\n    * @param playbackController A {@link PlaybackController} for handling playback actions.\n    */\n-  public MediaSessionConnector(MediaSessionCompat mediaSession,\n-      PlaybackController playbackController) {\n-    this(mediaSession, playbackController, true);\n+  public MediaSessionConnector(\n+      MediaSessionCompat mediaSession, PlaybackController playbackController) {\n+    this(mediaSession, playbackController, true, null);\n   }\n \n   /**\n    * Creates an instance. Must be called on the same thread that is used to construct the player\n    * instances passed to {@link #setPlayer(Player, PlaybackPreparer, CustomActionProvider...)}.\n    *\n    * @param mediaSession The {@link MediaSessionCompat} to connect to.\n-   * @param playbackController A {@link PlaybackController} for handling playback actions, or\n-   *     {@code null} if the connector should handle playback actions directly.\n+   * @param playbackController A {@link PlaybackController} for handling playback actions, or {@code\n+   *     null} if the connector should handle playback actions directly.\n    * @param doMaintainMetadata Whether the connector should maintain the metadata of the session. If\n    *     {@code false}, you need to maintain the metadata of the media session yourself (provide at\n    *     least the duration to allow clients to show a progress bar).\n+   * @param metadataExtrasPrefix A string to prefix extra keys which are propagated from the active\n+   *     queue item to the session metadata.\n    */\n-  public MediaSessionConnector(MediaSessionCompat mediaSession,\n-      PlaybackController playbackController, boolean doMaintainMetadata) {\n+  public MediaSessionConnector(\n+      MediaSessionCompat mediaSession,\n+      PlaybackController playbackController,\n+      boolean doMaintainMetadata,\n+      @Nullable String metadataExtrasPrefix) {\n     this.mediaSession = mediaSession;\n     this.playbackController = playbackController != null ? playbackController\n         : new DefaultPlaybackController();\n+    this.metadataExtrasPrefix = metadataExtrasPrefix != null ? metadataExtrasPrefix : \"\";\n     this.handler = new Handler(Looper.myLooper() != null ? Looper.myLooper()\n         : Looper.getMainLooper());\n     this.doMaintainMetadata = doMaintainMetadata;\n@@ -553,6 +561,25 @@ private void updateMediaSessionMetadata() {\n           MediaSessionCompat.QueueItem queueItem = queue.get(i);\n           if (queueItem.getQueueId() == activeQueueItemId) {\n             MediaDescriptionCompat description = queueItem.getDescription();\n+            Bundle extras = description.getExtras();\n+            if (extras != null) {\n+              for (String key : extras.keySet()) {\n+                Object value = extras.get(key);\n+                if (value instanceof String) {\n+                  builder.putString(metadataExtrasPrefix + key, (String) value);\n+                } else if (value instanceof CharSequence) {\n+                  builder.putText(metadataExtrasPrefix + key, (CharSequence) value);\n+                } else if (value instanceof Long) {\n+                  builder.putLong(metadataExtrasPrefix + key, (Long) value);\n+                } else if (value instanceof Integer) {\n+                  builder.putLong(metadataExtrasPrefix + key, (Integer) value);\n+                } else if (value instanceof Bitmap) {\n+                  builder.putBitmap(metadataExtrasPrefix + key, (Bitmap) value);\n+                } else if (value instanceof RatingCompat) {\n+                  builder.putRating(metadataExtrasPrefix + key, (RatingCompat) value);\n+                }\n+              }\n+            }\n             if (description.getTitle() != null) {\n               builder.putString(MediaMetadataCompat.METADATA_KEY_DISPLAY_TITLE,\n                   String.valueOf(description.getTitle()));",
      "parent_sha": "b223988e30c9f176de8a156c9ed49e5cef124b80"
    }
  },
  {
    "oid": "66b128251752e09bcd75f227278ed550d96951d9",
    "message": "Post `OfflineLicenseHelper` interactions to its internal handler thread\n\n`DefaultDrmSession(Manager)` expect most of their methods to be called\non the 'playback thread'. There isn't a playback thread in the case of\n`OfflineLicenseHelper`, but in that case it's the thread backing\n`DefaultDrmSessionManager.playbackLooper`, which is `OfflineLicenseHelper.handlerThread`.\n\nPiperOrigin-RevId: 520053006\n(cherry picked from commit 376bddef4720e07d18afeff0c591f03bf72149f7)",
    "date": "2023-04-18T13:56:45Z",
    "url": "https://github.com/google/ExoPlayer/commit/66b128251752e09bcd75f227278ed550d96951d9",
    "details": {
      "sha": "1dff7d67282de9c93a1a2d49056337f9bb3fe2a7",
      "filename": "libraries/exoplayer/src/main/java/androidx/media3/exoplayer/drm/OfflineLicenseHelper.java",
      "status": "modified",
      "additions": 181,
      "deletions": 44,
      "changes": 225,
      "blob_url": "https://github.com/google/ExoPlayer/blob/66b128251752e09bcd75f227278ed550d96951d9/libraries%2Fexoplayer%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fexoplayer%2Fdrm%2FOfflineLicenseHelper.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/66b128251752e09bcd75f227278ed550d96951d9/libraries%2Fexoplayer%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fexoplayer%2Fdrm%2FOfflineLicenseHelper.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/libraries%2Fexoplayer%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fexoplayer%2Fdrm%2FOfflineLicenseHelper.java?ref=66b128251752e09bcd75f227278ed550d96951d9",
      "patch": "@@ -19,6 +19,7 @@\n import android.os.ConditionVariable;\n import android.os.Handler;\n import android.os.HandlerThread;\n+import android.os.Looper;\n import android.util.Pair;\n import androidx.annotation.Nullable;\n import androidx.annotation.RequiresApi;\n@@ -31,8 +32,11 @@\n import androidx.media3.exoplayer.drm.DefaultDrmSessionManager.Mode;\n import androidx.media3.exoplayer.drm.DrmSession.DrmSessionException;\n import androidx.media3.exoplayer.source.MediaSource.MediaPeriodId;\n+import com.google.common.util.concurrent.SettableFuture;\n import java.util.Map;\n import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import org.checkerframework.checker.nullness.compatqual.NullableType;\n \n /** Helper class to download, renew and release offline licenses. */\n @RequiresApi(18)\n@@ -42,9 +46,10 @@ public final class OfflineLicenseHelper {\n   private static final Format FORMAT_WITH_EMPTY_DRM_INIT_DATA =\n       new Format.Builder().setDrmInitData(new DrmInitData()).build();\n \n-  private final ConditionVariable conditionVariable;\n+  private final ConditionVariable drmListenerConditionVariable;\n   private final DefaultDrmSessionManager drmSessionManager;\n   private final HandlerThread handlerThread;\n+  private final Handler handler;\n   private final DrmSessionEventListener.EventDispatcher eventDispatcher;\n \n   /**\n@@ -156,28 +161,29 @@ public OfflineLicenseHelper(\n     this.eventDispatcher = eventDispatcher;\n     handlerThread = new HandlerThread(\"ExoPlayer:OfflineLicenseHelper\");\n     handlerThread.start();\n-    conditionVariable = new ConditionVariable();\n+    handler = new Handler(handlerThread.getLooper());\n+    drmListenerConditionVariable = new ConditionVariable();\n     DrmSessionEventListener eventListener =\n         new DrmSessionEventListener() {\n           @Override\n           public void onDrmKeysLoaded(int windowIndex, @Nullable MediaPeriodId mediaPeriodId) {\n-            conditionVariable.open();\n+            drmListenerConditionVariable.open();\n           }\n \n           @Override\n           public void onDrmSessionManagerError(\n               int windowIndex, @Nullable MediaPeriodId mediaPeriodId, Exception e) {\n-            conditionVariable.open();\n+            drmListenerConditionVariable.open();\n           }\n \n           @Override\n           public void onDrmKeysRestored(int windowIndex, @Nullable MediaPeriodId mediaPeriodId) {\n-            conditionVariable.open();\n+            drmListenerConditionVariable.open();\n           }\n \n           @Override\n           public void onDrmKeysRemoved(int windowIndex, @Nullable MediaPeriodId mediaPeriodId) {\n-            conditionVariable.open();\n+            drmListenerConditionVariable.open();\n           }\n         };\n     eventDispatcher.addEventListener(new Handler(handlerThread.getLooper()), eventListener);\n@@ -193,7 +199,8 @@ public void onDrmKeysRemoved(int windowIndex, @Nullable MediaPeriodId mediaPerio\n    */\n   public synchronized byte[] downloadLicense(Format format) throws DrmSessionException {\n     Assertions.checkArgument(format.drmInitData != null);\n-    return blockingKeyRequest(DefaultDrmSessionManager.MODE_DOWNLOAD, null, format);\n+    return acquireSessionAndGetOfflineLicenseKeySetIdOnHandlerThread(\n+        DefaultDrmSessionManager.MODE_DOWNLOAD, /* offlineLicenseKeySetId= */ null, format);\n   }\n \n   /**\n@@ -206,7 +213,7 @@ public synchronized byte[] downloadLicense(Format format) throws DrmSessionExcep\n   public synchronized byte[] renewLicense(byte[] offlineLicenseKeySetId)\n       throws DrmSessionException {\n     Assertions.checkNotNull(offlineLicenseKeySetId);\n-    return blockingKeyRequest(\n+    return acquireSessionAndGetOfflineLicenseKeySetIdOnHandlerThread(\n         DefaultDrmSessionManager.MODE_DOWNLOAD,\n         offlineLicenseKeySetId,\n         FORMAT_WITH_EMPTY_DRM_INIT_DATA);\n@@ -221,7 +228,7 @@ public synchronized byte[] renewLicense(byte[] offlineLicenseKeySetId)\n   public synchronized void releaseLicense(byte[] offlineLicenseKeySetId)\n       throws DrmSessionException {\n     Assertions.checkNotNull(offlineLicenseKeySetId);\n-    blockingKeyRequest(\n+    acquireSessionAndGetOfflineLicenseKeySetIdOnHandlerThread(\n         DefaultDrmSessionManager.MODE_RELEASE,\n         offlineLicenseKeySetId,\n         FORMAT_WITH_EMPTY_DRM_INIT_DATA);\n@@ -237,56 +244,186 @@ public synchronized void releaseLicense(byte[] offlineLicenseKeySetId)\n   public synchronized Pair<Long, Long> getLicenseDurationRemainingSec(byte[] offlineLicenseKeySetId)\n       throws DrmSessionException {\n     Assertions.checkNotNull(offlineLicenseKeySetId);\n-    drmSessionManager.setPlayer(handlerThread.getLooper(), PlayerId.UNSET);\n-    drmSessionManager.prepare();\n-    DrmSession drmSession =\n-        openBlockingKeyRequest(\n-            DefaultDrmSessionManager.MODE_QUERY,\n-            offlineLicenseKeySetId,\n-            FORMAT_WITH_EMPTY_DRM_INIT_DATA);\n-    DrmSessionException error = drmSession.getError();\n-    Pair<Long, Long> licenseDurationRemainingSec =\n-        WidevineUtil.getLicenseDurationRemainingSec(drmSession);\n-    drmSession.release(eventDispatcher);\n-    drmSessionManager.release();\n-    if (error != null) {\n-      if (error.getCause() instanceof KeysExpiredException) {\n+    DrmSession drmSession;\n+    try {\n+      drmSession =\n+          acquireFirstSessionOnHandlerThread(\n+              DefaultDrmSessionManager.MODE_QUERY,\n+              offlineLicenseKeySetId,\n+              FORMAT_WITH_EMPTY_DRM_INIT_DATA);\n+    } catch (DrmSessionException e) {\n+      if (e.getCause() instanceof KeysExpiredException) {\n         return Pair.create(0L, 0L);\n       }\n-      throw error;\n+      throw e;\n+    }\n+\n+    SettableFuture<Pair<Long, Long>> licenseDurationRemainingSec = SettableFuture.create();\n+    handler.post(\n+        () -> {\n+          try {\n+            licenseDurationRemainingSec.set(\n+                Assertions.checkNotNull(WidevineUtil.getLicenseDurationRemainingSec(drmSession)));\n+          } catch (Throwable e) {\n+            licenseDurationRemainingSec.setException(e);\n+          } finally {\n+            drmSession.release(eventDispatcher);\n+          }\n+        });\n+    try {\n+      return licenseDurationRemainingSec.get();\n+    } catch (ExecutionException | InterruptedException e) {\n+      throw new IllegalStateException(e);\n+    } finally {\n+      releaseManagerOnHandlerThread();\n     }\n-    return Assertions.checkNotNull(licenseDurationRemainingSec);\n   }\n \n   /** Releases the helper. Should be called when the helper is no longer required. */\n   public void release() {\n     handlerThread.quit();\n   }\n \n-  private byte[] blockingKeyRequest(\n+  /**\n+   * Returns the result of {@link DrmSession#getOfflineLicenseKeySetId()}, or throws {@link\n+   * NullPointerException} if it's null.\n+   *\n+   * <p>This method takes care of acquiring and releasing the {@link DrmSessionManager} and {@link\n+   * DrmSession} instances needed.\n+   */\n+  private byte[] acquireSessionAndGetOfflineLicenseKeySetIdOnHandlerThread(\n       @Mode int licenseMode, @Nullable byte[] offlineLicenseKeySetId, Format format)\n       throws DrmSessionException {\n-    drmSessionManager.setPlayer(handlerThread.getLooper(), PlayerId.UNSET);\n-    drmSessionManager.prepare();\n-    DrmSession drmSession = openBlockingKeyRequest(licenseMode, offlineLicenseKeySetId, format);\n-    DrmSessionException error = drmSession.getError();\n-    byte[] keySetId = drmSession.getOfflineLicenseKeySetId();\n-    drmSession.release(eventDispatcher);\n-    drmSessionManager.release();\n-    if (error != null) {\n-      throw error;\n+    DrmSession drmSession =\n+        acquireFirstSessionOnHandlerThread(licenseMode, offlineLicenseKeySetId, format);\n+\n+    SettableFuture<byte @NullableType []> keySetId = SettableFuture.create();\n+    handler.post(\n+        () -> {\n+          try {\n+            keySetId.set(drmSession.getOfflineLicenseKeySetId());\n+          } catch (Throwable e) {\n+            keySetId.setException(e);\n+          } finally {\n+            drmSession.release(eventDispatcher);\n+          }\n+        });\n+\n+    try {\n+      return Assertions.checkNotNull(keySetId.get());\n+    } catch (ExecutionException | InterruptedException e) {\n+      throw new IllegalStateException(e);\n+    } finally {\n+      releaseManagerOnHandlerThread();\n     }\n-    return Assertions.checkNotNull(keySetId);\n   }\n \n-  private DrmSession openBlockingKeyRequest(\n-      @Mode int licenseMode, @Nullable byte[] offlineLicenseKeySetId, Format format) {\n+  /**\n+   * Calls {@link DrmSessionManager#acquireSession(DrmSessionEventListener.EventDispatcher, Format)}\n+   * on {@link #handlerThread} and blocks until a callback is received via {@link\n+   * DrmSessionEventListener}.\n+   *\n+   * <p>If key loading failed and {@link DrmSession#getState()} returns {@link\n+   * DrmSession#STATE_ERROR} then this method releases the session and throws {@link\n+   * DrmSession#getError()}.\n+   *\n+   * <p>Callers are responsible for the following:\n+   *\n+   * <ul>\n+   *   <li>Ensuring the {@link\n+   *       DrmSessionManager#acquireSession(DrmSessionEventListener.EventDispatcher, Format)} call\n+   *       will trigger a callback to {@link DrmSessionEventListener} (e.g. it will load new keys).\n+   *       If not, this method will block forever.\n+   *   <li>Releasing the returned {@link DrmSession} instance (on {@link #handlerThread}).\n+   *   <li>Releasing {@link #drmSessionManager} if a {@link DrmSession} instance is returned (the\n+   *       manager will be released before an exception is thrown).\n+   * </ul>\n+   */\n+  private DrmSession acquireFirstSessionOnHandlerThread(\n+      @Mode int licenseMode, @Nullable byte[] offlineLicenseKeySetId, Format format)\n+      throws DrmSessionException {\n     Assertions.checkNotNull(format.drmInitData);\n-    drmSessionManager.setMode(licenseMode, offlineLicenseKeySetId);\n-    conditionVariable.close();\n-    DrmSession drmSession = drmSessionManager.acquireSession(eventDispatcher, format);\n-    // Block current thread until key loading is finished\n-    conditionVariable.block();\n-    return Assertions.checkNotNull(drmSession);\n+    SettableFuture<DrmSession> drmSessionFuture = SettableFuture.create();\n+    drmListenerConditionVariable.close();\n+    handler.post(\n+        () -> {\n+          try {\n+            drmSessionManager.setPlayer(Assertions.checkNotNull(Looper.myLooper()), PlayerId.UNSET);\n+            drmSessionManager.prepare();\n+            try {\n+              drmSessionManager.setMode(licenseMode, offlineLicenseKeySetId);\n+              drmSessionFuture.set(\n+                  Assertions.checkNotNull(\n+                      drmSessionManager.acquireSession(eventDispatcher, format)));\n+            } catch (Throwable e) {\n+              drmSessionManager.release();\n+              throw e;\n+            }\n+          } catch (Throwable e) {\n+            drmSessionFuture.setException(e);\n+          }\n+        });\n+\n+    DrmSession drmSession;\n+    try {\n+      drmSession = drmSessionFuture.get();\n+    } catch (ExecutionException | InterruptedException e) {\n+      throw new IllegalStateException(e);\n+    }\n+\n+    // drmListenerConditionVariable will be opened by a callback to this.eventDispatcher when key\n+    // loading is complete (drmSession.state == STATE_OPENED_WITH_KEYS) or has failed\n+    // (drmSession.state == STATE_ERROR).\n+    drmListenerConditionVariable.block();\n+\n+    SettableFuture<@NullableType DrmSessionException> drmSessionErrorFuture =\n+        SettableFuture.create();\n+    handler.post(\n+        () -> {\n+          try {\n+            DrmSessionException drmSessionError = drmSession.getError();\n+            if (drmSession.getState() == DrmSession.STATE_ERROR) {\n+              drmSession.release(eventDispatcher);\n+              drmSessionManager.release();\n+            }\n+            drmSessionErrorFuture.set(drmSessionError);\n+          } catch (Throwable e) {\n+            drmSessionErrorFuture.setException(e);\n+            drmSession.release(eventDispatcher);\n+            drmSessionManager.release();\n+          }\n+        });\n+    try {\n+      DrmSessionException drmSessionError = drmSessionErrorFuture.get();\n+      if (drmSessionError != null) {\n+        throw drmSessionError;\n+      } else {\n+        return drmSession;\n+      }\n+    } catch (InterruptedException | ExecutionException e) {\n+      throw new IllegalStateException(e);\n+    }\n+  }\n+\n+  /**\n+   * Calls {@link DrmSessionManager#release()} on {@link #handlerThread} and blocks until it's\n+   * complete.\n+   */\n+  private void releaseManagerOnHandlerThread() {\n+    SettableFuture<Void> result = SettableFuture.create();\n+    handler.post(\n+        () -> {\n+          try {\n+            drmSessionManager.release();\n+            result.set(null);\n+          } catch (Throwable e) {\n+            result.setException(e);\n+          }\n+        });\n+    try {\n+      result.get();\n+    } catch (InterruptedException | ExecutionException e) {\n+      throw new IllegalStateException(e);\n+    }\n   }\n }",
      "parent_sha": "56dd0f761d158c34370d842016e685fbc44a493f"
    }
  },
  {
    "oid": "e0a00502a72a6a1b8fe3d7143bba38b49dd7c776",
    "message": "Avoid exception when creating ChunkIndex with length = 0.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=150908893",
    "date": "2017-03-22T20:14:48Z",
    "url": "https://github.com/google/ExoPlayer/commit/e0a00502a72a6a1b8fe3d7143bba38b49dd7c776",
    "details": {
      "sha": "baa5589f4b444c73c2e7ffdb6aac133a2e39da67",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/extractor/ChunkIndex.java",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/google/ExoPlayer/blob/e0a00502a72a6a1b8fe3d7143bba38b49dd7c776/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2FChunkIndex.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/e0a00502a72a6a1b8fe3d7143bba38b49dd7c776/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2FChunkIndex.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2FChunkIndex.java?ref=e0a00502a72a6a1b8fe3d7143bba38b49dd7c776",
      "patch": "@@ -61,7 +61,11 @@ public ChunkIndex(int[] sizes, long[] offsets, long[] durationsUs, long[] timesU\n     this.durationsUs = durationsUs;\n     this.timesUs = timesUs;\n     length = sizes.length;\n-    durationUs = durationsUs[length - 1] + timesUs[length - 1];\n+    if (length > 0) {\n+      durationUs = durationsUs[length - 1] + timesUs[length - 1];\n+    } else {\n+      durationUs = 0;\n+    }\n   }\n \n   /**",
      "parent_sha": "8f636991ad152bca610562b2374e1064ebfbc34b"
    }
  },
  {
    "oid": "86a86f6466987f97954e16a0bc0b6d256fa53944",
    "message": "Refactor ExtractorInput javadoc about allowEndOfInput\n\nThis parameter is a little confusing, especially as the behaviour\ncan be surprising if the intended use-case isn't clear. This change\nmoves the description of the parameter into the class javadoc,\nadds context/justification and slims down each method's\njavadoc to refer to the class-level.\n\nRelated to investigating/fixing issue:#6700\n\nPiperOrigin-RevId: 283724826",
    "date": "2019-12-06T23:22:30Z",
    "url": "https://github.com/google/ExoPlayer/commit/86a86f6466987f97954e16a0bc0b6d256fa53944",
    "details": {
      "sha": "1b492e38c7a99be527a4842c1d92e0007d12bd9d",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/extractor/ExtractorInput.java",
      "status": "modified",
      "additions": 63,
      "deletions": 31,
      "changes": 94,
      "blob_url": "https://github.com/google/ExoPlayer/blob/86a86f6466987f97954e16a0bc0b6d256fa53944/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2FExtractorInput.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/86a86f6466987f97954e16a0bc0b6d256fa53944/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2FExtractorInput.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2FExtractorInput.java?ref=86a86f6466987f97954e16a0bc0b6d256fa53944",
      "patch": "@@ -18,9 +18,50 @@\n import com.google.android.exoplayer2.C;\n import java.io.EOFException;\n import java.io.IOException;\n+import java.io.InputStream;\n \n /**\n  * Provides data to be consumed by an {@link Extractor}.\n+ *\n+ * <p>This interface provides two modes of accessing the underlying input. See the subheadings below\n+ * for more info about each mode.\n+ *\n+ * <ul>\n+ *   <li>The {@code read()} and {@code skip()} methods provide {@link InputStream}-like byte-level\n+ *       access operations.\n+ *   <li>The {@code read/skip/peekFully()} and {@code advancePeekPosition()} methods assume the user\n+ *       wants to read an entire block/frame/header of known length.\n+ * </ul>\n+ *\n+ * <h4>{@link InputStream}-like methods</h4>\n+ *\n+ * <p>The {@code read()} and {@code skip()} methods provide {@link InputStream}-like byte-level\n+ * access operations. The {@code length} parameter is a maximum, and each method returns the number\n+ * of bytes actually processed. This may be less than {@code length} because the end of the input\n+ * was reached, or the method was interrupted, or the operation was aborted early for another\n+ * reason.\n+ *\n+ * <h4>Block-based methods</h4>\n+ *\n+ * <p>The {@code read/skip/peekFully()} and {@code advancePeekPosition()} methods assume the user\n+ * wants to read an entire block/frame/header of known length.\n+ *\n+ * <p>These methods all have a variant that takes a boolean {@code allowEndOfInput} parameter. This\n+ * parameter is intended to be set to true when the caller believes the input might be fully\n+ * exhausted before the call is made (i.e. they've previously read/skipped/peeked the final\n+ * block/frame/header). It's <b>not</b> intended to allow a partial read (i.e. greater than 0 bytes,\n+ * but less than {@code length}) to succeed - this will always throw an {@link EOFException} from\n+ * these methods (a partial read is assumed to indicate a malformed block/frame/header - and\n+ * therefore a malformed file).\n+ *\n+ * <p>The expected behaviour of the block-based methods is therefore:\n+ *\n+ * <ul>\n+ *   <li>Already at end-of-input and {@code allowEndOfInput=false}: Throw {@link EOFException}.\n+ *   <li>Already at end-of-input and {@code allowEndOfInput=true}: Return {@code false}.\n+ *   <li>Encounter end-of-input during read/skip/peek/advance: Throw {@link EOFException}\n+ *       (regardless of {@code allowEndOfInput}).\n+ * </ul>\n  */\n public interface ExtractorInput {\n \n@@ -41,22 +82,16 @@ public interface ExtractorInput {\n \n   /**\n    * Like {@link #read(byte[], int, int)}, but reads the requested {@code length} in full.\n-   * <p>\n-   * If the end of the input is found having read no data, then behavior is dependent on\n-   * {@code allowEndOfInput}. If {@code allowEndOfInput == true} then {@code false} is returned.\n-   * Otherwise an {@link EOFException} is thrown.\n-   * <p>\n-   * Encountering the end of input having partially satisfied the read is always considered an\n-   * error, and will result in an {@link EOFException} being thrown.\n    *\n    * @param target A target array into which data should be written.\n    * @param offset The offset into the target array at which to write.\n    * @param length The number of bytes to read from the input.\n    * @param allowEndOfInput True if encountering the end of the input having read no data is\n    *     allowed, and should result in {@code false} being returned. False if it should be\n-   *     considered an error, causing an {@link EOFException} to be thrown.\n-   * @return True if the read was successful. False if the end of the input was encountered having\n-   *     read no data.\n+   *     considered an error, causing an {@link EOFException} to be thrown. See note in class\n+   *     Javadoc.\n+   * @return True if the read was successful. False if {@code allowEndOfInput=true} and the end of\n+   *     the input was encountered having read no data.\n    * @throws EOFException If the end of input was encountered having partially satisfied the read\n    *     (i.e. having read at least one byte, but fewer than {@code length}), or if no bytes were\n    *     read and {@code allowEndOfInput} is false.\n@@ -94,9 +129,10 @@ boolean readFully(byte[] target, int offset, int length, boolean allowEndOfInput\n    * @param length The number of bytes to skip from the input.\n    * @param allowEndOfInput True if encountering the end of the input having skipped no data is\n    *     allowed, and should result in {@code false} being returned. False if it should be\n-   *     considered an error, causing an {@link EOFException} to be thrown.\n-   * @return True if the skip was successful. False if the end of the input was encountered having\n-   *     skipped no data.\n+   *     considered an error, causing an {@link EOFException} to be thrown. See note in class\n+   *     Javadoc.\n+   * @return True if the skip was successful. False if {@code allowEndOfInput=true} and the end of\n+   *     the input was encountered having skipped no data.\n    * @throws EOFException If the end of input was encountered having partially satisfied the skip\n    *     (i.e. having skipped at least one byte, but fewer than {@code length}), or if no bytes were\n    *     skipped and {@code allowEndOfInput} is false.\n@@ -121,12 +157,8 @@ boolean readFully(byte[] target, int offset, int length, boolean allowEndOfInput\n   /**\n    * Peeks {@code length} bytes from the peek position, writing them into {@code target} at index\n    * {@code offset}. The current read position is left unchanged.\n-   * <p>\n-   * If the end of the input is found having peeked no data, then behavior is dependent on\n-   * {@code allowEndOfInput}. If {@code allowEndOfInput == true} then {@code false} is returned.\n-   * Otherwise an {@link EOFException} is thrown.\n-   * <p>\n-   * Calling {@link #resetPeekPosition()} resets the peek position to equal the current read\n+   *\n+   * <p>Calling {@link #resetPeekPosition()} resets the peek position to equal the current read\n    * position, so the caller can peek the same data again. Reading or skipping also resets the peek\n    * position.\n    *\n@@ -135,9 +167,10 @@ boolean readFully(byte[] target, int offset, int length, boolean allowEndOfInput\n    * @param length The number of bytes to peek from the input.\n    * @param allowEndOfInput True if encountering the end of the input having peeked no data is\n    *     allowed, and should result in {@code false} being returned. False if it should be\n-   *     considered an error, causing an {@link EOFException} to be thrown.\n-   * @return True if the peek was successful. False if the end of the input was encountered having\n-   *     peeked no data.\n+   *     considered an error, causing an {@link EOFException} to be thrown. See note in class\n+   *     Javadoc.\n+   * @return True if the peek was successful. False if {@code allowEndOfInput=true} and the end of\n+   *     the input was encountered having peeked no data.\n    * @throws EOFException If the end of input was encountered having partially satisfied the peek\n    *     (i.e. having peeked at least one byte, but fewer than {@code length}), or if no bytes were\n    *     peeked and {@code allowEndOfInput} is false.\n@@ -165,18 +198,16 @@ boolean peekFully(byte[] target, int offset, int length, boolean allowEndOfInput\n   void peekFully(byte[] target, int offset, int length) throws IOException, InterruptedException;\n \n   /**\n-   * Advances the peek position by {@code length} bytes.\n-   * <p>\n-   * If the end of the input is encountered before advancing the peek position, then behavior is\n-   * dependent on {@code allowEndOfInput}. If {@code allowEndOfInput == true} then {@code false} is\n-   * returned. Otherwise an {@link EOFException} is thrown.\n+   * Advances the peek position by {@code length} bytes. Like {@link #peekFully(byte[], int, int,\n+   * boolean)} except the data is skipped instead of read.\n    *\n    * @param length The number of bytes by which to advance the peek position.\n    * @param allowEndOfInput True if encountering the end of the input before advancing is allowed,\n    *     and should result in {@code false} being returned. False if it should be considered an\n-   *     error, causing an {@link EOFException} to be thrown.\n-   * @return True if advancing the peek position was successful. False if the end of the input was\n-   *     encountered before the peek position could be advanced.\n+   *     error, causing an {@link EOFException} to be thrown. See note in class Javadoc.\n+   * @return True if advancing the peek position was successful. False if {@code\n+   *     allowEndOfInput=true} and the end of the input was encountered before advancing over any\n+   *     data.\n    * @throws EOFException If the end of input was encountered having partially advanced (i.e. having\n    *     advanced by at least one byte, but fewer than {@code length}), or if the end of input was\n    *     encountered before advancing and {@code allowEndOfInput} is false.\n@@ -187,7 +218,8 @@ boolean advancePeekPosition(int length, boolean allowEndOfInput)\n       throws IOException, InterruptedException;\n \n   /**\n-   * Advances the peek position by {@code length} bytes.\n+   * Advances the peek position by {@code length} bytes. Like {@link #peekFully(byte[], int, int,)}\n+   * except the data is skipped instead of read.\n    *\n    * @param length The number of bytes to peek from the input.\n    * @throws EOFException If the end of input was encountered.",
      "parent_sha": "6a354bb29fc4c0cc8a13888fb6de2de721da3ba4"
    }
  },
  {
    "oid": "4f3ab7b22d0a8863907012da4be84fb705f2ed3a",
    "message": "ExoPlayerImplInternal: Some more minor cleanup\n\n- This should be a no-op change\n- Inline attemptRestart\n- Clean up processing of pending seeks\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=139804630",
    "date": "2016-11-21T19:15:13Z",
    "url": "https://github.com/google/ExoPlayer/commit/4f3ab7b22d0a8863907012da4be84fb705f2ed3a",
    "details": {
      "sha": "2b71163c6dc9ebfd1518f3438ff4ee5b7499ff11",
      "filename": "library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java",
      "status": "modified",
      "additions": 29,
      "deletions": 38,
      "changes": 67,
      "blob_url": "https://github.com/google/ExoPlayer/blob/4f3ab7b22d0a8863907012da4be84fb705f2ed3a/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FExoPlayerImplInternal.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/4f3ab7b22d0a8863907012da4be84fb705f2ed3a/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FExoPlayerImplInternal.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FExoPlayerImplInternal.java?ref=4f3ab7b22d0a8863907012da4be84fb705f2ed3a",
      "patch": "@@ -839,17 +839,21 @@ private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifes\n     timeline = timelineAndManifest.first;\n     Object manifest = timelineAndManifest.second;\n \n+    int processedInitialSeekCount = 0;\n     if (oldTimeline == null) {\n       if (pendingInitialSeekCount > 0) {\n         Pair<Integer, Long> periodPosition = resolveSeekPosition(pendingSeekPosition);\n         if (periodPosition == null) {\n           // We failed to resolve the seek position. Stop the player.\n-          finishSourceInfoRefresh(manifest, false);\n+          notifySourceInfoRefresh(manifest, 0);\n           // TODO: We should probably propagate an error here.\n           stopInternal();\n           return;\n         }\n         playbackInfo = new PlaybackInfo(periodPosition.first, periodPosition.second);\n+        processedInitialSeekCount = pendingInitialSeekCount;\n+        pendingInitialSeekCount = 0;\n+        pendingSeekPosition = null;\n       } else if (playbackInfo.startPositionUs == C.TIME_UNSET) {\n         Pair<Integer, Long> defaultPosition = getPeriodPosition(0, C.TIME_UNSET);\n         playbackInfo = new PlaybackInfo(defaultPosition.first, defaultPosition.second);\n@@ -860,19 +864,34 @@ private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifes\n         : loadingPeriodHolder;\n     if (periodHolder == null) {\n       // We don't have any period holders, so we're done.\n-      finishSourceInfoRefresh(manifest, true);\n+      notifySourceInfoRefresh(manifest, processedInitialSeekCount);\n       return;\n     }\n \n     int periodIndex = timeline.getIndexOfPeriod(periodHolder.uid);\n     if (periodIndex == C.INDEX_UNSET) {\n-      // We didn't find the current period in the new timeline. Attempt to restart.\n-      boolean restarted = attemptRestart(periodHolder, oldTimeline, timeline);\n-      finishSourceInfoRefresh(manifest, true);\n-      if (!restarted) {\n+      // We didn't find the current period in the new timeline. Attempt to resolve a subsequent\n+      // period whose window we can restart from.\n+      int newPeriodIndex = resolveSubsequentPeriod(periodHolder.index, oldTimeline, timeline);\n+      if (newPeriodIndex == C.INDEX_UNSET) {\n+        // We failed to resolve a subsequent period. Stop the player.\n+        notifySourceInfoRefresh(manifest, processedInitialSeekCount);\n         // TODO: We should probably propagate an error here.\n         stopInternal();\n+        return;\n       }\n+      // Release all loaded periods.\n+      releasePeriodHoldersFrom(periodHolder);\n+      playingPeriodHolder = null;\n+      readingPeriodHolder = null;\n+      loadingPeriodHolder = null;\n+      // Find the default initial position in the window and seek to it.\n+      Pair<Integer, Long> defaultPosition = getPeriodPosition(\n+          timeline.getPeriod(newPeriodIndex, period).windowIndex, C.TIME_UNSET);\n+      newPeriodIndex = defaultPosition.first;\n+      long newPlayingPositionUs = defaultPosition.second;\n+      playbackInfo = new PlaybackInfo(newPeriodIndex, newPlayingPositionUs);\n+      notifySourceInfoRefresh(manifest, processedInitialSeekCount);\n       return;\n     }\n \n@@ -925,40 +944,12 @@ private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifes\n       }\n     }\n \n-    finishSourceInfoRefresh(manifest, true);\n+    notifySourceInfoRefresh(manifest, processedInitialSeekCount);\n   }\n \n-  private boolean attemptRestart(MediaPeriodHolder oldPeriodHolder, Timeline oldTimeline,\n-      Timeline newTimeline) {\n-    int newPeriodIndex = resolveSubsequentPeriod(oldPeriodHolder.index, oldTimeline, newTimeline);\n-    if (newPeriodIndex == C.INDEX_UNSET) {\n-      // We failed to find a replacement period. Stop the player.\n-      return false;\n-    }\n-\n-    // Release all loaded periods.\n-    releasePeriodHoldersFrom(oldPeriodHolder);\n-    playingPeriodHolder = null;\n-    readingPeriodHolder = null;\n-    loadingPeriodHolder = null;\n-\n-    // Find the default initial position in the window and seek to it.\n-    Pair<Integer, Long> defaultPosition = getPeriodPosition(\n-        timeline.getPeriod(newPeriodIndex, period).windowIndex, C.TIME_UNSET);\n-    newPeriodIndex = defaultPosition.first;\n-    long newPlayingPositionUs = defaultPosition.second;\n-    playbackInfo = new PlaybackInfo(newPeriodIndex, newPlayingPositionUs);\n-    return true;\n-  }\n-\n-  private void finishSourceInfoRefresh(Object manifest, boolean processedInitialSeeks) {\n-    SourceInfo sourceInfo = new SourceInfo(timeline, manifest, playbackInfo,\n-        processedInitialSeeks ? pendingInitialSeekCount : 0);\n-    eventHandler.obtainMessage(MSG_SOURCE_INFO_REFRESHED, sourceInfo).sendToTarget();\n-    if (processedInitialSeeks) {\n-      pendingInitialSeekCount = 0;\n-      pendingSeekPosition = null;\n-    }\n+  private void notifySourceInfoRefresh(Object manifest, int processedInitialSeekCount) {\n+    eventHandler.obtainMessage(MSG_SOURCE_INFO_REFRESHED,\n+        new SourceInfo(timeline, manifest, playbackInfo, processedInitialSeekCount)).sendToTarget();\n   }\n \n   /**",
      "parent_sha": "9d7d8adc9c1cb9a683efac1ea06288fd393f9bfb"
    }
  },
  {
    "oid": "90412168e4fcf5438ce3fd998a3d90a90af8dd77",
    "message": "Add @RequiresApi(29) to RandomizedMp3Decoder\n\nThis is needed for the MediaFormat#getInteger calls in onConfigured().\n\nThe end-to-end playback tests this is used for have to run on API 29\nanyway (because of ShadowMediaCodec and ShadowMediaCodecList\nfunctionality).\n\n#minor-release\n\nPiperOrigin-RevId: 353858622",
    "date": "2021-02-01T22:54:24Z",
    "url": "https://github.com/google/ExoPlayer/commit/90412168e4fcf5438ce3fd998a3d90a90af8dd77",
    "details": {
      "sha": "3edc847273650458188b432dbc9fae7cce9036d5",
      "filename": "robolectricutils/src/main/java/com/google/android/exoplayer2/robolectric/RandomizedMp3Decoder.java",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/google/ExoPlayer/blob/90412168e4fcf5438ce3fd998a3d90a90af8dd77/robolectricutils%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Frobolectric%2FRandomizedMp3Decoder.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/90412168e4fcf5438ce3fd998a3d90a90af8dd77/robolectricutils%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Frobolectric%2FRandomizedMp3Decoder.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/robolectricutils%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Frobolectric%2FRandomizedMp3Decoder.java?ref=90412168e4fcf5438ce3fd998a3d90a90af8dd77",
      "patch": "@@ -20,6 +20,7 @@\n import android.media.MediaCrypto;\n import android.media.MediaFormat;\n import android.view.Surface;\n+import androidx.annotation.RequiresApi;\n import com.google.android.exoplayer2.audio.MpegAudioUtil;\n import com.google.android.exoplayer2.testutil.TestUtil;\n import com.google.android.exoplayer2.util.Assertions;\n@@ -41,6 +42,7 @@\n  *\n  * <p>All the data written to the output by the decoder can be obtained by getAllOutputBytes().\n  */\n+@RequiresApi(29)\n public final class RandomizedMp3Decoder implements ShadowMediaCodec.CodecConfig.Codec {\n   private final List<byte[]> decoderOutput = new ArrayList<>();\n   private int frameSizeInBytes;\n@@ -70,9 +72,6 @@ public void process(ByteBuffer in, ByteBuffer out) {\n \n   @Override\n   public void onConfigured(MediaFormat format, Surface surface, MediaCrypto crypto, int flags) {\n-    // Both getInteger and getString require API29. This class is only used in EndToEndGaplessTest\n-    // that only runs on\n-    // API29.\n     int pcmEncoding =\n         format.getInteger(\n             MediaFormat.KEY_PCM_ENCODING, /* defaultValue= */ AudioFormat.ENCODING_PCM_16BIT);",
      "parent_sha": "9b95b4628643b65e5d443659087e1b644912db56"
    }
  },
  {
    "oid": "e61ff42adb3668a75af5c0b28101bed23eccee78",
    "message": "Transformer: Remove obsolete TODO from TransformationException.\n\nThe bug has since been fixed.\n\nThe values still could change, as the API is labelled as @UnstableApi, so it's\nprobably fine to leave the <p> tag mostly as is.\n\nPiperOrigin-RevId: 490509205",
    "date": "2022-11-24T15:00:08Z",
    "url": "https://github.com/google/ExoPlayer/commit/e61ff42adb3668a75af5c0b28101bed23eccee78",
    "details": {
      "sha": "eb670271a00c85f3d4625503a6498db8885689ec",
      "filename": "library/transformer/src/main/java/com/google/android/exoplayer2/transformer/TransformationException.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/google/ExoPlayer/blob/e61ff42adb3668a75af5c0b28101bed23eccee78/library%2Ftransformer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftransformer%2FTransformationException.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/e61ff42adb3668a75af5c0b28101bed23eccee78/library%2Ftransformer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftransformer%2FTransformationException.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Ftransformer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftransformer%2FTransformationException.java?ref=e61ff42adb3668a75af5c0b28101bed23eccee78",
      "patch": "@@ -39,12 +39,11 @@\n public final class TransformationException extends Exception {\n \n   /**\n-   * Codes that identify causes of {@link Transformer} errors.\n+   * Error codes that identify causes of {@link Transformer} errors.\n    *\n    * <p>This list of errors may be extended in future versions. The underlying values may also\n    * change, so it is best to avoid relying on them directly without using the constants.\n    */\n-  // TODO(b/209469847): Update the javadoc once the underlying values are fixed.\n   @Documented\n   @Retention(RetentionPolicy.SOURCE)\n   @Target(TYPE_USE)",
      "parent_sha": "f262e9132b32ad89f65853086f30389925b61422"
    }
  },
  {
    "oid": "2813c0699fef8a2e4df5a37534401cbdaa8af572",
    "message": "Clarify threading requirements for the player in the doc.\n\nThis makes the requirement that all calls are made on one thread more\nexplicit and also mentions this in the Getting Started guide.\n\nIssue:#4278\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=198694579",
    "date": "2018-06-05T11:28:16Z",
    "url": "https://github.com/google/ExoPlayer/commit/2813c0699fef8a2e4df5a37534401cbdaa8af572",
    "details": {
      "sha": "b97790d5fb2b297cba844dcde1aac8cfbe08ab71",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/google/ExoPlayer/blob/2813c0699fef8a2e4df5a37534401cbdaa8af572/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FExoPlayer.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/2813c0699fef8a2e4df5a37534401cbdaa8af572/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FExoPlayer.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FExoPlayer.java?ref=2813c0699fef8a2e4df5a37534401cbdaa8af572",
      "patch": "@@ -89,12 +89,12 @@\n  * model\">\n  *\n  * <ul>\n- *   <li>It is strongly recommended that ExoPlayer instances are created and accessed from a single\n- *       application thread. The application's main thread is ideal. Accessing an instance from\n- *       multiple threads is discouraged as it may cause synchronization problems.\n- *   <li>Registered listeners are called on the thread that created the ExoPlayer instance, unless\n- *       the thread that created the ExoPlayer instance does not have a {@link Looper}. In that\n- *       case, registered listeners will be called on the application's main thread.\n+ *   <li>ExoPlayer instances must be accessed from a single application thread. This must be the\n+ *       thread the player is created on if that thread has a {@link Looper}, or the application's\n+ *       main thread otherwise.\n+ *   <li>Registered listeners are called on the thread the player is created on if that thread has a\n+ *       {@link Looper}, or the application's main thread otherwise. Note that this means registered\n+ *       listeners are called on the same thread which must be used to access the player.\n  *   <li>An internal playback thread is responsible for playback. Injected player components such as\n  *       Renderers, MediaSources, TrackSelectors and LoadControls are called by the player on this\n  *       thread.",
      "parent_sha": "9852af7372ee4bb68d9bb73f4935e7caf3294f69"
    }
  },
  {
    "oid": "aafa31e996f30daebec12f5e9e61aab1dbd0ba81",
    "message": "Fix frame processor reference\n\nPiperOrigin-RevId: 465562260",
    "date": "2022-10-19T16:44:08Z",
    "url": "https://github.com/google/ExoPlayer/commit/aafa31e996f30daebec12f5e9e61aab1dbd0ba81",
    "details": {
      "sha": "5b36a5f170da386be6119db0b343377c332487a7",
      "filename": "library/transformer/src/main/java/com/google/android/exoplayer2/transformer/TransformationException.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/google/ExoPlayer/blob/aafa31e996f30daebec12f5e9e61aab1dbd0ba81/library%2Ftransformer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftransformer%2FTransformationException.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/aafa31e996f30daebec12f5e9e61aab1dbd0ba81/library%2Ftransformer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftransformer%2FTransformationException.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Ftransformer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftransformer%2FTransformationException.java?ref=aafa31e996f30daebec12f5e9e61aab1dbd0ba81",
      "patch": "@@ -23,6 +23,7 @@\n import androidx.annotation.IntDef;\n import androidx.annotation.Nullable;\n import androidx.media3.common.FrameProcessingException;\n+import androidx.media3.common.FrameProcessor;\n import com.google.android.exoplayer2.Format;\n import com.google.android.exoplayer2.PlaybackException;\n import com.google.android.exoplayer2.audio.AudioProcessor;\n@@ -273,7 +274,7 @@ public static TransformationException createForAudioProcessor(\n   }\n \n   /**\n-   * Creates an instance for a {@link GlEffectsFrameProcessor} related exception.\n+   * Creates an instance for a {@link FrameProcessor} related exception.\n    *\n    * @param cause The cause of the failure.\n    * @param errorCode See {@link #errorCode}.",
      "parent_sha": "6da0a3543491a9d9bb3dbfaf1b203a04f7a19f5c"
    }
  },
  {
    "oid": "ba5f35995f21c9c2a86842ac9dce1d13009a6378",
    "message": "Send discontinuity at adjustments after shuffle/repeat mode changes.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=176749136",
    "date": "2017-11-23T15:09:04Z",
    "url": "https://github.com/google/ExoPlayer/commit/ba5f35995f21c9c2a86842ac9dce1d13009a6378",
    "details": {
      "sha": "316735da77d08d57a92f12cffd57d7f468e9ff0d",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/google/ExoPlayer/blob/ba5f35995f21c9c2a86842ac9dce1d13009a6378/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FExoPlayerImplInternal.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/ba5f35995f21c9c2a86842ac9dce1d13009a6378/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FExoPlayerImplInternal.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FExoPlayerImplInternal.java?ref=ba5f35995f21c9c2a86842ac9dce1d13009a6378",
      "patch": "@@ -476,8 +476,12 @@ private void validateExistingPeriodHolders() throws ExoPlaybackException {\n       // position of the playing period to make sure none of the removed period is played.\n       MediaPeriodId periodId = playingPeriodHolder.info.id;\n       long newPositionUs = seekToPeriodPosition(periodId, playbackInfo.positionUs);\n-      playbackInfo = playbackInfo.fromNewPosition(periodId, newPositionUs,\n+      if (newPositionUs != playbackInfo.positionUs) {\n+        playbackInfo = playbackInfo.fromNewPosition(periodId, newPositionUs,\n           playbackInfo.contentPositionUs);\n+        eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY, Player.DISCONTINUITY_REASON_INTERNAL,\n+          0, playbackInfo).sendToTarget();\n+      }\n     }\n   }\n ",
      "parent_sha": "1442c047cffc17d9307d4579a805c1def64b4f22"
    }
  },
  {
    "oid": "42b641221c9cb72c5058769bf84d7e7583fd50ea",
    "message": "Provide flag to disable throwing of cache initialization exceptions\n\nPiperOrigin-RevId: 241497141",
    "date": "2019-04-05T19:49:06Z",
    "url": "https://github.com/google/ExoPlayer/commit/42b641221c9cb72c5058769bf84d7e7583fd50ea",
    "details": {
      "sha": "0e4be169b691debd0ee3e263aa4c2a9220345623",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java",
      "status": "modified",
      "additions": 12,
      "deletions": 1,
      "changes": 13,
      "blob_url": "https://github.com/google/ExoPlayer/blob/42b641221c9cb72c5058769bf84d7e7583fd50ea/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fupstream%2Fcache%2FSimpleCache.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/42b641221c9cb72c5058769bf84d7e7583fd50ea/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fupstream%2Fcache%2FSimpleCache.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fupstream%2Fcache%2FSimpleCache.java?ref=42b641221c9cb72c5058769bf84d7e7583fd50ea",
      "patch": "@@ -62,6 +62,7 @@ public final class SimpleCache implements Cache {\n   private static final HashSet<File> lockedCacheDirs = new HashSet<>();\n \n   private static boolean cacheFolderLockingDisabled;\n+  private static boolean cacheInitializationExceptionsDisabled;\n \n   private final File cacheDir;\n   private final CacheEvictor evictor;\n@@ -100,6 +101,16 @@ public static synchronized void disableCacheFolderLocking() {\n     lockedCacheDirs.clear();\n   }\n \n+  /**\n+   * Disables throwing of cache initialization exceptions.\n+   *\n+   * @deprecated Don't use this. Provided for problematic upgrade cases only.\n+   */\n+  @Deprecated\n+  public static void disableCacheInitializationExceptions() {\n+    cacheInitializationExceptionsDisabled = true;\n+  }\n+\n   /**\n    * Deletes all content belonging to a cache instance.\n    *\n@@ -272,7 +283,7 @@ public void run() {\n    * @throws CacheException If an error occurred during initialization.\n    */\n   public synchronized void checkInitialization() throws CacheException {\n-    if (initializationException != null) {\n+    if (!cacheInitializationExceptionsDisabled && initializationException != null) {\n       throw initializationException;\n     }\n   }",
      "parent_sha": "9dc22c3086590bd36f67ec2c6ced0b1d2f7b4865"
    }
  },
  {
    "oid": "8d450a9f9d9d12db1dbe53db2d729c3515c10106",
    "message": "Fix assertThat actual/expected order\n\nPiperOrigin-RevId: 308844678",
    "date": "2020-05-01T18:45:38Z",
    "url": "https://github.com/google/ExoPlayer/commit/8d450a9f9d9d12db1dbe53db2d729c3515c10106",
    "details": {
      "sha": "4e7b71aa41731f83c987ee9e805a30b59a5f6601",
      "filename": "testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/google/ExoPlayer/blob/8d450a9f9d9d12db1dbe53db2d729c3515c10106/testutils%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftestutil%2FTestUtil.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/8d450a9f9d9d12db1dbe53db2d729c3515c10106/testutils%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftestutil%2FTestUtil.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/testutils%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftestutil%2FTestUtil.java?ref=8d450a9f9d9d12db1dbe53db2d729c3515c10106",
      "patch": "@@ -271,10 +271,10 @@ public static void assertDataSourceContent(\n   /** Returns whether two {@link android.media.MediaCodec.BufferInfo BufferInfos} are equal. */\n   public static void assertBufferInfosEqual(\n       MediaCodec.BufferInfo expected, MediaCodec.BufferInfo actual) {\n-    assertThat(expected.flags).isEqualTo(actual.flags);\n-    assertThat(expected.offset).isEqualTo(actual.offset);\n-    assertThat(expected.presentationTimeUs).isEqualTo(actual.presentationTimeUs);\n-    assertThat(expected.size).isEqualTo(actual.size);\n+    assertThat(actual.flags).isEqualTo(expected.flags);\n+    assertThat(actual.offset).isEqualTo(expected.offset);\n+    assertThat(actual.presentationTimeUs).isEqualTo(expected.presentationTimeUs);\n+    assertThat(actual.size).isEqualTo(expected.size);\n   }\n \n   /**",
      "parent_sha": "2d494861ec61672af9fdde943cfd42cc69a5acda"
    }
  },
  {
    "oid": "d4ca29d748938878a74ad9027eedcf96eb498e49",
    "message": "Set master playlist's channelCount only on audio renditions\n\nPiperOrigin-RevId: 379935363",
    "date": "2021-06-21T21:04:04Z",
    "url": "https://github.com/google/ExoPlayer/commit/d4ca29d748938878a74ad9027eedcf96eb498e49",
    "details": {
      "sha": "0a6cb78774b4f72aa4cbb5f4b0a2069f680cab44",
      "filename": "library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java",
      "status": "modified",
      "additions": 9,
      "deletions": 5,
      "changes": 14,
      "blob_url": "https://github.com/google/ExoPlayer/blob/d4ca29d748938878a74ad9027eedcf96eb498e49/library%2Fhls%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fhls%2FHlsSampleStreamWrapper.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/d4ca29d748938878a74ad9027eedcf96eb498e49/library%2Fhls%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fhls%2FHlsSampleStreamWrapper.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fhls%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fhls%2FHlsSampleStreamWrapper.java?ref=d4ca29d748938878a74ad9027eedcf96eb498e49",
      "patch": "@@ -1504,16 +1504,20 @@ private static Format deriveFormat(\n             .setRoleFlags(playlistFormat.roleFlags)\n             .setAverageBitrate(propagateBitrates ? playlistFormat.averageBitrate : Format.NO_VALUE)\n             .setPeakBitrate(propagateBitrates ? playlistFormat.peakBitrate : Format.NO_VALUE)\n-            .setCodecs(codecs)\n-            .setWidth(playlistFormat.width)\n-            .setHeight(playlistFormat.height)\n-            .setFrameRate(playlistFormat.frameRate);\n+            .setCodecs(codecs);\n+\n+    if (sampleTrackType == C.TRACK_TYPE_VIDEO) {\n+      formatBuilder\n+          .setWidth(playlistFormat.width)\n+          .setHeight(playlistFormat.height)\n+          .setFrameRate(playlistFormat.frameRate);\n+    }\n \n     if (sampleMimeType != null) {\n       formatBuilder.setSampleMimeType(sampleMimeType);\n     }\n \n-    if (playlistFormat.channelCount != Format.NO_VALUE) {\n+    if (playlistFormat.channelCount != Format.NO_VALUE && sampleTrackType == C.TRACK_TYPE_AUDIO) {\n       formatBuilder.setChannelCount(playlistFormat.channelCount);\n     }\n ",
      "parent_sha": "b5a464cbccd8109aabf0e6bc40f7c0860580c874"
    }
  },
  {
    "oid": "03ebc5b52f618ef65bf4dc84f12f40b95cc6be08",
    "message": "Move readPosition modification out of readSampleMetadata\n\nPreparation CL for SampleQueue.peek.\n\nPiperOrigin-RevId: 351439887",
    "date": "2021-01-13T00:04:23Z",
    "url": "https://github.com/google/ExoPlayer/commit/03ebc5b52f618ef65bf4dc84f12f40b95cc6be08",
    "details": {
      "sha": "ccbfd6a0b0baf62f953b7d5925f9ea69bfb449ea",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java",
      "status": "modified",
      "additions": 3,
      "deletions": 6,
      "changes": 9,
      "blob_url": "https://github.com/google/ExoPlayer/blob/03ebc5b52f618ef65bf4dc84f12f40b95cc6be08/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2FSampleQueue.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/03ebc5b52f618ef65bf4dc84f12f40b95cc6be08/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2FSampleQueue.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2FSampleQueue.java?ref=03ebc5b52f618ef65bf4dc84f12f40b95cc6be08",
      "patch": "@@ -403,9 +403,10 @@ public int read(\n       boolean formatRequired,\n       boolean loadingFinished) {\n     int result =\n-        readSampleMetadata(formatHolder, buffer, formatRequired, loadingFinished, extrasHolder);\n+        peekSampleMetadata(formatHolder, buffer, formatRequired, loadingFinished, extrasHolder);\n     if (result == C.RESULT_BUFFER_READ && !buffer.isEndOfStream() && !buffer.isFlagsOnly()) {\n       sampleDataQueue.readToBuffer(buffer, extrasHolder);\n+      readPosition++;\n     }\n     return result;\n   }\n@@ -650,7 +651,7 @@ private synchronized void rewind() {\n   }\n \n   @SuppressWarnings(\"ReferenceEquality\") // See comments in setUpstreamFormat\n-  private synchronized int readSampleMetadata(\n+  private synchronized int peekSampleMetadata(\n       FormatHolder formatHolder,\n       DecoderInputBuffer buffer,\n       boolean formatRequired,\n@@ -685,14 +686,10 @@ private synchronized int readSampleMetadata(\n     if (buffer.timeUs < startTimeUs) {\n       buffer.addFlag(C.BUFFER_FLAG_DECODE_ONLY);\n     }\n-    if (buffer.isFlagsOnly()) {\n-      return C.RESULT_BUFFER_READ;\n-    }\n     extrasHolder.size = sizes[relativeReadIndex];\n     extrasHolder.offset = offsets[relativeReadIndex];\n     extrasHolder.cryptoData = cryptoDatas[relativeReadIndex];\n \n-    readPosition++;\n     return C.RESULT_BUFFER_READ;\n   }\n ",
      "parent_sha": "69423bc2b4c6cdfa6f29c7d66a97a5a73b63b45a"
    }
  },
  {
    "oid": "b2997180362d9a1cec5647259eaa7cdca844cb72",
    "message": "Make removal of non-existent cache span a no-op\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=155413733",
    "date": "2017-05-08T21:39:14Z",
    "url": "https://github.com/google/ExoPlayer/commit/b2997180362d9a1cec5647259eaa7cdca844cb72",
    "details": {
      "sha": "bbff7dc4a289cda815eebe9604256275946b0a74",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/google/ExoPlayer/blob/b2997180362d9a1cec5647259eaa7cdca844cb72/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fupstream%2Fcache%2FSimpleCache.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/b2997180362d9a1cec5647259eaa7cdca844cb72/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fupstream%2Fcache%2FSimpleCache.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fupstream%2Fcache%2FSimpleCache.java?ref=b2997180362d9a1cec5647259eaa7cdca844cb72",
      "patch": "@@ -286,7 +286,9 @@ private void addSpan(SimpleCacheSpan span) {\n \n   private void removeSpan(CacheSpan span, boolean removeEmptyCachedContent) throws CacheException {\n     CachedContent cachedContent = index.get(span.key);\n-    Assertions.checkState(cachedContent.removeSpan(span));\n+    if (cachedContent == null || !cachedContent.removeSpan(span)) {\n+      return;\n+    }\n     totalSpace -= span.length;\n     if (removeEmptyCachedContent && cachedContent.isEmpty()) {\n       index.removeEmpty(cachedContent.key);",
      "parent_sha": "812068a2087c2d5c1b7b84b39881aadd4a33555a"
    }
  },
  {
    "oid": "37fd65a8e51ddba92584109217114d9f2c2f009d",
    "message": "Fix recursive loop when registering controller visibility listeners\n\nThere are two overloads of this method due to a type 'rename' from\n`PlayerControlView.VisibilityListener` to\n`PlayerView.ControllerVisibilityListener`. Currently when you call one\noverload it passes `null` to the other one (to clear the other listener).\nUnfortunately this results in it clearing itself, because it receives\na null call back!\n\nThis change tweaks the documentation to clarify that the 'other'\nlistener is only cleared if you pass a non-null listener in. This solves\nthe recursive problem, and allows the 'legacy' visibility listener to be\nsuccessfully registered.\n\nIssue: androidx/media#229\n\n#minor-release\n\nPiperOrigin-RevId: 496876397",
    "date": "2022-12-21T17:57:57Z",
    "url": "https://github.com/google/ExoPlayer/commit/37fd65a8e51ddba92584109217114d9f2c2f009d",
    "details": {
      "sha": "48e6821f52593fecbd835bc4d766f930c3b57294",
      "filename": "library/ui/src/main/java/com/google/android/exoplayer2/ui/StyledPlayerView.java",
      "status": "modified",
      "additions": 8,
      "deletions": 6,
      "changes": 14,
      "blob_url": "https://github.com/google/ExoPlayer/blob/37fd65a8e51ddba92584109217114d9f2c2f009d/library%2Fui%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FStyledPlayerView.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/37fd65a8e51ddba92584109217114d9f2c2f009d/library%2Fui%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FStyledPlayerView.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fui%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FStyledPlayerView.java?ref=37fd65a8e51ddba92584109217114d9f2c2f009d",
      "patch": "@@ -868,23 +868,25 @@ public void setControllerHideDuringAds(boolean controllerHideDuringAds) {\n   /**\n    * Sets the {@link StyledPlayerControlView.VisibilityListener}.\n    *\n-   * <p>Removes any listener set by {@link\n-   * #setControllerVisibilityListener(StyledPlayerControlView.VisibilityListener)}.\n+   * <p>If {@code listener} is non-null then any listener set by {@link\n+   * #setControllerVisibilityListener(StyledPlayerControlView.VisibilityListener)} is removed.\n    *\n    * @param listener The listener to be notified about visibility changes, or null to remove the\n    *     current listener.\n    */\n   @SuppressWarnings(\"deprecation\") // Clearing the legacy listener.\n   public void setControllerVisibilityListener(@Nullable ControllerVisibilityListener listener) {\n     this.controllerVisibilityListener = listener;\n-    setControllerVisibilityListener((StyledPlayerControlView.VisibilityListener) null);\n+    if (listener != null) {\n+      setControllerVisibilityListener((StyledPlayerControlView.VisibilityListener) null);\n+    }\n   }\n \n   /**\n    * Sets the {@link StyledPlayerControlView.VisibilityListener}.\n    *\n-   * <p>Removes any listener set by {@link\n-   * #setControllerVisibilityListener(ControllerVisibilityListener)}.\n+   * <p>If {@code listener} is non-null then any listener set by {@link\n+   * #setControllerVisibilityListener(ControllerVisibilityListener)} is removed.\n    *\n    * @deprecated Use {@link #setControllerVisibilityListener(ControllerVisibilityListener)} instead.\n    */\n@@ -903,8 +905,8 @@ public void setControllerVisibilityListener(\n     this.legacyControllerVisibilityListener = listener;\n     if (listener != null) {\n       controller.addVisibilityListener(listener);\n+      setControllerVisibilityListener((ControllerVisibilityListener) null);\n     }\n-    setControllerVisibilityListener((ControllerVisibilityListener) null);\n   }\n \n   /**",
      "parent_sha": "b7e887a58dff7615926f8002ee3210b3071c5537"
    }
  },
  {
    "oid": "1ed048dba80f4b3e2e9e8da8aff4578f2e24b0d1",
    "message": "Clean up TTML timestamp parsing.",
    "date": "2014-09-23T10:13:54Z",
    "url": "https://github.com/google/ExoPlayer/commit/1ed048dba80f4b3e2e9e8da8aff4578f2e24b0d1",
    "details": {
      "sha": "2fd1850f534d7190e107ee1e4b1e5395a7c2eaea",
      "filename": "library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/google/ExoPlayer/blob/1ed048dba80f4b3e2e9e8da8aff4578f2e24b0d1/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer%2Ftext%2Fttml%2FTtmlParser.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/1ed048dba80f4b3e2e9e8da8aff4578f2e24b0d1/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer%2Ftext%2Fttml%2FTtmlParser.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer%2Ftext%2Fttml%2FTtmlParser.java?ref=1ed048dba80f4b3e2e9e8da8aff4578f2e24b0d1",
      "patch": "@@ -233,22 +233,22 @@ private static long parseTimeExpression(String time, int frameRate, int subframe\n     matcher = OFFSET_TIME.matcher(time);\n     if (matcher.matches()) {\n       String timeValue = matcher.group(1);\n-      double value = Double.parseDouble(timeValue);\n+      double offsetSeconds = Double.parseDouble(timeValue);\n       String unit = matcher.group(2);\n       if (unit.equals(\"h\")) {\n-        value *= 3600L * 1000000L;\n+        offsetSeconds *= 3600;\n       } else if (unit.equals(\"m\")) {\n-        value *= 60 * 1000000;\n+        offsetSeconds *= 60;\n       } else if (unit.equals(\"s\")) {\n-        value *= 1000000;\n+        // Do nothing.\n       } else if (unit.equals(\"ms\")) {\n-        value *= 1000;\n+        offsetSeconds /= 1000;\n       } else if (unit.equals(\"f\")) {\n-        value = value / frameRate * 1000000;\n+        offsetSeconds /= frameRate;\n       } else if (unit.equals(\"t\")) {\n-        value = value / tickRate * 1000000;\n+        offsetSeconds /= tickRate;\n       }\n-      return (long) value;\n+      return (long) (offsetSeconds * 1000000);\n     }\n     throw new NumberFormatException(\"Malformed time expression: \" + time);\n   }",
      "parent_sha": "7cb55e23f6877fccdc376b705c16e8eb8b051c36"
    }
  },
  {
    "oid": "0e992370752e8570c330f70d83d5dd34a09e4228",
    "message": "Allow duplicate tracks in WebM/MKV extractor\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=145457836",
    "date": "2017-01-25T19:21:55Z",
    "url": "https://github.com/google/ExoPlayer/commit/0e992370752e8570c330f70d83d5dd34a09e4228",
    "details": {
      "sha": "970335e9d2527342b4172d4a1bc32da7c05bd696",
      "filename": "library/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/google/ExoPlayer/blob/0e992370752e8570c330f70d83d5dd34a09e4228/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2Fmkv%2FMatroskaExtractor.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/0e992370752e8570c330f70d83d5dd34a09e4228/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2Fmkv%2FMatroskaExtractor.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2Fmkv%2FMatroskaExtractor.java?ref=0e992370752e8570c330f70d83d5dd34a09e4228",
      "patch": "@@ -529,11 +529,9 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce\n         }\n         break;\n       case ID_TRACK_ENTRY:\n-        if (tracks.get(currentTrack.number) == null && isCodecSupported(currentTrack.codecId)) {\n+        if (isCodecSupported(currentTrack.codecId)) {\n           currentTrack.initializeOutput(extractorOutput, currentTrack.number);\n           tracks.put(currentTrack.number, currentTrack);\n-        } else {\n-          // We've seen this track entry before, or the codec is unsupported. Do nothing.\n         }\n         currentTrack = null;\n         break;",
      "parent_sha": "c01c2c34f731cf96baf1022e6cdbb68a9f0aca40"
    }
  },
  {
    "oid": "2c801ca2678016d5464caf214f45e6448f018756",
    "message": "docs(playlist): fix javadoc comments",
    "date": "2018-07-24T08:08:27Z",
    "url": "https://github.com/google/ExoPlayer/commit/2c801ca2678016d5464caf214f45e6448f018756",
    "details": {
      "sha": "a3bc8511b87d36effc82b6ced4d8fcf34310c654",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/google/ExoPlayer/blob/2c801ca2678016d5464caf214f45e6448f018756/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2FConcatenatingMediaSource.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/2c801ca2678016d5464caf214f45e6448f018756/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2FConcatenatingMediaSource.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2FConcatenatingMediaSource.java?ref=2c801ca2678016d5464caf214f45e6448f018756",
      "patch": "@@ -280,10 +280,10 @@ public final synchronized void removeMediaSource(int index) {\n    * Removes a {@link MediaSource} from the playlist and executes a custom action on completion.\n    *\n    * <p>Note: If you want to move the instance, it's preferable to use {@link #moveMediaSource(int,\n-   * int)} instead.\n+   * int, Runnable)} instead.\n    *\n    * <p>Note: If you want to remove a set of contiguous sources, it's preferable to use\n-   * {@link #removeMediaSourceRange(int, int)} instead.\n+   * {@link #removeMediaSourceRange(int, int, Runnable)} instead.\n    *\n    * @param index The index at which the media source will be removed. This index must be in the\n    *     range of 0 &lt;= index &lt; {@link #getSize()}.\n@@ -346,7 +346,7 @@ public final synchronized void removeMediaSourceRange(int fromIndex, int toIndex\n    * @throws IndexOutOfBoundsException when range is malformed, i.e. {@code fromIndex} &gt;\n    *      {@code toIndex}\n    * @param actionOnCompletion A {@link Runnable} which is executed immediately after the media\n-   *     source has been removed from the playlist.\n+   *     source range has been removed from the playlist.\n    */\n   public final synchronized void removeMediaSourceRange(\n           int fromIndex, int toIndex, @Nullable Runnable actionOnCompletion) {",
      "parent_sha": "c9b6a73cd8b820cac80d3343829e1f3dc122db18"
    }
  },
  {
    "oid": "f155aa2563e6d9a64b0ad948b1f9865ba13d6777",
    "message": "Add getMinimumLoadableRetryCount to LoadErrorHandlingPolicy.\n\nThis will allow deduplicating the argument from all Loader clients.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=204889331",
    "date": "2018-07-17T19:34:36Z",
    "url": "https://github.com/google/ExoPlayer/commit/f155aa2563e6d9a64b0ad948b1f9865ba13d6777",
    "details": {
      "sha": "8d6c0b9cf130d9217fe332169d8a3554d885e497",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/upstream/LoadErrorHandlingPolicy.java",
      "status": "modified",
      "additions": 24,
      "deletions": 2,
      "changes": 26,
      "blob_url": "https://github.com/google/ExoPlayer/blob/f155aa2563e6d9a64b0ad948b1f9865ba13d6777/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fupstream%2FLoadErrorHandlingPolicy.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/f155aa2563e6d9a64b0ad948b1f9865ba13d6777/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fupstream%2FLoadErrorHandlingPolicy.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fupstream%2FLoadErrorHandlingPolicy.java?ref=f155aa2563e6d9a64b0ad948b1f9865ba13d6777",
      "patch": "@@ -19,6 +19,7 @@\n import com.google.android.exoplayer2.ParserException;\n import com.google.android.exoplayer2.source.chunk.ChunkedTrackBlacklistUtil;\n import com.google.android.exoplayer2.upstream.HttpDataSource.InvalidResponseCodeException;\n+import com.google.android.exoplayer2.upstream.Loader.Callback;\n import com.google.android.exoplayer2.upstream.Loader.Loadable;\n import java.io.IOException;\n \n@@ -32,13 +33,17 @@\n  * blacklisted. Blacklisting will succeed if any of the alternatives is not in the black list.\n  *\n  * <p>When blacklisting does not take place, {@link #getRetryDelayMsFor(T, long, IOException, int)}\n- * defines whether the load is retried. Loader clients define when to propagate retry attempt\n- * errors. Errors that are not retried are propagated.\n+ * defines whether the load is retried. Errors whose load is not retried are propagated. Load errors\n+ * whose load is retried are propagated according to {@link\n+ * #getMinimumLoadableRetryCount(Loadable)}.\n  *\n  * @param <T> The type of the object being loaded.\n  */\n public interface LoadErrorHandlingPolicy<T extends Loadable> {\n \n+  /** The default minimum number of times to retry loading data prior to propagating the error. */\n+  int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;\n+\n   /** Default implementation of {@link LoadErrorHandlingPolicy}. */\n   LoadErrorHandlingPolicy<Loadable> DEFAULT =\n       new LoadErrorHandlingPolicy<Loadable>() {\n@@ -72,6 +77,12 @@ public long getRetryDelayMsFor(\n               ? C.TIME_UNSET\n               : Math.min((errorCount - 1) * 1000, 5000);\n         }\n+\n+        /** Returns {@link #DEFAULT_MIN_LOADABLE_RETRY_COUNT}. */\n+        @Override\n+        public int getMinimumLoadableRetryCount(Loadable loadable) {\n+          return DEFAULT_MIN_LOADABLE_RETRY_COUNT;\n+        }\n       };\n \n   /** Returns {@link #DEFAULT}. */\n@@ -113,4 +124,15 @@ long getBlacklistDurationMsFor(\n    *     C#TIME_UNSET} if the error is fatal and should not be retried.\n    */\n   long getRetryDelayMsFor(T loadable, long loadDurationMs, IOException exception, int errorCount);\n+\n+  /**\n+   * Returns the minimum number of times to retry a load in the case of a load error, before\n+   * propagating the error.\n+   *\n+   * @param loadable The loadable to load.\n+   * @return The minimum number of times to retry a load in the case of a load error, before\n+   *     propagating the error.\n+   * @see Loader#startLoading(Loadable, Callback, int)\n+   */\n+  int getMinimumLoadableRetryCount(T loadable);\n }",
      "parent_sha": "6aab2bdc5545b8013e0989b4034efa572c139d1a"
    }
  },
  {
    "oid": "d5425bb64acdff5e67913232ac0f1c27748f1e6a",
    "message": "resolve #1095 store the language as normalised attribute so we can access it from the track parser",
    "date": "2016-01-16T11:35:23Z",
    "url": "https://github.com/google/ExoPlayer/commit/d5425bb64acdff5e67913232ac0f1c27748f1e6a",
    "details": {
      "sha": "cc4a6996d5013f234aaf9e5a7e56ceb46634510b",
      "filename": "library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/google/ExoPlayer/blob/d5425bb64acdff5e67913232ac0f1c27748f1e6a/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer%2Fsmoothstreaming%2FSmoothStreamingManifestParser.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/d5425bb64acdff5e67913232ac0f1c27748f1e6a/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer%2Fsmoothstreaming%2FSmoothStreamingManifestParser.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer%2Fsmoothstreaming%2FSmoothStreamingManifestParser.java?ref=d5425bb64acdff5e67913232ac0f1c27748f1e6a",
      "patch": "@@ -543,6 +543,7 @@ private void parseStreamElementStartTag(XmlPullParser parser) throws ParserExcep\n       displayWidth = parseInt(parser, KEY_DISPLAY_WIDTH, -1);\n       displayHeight = parseInt(parser, KEY_DISPLAY_HEIGHT, -1);\n       language = parser.getAttributeValue(null, KEY_LANGUAGE);\n+      putNormalizedAttribute(KEY_LANGUAGE, language);\n       timescale = parseInt(parser, KEY_TIME_SCALE, -1);\n       if (timescale == -1) {\n         timescale = (Long) getNormalizedAttribute(KEY_TIME_SCALE);\n@@ -634,12 +635,12 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {\n         // If fourCC is missing and the stream type is audio, we assume AAC.\n         mimeType = fourCC != null ? fourCCToMimeType(fourCC)\n             : type == StreamElement.TYPE_AUDIO ? MimeTypes.AUDIO_AAC : null;\n-        language = (String) getNormalizedAttribute(KEY_LANGUAGE);\n       }\n \n       if (type == StreamElement.TYPE_AUDIO) {\n         samplingRate = parseRequiredInt(parser, KEY_SAMPLING_RATE);\n         channels = parseRequiredInt(parser, KEY_CHANNELS);\n+        language = (String) getNormalizedAttribute(KEY_LANGUAGE);\n       } else {\n         samplingRate = -1;\n         channels = -1;",
      "parent_sha": "19cf24234c8bee0e5719baa86c90fd9e0fb8478b"
    }
  },
  {
    "oid": "3670541465ceb96fc918cd7741c02b95ccd907e1",
    "message": "Add option to disable 5G-NSA disambiguation\n\nPiperOrigin-RevId: 384575860",
    "date": "2021-07-14T11:15:48Z",
    "url": "https://github.com/google/ExoPlayer/commit/3670541465ceb96fc918cd7741c02b95ccd907e1",
    "details": {
      "sha": "488c7947cc2ddbe7307f6ea80163dcba9cc9f197",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/util/NetworkTypeObserver.java",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/google/ExoPlayer/blob/3670541465ceb96fc918cd7741c02b95ccd907e1/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Futil%2FNetworkTypeObserver.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/3670541465ceb96fc918cd7741c02b95ccd907e1/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Futil%2FNetworkTypeObserver.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Futil%2FNetworkTypeObserver.java?ref=3670541465ceb96fc918cd7741c02b95ccd907e1",
      "patch": "@@ -59,6 +59,7 @@ public interface Listener {\n   }\n \n   @Nullable private static NetworkTypeObserver staticInstance;\n+  private static volatile boolean disable5GNsaDisambiguation;\n \n   private final Handler mainHandler;\n   // This class needs to hold weak references as it doesn't require listeners to unregister.\n@@ -69,6 +70,11 @@ public interface Listener {\n   @C.NetworkType\n   private int networkType;\n \n+  /** Disables logic to disambiguate 5G-NSA networks from 4G networks. */\n+  public static void disable5GNsaDisambiguation() {\n+    disable5GNsaDisambiguation = true;\n+  }\n+\n   /**\n    * Returns a network type observer instance.\n    *\n@@ -217,7 +223,7 @@ private final class Receiver extends BroadcastReceiver {\n     @Override\n     public void onReceive(Context context, Intent intent) {\n       @C.NetworkType int networkType = getNetworkTypeFromConnectivityManager(context);\n-      if (networkType == C.NETWORK_TYPE_4G && Util.SDK_INT >= 29) {\n+      if (Util.SDK_INT >= 29 && !disable5GNsaDisambiguation && networkType == C.NETWORK_TYPE_4G) {\n         // Delay update of the network type to check whether this is actually 5G-NSA.\n         try {\n           // We can't access TelephonyManager getters like getServiceState() directly as they",
      "parent_sha": "e403dda1050ba1f6bd9deb4d4813f4cf62584c3e"
    }
  },
  {
    "oid": "87adb88f57afb050a96a9c67dd9eb55fb3a6706c",
    "message": "Fix incorrect link tags\n\nPiperOrigin-RevId: 459215618",
    "date": "2022-07-07T16:44:05Z",
    "url": "https://github.com/google/ExoPlayer/commit/87adb88f57afb050a96a9c67dd9eb55fb3a6706c",
    "details": {
      "sha": "0059a9d99af7b6674b35cd9e104281f907f3a318",
      "filename": "libraries/session/src/main/java/androidx/media3/session/DefaultMediaNotificationProvider.java",
      "status": "modified",
      "additions": 9,
      "deletions": 8,
      "changes": 17,
      "blob_url": "https://github.com/google/ExoPlayer/blob/87adb88f57afb050a96a9c67dd9eb55fb3a6706c/libraries%2Fsession%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fsession%2FDefaultMediaNotificationProvider.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/87adb88f57afb050a96a9c67dd9eb55fb3a6706c/libraries%2Fsession%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fsession%2FDefaultMediaNotificationProvider.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/libraries%2Fsession%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fsession%2FDefaultMediaNotificationProvider.java?ref=87adb88f57afb050a96a9c67dd9eb55fb3a6706c",
      "patch": "@@ -72,10 +72,11 @@\n  * <h2>Custom commands</h2>\n  *\n  * Custom actions are sent to the session under the hood. You can receive them by overriding the\n- * session callback method {@link MediaSession.Callback#onCustomCommand(MediaSession, ControllerInfo\n- * controller, SessionCommand, Bundle)}. This is useful because starting with Android 13, the System\n- * UI notification sends commands directly to the session. So handling the custom commands on the\n- * session level allows you to handle them at the same callback for all API levels.\n+ * session callback method {@link MediaSession.Callback#onCustomCommand(MediaSession,\n+ * MediaSession.ControllerInfo, SessionCommand, Bundle)}. This is useful because starting with\n+ * Android 13, the System UI notification sends commands directly to the session. So handling the\n+ * custom commands on the session level allows you to handle them at the same callback for all API\n+ * levels.\n  *\n  * <h2>Drawables</h2>\n  *\n@@ -230,10 +231,10 @@ public final boolean handleCustomCommand(MediaSession session, String action, Bu\n    * <p>To make the custom layout and commands work, you need to {@linkplain\n    * MediaSession#setCustomLayout(List) set the custom layout of commands} and add the custom\n    * commands to the available commands when a controller {@linkplain\n-   * MediaSession.Callback#onConnect(MediaSession, ControllerInfo) connects to the session}.\n-   * Controllers that connect after you called {@link MediaSession#setCustomLayout(List)} need the\n-   * custom command set in {@link MediaSession.Callback#onPostConnect(MediaSession, ControllerInfo)}\n-   * also.\n+   * MediaSession.Callback#onConnect(MediaSession, MediaSession.ControllerInfo) connects to the\n+   * session}. Controllers that connect after you called {@link MediaSession#setCustomLayout(List)}\n+   * need the custom command set in {@link MediaSession.Callback#onPostConnect(MediaSession,\n+   * MediaSession.ControllerInfo)} also.\n    *\n    * @param playerCommands The available player commands.\n    * @param customLayout The {@linkplain MediaSession#setCustomLayout(List) custom layout of",
      "parent_sha": "f00f93a96e0c7fa4f37e32e280b073d1cef2649e"
    }
  },
  {
    "oid": "dc814fc37db2fb68b7befffff7bcecd7755ee758",
    "message": "Detect external surround sound on Xiaomi devices\n\nexoplayer can enable dolby passthrough on xiaomi device when get\nEXTERNAL_SURROUND_SOUND_KEY\n\nSigned-off-by: joakimzhang <zq15011526977@gmail.com>",
    "date": "2021-03-03T02:14:17Z",
    "url": "https://github.com/google/ExoPlayer/commit/dc814fc37db2fb68b7befffff7bcecd7755ee758",
    "details": {
      "sha": "c79d3f5eecf201725d4ac2f8e6d6918f38445dd1",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/audio/AudioCapabilities.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/google/ExoPlayer/blob/dc814fc37db2fb68b7befffff7bcecd7755ee758/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Faudio%2FAudioCapabilities.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/dc814fc37db2fb68b7befffff7bcecd7755ee758/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Faudio%2FAudioCapabilities.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Faudio%2FAudioCapabilities.java?ref=dc814fc37db2fb68b7befffff7bcecd7755ee758",
      "patch": "@@ -155,6 +155,7 @@ public String toString() {\n   }\n \n   private static boolean deviceMaySetExternalSurroundSoundGlobalSetting() {\n-    return Util.SDK_INT >= 17 && \"Amazon\".equals(Util.MANUFACTURER);\n+    return Util.SDK_INT >= 17 &&\n+            (\"Amazon\".equals(Util.MANUFACTURER) || \"Xiaomi\".equals(Util.MANUFACTURER));\n   }\n }",
      "parent_sha": "eb9de7a120240d34f3cd40bacdffa5860dfa782a"
    }
  },
  {
    "oid": "7098d3b8107723992a2abbdb3b6510d59e0f0495",
    "message": "Add caching for compositeRgbMatrixArray.\n\n* Refactor caching for matrix transformations to reuse it for rgb matrices.\n\nPiperOrigin-RevId: 473042194\n(cherry picked from commit 593370bb69ca5db1d693d42509da78ad496218db)",
    "date": "2022-09-08T18:31:11Z",
    "url": "https://github.com/google/ExoPlayer/commit/7098d3b8107723992a2abbdb3b6510d59e0f0495",
    "details": {
      "sha": "8fa90ac27e8a719d7abae753ac81ef17d71b15ad",
      "filename": "google3/third_party/java_src/android_libs/media/libraries/effect/src/main/java/androidx/media3/effect/MatrixTransformationProcessor.java",
      "status": "modified",
      "additions": 71,
      "deletions": 49,
      "changes": 120,
      "blob_url": "https://github.com/google/ExoPlayer/blob/7098d3b8107723992a2abbdb3b6510d59e0f0495/google3%2Fthird_party%2Fjava_src%2Fandroid_libs%2Fmedia%2Flibraries%2Feffect%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Feffect%2FMatrixTransformationProcessor.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/7098d3b8107723992a2abbdb3b6510d59e0f0495/google3%2Fthird_party%2Fjava_src%2Fandroid_libs%2Fmedia%2Flibraries%2Feffect%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Feffect%2FMatrixTransformationProcessor.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/google3%2Fthird_party%2Fjava_src%2Fandroid_libs%2Fmedia%2Flibraries%2Feffect%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Feffect%2FMatrixTransformationProcessor.java?ref=7098d3b8107723992a2abbdb3b6510d59e0f0495",
      "patch": "@@ -98,21 +98,28 @@\n    * for the most recent frame.\n    */\n   private final float[][] transformationMatrixCache;\n+  /** The RGB matrices provided by the {@link RgbMatrix RgbMatrices} for the most recent frame. */\n+  private final float[][] rgbMatrixCache;\n   /**\n    * The product of the {@link #transformationMatrixCache} for the most recent frame, to be applied\n    * in the vertex shader.\n    */\n-  private final float[] compositeTransformationMatrix;\n+  private final float[] compositeTransformationMatrixArray;\n+  /**\n+   * The product of the {@link #rgbMatrixCache} for the most recent frame, to be applied in the\n+   * fragment shader.\n+   */\n+  private final float[] compositeRgbMatrixArray;\n   /** Matrix for storing an intermediate calculation result. */\n   private final float[] tempResultMatrix;\n \n   /**\n    * A polygon in the input space chosen such that no additional clipping is needed to keep vertices\n    * inside the NDC range when applying each of the {@link #matrixTransformations}.\n    *\n-   * <p>This means that this polygon and {@link #compositeTransformationMatrix} can be used instead\n-   * of applying each of the {@link #matrixTransformations} to {@link #NDC_SQUARE} in separate\n-   * shaders.\n+   * <p>This means that this polygon and {@link #compositeTransformationMatrixArray} can be used\n+   * instead of applying each of the {@link #matrixTransformations} to {@link #NDC_SQUARE} in\n+   * separate shaders.\n    */\n   private ImmutableList<float[]> visiblePolygon;\n \n@@ -343,8 +350,11 @@ private MatrixTransformationProcessor(\n     this.useHdr = useHdr;\n \n     transformationMatrixCache = new float[matrixTransformations.size()][16];\n-    compositeTransformationMatrix = new float[16];\n-    Matrix.setIdentityM(compositeTransformationMatrix, /* smOffset= */ 0);\n+    rgbMatrixCache = new float[rgbMatrices.size()][16];\n+    compositeTransformationMatrixArray = new float[16];\n+    Matrix.setIdentityM(compositeTransformationMatrixArray, /* smOffset= */ 0);\n+    compositeRgbMatrixArray = new float[16];\n+    Matrix.setIdentityM(compositeRgbMatrixArray, /* smOffset= */ 0);\n     tempResultMatrix = new float[16];\n     visiblePolygon = NDC_SQUARE;\n   }\n@@ -378,17 +388,17 @@ public Pair<Integer, Integer> configure(int inputWidth, int inputHeight) {\n \n   @Override\n   public void drawFrame(int inputTexId, long presentationTimeUs) throws FrameProcessingException {\n+    updateCompositeRgbaMatrixArray(presentationTimeUs);\n     updateCompositeTransformationMatrixAndVisiblePolygon(presentationTimeUs);\n     if (visiblePolygon.size() < 3) {\n       return; // Need at least three visible vertices for a triangle.\n     }\n-    float[] compositeRgbMatrix =\n-        createCompositeRgbaMatrixArray(rgbMatrices, useHdr, presentationTimeUs);\n+\n     try {\n       glProgram.use();\n       glProgram.setSamplerTexIdUniform(\"uTexSampler\", inputTexId, /* texUnitIndex= */ 0);\n-      glProgram.setFloatsUniform(\"uTransformationMatrix\", compositeTransformationMatrix);\n-      glProgram.setFloatsUniform(\"uRgbMatrix\", compositeRgbMatrix);\n+      glProgram.setFloatsUniform(\"uTransformationMatrix\", compositeTransformationMatrixArray);\n+      glProgram.setFloatsUniform(\"uRgbMatrix\", compositeRgbMatrixArray);\n       glProgram.setBufferAttribute(\n           \"aFramePosition\",\n           GlUtil.createVertexBuffer(visiblePolygon),\n@@ -413,30 +423,36 @@ public void release() throws FrameProcessingException {\n   }\n \n   /**\n-   * Updates {@link #compositeTransformationMatrix} and {@link #visiblePolygon} based on the given\n-   * frame timestamp.\n+   * Updates {@link #compositeTransformationMatrixArray} and {@link #visiblePolygon} based on the\n+   * given frame timestamp.\n    */\n   private void updateCompositeTransformationMatrixAndVisiblePolygon(long presentationTimeUs) {\n-    if (!updateTransformationMatrixCache(presentationTimeUs)) {\n+    float[][] matricesAtPresentationTime = new float[matrixTransformations.size()][16];\n+    for (int i = 0; i < matrixTransformations.size(); i++) {\n+      matricesAtPresentationTime[i] =\n+          matrixTransformations.get(i).getGlMatrixArray(presentationTimeUs);\n+    }\n+\n+    if (!updateMatrixCache(transformationMatrixCache, matricesAtPresentationTime)) {\n       return;\n     }\n \n     // Compute the compositeTransformationMatrix and transform and clip the visiblePolygon for each\n     // MatrixTransformation's matrix.\n-    Matrix.setIdentityM(compositeTransformationMatrix, /* smOffset= */ 0);\n+    Matrix.setIdentityM(compositeTransformationMatrixArray, /* smOffset= */ 0);\n     visiblePolygon = NDC_SQUARE;\n     for (float[] transformationMatrix : transformationMatrixCache) {\n       Matrix.multiplyMM(\n           /* result= */ tempResultMatrix,\n           /* resultOffset= */ 0,\n           /* lhs= */ transformationMatrix,\n           /* lhsOffset= */ 0,\n-          /* rhs= */ compositeTransformationMatrix,\n+          /* rhs= */ compositeTransformationMatrixArray,\n           /* rhsOffset= */ 0);\n       System.arraycopy(\n           /* src= */ tempResultMatrix,\n           /* srcPos= */ 0,\n-          /* dest= */ compositeTransformationMatrix,\n+          /* dest= */ compositeTransformationMatrixArray,\n           /* destPost= */ 0,\n           /* length= */ tempResultMatrix.length);\n       visiblePolygon =\n@@ -449,58 +465,64 @@ private void updateCompositeTransformationMatrixAndVisiblePolygon(long presentat\n     }\n     // Calculate the input frame vertices corresponding to the output frame's visible polygon.\n     Matrix.invertM(\n-        tempResultMatrix, /* mInvOffset= */ 0, compositeTransformationMatrix, /* mOffset= */ 0);\n+        tempResultMatrix,\n+        /* mInvOffset= */ 0,\n+        compositeTransformationMatrixArray,\n+        /* mOffset= */ 0);\n     visiblePolygon = MatrixUtils.transformPoints(tempResultMatrix, visiblePolygon);\n   }\n \n-  /**\n-   * Updates {@link #transformationMatrixCache} with the transformation matrices provided by the\n-   * {@link #matrixTransformations} for the given frame timestamp and returns whether any matrix in\n-   * {@link #transformationMatrixCache} changed.\n-   */\n-  private boolean updateTransformationMatrixCache(long presentationTimeUs) {\n-    boolean matrixChanged = false;\n-    for (int i = 0; i < matrixTransformations.size(); i++) {\n-      float[] cachedMatrix = transformationMatrixCache[i];\n-      float[] matrix = matrixTransformations.get(i).getGlMatrixArray(presentationTimeUs);\n-      if (!Arrays.equals(cachedMatrix, matrix)) {\n-        checkState(matrix.length == 16, \"A 4x4 transformation matrix must have 16 elements\");\n-        System.arraycopy(\n-            /* src= */ matrix,\n-            /* srcPos= */ 0,\n-            /* dest= */ cachedMatrix,\n-            /* destPost= */ 0,\n-            /* length= */ matrix.length);\n-        matrixChanged = true;\n-      }\n+  /** Updates {@link #compositeRgbMatrixArray} based on the given frame timestamp. */\n+  private void updateCompositeRgbaMatrixArray(long presentationTimeUs) {\n+    float[][] matricesCurrTimestamp = new float[rgbMatrices.size()][16];\n+    for (int i = 0; i < rgbMatrices.size(); i++) {\n+      matricesCurrTimestamp[i] = rgbMatrices.get(i).getMatrix(presentationTimeUs, useHdr);\n     }\n-    return matrixChanged;\n-  }\n \n-  // TODO(b/239757183): Add caching for RgbMatrix and refactor RgbMatrix and MatrixTransformation\n-  // composing.\n-  private static float[] createCompositeRgbaMatrixArray(\n-      ImmutableList<RgbMatrix> rgbMatrices, boolean useHdr, long presentationTimeUs) {\n-    float[] tempResultMatrix = new float[16];\n-    float[] compositeRgbaMatrix = new float[16];\n-    Matrix.setIdentityM(compositeRgbaMatrix, /* smOffset= */ 0);\n+    if (!updateMatrixCache(rgbMatrixCache, matricesCurrTimestamp)) {\n+      return;\n+    }\n \n     for (int i = 0; i < rgbMatrices.size(); i++) {\n       Matrix.multiplyMM(\n           /* result= */ tempResultMatrix,\n           /* resultOffset= */ 0,\n           /* lhs= */ rgbMatrices.get(i).getMatrix(presentationTimeUs, useHdr),\n           /* lhsOffset= */ 0,\n-          /* rhs= */ compositeRgbaMatrix,\n+          /* rhs= */ compositeRgbMatrixArray,\n           /* rhsOffset= */ 0);\n       System.arraycopy(\n           /* src= */ tempResultMatrix,\n           /* srcPos= */ 0,\n-          /* dest= */ compositeRgbaMatrix,\n+          /* dest= */ compositeRgbMatrixArray,\n           /* destPost= */ 0,\n           /* length= */ tempResultMatrix.length);\n     }\n+  }\n \n-    return compositeRgbaMatrix;\n+  /**\n+   * Updates the {@code cachedMatrices} with the {@code newMatrices}. Returns whether a matrix has\n+   * changed inside the cache.\n+   *\n+   * @param cachedMatrices The existing cached matrices. Gets updated if it is out of date.\n+   * @param newMatrices The new matrices to compare the cached matrices against.\n+   */\n+  private static boolean updateMatrixCache(float[][] cachedMatrices, float[][] newMatrices) {\n+    boolean matrixChanged = false;\n+    for (int i = 0; i < cachedMatrices.length; i++) {\n+      float[] cachedMatrix = cachedMatrices[i];\n+      float[] newMatrix = newMatrices[i];\n+      if (!Arrays.equals(cachedMatrix, newMatrix)) {\n+        checkState(newMatrix.length == 16, \"A 4x4 transformation matrix must have 16 elements\");\n+        System.arraycopy(\n+            /* src= */ newMatrix,\n+            /* srcPos= */ 0,\n+            /* dest= */ cachedMatrix,\n+            /* destPost= */ 0,\n+            /* length= */ newMatrix.length);\n+        matrixChanged = true;\n+      }\n+    }\n+    return matrixChanged;\n   }\n }",
      "parent_sha": "8eab7391c21b05f2f04d8f1d2c97967b80d7eb75"
    }
  },
  {
    "oid": "f8d2229f522fb607274476ad7540e2e8bae75e27",
    "message": "Fix build break",
    "date": "2015-11-17T15:43:48Z",
    "url": "https://github.com/google/ExoPlayer/commit/f8d2229f522fb607274476ad7540e2e8bae75e27",
    "details": {
      "sha": "b4c91b79358eed0ec360ecb054f94071c5e7b28f",
      "filename": "library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/ExoPlayer/blob/f8d2229f522fb607274476ad7540e2e8bae75e27/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer%2Fsmoothstreaming%2FSmoothStreamingManifestParser.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/f8d2229f522fb607274476ad7540e2e8bae75e27/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer%2Fsmoothstreaming%2FSmoothStreamingManifestParser.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer%2Fsmoothstreaming%2FSmoothStreamingManifestParser.java?ref=f8d2229f522fb607274476ad7540e2e8bae75e27",
      "patch": "@@ -679,7 +679,7 @@ private static String fourCCToMimeType(String fourCC) {\n       } else if (fourCC.equalsIgnoreCase(\"ac-3\") || fourCC.equalsIgnoreCase(\"dac3\")) {\n         return MimeTypes.AUDIO_AC3;\n       } else if (fourCC.equalsIgnoreCase(\"ec-3\") || fourCC.equalsIgnoreCase(\"dec3\")) {\n-        return MimeTypes.AUDIO_EC3;\n+        return MimeTypes.AUDIO_E_AC3;\n       } else if (fourCC.equalsIgnoreCase(\"dtsc\") || fourCC.equalsIgnoreCase(\"dtse\")) {\n         return MimeTypes.AUDIO_DTS;\n       } else if (fourCC.equalsIgnoreCase(\"dtsh\") || fourCC.equalsIgnoreCase(\"dtsl\")) {",
      "parent_sha": "a3f894b86ba85503da361bc3db97e1c7d25aa32f"
    }
  },
  {
    "oid": "db11e3ddb6f48c897e7e9cdd40ad06b4911ce828",
    "message": "Show larger scrubber handle when focused\n\nAlso remove updateScrubberState as it doesn't do anything useful.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=160496133",
    "date": "2017-06-30T15:30:52Z",
    "url": "https://github.com/google/ExoPlayer/commit/db11e3ddb6f48c897e7e9cdd40ad06b4911ce828",
    "details": {
      "sha": "cc1e63bec64ee7eb476f9b79c45220eff3de3949",
      "filename": "library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java",
      "status": "modified",
      "additions": 2,
      "deletions": 12,
      "changes": 14,
      "blob_url": "https://github.com/google/ExoPlayer/blob/db11e3ddb6f48c897e7e9cdd40ad06b4911ce828/library%2Fui%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FDefaultTimeBar.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/db11e3ddb6f48c897e7e9cdd40ad06b4911ce828/library%2Fui%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FDefaultTimeBar.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fui%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FDefaultTimeBar.java?ref=db11e3ddb6f48c897e7e9cdd40ad06b4911ce828",
      "patch": "@@ -89,7 +89,6 @@ public class DefaultTimeBar extends View implements TimeBar {\n   private final Formatter formatter;\n   private final Runnable stopScrubbingRunnable;\n \n-  private int scrubberSize;\n   private OnScrubListener listener;\n   private int keyCountIncrement;\n   private long keyTimeIncrement;\n@@ -185,7 +184,6 @@ public void run() {\n         stopScrubbing(false);\n       }\n     };\n-    scrubberSize = scrubberEnabledSize;\n     scrubberPadding =\n         (Math.max(scrubberDisabledSize, Math.max(scrubberEnabledSize, scrubberDraggedSize)) + 1)\n             / 2;\n@@ -235,8 +233,6 @@ public void setDuration(long duration) {\n     this.duration = duration;\n     if (scrubbing && duration == C.TIME_UNSET) {\n       stopScrubbing(true);\n-    } else {\n-      updateScrubberState();\n     }\n     update();\n   }\n@@ -252,7 +248,6 @@ public void setAdGroupTimesMs(@Nullable long[] adGroupTimesMs, int adGroupCount)\n   @Override\n   public void setEnabled(boolean enabled) {\n     super.setEnabled(enabled);\n-    updateScrubberState();\n     if (scrubbing && !enabled) {\n       stopScrubbing(true);\n     }\n@@ -437,7 +432,6 @@ private void maybeSetImportantForAccessibilityV16() {\n \n   private void startScrubbing() {\n     scrubbing = true;\n-    updateScrubberState();\n     ViewParent parent = getParent();\n     if (parent != null) {\n       parent.requestDisallowInterceptTouchEvent(true);\n@@ -453,18 +447,12 @@ private void stopScrubbing(boolean canceled) {\n     if (parent != null) {\n       parent.requestDisallowInterceptTouchEvent(false);\n     }\n-    updateScrubberState();\n     invalidate();\n     if (listener != null) {\n       listener.onScrubStop(this, getScrubberPosition(), canceled);\n     }\n   }\n \n-  private void updateScrubberState() {\n-    scrubberSize = scrubbing ? scrubberDraggedSize\n-        : (isEnabled() && duration >= 0 ? scrubberEnabledSize : scrubberDisabledSize);\n-  }\n-\n   private void update() {\n     bufferedBar.set(progressBar);\n     scrubberBar.set(progressBar);\n@@ -544,6 +532,8 @@ private void drawPlayhead(Canvas canvas) {\n     if (duration <= 0) {\n       return;\n     }\n+    int scrubberSize = (scrubbing || isFocused()) ? scrubberDraggedSize\n+        : (isEnabled() ? scrubberEnabledSize : scrubberDisabledSize);\n     int playheadRadius = scrubberSize / 2;\n     int playheadCenter = Util.constrainValue(scrubberBar.right, scrubberBar.left,\n         progressBar.right);",
      "parent_sha": "a543436b960cc97ec1dfdb1ac5efe5da6e99fbe0"
    }
  },
  {
    "oid": "06f7b6be6ae5e085606cc11e122b861c1bec9d19",
    "message": "Use IntDef for AudioTrack.startMediaTimeState\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=169880369",
    "date": "2017-09-26T13:00:59Z",
    "url": "https://github.com/google/ExoPlayer/commit/06f7b6be6ae5e085606cc11e122b861c1bec9d19",
    "details": {
      "sha": "25813aefc08ebefcdd0db9cba9c8fa785b88a5d9",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/audio/AudioTrack.java",
      "status": "modified",
      "additions": 12,
      "deletions": 5,
      "changes": 17,
      "blob_url": "https://github.com/google/ExoPlayer/blob/06f7b6be6ae5e085606cc11e122b861c1bec9d19/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Faudio%2FAudioTrack.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/06f7b6be6ae5e085606cc11e122b861c1bec9d19/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Faudio%2FAudioTrack.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Faudio%2FAudioTrack.java?ref=06f7b6be6ae5e085606cc11e122b861c1bec9d19",
      "patch": "@@ -22,13 +22,16 @@\n import android.media.AudioTimestamp;\n import android.os.ConditionVariable;\n import android.os.SystemClock;\n+import android.support.annotation.IntDef;\n import android.support.annotation.Nullable;\n import android.util.Log;\n import com.google.android.exoplayer2.C;\n import com.google.android.exoplayer2.PlaybackParameters;\n import com.google.android.exoplayer2.util.Assertions;\n import com.google.android.exoplayer2.util.MimeTypes;\n import com.google.android.exoplayer2.util.Util;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n import java.lang.reflect.Method;\n import java.nio.ByteBuffer;\n import java.nio.ByteOrder;\n@@ -247,6 +250,12 @@ public InvalidAudioTrackTimestampException(String detailMessage) {\n    */\n   private static final long MAX_LATENCY_US = 5 * C.MICROS_PER_SECOND;\n \n+  /**\n+   * Represents states of the {@link #startMediaTimeUs} value.\n+   */\n+  @Retention(RetentionPolicy.SOURCE)\n+  @IntDef({START_NOT_SET, START_IN_SYNC, START_NEED_SYNC})\n+  private @interface StartMediaTimeState {}\n   private static final int START_NOT_SET = 0;\n   private static final int START_IN_SYNC = 1;\n   private static final int START_NEED_SYNC = 2;\n@@ -299,10 +308,8 @@ public InvalidAudioTrackTimestampException(String detailMessage) {\n   private android.media.AudioTrack audioTrack;\n   private int sampleRate;\n   private int channelConfig;\n-  @C.Encoding\n-  private int encoding;\n-  @C.Encoding\n-  private int outputEncoding;\n+  private @C.Encoding int encoding;\n+  private @C.Encoding int outputEncoding;\n   private AudioAttributes audioAttributes;\n   private boolean passthrough;\n   private int bufferSize;\n@@ -331,7 +338,7 @@ public InvalidAudioTrackTimestampException(String detailMessage) {\n   private long writtenPcmBytes;\n   private long writtenEncodedFrames;\n   private int framesPerEncodedSample;\n-  private int startMediaTimeState;\n+  private @StartMediaTimeState int startMediaTimeState;\n   private long startMediaTimeUs;\n   private long resumeSystemTimeUs;\n   private long latencyUs;",
      "parent_sha": "505d5cd0a4953e43094759efdd4c6cbc0749bee7"
    }
  },
  {
    "oid": "f88149385a63c407f0589f496b87a864a1aa32cd",
    "message": "Avoid rollover calculating sample offsets\n\nI considered using Util.scaleLargeTimestamp for this, but\ngiven sample offsets are relative and should always be\nsmall (<<1s), it really shouldn't be necessary.\n\nIssue: #3139\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=164443795",
    "date": "2017-08-07T12:42:57Z",
    "url": "https://github.com/google/ExoPlayer/commit/f88149385a63c407f0589f496b87a864a1aa32cd",
    "details": {
      "sha": "6b2077ef76208188223972390fb3df36bf6e83b3",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/ExoPlayer/blob/f88149385a63c407f0589f496b87a864a1aa32cd/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2Fmp4%2FFragmentedMp4Extractor.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/f88149385a63c407f0589f496b87a864a1aa32cd/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2Fmp4%2FFragmentedMp4Extractor.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2Fmp4%2FFragmentedMp4Extractor.java?ref=f88149385a63c407f0589f496b87a864a1aa32cd",
      "patch": "@@ -815,7 +815,7 @@ private static int parseTrun(TrackBundle trackBundle, int index, long decodeTime\n         // here, because unsigned integers will still be parsed correctly (unless their top bit is\n         // set, which is never true in practice because sample offsets are always small).\n         int sampleOffset = trun.readInt();\n-        sampleCompositionTimeOffsetTable[i] = (int) ((sampleOffset * 1000) / timescale);\n+        sampleCompositionTimeOffsetTable[i] = (int) ((sampleOffset * 1000L) / timescale);\n       } else {\n         sampleCompositionTimeOffsetTable[i] = 0;\n       }",
      "parent_sha": "15bcdf3b71f02b4ce2f8328625fb43a5b0f25fe6"
    }
  },
  {
    "oid": "525f151f2105c519a0c0358bd51806792dd51d54",
    "message": "Check whether drm session manager of sample queue is null\n\nPiperOrigin-RevId: 348688419",
    "date": "2020-12-23T22:52:48Z",
    "url": "https://github.com/google/ExoPlayer/commit/525f151f2105c519a0c0358bd51806792dd51d54",
    "details": {
      "sha": "120f6dc2e83321dbceaacf312b69f75394250ac1",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/google/ExoPlayer/blob/525f151f2105c519a0c0358bd51806792dd51d54/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2FSampleQueue.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/525f151f2105c519a0c0358bd51806792dd51d54/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2FSampleQueue.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2FSampleQueue.java?ref=525f151f2105c519a0c0358bd51806792dd51d54",
      "patch": "@@ -870,7 +870,10 @@ private void onFormatResult(Format newFormat, FormatHolder outputFormatHolder) {\n     @Nullable DrmInitData newDrmInitData = newFormat.drmInitData;\n \n     outputFormatHolder.format =\n-        newFormat.copyWithExoMediaCryptoType(drmSessionManager.getExoMediaCryptoType(newFormat));\n+        drmSessionManager != null\n+            ? newFormat.copyWithExoMediaCryptoType(\n+                drmSessionManager.getExoMediaCryptoType(newFormat))\n+            : newFormat;\n     outputFormatHolder.drmSession = currentDrmSession;\n     if (drmSessionManager == null) {\n       // This sample queue is not expected to handle DRM. Nothing to do.",
      "parent_sha": "ab4c92e9dae42cdf73f41a8aba69a8e3b029ad98"
    }
  },
  {
    "oid": "f93fb5dc557cbfa0f5877a6f65e9287759fa4a73",
    "message": "Switch DashManifestParser to use Ascii.equalsIgnoreCase\n\nString.equalsIgnoreCase depends on the device locale and is discouraged.\n\n#minor-release\n\nPiperOrigin-RevId: 368211677",
    "date": "2021-04-13T17:14:31Z",
    "url": "https://github.com/google/ExoPlayer/commit/f93fb5dc557cbfa0f5877a6f65e9287759fa4a73",
    "details": {
      "sha": "20300f78119b26f7ef9eeb9628ebf664d903b5fd",
      "filename": "library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java",
      "status": "modified",
      "additions": 10,
      "deletions": 8,
      "changes": 18,
      "blob_url": "https://github.com/google/ExoPlayer/blob/f93fb5dc557cbfa0f5877a6f65e9287759fa4a73/library%2Fdash%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fdash%2Fmanifest%2FDashManifestParser.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/f93fb5dc557cbfa0f5877a6f65e9287759fa4a73/library%2Fdash%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fdash%2Fmanifest%2FDashManifestParser.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fdash%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fdash%2Fmanifest%2FDashManifestParser.java?ref=f93fb5dc557cbfa0f5877a6f65e9287759fa4a73",
      "patch": "@@ -39,6 +39,7 @@\n import com.google.android.exoplayer2.util.UriUtil;\n import com.google.android.exoplayer2.util.Util;\n import com.google.android.exoplayer2.util.XmlPullParserUtil;\n+import com.google.common.base.Ascii;\n import com.google.common.base.Charsets;\n import com.google.common.collect.ImmutableList;\n import java.io.ByteArrayOutputStream;\n@@ -1393,7 +1394,7 @@ protected int parseAudioChannelConfiguration(XmlPullParser xpp)\n   protected int parseSelectionFlagsFromRoleDescriptors(List<Descriptor> roleDescriptors) {\n     for (int i = 0; i < roleDescriptors.size(); i++) {\n       Descriptor descriptor = roleDescriptors.get(i);\n-      if (\"urn:mpeg:dash:role:2011\".equalsIgnoreCase(descriptor.schemeIdUri)\n+      if (Ascii.equalsIgnoreCase(\"urn:mpeg:dash:role:2011\", descriptor.schemeIdUri)\n           && \"main\".equals(descriptor.value)) {\n         return C.SELECTION_FLAG_DEFAULT;\n       }\n@@ -1408,7 +1409,7 @@ protected int parseRoleFlagsFromRoleDescriptors(List<Descriptor> roleDescriptors\n     @C.RoleFlags int result = 0;\n     for (int i = 0; i < roleDescriptors.size(); i++) {\n       Descriptor descriptor = roleDescriptors.get(i);\n-      if (\"urn:mpeg:dash:role:2011\".equalsIgnoreCase(descriptor.schemeIdUri)) {\n+      if (Ascii.equalsIgnoreCase(\"urn:mpeg:dash:role:2011\", descriptor.schemeIdUri)) {\n         result |= parseDashRoleSchemeValue(descriptor.value);\n       }\n     }\n@@ -1421,10 +1422,10 @@ protected int parseRoleFlagsFromAccessibilityDescriptors(\n     @C.RoleFlags int result = 0;\n     for (int i = 0; i < accessibilityDescriptors.size(); i++) {\n       Descriptor descriptor = accessibilityDescriptors.get(i);\n-      if (\"urn:mpeg:dash:role:2011\".equalsIgnoreCase(descriptor.schemeIdUri)) {\n+      if (Ascii.equalsIgnoreCase(\"urn:mpeg:dash:role:2011\", descriptor.schemeIdUri)) {\n         result |= parseDashRoleSchemeValue(descriptor.value);\n-      } else if (\"urn:tva:metadata:cs:AudioPurposeCS:2007\"\n-          .equalsIgnoreCase(descriptor.schemeIdUri)) {\n+      } else if (Ascii.equalsIgnoreCase(\n+          \"urn:tva:metadata:cs:AudioPurposeCS:2007\", descriptor.schemeIdUri)) {\n         result |= parseTvaAudioPurposeCsValue(descriptor.value);\n       }\n     }\n@@ -1436,7 +1437,8 @@ protected int parseRoleFlagsFromProperties(List<Descriptor> accessibilityDescrip\n     @C.RoleFlags int result = 0;\n     for (int i = 0; i < accessibilityDescriptors.size(); i++) {\n       Descriptor descriptor = accessibilityDescriptors.get(i);\n-      if (\"http://dashif.org/guidelines/trickmode\".equalsIgnoreCase(descriptor.schemeIdUri)) {\n+      if (Ascii.equalsIgnoreCase(\n+          \"http://dashif.org/guidelines/trickmode\", descriptor.schemeIdUri)) {\n         result |= C.ROLE_FLAG_TRICK_PLAY;\n       }\n     }\n@@ -1801,8 +1803,8 @@ protected static long parseLastSegmentNumberSupplementalProperty(\n       List<Descriptor> supplementalProperties) {\n     for (int i = 0; i < supplementalProperties.size(); i++) {\n       Descriptor descriptor = supplementalProperties.get(i);\n-      if (\"http://dashif.org/guidelines/last-segment-number\"\n-          .equalsIgnoreCase(descriptor.schemeIdUri)) {\n+      if (Ascii.equalsIgnoreCase(\n+          \"http://dashif.org/guidelines/last-segment-number\", descriptor.schemeIdUri)) {\n         return Long.parseLong(descriptor.value);\n       }\n     }",
      "parent_sha": "19121f7b203b0f7ff9f488ebd41dc48ea9627234"
    }
  },
  {
    "oid": "ecaaed96748d6ea70bbca2a9f8566df995dbbfac",
    "message": "Relax string comparison in DASH parseContentProtection\n\n... by making it case insensitive and null-tolerant for schemeId (as was before\nadding playlist drm data merging).\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=174472123",
    "date": "2017-11-07T14:34:22Z",
    "url": "https://github.com/google/ExoPlayer/commit/ecaaed96748d6ea70bbca2a9f8566df995dbbfac",
    "details": {
      "sha": "72df69f7e9da68a862d43a14492bca411e4f4058",
      "filename": "library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java",
      "status": "modified",
      "additions": 21,
      "deletions": 19,
      "changes": 40,
      "blob_url": "https://github.com/google/ExoPlayer/blob/ecaaed96748d6ea70bbca2a9f8566df995dbbfac/library%2Fdash%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fdash%2Fmanifest%2FDashManifestParser.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/ecaaed96748d6ea70bbca2a9f8566df995dbbfac/library%2Fdash%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fdash%2Fmanifest%2FDashManifestParser.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fdash%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fdash%2Fmanifest%2FDashManifestParser.java?ref=ecaaed96748d6ea70bbca2a9f8566df995dbbfac",
      "patch": "@@ -345,30 +345,32 @@ protected int getContentType(Format format) {\n    */\n   protected Pair<String, SchemeData> parseContentProtection(XmlPullParser xpp)\n       throws XmlPullParserException, IOException {\n-    String schemeIdUri = xpp.getAttributeValue(null, \"schemeIdUri\");\n     String schemeType = null;\n     byte[] data = null;\n     UUID uuid = null;\n     boolean requiresSecureDecoder = false;\n \n-    switch (schemeIdUri) {\n-      case \"urn:mpeg:dash:mp4protection:2011\":\n-        schemeType = xpp.getAttributeValue(null, \"value\");\n-        String defaultKid = xpp.getAttributeValue(null, \"cenc:default_KID\");\n-        if (defaultKid != null && !\"00000000-0000-0000-0000-000000000000\".equals(defaultKid)) {\n-          UUID keyId = UUID.fromString(defaultKid);\n-          data = PsshAtomUtil.buildPsshAtom(C.COMMON_PSSH_UUID, new UUID[] {keyId}, null);\n-          uuid = C.COMMON_PSSH_UUID;\n-        }\n-        break;\n-      case \"urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95\":\n-        uuid = C.PLAYREADY_UUID;\n-        break;\n-      case \"urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\":\n-        uuid = C.WIDEVINE_UUID;\n-        break;\n-      default:\n-        break;\n+    String schemeIdUri = xpp.getAttributeValue(null, \"schemeIdUri\");\n+    if (schemeIdUri != null) {\n+      switch (schemeIdUri.toLowerCase()) {\n+        case \"urn:mpeg:dash:mp4protection:2011\":\n+          schemeType = xpp.getAttributeValue(null, \"value\");\n+          String defaultKid = xpp.getAttributeValue(null, \"cenc:default_KID\");\n+          if (defaultKid != null && !\"00000000-0000-0000-0000-000000000000\".equals(defaultKid)) {\n+            UUID keyId = UUID.fromString(defaultKid);\n+            data = PsshAtomUtil.buildPsshAtom(C.COMMON_PSSH_UUID, new UUID[] {keyId}, null);\n+            uuid = C.COMMON_PSSH_UUID;\n+          }\n+          break;\n+        case \"urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95\":\n+          uuid = C.PLAYREADY_UUID;\n+          break;\n+        case \"urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\":\n+          uuid = C.WIDEVINE_UUID;\n+          break;\n+        default:\n+          break;\n+      }\n     }\n \n     do {",
      "parent_sha": "1cfea625456e4ef66396d6fc94bbd00ec3f2302c"
    }
  },
  {
    "oid": "088938c9abed346c18533a472721ef150f78edb7",
    "message": "Fix DefaultTimeBar ignores touch transformations #7303",
    "date": "2020-04-29T11:55:59Z",
    "url": "https://github.com/google/ExoPlayer/commit/088938c9abed346c18533a472721ef150f78edb7",
    "details": {
      "sha": "3d07acf1a9e3c44a87ab08fcd257f9840216283e",
      "filename": "library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/google/ExoPlayer/blob/088938c9abed346c18533a472721ef150f78edb7/library%2Fui%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FDefaultTimeBar.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/088938c9abed346c18533a472721ef150f78edb7/library%2Fui%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FDefaultTimeBar.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fui%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FDefaultTimeBar.java?ref=088938c9abed346c18533a472721ef150f78edb7",
      "patch": "@@ -798,10 +798,9 @@ private void positionScrubber(float xPosition) {\n   }\n \n   private Point resolveRelativeTouchPosition(MotionEvent motionEvent) {\n-    getLocationOnScreen(locationOnScreen);\n     touchPosition.set(\n-        ((int) motionEvent.getRawX()) - locationOnScreen[0],\n-        ((int) motionEvent.getRawY()) - locationOnScreen[1]);\n+        (int) motionEvent.getX(),\n+        (int) motionEvent.getY());\n     return touchPosition;\n   }\n ",
      "parent_sha": "2e9ed51503ba491a19f605e6994fa5839633c74f"
    }
  },
  {
    "oid": "f5d3900b6db349d96935393a6bbc28a5cb0653b0",
    "message": "Document that channelNameResourceId needs to be set\n\nThis is documented on the setter already, but it seems to make sense to do this in the constructor as well for clarity.\n\nIssue: google/ExoPlayer#9550\nPiperOrigin-RevId: 411675700",
    "date": "2021-12-02T10:03:06Z",
    "url": "https://github.com/google/ExoPlayer/commit/f5d3900b6db349d96935393a6bbc28a5cb0653b0",
    "details": {
      "sha": "8909d3d4000925b18053238128f40d12a8f54add",
      "filename": "libraries/ui/src/main/java/androidx/media3/ui/PlayerNotificationManager.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/google/ExoPlayer/blob/f5d3900b6db349d96935393a6bbc28a5cb0653b0/libraries%2Fui%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fui%2FPlayerNotificationManager.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/f5d3900b6db349d96935393a6bbc28a5cb0653b0/libraries%2Fui%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fui%2FPlayerNotificationManager.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/libraries%2Fui%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fui%2FPlayerNotificationManager.java?ref=f5d3900b6db349d96935393a6bbc28a5cb0653b0",
      "patch": "@@ -345,7 +345,9 @@ public Builder(\n      *\n      * @param context The {@link Context}.\n      * @param notificationId The id of the notification to be posted. Must be greater than 0.\n-     * @param channelId The id of the notification channel.\n+     * @param channelId The id of the notification channel of an existing notification channel or of\n+     *     the channel that should be automatically created. In the latter case, {@link\n+     *     #setChannelNameResourceId(int)} needs to be called as well.\n      */\n     public Builder(Context context, @IntRange(from = 1) int notificationId, String channelId) {\n       checkArgument(notificationId > 0);",
      "parent_sha": "2749dbd3f5fda88aee0d3f679f3707e785056279"
    }
  },
  {
    "oid": "b26d578ff39b6592dd7d747561afea0409a05db6",
    "message": "Fix bug that clicking didn't show up controls at the beginning\n\nStyledLayoutManager#isFullyVisibility() was wrong and\nso hiding/showing logic didn't work properly.\n\nPiperOrigin-RevId: 324996446",
    "date": "2020-08-07T18:01:45Z",
    "url": "https://github.com/google/ExoPlayer/commit/b26d578ff39b6592dd7d747561afea0409a05db6",
    "details": {
      "sha": "a5e6e40df636422a91ac2cf8853ebb3cd83edc1c",
      "filename": "library/ui/src/main/java/com/google/android/exoplayer2/ui/StyledPlayerControlViewLayoutManager.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/google/ExoPlayer/blob/b26d578ff39b6592dd7d747561afea0409a05db6/library%2Fui%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FStyledPlayerControlViewLayoutManager.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/b26d578ff39b6592dd7d747561afea0409a05db6/library%2Fui%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FStyledPlayerControlViewLayoutManager.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fui%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FStyledPlayerControlViewLayoutManager.java?ref=b26d578ff39b6592dd7d747561afea0409a05db6",
      "patch": "@@ -53,7 +53,7 @@\n   private final Runnable hideControllerRunnable;\n   private final OnLayoutChangeListener onLayoutChangeListener;\n \n-  private int uxState = UX_STATE_ALL_VISIBLE;\n+  private int uxState;\n   private boolean initiallyHidden;\n   private boolean isMinimalMode;\n   private boolean needToShowBars;\n@@ -88,6 +88,7 @@ public StyledPlayerControlViewLayoutManager() {\n     hideControllerRunnable = this::hideController;\n     onLayoutChangeListener = this::onLayoutChange;\n     animationEnabled = true;\n+    uxState = UX_STATE_ALL_VISIBLE;\n   }\n \n   public void show() {\n@@ -432,7 +433,7 @@ public boolean isFullyVisible() {\n     if (styledPlayerControlView == null) {\n       return false;\n     }\n-    return uxState == UX_STATE_ALL_VISIBLE;\n+    return uxState == UX_STATE_ALL_VISIBLE && styledPlayerControlView.isVisible();\n   }\n \n   private void setUxState(int uxState) {",
      "parent_sha": "5342576e734f6e47007a3a61e3ccfc45a211e70e"
    }
  },
  {
    "oid": "09c49f3ca8d551f2a8b688ec34cf6a4a6dc3ebaf",
    "message": "Simplify comment\n\n#minor-release\n\nPiperOrigin-RevId: 351144857",
    "date": "2021-01-11T18:05:44Z",
    "url": "https://github.com/google/ExoPlayer/commit/09c49f3ca8d551f2a8b688ec34cf6a4a6dc3ebaf",
    "details": {
      "sha": "ea09c076f061c08107ef80741df9a6349fea5ec2",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/google/ExoPlayer/blob/09c49f3ca8d551f2a8b688ec34cf6a4a6dc3ebaf/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FExoPlayerImplInternal.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/09c49f3ca8d551f2a8b688ec34cf6a4a6dc3ebaf/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FExoPlayerImplInternal.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FExoPlayerImplInternal.java?ref=09c49f3ca8d551f2a8b688ec34cf6a4a6dc3ebaf",
      "patch": "@@ -1908,8 +1908,8 @@ private void maybeUpdateLoadingPeriod() throws ExoPlaybackException {\n       }\n     }\n     if (shouldContinueLoading) {\n-      // We should still be loading, except in the case that it's no longer possible (i.e., because\n-      // we've loaded the current playlist to the end).\n+      // We should still be loading, except when there is nothing to load or we have fully loaded\n+      // the current period.\n       shouldContinueLoading = isLoadingPossible();\n       updateIsLoading();\n     } else {",
      "parent_sha": "a7b20fd133f8976ca29c91d69a71558ae99f765c"
    }
  },
  {
    "oid": "0760520b23a61b6ab6b88fd4a45481dc9c124b66",
    "message": "FrameProcessor: Avoid early rounding in Presentation output dimensions.\n\nPiperOrigin-RevId: 444253425",
    "date": "2022-04-26T15:55:44Z",
    "url": "https://github.com/google/ExoPlayer/commit/0760520b23a61b6ab6b88fd4a45481dc9c124b66",
    "details": {
      "sha": "44cb876fcd9fde2bb9ee103a7d68b56471f0f712",
      "filename": "library/transformer/src/main/java/com/google/android/exoplayer2/transformer/PresentationFrameProcessor.java",
      "status": "modified",
      "additions": 17,
      "deletions": 15,
      "changes": 32,
      "blob_url": "https://github.com/google/ExoPlayer/blob/0760520b23a61b6ab6b88fd4a45481dc9c124b66/library%2Ftransformer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftransformer%2FPresentationFrameProcessor.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/0760520b23a61b6ab6b88fd4a45481dc9c124b66/library%2Ftransformer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftransformer%2FPresentationFrameProcessor.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Ftransformer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftransformer%2FPresentationFrameProcessor.java?ref=0760520b23a61b6ab6b88fd4a45481dc9c124b66",
      "patch": "@@ -231,8 +231,9 @@ public PresentationFrameProcessor build() {\n   private final float requestedAspectRatio;\n   private final @Layout int layout;\n \n-  private int outputWidth;\n-  private int outputHeight;\n+  private float outputWidth;\n+  private float outputHeight;\n+  private @MonotonicNonNull Size outputSize;\n   private @MonotonicNonNull Matrix transformationMatrix;\n   private @MonotonicNonNull AdvancedFrameProcessor advancedFrameProcessor;\n \n@@ -268,10 +269,10 @@ public void initialize(Context context, int inputTexId, int inputWidth, int inpu\n \n   @Override\n   public Size getOutputSize() {\n-    checkState(\n-        outputWidth != C.LENGTH_UNSET && outputHeight != C.LENGTH_UNSET,\n+    checkStateNotNull(\n+        outputSize,\n         \"configureOutputSizeAndTransformationMatrix must be called before getOutputSize\");\n-    return new Size(outputWidth, outputHeight);\n+    return outputSize;\n   }\n \n   @Override\n@@ -307,9 +308,10 @@ public void release() {\n \n     // Scale width and height to desired requestedHeightPixels, preserving aspect ratio.\n     if (requestedHeightPixels != C.LENGTH_UNSET && requestedHeightPixels != outputHeight) {\n-      outputWidth = Math.round((float) requestedHeightPixels * outputWidth / outputHeight);\n+      outputWidth = requestedHeightPixels * outputWidth / outputHeight;\n       outputHeight = requestedHeightPixels;\n     }\n+    outputSize = new Size(Math.round(outputWidth), Math.round(outputHeight));\n   }\n \n   @RequiresNonNull(\"transformationMatrix\")\n@@ -322,34 +324,34 @@ private void applyCrop() {\n     transformationMatrix.postTranslate(-centerX, -centerY);\n     transformationMatrix.postScale(1f / scaleX, 1f / scaleY);\n \n-    outputWidth = Math.round(outputWidth * scaleX);\n-    outputHeight = Math.round(outputHeight * scaleY);\n+    outputWidth = outputWidth * scaleX;\n+    outputHeight = outputHeight * scaleY;\n   }\n \n   @RequiresNonNull(\"transformationMatrix\")\n   private void applyAspectRatio() {\n-    float inputAspectRatio = (float) outputWidth / outputHeight;\n+    float inputAspectRatio = outputWidth / outputHeight;\n     if (layout == LAYOUT_SCALE_TO_FIT) {\n       if (requestedAspectRatio > inputAspectRatio) {\n         transformationMatrix.setScale(inputAspectRatio / requestedAspectRatio, 1f);\n-        outputWidth = Math.round(outputHeight * requestedAspectRatio);\n+        outputWidth = outputHeight * requestedAspectRatio;\n       } else {\n         transformationMatrix.setScale(1f, requestedAspectRatio / inputAspectRatio);\n-        outputHeight = Math.round(outputWidth / requestedAspectRatio);\n+        outputHeight = outputWidth / requestedAspectRatio;\n       }\n     } else if (layout == LAYOUT_SCALE_TO_FIT_WITH_CROP) {\n       if (requestedAspectRatio > inputAspectRatio) {\n         transformationMatrix.setScale(1f, requestedAspectRatio / inputAspectRatio);\n-        outputHeight = Math.round(outputWidth / requestedAspectRatio);\n+        outputHeight = outputWidth / requestedAspectRatio;\n       } else {\n         transformationMatrix.setScale(inputAspectRatio / requestedAspectRatio, 1f);\n-        outputWidth = Math.round(outputHeight * requestedAspectRatio);\n+        outputWidth = outputHeight * requestedAspectRatio;\n       }\n     } else if (layout == LAYOUT_STRETCH_TO_FIT) {\n       if (requestedAspectRatio > inputAspectRatio) {\n-        outputWidth = Math.round(outputHeight * requestedAspectRatio);\n+        outputWidth = outputHeight * requestedAspectRatio;\n       } else {\n-        outputHeight = Math.round(outputWidth / requestedAspectRatio);\n+        outputHeight = outputWidth / requestedAspectRatio;\n       }\n     }\n   }",
      "parent_sha": "40c27c43c807ddae2b8e83464673844f5ec04abf"
    }
  },
  {
    "oid": "31513202df8c186764ad5d2d1d14a8a7fa49a7f6",
    "message": "Fix subtitle painter issues",
    "date": "2017-02-20T13:01:00Z",
    "url": "https://github.com/google/ExoPlayer/commit/31513202df8c186764ad5d2d1d14a8a7fa49a7f6",
    "details": {
      "sha": "04a6bafd3dd3344643289908a1cab73bc626847a",
      "filename": "library/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/google/ExoPlayer/blob/31513202df8c186764ad5d2d1d14a8a7fa49a7f6/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FSubtitlePainter.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/31513202df8c186764ad5d2d1d14a8a7fa49a7f6/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FSubtitlePainter.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FSubtitlePainter.java?ref=31513202df8c186764ad5d2d1d14a8a7fa49a7f6",
      "patch": "@@ -65,9 +65,9 @@\n   private final Paint paint;\n \n   // Previous input variables.\n-  private Bitmap cueBitmap;\n   private CharSequence cueText;\n   private Alignment cueTextAlignment;\n+  private Bitmap cueBitmap;\n   private float cueLine;\n   @Cue.LineType\n   private int cueLineType;\n@@ -148,12 +148,14 @@ public void draw(Cue cue, boolean applyEmbeddedStyles, CaptionStyleCompat style,\n     boolean isTextCue = cue.bitmap == null;\n     CharSequence cueText = null;\n     Bitmap cueBitmap = null;\n+    int windowColor = Color.BLACK;\n     if (isTextCue) {\n       cueText = cue.text;\n       if (TextUtils.isEmpty(cueText)) {\n         // Nothing to draw.\n         return;\n       }\n+      windowColor = cue.windowColorSet ? cue.windowColor : style.windowColor;\n       if (!applyEmbeddedStyles) {\n         // Strip out any embedded styling.\n         cueText = cueText.toString();\n@@ -174,7 +176,7 @@ public void draw(Cue cue, boolean applyEmbeddedStyles, CaptionStyleCompat style,\n         && this.applyEmbeddedStyles == applyEmbeddedStyles\n         && this.foregroundColor == style.foregroundColor\n         && this.backgroundColor == style.backgroundColor\n-        && this.windowColor == style.windowColor\n+        && this.windowColor == windowColor\n         && this.edgeType == style.edgeType\n         && this.edgeColor == style.edgeColor\n         && Util.areEqual(this.textPaint.getTypeface(), style.typeface)\n@@ -275,7 +277,7 @@ private void setupTextLayout() {\n         if (cueLine >= 0) {\n           anchorPosition = Math.round(cueLine * firstLineHeight) + parentTop;\n         } else {\n-          anchorPosition = Math.round(cueLine * firstLineHeight) + parentBottom;\n+          anchorPosition = Math.round((cueLine + 1) * firstLineHeight) + parentBottom;\n         }\n       }\n       textTop = cueLineAnchor == Cue.ANCHOR_TYPE_END ? anchorPosition - textHeight\n@@ -309,8 +311,8 @@ private void setupBitmapLayout() {\n     int height = (int) (width * ((float) cueBitmap.getHeight() / cueBitmap.getWidth()));\n     int x = (int) (cueLineAnchor == Cue.ANCHOR_TYPE_END ? (anchorX - width)\n         : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorX - (width / 2)) : anchorX);\n-    int y = (int) (cuePositionAnchor == Cue.ANCHOR_TYPE_END ? (anchorY - width)\n-        : cuePositionAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorY - (width / 2)) : anchorY);\n+    int y = (int) (cuePositionAnchor == Cue.ANCHOR_TYPE_END ? (anchorY - height)\n+        : cuePositionAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorY - (height / 2)) : anchorY);\n     bitmapRect = new Rect(x, y, x + width, y + height);\n   }\n ",
      "parent_sha": "21923ae1faa1db85256a016721bc238a20d2d2b8"
    }
  },
  {
    "oid": "922e508213bb31d9b87fae93756b6abe07d6fd66",
    "message": "Update import scrubbing\n\nPiperOrigin-RevId: 405396600",
    "date": "2021-10-25T20:28:15Z",
    "url": "https://github.com/google/ExoPlayer/commit/922e508213bb31d9b87fae93756b6abe07d6fd66",
    "details": {
      "sha": "ba04f73429af60ae58fe05dfb494edaa166c366f",
      "filename": "library/common/src/test/java/com/google/android/exoplayer2/trackselection/TrackSelectionOverridesTest.java",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/google/ExoPlayer/blob/922e508213bb31d9b87fae93756b6abe07d6fd66/library%2Fcommon%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftrackselection%2FTrackSelectionOverridesTest.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/922e508213bb31d9b87fae93756b6abe07d6fd66/library%2Fcommon%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftrackselection%2FTrackSelectionOverridesTest.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcommon%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftrackselection%2FTrackSelectionOverridesTest.java?ref=922e508213bb31d9b87fae93756b6abe07d6fd66",
      "patch": "@@ -19,15 +19,14 @@\n import static org.junit.Assert.assertThrows;\n \n import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import com.google.android.exoplayer2.C;\n+import com.google.android.exoplayer2.Format;\n import com.google.android.exoplayer2.trackselection.TrackSelectionOverrides.TrackSelectionOverride;\n+import com.google.android.exoplayer2.util.MimeTypes;\n import com.google.common.collect.ImmutableList;\n import java.util.Arrays;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n-// packages.bara.sky: import com.google.android.exoplayer2.util.MimeTypes;\n-// packages.bara.sky: import com.google.android.exoplayer2.Bundleable;\n-// packages.bara.sky: import com.google.android.exoplayer2.C;\n-// packages.bara.sky: import com.google.android.exoplayer2.Format;\n \n /** Unit tests for {@link TrackSelectionOverrides}. */\n @RunWith(AndroidJUnit4.class)",
      "parent_sha": "4a8f2fc78723810403d69467e654cb8f9ed15e8b"
    }
  },
  {
    "oid": "0bfbcea632c14c56e6c14d8a3d1760b6e251a26b",
    "message": "Reset requiresSecureDecoder boolean on codec release\n\nPiperOrigin-RevId: 229253065",
    "date": "2019-01-14T23:58:35Z",
    "url": "https://github.com/google/ExoPlayer/commit/0bfbcea632c14c56e6c14d8a3d1760b6e251a26b",
    "details": {
      "sha": "77d3b31ab7e2b7cdefa6cc8b882b08a998f12f53",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java",
      "status": "modified",
      "additions": 12,
      "deletions": 11,
      "changes": 23,
      "blob_url": "https://github.com/google/ExoPlayer/blob/0bfbcea632c14c56e6c14d8a3d1760b6e251a26b/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fmediacodec%2FMediaCodecRenderer.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/0bfbcea632c14c56e6c14d8a3d1760b6e251a26b/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fmediacodec%2FMediaCodecRenderer.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fmediacodec%2FMediaCodecRenderer.java?ref=0bfbcea632c14c56e6c14d8a3d1760b6e251a26b",
      "patch": "@@ -296,7 +296,7 @@ private static String buildCustomDiagnosticInfo(int errorCode) {\n   @Nullable private DrmSession<FrameworkMediaCrypto> codecDrmSession;\n   @Nullable private DrmSession<FrameworkMediaCrypto> sourceDrmSession;\n   @Nullable private MediaCrypto mediaCrypto;\n-  private boolean drmSessionRequiresSecureDecoder;\n+  private boolean mediaCryptoRequiresSecureDecoder;\n   private long renderTimeLimitMs;\n   private float rendererOperatingRate;\n   @Nullable private MediaCodec codec;\n@@ -481,7 +481,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {\n           } catch (MediaCryptoException e) {\n             throw ExoPlaybackException.createForRenderer(e, getIndex());\n           }\n-          drmSessionRequiresSecureDecoder =\n+          mediaCryptoRequiresSecureDecoder =\n               !sessionMediaCrypto.forceAllowInsecureDecoderComponents\n                   && mediaCrypto.requiresSecureDecoderComponent(mimeType);\n         }\n@@ -498,7 +498,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {\n     }\n \n     try {\n-      maybeInitCodecWithFallback(mediaCrypto, drmSessionRequiresSecureDecoder);\n+      maybeInitCodecWithFallback(mediaCrypto, mediaCryptoRequiresSecureDecoder);\n     } catch (DecoderInitializationException e) {\n       throw ExoPlaybackException.createForRenderer(e, getIndex());\n     }\n@@ -606,6 +606,7 @@ protected void releaseCodec() {\n         }\n       } finally {\n         mediaCrypto = null;\n+        mediaCryptoRequiresSecureDecoder = false;\n         setCodecDrmSession(null);\n       }\n     }\n@@ -727,18 +728,18 @@ protected boolean flushOrReleaseCodec() {\n   }\n \n   private void maybeInitCodecWithFallback(\n-      MediaCrypto crypto, boolean drmSessionRequiresSecureDecoder)\n+      MediaCrypto crypto, boolean mediaCryptoRequiresSecureDecoder)\n       throws DecoderInitializationException {\n     if (availableCodecInfos == null) {\n       try {\n         availableCodecInfos =\n-            new ArrayDeque<>(getAvailableCodecInfos(drmSessionRequiresSecureDecoder));\n+            new ArrayDeque<>(getAvailableCodecInfos(mediaCryptoRequiresSecureDecoder));\n         preferredDecoderInitializationException = null;\n       } catch (DecoderQueryException e) {\n         throw new DecoderInitializationException(\n             inputFormat,\n             e,\n-            drmSessionRequiresSecureDecoder,\n+            mediaCryptoRequiresSecureDecoder,\n             DecoderInitializationException.DECODER_QUERY_ERROR);\n       }\n     }\n@@ -747,7 +748,7 @@ private void maybeInitCodecWithFallback(\n       throw new DecoderInitializationException(\n           inputFormat,\n           /* cause= */ null,\n-          drmSessionRequiresSecureDecoder,\n+          mediaCryptoRequiresSecureDecoder,\n           DecoderInitializationException.NO_SUITABLE_DECODER_ERROR);\n     }\n \n@@ -766,7 +767,7 @@ private void maybeInitCodecWithFallback(\n         availableCodecInfos.removeFirst();\n         DecoderInitializationException exception =\n             new DecoderInitializationException(\n-                inputFormat, e, drmSessionRequiresSecureDecoder, codecInfo.name);\n+                inputFormat, e, mediaCryptoRequiresSecureDecoder, codecInfo.name);\n         if (preferredDecoderInitializationException == null) {\n           preferredDecoderInitializationException = exception;\n         } else {\n@@ -782,11 +783,11 @@ private void maybeInitCodecWithFallback(\n     availableCodecInfos = null;\n   }\n \n-  private List<MediaCodecInfo> getAvailableCodecInfos(boolean drmSessionRequiresSecureDecoder)\n+  private List<MediaCodecInfo> getAvailableCodecInfos(boolean mediaCryptoRequiresSecureDecoder)\n       throws DecoderQueryException {\n     List<MediaCodecInfo> codecInfos =\n-        getDecoderInfos(mediaCodecSelector, inputFormat, drmSessionRequiresSecureDecoder);\n-    if (codecInfos.isEmpty() && drmSessionRequiresSecureDecoder) {\n+        getDecoderInfos(mediaCodecSelector, inputFormat, mediaCryptoRequiresSecureDecoder);\n+    if (codecInfos.isEmpty() && mediaCryptoRequiresSecureDecoder) {\n       // The drm session indicates that a secure decoder is required, but the device does not\n       // have one. Assuming that supportsFormat indicated support for the media being played, we\n       // know that it does not require a secure output path. Most CDM implementations allow",
      "parent_sha": "1b62277a0b2bf72d68abd3afb6510647a7ff6643"
    }
  },
  {
    "oid": "79055066813123c939c29e5a5e223a5ff043b91e",
    "message": "On Sony Bravia devices check for 4k panel.\n\nDocumentation: https://developer.sony.com/develop/tvs/android-tv/design-guide/\n\nOn API 23 we should also check Display.Mode (where supported).\n\nIssue: #800",
    "date": "2015-10-12T11:25:58Z",
    "url": "https://github.com/google/ExoPlayer/commit/79055066813123c939c29e5a5e223a5ff043b91e",
    "details": {
      "sha": "f9a4aae6b74ea8f24e3c1da8d78e28d4be9b1738",
      "filename": "library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java",
      "status": "modified",
      "additions": 15,
      "deletions": 4,
      "changes": 19,
      "blob_url": "https://github.com/google/ExoPlayer/blob/79055066813123c939c29e5a5e223a5ff043b91e/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer%2Fchunk%2FVideoFormatSelectorUtil.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/79055066813123c939c29e5a5e223a5ff043b91e/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer%2Fchunk%2FVideoFormatSelectorUtil.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer%2Fchunk%2FVideoFormatSelectorUtil.java?ref=79055066813123c939c29e5a5e223a5ff043b91e",
      "patch": "@@ -55,11 +55,9 @@ public final class VideoFormatSelectorUtil {\n   public static int[] selectVideoFormatsForDefaultDisplay(Context context,\n       List<? extends FormatWrapper> formatWrappers, String[] allowedContainerMimeTypes,\n       boolean filterHdFormats) throws DecoderQueryException {\n-    WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);\n-    Display display = windowManager.getDefaultDisplay();\n-    Point displaySize = getDisplaySize(display);\n+    Point viewportSize = getViewportSize(context);\n     return selectVideoFormats(formatWrappers, allowedContainerMimeTypes, filterHdFormats, true,\n-        displaySize.x, displaySize.y);\n+        viewportSize.x, viewportSize.y);\n   }\n \n   /**\n@@ -184,6 +182,19 @@ private static Point getMaxVideoSizeInViewport(boolean orientationMayChange, int\n     }\n   }\n \n+  private static Point getViewportSize(Context context) {\n+    // Before API 23 the platform Display object does not provide a way to identify Android TVs that\n+    // can show 4k resolution in a SurfaceView, so check for supported devices here.\n+    // See also https://developer.sony.com/develop/tvs/android-tv/design-guide/.\n+    if (Util.MODEL != null && Util.MODEL.startsWith(\"BRAVIA\")\n+        && context.getPackageManager().hasSystemFeature(\"com.sony.dtv.hardware.panel.qfhd\")) {\n+      return new Point(3840, 2160);\n+    }\n+\n+    WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);\n+    return getDisplaySize(windowManager.getDefaultDisplay());\n+  }\n+\n   private static Point getDisplaySize(Display display) {\n     Point displaySize = new Point();\n     if (Util.SDK_INT >= 17) {",
      "parent_sha": "952bd4e73cf261be9baa6b251d59cfff3d455783"
    }
  },
  {
    "oid": "513b268558f7c01240a3656518be75e14983361c",
    "message": "Detect invalid frames early in passthrough/offload\n\nWithout checking if getFramesPerEncodedSample fails,\nthe frame count becomes negative which leads to\nhard to debug errors.\n\nPiperOrigin-RevId: 319247618",
    "date": "2020-07-03T08:02:41Z",
    "url": "https://github.com/google/ExoPlayer/commit/513b268558f7c01240a3656518be75e14983361c",
    "details": {
      "sha": "9beae27c895073e85b666ee38ba9e170f3afcf5c",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/google/ExoPlayer/blob/513b268558f7c01240a3656518be75e14983361c/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Faudio%2FDefaultAudioSink.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/513b268558f7c01240a3656518be75e14983361c/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Faudio%2FDefaultAudioSink.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Faudio%2FDefaultAudioSink.java?ref=513b268558f7c01240a3656518be75e14983361c",
      "patch": "@@ -1402,7 +1402,11 @@ private static int getFramesPerEncodedSample(@C.Encoding int encoding, ByteBuffe\n     switch (encoding) {\n       case C.ENCODING_MP3:\n         int headerDataInBigEndian = Util.getBigEndianInt(buffer, buffer.position());\n-        return MpegAudioUtil.parseMpegAudioFrameSampleCount(headerDataInBigEndian);\n+        int frameCount = MpegAudioUtil.parseMpegAudioFrameSampleCount(headerDataInBigEndian);\n+        if (frameCount == C.LENGTH_UNSET) {\n+          throw new IllegalArgumentException();\n+        }\n+        return frameCount;\n       case C.ENCODING_AAC_LC:\n         return AacUtil.AAC_LC_AUDIO_SAMPLE_COUNT;\n       case C.ENCODING_AAC_HE_V1:",
      "parent_sha": "541568386baa0b1aeebd7afb6d86a494b044144b"
    }
  },
  {
    "oid": "44f6dbb0ccb856391e67ca96c5a8bdc5bbf7e067",
    "message": "Work around the error prone warning\n\nError prone check doesn't like we pass a variable named 'end' as start parameter and 'start' as end.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=159567308",
    "date": "2017-06-22T19:12:24Z",
    "url": "https://github.com/google/ExoPlayer/commit/44f6dbb0ccb856391e67ca96c5a8bdc5bbf7e067",
    "details": {
      "sha": "7c01c59914e8ba556d321ba92d31a726a5f1c545",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/util/Util.java",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/google/ExoPlayer/blob/44f6dbb0ccb856391e67ca96c5a8bdc5bbf7e067/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Futil%2FUtil.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/44f6dbb0ccb856391e67ca96c5a8bdc5bbf7e067/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Futil%2FUtil.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Futil%2FUtil.java?ref=44f6dbb0ccb856391e67ca96c5a8bdc5bbf7e067",
      "patch": "@@ -977,15 +977,15 @@ public static String unescapeFileName(String fileName) {\n     int expectedLength = length - percentCharacterCount * 2;\n     StringBuilder builder = new StringBuilder(expectedLength);\n     Matcher matcher = ESCAPED_CHARACTER_PATTERN.matcher(fileName);\n-    int endOfLastMatch = 0;\n+    int startOfNotEscaped = 0;\n     while (percentCharacterCount > 0 && matcher.find()) {\n       char unescapedCharacter = (char) Integer.parseInt(matcher.group(1), 16);\n-      builder.append(fileName, endOfLastMatch, matcher.start()).append(unescapedCharacter);\n-      endOfLastMatch = matcher.end();\n+      builder.append(fileName, startOfNotEscaped, matcher.start()).append(unescapedCharacter);\n+      startOfNotEscaped = matcher.end();\n       percentCharacterCount--;\n     }\n-    if (endOfLastMatch < length) {\n-      builder.append(fileName, endOfLastMatch, length);\n+    if (startOfNotEscaped < length) {\n+      builder.append(fileName, startOfNotEscaped, length);\n     }\n     if (builder.length() != expectedLength) {\n       return null;",
      "parent_sha": "467fd2535c030171a0520e4884de76ecd9308731"
    }
  },
  {
    "oid": "679909793025fb4682a37fd031a62cf2f0f91f1e",
    "message": "Fix decoder fallback for E-AC3 JOC to E-AC3\n\n\r\nIssue: #6073",
    "date": "2019-06-21T10:50:12Z",
    "url": "https://github.com/google/ExoPlayer/commit/679909793025fb4682a37fd031a62cf2f0f91f1e",
    "details": {
      "sha": "374c15eea05ed2e497363638697c3ffff63bdab9",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/ExoPlayer/blob/679909793025fb4682a37fd031a62cf2f0f91f1e/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fmediacodec%2FMediaCodecUtil.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/679909793025fb4682a37fd031a62cf2f0f91f1e/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fmediacodec%2FMediaCodecUtil.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fmediacodec%2FMediaCodecUtil.java?ref=679909793025fb4682a37fd031a62cf2f0f91f1e",
      "patch": "@@ -176,7 +176,7 @@ public static synchronized List<MediaCodecInfo> getDecoderInfos(\n       // E-AC3 decoders can decode JOC streams, but in 2-D rather than 3-D.\n       CodecKey eac3Key = new CodecKey(MimeTypes.AUDIO_E_AC3, key.secure, key.tunneling);\n       ArrayList<MediaCodecInfo> eac3DecoderInfos =\n-          getDecoderInfosInternal(eac3Key, mediaCodecList, mimeType);\n+          getDecoderInfosInternal(eac3Key, mediaCodecList, MimeTypes.AUDIO_E_AC3);\n       decoderInfos.addAll(eac3DecoderInfos);\n     }\n     applyWorkarounds(mimeType, decoderInfos);",
      "parent_sha": "c8955ed5ff134e197143da98bb52edecd3efd090"
    }
  },
  {
    "oid": "a24ffbd21b83538e0022de87ec0c05fad7d0ad7d",
    "message": "Fix StyledPlayerControlView reference in demo app's PlayerActivity\n\nPiperOrigin-RevId: 416809105",
    "date": "2022-01-05T10:31:28Z",
    "url": "https://github.com/google/ExoPlayer/commit/a24ffbd21b83538e0022de87ec0c05fad7d0ad7d",
    "details": {
      "sha": "00cb9e7b260f1083c7d9ede73814f4ab4dcca34c",
      "filename": "demos/main/src/main/java/androidx/media3/demo/main/PlayerActivity.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/ExoPlayer/blob/a24ffbd21b83538e0022de87ec0c05fad7d0ad7d/demos%2Fmain%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fdemo%2Fmain%2FPlayerActivity.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/a24ffbd21b83538e0022de87ec0c05fad7d0ad7d/demos%2Fmain%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fdemo%2Fmain%2FPlayerActivity.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/demos%2Fmain%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fdemo%2Fmain%2FPlayerActivity.java?ref=a24ffbd21b83538e0022de87ec0c05fad7d0ad7d",
      "patch": "@@ -234,7 +234,7 @@ public void onClick(View view) {\n     }\n   }\n \n-  // PlayerControlView.VisibilityListener implementation\n+  // StyledPlayerControlView.VisibilityListener implementation\n \n   @Override\n   public void onVisibilityChange(int visibility) {",
      "parent_sha": "4c71e06079e3bbdace9a05ed077c12faec5816cd"
    }
  },
  {
    "oid": "a04663372fe6f3538fd27c322054769996bf84e4",
    "message": "Detect playlist stuck and playlist reset conditions in HLS\n\nThis CL aims that the player fails upon:\n\n- Playlist that don't change in a suspiciously long time,\n  which might mean there are server side issues.\n- Playlist with a media sequence lower that its last snapshot\n  and no overlapping segments.\n\nThis two error conditions are propagated through the renderer,\nbut not through MediaSource#maybeThrowSourceInfoRefreshError.\n\nIssue:#2872\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=160899995",
    "date": "2017-07-05T14:02:39Z",
    "url": "https://github.com/google/ExoPlayer/commit/a04663372fe6f3538fd27c322054769996bf84e4",
    "details": {
      "sha": "567dbd4af6715b0610dd4a32408c6c73da37394d",
      "filename": "library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java",
      "status": "modified",
      "additions": 72,
      "deletions": 10,
      "changes": 82,
      "blob_url": "https://github.com/google/ExoPlayer/blob/a04663372fe6f3538fd27c322054769996bf84e4/library%2Fhls%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fhls%2Fplaylist%2FHlsPlaylistTracker.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/a04663372fe6f3538fd27c322054769996bf84e4/library%2Fhls%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fhls%2Fplaylist%2FHlsPlaylistTracker.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fhls%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fhls%2Fplaylist%2FHlsPlaylistTracker.java?ref=a04663372fe6f3538fd27c322054769996bf84e4",
      "patch": "@@ -40,6 +40,38 @@\n  */\n public final class HlsPlaylistTracker implements Loader.Callback<ParsingLoadable<HlsPlaylist>> {\n \n+  /**\n+   * Thrown when a playlist is considered to be stuck due to a server side error.\n+   */\n+  public static final class PlaylistStuckException extends IOException {\n+\n+    /**\n+     * The url of the stuck playlist.\n+     */\n+    public final String url;\n+\n+    private PlaylistStuckException(String url) {\n+      this.url = url;\n+    }\n+\n+  }\n+\n+  /**\n+   * Thrown when the media sequence of a new snapshot indicates the server has reset.\n+   */\n+  public static final class PlaylistResetException extends IOException {\n+\n+    /**\n+     * The url of the reset playlist.\n+     */\n+    public final String url;\n+\n+    private PlaylistResetException(String url) {\n+      this.url = url;\n+    }\n+\n+  }\n+\n   /**\n    * Listener for primary playlist changes.\n    */\n@@ -75,6 +107,11 @@ public interface PlaylistEventListener {\n \n   }\n \n+  /**\n+   * Coefficient applied on the target duration of a playlist to determine the amount of time after\n+   * which an unchanging playlist is considered stuck.\n+   */\n+  private static final double PLAYLIST_STUCK_TARGET_DURATION_COEFFICIENT = 3.5;\n   /**\n    * The minimum number of milliseconds that a url is kept as primary url, if no\n    * {@link #getPlaylistSnapshot} call is made for that url.\n@@ -213,14 +250,14 @@ public void maybeThrowPrimaryPlaylistRefreshError() throws IOException {\n   }\n \n   /**\n-   * If the playlist is having trouble loading the playlist referenced by the given {@link HlsUrl},\n-   * this method throws the underlying error.\n+   * If the playlist is having trouble refreshing the playlist referenced by the given\n+   * {@link HlsUrl}, this method throws the underlying error.\n    *\n    * @param url The {@link HlsUrl}.\n    * @throws IOException The underyling error.\n    */\n   public void maybeThrowPlaylistRefreshError(HlsUrl url) throws IOException {\n-    playlistBundles.get(url).mediaPlaylistLoader.maybeThrowError();\n+    playlistBundles.get(url).maybeThrowPlaylistRefreshError();\n   }\n \n   /**\n@@ -441,9 +478,11 @@ private final class MediaPlaylistBundle implements Loader.Callback<ParsingLoadab\n \n     private HlsMediaPlaylist playlistSnapshot;\n     private long lastSnapshotLoadMs;\n+    private long lastSnapshotChangeMs;\n     private long lastSnapshotAccessTimeMs;\n     private long blacklistUntilMs;\n     private boolean pendingRefresh;\n+    private IOException playlistError;\n \n     public MediaPlaylistBundle(HlsUrl playlistUrl, long initialLastSnapshotAccessTimeMs) {\n       this.playlistUrl = playlistUrl;\n@@ -483,6 +522,13 @@ public void loadPlaylist() {\n       }\n     }\n \n+    public void maybeThrowPlaylistRefreshError() throws IOException {\n+      mediaPlaylistLoader.maybeThrowError();\n+      if (playlistError != null) {\n+        throw playlistError;\n+      }\n+    }\n+\n     // Loader.Callback implementation.\n \n     @Override\n@@ -494,8 +540,7 @@ public void onLoadCompleted(ParsingLoadable<HlsPlaylist> loadable, long elapsedR\n         eventDispatcher.loadCompleted(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,\n             loadDurationMs, loadable.bytesLoaded());\n       } else {\n-        onLoadError(loadable, elapsedRealtimeMs, loadDurationMs,\n-            new ParserException(\"Loaded playlist has unexpected type.\"));\n+        playlistError = new ParserException(\"Loaded playlist has unexpected type.\");\n       }\n     }\n \n@@ -517,10 +562,7 @@ public int onLoadError(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealti\n       }\n       boolean shouldRetry = true;\n       if (ChunkedTrackBlacklistUtil.shouldBlacklist(error)) {\n-        blacklistUntilMs =\n-            SystemClock.elapsedRealtime() + ChunkedTrackBlacklistUtil.DEFAULT_TRACK_BLACKLIST_MS;\n-        notifyPlaylistBlacklisting(playlistUrl,\n-            ChunkedTrackBlacklistUtil.DEFAULT_TRACK_BLACKLIST_MS);\n+        blacklistPlaylist();\n         shouldRetry = primaryHlsUrl == playlistUrl && !maybeSelectNewPrimaryUrl();\n       }\n       return shouldRetry ? Loader.RETRY : Loader.DONT_RETRY;\n@@ -538,14 +580,28 @@ public void run() {\n \n     private void processLoadedPlaylist(HlsMediaPlaylist loadedPlaylist) {\n       HlsMediaPlaylist oldPlaylist = playlistSnapshot;\n-      lastSnapshotLoadMs = SystemClock.elapsedRealtime();\n+      long currentTimeMs = SystemClock.elapsedRealtime();\n+      lastSnapshotLoadMs = currentTimeMs;\n       playlistSnapshot = getLatestPlaylistSnapshot(oldPlaylist, loadedPlaylist);\n       long refreshDelayUs = C.TIME_UNSET;\n       if (playlistSnapshot != oldPlaylist) {\n+        playlistError = null;\n+        lastSnapshotChangeMs = currentTimeMs;\n         if (onPlaylistUpdated(playlistUrl, playlistSnapshot)) {\n           refreshDelayUs = playlistSnapshot.targetDurationUs;\n         }\n       } else if (!playlistSnapshot.hasEndTag) {\n+        if (currentTimeMs - lastSnapshotChangeMs\n+            > C.usToMs(playlistSnapshot.targetDurationUs)\n+                * PLAYLIST_STUCK_TARGET_DURATION_COEFFICIENT) {\n+          // The playlist seems to be stuck, we blacklist it.\n+          playlistError = new PlaylistStuckException(playlistUrl.url);\n+          blacklistPlaylist();\n+        } else if (loadedPlaylist.mediaSequence + loadedPlaylist.segments.size()\n+            < playlistSnapshot.mediaSequence) {\n+          // The media sequence has jumped backwards. The server has likely reset.\n+          playlistError = new PlaylistResetException(playlistUrl.url);\n+        }\n         refreshDelayUs = playlistSnapshot.targetDurationUs / 2;\n       }\n       if (refreshDelayUs != C.TIME_UNSET) {\n@@ -554,6 +610,12 @@ private void processLoadedPlaylist(HlsMediaPlaylist loadedPlaylist) {\n       }\n     }\n \n+    private void blacklistPlaylist() {\n+      blacklistUntilMs = SystemClock.elapsedRealtime()\n+          + ChunkedTrackBlacklistUtil.DEFAULT_TRACK_BLACKLIST_MS;\n+      notifyPlaylistBlacklisting(playlistUrl, ChunkedTrackBlacklistUtil.DEFAULT_TRACK_BLACKLIST_MS);\n+    }\n+\n   }\n \n }",
      "parent_sha": "dda3616f5ad2b83016bfe1f8a7fe427b29670a41"
    }
  },
  {
    "oid": "91e611d5dcf085b3f92829f7109238289adcce7f",
    "message": "Create an AdEventListener for each supported stream type\n\nThis is a refactoring to separate and simplify the logic\nof VOD and live streams when handling IMA ad events. An\nadditional listener will be required for DASH live stream\nin a follow-up CL.\n\nPiperOrigin-RevId: 507435741",
    "date": "2023-02-08T15:02:36Z",
    "url": "https://github.com/google/ExoPlayer/commit/91e611d5dcf085b3f92829f7109238289adcce7f",
    "details": {
      "sha": "8ff13b888f37f83d073fa6ea491c1838cad04c32",
      "filename": "extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaServerSideAdInsertionMediaSource.java",
      "status": "modified",
      "additions": 80,
      "deletions": 51,
      "changes": 131,
      "blob_url": "https://github.com/google/ExoPlayer/blob/91e611d5dcf085b3f92829f7109238289adcce7f/extensions%2Fima%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fext%2Fima%2FImaServerSideAdInsertionMediaSource.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/91e611d5dcf085b3f92829f7109238289adcce7f/extensions%2Fima%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fext%2Fima%2FImaServerSideAdInsertionMediaSource.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/extensions%2Fima%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fext%2Fima%2FImaServerSideAdInsertionMediaSource.java?ref=91e611d5dcf085b3f92829f7109238289adcce7f",
      "patch": "@@ -526,14 +526,19 @@ private ImaServerSideAdInsertionMediaSource(\n     this.contentMediaSourceFactory = contentMediaSourceFactory;\n     this.applicationAdEventListener = applicationAdEventListener;\n     this.applicationAdErrorListener = applicationAdErrorListener;\n-    componentListener = new ComponentListener();\n     Assertions.checkArgument(player.getApplicationLooper() == Looper.getMainLooper());\n     mainHandler = new Handler(Looper.getMainLooper());\n     Uri streamRequestUri = checkNotNull(mediaItem.localConfiguration).uri;\n     isLiveStream = ImaServerSideAdInsertionUriBuilder.isLiveStream(streamRequestUri);\n     adsId = ImaServerSideAdInsertionUriBuilder.getAdsId(streamRequestUri);\n     loadVideoTimeoutMs = ImaServerSideAdInsertionUriBuilder.getLoadVideoTimeoutMs(streamRequestUri);\n     streamRequest = ImaServerSideAdInsertionUriBuilder.createStreamRequest(streamRequestUri);\n+    boolean isDashStream = streamRequest.getFormat().equals(StreamRequest.StreamFormat.DASH);\n+    componentListener =\n+        new ComponentListener(\n+            isLiveStream\n+                ? (isDashStream ? new NoopAdEventListener() : new SinglePeriodLiveAdEventListener())\n+                : new VodAdEventListener());\n     adPlaybackState = adsLoader.getAdPlaybackState(adsId);\n   }\n \n@@ -771,6 +776,13 @@ private static AdPlaybackState skipAd(Ad ad, AdPlaybackState adPlaybackState) {\n   private final class ComponentListener\n       implements AdEvent.AdEventListener, Player.Listener, AdPlaybackStateUpdater {\n \n+    private final AdEventListener adEventListener;\n+\n+    /** Creates an new instance. */\n+    public ComponentListener(AdEventListener adEventListener) {\n+      this.adEventListener = adEventListener;\n+    }\n+\n     // Implement Player.Listener.\n \n     @Override\n@@ -881,56 +893,7 @@ public void onVolumeChanged(float volume) {\n     @MainThread\n     @Override\n     public void onAdEvent(AdEvent event) {\n-      AdPlaybackState newAdPlaybackState = adPlaybackState;\n-      switch (event.getType()) {\n-        case CUEPOINTS_CHANGED:\n-          // CUEPOINTS_CHANGED event is firing multiple times with the same queue points.\n-          if (!isLiveStream && newAdPlaybackState.equals(AdPlaybackState.NONE)) {\n-            newAdPlaybackState =\n-                setVodAdGroupPlaceholders(\n-                    checkNotNull(streamManager).getCuePoints(), new AdPlaybackState(adsId));\n-          }\n-          break;\n-        case LOADED:\n-          if (isLiveStream) {\n-            Timeline timeline = player.getCurrentTimeline();\n-            Timeline.Window window =\n-                timeline.getWindow(player.getCurrentMediaItemIndex(), new Timeline.Window());\n-            if (window.lastPeriodIndex > window.firstPeriodIndex) {\n-              // multi-period live not integrated\n-              return;\n-            }\n-            long positionInWindowUs =\n-                timeline.getPeriod(player.getCurrentPeriodIndex(), new Timeline.Period())\n-                    .positionInWindowUs;\n-            long currentContentPeriodPositionUs =\n-                msToUs(player.getContentPosition()) - positionInWindowUs;\n-            Ad ad = event.getAd();\n-            AdPodInfo adPodInfo = ad.getAdPodInfo();\n-            newAdPlaybackState =\n-                addLiveAdBreak(\n-                    currentContentPeriodPositionUs,\n-                    /* adDurationUs= */ secToUsRounded(ad.getDuration()),\n-                    /* adPositionInAdPod= */ adPodInfo.getAdPosition(),\n-                    /* totalAdDurationUs= */ secToUsRounded(adPodInfo.getMaxDuration()),\n-                    /* totalAdsInAdPod= */ adPodInfo.getTotalAds(),\n-                    /* adPlaybackState= */ newAdPlaybackState.equals(AdPlaybackState.NONE)\n-                        ? new AdPlaybackState(adsId)\n-                        : newAdPlaybackState);\n-          } else {\n-            newAdPlaybackState = setVodAdInPlaceholder(event.getAd(), newAdPlaybackState);\n-          }\n-          break;\n-        case SKIPPED:\n-          if (!isLiveStream) {\n-            newAdPlaybackState = skipAd(event.getAd(), newAdPlaybackState);\n-          }\n-          break;\n-        default:\n-          // Do nothing.\n-          break;\n-      }\n-      setAdPlaybackState(newAdPlaybackState);\n+      adEventListener.onAdEvent(event);\n     }\n \n     // Implement AdPlaybackStateUpdater (called on the playback thread).\n@@ -1354,4 +1317,70 @@ private static void assertSingleInstanceInPlaylist(Player player) {\n       }\n     }\n   }\n+\n+  private class VodAdEventListener implements AdEventListener {\n+    @Override\n+    public void onAdEvent(AdEvent event) {\n+      AdPlaybackState newAdPlaybackState = adPlaybackState;\n+      switch (event.getType()) {\n+        case CUEPOINTS_CHANGED:\n+          if (newAdPlaybackState.equals(AdPlaybackState.NONE)) {\n+            newAdPlaybackState =\n+                setVodAdGroupPlaceholders(\n+                    checkNotNull(streamManager).getCuePoints(), new AdPlaybackState(adsId));\n+          }\n+          break;\n+        case LOADED:\n+          newAdPlaybackState = setVodAdInPlaceholder(event.getAd(), newAdPlaybackState);\n+          break;\n+        case SKIPPED:\n+          newAdPlaybackState = skipAd(event.getAd(), newAdPlaybackState);\n+          break;\n+        default:\n+          // Do nothing.\n+          break;\n+      }\n+      setAdPlaybackState(newAdPlaybackState);\n+    }\n+  }\n+\n+  private class SinglePeriodLiveAdEventListener implements AdEventListener {\n+    @Override\n+    public void onAdEvent(AdEvent event) {\n+      if (event.getType() != AdEvent.AdEventType.LOADED) {\n+        return;\n+      }\n+      AdPlaybackState newAdPlaybackState = adPlaybackState;\n+      Timeline timeline = player.getCurrentTimeline();\n+      long positionInWindowUs =\n+          timeline.getPeriod(player.getCurrentPeriodIndex(), new Timeline.Period())\n+              .positionInWindowUs;\n+      long currentContentPeriodPositionUs =\n+          msToUs(player.getContentPosition()) - positionInWindowUs;\n+      Ad ad = event.getAd();\n+      AdPodInfo adPodInfo = ad.getAdPodInfo();\n+      newAdPlaybackState =\n+          addLiveAdBreak(\n+              currentContentPeriodPositionUs,\n+              /* adDurationUs= */ secToUsRounded(ad.getDuration()),\n+              /* adPositionInAdPod= */ adPodInfo.getAdPosition(),\n+              /* totalAdDurationUs= */ secToUsRounded(adPodInfo.getMaxDuration()),\n+              /* totalAdsInAdPod= */ adPodInfo.getTotalAds(),\n+              /* adPlaybackState= */ newAdPlaybackState.equals(AdPlaybackState.NONE)\n+                  ? new AdPlaybackState(adsId)\n+                  : newAdPlaybackState);\n+      setAdPlaybackState(newAdPlaybackState);\n+    }\n+  }\n+\n+  private static class NoopAdEventListener implements AdEventListener {\n+    @Override\n+    public void onAdEvent(AdEvent event) {\n+      Log.w(\n+          \"ImaSSAIMediaSource\",\n+          String.format(\n+              \"Ignoring IMA ad event %s because the current stream type is not supported.\",\n+              event.getType().name()));\n+    }\n+  }\n }",
      "parent_sha": "4631105fb3c199bed616628f96b312a63bc93283"
    }
  },
  {
    "oid": "dbe0e602ef76f8491e8da41635be3fef2e7b7c50",
    "message": "Use Timeline.getPeriodPosition to resolve period index in ExoPlayerImpl.seekTo\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=174460558",
    "date": "2017-11-03T16:09:46Z",
    "url": "https://github.com/google/ExoPlayer/commit/dbe0e602ef76f8491e8da41635be3fef2e7b7c50",
    "details": {
      "sha": "d28f72e73987f80499611eb21e457fabeee6f80a",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java",
      "status": "modified",
      "additions": 6,
      "deletions": 12,
      "changes": 18,
      "blob_url": "https://github.com/google/ExoPlayer/blob/dbe0e602ef76f8491e8da41635be3fef2e7b7c50/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FExoPlayerImpl.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/dbe0e602ef76f8491e8da41635be3fef2e7b7c50/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FExoPlayerImpl.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FExoPlayerImpl.java?ref=dbe0e602ef76f8491e8da41635be3fef2e7b7c50",
      "patch": "@@ -21,6 +21,7 @@\n import android.os.Message;\n import android.support.annotation.Nullable;\n import android.util.Log;\n+import android.util.Pair;\n import com.google.android.exoplayer2.source.MediaSource;\n import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;\n import com.google.android.exoplayer2.source.TrackGroupArray;\n@@ -254,19 +255,12 @@ public void seekTo(int windowIndex, long positionMs) {\n       maskingWindowPositionMs = positionMs == C.TIME_UNSET ? 0 : positionMs;\n       maskingPeriodIndex = 0;\n     } else {\n-      timeline.getWindow(windowIndex, window);\n-      long windowPositionUs = positionMs == C.TIME_UNSET ? window.getDefaultPositionUs()\n-          : C.msToUs(positionMs);\n-      int periodIndex = window.firstPeriodIndex;\n-      long periodPositionUs = window.getPositionInFirstPeriodUs() + windowPositionUs;\n-      long periodDurationUs = timeline.getPeriod(periodIndex, period).getDurationUs();\n-      while (periodDurationUs != C.TIME_UNSET && periodPositionUs >= periodDurationUs\n-          && periodIndex < window.lastPeriodIndex) {\n-        periodPositionUs -= periodDurationUs;\n-        periodDurationUs = timeline.getPeriod(++periodIndex, period).getDurationUs();\n-      }\n+      long windowPositionUs = positionMs == C.TIME_UNSET\n+          ? timeline.getWindow(windowIndex, window).getDefaultPositionUs() : C.msToUs(positionMs);\n+      Pair<Integer, Long> periodIndexAndPositon =\n+          timeline.getPeriodPosition(window, period, windowIndex, windowPositionUs);\n       maskingWindowPositionMs = C.usToMs(windowPositionUs);\n-      maskingPeriodIndex = periodIndex;\n+      maskingPeriodIndex = periodIndexAndPositon.first;\n     }\n     internalPlayer.seekTo(timeline, windowIndex, C.msToUs(positionMs));\n     for (Player.EventListener listener : listeners) {",
      "parent_sha": "6ec53f4717df4cfe1fa85fa21a217fe032572823"
    }
  },
  {
    "oid": "f5024131b822572a305bf553ff47c021b10e5f03",
    "message": "Fix typos in Javadoc\n\nPiperOrigin-RevId: 360440021",
    "date": "2021-03-12T10:37:19Z",
    "url": "https://github.com/google/ExoPlayer/commit/f5024131b822572a305bf553ff47c021b10e5f03",
    "details": {
      "sha": "f43c9791356c8a6022931da73a19d52713f1e97c",
      "filename": "library/common/src/main/java/com/google/android/exoplayer2/Player.java",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/google/ExoPlayer/blob/f5024131b822572a305bf553ff47c021b10e5f03/library%2Fcommon%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FPlayer.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/f5024131b822572a305bf553ff47c021b10e5f03/library%2Fcommon%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FPlayer.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcommon%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FPlayer.java?ref=f5024131b822572a305bf553ff47c021b10e5f03",
      "patch": "@@ -1316,11 +1316,10 @@ public int get(int index) {\n   void setPlaybackParameters(@Nullable PlaybackParameters playbackParameters);\n \n   /**\n-   * Changes the rate at which playback occurs.\n+   * Changes the rate at which playback occurs. The pitch is not changed.\n    *\n-   * <p>The pitch is not changed.\n-   *\n-   * <p>This is equivalent to {@code setPlaybackParameter(getPlaybackParameter().withSpeed(speed))}.\n+   * <p>This is equivalent to {@code\n+   * setPlaybackParameters(getPlaybackParameters().withSpeed(speed))}.\n    *\n    * @param speed The linear factor by which playback will be sped up. Must be higher than 0. 1 is\n    *     normal speed, 2 is twice as fast, 0.5 is half normal speed...",
      "parent_sha": "6be3a59354635a633d597576f011934cb1c70425"
    }
  },
  {
    "oid": "5d6ffaaf5576fd83b039ffc32b4be1aef594bafc",
    "message": "Fix HDR effect pipeline\n\nNPE in toneMap_hlgFrame_matchesGoldenFile and toneMap_pqFrame_matchesGoldenFile was created because a uEnableColorTransfer uniform was being created on the HDR path, when HDR shader files don't have this uniform. (they don't support disable color transfers right now)\n\nFix: only create the uniform when input is SDR.\n\nmanually tested on failing tests\n\nPiperOrigin-RevId: 522002603",
    "date": "2023-04-05T10:14:04Z",
    "url": "https://github.com/google/ExoPlayer/commit/5d6ffaaf5576fd83b039ffc32b4be1aef594bafc",
    "details": {
      "sha": "3950b1a7299e59560c7a80e8eac80fe4dd392870",
      "filename": "libraries/effect/src/main/java/androidx/media3/effect/DefaultShaderProgram.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/ExoPlayer/blob/5d6ffaaf5576fd83b039ffc32b4be1aef594bafc/libraries%2Feffect%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Feffect%2FDefaultShaderProgram.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/5d6ffaaf5576fd83b039ffc32b4be1aef594bafc/libraries%2Feffect%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Feffect%2FDefaultShaderProgram.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/libraries%2Feffect%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Feffect%2FDefaultShaderProgram.java?ref=5d6ffaaf5576fd83b039ffc32b4be1aef594bafc",
      "patch": "@@ -334,7 +334,6 @@ private static DefaultShaderProgram createWithSampler(\n       ColorInfo outputColorInfo,\n       boolean enableColorTransfers)\n       throws VideoFrameProcessingException {\n-    glProgram.setIntUniform(\"uEnableColorTransfer\", enableColorTransfers ? GL_TRUE : GL_FALSE);\n     boolean isInputTransferHdr = ColorInfo.isTransferHdr(inputColorInfo);\n     @C.ColorTransfer int outputColorTransfer = outputColorInfo.colorTransfer;\n     if (isInputTransferHdr) {\n@@ -362,6 +361,7 @@ private static DefaultShaderProgram createWithSampler(\n           outputColorTransfer != Format.NO_VALUE && outputColorTransfer != C.COLOR_TRANSFER_SDR);\n       glProgram.setIntUniform(\"uOutputColorTransfer\", outputColorTransfer);\n     } else {\n+      glProgram.setIntUniform(\"uEnableColorTransfer\", enableColorTransfers ? GL_TRUE : GL_FALSE);\n       checkArgument(\n           outputColorInfo.colorSpace != C.COLOR_SPACE_BT2020,\n           \"Converting from SDR to HDR is not supported.\");",
      "parent_sha": "219967c5a3ff8d8957a07e39c04ea27b657cab92"
    }
  },
  {
    "oid": "1554db1673db2983566caa830dcc819ca8c1d1cb",
    "message": "Skip bad PES packets\n\nIssue: #200",
    "date": "2014-12-11T10:26:50Z",
    "url": "https://github.com/google/ExoPlayer/commit/1554db1673db2983566caa830dcc819ca8c1d1cb",
    "details": {
      "sha": "52a746ae279e55ecab4e9ed138268572d6bd0d69",
      "filename": "library/src/main/java/com/google/android/exoplayer/hls/TsExtractor.java",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/google/ExoPlayer/blob/1554db1673db2983566caa830dcc819ca8c1d1cb/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer%2Fhls%2FTsExtractor.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/1554db1673db2983566caa830dcc819ca8c1d1cb/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer%2Fhls%2FTsExtractor.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer%2Fhls%2FTsExtractor.java?ref=1554db1673db2983566caa830dcc819ca8c1d1cb",
      "patch": "@@ -448,12 +448,14 @@ public void read(BitArray tsBuffer, boolean payloadUnitStartIndicator) {\n     private void readPacketStart() {\n       int startCodePrefix = pesBuffer.readBits(24);\n       if (startCodePrefix != 0x000001) {\n-        // Error.\n+        Log.e(TAG, \"Unexpected start code prefix: \" + startCodePrefix);\n+        pesBuffer.reset();\n+        packetLength = -1;\n+      } else {\n+        // TODO: Read and use stream_id.\n+        pesBuffer.skipBits(8); // Skip stream_id.\n+        packetLength = pesBuffer.readBits(16);\n       }\n-      // TODO: Read and use stream_id.\n-      // Skip stream_id.\n-      pesBuffer.skipBits(8);\n-      packetLength = pesBuffer.readBits(16);\n     }\n \n     private void readPacketBody() {",
      "parent_sha": "035671b722286f7ea22e5bdf6a1fc1b76a9ca525"
    }
  },
  {
    "oid": "311d21bf8d2c53e05c4eaa502f2c1568a94af2f2",
    "message": "Remove the multi-threading from DrmSessionManagerTest\n\nI don't need to keep a separate playback looper, I can just use\nShadowLooper.idleMainLooper().\n\nPiperOrigin-RevId: 318823190",
    "date": "2020-07-03T07:59:51Z",
    "url": "https://github.com/google/ExoPlayer/commit/311d21bf8d2c53e05c4eaa502f2c1568a94af2f2",
    "details": {
      "sha": "73f68d12028e3bb6d26bfcc78af40f6a3b43ad20",
      "filename": "library/core/src/test/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManagerTest.java",
      "status": "modified",
      "additions": 25,
      "deletions": 76,
      "changes": 101,
      "blob_url": "https://github.com/google/ExoPlayer/blob/311d21bf8d2c53e05c4eaa502f2c1568a94af2f2/library%2Fcore%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fdrm%2FDefaultDrmSessionManagerTest.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/311d21bf8d2c53e05c4eaa502f2c1568a94af2f2/library%2Fcore%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fdrm%2FDefaultDrmSessionManagerTest.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fdrm%2FDefaultDrmSessionManagerTest.java?ref=311d21bf8d2c53e05c4eaa502f2c1568a94af2f2",
      "patch": "@@ -17,25 +17,17 @@\n \n import static com.google.common.truth.Truth.assertThat;\n \n-import android.os.Handler;\n-import android.os.HandlerThread;\n-import androidx.annotation.Nullable;\n+import android.os.Looper;\n import androidx.test.ext.junit.runners.AndroidJUnit4;\n-import com.google.android.exoplayer2.source.MediaSource;\n import com.google.android.exoplayer2.testutil.FakeExoMediaDrm;\n import com.google.android.exoplayer2.testutil.TestUtil;\n-import com.google.android.exoplayer2.util.ConditionVariable;\n-import com.google.android.exoplayer2.util.Function;\n-import com.google.android.exoplayer2.util.MediaSourceEventDispatcher;\n+import com.google.android.exoplayer2.util.Assertions;\n import com.google.android.exoplayer2.util.MimeTypes;\n import com.google.common.collect.ImmutableList;\n-import java.util.Map;\n import java.util.UUID;\n-import java.util.concurrent.atomic.AtomicReference;\n-import org.junit.After;\n-import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n+import org.robolectric.shadows.ShadowLooper;\n \n /** Tests for {@link DefaultDrmSessionManager} and {@link DefaultDrmSession}. */\n // TODO: Test more branches:\n@@ -46,8 +38,6 @@\n @RunWith(AndroidJUnit4.class)\n public class DefaultDrmSessionManagerTest {\n \n-  private static final int TIMEOUT_MS = 1_000;\n-\n   private static final UUID DRM_SCHEME_UUID =\n       UUID.nameUUIDFromBytes(TestUtil.createByteArray(7, 8, 9));\n   private static final ImmutableList<DrmInitData.SchemeData> DRM_SCHEME_DATAS =\n@@ -56,76 +46,35 @@ public class DefaultDrmSessionManagerTest {\n               DRM_SCHEME_UUID, MimeTypes.VIDEO_MP4, /* data= */ TestUtil.createByteArray(1, 2, 3)));\n   private static final DrmInitData DRM_INIT_DATA = new DrmInitData(DRM_SCHEME_DATAS);\n \n-  private HandlerThread playbackThread;\n-  private Handler playbackThreadHandler;\n-  private MediaSourceEventDispatcher eventDispatcher;\n-  private ConditionVariable keysLoaded;\n-\n-  @Before\n-  public void setUp() {\n-    playbackThread = new HandlerThread(\"Test playback thread\");\n-    playbackThread.start();\n-    playbackThreadHandler = new Handler(playbackThread.getLooper());\n-    eventDispatcher = new MediaSourceEventDispatcher();\n-    keysLoaded = TestUtil.createRobolectricConditionVariable();\n-    eventDispatcher.addEventListener(\n-        playbackThreadHandler,\n-        new DrmSessionEventListener() {\n-          @Override\n-          public void onDrmKeysLoaded(\n-              int windowIndex, @Nullable MediaSource.MediaPeriodId mediaPeriodId) {\n-            keysLoaded.open();\n-          }\n-        },\n-        DrmSessionEventListener.class);\n-  }\n-\n-  @After\n-  public void tearDown() {\n-    playbackThread.quitSafely();\n-  }\n-\n-  @Test\n+  @Test(timeout = 10_000)\n   public void acquireSessionTriggersKeyLoadAndSessionIsOpened() throws Exception {\n     FakeExoMediaDrm.LicenseServer licenseServer =\n         FakeExoMediaDrm.LicenseServer.allowingSchemeDatas(DRM_SCHEME_DATAS);\n \n-    keysLoaded.close();\n-    AtomicReference<DrmSession> drmSession = new AtomicReference<>();\n-    playbackThreadHandler.post(\n-        () -> {\n-          DefaultDrmSessionManager drmSessionManager =\n-              new DefaultDrmSessionManager.Builder()\n-                  .setUuidAndExoMediaDrmProvider(DRM_SCHEME_UUID, uuid -> new FakeExoMediaDrm())\n-                  .build(/* mediaDrmCallback= */ licenseServer);\n-\n-          drmSessionManager.prepare();\n-          drmSession.set(\n-              drmSessionManager.acquireSession(\n-                  playbackThread.getLooper(), eventDispatcher, DRM_INIT_DATA));\n-        });\n-\n-    keysLoaded.block(TIMEOUT_MS);\n+    DefaultDrmSessionManager drmSessionManager =\n+        new DefaultDrmSessionManager.Builder()\n+            .setUuidAndExoMediaDrmProvider(DRM_SCHEME_UUID, uuid -> new FakeExoMediaDrm())\n+            .build(/* mediaDrmCallback= */ licenseServer);\n+    drmSessionManager.prepare();\n+    DrmSession drmSession =\n+        drmSessionManager.acquireSession(\n+            /* playbackLooper= */ Assertions.checkNotNull(Looper.myLooper()),\n+            /* eventDispatcher= */ null,\n+            DRM_INIT_DATA);\n+    waitForOpenedWithKeys(drmSession);\n \n-    @DrmSession.State int state = post(drmSession.get(), DrmSession::getState);\n-    assertThat(state).isEqualTo(DrmSession.STATE_OPENED_WITH_KEYS);\n-    Map<String, String> keyStatus = post(drmSession.get(), DrmSession::queryKeyStatus);\n-    assertThat(keyStatus)\n+    assertThat(drmSession.getState()).isEqualTo(DrmSession.STATE_OPENED_WITH_KEYS);\n+    assertThat(drmSession.queryKeyStatus())\n         .containsExactly(FakeExoMediaDrm.KEY_STATUS_KEY, FakeExoMediaDrm.KEY_STATUS_AVAILABLE);\n   }\n \n-  /** Call a function on {@code drmSession} on the playback thread and return the result. */\n-  private <T> T post(DrmSession drmSession, Function<DrmSession, T> fn)\n-      throws InterruptedException {\n-    AtomicReference<T> result = new AtomicReference<>();\n-    ConditionVariable resultReady = TestUtil.createRobolectricConditionVariable();\n-    resultReady.close();\n-    playbackThreadHandler.post(\n-        () -> {\n-          result.set(fn.apply(drmSession));\n-          resultReady.open();\n-        });\n-    resultReady.block(TIMEOUT_MS);\n-    return result.get();\n+  private static void waitForOpenedWithKeys(DrmSession drmSession) {\n+    // Check the error first, so we get a meaningful failure if there's been an error.\n+    assertThat(drmSession.getError()).isNull();\n+    assertThat(drmSession.getState()).isEqualTo(DrmSession.STATE_OPENED);\n+    while (drmSession.getState() != DrmSession.STATE_OPENED_WITH_KEYS) {\n+      // Allow the key response to be handled.\n+      ShadowLooper.idleMainLooper();\n+    }\n   }\n }",
      "parent_sha": "314bc65d620521824f45c0bce4d1dcfcd4e50693"
    }
  },
  {
    "oid": "e56219f1f6ba4d3d3b7e579ba48c6a661761ee3f",
    "message": "Fix a mis-match in encoder priority.\n\nPiperOrigin-RevId: 460500666",
    "date": "2022-07-13T17:39:16Z",
    "url": "https://github.com/google/ExoPlayer/commit/e56219f1f6ba4d3d3b7e579ba48c6a661761ee3f",
    "details": {
      "sha": "475d491f92468018abff09381750614755e32f4e",
      "filename": "libraries/transformer/src/androidTest/java/androidx/media3/transformer/mh/analysis/EncoderPerformanceAnalysisTest.java",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/google/ExoPlayer/blob/e56219f1f6ba4d3d3b7e579ba48c6a661761ee3f/libraries%2Ftransformer%2Fsrc%2FandroidTest%2Fjava%2Fandroidx%2Fmedia3%2Ftransformer%2Fmh%2Fanalysis%2FEncoderPerformanceAnalysisTest.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/e56219f1f6ba4d3d3b7e579ba48c6a661761ee3f/libraries%2Ftransformer%2Fsrc%2FandroidTest%2Fjava%2Fandroidx%2Fmedia3%2Ftransformer%2Fmh%2Fanalysis%2FEncoderPerformanceAnalysisTest.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/libraries%2Ftransformer%2Fsrc%2FandroidTest%2Fjava%2Fandroidx%2Fmedia3%2Ftransformer%2Fmh%2Fanalysis%2FEncoderPerformanceAnalysisTest.java?ref=e56219f1f6ba4d3d3b7e579ba48c6a661761ee3f",
      "patch": "@@ -44,10 +44,12 @@\n @RunWith(Parameterized.class)\n public class EncoderPerformanceAnalysisTest {\n \n-  /** A non-realtime {@link MediaFormat#KEY_PRIORITY encoder priority}. */\n-  private static final int MEDIA_CODEC_PRIORITY_NON_REALTIME = 0;\n-  /** A realtime {@link MediaFormat#KEY_PRIORITY encoder priority}. */\n-  private static final int MEDIA_CODEC_PRIORITY_REALTIME = 1;\n+  /** A realtime {@linkplain MediaFormat#KEY_PRIORITY encoder priority}. */\n+  private static final int MEDIA_CODEC_PRIORITY_REALTIME = 0;\n+  /**\n+   * A non-realtime (as fast as possible) {@linkplain MediaFormat#KEY_PRIORITY encoder priority}.\n+   */\n+  private static final int MEDIA_CODEC_PRIORITY_NON_REALTIME = 1;\n \n   private static final ImmutableList<String> INPUT_FILES =\n       ImmutableList.of(",
      "parent_sha": "704aa2531adac1a73cc284baa1a2f5e22f0c2a0b"
    }
  },
  {
    "oid": "ac4a7e919a5a098a6657e9978ee75d9a533608ba",
    "message": "Remove ExoPlayer link from UI module\n\nPiperOrigin-RevId: 400706800",
    "date": "2021-10-04T14:37:48Z",
    "url": "https://github.com/google/ExoPlayer/commit/ac4a7e919a5a098a6657e9978ee75d9a533608ba",
    "details": {
      "sha": "a7c29321bea7c454e182d17cb16ffeda4872e9bb",
      "filename": "library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/google/ExoPlayer/blob/ac4a7e919a5a098a6657e9978ee75d9a533608ba/library%2Fui%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FPlayerNotificationManager.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/ac4a7e919a5a098a6657e9978ee75d9a533608ba/library%2Fui%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FPlayerNotificationManager.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fui%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FPlayerNotificationManager.java?ref=ac4a7e919a5a098a6657e9978ee75d9a533608ba",
      "patch": "@@ -54,7 +54,6 @@\n import com.google.android.exoplayer2.C;\n import com.google.android.exoplayer2.ControlDispatcher;\n import com.google.android.exoplayer2.DefaultControlDispatcher;\n-import com.google.android.exoplayer2.ExoPlayer;\n import com.google.android.exoplayer2.ForwardingPlayer;\n import com.google.android.exoplayer2.Player;\n import com.google.android.exoplayer2.util.NotificationUtil;\n@@ -820,7 +819,7 @@ public final void setPlayer(@Nullable Player player) {\n   /**\n    * @deprecated Use a {@link ForwardingPlayer} and pass it to {@link #setPlayer(Player)} instead.\n    *     You can also customize some operations when configuring the player (for example by using\n-   *     {@link ExoPlayer.Builder#setSeekBackIncrementMs(long)}), or configure whether the rewind\n+   *     {@code ExoPlayer.Builder.setSeekBackIncrementMs(long)}), or configure whether the rewind\n    *     and fast forward actions should be used with {{@link #setUseRewindAction(boolean)}} and\n    *     {@link #setUseFastForwardAction(boolean)}.\n    */",
      "parent_sha": "9788750ddb23b2064dddf99d6e1ea491b2e45cea"
    }
  },
  {
    "oid": "b6bd35860cda60f27439df737fdee815060ed6fe",
    "message": "Fix parameter comment block.\n\n#cleanup\n\nPiperOrigin-RevId: 481882181",
    "date": "2022-10-20T02:49:37Z",
    "url": "https://github.com/google/ExoPlayer/commit/b6bd35860cda60f27439df737fdee815060ed6fe",
    "details": {
      "sha": "e4f1123c70590e0c9de1ccd29538c7da257f2488",
      "filename": "library/transformer/src/main/java/com/google/android/exoplayer2/transformer/SpeedChangingAudioProcessor.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/ExoPlayer/blob/b6bd35860cda60f27439df737fdee815060ed6fe/library%2Ftransformer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftransformer%2FSpeedChangingAudioProcessor.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/b6bd35860cda60f27439df737fdee815060ed6fe/library%2Ftransformer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftransformer%2FSpeedChangingAudioProcessor.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Ftransformer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftransformer%2FSpeedChangingAudioProcessor.java?ref=b6bd35860cda60f27439df737fdee815060ed6fe",
      "patch": "@@ -105,7 +105,7 @@ public void queueInput(ByteBuffer inputBuffer) {\n         endOfStreamQueuedToSonic = true;\n       }\n     } else {\n-      ByteBuffer buffer = replaceOutputBuffer(/* count= */ inputBuffer.remaining());\n+      ByteBuffer buffer = replaceOutputBuffer(/* size= */ inputBuffer.remaining());\n       buffer.put(inputBuffer);\n       buffer.flip();\n     }",
      "parent_sha": "a5583c04bb6c199633e2b1edf036060c0d33b616"
    }
  },
  {
    "oid": "fc642eb45f6c997a2a501bcc3ea19043cd9911eb",
    "message": "Fix error in documentation string\n\nThe current javadoc refers to the SessionCallback#onConnected, which doesn't exist.\n\nPiperOrigin-RevId: 510261965",
    "date": "2023-02-17T11:55:35Z",
    "url": "https://github.com/google/ExoPlayer/commit/fc642eb45f6c997a2a501bcc3ea19043cd9911eb",
    "details": {
      "sha": "7fea6a0c81acebf51d25d792668987a642d5506f",
      "filename": "libraries/session/src/main/java/androidx/media3/session/MediaSession.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/ExoPlayer/blob/fc642eb45f6c997a2a501bcc3ea19043cd9911eb/libraries%2Fsession%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fsession%2FMediaSession.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/fc642eb45f6c997a2a501bcc3ea19043cd9911eb/libraries%2Fsession%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fsession%2FMediaSession.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/libraries%2Fsession%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fsession%2FMediaSession.java?ref=fc642eb45f6c997a2a501bcc3ea19043cd9911eb",
      "patch": "@@ -372,7 +372,7 @@ public static final class ControllerInfo {\n      * @param remoteUserInfo The remote user info.\n      * @param trusted {@code true} if trusted, {@code false} otherwise.\n      * @param cb ControllerCb. Can be {@code null} only when a MediaBrowserCompat connects to\n-     *     MediaSessionService and ControllerInfo is needed for SessionCallback#onConnected().\n+     *     MediaSessionService and ControllerInfo is needed for {@code SessionCallback#onConnect()}.\n      * @param connectionHints A session-specific argument sent from the controller for the\n      *     connection. The contents of this bundle may affect the connection result.\n      */",
      "parent_sha": "6711a59564b3d672b5fbce57d63e23704944cb07"
    }
  },
  {
    "oid": "1f11233ba022e00367ed32904092070d8c42f5ee",
    "message": "Support implicit i-Frame initialization segment.\n\nIn the HLS Spec (https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-04#section-4.4.3.6), specifically this or condition of this statement:\n\n\"... defined by the EXT-X-MAP tag, or is located between the start of the resource\n    and the offset of the first I-frame segment in that resource.\"\n\nChange adds code to add this \"implicit\" Media Initialization Segment if no EXT-X-MAP defines one explicitly.",
    "date": "2020-03-18T00:18:18Z",
    "url": "https://github.com/google/ExoPlayer/commit/1f11233ba022e00367ed32904092070d8c42f5ee",
    "details": {
      "sha": "d0521608713c561d92346fe21f993f21a94f34b0",
      "filename": "library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java",
      "status": "modified",
      "additions": 34,
      "deletions": 2,
      "changes": 36,
      "blob_url": "https://github.com/google/ExoPlayer/blob/1f11233ba022e00367ed32904092070d8c42f5ee/library%2Fhls%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fhls%2Fplaylist%2FHlsPlaylistParser.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/1f11233ba022e00367ed32904092070d8c42f5ee/library%2Fhls%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fhls%2Fplaylist%2FHlsPlaylistParser.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fhls%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fhls%2Fplaylist%2FHlsPlaylistParser.java?ref=1f11233ba022e00367ed32904092070d8c42f5ee",
      "patch": "@@ -70,6 +70,7 @@ public final class HlsPlaylistParser implements ParsingLoadable.Parser<HlsPlayli\n   private static final String TAG_DEFINE = \"#EXT-X-DEFINE\";\n   private static final String TAG_STREAM_INF = \"#EXT-X-STREAM-INF\";\n   private static final String TAG_STREAM_IFRAME = \"#EXT-X-I-FRAME-STREAM-INF\";\n+  private static final String TAG_IFRAME = \"#EXT-X-I-FRAMES-ONLY\";\n   private static final String TAG_MEDIA = \"#EXT-X-MEDIA\";\n   private static final String TAG_TARGET_DURATION = \"#EXT-X-TARGETDURATION\";\n   private static final String TAG_DISCONTINUITY = \"#EXT-X-DISCONTINUITY\";\n@@ -560,7 +561,7 @@ private static HlsMediaPlaylist parseMediaPlaylist(\n     long targetDurationUs = C.TIME_UNSET;\n     boolean hasIndependentSegmentsTag = masterPlaylist.hasIndependentSegments;\n     boolean hasEndTag = false;\n-    Segment initializationSegment = null;\n+    @Nullable Segment initializationSegment = null;\n     HashMap<String, String> variableDefinitions = new HashMap<>();\n     List<Segment> segments = new ArrayList<>();\n     List<String> tags = new ArrayList<>();\n@@ -574,6 +575,9 @@ private static HlsMediaPlaylist parseMediaPlaylist(\n     long segmentStartTimeUs = 0;\n     long segmentByteRangeOffset = 0;\n     long segmentByteRangeLength = C.LENGTH_UNSET;\n+    boolean isExplicitInitSegment = false;   // Was declared (TAG_INIT_SEGMENT) vs implied.\n+    boolean isIframeOnly = false;\n+\n     long segmentMediaSequence = 0;\n     boolean hasGapTag = false;\n \n@@ -625,6 +629,7 @@ private static HlsMediaPlaylist parseMediaPlaylist(\n                 segmentByteRangeLength,\n                 fullSegmentEncryptionKeyUri,\n                 fullSegmentEncryptionIV);\n+        isExplicitInitSegment = false;\n         segmentByteRangeOffset = 0;\n         segmentByteRangeLength = C.LENGTH_UNSET;\n       } else if (line.startsWith(TAG_TARGET_DURATION)) {\n@@ -706,6 +711,8 @@ private static HlsMediaPlaylist parseMediaPlaylist(\n         hasIndependentSegmentsTag = true;\n       } else if (line.equals(TAG_ENDLIST)) {\n         hasEndTag = true;\n+      } else if (line.equals(TAG_IFRAME)) {\n+        isIframeOnly = true;\n       } else if (!line.startsWith(\"#\")) {\n         String segmentEncryptionIV;\n         if (fullSegmentEncryptionKeyUri == null) {\n@@ -716,9 +723,34 @@ private static HlsMediaPlaylist parseMediaPlaylist(\n           segmentEncryptionIV = Long.toHexString(segmentMediaSequence);\n         }\n \n+        String segmentResourseUri = replaceVariableReferences(line, variableDefinitions);\n+\n         segmentMediaSequence++;\n         if (segmentByteRangeLength == C.LENGTH_UNSET) {\n           segmentByteRangeOffset = 0;\n+        } else if (isIframeOnly) {\n+          // If the I-Frame segment is byte-ranged then check if there is an initialization segment, if not,\n+          // per the spec (https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-04#section-4.4.3.6)\n+          // it is assumed to be \"located between the start of the resource and the offset of the\n+          // first I-frame segment\"\n+\n+          // Wipe previous implict init segment if base resource URI changes\n+          if (isExplicitInitSegment && initializationSegment != null) {\n+            if (! segmentResourseUri.equals(initializationSegment.url)) {\n+              initializationSegment = null;\n+            }\n+          }\n+\n+          if (initializationSegment == null) {\n+            isExplicitInitSegment = true;\n+            initializationSegment = new Segment(\n+                segmentResourseUri,\n+                0,\n+                segmentByteRangeOffset - 1,\n+                null,   // TODO encryption same as segment?\n+                null\n+            );\n+          }\n         }\n \n         if (cachedDrmInitData == null && !currentSchemeDatas.isEmpty()) {\n@@ -735,7 +767,7 @@ private static HlsMediaPlaylist parseMediaPlaylist(\n \n         segments.add(\n             new Segment(\n-                replaceVariableReferences(line, variableDefinitions),\n+                segmentResourseUri,\n                 initializationSegment,\n                 segmentTitle,\n                 segmentDurationUs,",
      "parent_sha": "64cd4383adceab12a5467869b78059f0935610d4"
    }
  },
  {
    "oid": "f56193bcd76f18c950f0c43c3abb7b9d91001a51",
    "message": "Change areSizeAndRateSupported to use PerfomancePoint.covers\n\nPiperOrigin-RevId: 482461219\n(cherry picked from commit b9c945459820ae264670aa2548fc747bb9402e97)",
    "date": "2022-10-20T12:20:14Z",
    "url": "https://github.com/google/ExoPlayer/commit/f56193bcd76f18c950f0c43c3abb7b9d91001a51",
    "details": {
      "sha": "72733a90e9ac6dac84c25c38b1c913d727e440b7",
      "filename": "libraries/exoplayer/src/main/java/androidx/media3/exoplayer/mediacodec/MediaCodecInfo.java",
      "status": "modified",
      "additions": 68,
      "deletions": 4,
      "changes": 72,
      "blob_url": "https://github.com/google/ExoPlayer/blob/f56193bcd76f18c950f0c43c3abb7b9d91001a51/libraries%2Fexoplayer%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fexoplayer%2Fmediacodec%2FMediaCodecInfo.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/f56193bcd76f18c950f0c43c3abb7b9d91001a51/libraries%2Fexoplayer%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fexoplayer%2Fmediacodec%2FMediaCodecInfo.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/libraries%2Fexoplayer%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fexoplayer%2Fmediacodec%2FMediaCodecInfo.java?ref=f56193bcd76f18c950f0c43c3abb7b9d91001a51",
      "patch": "@@ -28,14 +28,18 @@\n import static androidx.media3.exoplayer.DecoderReuseEvaluation.REUSE_RESULT_YES_WITHOUT_RECONFIGURATION;\n import static androidx.media3.exoplayer.DecoderReuseEvaluation.REUSE_RESULT_YES_WITH_FLUSH;\n import static androidx.media3.exoplayer.DecoderReuseEvaluation.REUSE_RESULT_YES_WITH_RECONFIGURATION;\n+import static java.lang.annotation.ElementType.TYPE_USE;\n \n import android.graphics.Point;\n import android.media.MediaCodec;\n import android.media.MediaCodecInfo.AudioCapabilities;\n import android.media.MediaCodecInfo.CodecCapabilities;\n import android.media.MediaCodecInfo.CodecProfileLevel;\n import android.media.MediaCodecInfo.VideoCapabilities;\n+import android.media.MediaCodecInfo.VideoCapabilities.PerformancePoint;\n import android.util.Pair;\n+import androidx.annotation.DoNotInline;\n+import androidx.annotation.IntDef;\n import androidx.annotation.Nullable;\n import androidx.annotation.RequiresApi;\n import androidx.annotation.VisibleForTesting;\n@@ -48,6 +52,11 @@\n import androidx.media3.exoplayer.DecoderReuseEvaluation;\n import androidx.media3.exoplayer.DecoderReuseEvaluation.DecoderDiscardReasons;\n import androidx.media3.exoplayer.DecoderReuseEvaluation.DecoderReuseResult;\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.util.List;\n \n /** Information about a {@link MediaCodec} for a given mime type. */\n @SuppressWarnings(\"InlinedApi\")\n@@ -482,8 +491,6 @@ public DecoderReuseEvaluation canReuseCodec(Format oldFormat, Format newFormat)\n   /**\n    * Whether the decoder supports video with a given width, height and frame rate.\n    *\n-   * <p>Must not be called if the device SDK version is less than 21.\n-   *\n    * @param width Width in pixels.\n    * @param height Height in pixels.\n    * @param frameRate Optional frame rate in frames per second. Ignored if set to {@link\n@@ -501,14 +508,28 @@ public boolean isVideoSizeAndRateSupportedV21(int width, int height, double fram\n       logNoSupport(\"sizeAndRate.vCaps\");\n       return false;\n     }\n+\n+    if (Util.SDK_INT >= 29) {\n+      @PerformancePointCoverageResult\n+      int evaluation =\n+          Api29.areResolutionAndFrameRateCovered(videoCapabilities, width, height, frameRate);\n+      if (evaluation == COVERAGE_RESULT_YES) {\n+        return true;\n+      } else if (evaluation == COVERAGE_RESULT_NO) {\n+        logNoSupport(\"sizeAndRate.cover, \" + width + \"x\" + height + \"@\" + frameRate);\n+        return false;\n+      }\n+      // COVERAGE_RESULT_NO_EMPTY_LIST falls through to API 21+ code below\n+    }\n+\n     if (!areSizeAndRateSupportedV21(videoCapabilities, width, height, frameRate)) {\n       if (width >= height\n           || !needsRotatedVerticalResolutionWorkaround(name)\n           || !areSizeAndRateSupportedV21(videoCapabilities, height, width, frameRate)) {\n-        logNoSupport(\"sizeAndRate.support, \" + width + \"x\" + height + \"x\" + frameRate);\n+        logNoSupport(\"sizeAndRate.support, \" + width + \"x\" + height + \"@\" + frameRate);\n         return false;\n       }\n-      logAssumedSupport(\"sizeAndRate.rotated, \" + width + \"x\" + height + \"x\" + frameRate);\n+      logAssumedSupport(\"sizeAndRate.rotated, \" + width + \"x\" + height + \"@\" + frameRate);\n     }\n     return true;\n   }\n@@ -844,4 +865,47 @@ private static boolean needsProfileExcludedWorkaround(String mimeType, int profi\n         && CodecProfileLevel.HEVCProfileMain10 == profile\n         && (\"sailfish\".equals(Util.DEVICE) || \"marlin\".equals(Util.DEVICE));\n   }\n+\n+  /** Possible outcomes of evaluating PerformancePoint coverage */\n+  @Documented\n+  @Retention(RetentionPolicy.SOURCE)\n+  @Target(TYPE_USE)\n+  @IntDef({COVERAGE_RESULT_YES, COVERAGE_RESULT_NO, COVERAGE_RESULT_NO_EMPTY_LIST})\n+  private @interface PerformancePointCoverageResult {}\n+\n+  /** The decoder has a PerformancePoint that covers the resolution and frame rate */\n+  private static final int COVERAGE_RESULT_YES = 2;\n+  /**\n+   * The decoder has at least one PerformancePoint, but none of them cover the resolution and frame\n+   * rate\n+   */\n+  private static final int COVERAGE_RESULT_NO = 1;\n+  /** The VideoCapabilities does not contain any PerformancePoints */\n+  private static final int COVERAGE_RESULT_NO_EMPTY_LIST = 0;\n+\n+  @RequiresApi(29)\n+  private static final class Api29 {\n+    @DoNotInline\n+    public static @PerformancePointCoverageResult int areResolutionAndFrameRateCovered(\n+        VideoCapabilities videoCapabilities, int width, int height, double frameRate) {\n+      List<PerformancePoint> performancePointList =\n+          videoCapabilities.getSupportedPerformancePoints();\n+      if (performancePointList == null || performancePointList.isEmpty()) {\n+        return COVERAGE_RESULT_NO_EMPTY_LIST;\n+      }\n+\n+      // Round frame rate down to to avoid situations where a range check in\n+      // covers fails due to slightly exceeding the limits for a standard format\n+      // (e.g., 1080p at 30 fps). [Internal ref: b/134706676]\n+      PerformancePoint targetPerformancePoint =\n+          new PerformancePoint(width, height, (int) frameRate);\n+\n+      for (int i = 0; i < performancePointList.size(); i++) {\n+        if (performancePointList.get(i).covers(targetPerformancePoint)) {\n+          return COVERAGE_RESULT_YES;\n+        }\n+      }\n+      return COVERAGE_RESULT_NO;\n+    }\n+  }\n }",
      "parent_sha": "f10021ff7f15a497063d991c5c100d4120106156"
    }
  },
  {
    "oid": "28434044122e8e408ee357c2dd0f63b1e10c1cdc",
    "message": "Move parseSelectionFlags with the rest of the parse{attribute} methods\n\nPiperOrigin-RevId: 230734189",
    "date": "2019-01-30T19:06:48Z",
    "url": "https://github.com/google/ExoPlayer/commit/28434044122e8e408ee357c2dd0f63b1e10c1cdc",
    "details": {
      "sha": "7dba626e70326e040a4ae927c119a3f6a8a0bd5b",
      "filename": "library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/google/ExoPlayer/blob/28434044122e8e408ee357c2dd0f63b1e10c1cdc/library%2Fhls%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fhls%2Fplaylist%2FHlsPlaylistParser.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/28434044122e8e408ee357c2dd0f63b1e10c1cdc/library%2Fhls%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fhls%2Fplaylist%2FHlsPlaylistParser.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fhls%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fhls%2Fplaylist%2FHlsPlaylistParser.java?ref=28434044122e8e408ee357c2dd0f63b1e10c1cdc",
      "patch": "@@ -426,21 +426,6 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri\n         variableDefinitions);\n   }\n \n-  @C.SelectionFlags\n-  private static int parseSelectionFlags(String line) {\n-    int flags = 0;\n-    if (parseOptionalBooleanAttribute(line, REGEX_DEFAULT, false)) {\n-      flags |= C.SELECTION_FLAG_DEFAULT;\n-    }\n-    if (parseOptionalBooleanAttribute(line, REGEX_FORCED, false)) {\n-      flags |= C.SELECTION_FLAG_FORCED;\n-    }\n-    if (parseOptionalBooleanAttribute(line, REGEX_AUTOSELECT, false)) {\n-      flags |= C.SELECTION_FLAG_AUTOSELECT;\n-    }\n-    return flags;\n-  }\n-\n   private static HlsMediaPlaylist parseMediaPlaylist(\n       HlsMasterPlaylist masterPlaylist, LineIterator iterator, String baseUri) throws IOException {\n     @HlsMediaPlaylist.PlaylistType int playlistType = HlsMediaPlaylist.PLAYLIST_TYPE_UNKNOWN;\n@@ -661,6 +646,21 @@ private static HlsMediaPlaylist parseMediaPlaylist(\n         segments);\n   }\n \n+  @C.SelectionFlags\n+  private static int parseSelectionFlags(String line) {\n+    int flags = 0;\n+    if (parseOptionalBooleanAttribute(line, REGEX_DEFAULT, false)) {\n+      flags |= C.SELECTION_FLAG_DEFAULT;\n+    }\n+    if (parseOptionalBooleanAttribute(line, REGEX_FORCED, false)) {\n+      flags |= C.SELECTION_FLAG_FORCED;\n+    }\n+    if (parseOptionalBooleanAttribute(line, REGEX_AUTOSELECT, false)) {\n+      flags |= C.SELECTION_FLAG_AUTOSELECT;\n+    }\n+    return flags;\n+  }\n+\n   private static @Nullable SchemeData parsePlayReadySchemeData(\n       String line, Map<String, String> variableDefinitions) throws ParserException {\n     String keyFormatVersions =",
      "parent_sha": "1c4ea26ff0ff530a1282398377a2cddfceefc3f6"
    }
  },
  {
    "oid": "f75710be933aca23f24c5b6d8f2f1925ba1da543",
    "message": "Fix typo in AdvancedFrameProcessorTest.\n\nPiperOrigin-RevId: 439599201",
    "date": "2022-04-06T11:00:19Z",
    "url": "https://github.com/google/ExoPlayer/commit/f75710be933aca23f24c5b6d8f2f1925ba1da543",
    "details": {
      "sha": "c7e9f9b2b16fd24723d698ecffa0b0af3256c620",
      "filename": "libraries/transformer/src/test/java/androidx/media3/transformer/AdvancedFrameProcessorTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/ExoPlayer/blob/f75710be933aca23f24c5b6d8f2f1925ba1da543/libraries%2Ftransformer%2Fsrc%2Ftest%2Fjava%2Fandroidx%2Fmedia3%2Ftransformer%2FAdvancedFrameProcessorTest.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/f75710be933aca23f24c5b6d8f2f1925ba1da543/libraries%2Ftransformer%2Fsrc%2Ftest%2Fjava%2Fandroidx%2Fmedia3%2Ftransformer%2FAdvancedFrameProcessorTest.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/libraries%2Ftransformer%2Fsrc%2Ftest%2Fjava%2Fandroidx%2Fmedia3%2Ftransformer%2FAdvancedFrameProcessorTest.java?ref=f75710be933aca23f24c5b6d8f2f1925ba1da543",
      "patch": "@@ -39,7 +39,7 @@ public void construct_withInvalidMatrixSize_throwsException() {\n   }\n \n   @Test\n-  public void construct_withValidMatrixSize_completesSucessfully() {\n+  public void construct_withValidMatrixSize_completesSuccessfully() {\n     new AdvancedFrameProcessor(getApplicationContext(), new float[16]);\n   }\n }",
      "parent_sha": "296efbb395ca218ee941210c7ebf9710e2bd9e26"
    }
  },
  {
    "oid": "3ad1b954604bb83c32fd39c451a0ff28832cbb35",
    "message": "Enable nullness checking for BaseRenderer\n\n#exofixit\n\nPiperOrigin-RevId: 322567104",
    "date": "2020-07-24T09:45:43Z",
    "url": "https://github.com/google/ExoPlayer/commit/3ad1b954604bb83c32fd39c451a0ff28832cbb35",
    "details": {
      "sha": "902350e9002f0db27b5369ddf637897acbb16eee",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java",
      "status": "modified",
      "additions": 29,
      "deletions": 11,
      "changes": 40,
      "blob_url": "https://github.com/google/ExoPlayer/blob/3ad1b954604bb83c32fd39c451a0ff28832cbb35/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FBaseRenderer.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/3ad1b954604bb83c32fd39c451a0ff28832cbb35/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FBaseRenderer.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FBaseRenderer.java?ref=3ad1b954604bb83c32fd39c451a0ff28832cbb35",
      "patch": "@@ -30,11 +30,11 @@ public abstract class BaseRenderer implements Renderer, RendererCapabilities {\n   private final int trackType;\n   private final FormatHolder formatHolder;\n \n-  private RendererConfiguration configuration;\n+  @Nullable private RendererConfiguration configuration;\n   private int index;\n   private int state;\n-  private SampleStream stream;\n-  private Format[] streamFormats;\n+  @Nullable private SampleStream stream;\n+  @Nullable private Format[] streamFormats;\n   private long streamOffsetUs;\n   private long lastResetPositionUs;\n   private long readingPositionUs;\n@@ -144,7 +144,7 @@ public final boolean isCurrentStreamFinal() {\n \n   @Override\n   public final void maybeThrowStreamError() throws IOException {\n-    stream.maybeThrowError();\n+    Assertions.checkNotNull(stream).maybeThrowError();\n   }\n \n   @Override\n@@ -303,16 +303,24 @@ protected final FormatHolder getFormatHolder() {\n     return formatHolder;\n   }\n \n-  /** Returns the formats of the currently enabled stream. */\n+  /**\n+   * Returns the formats of the currently enabled stream.\n+   *\n+   * <p>This method may be called when the renderer is in the following states: {@link\n+   * #STATE_ENABLED}, {@link #STATE_STARTED}.\n+   */\n   protected final Format[] getStreamFormats() {\n-    return streamFormats;\n+    return Assertions.checkNotNull(streamFormats);\n   }\n \n   /**\n    * Returns the configuration set when the renderer was most recently enabled.\n+   *\n+   * <p>This method may be called when the renderer is in the following states: {@link\n+   * #STATE_ENABLED}, {@link #STATE_STARTED}.\n    */\n   protected final RendererConfiguration getConfiguration() {\n-    return configuration;\n+    return Assertions.checkNotNull(configuration);\n   }\n \n   /**\n@@ -352,6 +360,9 @@ protected final ExoPlaybackException createRendererException(\n    * {@link C#RESULT_BUFFER_READ} is only returned if {@link #setCurrentStreamFinal()} has been\n    * called. {@link C#RESULT_NOTHING_READ} is returned otherwise.\n    *\n+   * <p>This method may be called when the renderer is in the following states: {@link\n+   * #STATE_ENABLED}, {@link #STATE_STARTED}.\n+   *\n    * @param formatHolder A {@link FormatHolder} to populate in the case of reading a format.\n    * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or the\n    *     end of the stream. If the end of the stream has been reached, the {@link\n@@ -364,7 +375,8 @@ protected final ExoPlaybackException createRendererException(\n   @SampleStream.ReadDataResult\n   protected final int readSource(\n       FormatHolder formatHolder, DecoderInputBuffer buffer, boolean formatRequired) {\n-    @SampleStream.ReadDataResult int result = stream.readData(formatHolder, buffer, formatRequired);\n+    @SampleStream.ReadDataResult\n+    int result = Assertions.checkNotNull(stream).readData(formatHolder, buffer, formatRequired);\n     if (result == C.RESULT_BUFFER_READ) {\n       if (buffer.isEndOfStream()) {\n         readingPositionUs = C.TIME_END_OF_SOURCE;\n@@ -373,7 +385,7 @@ protected final int readSource(\n       buffer.timeUs += streamOffsetUs;\n       readingPositionUs = Math.max(readingPositionUs, buffer.timeUs);\n     } else if (result == C.RESULT_FORMAT_READ) {\n-      Format format = formatHolder.format;\n+      Format format = Assertions.checkNotNull(formatHolder.format);\n       if (format.subsampleOffsetUs != Format.OFFSET_SAMPLE_RELATIVE) {\n         format =\n             format\n@@ -390,17 +402,23 @@ protected final int readSource(\n    * Attempts to skip to the keyframe before the specified position, or to the end of the stream if\n    * {@code positionUs} is beyond it.\n    *\n+   * <p>This method may be called when the renderer is in the following states: {@link\n+   * #STATE_ENABLED}, {@link #STATE_STARTED}.\n+   *\n    * @param positionUs The position in microseconds.\n    * @return The number of samples that were skipped.\n    */\n   protected int skipSource(long positionUs) {\n-    return stream.skipData(positionUs - streamOffsetUs);\n+    return Assertions.checkNotNull(stream).skipData(positionUs - streamOffsetUs);\n   }\n \n   /**\n    * Returns whether the upstream source is ready.\n+   *\n+   * <p>This method may be called when the renderer is in the following states: {@link\n+   * #STATE_ENABLED}, {@link #STATE_STARTED}.\n    */\n   protected final boolean isSourceReady() {\n-    return hasReadStreamToEnd() ? streamIsFinal : stream.isReady();\n+    return hasReadStreamToEnd() ? streamIsFinal : Assertions.checkNotNull(stream).isReady();\n   }\n }",
      "parent_sha": "6e751c35c78af953a441a30d0c6a28024ec77e45"
    }
  },
  {
    "oid": "958f12e2cc9526f52240fca91cedbbc2b8dd8f58",
    "message": "Make isReady of FakeRenderer more realistic.\n\nCurrently the renderer is only ready when the input stream has more data to\nread. Actual renderers, however, are also ready as long as their output buffer\ncontains some audio/video samples to play, roughly corresponding to the fact\nthat the playback time hasn't reached the timestamp of the last buffered\nsample. Added a isready flag to FakeRenderer to simulate this behaviour.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=162343074",
    "date": "2017-07-19T13:04:58Z",
    "url": "https://github.com/google/ExoPlayer/commit/958f12e2cc9526f52240fca91cedbbc2b8dd8f58",
    "details": {
      "sha": "a66043b77ff79e929d5fa8c80ddea2b1fccd4111",
      "filename": "testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeRenderer.java",
      "status": "modified",
      "additions": 19,
      "deletions": 19,
      "changes": 38,
      "blob_url": "https://github.com/google/ExoPlayer/blob/958f12e2cc9526f52240fca91cedbbc2b8dd8f58/testutils%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftestutil%2FFakeRenderer.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/958f12e2cc9526f52240fca91cedbbc2b8dd8f58/testutils%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftestutil%2FFakeRenderer.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/testutils%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftestutil%2FFakeRenderer.java?ref=958f12e2cc9526f52240fca91cedbbc2b8dd8f58",
      "patch": "@@ -35,16 +35,19 @@\n public class FakeRenderer extends BaseRenderer {\n \n   private final List<Format> expectedFormats;\n+  private final DecoderInputBuffer buffer;\n \n   public int positionResetCount;\n   public int formatReadCount;\n   public int bufferReadCount;\n   public boolean isEnded;\n+  public boolean isReady;\n \n   public FakeRenderer(Format... expectedFormats) {\n     super(expectedFormats.length == 0 ? C.TRACK_TYPE_UNKNOWN\n         : MimeTypes.getTrackType(expectedFormats[0].sampleMimeType));\n     this.expectedFormats = Collections.unmodifiableList(Arrays.asList(expectedFormats));\n+    this.buffer = new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_NORMAL);\n   }\n \n   @Override\n@@ -55,29 +58,26 @@ protected void onPositionReset(long positionUs, boolean joining) throws ExoPlayb\n \n   @Override\n   public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {\n-    if (isEnded) {\n-      return;\n-    }\n-\n-    // Verify the format matches the expected format.\n-    FormatHolder formatHolder = new FormatHolder();\n-    DecoderInputBuffer buffer =\n-        new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_NORMAL);\n-    int result = readSource(formatHolder, buffer, false);\n-    if (result == C.RESULT_FORMAT_READ) {\n-      formatReadCount++;\n-      Assert.assertTrue(expectedFormats.contains(formatHolder.format));\n-    } else if (result == C.RESULT_BUFFER_READ) {\n-      bufferReadCount++;\n-      if (buffer.isEndOfStream()) {\n-        isEnded = true;\n+    if (!isEnded) {\n+      // Verify the format matches the expected format.\n+      FormatHolder formatHolder = new FormatHolder();\n+      int result = readSource(formatHolder, buffer, false);\n+      if (result == C.RESULT_FORMAT_READ) {\n+        formatReadCount++;\n+        Assert.assertTrue(expectedFormats.contains(formatHolder.format));\n+      } else if (result == C.RESULT_BUFFER_READ) {\n+        bufferReadCount++;\n+        if (buffer.isEndOfStream()) {\n+          isEnded = true;\n+        }\n       }\n     }\n+    isReady = buffer.timeUs >= positionUs;\n   }\n \n   @Override\n   public boolean isReady() {\n-    return isSourceReady();\n+    return isReady || isSourceReady();\n   }\n \n   @Override\n@@ -87,8 +87,8 @@ public boolean isEnded() {\n \n   @Override\n   public int supportsFormat(Format format) throws ExoPlaybackException {\n-    return getTrackType() == MimeTypes.getTrackType(format.sampleMimeType) ? FORMAT_HANDLED\n-        : FORMAT_UNSUPPORTED_TYPE;\n+    return getTrackType() == MimeTypes.getTrackType(format.sampleMimeType)\n+        ? (FORMAT_HANDLED | ADAPTIVE_SEAMLESS) : FORMAT_UNSUPPORTED_TYPE;\n   }\n \n }",
      "parent_sha": "4fd516e35bef3f3e7d34a81adaf466f0758fc420"
    }
  },
  {
    "oid": "819ebf703abb61b1ac3f4a60359a45266ac49cb4",
    "message": "Assign track type TEXT for CEA708\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=137011920",
    "date": "2016-10-24T17:42:02Z",
    "url": "https://github.com/google/ExoPlayer/commit/819ebf703abb61b1ac3f4a60359a45266ac49cb4",
    "details": {
      "sha": "e289a5bac1fe1d56e06abdbd4758cc09a7764fcb",
      "filename": "library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/google/ExoPlayer/blob/819ebf703abb61b1ac3f4a60359a45266ac49cb4/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Futil%2FMimeTypes.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/819ebf703abb61b1ac3f4a60359a45266ac49cb4/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Futil%2FMimeTypes.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Futil%2FMimeTypes.java?ref=819ebf703abb61b1ac3f4a60359a45266ac49cb4",
      "patch": "@@ -211,10 +211,10 @@ public static int getTrackType(String mimeType) {\n     } else if (isVideo(mimeType)) {\n       return C.TRACK_TYPE_VIDEO;\n     } else if (isText(mimeType) || APPLICATION_CEA608.equals(mimeType)\n-        || APPLICATION_SUBRIP.equals(mimeType) || APPLICATION_TTML.equals(mimeType)\n-        || APPLICATION_TX3G.equals(mimeType) || APPLICATION_MP4VTT.equals(mimeType)\n-        || APPLICATION_RAWCC.equals(mimeType) || APPLICATION_VOBSUB.equals(mimeType)\n-        || APPLICATION_PGS.equals(mimeType)) {\n+        || APPLICATION_CEA708.equals(mimeType) || APPLICATION_SUBRIP.equals(mimeType)\n+        || APPLICATION_TTML.equals(mimeType) || APPLICATION_TX3G.equals(mimeType)\n+        || APPLICATION_MP4VTT.equals(mimeType) || APPLICATION_RAWCC.equals(mimeType)\n+        || APPLICATION_VOBSUB.equals(mimeType) || APPLICATION_PGS.equals(mimeType)) {\n       return C.TRACK_TYPE_TEXT;\n     } else if (APPLICATION_ID3.equals(mimeType)) {\n       return C.TRACK_TYPE_METADATA;",
      "parent_sha": "6e69b985175afcc692ae4b4f1ed89ab3f993712c"
    }
  },
  {
    "oid": "53eae50c0c44b4d4871c67352c290db66fb2b5d6",
    "message": "Simplify buffer resizing in Sonic\n\nThis is in preparation for making it possible to flush a Sonic instance so that\nit's not necessary to create new ones every time the processor is flushed.\n\nThere should be no behavior changes here.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=191410326",
    "date": "2018-04-03T14:32:20Z",
    "url": "https://github.com/google/ExoPlayer/commit/53eae50c0c44b4d4871c67352c290db66fb2b5d6",
    "details": {
      "sha": "f9bf583a80b1a959ac6cb0eb23252d350f9115b1",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/audio/Sonic.java",
      "status": "modified",
      "additions": 36,
      "deletions": 36,
      "changes": 72,
      "blob_url": "https://github.com/google/ExoPlayer/blob/53eae50c0c44b4d4871c67352c290db66fb2b5d6/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Faudio%2FSonic.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/53eae50c0c44b4d4871c67352c290db66fb2b5d6/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Faudio%2FSonic.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Faudio%2FSonic.java?ref=53eae50c0c44b4d4871c67352c290db66fb2b5d6",
      "patch": "@@ -41,17 +41,14 @@\n   private final int maxRequiredFrameCount;\n   private final short[] downSampleBuffer;\n \n-  private int inputBufferSizeFrames;\n   private short[] inputBuffer;\n-  private int outputBufferSize;\n+  private int inputFrameCount;\n   private short[] outputBuffer;\n-  private int pitchBufferSize;\n+  private int outputFrameCount;\n   private short[] pitchBuffer;\n+  private int pitchFrameCount;\n   private int oldRatePosition;\n   private int newRatePosition;\n-  private int inputFrameCount;\n-  private int outputFrameCount;\n-  private int pitchFrameCount;\n   private int remainingInputToCopyFrameCount;\n   private int prevPeriod;\n   private int prevMinDiff;\n@@ -71,22 +68,16 @@ public Sonic(\n       int inputSampleRateHz, int channelCount, float speed, float pitch, int outputSampleRateHz) {\n     this.inputSampleRateHz = inputSampleRateHz;\n     this.channelCount = channelCount;\n+    this.speed = speed;\n+    this.pitch = pitch;\n+    rate = (float) inputSampleRateHz / outputSampleRateHz;\n     minPeriod = inputSampleRateHz / MAXIMUM_PITCH;\n     maxPeriod = inputSampleRateHz / MINIMUM_PITCH;\n     maxRequiredFrameCount = 2 * maxPeriod;\n     downSampleBuffer = new short[maxRequiredFrameCount];\n-    inputBufferSizeFrames = maxRequiredFrameCount;\n     inputBuffer = new short[maxRequiredFrameCount * channelCount];\n-    outputBufferSize = maxRequiredFrameCount;\n     outputBuffer = new short[maxRequiredFrameCount * channelCount];\n-    pitchBufferSize = maxRequiredFrameCount;\n     pitchBuffer = new short[maxRequiredFrameCount * channelCount];\n-    oldRatePosition = 0;\n-    newRatePosition = 0;\n-    prevPeriod = 0;\n-    this.speed = speed;\n-    this.pitch = pitch;\n-    this.rate = (float) inputSampleRateHz / outputSampleRateHz;\n   }\n \n   /**\n@@ -98,7 +89,7 @@ public Sonic(\n   public void queueInput(ShortBuffer buffer) {\n     int framesToWrite = buffer.remaining() / channelCount;\n     int bytesToWrite = framesToWrite * channelCount * 2;\n-    enlargeInputBufferIfNeeded(framesToWrite);\n+    inputBuffer = ensureSpaceForAdditionalFrames(inputBuffer, inputFrameCount, framesToWrite);\n     buffer.get(inputBuffer, inputFrameCount * channelCount, bytesToWrite / 2);\n     inputFrameCount += framesToWrite;\n     processStreamInput();\n@@ -134,7 +125,9 @@ public void queueEndOfStream() {\n         outputFrameCount + (int) ((remainingFrameCount / s + pitchFrameCount) / r + 0.5f);\n \n     // Add enough silence to flush both input and pitch buffers.\n-    enlargeInputBufferIfNeeded(remainingFrameCount + 2 * maxRequiredFrameCount);\n+    inputBuffer =\n+        ensureSpaceForAdditionalFrames(\n+            inputBuffer, inputFrameCount, remainingFrameCount + 2 * maxRequiredFrameCount);\n     for (int xSample = 0; xSample < 2 * maxRequiredFrameCount * channelCount; xSample++) {\n       inputBuffer[remainingFrameCount * channelCount + xSample] = 0;\n     }\n@@ -157,17 +150,24 @@ public int getFramesAvailable() {\n \n   // Internal methods.\n \n-  private void enlargeOutputBufferIfNeeded(int frameCount) {\n-    if (outputFrameCount + frameCount > outputBufferSize) {\n-      outputBufferSize += (outputBufferSize / 2) + frameCount;\n-      outputBuffer = Arrays.copyOf(outputBuffer, outputBufferSize * channelCount);\n-    }\n-  }\n-\n-  private void enlargeInputBufferIfNeeded(int frameCount) {\n-    if (inputFrameCount + frameCount > inputBufferSizeFrames) {\n-      inputBufferSizeFrames += (inputBufferSizeFrames / 2) + frameCount;\n-      inputBuffer = Arrays.copyOf(inputBuffer, inputBufferSizeFrames * channelCount);\n+  /**\n+   * Returns {@code buffer} or a copy of it, such that there is enough space in the returned buffer\n+   * to store {@code newFrameCount} additional frames.\n+   *\n+   * @param buffer The buffer.\n+   * @param frameCount The number of frames already in the buffer.\n+   * @param additionalFrameCount The number of additional frames that need to be stored in the\n+   *     buffer.\n+   * @return A buffer with enough space for the additional frames.\n+   */\n+  private short[] ensureSpaceForAdditionalFrames(\n+      short[] buffer, int frameCount, int additionalFrameCount) {\n+    int currentCapacityFrames = buffer.length / channelCount;\n+    if (frameCount + additionalFrameCount <= currentCapacityFrames) {\n+      return buffer;\n+    } else {\n+      int newCapacityFrames = 3 * currentCapacityFrames / 2 + additionalFrameCount;\n+      return Arrays.copyOf(buffer, newCapacityFrames * channelCount);\n     }\n   }\n \n@@ -179,7 +179,7 @@ private void removeProcessedInputFrames(int positionFrames) {\n   }\n \n   private void copyToOutput(short[] samples, int positionFrames, int frameCount) {\n-    enlargeOutputBufferIfNeeded(frameCount);\n+    outputBuffer = ensureSpaceForAdditionalFrames(outputBuffer, outputFrameCount, frameCount);\n     System.arraycopy(\n         samples,\n         positionFrames * channelCount,\n@@ -306,10 +306,7 @@ private int findPitchPeriod(short[] samples, int position) {\n \n   private void moveNewSamplesToPitchBuffer(int originalOutputFrameCount) {\n     int frameCount = outputFrameCount - originalOutputFrameCount;\n-    if (pitchFrameCount + frameCount > pitchBufferSize) {\n-      pitchBufferSize += (pitchBufferSize / 2) + frameCount;\n-      pitchBuffer = Arrays.copyOf(pitchBuffer, pitchBufferSize * channelCount);\n-    }\n+    pitchBuffer = ensureSpaceForAdditionalFrames(pitchBuffer, pitchFrameCount, frameCount);\n     System.arraycopy(\n         outputBuffer,\n         originalOutputFrameCount * channelCount,\n@@ -359,7 +356,9 @@ private void adjustRate(float rate, int originalOutputFrameCount) {\n     // Leave at least one pitch sample in the buffer.\n     for (int position = 0; position < pitchFrameCount - 1; position++) {\n       while ((oldRatePosition + 1) * newSampleRate > newRatePosition * oldSampleRate) {\n-        enlargeOutputBufferIfNeeded(1);\n+        outputBuffer =\n+            ensureSpaceForAdditionalFrames(\n+                outputBuffer, outputFrameCount, /* additionalFrameCount= */ 1);\n         for (int i = 0; i < channelCount; i++) {\n           outputBuffer[outputFrameCount * channelCount + i] =\n               interpolate(pitchBuffer, position * channelCount + i, oldSampleRate, newSampleRate);\n@@ -386,7 +385,7 @@ private int skipPitchPeriod(short[] samples, int position, float speed, int peri\n       newFrameCount = period;\n       remainingInputToCopyFrameCount = (int) (period * (2.0f - speed) / (speed - 1.0f));\n     }\n-    enlargeOutputBufferIfNeeded(newFrameCount);\n+    outputBuffer = ensureSpaceForAdditionalFrames(outputBuffer, outputFrameCount, newFrameCount);\n     overlapAdd(\n         newFrameCount,\n         channelCount,\n@@ -409,7 +408,8 @@ private int insertPitchPeriod(short[] samples, int position, float speed, int pe\n       newFrameCount = period;\n       remainingInputToCopyFrameCount = (int) (period * (2.0f * speed - 1.0f) / (1.0f - speed));\n     }\n-    enlargeOutputBufferIfNeeded(period + newFrameCount);\n+    outputBuffer =\n+        ensureSpaceForAdditionalFrames(outputBuffer, outputFrameCount, period + newFrameCount);\n     System.arraycopy(\n         samples,\n         position * channelCount,",
      "parent_sha": "8b5a34769f74a7c8d22985d9b92bb5c9ab1e748a"
    }
  },
  {
    "oid": "658e0e17b844837f9aeb43e6a4ee5945aa686bcb",
    "message": "Make SubtitleWebView 'invisible' to touch  events\n\nWithout this, tapping the main video playback doesn't bring up the\ncontrols.\n\nPiperOrigin-RevId: 291943063",
    "date": "2020-01-30T19:29:29Z",
    "url": "https://github.com/google/ExoPlayer/commit/658e0e17b844837f9aeb43e6a4ee5945aa686bcb",
    "details": {
      "sha": "7fa6e4165ab145818b7cedaaef11507eed713e9d",
      "filename": "library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleWebView.java",
      "status": "modified",
      "additions": 17,
      "deletions": 1,
      "changes": 18,
      "blob_url": "https://github.com/google/ExoPlayer/blob/658e0e17b844837f9aeb43e6a4ee5945aa686bcb/library%2Fui%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FSubtitleWebView.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/658e0e17b844837f9aeb43e6a4ee5945aa686bcb/library%2Fui%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FSubtitleWebView.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fui%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fui%2FSubtitleWebView.java?ref=658e0e17b844837f9aeb43e6a4ee5945aa686bcb",
      "patch": "@@ -22,6 +22,7 @@\n import android.content.Context;\n import android.graphics.Color;\n import android.util.AttributeSet;\n+import android.view.MotionEvent;\n import android.view.ViewGroup;\n import android.webkit.WebView;\n import androidx.annotation.Nullable;\n@@ -65,7 +66,22 @@ public SubtitleWebView(Context context, @Nullable AttributeSet attrs) {\n     style = CaptionStyleCompat.DEFAULT;\n     bottomPaddingFraction = DEFAULT_BOTTOM_PADDING_FRACTION;\n \n-    webView = new WebView(context, attrs);\n+    webView =\n+        new WebView(context, attrs) {\n+          @Override\n+          public boolean onTouchEvent(MotionEvent event) {\n+            super.onTouchEvent(event);\n+            // Return false so that touch events are allowed down into @id/exo_content_frame below.\n+            return false;\n+          }\n+\n+          @Override\n+          public boolean performClick() {\n+            super.performClick();\n+            // Return false so that clicks are allowed down into @id/exo_content_frame below.\n+            return false;\n+          }\n+        };\n     webView.setBackgroundColor(Color.TRANSPARENT);\n     addView(webView);\n   }",
      "parent_sha": "e92ea31fcd19800c061f790cce37128b3fd754fd"
    }
  },
  {
    "oid": "62e3ac3e9ed96c5b76efe6a78b0bc905a565f3be",
    "message": "Update parseStbl to handle edit lists & gapless info\n\nWithout this, a subtitle track empty edit list used to offset the start of\nsubtitles is ignored.\n\nAlso the current code seems to depend on the order in which\nwe parse the tracks (audio first means we have gapless info when we parse\nvideo track, while video first we wouldn't).\n\nIt's not clear why we can't handle both edit lists & gapless info\n\nPiperOrigin-RevId: 276029744",
    "date": "2019-10-30T08:48:00Z",
    "url": "https://github.com/google/ExoPlayer/commit/62e3ac3e9ed96c5b76efe6a78b0bc905a565f3be",
    "details": {
      "sha": "e06a3278f0a19b125cfb9cf0b3e7fb7dda92b1b3",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/google/ExoPlayer/blob/62e3ac3e9ed96c5b76efe6a78b0bc905a565f3be/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2Fmp4%2FAtomParsers.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/62e3ac3e9ed96c5b76efe6a78b0bc905a565f3be/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2Fmp4%2FAtomParsers.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2Fmp4%2FAtomParsers.java?ref=62e3ac3e9ed96c5b76efe6a78b0bc905a565f3be",
      "patch": "@@ -363,9 +363,7 @@ public static TrackSampleTable parseStbl(\n     }\n     long durationUs = Util.scaleLargeTimestamp(duration, C.MICROS_PER_SECOND, track.timescale);\n \n-    if (track.editListDurations == null || gaplessInfoHolder.hasGaplessInfo()) {\n-      // There is no edit list, or we are ignoring it as we already have gapless metadata to apply.\n-      // This implementation does not support applying both gapless metadata and an edit list.\n+    if (track.editListDurations == null) {\n       Util.scaleLargeTimestampsInPlace(timestamps, C.MICROS_PER_SECOND, track.timescale);\n       return new TrackSampleTable(\n           track, offsets, sizes, maximumSize, timestamps, flags, durationUs);",
      "parent_sha": "51e4f7b260a0eb77dec7abc830f216f582cb674e"
    }
  },
  {
    "oid": "9ac7f64c8448551e5a5c3d69b40bb2d9e13c90f2",
    "message": "Fix search to end of stream in HLS\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=139905590",
    "date": "2016-11-25T20:18:32Z",
    "url": "https://github.com/google/ExoPlayer/commit/9ac7f64c8448551e5a5c3d69b40bb2d9e13c90f2",
    "details": {
      "sha": "6a90c8836f8b53d9686aee0559550030d7217153",
      "filename": "library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/ExoPlayer/blob/9ac7f64c8448551e5a5c3d69b40bb2d9e13c90f2/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fhls%2FHlsChunkSource.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/9ac7f64c8448551e5a5c3d69b40bb2d9e13c90f2/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fhls%2FHlsChunkSource.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2Fhls%2FHlsChunkSource.java?ref=9ac7f64c8448551e5a5c3d69b40bb2d9e13c90f2",
      "patch": "@@ -215,7 +215,7 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu\n     int chunkMediaSequence;\n     if (previous == null || switchingVariant) {\n       long targetPositionUs = previous == null ? playbackPositionUs : previous.startTimeUs;\n-      if (targetPositionUs > mediaPlaylist.getEndTimeUs()) {\n+      if (!mediaPlaylist.hasEndTag && targetPositionUs > mediaPlaylist.getEndTimeUs()) {\n         // If the playlist is too old to contain the chunk, we need to refresh it.\n         chunkMediaSequence = mediaPlaylist.mediaSequence + mediaPlaylist.segments.size();\n       } else {",
      "parent_sha": "77715fbfbe715721d48a0483cf045fa258118c80"
    }
  },
  {
    "oid": "625bb4ed48c9d70a44f9207c6604369b0c9b3c70",
    "message": "Fix PMT descriptors parsing bug\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=132862014",
    "date": "2016-09-13T16:39:16Z",
    "url": "https://github.com/google/ExoPlayer/commit/625bb4ed48c9d70a44f9207c6604369b0c9b3c70",
    "details": {
      "sha": "5c9e8cf673042b45c2b8effd644449ffd20675d1",
      "filename": "library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/google/ExoPlayer/blob/625bb4ed48c9d70a44f9207c6604369b0c9b3c70/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2Fts%2FTsExtractor.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/625bb4ed48c9d70a44f9207c6604369b0c9b3c70/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2Fts%2FTsExtractor.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2Fts%2FTsExtractor.java?ref=625bb4ed48c9d70a44f9207c6604369b0c9b3c70",
      "patch": "@@ -361,20 +361,6 @@ private class PmtReader extends TsPayloadReader {\n     private int sectionBytesRead;\n     private int crc;\n \n-    private final class EsInfo {\n-\n-      final int streamType;\n-      final int audioType;\n-      final String language;\n-\n-      public EsInfo(int streamType, int audioType, String language) {\n-        this.streamType = streamType;\n-        this.audioType = audioType;\n-        this.language = language;\n-      }\n-\n-    }\n-\n     public PmtReader() {\n       pmtScratch = new ParsableBitArray(new byte[5]);\n       sectionData = new ParsableByteArray();\n@@ -444,7 +430,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,\n         pmtScratch.skipBits(3); // reserved\n         int elementaryPid = pmtScratch.readBits(13);\n         pmtScratch.skipBits(4); // reserved\n-        int esInfoLength = pmtScratch.readBits(12); // ES_info_length\n+        int esInfoLength = pmtScratch.readBits(12); // ES_info_length.\n         EsInfo esInfo = readEsInfo(sectionData, esInfoLength);\n         if (streamType == 0x06) {\n           streamType = esInfo.streamType;\n@@ -527,6 +513,7 @@ private EsInfo readEsInfo(ParsableByteArray data, int length) {\n       while (data.getPosition() < descriptorsEndPosition) {\n         int descriptorTag = data.readUnsignedByte();\n         int descriptorLength = data.readUnsignedByte();\n+        int positionOfNextDescriptor = data.getPosition() + descriptorLength;\n         if (descriptorTag == TS_PMT_DESC_REGISTRATION) { // registration_descriptor\n           long formatIdentifier = data.readUnsignedInt();\n           if (formatIdentifier == AC3_FORMAT_IDENTIFIER) {\n@@ -536,7 +523,6 @@ private EsInfo readEsInfo(ParsableByteArray data, int length) {\n           } else if (formatIdentifier == HEVC_FORMAT_IDENTIFIER) {\n             streamType = TS_STREAM_TYPE_H265;\n           }\n-          break;\n         } else if (descriptorTag == TS_PMT_DESC_AC3) { // AC-3_descriptor in DVB (ETSI EN 300 468)\n           streamType = TS_STREAM_TYPE_AC3;\n         } else if (descriptorTag == TS_PMT_DESC_EAC3) { // enhanced_AC-3_descriptor\n@@ -547,13 +533,27 @@ private EsInfo readEsInfo(ParsableByteArray data, int length) {\n           language = new String(data.data, data.getPosition(), 3).trim();\n           audioType = data.data[data.getPosition() + 3];\n         }\n-\n-        data.skipBytes(descriptorLength);\n+        // Skip unused bytes of current descriptor.\n+        data.skipBytes(positionOfNextDescriptor - data.getPosition());\n       }\n       data.setPosition(descriptorsEndPosition);\n       return new EsInfo(streamType, audioType, language);\n     }\n \n+    private final class EsInfo {\n+\n+      final int streamType;\n+      final int audioType;\n+      final String language;\n+\n+      public EsInfo(int streamType, int audioType, String language) {\n+        this.streamType = streamType;\n+        this.audioType = audioType;\n+        this.language = language;\n+      }\n+\n+    }\n+\n   }\n \n   /**",
      "parent_sha": "bcec5970231d7159afbfc2939ef215fe32326864"
    }
  },
  {
    "oid": "8773b59fb5b3e35718305947bda312a97bebe62d",
    "message": "Clarify exception message.\n\nThe exception fires when intent resolution fails to find a service which declares an appropriate intent-filter. The existing message is confusing; it's trying to say that the service couldn't be found but the double negative renders it incorrect.\n\n#cleanup\n#minor-release\n\nPiperOrigin-RevId: 472736740\n(cherry picked from commit 15d3d74e16bf9830e5ae32d0a8edf691474d0b4e)",
    "date": "2022-09-07T15:56:07Z",
    "url": "https://github.com/google/ExoPlayer/commit/8773b59fb5b3e35718305947bda312a97bebe62d",
    "details": {
      "sha": "5b0e76b81714c3b9217c93cc0a5675c315344351",
      "filename": "libraries/session/src/main/java/androidx/media3/session/SessionToken.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/google/ExoPlayer/blob/8773b59fb5b3e35718305947bda312a97bebe62d/libraries%2Fsession%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fsession%2FSessionToken.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/8773b59fb5b3e35718305947bda312a97bebe62d/libraries%2Fsession%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fsession%2FSessionToken.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/libraries%2Fsession%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Fsession%2FSessionToken.java?ref=8773b59fb5b3e35718305947bda312a97bebe62d",
      "patch": "@@ -118,10 +118,10 @@ public SessionToken(Context context, ComponentName serviceComponent) {\n       type = TYPE_BROWSER_SERVICE_LEGACY;\n     } else {\n       throw new IllegalArgumentException(\n-          serviceComponent\n-              + \" doesn't implement none of\"\n-              + \" MediaSessionService, MediaLibraryService, MediaBrowserService nor\"\n-              + \" MediaBrowserServiceCompat. Use service's full name\");\n+          \"Failed to resolve SessionToken for \"\n+              + serviceComponent\n+              + \". Manifest doesn't declare one of either MediaSessionService, MediaLibraryService,\"\n+              + \" MediaBrowserService or MediaBrowserServiceCompat. Use service's full name.\");\n     }\n     if (type != TYPE_BROWSER_SERVICE_LEGACY) {\n       impl = new SessionTokenImplBase(serviceComponent, uid, type);",
      "parent_sha": "e6a725b6c2c798e366ed436995a974f088172cdc"
    }
  },
  {
    "oid": "996e58973d7e3837647910366862b9c1efdf650b",
    "message": "Make renderer flush when setting pause-at-end more targeted.\n\nWe currently always reset everything if playingPeriod != readingPeriod.\nHowever, this is only needed when the pausing is actually required, i.e.,\nif the feature is enabled and we are in the last period of the window.\n\nPiperOrigin-RevId: 328141242",
    "date": "2020-08-26T15:39:29Z",
    "url": "https://github.com/google/ExoPlayer/commit/996e58973d7e3837647910366862b9c1efdf650b",
    "details": {
      "sha": "c1c6a629202f319fa73147b4172165841903c051",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/google/ExoPlayer/blob/996e58973d7e3837647910366862b9c1efdf650b/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FExoPlayerImplInternal.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/996e58973d7e3837647910366862b9c1efdf650b/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FExoPlayerImplInternal.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FExoPlayerImplInternal.java?ref=996e58973d7e3837647910366862b9c1efdf650b",
      "patch": "@@ -733,11 +733,13 @@ private void setPlayWhenReadyInternal(\n   private void setPauseAtEndOfWindowInternal(boolean pauseAtEndOfWindow)\n       throws ExoPlaybackException {\n     this.pauseAtEndOfWindow = pauseAtEndOfWindow;\n-    if (queue.getReadingPeriod() != queue.getPlayingPeriod()) {\n+    resetPendingPauseAtEndOfPeriod();\n+    if (pendingPauseAtEndOfPeriod && queue.getReadingPeriod() != queue.getPlayingPeriod()) {\n+      // When pausing is required, we need to set the streams of the playing period final. If we\n+      // already started reading the next period, we need to flush the renderers.\n       seekToCurrentPosition(/* sendDiscontinuity= */ true);\n+      handleLoadingMediaPeriodChanged(/* loadingTrackSelectionChanged= */ false);\n     }\n-    resetPendingPauseAtEndOfPeriod();\n-    handleLoadingMediaPeriodChanged(/* loadingTrackSelectionChanged= */ false);\n   }\n \n   private void setOffloadSchedulingEnabledInternal(boolean offloadSchedulingEnabled) {",
      "parent_sha": "4b0e39e4b9dd8cdf7c90cc6e2054ca727538b96c"
    }
  },
  {
    "oid": "9ae0f6c5c170415a71bc472bb86fe7890e011eed",
    "message": "Clarify format is supported by encoder.\n\n#cleanup\n#minor-release\n\nPiperOrigin-RevId: 460688226\n(cherry picked from commit a88426ae58dc2ce31e1c4c0b7838f5e464107dcd)",
    "date": "2022-07-13T12:16:59Z",
    "url": "https://github.com/google/ExoPlayer/commit/9ae0f6c5c170415a71bc472bb86fe7890e011eed",
    "details": {
      "sha": "8427f2cb4a444ba430c19f0de68bd42f053220bc",
      "filename": "libraries/transformer/src/main/java/androidx/media3/transformer/DefaultEncoderFactory.java",
      "status": "modified",
      "additions": 20,
      "deletions": 10,
      "changes": 30,
      "blob_url": "https://github.com/google/ExoPlayer/blob/9ae0f6c5c170415a71bc472bb86fe7890e011eed/libraries%2Ftransformer%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Ftransformer%2FDefaultEncoderFactory.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/9ae0f6c5c170415a71bc472bb86fe7890e011eed/libraries%2Ftransformer%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Ftransformer%2FDefaultEncoderFactory.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/libraries%2Ftransformer%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Ftransformer%2FDefaultEncoderFactory.java?ref=9ae0f6c5c170415a71bc472bb86fe7890e011eed",
      "patch": "@@ -231,24 +231,34 @@ public Codec createForVideoEncoding(Format format, List<String> allowedMimeTypes\n     }\n \n     MediaCodecInfo encoderInfo = encoderAndClosestFormatSupport.encoder;\n-    format = encoderAndClosestFormatSupport.supportedFormat;\n+    Format encoderSupportedFormat = encoderAndClosestFormatSupport.supportedFormat;\n     VideoEncoderSettings supportedVideoEncoderSettings =\n         encoderAndClosestFormatSupport.supportedEncoderSettings;\n \n-    String mimeType = checkNotNull(format.sampleMimeType);\n-    MediaFormat mediaFormat = MediaFormat.createVideoFormat(mimeType, format.width, format.height);\n-    mediaFormat.setInteger(MediaFormat.KEY_FRAME_RATE, round(format.frameRate));\n+    String mimeType = checkNotNull(encoderSupportedFormat.sampleMimeType);\n+    MediaFormat mediaFormat =\n+        MediaFormat.createVideoFormat(\n+            mimeType, encoderSupportedFormat.width, encoderSupportedFormat.height);\n+    mediaFormat.setInteger(MediaFormat.KEY_FRAME_RATE, round(encoderSupportedFormat.frameRate));\n \n     int bitrate;\n \n     if (supportedVideoEncoderSettings.enableHighQualityTargeting) {\n       bitrate =\n           new DeviceMappedEncoderBitrateProvider()\n-              .getBitrate(encoderInfo.getName(), format.width, format.height, format.frameRate);\n+              .getBitrate(\n+                  encoderInfo.getName(),\n+                  encoderSupportedFormat.width,\n+                  encoderSupportedFormat.height,\n+                  encoderSupportedFormat.frameRate);\n     } else if (supportedVideoEncoderSettings.bitrate != VideoEncoderSettings.NO_VALUE) {\n       bitrate = supportedVideoEncoderSettings.bitrate;\n     } else {\n-      bitrate = getSuggestedBitrate(format.width, format.height, format.frameRate);\n+      bitrate =\n+          getSuggestedBitrate(\n+              encoderSupportedFormat.width,\n+              encoderSupportedFormat.height,\n+              encoderSupportedFormat.frameRate);\n     }\n \n     mediaFormat.setInteger(MediaFormat.KEY_BIT_RATE, bitrate);\n@@ -267,7 +277,7 @@ public Codec createForVideoEncoding(Format format, List<String> allowedMimeTypes\n       adjustMediaFormatForH264EncoderSettings(mediaFormat, encoderInfo);\n     }\n \n-    MediaFormatUtil.maybeSetColorInfo(mediaFormat, format.colorInfo);\n+    MediaFormatUtil.maybeSetColorInfo(mediaFormat, encoderSupportedFormat.colorInfo);\n     mediaFormat.setInteger(\n         MediaFormat.KEY_COLOR_FORMAT, supportedVideoEncoderSettings.colorProfile);\n \n@@ -303,7 +313,7 @@ public Codec createForVideoEncoding(Format format, List<String> allowedMimeTypes\n \n     return new DefaultCodec(\n         context,\n-        format,\n+        encoderSupportedFormat,\n         mediaFormat,\n         encoderInfo.getName(),\n         /* isDecoder= */ false,\n@@ -396,7 +406,7 @@ private static VideoEncoderQueryResult findEncoderWithClosestFormatSupport(\n           VideoEncoderSettings.NO_VALUE, VideoEncoderSettings.NO_VALUE);\n     }\n \n-    Format supportedEncoderFormat =\n+    Format encoderSupportedFormat =\n         requestedFormat\n             .buildUpon()\n             .setSampleMimeType(mimeType)\n@@ -405,7 +415,7 @@ private static VideoEncoderQueryResult findEncoderWithClosestFormatSupport(\n             .setAverageBitrate(closestSupportedBitrate)\n             .build();\n     return new VideoEncoderQueryResult(\n-        pickedEncoderInfo, supportedEncoderFormat, supportedEncodingSettingBuilder.build());\n+        pickedEncoderInfo, encoderSupportedFormat, supportedEncodingSettingBuilder.build());\n   }\n \n   /** Returns a list of encoders that support the requested resolution most closely. */",
      "parent_sha": "8f79af815535971f4623e82fdcddd60e12e1a56a"
    }
  },
  {
    "oid": "0f4fcc1110208f18689ac87aa452d76ab2d1a17a",
    "message": "Report flushing completed after all pending frames are decoded.\n\nWith the current ExtTexMgr,\n\nit can happen that\n\n- `x` frames are registered, but haven't arrived yet\n- flush\n  - need to drop `x` frames when they arrive on SurfaceTexture\n  - status is reset to 0 pending, 0 available, drop `x` when frames arrive\n- register one frame\n  - status is set to 1 pending, 0 available, drop `x` when frames arrive\n- flush\n  - now the number of frame to drop is reset to `pending - available = 1`\n  - but it should be `x+1`\n\nThis CL solves the issue by reporting (by running the afterFlushTask) flush completes only after all the pending frames before calling flush are accounted for.\n\nPiperOrigin-RevId: 506310671",
    "date": "2023-02-02T15:36:02Z",
    "url": "https://github.com/google/ExoPlayer/commit/0f4fcc1110208f18689ac87aa452d76ab2d1a17a",
    "details": {
      "sha": "bbbbe435a7344a37812edc21363e9c440f81d99c",
      "filename": "libraries/effect/src/main/java/androidx/media3/effect/ExternalTextureManager.java",
      "status": "modified",
      "additions": 8,
      "deletions": 2,
      "changes": 10,
      "blob_url": "https://github.com/google/ExoPlayer/blob/0f4fcc1110208f18689ac87aa452d76ab2d1a17a/libraries%2Feffect%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Feffect%2FExternalTextureManager.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/0f4fcc1110208f18689ac87aa452d76ab2d1a17a/libraries%2Feffect%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Feffect%2FExternalTextureManager.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/libraries%2Feffect%2Fsrc%2Fmain%2Fjava%2Fandroidx%2Fmedia3%2Feffect%2FExternalTextureManager.java?ref=0f4fcc1110208f18689ac87aa452d76ab2d1a17a",
      "patch": "@@ -58,6 +58,7 @@\n   // Set to null on any thread. Read and set to non-null on the GL thread only.\n   @Nullable private volatile FrameInfo currentFrame;\n \n+  // TODO(b/238302341) Remove the use of after flush task, block the calling thread instead.\n   @Nullable private volatile FrameProcessingTask onFlushCompleteTask;\n \n   private long previousStreamOffsetUs;\n@@ -97,6 +98,7 @@ public SurfaceTexture getSurfaceTexture() {\n                   if (numberOfFramesToDropOnBecomingAvailable > 0) {\n                     numberOfFramesToDropOnBecomingAvailable--;\n                     surfaceTexture.updateTexImage();\n+                    maybeExecuteAfterFlushTask();\n                   } else {\n                     availableFrameCount++;\n                     maybeQueueFrameToExternalTextureProcessor();\n@@ -184,10 +186,14 @@ private void flush() {\n     externalTextureProcessorInputCapacity.set(0);\n     currentFrame = null;\n     pendingFrames.clear();\n+    maybeExecuteAfterFlushTask();\n+  }\n \n-    if (onFlushCompleteTask != null) {\n-      frameProcessingTaskExecutor.submitWithHighPriority(onFlushCompleteTask);\n+  private void maybeExecuteAfterFlushTask() {\n+    if (onFlushCompleteTask == null || numberOfFramesToDropOnBecomingAvailable > 0) {\n+      return;\n     }\n+    frameProcessingTaskExecutor.submitWithHighPriority(onFlushCompleteTask);\n   }\n \n   @WorkerThread",
      "parent_sha": "656a1d9475817affef9d7fc95d0090cb11e27302"
    }
  },
  {
    "oid": "469a78ef1a31cb0e8636d5952eb583df19997f80",
    "message": "Update comment on `Track.nalUnitLengthFieldLength`\n\nThis field is also non-zero for h.265 tracks.\n\nPiperOrigin-RevId: 523676455",
    "date": "2023-04-12T16:39:20Z",
    "url": "https://github.com/google/ExoPlayer/commit/469a78ef1a31cb0e8636d5952eb583df19997f80",
    "details": {
      "sha": "383a677cd483192ffe7b6ed80225d5d3ca7d53db",
      "filename": "library/extractor/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/google/ExoPlayer/blob/469a78ef1a31cb0e8636d5952eb583df19997f80/library%2Fextractor%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2Fmp4%2FTrack.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/469a78ef1a31cb0e8636d5952eb583df19997f80/library%2Fextractor%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2Fmp4%2FTrack.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fextractor%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2Fmp4%2FTrack.java?ref=469a78ef1a31cb0e8636d5952eb583df19997f80",
      "patch": "@@ -76,8 +76,8 @@ public final class Track {\n   @Nullable public final long[] editListMediaTimes;\n \n   /**\n-   * For H264 video tracks, the length in bytes of the NALUnitLength field in each sample. 0 for\n-   * other track types.\n+   * The length in bytes of the NALUnitLength field in each sample. 0 for tracks that don't use\n+   * length-delimited NAL units.\n    */\n   public final int nalUnitLengthFieldLength;\n ",
      "parent_sha": "001d3468865ce43f005d07f8ebcad9f997a56310"
    }
  },
  {
    "oid": "73546231d2c454dd23b89d14bf9fb25bdce10704",
    "message": "Bump ExoPlayerLibraryInfo versions to 2.11.6\n\nPiperOrigin-RevId: 317921368",
    "date": "2020-06-26T10:13:10Z",
    "url": "https://github.com/google/ExoPlayer/commit/73546231d2c454dd23b89d14bf9fb25bdce10704",
    "details": {
      "sha": "f35c3ac49834032a382b7b6d96c82035769a91c0",
      "filename": "library/common/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/google/ExoPlayer/blob/73546231d2c454dd23b89d14bf9fb25bdce10704/library%2Fcommon%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FExoPlayerLibraryInfo.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/73546231d2c454dd23b89d14bf9fb25bdce10704/library%2Fcommon%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FExoPlayerLibraryInfo.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcommon%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FExoPlayerLibraryInfo.java?ref=73546231d2c454dd23b89d14bf9fb25bdce10704",
      "patch": "@@ -29,11 +29,11 @@ public final class ExoPlayerLibraryInfo {\n \n   /** The version of the library expressed as a string, for example \"1.2.3\". */\n   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION_INT) or vice versa.\n-  public static final String VERSION = \"2.11.5\";\n+  public static final String VERSION = \"2.11.6\";\n \n   /** The version of the library expressed as {@code \"ExoPlayerLib/\" + VERSION}. */\n   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.\n-  public static final String VERSION_SLASHY = \"ExoPlayerLib/2.11.5\";\n+  public static final String VERSION_SLASHY = \"ExoPlayerLib/2.11.6\";\n \n   /**\n    * The version of the library expressed as an integer, for example 1002003.\n@@ -43,7 +43,7 @@ public final class ExoPlayerLibraryInfo {\n    * integer version 123045006 (123-045-006).\n    */\n   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.\n-  public static final int VERSION_INT = 2011005;\n+  public static final int VERSION_INT = 2011006;\n \n   /**\n    * Whether the library was compiled with {@link com.google.android.exoplayer2.util.Assertions}",
      "parent_sha": "05f3fd8138ea98069bde258817b9ef1274d433bc"
    }
  },
  {
    "oid": "f402a84dfa057a6f0a0ac747145683fca6b03ee9",
    "message": "Group Timeline.getPeriod overloads\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=183238240",
    "date": "2018-02-01T14:19:41Z",
    "url": "https://github.com/google/ExoPlayer/commit/f402a84dfa057a6f0a0ac747145683fca6b03ee9",
    "details": {
      "sha": "4a1f2bfd1eb6fd403fff1b43aeb47663390ef1fd",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/Timeline.java",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/google/ExoPlayer/blob/f402a84dfa057a6f0a0ac747145683fca6b03ee9/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FTimeline.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/f402a84dfa057a6f0a0ac747145683fca6b03ee9/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FTimeline.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2FTimeline.java?ref=f402a84dfa057a6f0a0ac747145683fca6b03ee9",
      "patch": "@@ -710,18 +710,6 @@ public final boolean isLastPeriod(int periodIndex, Period period, Window window,\n         == C.INDEX_UNSET;\n   }\n \n-  /**\n-   * Populates a {@link Period} with data for the period at the specified index. Does not populate\n-   * {@link Period#id} and {@link Period#uid}.\n-   *\n-   * @param periodIndex The index of the period.\n-   * @param period The {@link Period} to populate. Must not be null.\n-   * @return The populated {@link Period}, for convenience.\n-   */\n-  public final Period getPeriod(int periodIndex, Period period) {\n-    return getPeriod(periodIndex, period, false);\n-  }\n-\n   /**\n    * Calls {@link #getPeriodPosition(Window, Period, int, long, long)} with a zero default position\n    * projection.\n@@ -766,6 +754,18 @@ public final Pair<Integer, Long> getPeriodPosition(Window window, Period period,\n     return Pair.create(periodIndex, periodPositionUs);\n   }\n \n+  /**\n+   * Populates a {@link Period} with data for the period at the specified index. Does not populate\n+   * {@link Period#id} and {@link Period#uid}.\n+   *\n+   * @param periodIndex The index of the period.\n+   * @param period The {@link Period} to populate. Must not be null.\n+   * @return The populated {@link Period}, for convenience.\n+   */\n+  public final Period getPeriod(int periodIndex, Period period) {\n+    return getPeriod(periodIndex, period, false);\n+  }\n+\n   /**\n    * Populates a {@link Period} with data for the period at the specified index.\n    *",
      "parent_sha": "205055a01f92cdc357b3970151ff7ac174d62be0"
    }
  },
  {
    "oid": "dd60bac07d827155f8bdc25972050d43b97bbac2",
    "message": "MatroskaExtractor naming cleanup\n\n- Change sampleHasReferenceBlock to a block reading variable, which is\n  what it is (the distinction didn't matter previously, but will do so\n  when we add lacing support in full blocks because there wont be a 1:1\n  relationship any more.\n- Move sampleRead to be a reading state variable.\n- Stop abbreviating \"additional\"\n\nIssue: #3026\nPiperOrigin-RevId: 284000937",
    "date": "2019-12-06T19:20:44Z",
    "url": "https://github.com/google/ExoPlayer/commit/dd60bac07d827155f8bdc25972050d43b97bbac2",
    "details": {
      "sha": "ff64357ca7940cf1b253ea5cd715e93325c542ef",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java",
      "status": "modified",
      "additions": 30,
      "deletions": 26,
      "changes": 56,
      "blob_url": "https://github.com/google/ExoPlayer/blob/dd60bac07d827155f8bdc25972050d43b97bbac2/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2Fmkv%2FMatroskaExtractor.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/dd60bac07d827155f8bdc25972050d43b97bbac2/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2Fmkv%2FMatroskaExtractor.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fextractor%2Fmkv%2FMatroskaExtractor.java?ref=dd60bac07d827155f8bdc25972050d43b97bbac2",
      "patch": "@@ -224,7 +224,7 @@ public class MatroskaExtractor implements Extractor {\n    * BlockAddID value for ITU T.35 metadata in a VP9 track. See also\n    * https://www.webmproject.org/docs/container/.\n    */\n-  private static final int BLOCK_ADD_ID_VP9_ITU_T_35 = 4;\n+  private static final int BLOCK_ADDITIONAL_ID_VP9_ITU_T_35 = 4;\n \n   private static final int LACING_NONE = 0;\n   private static final int LACING_XIPH = 1;\n@@ -332,7 +332,7 @@ public class MatroskaExtractor implements Extractor {\n   private final ParsableByteArray subtitleSample;\n   private final ParsableByteArray encryptionInitializationVector;\n   private final ParsableByteArray encryptionSubsampleData;\n-  private final ParsableByteArray blockAddData;\n+  private final ParsableByteArray blockAdditionalData;\n   private ByteBuffer encryptionSubsampleDataBuffer;\n \n   private long segmentContentSize;\n@@ -360,6 +360,9 @@ public class MatroskaExtractor implements Extractor {\n   private LongArray cueClusterPositions;\n   private boolean seenClusterPositionForCurrentCuePoint;\n \n+  // Reading state.\n+  private boolean haveOutputSample;\n+\n   // Block reading state.\n   private int blockState;\n   private long blockTimeUs;\n@@ -371,20 +374,19 @@ public class MatroskaExtractor implements Extractor {\n   private int blockTrackNumberLength;\n   @C.BufferFlags\n   private int blockFlags;\n-  private int blockAddId;\n+  private int blockAdditionalId;\n+  private boolean blockHasReferenceBlock;\n \n   // Sample reading state.\n   private int sampleBytesRead;\n+  private int sampleBytesWritten;\n+  private int sampleCurrentNalBytesRemaining;\n   private boolean sampleEncodingHandled;\n   private boolean sampleSignalByteRead;\n-  private boolean sampleInitializationVectorRead;\n   private boolean samplePartitionCountRead;\n-  private byte sampleSignalByte;\n   private int samplePartitionCount;\n-  private int sampleCurrentNalBytesRemaining;\n-  private int sampleBytesWritten;\n-  private boolean sampleRead;\n-  private boolean sampleSeenReferenceBlock;\n+  private byte sampleSignalByte;\n+  private boolean sampleInitializationVectorRead;\n \n   // Extractor outputs.\n   private ExtractorOutput extractorOutput;\n@@ -412,7 +414,7 @@ public MatroskaExtractor(@Flags int flags) {\n     subtitleSample = new ParsableByteArray();\n     encryptionInitializationVector = new ParsableByteArray(ENCRYPTION_IV_SIZE);\n     encryptionSubsampleData = new ParsableByteArray();\n-    blockAddData = new ParsableByteArray();\n+    blockAdditionalData = new ParsableByteArray();\n   }\n \n   @Override\n@@ -446,9 +448,9 @@ public final void release() {\n   @Override\n   public final int read(ExtractorInput input, PositionHolder seekPosition)\n       throws IOException, InterruptedException {\n-    sampleRead = false;\n+    haveOutputSample = false;\n     boolean continueReading = true;\n-    while (continueReading && !sampleRead) {\n+    while (continueReading && !haveOutputSample) {\n       continueReading = reader.read(input);\n       if (continueReading && maybeSeekForCues(seekPosition, input.getPosition())) {\n         return Extractor.RESULT_SEEK;\n@@ -623,7 +625,7 @@ protected void startMasterElement(int id, long contentPosition, long contentSize\n         }\n         break;\n       case ID_BLOCK_GROUP:\n-        sampleSeenReferenceBlock = false;\n+        blockHasReferenceBlock = false;\n         break;\n       case ID_CONTENT_ENCODING:\n         // TODO: check and fail if more than one content encoding is present.\n@@ -681,7 +683,7 @@ protected void endMasterElement(int id) throws ParserException {\n           return;\n         }\n         // If the ReferenceBlock element was not found for this sample, then it is a keyframe.\n-        if (!sampleSeenReferenceBlock) {\n+        if (!blockHasReferenceBlock) {\n           blockFlags |= C.BUFFER_FLAG_KEY_FRAME;\n         }\n         commitSampleToOutput(tracks.get(blockTrackNumber), blockTimeUs);\n@@ -793,7 +795,7 @@ protected void integerElement(int id, long value) throws ParserException {\n         currentTrack.audioBitDepth = (int) value;\n         break;\n       case ID_REFERENCE_BLOCK:\n-        sampleSeenReferenceBlock = true;\n+        blockHasReferenceBlock = true;\n         break;\n       case ID_CONTENT_ENCODING_ORDER:\n         // This extractor only supports one ContentEncoding element and hence the order has to be 0.\n@@ -935,7 +937,7 @@ protected void integerElement(int id, long value) throws ParserException {\n         }\n         break;\n       case ID_BLOCK_ADD_ID:\n-        blockAddId = (int) value;\n+        blockAdditionalId = (int) value;\n         break;\n       default:\n         break;\n@@ -1199,19 +1201,21 @@ protected void binaryElement(int id, int contentSize, ExtractorInput input)\n         if (blockState != BLOCK_STATE_DATA) {\n           return;\n         }\n-        handleBlockAdditionalData(tracks.get(blockTrackNumber), blockAddId, input, contentSize);\n+        handleBlockAdditionalData(\n+            tracks.get(blockTrackNumber), blockAdditionalId, input, contentSize);\n         break;\n       default:\n         throw new ParserException(\"Unexpected id: \" + id);\n     }\n   }\n \n   protected void handleBlockAdditionalData(\n-      Track track, int blockAddId, ExtractorInput input, int contentSize)\n+      Track track, int blockAdditionalId, ExtractorInput input, int contentSize)\n       throws IOException, InterruptedException {\n-    if (blockAddId == BLOCK_ADD_ID_VP9_ITU_T_35 && CODEC_ID_VP9.equals(track.codecId)) {\n-      blockAddData.reset(contentSize);\n-      input.readFully(blockAddData.data, 0, contentSize);\n+    if (blockAdditionalId == BLOCK_ADDITIONAL_ID_VP9_ITU_T_35\n+        && CODEC_ID_VP9.equals(track.codecId)) {\n+      blockAdditionalData.reset(contentSize);\n+      input.readFully(blockAdditionalData.data, 0, contentSize);\n     } else {\n       // Unhandled block additional data.\n       input.skipFully(contentSize);\n@@ -1236,13 +1240,13 @@ private void commitSampleToOutput(Track track, long timeUs) {\n \n       if ((blockFlags & C.BUFFER_FLAG_HAS_SUPPLEMENTAL_DATA) != 0) {\n         // Append supplemental data.\n-        int size = blockAddData.limit();\n-        track.output.sampleData(blockAddData, size);\n-        sampleBytesWritten += size;\n+        int blockAdditionalSize = blockAdditionalData.limit();\n+        track.output.sampleData(blockAdditionalData, blockAdditionalSize);\n+        sampleBytesWritten += blockAdditionalSize;\n       }\n       track.output.sampleMetadata(timeUs, blockFlags, sampleBytesWritten, 0, track.cryptoData);\n     }\n-    sampleRead = true;\n+    haveOutputSample = true;\n     resetSample();\n   }\n \n@@ -1375,7 +1379,7 @@ private void writeSampleData(ExtractorInput input, Track track, int size)\n \n       if (track.maxBlockAdditionId > 0) {\n         blockFlags |= C.BUFFER_FLAG_HAS_SUPPLEMENTAL_DATA;\n-        blockAddData.reset();\n+        blockAdditionalData.reset();\n         // If there is supplemental data, the structure of the sample data is:\n         // sample size (4 bytes) || sample data || supplemental data\n         scratch.reset(/* limit= */ 4);",
      "parent_sha": "bf495de529aef70b7a2de862a425cbc6424fb8be"
    }
  },
  {
    "oid": "d632cb86c13edc398bcd0400a5bee0e3f6bad808",
    "message": "Make multisession work well with placeholder session\n\nIssue:#4867\nPiperOrigin-RevId: 271404942",
    "date": "2019-10-02T20:27:19Z",
    "url": "https://github.com/google/ExoPlayer/commit/d632cb86c13edc398bcd0400a5bee0e3f6bad808",
    "details": {
      "sha": "92cb5d7b8bd04b05b5dca8377d09d32645fc6eac",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java",
      "status": "modified",
      "additions": 9,
      "deletions": 2,
      "changes": 11,
      "blob_url": "https://github.com/google/ExoPlayer/blob/d632cb86c13edc398bcd0400a5bee0e3f6bad808/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fdrm%2FDefaultDrmSessionManager.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/d632cb86c13edc398bcd0400a5bee0e3f6bad808/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fdrm%2FDefaultDrmSessionManager.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fdrm%2FDefaultDrmSessionManager.java?ref=d632cb86c13edc398bcd0400a5bee0e3f6bad808",
      "patch": "@@ -102,6 +102,7 @@ private MissingSchemeDataException(UUID uuid) {\n   private int prepareCallsCount;\n   @Nullable private ExoMediaDrm<T> exoMediaDrm;\n   @Nullable private DefaultDrmSession<T> placeholderDrmSession;\n+  @Nullable private DefaultDrmSession<T> noMultiSessionDrmSession;\n   @Nullable private Looper playbackLooper;\n   private int mode;\n   @Nullable private byte[] offlineLicenseKeySetId;\n@@ -357,9 +358,9 @@ public DrmSession<T> acquireSession(Looper playbackLooper, DrmInitData drmInitDa\n       }\n     }\n \n-    DefaultDrmSession<T> session;\n+    @Nullable DefaultDrmSession<T> session;\n     if (!multiSession) {\n-      session = sessions.isEmpty() ? null : sessions.get(0);\n+      session = noMultiSessionDrmSession;\n     } else {\n       // Only use an existing session if it has matching init data.\n       session = null;\n@@ -374,6 +375,9 @@ public DrmSession<T> acquireSession(Looper playbackLooper, DrmInitData drmInitDa\n     if (session == null) {\n       // Create a new session.\n       session = createNewDefaultSession(schemeDatas, /* isPlaceholderSession= */ false);\n+      if (!multiSession) {\n+        noMultiSessionDrmSession = session;\n+      }\n       sessions.add(session);\n     }\n     session.acquireReference();\n@@ -462,6 +466,9 @@ private void onSessionReleased(DefaultDrmSession<T> drmSession) {\n     if (placeholderDrmSession == drmSession) {\n       placeholderDrmSession = null;\n     }\n+    if (noMultiSessionDrmSession == drmSession) {\n+      noMultiSessionDrmSession = null;\n+    }\n     if (provisioningSessions.size() > 1 && provisioningSessions.get(0) == drmSession) {\n       // Other sessions were waiting for the released session to complete a provision operation.\n       // We need to have one of those sessions perform the provision operation instead.",
      "parent_sha": "f0b9889ef6e218b1a41bbf18cb0948135fd994ee"
    }
  },
  {
    "oid": "ce12edf46e0accf68839e9bc4a3c1275de0953ce",
    "message": "Remove unnecessary `volatile`\n\nThis field is always accessed with the mutex held.\n\nPiperOrigin-RevId: 534027096\n(cherry picked from commit ea42465fef89a667655c4d2603e7b48b54157d92)",
    "date": "2023-05-26T13:16:26Z",
    "url": "https://github.com/google/ExoPlayer/commit/ce12edf46e0accf68839e9bc4a3c1275de0953ce",
    "details": {
      "sha": "236507a72b2eb7eb73807af5b39cbc8c1fc2e47f",
      "filename": "library/effect/src/main/java/com/google/android/exoplayer2/effect/FinalShaderProgramWrapper.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/google/ExoPlayer/blob/ce12edf46e0accf68839e9bc4a3c1275de0953ce/library%2Feffect%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Feffect%2FFinalShaderProgramWrapper.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/ce12edf46e0accf68839e9bc4a3c1275de0953ce/library%2Feffect%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Feffect%2FFinalShaderProgramWrapper.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Feffect%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Feffect%2FFinalShaderProgramWrapper.java?ref=ce12edf46e0accf68839e9bc4a3c1275de0953ce",
      "patch": "@@ -106,7 +106,8 @@ interface OnInputStreamProcessedListener {\n   @Nullable private OnInputStreamProcessedListener onInputStreamProcessedListener;\n   private boolean frameProcessingStarted;\n \n-  private volatile boolean outputSurfaceInfoChanged;\n+  @GuardedBy(\"this\")\n+  private boolean outputSurfaceInfoChanged;\n \n   @GuardedBy(\"this\")\n   @Nullable",
      "parent_sha": "2469ee43b4fedd9be8bb430c427ad2193c965a6b"
    }
  },
  {
    "oid": "660cfd2863f68e687ea22f087ccd3c087ccd494c",
    "message": "Lock down SampleQueue to reasonable extension points\n\nPiperOrigin-RevId: 292542298",
    "date": "2020-01-31T17:52:34Z",
    "url": "https://github.com/google/ExoPlayer/commit/660cfd2863f68e687ea22f087ccd3c087ccd494c",
    "details": {
      "sha": "d4e447bc61183d38a6670f47cc66923a2ae9adec",
      "filename": "library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java",
      "status": "modified",
      "additions": 33,
      "deletions": 29,
      "changes": 62,
      "blob_url": "https://github.com/google/ExoPlayer/blob/660cfd2863f68e687ea22f087ccd3c087ccd494c/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2FSampleQueue.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/660cfd2863f68e687ea22f087ccd3c087ccd494c/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2FSampleQueue.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/library%2Fcore%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Fsource%2FSampleQueue.java?ref=660cfd2863f68e687ea22f087ccd3c087ccd494c",
      "patch": "@@ -114,16 +114,15 @@ public SampleQueue(Allocator allocator, DrmSessionManager<?> drmSessionManager)\n \n   // Called by the consuming thread when there is no loading thread.\n \n-  /**\n-   * Calls {@link #reset(boolean) reset(true)} and releases any owned {@link DrmSession} references.\n-   */\n+  /** Calls {@link #reset(boolean) reset(true)} and releases any resources owned by the queue. */\n+  @CallSuper\n   public void release() {\n     reset(/* resetUpstreamFormat= */ true);\n     releaseDrmSessionReferences();\n   }\n \n-  /** Resets the output without clearing the upstream format. Equivalent to {@code reset(false)}. */\n-  public void reset() {\n+  /** Convenience method for {@code reset(false)}. */\n+  public final void reset() {\n     reset(/* resetUpstreamFormat= */ false);\n   }\n \n@@ -135,6 +134,7 @@ public void reset() {\n    *     are assumed to have the current upstream format. If set to true, {@link #format(Format)}\n    *     must be called after the reset before any more samples can be queued.\n    */\n+  @CallSuper\n   public void reset(boolean resetUpstreamFormat) {\n     sampleDataQueue.reset();\n     length = 0;\n@@ -158,17 +158,17 @@ public void reset(boolean resetUpstreamFormat) {\n    *\n    * @param sourceId The source identifier.\n    */\n-  public void sourceId(int sourceId) {\n+  public final void sourceId(int sourceId) {\n     upstreamSourceId = sourceId;\n   }\n \n   /** Indicates samples that are subsequently queued should be spliced into those already queued. */\n-  public void splice() {\n+  public final void splice() {\n     pendingSplice = true;\n   }\n \n   /** Returns the current absolute write index. */\n-  public int getWriteIndex() {\n+  public final int getWriteIndex() {\n     return absoluteFirstIndex + length;\n   }\n \n@@ -178,13 +178,14 @@ public int getWriteIndex() {\n    * @param discardFromIndex The absolute index of the first sample to be discarded. Must be in the\n    *     range [{@link #getReadIndex()}, {@link #getWriteIndex()}].\n    */\n-  public void discardUpstreamSamples(int discardFromIndex) {\n+  public final void discardUpstreamSamples(int discardFromIndex) {\n     sampleDataQueue.discardUpstreamSampleBytes(discardUpstreamSampleMetadata(discardFromIndex));\n   }\n \n   // Called by the consuming thread.\n \n-  /** Calls {@link #discardToEnd()} and releases any owned {@link DrmSession} references. */\n+  /** Calls {@link #discardToEnd()} and releases any resources owned by the queue. */\n+  @CallSuper\n   public void preRelease() {\n     discardToEnd();\n     releaseDrmSessionReferences();\n@@ -195,6 +196,7 @@ public void preRelease() {\n    *\n    * @throws IOException The underlying error.\n    */\n+  @CallSuper\n   public void maybeThrowError() throws IOException {\n     // TODO: Avoid throwing if the DRM error is not preventing a read operation.\n     if (currentDrmSession != null && currentDrmSession.getState() == DrmSession.STATE_ERROR) {\n@@ -203,12 +205,12 @@ public void maybeThrowError() throws IOException {\n   }\n \n   /** Returns the current absolute start index. */\n-  public int getFirstIndex() {\n+  public final int getFirstIndex() {\n     return absoluteFirstIndex;\n   }\n \n   /** Returns the current absolute read index. */\n-  public int getReadIndex() {\n+  public final int getReadIndex() {\n     return absoluteFirstIndex + readPosition;\n   }\n \n@@ -218,13 +220,13 @@ public int getReadIndex() {\n    *\n    * @return The source id.\n    */\n-  public synchronized int peekSourceId() {\n+  public final synchronized int peekSourceId() {\n     int relativeReadIndex = getRelativeIndex(readPosition);\n     return hasNextSample() ? sourceIds[relativeReadIndex] : upstreamSourceId;\n   }\n \n   /** Returns the upstream {@link Format} in which samples are being queued. */\n-  public synchronized Format getUpstreamFormat() {\n+  public final synchronized Format getUpstreamFormat() {\n     return upstreamFormatRequired ? null : upstreamFormat;\n   }\n \n@@ -238,7 +240,7 @@ public synchronized Format getUpstreamFormat() {\n    * @return The largest sample timestamp that has been queued, or {@link Long#MIN_VALUE} if no\n    *     samples have been queued.\n    */\n-  public synchronized long getLargestQueuedTimestampUs() {\n+  public final synchronized long getLargestQueuedTimestampUs() {\n     return largestQueuedTimestampUs;\n   }\n \n@@ -251,12 +253,12 @@ public synchronized long getLargestQueuedTimestampUs() {\n    * considered as having been queued. Samples that were dequeued from the front of the queue are\n    * considered as having been queued.\n    */\n-  public synchronized boolean isLastSampleQueued() {\n+  public final synchronized boolean isLastSampleQueued() {\n     return isLastSampleQueued;\n   }\n \n   /** Returns the timestamp of the first sample, or {@link Long#MIN_VALUE} if the queue is empty. */\n-  public synchronized long getFirstTimestampUs() {\n+  public final synchronized long getFirstTimestampUs() {\n     return length == 0 ? Long.MIN_VALUE : timesUs[relativeFirstIndex];\n   }\n \n@@ -272,6 +274,7 @@ public synchronized long getFirstTimestampUs() {\n    *     queue is empty.\n    */\n   @SuppressWarnings(\"ReferenceEquality\") // See comments in setUpstreamFormat\n+  @CallSuper\n   public synchronized boolean isReady(boolean loadingFinished) {\n     if (!hasNextSample()) {\n       return loadingFinished\n@@ -313,6 +316,7 @@ public synchronized boolean isReady(boolean loadingFinished) {\n    * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ} or\n    *     {@link C#RESULT_BUFFER_READ}.\n    */\n+  @CallSuper\n   public int read(\n       FormatHolder formatHolder,\n       DecoderInputBuffer buffer,\n@@ -334,7 +338,7 @@ public int read(\n    * @param sampleIndex The sample index.\n    * @return Whether the seek was successful.\n    */\n-  public synchronized boolean seekTo(int sampleIndex) {\n+  public final synchronized boolean seekTo(int sampleIndex) {\n     rewind();\n     if (sampleIndex < absoluteFirstIndex || sampleIndex > absoluteFirstIndex + length) {\n       return false;\n@@ -351,7 +355,7 @@ public synchronized boolean seekTo(int sampleIndex) {\n    *     end of the queue, by seeking to the last sample (or keyframe).\n    * @return Whether the seek was successful.\n    */\n-  public synchronized boolean seekTo(long timeUs, boolean allowTimeBeyondBuffer) {\n+  public final synchronized boolean seekTo(long timeUs, boolean allowTimeBeyondBuffer) {\n     rewind();\n     int relativeReadIndex = getRelativeIndex(readPosition);\n     if (!hasNextSample()\n@@ -374,7 +378,7 @@ public synchronized boolean seekTo(long timeUs, boolean allowTimeBeyondBuffer) {\n    * @param timeUs The time to advance to.\n    * @return The number of samples that were skipped, which may be equal to 0.\n    */\n-  public synchronized int advanceTo(long timeUs) {\n+  public final synchronized int advanceTo(long timeUs) {\n     int relativeReadIndex = getRelativeIndex(readPosition);\n     if (!hasNextSample() || timeUs < timesUs[relativeReadIndex]) {\n       return 0;\n@@ -393,7 +397,7 @@ public synchronized int advanceTo(long timeUs) {\n    *\n    * @return The number of samples that were skipped.\n    */\n-  public synchronized int advanceToEnd() {\n+  public final synchronized int advanceToEnd() {\n     int skipCount = length - readPosition;\n     readPosition = length;\n     return skipCount;\n@@ -409,18 +413,18 @@ public synchronized int advanceToEnd() {\n    *     position. If false then samples at and beyond the read position may be discarded, in which\n    *     case the read position is advanced to the first remaining sample.\n    */\n-  public void discardTo(long timeUs, boolean toKeyframe, boolean stopAtReadPosition) {\n+  public final void discardTo(long timeUs, boolean toKeyframe, boolean stopAtReadPosition) {\n     sampleDataQueue.discardDownstreamTo(\n         discardSampleMetadataTo(timeUs, toKeyframe, stopAtReadPosition));\n   }\n \n   /** Discards up to but not including the read position. */\n-  public void discardToRead() {\n+  public final void discardToRead() {\n     sampleDataQueue.discardDownstreamTo(discardSampleMetadataToRead());\n   }\n \n   /** Discards all samples in the queue and advances the read position. */\n-  public void discardToEnd() {\n+  public final void discardToEnd() {\n     sampleDataQueue.discardDownstreamTo(discardSampleMetadataToEnd());\n   }\n \n@@ -432,7 +436,7 @@ public void discardToEnd() {\n    *\n    * @param sampleOffsetUs The timestamp offset in microseconds.\n    */\n-  public void setSampleOffsetUs(long sampleOffsetUs) {\n+  public final void setSampleOffsetUs(long sampleOffsetUs) {\n     if (this.sampleOffsetUs != sampleOffsetUs) {\n       this.sampleOffsetUs = sampleOffsetUs;\n       invalidateUpstreamFormatAdjustment();\n@@ -444,7 +448,7 @@ public void setSampleOffsetUs(long sampleOffsetUs) {\n    *\n    * @param listener The listener.\n    */\n-  public void setUpstreamFormatChangeListener(UpstreamFormatChangedListener listener) {\n+  public final void setUpstreamFormatChangeListener(UpstreamFormatChangedListener listener) {\n     upstreamFormatChangeListener = listener;\n   }\n \n@@ -462,18 +466,18 @@ public final void format(Format unadjustedUpstreamFormat) {\n   }\n \n   @Override\n-  public int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)\n+  public final int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)\n       throws IOException, InterruptedException {\n     return sampleDataQueue.sampleData(input, length, allowEndOfInput);\n   }\n \n   @Override\n-  public void sampleData(ParsableByteArray buffer, int length) {\n+  public final void sampleData(ParsableByteArray buffer, int length) {\n     sampleDataQueue.sampleData(buffer, length);\n   }\n \n   @Override\n-  public void sampleMetadata(\n+  public final void sampleMetadata(\n       long timeUs,\n       @C.BufferFlags int flags,\n       int size,",
      "parent_sha": "3774530831a513090790178776d10235ab4ddb53"
    }
  },
  {
    "oid": "578afa883d63b9122debb194e28ff8a4261139e1",
    "message": "Fix demo app crash when media pipe isn't loaded\n\nThe toast message about media pipe not loading needs to be shown on the main\n(UI) thread.\n\nPiperOrigin-RevId: 449199285",
    "date": "2022-05-24T10:20:08Z",
    "url": "https://github.com/google/ExoPlayer/commit/578afa883d63b9122debb194e28ff8a4261139e1",
    "details": {
      "sha": "6cd904037aee6e35496e95fc3daab03cbef5bf90",
      "filename": "demos/transformer/src/main/java/com/google/android/exoplayer2/transformerdemo/TransformerActivity.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/ExoPlayer/blob/578afa883d63b9122debb194e28ff8a4261139e1/demos%2Ftransformer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftransformerdemo%2FTransformerActivity.java",
      "raw_url": "https://github.com/google/ExoPlayer/raw/578afa883d63b9122debb194e28ff8a4261139e1/demos%2Ftransformer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftransformerdemo%2FTransformerActivity.java",
      "contents_url": "https://api.github.com/repos/google/ExoPlayer/contents/demos%2Ftransformer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fandroid%2Fexoplayer2%2Ftransformerdemo%2FTransformerActivity.java?ref=578afa883d63b9122debb194e28ff8a4261139e1",
      "patch": "@@ -267,7 +267,7 @@ private Transformer createTransformer(@Nullable Bundle bundle, String filePath)\n                             /* inputStreamName= */ \"input_video\",\n                             /* outputStreamName= */ \"output_video\");\n                   } catch (Exception e) {\n-                    showToast(R.string.no_media_pipe_error);\n+                    runOnUiThread(() -> showToast(R.string.no_media_pipe_error));\n                     throw new RuntimeException(\"Failed to load MediaPipe processor\", e);\n                   }\n                 });",
      "parent_sha": "463603049e9fab98a43f931596a15ea2df809b7b"
    }
  }
]