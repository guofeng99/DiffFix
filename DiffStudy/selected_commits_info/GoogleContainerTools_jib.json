[
  {
    "oid": "5cad2a62b2f7e0c8b86e427a7c397de804ec6f07",
    "message": "Add content tests for image (#1680)",
    "date": "2019-05-02T15:20:34Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/5cad2a62b2f7e0c8b86e427a7c397de804ec6f07",
    "details": {
      "sha": "0bc365de8593443f8d19e393e95e2df6ab960554",
      "filename": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/api/ReproducibleImageTest.java",
      "status": "modified",
      "additions": 67,
      "deletions": 2,
      "changes": 69,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/5cad2a62b2f7e0c8b86e427a7c397de804ec6f07/jib-core%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fapi%2FReproducibleImageTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/5cad2a62b2f7e0c8b86e427a7c397de804ec6f07/jib-core%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fapi%2FReproducibleImageTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fapi%2FReproducibleImageTest.java?ref=5cad2a62b2f7e0c8b86e427a7c397de804ec6f07",
      "patch": "@@ -26,9 +26,12 @@\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Multimap;\n+import com.google.common.io.CharStreams;\n import java.io.File;\n-import java.io.FileInputStream;\n import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.time.Instant;\n@@ -89,6 +92,53 @@ public static void createImage()\n         .containerize(containerizer);\n   }\n \n+  @Test\n+  public void testTarballStructure() throws IOException {\n+    // known content should produce known results\n+    List<String> expected =\n+        ImmutableList.of(\n+            \"c46572ef74f58d95e44dd36c1fbdfebd3752e8b56a794a13c11cfed35a1a6e1c.tar.gz\",\n+            \"6d2763b0f3940d324ea6b55386429e5b173899608abf7d1bff62e25dd2e4dcea.tar.gz\",\n+            \"530c1954a2b087d0b989895ea56435c9dc739a973f2d2b6cb9bb98e55bbea7ac.tar.gz\",\n+            \"config.json\",\n+            \"manifest.json\");\n+\n+    List<String> actual = new ArrayList<>();\n+    try (TarArchiveInputStream input =\n+        new TarArchiveInputStream(Files.newInputStream(imageTar.toPath()))) {\n+      TarArchiveEntry imageEntry;\n+      while ((imageEntry = input.getNextTarEntry()) != null) {\n+        actual.add(imageEntry.getName());\n+      }\n+    }\n+\n+    Assert.assertEquals(expected, actual);\n+  }\n+\n+  @Test\n+  public void testManifest() throws IOException {\n+    try (InputStream input = Files.newInputStream(imageTar.toPath())) {\n+      String exectedManifest =\n+          \"[{\\\"config\\\":\\\"config.json\\\",\\\"repoTags\\\":[\\\"jib-core/reproducible:latest\\\"],\"\n+              + \"\\\"layers\\\":[\\\"c46572ef74f58d95e44dd36c1fbdfebd3752e8b56a794a13c11cfed35a1a6e1c.tar.gz\\\",\\\"6d2763b0f3940d324ea6b55386429e5b173899608abf7d1bff62e25dd2e4dcea.tar.gz\\\",\\\"530c1954a2b087d0b989895ea56435c9dc739a973f2d2b6cb9bb98e55bbea7ac.tar.gz\\\"]}]\";\n+      String generatedManifest = extractFromTarFileAsString(imageTar, \"manifest.json\");\n+      Assert.assertEquals(exectedManifest, generatedManifest);\n+    }\n+  }\n+\n+  @Test\n+  public void testConfiguration() throws IOException {\n+    try (InputStream input = Files.newInputStream(imageTar.toPath())) {\n+      String exectedConfig =\n+          \"{\\\"created\\\":\\\"1970-01-01T00:00:00Z\\\",\\\"architecture\\\":\\\"amd64\\\",\\\"os\\\":\\\"linux\\\",\"\n+              + \"\\\"config\\\":{\\\"Env\\\":[],\\\"Entrypoint\\\":[\\\"echo\\\",\\\"Hello World\\\"],\\\"ExposedPorts\\\":{},\\\"Labels\\\":{},\\\"Volumes\\\":{}},\"\n+              + \"\\\"history\\\":[{\\\"created\\\":\\\"1970-01-01T00:00:00Z\\\",\\\"author\\\":\\\"Jib\\\",\\\"created_by\\\":\\\"jib-core:null\\\",\\\"comment\\\":\\\"\\\"},{\\\"created\\\":\\\"1970-01-01T00:00:00Z\\\",\\\"author\\\":\\\"Jib\\\",\\\"created_by\\\":\\\"jib-core:null\\\",\\\"comment\\\":\\\"\\\"},{\\\"created\\\":\\\"1970-01-01T00:00:00Z\\\",\\\"author\\\":\\\"Jib\\\",\\\"created_by\\\":\\\"jib-core:null\\\",\\\"comment\\\":\\\"\\\"}],\"\n+              + \"\\\"rootfs\\\":{\\\"type\\\":\\\"layers\\\",\\\"diff_ids\\\":[\\\"sha256:18e4f44e6d1835bd968339b166057bd17ab7d4cbb56dc7262a5cafea7cf8d405\\\",\\\"sha256:13369c34f073f2b9c1fa6431e23d925f1a8eac65b1726c8cc8fcc2596c69b414\\\",\\\"sha256:4f92c507112d7880ca0f504ef8272b7fdee107263270125036a260a741565923\\\"]}}\";\n+      String generatedConfig = extractFromTarFileAsString(imageTar, \"config.json\");\n+      Assert.assertEquals(exectedConfig, generatedConfig);\n+    }\n+  }\n+\n   @Test\n   public void testImageLayout() throws IOException {\n     Set<String> paths = new HashSet<>();\n@@ -179,7 +229,8 @@ public void testFileOrdering() throws IOException {\n   private void layerEntriesDo(BiConsumer<String, TarArchiveEntry> layerConsumer)\n       throws IOException {\n \n-    try (TarArchiveInputStream input = new TarArchiveInputStream(new FileInputStream(imageTar))) {\n+    try (TarArchiveInputStream input =\n+        new TarArchiveInputStream(Files.newInputStream(imageTar.toPath()))) {\n       TarArchiveEntry imageEntry;\n       while ((imageEntry = input.getNextTarEntry()) != null) {\n         String imageEntryName = imageEntry.getName();\n@@ -195,4 +246,18 @@ private void layerEntriesDo(BiConsumer<String, TarArchiveEntry> layerConsumer)\n       }\n     }\n   }\n+\n+  private static String extractFromTarFileAsString(File tarFile, String filename)\n+      throws IOException {\n+    try (TarArchiveInputStream input =\n+        new TarArchiveInputStream(Files.newInputStream(tarFile.toPath()))) {\n+      TarArchiveEntry imageEntry;\n+      while ((imageEntry = input.getNextTarEntry()) != null) {\n+        if (filename.equals(imageEntry.getName())) {\n+          return CharStreams.toString(new InputStreamReader(input, StandardCharsets.UTF_8));\n+        }\n+      }\n+    }\n+    throw new AssertionError(\"file not found: \" + filename);\n+  }\n }",
      "parent_sha": "9d5ee513bdeea6009f62d665f98d24bbae235290"
    }
  },
  {
    "oid": "8ed4eeeacacd6979c5a40932d50368f042962ad6",
    "message": "address order permutation in MutuallyExclusiveArgsException (#4093)",
    "date": "2023-09-08T14:30:07Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/8ed4eeeacacd6979c5a40932d50368f042962ad6",
    "details": {
      "sha": "528bdd6f9ae0537e5d695701dada97316ba12f01",
      "filename": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/JarTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/8ed4eeeacacd6979c5a40932d50368f042962ad6/jib-cli%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2FJarTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/8ed4eeeacacd6979c5a40932d50368f042962ad6/jib-cli%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2FJarTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-cli%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2FJarTest.java?ref=8ed4eeeacacd6979c5a40932d50368f042962ad6",
      "patch": "@@ -434,7 +434,7 @@ public void testParse_incompatibleCredentialOptions(String[] authArgs) {\n                     new Jar(), ArrayUtils.addAll(authArgs, \"--target=ignored\", \"my-app.jar\")));\n     assertThat(meae)\n         .hasMessageThat()\n-        .containsMatch(\"^Error: (--(from-|to-)?credential-helper|\\\\[--username)\");\n+        .containsMatch(\"^Error: (\\\\[)*(--(from-|to-)?credential-helper|\\\\[--(username|password))\");\n   }\n \n   @Test",
      "parent_sha": "076650620edc4643d096ba9842ab7598049e00d7"
    }
  },
  {
    "oid": "19c7d1da11fb3fa8379e4c295520cb73fd5f9dc6",
    "message": "Fix typos in usage text for Jar command (#3103)\n\n* Make help text clearer",
    "date": "2021-03-03T16:39:42Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/19c7d1da11fb3fa8379e4c295520cb73fd5f9dc6",
    "details": {
      "sha": "178d9296b2cc2a0fe911ef702938001dfc523fa2",
      "filename": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/Jar.java",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/19c7d1da11fb3fa8379e4c295520cb73fd5f9dc6/jib-cli%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2FJar.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/19c7d1da11fb3fa8379e4c295520cb73fd5f9dc6/jib-cli%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2FJar.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-cli%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2FJar.java?ref=19c7d1da11fb3fa8379e4c295520cb73fd5f9dc6",
      "patch": "@@ -80,37 +80,37 @@ public class Jar implements Callable<Integer> {\n \n   @CommandLine.Option(\n       names = \"--jvm-flags\",\n-      paramLabel = \"<jvm-flags>\",\n+      paramLabel = \"<jvm-flag>\",\n       split = \",\",\n       description = \"JVM arguments, example: --jvm-flags=-Dmy.property=value,-Xshare:off\")\n   private List<String> jvmFlags = Collections.emptyList();\n \n   @CommandLine.Option(\n       names = \"--expose\",\n-      paramLabel = \"<exposed-ports>\",\n+      paramLabel = \"<port>\",\n       split = \",\",\n       description = \"Ports to expose on container, example: --expose=5000,7/udp.\")\n   private List<String> exposedPorts = Collections.emptyList();\n \n   @CommandLine.Option(\n       names = \"--volumes\",\n-      paramLabel = \"<volumes>\",\n+      paramLabel = \"<volume>\",\n       split = \",\",\n       description =\n           \"Directories on container to hold extra volumes,  example: --volumes=/var/log,/var/log2.\")\n   private List<String> volumes = Collections.emptyList();\n \n   @CommandLine.Option(\n       names = \"--environment-variables\",\n-      paramLabel = \"<environment-variables>\",\n+      paramLabel = \"<key>=<value>\",\n       split = \",\",\n       description =\n           \"Environment variables to write into container, example: --environment-variables env1=env_value1,env2=env_value2.\")\n   private Map<String, String> environment = Collections.emptyMap();\n \n   @CommandLine.Option(\n       names = \"--labels\",\n-      paramLabel = \"<labels>\",\n+      paramLabel = \"<key>=<value>\",\n       split = \",\",\n       description =\n           \"Labels to write into container metadata, example: --labels=label1=value1,label2=value2.\")\n@@ -134,7 +134,7 @@ public class Jar implements Callable<Integer> {\n \n   @CommandLine.Option(\n       names = \"--program-args\",\n-      paramLabel = \"<program-arguments>\",\n+      paramLabel = \"<program-argument>\",\n       split = \",\",\n       description = \"Program arguments for container entrypoint.\")\n   private List<String> programArguments = Collections.emptyList();",
      "parent_sha": "d23a0ac7e82acfe95faa6996599eb5fd1b02cad5"
    }
  },
  {
    "oid": "5344b59c3785a662d3240a4098426c0f28ec7b40",
    "message": "Disable mount+from (#833)",
    "date": "2018-08-13T19:35:56Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/5344b59c3785a662d3240a4098426c0f28ec7b40",
    "details": {
      "sha": "5fb0210d00003b92805b395c27281249a099fd8f",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PushBlobStep.java",
      "status": "modified",
      "additions": 2,
      "deletions": 12,
      "changes": 14,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/5344b59c3785a662d3240a4098426c0f28ec7b40/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPushBlobStep.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/5344b59c3785a662d3240a4098426c0f28ec7b40/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPushBlobStep.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPushBlobStep.java?ref=5344b59c3785a662d3240a4098426c0f28ec7b40",
      "patch": "@@ -86,18 +86,8 @@ public BlobDescriptor call() throws IOException, RegistryException, ExecutionExc\n         return blobDescriptor;\n       }\n \n-      // If base and target images are in the same registry, then use mount/from to try mounting the\n-      // BLOB from the base image repository to the target image repository and possibly avoid\n-      // having to push the BLOB. See\n-      // https://docs.docker.com/registry/spec/api/#cross-repository-blob-mount for details.\n-      boolean sameRegistry =\n-          buildConfiguration\n-              .getBaseImageConfiguration()\n-              .getImageRegistry()\n-              .equals(buildConfiguration.getTargetImageConfiguration().getImageRegistry());\n-      String mountFrom =\n-          sameRegistry ? buildConfiguration.getBaseImageConfiguration().getImageRepository() : null;\n-      registryClient.pushBlob(blobDescriptor.getDigest(), blob, mountFrom);\n+      // todo: leverage cross-repository mounts\n+      registryClient.pushBlob(blobDescriptor.getDigest(), blob, null);\n \n       return blobDescriptor;\n     }",
      "parent_sha": "d49a3425b0118c803b3f1a4221e60d8cc24cab3c"
    }
  },
  {
    "oid": "1fd6b62c90bb96a53fdc719265c4224157810361",
    "message": "rename field port to fix for sonar. (#3385)\n\nfixes sonar code smell.\r\n\r\nchanged name for private variable, and leaving public interface unchanged.",
    "date": "2021-08-05T16:36:24Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/1fd6b62c90bb96a53fdc719265c4224157810361",
    "details": {
      "sha": "7bd1e91f7fa385c86424fbe096f1a41600e1eba9",
      "filename": "jib-build-plan/src/main/java/com/google/cloud/tools/jib/api/buildplan/Port.java",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/1fd6b62c90bb96a53fdc719265c4224157810361/jib-build-plan%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fapi%2Fbuildplan%2FPort.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/1fd6b62c90bb96a53fdc719265c4224157810361/jib-build-plan%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fapi%2Fbuildplan%2FPort.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-build-plan%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fapi%2Fbuildplan%2FPort.java?ref=1fd6b62c90bb96a53fdc719265c4224157810361",
      "patch": "@@ -59,11 +59,11 @@ public static Port parseProtocol(int port, String protocolString) {\n     return new Port(port, protocol);\n   }\n \n-  private final int port;\n+  private final int portNumber;\n   private final String protocol;\n \n-  private Port(int port, String protocol) {\n-    this.port = port;\n+  private Port(int portNumber, String protocol) {\n+    this.portNumber = portNumber;\n     this.protocol = protocol;\n   }\n \n@@ -73,7 +73,7 @@ private Port(int port, String protocol) {\n    * @return the port number\n    */\n   public int getPort() {\n-    return port;\n+    return portNumber;\n   }\n \n   /**\n@@ -94,12 +94,12 @@ public boolean equals(Object other) {\n       return false;\n     }\n     Port otherPort = (Port) other;\n-    return port == otherPort.port && protocol.equals(otherPort.protocol);\n+    return portNumber == otherPort.portNumber && protocol.equals(otherPort.protocol);\n   }\n \n   @Override\n   public int hashCode() {\n-    return Objects.hash(port, protocol);\n+    return Objects.hash(portNumber, protocol);\n   }\n \n   /**\n@@ -110,6 +110,6 @@ public int hashCode() {\n    */\n   @Override\n   public String toString() {\n-    return port + \"/\" + protocol;\n+    return portNumber + \"/\" + protocol;\n   }\n }",
      "parent_sha": "bcaa9bc1b127a3b030bd054a026ca321faf98739"
    }
  },
  {
    "oid": "18d5c77392964ee417ba563084fe8335cb90a11c",
    "message": "fix: address windows deadlock issue when determining docker environment info (#4288)",
    "date": "2024-07-19T18:53:26Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/18d5c77392964ee417ba563084fe8335cb90a11c",
    "details": {
      "sha": "d3dcecd883b5295de9633bd3db1e4cb8680cabcf",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/docker/CliDockerClient.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/18d5c77392964ee417ba563084fe8335cb90a11c/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fdocker%2FCliDockerClient.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/18d5c77392964ee417ba563084fe8335cb90a11c/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fdocker%2FCliDockerClient.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fdocker%2FCliDockerClient.java?ref=18d5c77392964ee417ba563084fe8335cb90a11c",
      "patch": "@@ -189,11 +189,12 @@ public boolean supported(Map<String, String> parameters) {\n   public DockerInfoDetails info() throws IOException, InterruptedException {\n     // Runs 'docker info'.\n     Process infoProcess = docker(\"info\", \"-f\", \"{{json .}}\");\n+    InputStream inputStream = infoProcess.getInputStream();\n     if (infoProcess.waitFor() != 0) {\n       throw new IOException(\n           \"'docker info' command failed with error: \" + getStderrOutput(infoProcess));\n     }\n-    return JsonTemplateMapper.readJson(infoProcess.getInputStream(), DockerInfoDetails.class);\n+    return JsonTemplateMapper.readJson(inputStream, DockerInfoDetails.class);\n   }\n \n   @Override",
      "parent_sha": "ff15988e5eb36c686e7db47abb31bdc15c88f44a"
    }
  },
  {
    "oid": "29f4ad8d1b80fc718a674598e4231a6951ede9e1",
    "message": "Fix ManifestPusherTest warnings (#941)",
    "date": "2018-09-05T21:30:03Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/29f4ad8d1b80fc718a674598e4231a6951ede9e1",
    "details": {
      "sha": "2f9f971325b5789d98d249ad590c2a3f5b9e1be4",
      "filename": "jib-core/src/test/java/com/google/cloud/tools/jib/registry/ManifestPusherTest.java",
      "status": "modified",
      "additions": 6,
      "deletions": 16,
      "changes": 22,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/29f4ad8d1b80fc718a674598e4231a6951ede9e1/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FManifestPusherTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/29f4ad8d1b80fc718a674598e4231a6951ede9e1/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FManifestPusherTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FManifestPusherTest.java?ref=29f4ad8d1b80fc718a674598e4231a6951ede9e1",
      "patch": "@@ -108,7 +108,8 @@ public void testGetAccept() {\n \n   /** Docker Registry 2.0 and 2.1 return 400 / TAG_INVALID. */\n   @Test\n-  public void testHandleHttpResponseException_dockerRegistry_tagInvalid() {\n+  public void testHandleHttpResponseException_dockerRegistry_tagInvalid()\n+      throws HttpResponseException {\n     HttpResponseException exception =\n         new HttpResponseException.Builder(\n                 HttpStatus.SC_BAD_REQUEST, \"Bad Request\", new HttpHeaders())\n@@ -124,15 +125,13 @@ public void testHandleHttpResponseException_dockerRegistry_tagInvalid() {\n           ex.getMessage(),\n           CoreMatchers.containsString(\n               \"Registry may not support Image Manifest Version 2, Schema 2\"));\n-\n-    } catch (HttpResponseException ex) {\n-      Assert.fail(\"should have been a RegistryErrorException\");\n     }\n   }\n \n   /** Docker Registry 2.2 returns a 400 / MANIFEST_INVALID. */\n   @Test\n-  public void testHandleHttpResponseException_dockerRegistry_manifestInvalid() {\n+  public void testHandleHttpResponseException_dockerRegistry_manifestInvalid()\n+      throws HttpResponseException {\n     HttpResponseException exception =\n         new HttpResponseException.Builder(\n                 HttpStatus.SC_BAD_REQUEST, \"Bad Request\", new HttpHeaders())\n@@ -148,15 +147,12 @@ public void testHandleHttpResponseException_dockerRegistry_manifestInvalid() {\n           ex.getMessage(),\n           CoreMatchers.containsString(\n               \"Registry may not support Image Manifest Version 2, Schema 2\"));\n-\n-    } catch (HttpResponseException ex) {\n-      Assert.fail(\"should have been a RegistryErrorException\");\n     }\n   }\n \n   /** Quay.io returns an undocumented 415 / MANIFEST_INVALID. */\n   @Test\n-  public void testHandleHttpResponseException_quayIo() {\n+  public void testHandleHttpResponseException_quayIo() throws HttpResponseException {\n     HttpResponseException exception =\n         new HttpResponseException.Builder(\n                 HttpStatus.SC_UNSUPPORTED_MEDIA_TYPE, \"UNSUPPORTED MEDIA TYPE\", new HttpHeaders())\n@@ -173,14 +169,11 @@ public void testHandleHttpResponseException_quayIo() {\n           ex.getMessage(),\n           CoreMatchers.containsString(\n               \"Registry may not support Image Manifest Version 2, Schema 2\"));\n-\n-    } catch (HttpResponseException ex) {\n-      Assert.fail(\"should have been a RegistryErrorException\");\n     }\n   }\n \n   @Test\n-  public void testHandleHttpResponseException_otherError() {\n+  public void testHandleHttpResponseException_otherError() throws RegistryErrorException {\n     HttpResponseException exception =\n         new HttpResponseException.Builder(\n                 HttpStatus.SC_UNAUTHORIZED, \"Unauthorized\", new HttpHeaders())\n@@ -190,9 +183,6 @@ public void testHandleHttpResponseException_otherError() {\n       testManifestPusher.handleHttpResponseException(exception);\n       Assert.fail();\n \n-    } catch (RegistryErrorException ex) {\n-      Assert.fail(\"should have been a HttpResponseException\");\n-\n     } catch (HttpResponseException ex) {\n       Assert.assertSame(exception, ex);\n     }",
      "parent_sha": "f68833ebf3732a680cb2ae966979f8d0c46d7cdd"
    }
  },
  {
    "oid": "4ed43b8f02504754a9b0ab94fd0eed740f7ed179",
    "message": "obtainBaseImageLayers for multiple images (#2646)\n\n* Adding functionality to concurrently pull layers for multiple images .",
    "date": "2020-07-31T18:20:41Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/4ed43b8f02504754a9b0ab94fd0eed740f7ed179",
    "details": {
      "sha": "841193816a6217f529db16ad3e5db3056e75a637",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java",
      "status": "modified",
      "additions": 49,
      "deletions": 25,
      "changes": 74,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/4ed43b8f02504754a9b0ab94fd0eed740f7ed179/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FStepsRunner.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/4ed43b8f02504754a9b0ab94fd0eed740f7ed179/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FStepsRunner.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FStepsRunner.java?ref=4ed43b8f02504754a9b0ab94fd0eed740f7ed179",
      "patch": "@@ -37,7 +37,10 @@\n import com.google.common.util.concurrent.MoreExecutors;\n import java.nio.file.Path;\n import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutionException;\n@@ -63,8 +66,8 @@ private static <E> Future<E> failedFuture() {\n           new IllegalStateException(\"invalid usage; required step not configured\"));\n     }\n \n-    private Future<ImagesAndRegistryClient> baseImageAndRegistryClient = failedFuture();\n-    private Future<List<Future<PreparedLayer>>> baseImageLayers = failedFuture();\n+    private Future<ImagesAndRegistryClient> baseImagesAndRegistryClient = failedFuture();\n+    private Future<Map<Image, List<Future<PreparedLayer>>>> baseImagesAndLayers = failedFuture();\n     @Nullable private List<Future<PreparedLayer>> applicationLayers;\n     private Future<Image> builtImage = failedFuture();\n     private Future<RegistryClient> targetRegistryClient = failedFuture();\n@@ -271,44 +274,56 @@ private void extractTar() {\n   }\n \n   private void assignLocalImageResult(Future<LocalImage> localImage) {\n-    results.baseImageLayers = executorService.submit(() -> localImage.get().layers);\n-    results.baseImageAndRegistryClient =\n+    results.baseImagesAndRegistryClient =\n         executorService.submit(\n             () ->\n                 LocalBaseImageSteps.returnImageAndRegistryClientStep(\n-                        realizeFutures(results.baseImageLayers.get()),\n+                        realizeFutures(localImage.get().layers),\n                         localImage.get().configurationTemplate)\n                     .call());\n+\n+    results.baseImagesAndLayers =\n+        executorService.submit(\n+            () ->\n+                Collections.singletonMap(\n+                    results.baseImagesAndRegistryClient.get().images.get(0),\n+                    localImage.get().layers));\n   }\n \n   private void pullBaseImage() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.baseImageAndRegistryClient =\n+    results.baseImagesAndRegistryClient =\n         executorService.submit(new PullBaseImageStep(buildContext, childProgressDispatcherFactory));\n   }\n \n   private void obtainBaseImageLayers(boolean layersRequiredLocally) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n-\n-    results.baseImageLayers =\n+    results.baseImagesAndLayers =\n         executorService.submit(\n-            () ->\n-                scheduleCallables(\n-                    layersRequiredLocally\n-                        ? ObtainBaseImageLayerStep.makeListForForcedDownload(\n-                            buildContext,\n-                            childProgressDispatcherFactory,\n-                            results.baseImageAndRegistryClient.get().images.get(0),\n-                            results.baseImageAndRegistryClient.get().registryClient)\n-                        : ObtainBaseImageLayerStep.makeListForSelectiveDownload(\n-                            buildContext,\n-                            childProgressDispatcherFactory,\n-                            results.baseImageAndRegistryClient.get().images.get(0),\n-                            results.baseImageAndRegistryClient.get().registryClient,\n-                            results.targetRegistryClient.get())));\n+            () -> {\n+              Map<Image, List<Future<PreparedLayer>>> baseImagesAndLayers = new HashMap<>();\n+              for (Image image : results.baseImagesAndRegistryClient.get().images) {\n+                List<Future<PreparedLayer>> layers =\n+                    scheduleCallables(\n+                        layersRequiredLocally\n+                            ? ObtainBaseImageLayerStep.makeListForForcedDownload(\n+                                buildContext,\n+                                childProgressDispatcherFactory,\n+                                image,\n+                                results.baseImagesAndRegistryClient.get().registryClient)\n+                            : ObtainBaseImageLayerStep.makeListForSelectiveDownload(\n+                                buildContext,\n+                                childProgressDispatcherFactory,\n+                                image,\n+                                results.baseImagesAndRegistryClient.get().registryClient,\n+                                results.targetRegistryClient.get()));\n+                baseImagesAndLayers.put(image, layers);\n+              }\n+              return baseImagesAndLayers;\n+            });\n   }\n \n   private void pushBaseImageLayers() {\n@@ -323,7 +338,11 @@ private void pushBaseImageLayers() {\n                         buildContext,\n                         childProgressDispatcherFactory,\n                         results.targetRegistryClient.get(),\n-                        results.baseImageLayers.get())));\n+                        Verify.verifyNotNull(\n+                            results\n+                                .baseImagesAndLayers\n+                                .get()\n+                                .get(results.baseImagesAndRegistryClient.get().images.get(0))))));\n   }\n \n   private void buildAndCacheApplicationLayers() {\n@@ -346,8 +365,13 @@ private void buildImage() {\n                 new BuildImageStep(\n                         buildContext,\n                         childProgressDispatcherFactory,\n-                        results.baseImageAndRegistryClient.get().images.get(0),\n-                        realizeFutures(results.baseImageLayers.get()),\n+                        results.baseImagesAndRegistryClient.get().images.get(0),\n+                        realizeFutures(\n+                            Verify.verifyNotNull(\n+                                results\n+                                    .baseImagesAndLayers\n+                                    .get()\n+                                    .get(results.baseImagesAndRegistryClient.get().images.get(0)))),\n                         realizeFutures(Verify.verifyNotNull(results.applicationLayers)))\n                     .call());\n   }",
      "parent_sha": "f2484f26197faa32f2dab5097e33a373ae5466c1"
    }
  },
  {
    "oid": "c7fe0962f3aa0fb8f574abb3260a8e0bad592507",
    "message": "Fix incomplete progress dispatching in PullBaseImageStep (#2914)\n\n* Fix incomplete progress\r\n\r\n* Format comment",
    "date": "2020-12-04T15:10:22Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/c7fe0962f3aa0fb8f574abb3260a8e0bad592507",
    "details": {
      "sha": "61c40f259cb26b2e184a1c9422e129057dd2db70",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java",
      "status": "modified",
      "additions": 38,
      "deletions": 37,
      "changes": 75,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/c7fe0962f3aa0fb8f574abb3260a8e0bad592507/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPullBaseImageStep.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/c7fe0962f3aa0fb8f574abb3260a8e0bad592507/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPullBaseImageStep.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPullBaseImageStep.java?ref=c7fe0962f3aa0fb8f574abb3260a8e0bad592507",
      "patch": "@@ -95,47 +95,48 @@ public ImagesAndRegistryClient call()\n           LayerCountMismatchException, BadContainerConfigurationFormatException,\n           CacheCorruptedException, CredentialRetrievalException {\n     EventHandlers eventHandlers = buildContext.getEventHandlers();\n-    // Skip this step if this is a scratch image\n-    ImageReference imageReference = buildContext.getBaseImageConfiguration().getImage();\n-    if (imageReference.isScratch()) {\n-      Set<Platform> platforms = buildContext.getContainerConfiguration().getPlatforms();\n-      Verify.verify(!platforms.isEmpty());\n-\n-      eventHandlers.dispatch(LogEvent.progress(\"Getting scratch base image...\"));\n-      ImmutableList.Builder<Image> images = ImmutableList.builder();\n-      for (Platform platform : platforms) {\n-        Image.Builder imageBuilder = Image.builder(buildContext.getTargetFormat());\n-        imageBuilder.setArchitecture(platform.getArchitecture()).setOs(platform.getOs());\n-        images.add(imageBuilder.build());\n+    try (ProgressEventDispatcher progressEventDispatcher =\n+            progressEventDispatcherFactory.create(\"pulling base image manifest\", 2);\n+        TimerEventDispatcher ignored1 = new TimerEventDispatcher(eventHandlers, DESCRIPTION)) {\n+\n+      // Skip this step if this is a scratch image\n+      ImageReference imageReference = buildContext.getBaseImageConfiguration().getImage();\n+      if (imageReference.isScratch()) {\n+        Set<Platform> platforms = buildContext.getContainerConfiguration().getPlatforms();\n+        Verify.verify(!platforms.isEmpty());\n+\n+        eventHandlers.dispatch(LogEvent.progress(\"Getting scratch base image...\"));\n+        ImmutableList.Builder<Image> images = ImmutableList.builder();\n+        for (Platform platform : platforms) {\n+          Image.Builder imageBuilder = Image.builder(buildContext.getTargetFormat());\n+          imageBuilder.setArchitecture(platform.getArchitecture()).setOs(platform.getOs());\n+          images.add(imageBuilder.build());\n+        }\n+        return new ImagesAndRegistryClient(images.build(), null);\n       }\n-      return new ImagesAndRegistryClient(images.build(), null);\n-    }\n \n-    eventHandlers.dispatch(\n-        LogEvent.progress(\"Getting manifest for base image \" + imageReference + \"...\"));\n+      eventHandlers.dispatch(\n+          LogEvent.progress(\"Getting manifest for base image \" + imageReference + \"...\"));\n \n-    if (buildContext.isOffline()) {\n-      List<Image> images = getCachedBaseImages();\n-      if (!images.isEmpty()) {\n-        return new ImagesAndRegistryClient(images, null);\n-      }\n-      throw new IOException(\n-          \"Cannot run Jib in offline mode; \" + imageReference + \" not found in local Jib cache\");\n-\n-    } else if (imageReference.getDigest().isPresent()) {\n-      List<Image> images = getCachedBaseImages();\n-      if (!images.isEmpty()) {\n-        RegistryClient noAuthRegistryClient =\n-            buildContext.newBaseImageRegistryClientFactory().newRegistryClient();\n-        // TODO: passing noAuthRegistryClient may be problematic. It may return 401 unauthorized if\n-        // layers have to be downloaded. https://github.com/GoogleContainerTools/jib/issues/2220\n-        return new ImagesAndRegistryClient(images, noAuthRegistryClient);\n+      if (buildContext.isOffline()) {\n+        List<Image> images = getCachedBaseImages();\n+        if (!images.isEmpty()) {\n+          return new ImagesAndRegistryClient(images, null);\n+        }\n+        throw new IOException(\n+            \"Cannot run Jib in offline mode; \" + imageReference + \" not found in local Jib cache\");\n+\n+      } else if (imageReference.getDigest().isPresent()) {\n+        List<Image> images = getCachedBaseImages();\n+        if (!images.isEmpty()) {\n+          RegistryClient noAuthRegistryClient =\n+              buildContext.newBaseImageRegistryClientFactory().newRegistryClient();\n+          // TODO: passing noAuthRegistryClient may be problematic. It may return 401 unauthorized\n+          // if layers have to be downloaded.\n+          // https://github.com/GoogleContainerTools/jib/issues/2220\n+          return new ImagesAndRegistryClient(images, noAuthRegistryClient);\n+        }\n       }\n-    }\n-\n-    try (ProgressEventDispatcher progressEventDispatcher =\n-            progressEventDispatcherFactory.create(\"pulling base image manifest\", 2);\n-        TimerEventDispatcher ignored1 = new TimerEventDispatcher(eventHandlers, DESCRIPTION)) {\n \n       // First, try with no credentials. This works with public GCR images (but not Docker Hub).\n       // TODO: investigate if we should just pass credentials up front. However, this involves",
      "parent_sha": "b9cd564f35915370c8bf422477d97b30a1caa7ea"
    }
  },
  {
    "oid": "bb1afe2a9cab2b77a0b836d86d30cf40ff2769cc",
    "message": "Fix error message (#3122)",
    "date": "2021-03-09T19:03:33Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/bb1afe2a9cab2b77a0b836d86d30cf40ff2769cc",
    "details": {
      "sha": "920578cfa4bd709bc1810eefbbce7ff4456eaa77",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/bb1afe2a9cab2b77a0b836d86d30cf40ff2769cc/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPullBaseImageStep.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/bb1afe2a9cab2b77a0b836d86d30cf40ff2769cc/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPullBaseImageStep.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPullBaseImageStep.java?ref=bb1afe2a9cab2b77a0b836d86d30cf40ff2769cc",
      "patch": "@@ -367,15 +367,14 @@ String lookUpPlatformSpecificImageManifest(\n     List<String> digests =\n         manifestListTemplate.getDigestsForPlatform(platform.getArchitecture(), platform.getOs());\n     if (digests.size() == 0) {\n-      String errorMessage =\n+      String errorTemplate =\n           buildContext.getBaseImageConfiguration().getImage()\n               + \" is a manifest list, but the list does not contain an image for architecture=%s, \"\n               + \"os=%s. If your intention was to specify a platform for your image, see \"\n               + \"https://github.com/GoogleContainerTools/jib/blob/master/docs/faq.md#how-do-i-specify-a-platform-in-the-manifest-list-or-oci-index-of-a-base-image\";\n-      eventHandlers.dispatch(\n-          LogEvent.error(\n-              String.format(errorMessage, platform.getArchitecture(), platform.getOs())));\n-      throw new UnlistedPlatformInManifestListException(errorMessage);\n+      String error = String.format(errorTemplate, platform.getArchitecture(), platform.getOs());\n+      eventHandlers.dispatch(LogEvent.error(error));\n+      throw new UnlistedPlatformInManifestListException(error);\n     }\n     // TODO: perhaps we should return multiple digests matching the platform.\n     return digests.get(0);",
      "parent_sha": "5421070481ee70c6669bc1ae2cdf8c2e2ee1c633"
    }
  },
  {
    "oid": "e858464cd84f2721d0729aad1099e08ed933e3b1",
    "message": "Ignores InsecureRecursiveDeleteException. (#367)",
    "date": "2018-06-05T23:19:47Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/e858464cd84f2721d0729aad1099e08ed933e3b1",
    "details": {
      "sha": "0e32e5ad392274165a38fc369f95aa9b681ae5b6",
      "filename": "jib-gradle-plugin/src/integration-test/java/com/google/cloud/tools/jib/gradle/JibPluginIntegrationTest.java",
      "status": "modified",
      "additions": 14,
      "deletions": 4,
      "changes": 18,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/e858464cd84f2721d0729aad1099e08ed933e3b1/jib-gradle-plugin%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FJibPluginIntegrationTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/e858464cd84f2721d0729aad1099e08ed933e3b1/jib-gradle-plugin%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FJibPluginIntegrationTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-gradle-plugin%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FJibPluginIntegrationTest.java?ref=e858464cd84f2721d0729aad1099e08ed933e3b1",
      "patch": "@@ -157,9 +157,19 @@ public void testDockerContext() throws IOException, InterruptedException {\n             .resolve(\"main\")\n             .resolve(\"resources\")\n             .resolve(\"newfile\"));\n-    BuildTask reexecutedJibDockerContextTask =\n-        simpleTestProject.build(\"jibDockerContext\").task(\":jibDockerContext\");\n-    Assert.assertNotNull(reexecutedJibDockerContextTask);\n-    Assert.assertEquals(TaskOutcome.SUCCESS, reexecutedJibDockerContextTask.getOutcome());\n+    try {\n+      BuildTask reexecutedJibDockerContextTask =\n+          simpleTestProject.build(\"jibDockerContext\").task(\":jibDockerContext\");\n+      Assert.assertNotNull(reexecutedJibDockerContextTask);\n+      Assert.assertEquals(TaskOutcome.SUCCESS, reexecutedJibDockerContextTask.getOutcome());\n+\n+    } catch (UnexpectedBuildFailure ex) {\n+      // THis might happen on systems without SecureDirectoryStream, so we just ignore it.\n+      // See com.google.common.io.MoreFiles#deleteDirectoryContents.\n+      Assert.assertThat(\n+          ex.getMessage(),\n+          CoreMatchers.containsString(\n+              \"Export Docker context failed because cannot clear directory\"));\n+    }\n   }\n }",
      "parent_sha": "302e280666f17f7b267751b0dc1ddf9514f1ffa9"
    }
  },
  {
    "oid": "2d621a4864a50ed117238c876e99fdf3cf52a8de",
    "message": "Clean up some Parameterized tests (#2841)",
    "date": "2020-10-19T18:09:07Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/2d621a4864a50ed117238c876e99fdf3cf52a8de",
    "details": {
      "sha": "0c170a92d204160612fa07b7dda597acf0f56c7c",
      "filename": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/cli2/JibCliTest.java",
      "status": "modified",
      "additions": 62,
      "deletions": 79,
      "changes": 141,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/2d621a4864a50ed117238c876e99fdf3cf52a8de/jib-cli%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2Fcli2%2FJibCliTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/2d621a4864a50ed117238c876e99fdf3cf52a8de/jib-cli%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2Fcli2%2FJibCliTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-cli%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2Fcli2%2FJibCliTest.java?ref=2d621a4864a50ed117238c876e99fdf3cf52a8de",
      "patch": "@@ -25,16 +25,16 @@\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n import java.nio.file.Paths;\n-import java.util.Arrays;\n-import java.util.Collection;\n+import junitparams.JUnitParamsRunner;\n+import junitparams.Parameters;\n import org.apache.commons.lang3.ArrayUtils;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n import picocli.CommandLine;\n import picocli.CommandLine.MissingParameterException;\n import picocli.CommandLine.MutuallyExclusiveArgsException;\n \n+@RunWith(JUnitParamsRunner.class)\n public class JibCliTest {\n   @Test\n   public void testParse_missingRequiredParams() {\n@@ -329,83 +329,66 @@ public void testParse_toCredentialHelperAndFromUsernamePassword() {\n         .hasValue(Credential.from(\"test-username\", \"test-password\"));\n   }\n \n-  @RunWith(Parameterized.class)\n-  public static class UsernamePasswordBothRequired {\n-    @Parameterized.Parameters(name = \"{0},{1}\")\n-    public static Collection<Object[]> data() {\n-      return Arrays.asList(\n-          new Object[][] {\n-            {\"--username\", \"--password\"},\n-            {\"--to-username\", \"--to-password\"},\n-            {\"--from-username\", \"--from-password\"}\n-          });\n-    }\n-\n-    @Parameterized.Parameter(0)\n-    public String usernameField;\n-\n-    @Parameterized.Parameter(1)\n-    public String passwordField;\n-\n-    @Test\n-    public void testParse_usernameWithoutPassword() {\n-      MissingParameterException mpe =\n-          assertThrows(\n-              MissingParameterException.class,\n-              () ->\n-                  CommandLine.populateCommand(\n-                      new JibCli(), \"--target\", \"test-image-ref\", usernameField, \"test-username\"));\n-      assertThat(mpe.getMessage())\n-          .isEqualTo(\"Error: Missing required argument(s): \" + passwordField);\n-    }\n-\n-    @Test\n-    public void testParse_passwordWithoutUsername() {\n-      MissingParameterException mpe =\n-          assertThrows(\n-              MissingParameterException.class,\n-              () ->\n-                  CommandLine.populateCommand(\n-                      new JibCli(), \"--target\", \"test-image-ref\", passwordField, \"test-password\"));\n-      assertThat(mpe.getMessage())\n-          .isEqualTo(\"Error: Missing required argument(s): \" + usernameField + \"=<username>\");\n-    }\n+  private Object usernamePasswordPairs() {\n+    return new Object[][] {\n+      {\"--username\", \"--password\"},\n+      {\"--to-username\", \"--to-password\"},\n+      {\"--from-username\", \"--from-password\"}\n+    };\n   }\n \n-  @RunWith(Parameterized.class)\n-  public static class IncompatibleCredentialCombos {\n-    @Parameterized.Parameters\n-    public static Collection<String[][]> data() {\n-      return Arrays.asList(\n-          new String[][][] {\n-            {{\"--credential-helper=x\", \"--to-credential-helper=x\"}},\n-            {{\"--credential-helper=x\", \"--from-credential-helper=x\"}},\n-            {{\"--credential-helper=x\", \"--username=x\", \"--password=x\"}},\n-            {{\"--credential-helper=x\", \"--from-username=x\", \"--from-password=x\"}},\n-            {{\"--credential-helper=x\", \"--to-username=x\", \"--to-password=x\"}},\n-            {{\"--username=x\", \"--password=x\", \"--from-username=x\", \"--from-password=x\"}},\n-            {{\"--username=x\", \"--password=x\", \"--to-username=x\", \"--to-password=x\"}},\n-            {{\"--username=x\", \"--password=x\", \"--to-credential-helper=x\"}},\n-            {{\"--username=x\", \"--password=x\", \"--from-credential-helper=x\"}},\n-            {{\"--from-credential-helper=x\", \"--from-username=x\", \"--from-password=x\"}},\n-            {{\"--to-credential-helper=x\", \"--to-password=x\", \"--to-username=x\"}},\n-          });\n-    }\n-\n-    @Parameterized.Parameter public String[] authArgs;\n-    private final String[] requiredArgs = new String[] {\"--target=ignored\"};\n-\n-    @Test\n-    public void testParse_usernameWithoutPassword() {\n-      MutuallyExclusiveArgsException meae =\n-          assertThrows(\n-              MutuallyExclusiveArgsException.class,\n-              () ->\n-                  CommandLine.populateCommand(\n-                      new JibCli(), ArrayUtils.addAll(requiredArgs, authArgs)));\n-      assertThat(meae)\n-          .hasMessageThat()\n-          .containsMatch(\"^Error: (--(from-|to-)?credential-helper|\\\\[--username)\");\n-    }\n+  @Test\n+  @Parameters(method = \"usernamePasswordPairs\")\n+  public void testParse_usernameWithoutPassword(String usernameField, String passwordField) {\n+    MissingParameterException mpe =\n+        assertThrows(\n+            MissingParameterException.class,\n+            () ->\n+                CommandLine.populateCommand(\n+                    new JibCli(), \"--target\", \"test-image-ref\", usernameField, \"test-username\"));\n+    assertThat(mpe.getMessage()).isEqualTo(\"Error: Missing required argument(s): \" + passwordField);\n+  }\n+\n+  @Test\n+  @Parameters(method = \"usernamePasswordPairs\")\n+  public void testParse_passwordWithoutUsername(String usernameField, String passwordField) {\n+    MissingParameterException mpe =\n+        assertThrows(\n+            MissingParameterException.class,\n+            () ->\n+                CommandLine.populateCommand(\n+                    new JibCli(), \"--target\", \"test-image-ref\", passwordField, \"test-password\"));\n+    assertThat(mpe.getMessage())\n+        .isEqualTo(\"Error: Missing required argument(s): \" + usernameField + \"=<username>\");\n+  }\n+\n+  public Object incompatibleCredentialOptions() {\n+    return new Object[] {\n+      new String[] {\"--credential-helper=x\", \"--to-credential-helper=x\"},\n+      new String[] {\"--credential-helper=x\", \"--from-credential-helper=x\"},\n+      new String[] {\"--credential-helper=x\", \"--username=x\", \"--password=x\"},\n+      new String[] {\"--credential-helper=x\", \"--from-username=x\", \"--from-password=x\"},\n+      new String[] {\"--credential-helper=x\", \"--to-username=x\", \"--to-password=x\"},\n+      new String[] {\"--username=x\", \"--password=x\", \"--from-username=x\", \"--from-password=x\"},\n+      new String[] {\"--username=x\", \"--password=x\", \"--to-username=x\", \"--to-password=x\"},\n+      new String[] {\"--username=x\", \"--password=x\", \"--to-credential-helper=x\"},\n+      new String[] {\"--username=x\", \"--password=x\", \"--from-credential-helper=x\"},\n+      new String[] {\"--from-credential-helper=x\", \"--from-username=x\", \"--from-password=x\"},\n+      new String[] {\"--to-credential-helper=x\", \"--to-password=x\", \"--to-username=x\"},\n+    };\n+  }\n+\n+  @Test\n+  @Parameters(method = \"incompatibleCredentialOptions\")\n+  public void testParse_incompatibleCredentialOptions(String[] authArgs) {\n+    MutuallyExclusiveArgsException meae =\n+        assertThrows(\n+            MutuallyExclusiveArgsException.class,\n+            () ->\n+                CommandLine.populateCommand(\n+                    new JibCli(), ArrayUtils.add(authArgs, \"--target=ignored\")));\n+    assertThat(meae)\n+        .hasMessageThat()\n+        .containsMatch(\"^Error: (--(from-|to-)?credential-helper|\\\\[--username)\");\n   }\n }",
      "parent_sha": "d12437c05ab8b11ed7988b411db9f034a8a38968"
    }
  },
  {
    "oid": "c62012230f7e48e86160db37e2e599b53abbfd0c",
    "message": "Fix integration test after changing base image (#3186)",
    "date": "2021-04-05T19:37:30Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/c62012230f7e48e86160db37e2e599b53abbfd0c",
    "details": {
      "sha": "b31850671569c9dbf47e4e4459bbffe1847982db",
      "filename": "jib-maven-plugin/src/integration-test/java/com/google/cloud/tools/jib/maven/BuildImageMojoIntegrationTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/c62012230f7e48e86160db37e2e599b53abbfd0c/jib-maven-plugin%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FBuildImageMojoIntegrationTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/c62012230f7e48e86160db37e2e599b53abbfd0c/jib-maven-plugin%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FBuildImageMojoIntegrationTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-maven-plugin%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FBuildImageMojoIntegrationTest.java?ref=c62012230f7e48e86160db37e2e599b53abbfd0c",
      "patch": "@@ -497,7 +497,7 @@ public void testExecute_empty()\n     Assert.assertEquals(\n         \"\", buildAndRun(emptyTestProject.getProjectRoot(), targetImage, \"pom.xml\", false));\n     assertThat(getCreationTime(targetImage)).isEqualTo(Instant.EPOCH);\n-    assertThat(getWorkingDirectory(targetImage)).isEqualTo(\"/\");\n+    assertThat(getWorkingDirectory(targetImage)).isEmpty();\n   }\n \n   @Test",
      "parent_sha": "6569f2f2ae0ae7fb7f81a60fef06022ff21b43fb"
    }
  },
  {
    "oid": "fb29e86b99ff124ccf7f64e24b366d2862f95d6c",
    "message": "Small cleanup (#2167)",
    "date": "2019-11-20T17:08:44Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/fb29e86b99ff124ccf7f64e24b366d2862f95d6c",
    "details": {
      "sha": "67c17fd1039c4e7c0c856eb1743cfdf8a6976f9c",
      "filename": "jib-gradle-plugin/src/test/java/com/google/cloud/tools/jib/gradle/GradleProjectPropertiesTest.java",
      "status": "modified",
      "additions": 12,
      "deletions": 15,
      "changes": 27,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/fb29e86b99ff124ccf7f64e24b366d2862f95d6c/jib-gradle-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FGradleProjectPropertiesTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/fb29e86b99ff124ccf7f64e24b366d2862f95d6c/jib-gradle-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FGradleProjectPropertiesTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-gradle-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FGradleProjectPropertiesTest.java?ref=fb29e86b99ff124ccf7f64e24b366d2862f95d6c",
      "patch": "@@ -94,7 +94,6 @@\n @RunWith(MockitoJUnitRunner.class)\n public class GradleProjectPropertiesTest {\n \n-  private static final ContainerizingMode DEFAULT_CONTAINERIZING_MODE = ContainerizingMode.EXPLODED;\n   private static final Instant SAMPLE_FILE_MODIFICATION_TIME = Instant.ofEpochSecond(32);\n \n   /** Implementation of {@link FileCollection} that just holds a set of {@link File}s. */\n@@ -122,7 +121,7 @@ public TaskDependency getBuildDependencies() {\n     }\n   }\n \n-  /** Helper for reading back layers in a {@link buildContext}. */\n+  /** Helper for reading back layers in a {@link BuildContext}. */\n   private static class ContainerBuilderLayers {\n \n     private final List<LayerConfiguration> resourcesLayerEntries;\n@@ -333,7 +332,7 @@ public void testGetMajorJavaVersion_jvm11() {\n   public void testCreateContainerBuilder_correctFiles()\n       throws URISyntaxException, IOException, InvalidImageReferenceException,\n           CacheDirectoryCreationException {\n-    BuildContext buildContext = setupBuildContext(\"/app\", DEFAULT_CONTAINERIZING_MODE);\n+    BuildContext buildContext = setupBuildContext(\"/app\");\n     ContainerBuilderLayers layers = new ContainerBuilderLayers(buildContext);\n \n     Path applicationDirectory = getResource(\"gradle/application\");\n@@ -374,14 +373,14 @@ public void testCreateContainerBuilder_noClassesFiles() throws InvalidImageRefer\n     Mockito.when(mockMainSourceSetOutput.getClassesDirs())\n         .thenReturn(new TestFileCollection(ImmutableSet.of(nonexistentFile)));\n     gradleProjectProperties.createJibContainerBuilder(\n-        JavaContainerBuilder.from(RegistryImage.named(\"base\")), DEFAULT_CONTAINERIZING_MODE);\n+        JavaContainerBuilder.from(RegistryImage.named(\"base\")), ContainerizingMode.EXPLODED);\n     Mockito.verify(mockLogger).warn(\"No classes files were found - did you compile your project?\");\n   }\n \n   @Test\n   public void testCreateContainerBuilder_nonDefaultAppRoot()\n       throws IOException, InvalidImageReferenceException, CacheDirectoryCreationException {\n-    BuildContext buildContext = setupBuildContext(\"/my/app\", DEFAULT_CONTAINERIZING_MODE);\n+    BuildContext buildContext = setupBuildContext(\"/my/app\");\n     ContainerBuilderLayers layers = new ContainerBuilderLayers(buildContext);\n \n     assertExtractionPathsUnordered(\n@@ -410,8 +409,7 @@ public void testCreateContainerBuilder_nonDefaultAppRoot()\n   @Test\n   public void testCreateContainerBuilder_defaultAppRoot()\n       throws IOException, InvalidImageReferenceException, CacheDirectoryCreationException {\n-    BuildContext buildContext =\n-        setupBuildContext(JavaContainerBuilder.DEFAULT_APP_ROOT, DEFAULT_CONTAINERIZING_MODE);\n+    BuildContext buildContext = setupBuildContext(JavaContainerBuilder.DEFAULT_APP_ROOT);\n     ContainerBuilderLayers layers = new ContainerBuilderLayers(buildContext);\n     assertExtractionPathsUnordered(\n         Arrays.asList(\n@@ -441,7 +439,7 @@ public void testCreateContainerBuilder_war()\n     Path webAppDirectory = getResource(\"gradle/webapp\");\n     Path unzipTarget = setUpWarProject(webAppDirectory);\n \n-    BuildContext buildContext = setupBuildContext(\"/my/app\", DEFAULT_CONTAINERIZING_MODE);\n+    BuildContext buildContext = setupBuildContext(\"/my/app\");\n     ContainerBuilderLayers layers = new ContainerBuilderLayers(buildContext);\n     assertSourcePathsUnordered(\n         ImmutableList.of(unzipTarget.resolve(\"WEB-INF/lib/dependency-1.0.0.jar\")),\n@@ -504,8 +502,7 @@ public void testCreateContainerBuilder_defaultWebAppRoot()\n           CacheDirectoryCreationException {\n     Path unzipTarget = setUpWarProject(getResource(\"gradle/webapp\"));\n \n-    BuildContext buildContext =\n-        setupBuildContext(JavaContainerBuilder.DEFAULT_WEB_APP_ROOT, DEFAULT_CONTAINERIZING_MODE);\n+    BuildContext buildContext = setupBuildContext(JavaContainerBuilder.DEFAULT_WEB_APP_ROOT);\n     ContainerBuilderLayers layers = new ContainerBuilderLayers(buildContext);\n     assertSourcePathsUnordered(\n         ImmutableList.of(unzipTarget.resolve(\"WEB-INF/lib/dependency-1.0.0.jar\")),\n@@ -540,22 +537,22 @@ public void testCreateContainerBuilder_noErrorIfWebInfClassesDoesNotExist()\n       throws IOException, InvalidImageReferenceException, CacheDirectoryCreationException {\n     temporaryFolder.newFolder(\"WEB-INF\", \"lib\");\n     setUpWarProject(temporaryFolder.getRoot().toPath());\n-    setupBuildContext(\"/anything\", DEFAULT_CONTAINERIZING_MODE); // should pass\n+    setupBuildContext(\"/anything\"); // should pass\n   }\n \n   @Test\n   public void testCreateContainerBuilder_noErrorIfWebInfLibDoesNotExist()\n       throws IOException, InvalidImageReferenceException, CacheDirectoryCreationException {\n     temporaryFolder.newFolder(\"WEB-INF\", \"classes\");\n     setUpWarProject(temporaryFolder.getRoot().toPath());\n-    setupBuildContext(\"/anything\", DEFAULT_CONTAINERIZING_MODE); // should pass\n+    setupBuildContext(\"/anything\"); // should pass\n   }\n \n   @Test\n   public void testCreateContainerBuilder_noErrorIfWebInfDoesNotExist()\n       throws IOException, InvalidImageReferenceException, CacheDirectoryCreationException {\n     setUpWarProject(temporaryFolder.getRoot().toPath());\n-    setupBuildContext(\"/anything\", DEFAULT_CONTAINERIZING_MODE); // should pass\n+    setupBuildContext(\"/anything\"); // should pass\n   }\n \n   @Test\n@@ -594,15 +591,15 @@ public void testGetWarFilePath_bootWarDisabled() {\n     Assert.assertEquals(\"war.war\", gradleProjectProperties.getWarFilePath());\n   }\n \n-  private BuildContext setupBuildContext(String appRoot, ContainerizingMode containerizingMode)\n+  private BuildContext setupBuildContext(String appRoot)\n       throws InvalidImageReferenceException, IOException, CacheDirectoryCreationException {\n     JavaContainerBuilder javaContainerBuilder =\n         JavaContainerBuilder.from(RegistryImage.named(\"base\"))\n             .setAppRoot(AbsoluteUnixPath.get(appRoot))\n             .setModificationTimeProvider((ignored1, ignored2) -> SAMPLE_FILE_MODIFICATION_TIME);\n     JibContainerBuilder jibContainerBuilder =\n         new GradleProjectProperties(mockProject, mockLogger, mockTempDirectoryProvider)\n-            .createJibContainerBuilder(javaContainerBuilder, containerizingMode);\n+            .createJibContainerBuilder(javaContainerBuilder, ContainerizingMode.EXPLODED);\n     return JibContainerBuilderTestHelper.toBuildContext(\n         jibContainerBuilder, Containerizer.to(RegistryImage.named(\"to\")));\n   }",
      "parent_sha": "701fc31afce8850bf380d6e38cf5f178991448b9"
    }
  },
  {
    "oid": "714c6e1ab1df3ceb1de7619c339367781668bce8",
    "message": "Increase Timeout in MultithreadedExecutor (#1846)",
    "date": "2019-07-15T17:16:38Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/714c6e1ab1df3ceb1de7619c339367781668bce8",
    "details": {
      "sha": "658aee81efd2d6badb007ca5fddadba423291e38",
      "filename": "jib-core/src/test/java/com/google/cloud/tools/jib/MultithreadedExecutor.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/714c6e1ab1df3ceb1de7619c339367781668bce8/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2FMultithreadedExecutor.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/714c6e1ab1df3ceb1de7619c339367781668bce8/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2FMultithreadedExecutor.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2FMultithreadedExecutor.java?ref=714c6e1ab1df3ceb1de7619c339367781668bce8",
      "patch": "@@ -33,7 +33,7 @@\n /** Testing infrastructure for running code across multiple threads. */\n public class MultithreadedExecutor implements Closeable {\n \n-  private static final Duration MULTITHREADED_TEST_TIMEOUT = Duration.ofSeconds(1);\n+  private static final Duration MULTITHREADED_TEST_TIMEOUT = Duration.ofSeconds(3);\n   private static final int THREAD_COUNT = 20;\n \n   private final ExecutorService executorService = Executors.newFixedThreadPool(THREAD_COUNT);",
      "parent_sha": "ad063a220d7f7a48370f2926f549e43913b4835a"
    }
  },
  {
    "oid": "ce193cf4a93eb2b755ce033fb4fc565be6ca0b0f",
    "message": "Use temurin builds based on older version of ubuntu (#3694)\n\n* latest versions of temurin are incompatible with older versions of docker",
    "date": "2022-06-22T14:24:54Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/ce193cf4a93eb2b755ce033fb4fc565be6ca0b0f",
    "details": {
      "sha": "a09cfc8735c645fe989a6ecf486c6e6ad6d25c8f",
      "filename": "jib-cli/src/integration-test/java/com/google/cloud/tools/jib/cli/JarCommandTest.java",
      "status": "modified",
      "additions": 39,
      "deletions": 5,
      "changes": 44,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/ce193cf4a93eb2b755ce033fb4fc565be6ca0b0f/jib-cli%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2FJarCommandTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/ce193cf4a93eb2b755ce033fb4fc565be6ca0b0f/jib-cli%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2FJarCommandTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-cli%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2FJarCommandTest.java?ref=ce193cf4a93eb2b755ce033fb4fc565be6ca0b0f",
      "patch": "@@ -87,7 +87,13 @@ public void testStandardJar_explodedMode_toDocker()\n     Path jarPath = Paths.get(Resources.getResource(\"jarTest/standard/jarWithCp.jar\").toURI());\n     Integer exitCode =\n         new CommandLine(new JibCli())\n-            .execute(\"jar\", \"--target\", \"docker://exploded-jar\", jarPath.toString());\n+            .execute(\n+                \"jar\",\n+                \"--from\",\n+                \"eclipse-temurin:8-jdk-focal\",\n+                \"--target\",\n+                \"docker://exploded-jar\",\n+                jarPath.toString());\n     String output = new Command(\"docker\", \"run\", \"--rm\", \"exploded-jar\").run();\n     try (JarFile jarFile = new JarFile(jarPath.toFile())) {\n       String classPath =\n@@ -105,7 +111,13 @@ public void testNoDependencyStandardJar_explodedMode_toDocker()\n     Path jarPath = Paths.get(Resources.getResource(\"jarTest/standard/noDependencyJar.jar\").toURI());\n     Integer exitCode =\n         new CommandLine(new JibCli())\n-            .execute(\"jar\", \"--target\", \"docker://exploded-no-dep-jar\", jarPath.toString());\n+            .execute(\n+                \"jar\",\n+                \"--from\",\n+                \"eclipse-temurin:8-jdk-focal\",\n+                \"--target\",\n+                \"docker://exploded-no-dep-jar\",\n+                jarPath.toString());\n     String output = new Command(\"docker\", \"run\", \"--rm\", \"exploded-no-dep-jar\").run();\n     try (JarFile jarFile = new JarFile(jarPath.toFile())) {\n       String classPath =\n@@ -124,7 +136,13 @@ public void testStandardJar_packagedMode_toDocker()\n     Integer exitCode =\n         new CommandLine(new JibCli())\n             .execute(\n-                \"jar\", \"--target\", \"docker://packaged-jar\", jarPath.toString(), \"--mode=packaged\");\n+                \"jar\",\n+                \"--from\",\n+                \"eclipse-temurin:8-jdk-focal\",\n+                \"--target\",\n+                \"docker://packaged-jar\",\n+                jarPath.toString(),\n+                \"--mode=packaged\");\n     String output = new Command(\"docker\", \"run\", \"--rm\", \"packaged-jar\").run();\n     try (JarFile jarFile = new JarFile(jarPath.toFile())) {\n       String classPath =\n@@ -144,6 +162,8 @@ public void testNoDependencyStandardJar_packagedMode_toDocker()\n         new CommandLine(new JibCli())\n             .execute(\n                 \"jar\",\n+                \"--from\",\n+                \"eclipse-temurin:8-jdk-focal\",\n                 \"--target\",\n                 \"docker://packaged-no-dep-jar\",\n                 jarPath.toString(),\n@@ -167,7 +187,13 @@ public void testSpringBootLayeredJar_explodedMode() throws IOException, Interrup\n \n     Integer exitCode =\n         new CommandLine(new JibCli())\n-            .execute(\"jar\", \"--target\", \"docker://spring-boot-jar-layered\", jarPath.toString());\n+            .execute(\n+                \"jar\",\n+                \"--from\",\n+                \"eclipse-temurin:8-jdk-focal\",\n+                \"--target\",\n+                \"docker://spring-boot-jar-layered\",\n+                jarPath.toString());\n     assertThat(exitCode).isEqualTo(0);\n \n     String output =\n@@ -189,7 +215,13 @@ public void testSpringBootNonLayeredJar_explodedMode() throws IOException, Inter\n \n     Integer exitCode =\n         new CommandLine(new JibCli())\n-            .execute(\"jar\", \"--target\", \"docker://spring-boot-jar\", jarPath.toString());\n+            .execute(\n+                \"jar\",\n+                \"--from\",\n+                \"eclipse-temurin:8-jdk-focal\",\n+                \"--target\",\n+                \"docker://spring-boot-jar\",\n+                jarPath.toString());\n     assertThat(exitCode).isEqualTo(0);\n \n     String output =\n@@ -211,6 +243,8 @@ public void testSpringBootJar_packagedMode() throws IOException, InterruptedExce\n         new CommandLine(new JibCli())\n             .execute(\n                 \"jar\",\n+                \"--from\",\n+                \"eclipse-temurin:8-jdk-focal\",\n                 \"--target\",\n                 \"docker://packaged-spring-boot\",\n                 jarPath.toString(),",
      "parent_sha": "976237fda4c5593e96353c3a863fb2e9979e52b0"
    }
  },
  {
    "oid": "21c9d8f0ed0af4df8f9c3abbc76c3ea18a88d025",
    "message": "Sonar security: replaced regex. (#3413)\n\nRemove use of regex in response to sonar security hotspot review.",
    "date": "2021-08-13T16:16:11Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/21c9d8f0ed0af4df8f9c3abbc76c3ea18a88d025",
    "details": {
      "sha": "cb3864865a9ef86a91d6faff099b3229595d0ff3",
      "filename": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/PluginConfigurationProcessor.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/21c9d8f0ed0af4df8f9c3abbc76c3ea18a88d025/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FPluginConfigurationProcessor.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/21c9d8f0ed0af4df8f9c3abbc76c3ea18a88d025/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FPluginConfigurationProcessor.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FPluginConfigurationProcessor.java?ref=21c9d8f0ed0af4df8f9c3abbc76c3ea18a88d025",
      "patch": "@@ -43,6 +43,7 @@\n import com.google.cloud.tools.jib.plugins.extension.JibPluginExtensionException;\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n+import com.google.common.base.Splitter;\n import com.google.common.base.Verify;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Multimaps;\n@@ -506,7 +507,8 @@ static JavaContainerBuilder getJavaContainerBuilderWithBaseImage(\n     }\n \n     // Verify Java version is compatible\n-    String prefixRemoved = baseImageConfig.replaceFirst(\".*://\", \"\");\n+    List<String> splits = Splitter.on(\"://\").splitToList(baseImageConfig);\n+    String prefixRemoved = splits.get(splits.size() - 1);\n     int javaVersion = projectProperties.getMajorJavaVersion();\n     if (isKnownJava8Image(prefixRemoved) && javaVersion > 8) {\n       throw new IncompatibleBaseImageJavaVersionException(8, javaVersion);",
      "parent_sha": "7e8489679722870f14ded2bc9dcd42461d69425f"
    }
  },
  {
    "oid": "df08f662c4755b91b091b3c9a137d93f27f2d373",
    "message": "Has integration test check actual build time. (#753)\n\n* Makes sure first run has different layer.",
    "date": "2018-08-01T18:11:29Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/df08f662c4755b91b091b3c9a137d93f27f2d373",
    "details": {
      "sha": "8c4f08061a073948e1e69b2858b13235dd4202dc",
      "filename": "jib-maven-plugin/src/test/java/com/google/cloud/tools/jib/maven/BuildImageMojoIntegrationTest.java",
      "status": "modified",
      "additions": 42,
      "deletions": 6,
      "changes": 48,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/df08f662c4755b91b091b3c9a137d93f27f2d373/jib-maven-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FBuildImageMojoIntegrationTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/df08f662c4755b91b091b3c9a137d93f27f2d373/jib-maven-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FBuildImageMojoIntegrationTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-maven-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FBuildImageMojoIntegrationTest.java?ref=df08f662c4755b91b091b3c9a137d93f27f2d373",
      "patch": "@@ -18,9 +18,14 @@\n \n import com.google.cloud.tools.jib.Command;\n import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.Paths;\n import java.time.Instant;\n import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n import org.apache.maven.it.VerificationException;\n import org.apache.maven.it.Verifier;\n import org.hamcrest.CoreMatchers;\n@@ -51,17 +56,17 @@ private static String buildAndRun(Path projectRoot, String imageReference, boole\n       throws VerificationException, IOException, InterruptedException {\n     Verifier verifier = new Verifier(projectRoot.toString());\n     verifier.setAutoclean(false);\n-    verifier.executeGoal(\"package\");\n+    verifier.addCliOption(\"-X\");\n+    verifier.executeGoals(Arrays.asList(\"clean\", \"compile\"));\n \n     // Builds twice, and checks if the second build took less time.\n-    long lastTime = System.nanoTime();\n     verifier.executeGoal(\"jib:\" + BuildImageMojo.GOAL_NAME);\n-    long timeOne = System.nanoTime() - lastTime;\n-    lastTime = System.nanoTime();\n+    float timeOne = getBuildTimeFromVerifierLog(verifier);\n \n     if (runTwice) {\n+      verifier.resetStreams();\n       verifier.executeGoal(\"jib:\" + BuildImageMojo.GOAL_NAME);\n-      long timeTwo = System.nanoTime() - lastTime;\n+      float timeTwo = getBuildTimeFromVerifierLog(verifier);\n \n       Assert.assertTrue(\n           \"First build time (\"\n@@ -87,6 +92,22 @@ private static String buildAndRun(Path projectRoot, String imageReference, boole\n     return new Command(\"docker\", \"run\", imageReference).run();\n   }\n \n+  private static float getBuildTimeFromVerifierLog(Verifier verifier) throws IOException {\n+    Pattern pattern = Pattern.compile(\"Building and pushing image : (?<time>.*) ms\");\n+\n+    for (String line :\n+        Files.readAllLines(Paths.get(verifier.getBasedir(), verifier.getLogFileName()))) {\n+      Matcher matcher = pattern.matcher(line);\n+      if (matcher.find()) {\n+        return Float.parseFloat(matcher.group(\"time\"));\n+      }\n+    }\n+\n+    Assert.fail(\"Could not find build execution time in logs\");\n+    // Should not reach here.\n+    return -1;\n+  }\n+\n   @Test\n   public void testExecute_simple() throws VerificationException, IOException, InterruptedException {\n     // Test empty output error\n@@ -105,8 +126,22 @@ public void testExecute_simple() throws VerificationException, IOException, Inte\n     }\n \n     Instant before = Instant.now();\n+\n+    // The target registry these tests push to would already have all the layers cached from before,\n+    // causing this test to fail sometimes with the second build being a bit slower than the first\n+    // build. This file change makes sure that a new layer is always pushed the first time to solve\n+    // this issue.\n+    Files.write(\n+        simpleTestProject\n+            .getProjectRoot()\n+            .resolve(\"src\")\n+            .resolve(\"main\")\n+            .resolve(\"resources\")\n+            .resolve(\"world\"),\n+        before.toString().getBytes(StandardCharsets.UTF_8));\n+\n     Assert.assertEquals(\n-        \"Hello, world. An argument.\\nfoo\\ncat\\n\",\n+        \"Hello, \" + before + \". An argument.\\nfoo\\ncat\\n\",\n         buildAndRun(\n             simpleTestProject.getProjectRoot(),\n             \"gcr.io/jib-integration-testing/simpleimage:maven\",\n@@ -153,6 +188,7 @@ public void testExecute_defaultTarget() {\n       verifier.setAutoclean(false);\n       verifier.executeGoals(Arrays.asList(\"clean\", \"jib:\" + BuildImageMojo.GOAL_NAME));\n       Assert.fail();\n+\n     } catch (VerificationException ex) {\n       Assert.assertThat(\n           ex.getMessage(),",
      "parent_sha": "373300b82fbe67aa293bdf35436d938b4d3771ae"
    }
  },
  {
    "oid": "7f7ec1bec31b181c8244ba1510f164047042dc63",
    "message": "Fixes #2860, log the build can be not reproducible when using USE_CURRENT_TIMESTAMP at debug level (#3520)",
    "date": "2021-12-01T16:33:46Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/7f7ec1bec31b181c8244ba1510f164047042dc63",
    "details": {
      "sha": "cee32fc386fe46f2acdb14e40a431abb7090e634",
      "filename": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/PluginConfigurationProcessor.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/7f7ec1bec31b181c8244ba1510f164047042dc63/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FPluginConfigurationProcessor.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/7f7ec1bec31b181c8244ba1510f164047042dc63/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FPluginConfigurationProcessor.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FPluginConfigurationProcessor.java?ref=7f7ec1bec31b181c8244ba1510f164047042dc63",
      "patch": "@@ -931,7 +931,7 @@ static Instant getCreationTime(String configuredCreationTime, ProjectProperties\n \n         case \"USE_CURRENT_TIMESTAMP\":\n           projectProperties.log(\n-              LogEvent.warn(\n+              LogEvent.debug(\n                   \"Setting image creation time to current time; your image may not be reproducible.\"));\n           return Instant.now();\n ",
      "parent_sha": "3fd34d23cea5e6aafd998609c60fcf7db85fbebb"
    }
  },
  {
    "oid": "af7fa3c3df18c95ef7036a507af395fd6180e98c",
    "message": "Fix lock file failures (#1696)",
    "date": "2019-05-07T13:30:31Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/af7fa3c3df18c95ef7036a507af395fd6180e98c",
    "details": {
      "sha": "08711ec27b80efc12d9ef407f471ac7f8f262f77",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/filesystem/LockFile.java",
      "status": "modified",
      "additions": 17,
      "deletions": 9,
      "changes": 26,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/af7fa3c3df18c95ef7036a507af395fd6180e98c/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Ffilesystem%2FLockFile.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/af7fa3c3df18c95ef7036a507af395fd6180e98c/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Ffilesystem%2FLockFile.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Ffilesystem%2FLockFile.java?ref=af7fa3c3df18c95ef7036a507af395fd6180e98c",
      "patch": "@@ -20,6 +20,7 @@\n import java.io.Closeable;\n import java.io.FileOutputStream;\n import java.io.IOException;\n+import java.io.OutputStream;\n import java.nio.channels.FileLock;\n import java.nio.file.Files;\n import java.nio.file.Path;\n@@ -34,10 +35,12 @@ public class LockFile implements Closeable {\n \n   private final Path lockFile;\n   private final FileLock fileLock;\n+  private final OutputStream outputStream;\n \n-  private LockFile(Path lockFile, FileLock fileLock) {\n+  private LockFile(Path lockFile, FileLock fileLock, OutputStream outputStream) {\n     this.lockFile = lockFile;\n     this.fileLock = fileLock;\n+    this.outputStream = outputStream;\n   }\n \n   /**\n@@ -58,26 +61,31 @@ public static LockFile lock(Path lockFile) throws IOException {\n     }\n \n     Files.createDirectories(lockFile.getParent());\n-    FileLock fileLock = new FileOutputStream(lockFile.toFile()).getChannel().lock();\n-    return new LockFile(lockFile, fileLock);\n+    FileOutputStream outputStream = new FileOutputStream(lockFile.toFile());\n+    FileLock fileLock = null;\n+    try {\n+      fileLock = outputStream.getChannel().lock();\n+      return new LockFile(lockFile, fileLock, outputStream);\n+\n+    } finally {\n+      if (fileLock == null) {\n+        outputStream.close();\n+      }\n+    }\n   }\n \n   /** Releases the lock file. */\n   @Override\n   public void close() {\n     try {\n       fileLock.release();\n+      outputStream.close();\n \n     } catch (IOException ex) {\n       throw new IllegalStateException(\"Unable to release lock\", ex);\n \n     } finally {\n-      try {\n-        Preconditions.checkNotNull(lockMap.get(lockFile)).unlock();\n-        Files.delete(lockFile);\n-\n-      } catch (IllegalMonitorStateException | IOException ignored) {\n-      }\n+      Preconditions.checkNotNull(lockMap.get(lockFile)).unlock();\n     }\n   }\n }",
      "parent_sha": "62ab86bdc096c3f9745b8bf991851550a9a4e904"
    }
  },
  {
    "oid": "685b7e2c27874b489b8ed6445fd6761e84f621db",
    "message": "chore: Set tempFolder permissions for local registry test (#3716)\n\nSet explicit permissions to tempFolder created for local registry integration tests to 755.\r\n\r\nCurrently the default permissions set for tempFolder is 700, but it seems like docker running on macOS are sometimes unable to access this.",
    "date": "2022-08-02T17:37:10Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/685b7e2c27874b489b8ed6445fd6761e84f621db",
    "details": {
      "sha": "d6e7163bd8d7b5a5769c59d980d68aea194147de",
      "filename": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/registry/LocalRegistry.java",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/685b7e2c27874b489b8ed6445fd6761e84f621db/jib-core%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FLocalRegistry.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/685b7e2c27874b489b8ed6445fd6761e84f621db/jib-core%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FLocalRegistry.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FLocalRegistry.java?ref=685b7e2c27874b489b8ed6445fd6761e84f621db",
      "patch": "@@ -26,8 +26,12 @@\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n+import java.nio.file.attribute.FileAttribute;\n+import java.nio.file.attribute.PosixFilePermission;\n+import java.nio.file.attribute.PosixFilePermissions;\n import java.util.Arrays;\n import java.util.List;\n+import java.util.Set;\n import java.util.UUID;\n import javax.annotation.Nullable;\n import org.junit.rules.ExternalResource;\n@@ -76,7 +80,9 @@ public void start() throws IOException, InterruptedException {\n       // BCrypt generates hashes using $2a$ algorithm (instead of $2y$ from docs), but this seems\n       // to work okay\n       String credentialString = username + \":\" + BCrypt.hashpw(password, BCrypt.gensalt());\n-      Path tempFolder = Files.createTempDirectory(Paths.get(\"/tmp\"), \"\");\n+      FileAttribute<Set<PosixFilePermission>> attrs =\n+          PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rwxr-xr-x\"));\n+      Path tempFolder = Files.createTempDirectory(Paths.get(\"/tmp\"), \"\", attrs);\n       Files.write(\n           tempFolder.resolve(\"htpasswd\"), credentialString.getBytes(StandardCharsets.UTF_8));\n       boolean isOnKokoroCI =",
      "parent_sha": "4a31c035a0b6ceea0cef62bcae8b77380fb3c591"
    }
  },
  {
    "oid": "f1dc4f0d2dbf70dae140a3ea6fb18364081f713f",
    "message": "Add JibContainerBuilder#addLayer overload with String instead of AbsoluteUnixPath (#1377)",
    "date": "2018-12-26T22:05:36Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/f1dc4f0d2dbf70dae140a3ea6fb18364081f713f",
    "details": {
      "sha": "0ecb044f0c74378d3973be9803e55699698d814f",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/api/JibContainerBuilder.java",
      "status": "modified",
      "additions": 27,
      "deletions": 11,
      "changes": 38,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/f1dc4f0d2dbf70dae140a3ea6fb18364081f713f/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fapi%2FJibContainerBuilder.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/f1dc4f0d2dbf70dae140a3ea6fb18364081f713f/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fapi%2FJibContainerBuilder.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fapi%2FJibContainerBuilder.java?ref=f1dc4f0d2dbf70dae140a3ea6fb18364081f713f",
      "patch": "@@ -119,6 +119,33 @@ public JibContainerBuilder addLayer(List<Path> files, AbsoluteUnixPath pathInCon\n     return addLayer(layerConfigurationBuilder.build());\n   }\n \n+  /**\n+   * Adds a new layer to the container with {@code files} as the source files and {@code\n+   * pathInContainer} as the path to copy the source files to in the container file system.\n+   *\n+   * @param files the source files to copy to a new layer in the container\n+   * @param pathInContainer the path in the container file system corresponding to the {@code\n+   *     sourceFile}\n+   * @return this\n+   * @throws IOException if an exception occurred when recursively listing any directories\n+   * @throws IllegalArgumentException if {@code pathInContainer} is not an absolute Unix-style path\n+   * @see #addLayer(List, AbsoluteUnixPath)\n+   */\n+  public JibContainerBuilder addLayer(List<Path> files, String pathInContainer) throws IOException {\n+    return addLayer(files, AbsoluteUnixPath.get(pathInContainer));\n+  }\n+\n+  /**\n+   * Adds a layer (defined by a {@link LayerConfiguration}).\n+   *\n+   * @param layerConfiguration the {@link LayerConfiguration}\n+   * @return this\n+   */\n+  public JibContainerBuilder addLayer(LayerConfiguration layerConfiguration) {\n+    layerConfigurations.add(layerConfiguration);\n+    return this;\n+  }\n+\n   /**\n    * Sets the layers (defined by a list of {@link LayerConfiguration}s). This replaces any\n    * previously-added layers.\n@@ -141,17 +168,6 @@ public JibContainerBuilder setLayers(LayerConfiguration... layerConfigurations)\n     return setLayers(Arrays.asList(layerConfigurations));\n   }\n \n-  /**\n-   * Adds a layer (defined by a {@link LayerConfiguration}).\n-   *\n-   * @param layerConfiguration the {@link LayerConfiguration}\n-   * @return this\n-   */\n-  public JibContainerBuilder addLayer(LayerConfiguration layerConfiguration) {\n-    layerConfigurations.add(layerConfiguration);\n-    return this;\n-  }\n-\n   /**\n    * Sets the container entrypoint. This is the beginning of the command that is run when the\n    * container starts. {@link #setProgramArguments} sets additional tokens.",
      "parent_sha": "31b49b963a5d01f8ea8509275f89d63860d623b6"
    }
  },
  {
    "oid": "005f0f66def65be8a5a2aae87d490d7e2263a1d2",
    "message": "extract nested try block into method. (#3417)\n\nFix this sonar issue of \"Try-catch blocks should not be nested\" to increase readability.",
    "date": "2021-08-24T18:23:20Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/005f0f66def65be8a5a2aae87d490d7e2263a1d2",
    "details": {
      "sha": "e36d4613e8dc6d96990874dd828736d43de84d48",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java",
      "status": "modified",
      "additions": 20,
      "deletions": 16,
      "changes": 36,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/005f0f66def65be8a5a2aae87d490d7e2263a1d2/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPullBaseImageStep.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/005f0f66def65be8a5a2aae87d490d7e2263a1d2/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPullBaseImageStep.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPullBaseImageStep.java?ref=005f0f66def65be8a5a2aae87d490d7e2263a1d2",
      "patch": "@@ -231,24 +231,11 @@ Optional<ImagesAndRegistryClient> tryMirrors(\n         eventHandlers.dispatch(LogEvent.info(\"trying mirror \" + mirror + \" for the base image\"));\n         try (ProgressEventDispatcher progressDispatcher2 =\n             progressDispatcher1.newChildProducer().create(\"trying mirror \" + mirror, 2)) {\n-          // First, try with no credentials. This works with public GCR images.\n           RegistryClient registryClient =\n               buildContext.newBaseImageRegistryClientFactory(mirror).newRegistryClient();\n-          try {\n-            List<Image> images =\n-                pullBaseImages(registryClient, progressDispatcher2.newChildProducer());\n-            eventHandlers.dispatch(LogEvent.info(\"pulled manifest from mirror \" + mirror));\n-            return Optional.of(new ImagesAndRegistryClient(images, registryClient));\n-\n-          } catch (RegistryUnauthorizedException ex) {\n-            // in case if a mirror requires bearer auth\n-            eventHandlers.dispatch(LogEvent.debug(\"mirror \" + mirror + \" requires auth\"));\n-            registryClient.doPullBearerAuth();\n-            List<Image> images =\n-                pullBaseImages(registryClient, progressDispatcher2.newChildProducer());\n-            eventHandlers.dispatch(LogEvent.info(\"pulled manifest from mirror \" + mirror));\n-            return Optional.of(new ImagesAndRegistryClient(images, registryClient));\n-          }\n+          List<Image> images = pullPublicImages(eventHandlers, registryClient, progressDispatcher2);\n+          eventHandlers.dispatch(LogEvent.info(\"pulled manifest from mirror \" + mirror));\n+          return Optional.of(new ImagesAndRegistryClient(images, registryClient));\n \n         } catch (IOException | RegistryException ex) {\n           // Ignore errors from this mirror and continue.\n@@ -261,6 +248,23 @@ Optional<ImagesAndRegistryClient> tryMirrors(\n     }\n   }\n \n+  private List<Image> pullPublicImages(\n+      EventHandlers eventHandlers,\n+      RegistryClient registryClient,\n+      ProgressEventDispatcher progressDispatcher)\n+      throws IOException, RegistryException, LayerCountMismatchException,\n+          BadContainerConfigurationFormatException {\n+    try {\n+      // First, try with no credentials. This works with public GCR images.\n+      return pullBaseImages(registryClient, progressDispatcher.newChildProducer());\n+\n+    } catch (RegistryUnauthorizedException ex) {\n+      // in case if a registry requires bearer auth\n+      registryClient.doPullBearerAuth();\n+      return pullBaseImages(registryClient, progressDispatcher.newChildProducer());\n+    }\n+  }\n+\n   /**\n    * Pulls the base images specified in the platforms list.\n    *",
      "parent_sha": "da8596760664d13c518fe248f41233d40d95703f"
    }
  },
  {
    "oid": "1b1fc24fcd962a5ad23fa749dbbde76d74798a9d",
    "message": "fix sonar bug to call Optional#isPresent() before accessing value. (#3366)\n\nFix sonar bug: https://sonarcloud.io/project/issues?id=GoogleContainerTools_jib&issues=AXrlUTIQcB_fbtb802TR&open=AXrlUTIQcB_fbtb802TR",
    "date": "2021-08-02T19:14:33Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/1b1fc24fcd962a5ad23fa749dbbde76d74798a9d",
    "details": {
      "sha": "ed071bd5fff0edd31828ffbb5507425bff52f9bd",
      "filename": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/buildfile/BuildFiles.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/1b1fc24fcd962a5ad23fa749dbbde76d74798a9d/jib-cli%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2Fbuildfile%2FBuildFiles.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/1b1fc24fcd962a5ad23fa749dbbde76d74798a9d/jib-cli%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2Fbuildfile%2FBuildFiles.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-cli%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2Fbuildfile%2FBuildFiles.java?ref=1b1fc24fcd962a5ad23fa749dbbde76d74798a9d",
      "patch": "@@ -94,9 +94,9 @@ public static JibContainerBuilder toJibContainerBuilder(\n     buildFile.getEntrypoint().ifPresent(containerBuilder::setEntrypoint);\n     buildFile.getCmd().ifPresent(containerBuilder::setProgramArguments);\n \n-    if (buildFile.getLayers().isPresent()) {\n-      containerBuilder.setFileEntriesLayers(\n-          Layers.toLayers(projectRoot, buildFile.getLayers().get()));\n+    Optional<LayersSpec> layersSpec = buildFile.getLayers();\n+    if (layersSpec.isPresent()) {\n+      containerBuilder.setFileEntriesLayers(Layers.toLayers(projectRoot, layersSpec.get()));\n     }\n     return containerBuilder;\n   }",
      "parent_sha": "dfd4efa71b46300016306c3ee28ddb2999e196c9"
    }
  },
  {
    "oid": "9109122f076618c82c792705176d28d58de0c67f",
    "message": "Wait until local registry is ready when setting it up in integration tests (#1006)",
    "date": "2018-09-20T12:57:17Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/9109122f076618c82c792705176d28d58de0c67f",
    "details": {
      "sha": "e5c03066031b31248a442045f88b2ffcb461836d",
      "filename": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/registry/LocalRegistry.java",
      "status": "modified",
      "additions": 22,
      "deletions": 9,
      "changes": 31,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/9109122f076618c82c792705176d28d58de0c67f/jib-core%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FLocalRegistry.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/9109122f076618c82c792705176d28d58de0c67f/jib-core%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FLocalRegistry.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FLocalRegistry.java?ref=9109122f076618c82c792705176d28d58de0c67f",
      "patch": "@@ -18,6 +18,9 @@\n \n import com.google.cloud.tools.jib.Command;\n import java.io.IOException;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n import java.nio.file.Path;\n@@ -53,20 +56,14 @@ protected void before() throws IOException, InterruptedException {\n     ArrayList<String> dockerTokens =\n         new ArrayList<>(\n             Arrays.asList(\n-                \"docker\",\n-                \"run\",\n-                \"-d\",\n-                \"-p\",\n-                port + \":5000\",\n-                \"--restart=always\",\n-                \"--name\",\n-                containerName));\n+                \"docker\", \"run\", \"--rm\", \"-d\", \"-p\", port + \":5000\", \"--name\", containerName));\n     if (username != null && password != null) {\n       // Generate the htpasswd file to store credentials\n       String credentialString =\n           new Command(\n                   \"docker\",\n                   \"run\",\n+                  \"--rm\",\n                   \"--entrypoint\",\n                   \"htpasswd\",\n                   \"registry:2\",\n@@ -96,14 +93,14 @@ protected void before() throws IOException, InterruptedException {\n     }\n     dockerTokens.add(\"registry:2\");\n     new Command(dockerTokens).run();\n+    waitUntilReady();\n   }\n \n   @Override\n   protected void after() {\n     try {\n       logout();\n       new Command(\"docker\", \"stop\", containerName).run();\n-      new Command(\"docker\", \"rm\", \"-v\", containerName).run();\n \n     } catch (InterruptedException | IOException ex) {\n       throw new RuntimeException(\"Could not stop local registry fully: \" + containerName, ex);\n@@ -151,4 +148,20 @@ private void logout() throws IOException, InterruptedException {\n       new Command(\"docker\", \"logout\", \"localhost:\" + port).run();\n     }\n   }\n+\n+  private void waitUntilReady() throws InterruptedException, MalformedURLException {\n+    URL queryUrl = new URL(\"http://localhost:\" + port + \"/v2/_catalog\");\n+\n+    for (int i = 0; i < 40; i++) {\n+      try {\n+        HttpURLConnection connection = (HttpURLConnection) queryUrl.openConnection();\n+        int code = connection.getResponseCode();\n+        if (code == HttpURLConnection.HTTP_OK || code == HttpURLConnection.HTTP_UNAUTHORIZED) {\n+          return;\n+        }\n+      } catch (IOException ex) {\n+      }\n+      Thread.sleep(250);\n+    }\n+  }\n }",
      "parent_sha": "34c4e49c5f43cf3d37338fe3e69a2cfce07224b3"
    }
  },
  {
    "oid": "384ad0283174c6a7aa0d21c52c6eeedf28b8ee96",
    "message": "Ignore http client logging in update check (#2243)",
    "date": "2020-01-23T22:39:49Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/384ad0283174c6a7aa0d21c52c6eeedf28b8ee96",
    "details": {
      "sha": "340fd530a3b4d6abf69f05687ba8ace3b1c1dfb2",
      "filename": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/384ad0283174c6a7aa0d21c52c6eeedf28b8ee96/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FUpdateChecker.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/384ad0283174c6a7aa0d21c52c6eeedf28b8ee96/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FUpdateChecker.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FUpdateChecker.java?ref=384ad0283174c6a7aa0d21c52c6eeedf28b8ee96",
      "patch": "@@ -150,7 +150,7 @@ static Optional<String> performUpdateCheck(\n       }\n \n       // Check for update\n-      FailoverHttpClient httpClient = new FailoverHttpClient(true, false, log);\n+      FailoverHttpClient httpClient = new FailoverHttpClient(true, false, ignored -> {});\n       try {\n         Response response =\n             httpClient.get(",
      "parent_sha": "2d40c8b840883e0739d504d30e71b7e71c19019c"
    }
  },
  {
    "oid": "46e1751ba4a453b8658a68b6c1680553c23692b7",
    "message": "Log zip filename when blocking Zip-Slip (#912)",
    "date": "2018-08-31T12:59:09Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/46e1751ba4a453b8658a68b6c1680553c23692b7",
    "details": {
      "sha": "07ffb2c994940e01fa54ec861d12e5331d4edbfe",
      "filename": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/ZipUtil.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/46e1751ba4a453b8658a68b6c1680553c23692b7/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FZipUtil.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/46e1751ba4a453b8658a68b6c1680553c23692b7/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FZipUtil.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FZipUtil.java?ref=46e1751ba4a453b8658a68b6c1680553c23692b7",
      "patch": "@@ -48,7 +48,8 @@ public static void unzip(Path archive, Path destination) throws IOException {\n \n         String canonicalTarget = entryPath.toFile().getCanonicalPath();\n         if (!canonicalTarget.startsWith(canonicalDestination + File.separator)) {\n-          throw new IOException(\"Blocked unzipping files outside destination: \" + entry.getName());\n+          String offender = entry.getName() + \" from \" + archive;\n+          throw new IOException(\"Blocked unzipping files outside destination: \" + offender);\n         }\n \n         if (entry.isDirectory()) {",
      "parent_sha": "84a50029164ed6a5d9de3de9cb8f442686d093f8"
    }
  },
  {
    "oid": "302e280666f17f7b267751b0dc1ddf9514f1ffa9",
    "message": "Synchronizes CacheMetadata methods to avoid concurrency issue. (#371)",
    "date": "2018-06-05T22:45:33Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/302e280666f17f7b267751b0dc1ddf9514f1ffa9",
    "details": {
      "sha": "0fcf3fec0dfe45b5fadf26c6fb29d19771fc5a68",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/cache/CacheMetadata.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/302e280666f17f7b267751b0dc1ddf9514f1ffa9/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcache%2FCacheMetadata.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/302e280666f17f7b267751b0dc1ddf9514f1ffa9/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcache%2FCacheMetadata.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcache%2FCacheMetadata.java?ref=302e280666f17f7b267751b0dc1ddf9514f1ffa9",
      "patch": "@@ -83,15 +83,17 @@ ImageLayers<CachedLayerWithMetadata> filter() throws CacheMetadataCorruptedExcep\n     }\n   }\n \n-  ImageLayers<CachedLayerWithMetadata> getLayers() {\n+  // TODO: Remove explicit synchronization by refactoring build steps to not mutate a common\n+  // CacheMetadata.\n+  synchronized ImageLayers<CachedLayerWithMetadata> getLayers() {\n     return layersBuilder.build();\n   }\n \n   synchronized void addLayer(CachedLayerWithMetadata layer) throws LayerPropertyNotFoundException {\n     layersBuilder.add(layer);\n   }\n \n-  LayerFilter filterLayers() {\n+  synchronized LayerFilter filterLayers() {\n     return new LayerFilter(layersBuilder.build());\n   }\n }",
      "parent_sha": "a1a4ede912c69a80687b934a93202c8ca353d535"
    }
  },
  {
    "oid": "664d6615850964915bfc42cb28eb3d7ef1447473",
    "message": "Close ProgressEventDispatchers in StepsRunner (#2774)",
    "date": "2020-09-22T14:39:52Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/664d6615850964915bfc42cb28eb3d7ef1447473",
    "details": {
      "sha": "694b79b2670380c2a321d0e8184bf9bd34483c50",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java",
      "status": "modified",
      "additions": 68,
      "deletions": 88,
      "changes": 156,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/664d6615850964915bfc42cb28eb3d7ef1447473/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FStepsRunner.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/664d6615850964915bfc42cb28eb3d7ef1447473/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FStepsRunner.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FStepsRunner.java?ref=664d6615850964915bfc42cb28eb3d7ef1447473",
      "patch": "@@ -315,24 +315,20 @@ private void obtainBaseImagesLayers(boolean layersRequiredLocally) {\n     results.baseImagesAndLayers =\n         executorService.submit(\n             () -> {\n-              // TODO: ideally, progressDispatcher should be closed at the right moment, after the\n-              // scheduled threads have completed. However, it can be tricky and cumbersome to track\n-              // completion, so it may just be better to delay closing until everything ends. At\n-              // least, we must ensure that it's not closed prematurely. (Garbage collection doesn't\n-              // auto-close it wit the current implementation.)\n-              ProgressEventDispatcher progressDispatcher =\n+              try (ProgressEventDispatcher progressDispatcher =\n                   childProgressDispatcherFactory.create(\n-                      \"scheduling obtaining base image layers\",\n-                      results.baseImagesAndRegistryClient.get().images.size());\n-\n-              Map<Image, List<Future<PreparedLayer>>> baseImagesAndLayers = new HashMap<>();\n-              for (Image baseImage : results.baseImagesAndRegistryClient.get().images) {\n-                List<Future<PreparedLayer>> layers =\n-                    obtainBaseImageLayers(\n-                        baseImage, layersRequiredLocally, progressDispatcher.newChildProducer());\n-                baseImagesAndLayers.put(baseImage, layers);\n+                      \"scheduling obtaining base images layers\",\n+                      results.baseImagesAndRegistryClient.get().images.size())) {\n+\n+                Map<Image, List<Future<PreparedLayer>>> baseImagesAndLayers = new HashMap<>();\n+                for (Image baseImage : results.baseImagesAndRegistryClient.get().images) {\n+                  List<Future<PreparedLayer>> layers =\n+                      obtainBaseImageLayers(\n+                          baseImage, layersRequiredLocally, progressDispatcher.newChildProducer());\n+                  baseImagesAndLayers.put(baseImage, layers);\n+                }\n+                return baseImagesAndLayers;\n               }\n-              return baseImagesAndLayers;\n             });\n   }\n \n@@ -363,27 +359,23 @@ private void pushBaseImagesLayers() {\n     results.baseImagesAndLayerPushResults =\n         executorService.submit(\n             () -> {\n-              // TODO: ideally, progressDispatcher should be closed at the right moment, after the\n-              // scheduled threads have completed. However, it can be tricky and cumbersome to track\n-              // completion, so it may just be better to delay closing until everything ends. At\n-              // least, we must ensure that it's not closed prematurely. (Garbage collection doesn't\n-              // auto-close it wit the current implementation.)\n-              ProgressEventDispatcher progressDispatcher =\n+              try (ProgressEventDispatcher progressDispatcher =\n                   childProgressDispatcherFactory.create(\n-                      \"scheduling pushing base image layers\",\n-                      results.baseImagesAndLayers.get().size());\n-\n-              Map<Image, List<Future<BlobDescriptor>>> layerPushResults = new HashMap<>();\n-              for (Map.Entry<Image, List<Future<PreparedLayer>>> entry :\n-                  results.baseImagesAndLayers.get().entrySet()) {\n-                Image baseImage = entry.getKey();\n-                List<Future<PreparedLayer>> baseLayers = entry.getValue();\n-\n-                List<Future<BlobDescriptor>> pushResults =\n-                    pushBaseImageLayers(baseLayers, progressDispatcher.newChildProducer());\n-                layerPushResults.put(baseImage, pushResults);\n+                      \"scheduling pushing base images layers\",\n+                      results.baseImagesAndLayers.get().size())) {\n+\n+                Map<Image, List<Future<BlobDescriptor>>> layerPushResults = new HashMap<>();\n+                for (Map.Entry<Image, List<Future<PreparedLayer>>> entry :\n+                    results.baseImagesAndLayers.get().entrySet()) {\n+                  Image baseImage = entry.getKey();\n+                  List<Future<PreparedLayer>> baseLayers = entry.getValue();\n+\n+                  List<Future<BlobDescriptor>> pushResults =\n+                      pushBaseImageLayers(baseLayers, progressDispatcher.newChildProducer());\n+                  layerPushResults.put(baseImage, pushResults);\n+                }\n+                return layerPushResults;\n               }\n-              return layerPushResults;\n             });\n   }\n \n@@ -396,7 +388,7 @@ private List<Future<BlobDescriptor>> pushBaseImageLayers(\n             buildContext,\n             progressDispatcherFactory,\n             results.targetRegistryClient.get(),\n-            Verify.verifyNotNull(baseLayers)));\n+            baseLayers));\n   }\n \n   private void buildAndCacheApplicationLayers() {\n@@ -416,26 +408,22 @@ private void buildImages() {\n     results.baseImagesAndBuiltImages =\n         executorService.submit(\n             () -> {\n-              // TODO: ideally, progressDispatcher should be closed at the right moment, after the\n-              // scheduled threads have completed. However, it can be tricky and cumbersome to track\n-              // completion, so it may just be better to delay closing until everything ends. At\n-              // least, we must ensure that it's not closed prematurely. (Garbage collection doesn't\n-              // auto-close it wit the current implementation.)\n-              ProgressEventDispatcher progressDispatcher =\n+              try (ProgressEventDispatcher progressDispatcher =\n                   childProgressDispatcherFactory.create(\n-                      \"scheduling building manifests\", results.baseImagesAndLayers.get().size());\n-\n-              Map<Image, Future<Image>> baseImagesAndBuiltImages = new HashMap<>();\n-              for (Map.Entry<Image, List<Future<PreparedLayer>>> entry :\n-                  results.baseImagesAndLayers.get().entrySet()) {\n-                Image baseImage = entry.getKey();\n-                List<Future<PreparedLayer>> baseLayers = entry.getValue();\n-\n-                Future<Image> builtImage =\n-                    buildImage(baseImage, baseLayers, progressDispatcher.newChildProducer());\n-                baseImagesAndBuiltImages.put(baseImage, builtImage);\n+                      \"scheduling building manifests\", results.baseImagesAndLayers.get().size())) {\n+\n+                Map<Image, Future<Image>> baseImagesAndBuiltImages = new HashMap<>();\n+                for (Map.Entry<Image, List<Future<PreparedLayer>>> entry :\n+                    results.baseImagesAndLayers.get().entrySet()) {\n+                  Image baseImage = entry.getKey();\n+                  List<Future<PreparedLayer>> baseLayers = entry.getValue();\n+\n+                  Future<Image> builtImage =\n+                      buildImage(baseImage, baseLayers, progressDispatcher.newChildProducer());\n+                  baseImagesAndBuiltImages.put(baseImage, builtImage);\n+                }\n+                return baseImagesAndBuiltImages;\n               }\n-              return baseImagesAndBuiltImages;\n             });\n   }\n \n@@ -475,27 +463,23 @@ private void pushContainerConfigurations() {\n     results.baseImagesAndContainerConfigPushResults =\n         executorService.submit(\n             () -> {\n-              // TODO: ideally, progressDispatcher should be closed at the right moment, after the\n-              // scheduled threads have completed. However, it can be tricky and cumbersome to track\n-              // completion, so it may just be better to delay closing until everything ends. At\n-              // least, we must ensure that it's not closed prematurely. (Garbage collection doesn't\n-              // auto-close it wit the current implementation.)\n-              ProgressEventDispatcher progressDispatcher =\n+              try (ProgressEventDispatcher progressDispatcher =\n                   childProgressDispatcherFactory.create(\n                       \"scheduling pushing container configurations\",\n-                      results.baseImagesAndBuiltImages.get().size());\n-\n-              Map<Image, Future<BlobDescriptor>> configPushResults = new HashMap<>();\n-              for (Map.Entry<Image, Future<Image>> entry :\n-                  results.baseImagesAndBuiltImages.get().entrySet()) {\n-                Image baseImage = entry.getKey();\n-                Future<Image> builtImage = entry.getValue();\n-\n-                Future<BlobDescriptor> pushResult =\n-                    pushContainerConfiguration(builtImage, progressDispatcher.newChildProducer());\n-                configPushResults.put(baseImage, pushResult);\n+                      results.baseImagesAndBuiltImages.get().size())) {\n+\n+                Map<Image, Future<BlobDescriptor>> configPushResults = new HashMap<>();\n+                for (Map.Entry<Image, Future<Image>> entry :\n+                    results.baseImagesAndBuiltImages.get().entrySet()) {\n+                  Image baseImage = entry.getKey();\n+                  Future<Image> builtImage = entry.getValue();\n+\n+                  Future<BlobDescriptor> pushResult =\n+                      pushContainerConfiguration(builtImage, progressDispatcher.newChildProducer());\n+                  configPushResults.put(baseImage, pushResult);\n+                }\n+                return configPushResults;\n               }\n-              return configPushResults;\n             });\n   }\n \n@@ -548,28 +532,24 @@ private void pushImages() {\n     results.imagePushResults =\n         executorService.submit(\n             () -> {\n-              // TODO: ideally, progressDispatcher should be closed at the right moment, after the\n-              // scheduled threads have completed. However, it can be tricky and cumbersome to track\n-              // completion, so it may just be better to delay closing until everything ends. At\n-              // least, we must ensure that it's not closed prematurely. (Garbage collection doesn't\n-              // auto-close it wit the current implementation.)\n-              ProgressEventDispatcher progressDispatcher =\n+              try (ProgressEventDispatcher progressDispatcher =\n                   childProgressDispatcherFactory.create(\n                       \"scheduling pushing manifests\",\n-                      results.baseImagesAndBuiltImages.get().size());\n+                      results.baseImagesAndBuiltImages.get().size())) {\n \n-              realizeFutures(results.applicationLayerPushResults.get());\n+                realizeFutures(results.applicationLayerPushResults.get());\n \n-              List<Future<BuildResult>> buildResults = new ArrayList<>();\n-              for (Map.Entry<Image, Future<Image>> entry :\n-                  results.baseImagesAndBuiltImages.get().entrySet()) {\n-                Image baseImage = entry.getKey();\n-                Future<Image> builtImage = entry.getValue();\n+                List<Future<BuildResult>> buildResults = new ArrayList<>();\n+                for (Map.Entry<Image, Future<Image>> entry :\n+                    results.baseImagesAndBuiltImages.get().entrySet()) {\n+                  Image baseImage = entry.getKey();\n+                  Future<Image> builtImage = entry.getValue();\n \n-                buildResults.add(\n-                    pushImage(baseImage, builtImage, progressDispatcher.newChildProducer()));\n+                  buildResults.add(\n+                      pushImage(baseImage, builtImage, progressDispatcher.newChildProducer()));\n+                }\n+                return buildResults;\n               }\n-              return buildResults;\n             });\n   }\n ",
      "parent_sha": "e8a46540db4a20ccc274a1ec1f4a6109d17768c6"
    }
  },
  {
    "oid": "ed0ab8565b649c72f83f4a92ebf0638c7cbb6e7b",
    "message": "fix sonar issue: swap expected and actual value. (#3388)\n\nFix sonar code smells by asserting list is not empty instead.\r\nsample sonar link:\r\nhttps://sonarcloud.io/project/issues?id=GoogleContainerTools_jib&issues=AXrlUTqfcB_fbtb802Yw&open=AXrlUTqfcB_fbtb802Yw",
    "date": "2021-08-06T20:06:30Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/ed0ab8565b649c72f83f4a92ebf0638c7cbb6e7b",
    "details": {
      "sha": "3df3a861543a7e702f177112cfc17522ab8c3076",
      "filename": "jib-gradle-plugin/src/test/java/com/google/cloud/tools/jib/gradle/skaffold/FilesTaskV2Test.java",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/ed0ab8565b649c72f83f4a92ebf0638c7cbb6e7b/jib-gradle-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2Fskaffold%2FFilesTaskV2Test.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/ed0ab8565b649c72f83f4a92ebf0638c7cbb6e7b/jib-gradle-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2Fskaffold%2FFilesTaskV2Test.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-gradle-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2Fskaffold%2FFilesTaskV2Test.java?ref=ed0ab8565b649c72f83f4a92ebf0638c7cbb6e7b",
      "patch": "@@ -16,6 +16,8 @@\n \n package com.google.cloud.tools.jib.gradle.skaffold;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import com.google.cloud.tools.jib.gradle.JibPlugin;\n import com.google.cloud.tools.jib.gradle.TestProject;\n import com.google.cloud.tools.jib.plugins.common.SkaffoldFilesOutput;\n@@ -99,7 +101,7 @@ public void testFilesTask_singleProject() throws IOException {\n             projectRoot.resolve(\"src/main/java\"),\n             projectRoot.resolve(\"src/main/custom-extra-dir\")),\n         result.getInputs());\n-    Assert.assertEquals(result.getIgnore().size(), 0);\n+    assertThat(result.getIgnore()).isEmpty();\n   }\n \n   @Test\n@@ -117,7 +119,7 @@ public void testFilesTask_multiProjectSimpleService() throws IOException {\n         result.getBuild());\n     assertPathListsAreEqual(\n         ImmutableList.of(simpleServiceRoot.resolve(\"src/main/java\")), result.getInputs());\n-    Assert.assertEquals(result.getIgnore().size(), 0);\n+    assertThat(result.getIgnore()).isEmpty();\n   }\n \n   @Test\n@@ -146,7 +148,7 @@ public void testFilesTask_multiProjectComplexService() throws IOException {\n             complexServiceRoot.resolve(\n                 \"local-m2-repo/com/google/cloud/tools/tiny-test-lib/0.0.1-SNAPSHOT/tiny-test-lib-0.0.1-SNAPSHOT.jar\")),\n         result.getInputs());\n-    Assert.assertEquals(result.getIgnore().size(), 0);\n+    assertThat(result.getIgnore()).isEmpty();\n   }\n \n   @Test\n@@ -165,7 +167,7 @@ public void testFilesTask_platformProject() throws IOException {\n         result.getBuild());\n     assertPathListsAreEqual(\n         ImmutableList.of(serviceRoot.resolve(\"src/main/java\")), result.getInputs());\n-    Assert.assertEquals(result.getIgnore().size(), 0);\n+    assertThat(result.getIgnore()).isEmpty();\n   }\n \n   @Test",
      "parent_sha": "b2e70a17e1b9234f0f874d4768c66f1ca7a72f78"
    }
  },
  {
    "oid": "74df684747eafe8a2037919bc6aa96132a560fe4",
    "message": "Hide and disbale jar command for Jib CLI (#2956)",
    "date": "2020-12-23T14:53:23Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/74df684747eafe8a2037919bc6aa96132a560fe4",
    "details": {
      "sha": "fc902a645dbab3c1bb31e1ed219e76d4456e9254",
      "filename": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/cli2/Jar.java",
      "status": "modified",
      "additions": 12,
      "deletions": 1,
      "changes": 13,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/74df684747eafe8a2037919bc6aa96132a560fe4/jib-cli%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2Fcli2%2FJar.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/74df684747eafe8a2037919bc6aa96132a560fe4/jib-cli%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2Fcli2%2FJar.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-cli%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2Fcli2%2FJar.java?ref=74df684747eafe8a2037919bc6aa96132a560fe4",
      "patch": "@@ -33,7 +33,11 @@\n import picocli.CommandLine;\n import picocli.CommandLine.Model.CommandSpec;\n \n-@CommandLine.Command(name = \"jar\", showAtFileInUsageHelp = true, description = \"Containerize a jar\")\n+@CommandLine.Command(\n+    name = \"jar\",\n+    showAtFileInUsageHelp = true,\n+    description = \"Containerize a jar\",\n+    hidden = true)\n public class Jar implements Callable<Integer> {\n \n   @CommandLine.Spec\n@@ -60,6 +64,13 @@ public class Jar implements Callable<Integer> {\n \n   @Override\n   public Integer call() {\n+    try {\n+      // Temporarily disable the command, but allow to proceed in tests.\n+      Class.forName(\"org.junit.Test\");\n+    } catch (ClassNotFoundException ex) {\n+      throw new UnsupportedOperationException(\"jar command not implemented\");\n+    }\n+\n     commonCliOptions.validate();\n     SingleThreadedExecutor executor = new SingleThreadedExecutor();\n     try (TempDirectoryProvider tempDirectoryProvider = new TempDirectoryProvider()) {",
      "parent_sha": "2dfccaac7d3698e4358ba6c9eb3515d684db46e1"
    }
  },
  {
    "oid": "563482b86ffea3a87ac8447b836ad146d2d00b01",
    "message": "fix: Uncompress compressed layer until EOF (#3983)\n\nThe CompressorStreamFactory used did not specify, that the compression\r\nlibrary should read until the end of the input file. This caused broken\r\ncompressed layer digests, as the digest was calculated only on a part of\r\nthe stream.",
    "date": "2023-05-05T18:59:01Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/563482b86ffea3a87ac8447b836ad146d2d00b01",
    "details": {
      "sha": "4f059fba5c37a077ddac64c0be21529a6ba98d45",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/cache/CacheStorageWriter.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/563482b86ffea3a87ac8447b836ad146d2d00b01/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcache%2FCacheStorageWriter.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/563482b86ffea3a87ac8447b836ad146d2d00b01/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcache%2FCacheStorageWriter.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcache%2FCacheStorageWriter.java?ref=563482b86ffea3a87ac8447b836ad146d2d00b01",
      "patch": "@@ -161,7 +161,7 @@ static void moveIfDoesNotExist(Path source, Path destination) throws IOException\n   private static DescriptorDigest getDiffIdByDecompressingFile(Path compressedFile)\n       throws IOException {\n     try (InputStream in =\n-        CompressorStreamFactory.getSingleton()\n+        new CompressorStreamFactory(true)\n             .createCompressorInputStream(\n                 new BufferedInputStream(Files.newInputStream(compressedFile)))) {\n       return Digests.computeDigest(in).getDigest();",
      "parent_sha": "3d3c02d53cc39a5178b87d5fa81563ea168371b9"
    }
  },
  {
    "oid": "2c1dfb847e9460b3a7f4ccf492338024afb6bd30",
    "message": "Fixes CacheReaderTest. (#109)",
    "date": "2018-02-20T19:02:36Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/2c1dfb847e9460b3a7f4ccf492338024afb6bd30",
    "details": {
      "sha": "91f12d9f2d5a95adfc83fb57c5f6c9fd0c36793f",
      "filename": "jib-core/src/test/java/com/google/cloud/tools/jib/cache/CacheReaderTest.java",
      "status": "modified",
      "additions": 27,
      "deletions": 22,
      "changes": 49,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/2c1dfb847e9460b3a7f4ccf492338024afb6bd30/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcache%2FCacheReaderTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/2c1dfb847e9460b3a7f4ccf492338024afb6bd30/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcache%2FCacheReaderTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcache%2FCacheReaderTest.java?ref=2c1dfb847e9460b3a7f4ccf492338024afb6bd30",
      "patch": "@@ -43,13 +43,34 @@\n /** Tests for {@link CacheReader}. */\n public class CacheReaderTest {\n \n+  private static void copyDirectory(Path source, Path destination) throws IOException {\n+    Files.walk(source)\n+        .forEach(\n+            path -> {\n+              try {\n+                if (path.equals(source)) {\n+                  return;\n+                }\n+                Path newPath = destination.resolve(source.relativize(path));\n+                Files.copy(path, newPath);\n+\n+              } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+              }\n+            });\n+  }\n+\n   @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();\n \n   private Path testCacheFolder;\n \n   @Before\n-  public void setUp() throws URISyntaxException {\n-    testCacheFolder = Paths.get(Resources.getResource(\"cache\").toURI());\n+  public void setUp() throws IOException, URISyntaxException {\n+    testCacheFolder = temporaryFolder.newFolder().toPath();\n+\n+    // Copies the test resource cache to the temporary test cache folder.\n+    Path resourceCache = Paths.get(Resources.getResource(\"cache\").toURI());\n+    copyDirectory(resourceCache, testCacheFolder);\n   }\n \n   @Test\n@@ -101,13 +122,10 @@ public void testAreBaseImageLayersCached()\n   }\n \n   @Test\n-  public void testGetLayerFile()\n-      throws URISyntaxException, CacheMetadataCorruptedException, IOException {\n+  public void testGetLayerFile() throws CacheMetadataCorruptedException, IOException {\n     Path expectedFile =\n-        Paths.get(\n-            Resources.getResource(\n-                    \"cache/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.tar.gz\")\n-                .toURI());\n+        testCacheFolder.resolve(\n+            \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.tar.gz\");\n \n     try (Cache cache = Cache.init(testCacheFolder)) {\n       CacheReader cacheReader = new CacheReader(cache);\n@@ -141,20 +159,7 @@ public void testGetUpToDateLayerBySourceFiles()\n     // Copies test files to a modifiable temporary folder.\n     Path resourceSourceFiles = Paths.get(Resources.getResource(\"layer\").toURI());\n     Path testSourceFiles = temporaryFolder.newFolder().toPath();\n-    Files.walk(resourceSourceFiles)\n-        .forEach(\n-            path -> {\n-              try {\n-                if (path.equals(resourceSourceFiles)) {\n-                  return;\n-                }\n-                Path newPath = testSourceFiles.resolve(resourceSourceFiles.relativize(path));\n-                Files.copy(path, newPath);\n-\n-              } catch (IOException ex) {\n-                throw new UncheckedIOException(ex);\n-              }\n-            });\n+    copyDirectory(resourceSourceFiles, testSourceFiles);\n \n     // Walk the files in reverse order so that the subfiles are changed before the parent\n     // directories are.",
      "parent_sha": "e10d9b29235e8f7e896e238f6b0e48127bfb590e"
    }
  },
  {
    "oid": "d23a0ac7e82acfe95faa6996599eb5fd1b02cad5",
    "message": "remove feature lock on jar command (#3098)",
    "date": "2021-03-02T18:48:23Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/d23a0ac7e82acfe95faa6996599eb5fd1b02cad5",
    "details": {
      "sha": "d111bdc2af818835b30d628c25fc9c7a68b6b796",
      "filename": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/Jar.java",
      "status": "modified",
      "additions": 1,
      "deletions": 12,
      "changes": 13,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/d23a0ac7e82acfe95faa6996599eb5fd1b02cad5/jib-cli%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2FJar.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/d23a0ac7e82acfe95faa6996599eb5fd1b02cad5/jib-cli%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2FJar.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-cli%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2FJar.java?ref=d23a0ac7e82acfe95faa6996599eb5fd1b02cad5",
      "patch": "@@ -46,11 +46,7 @@\n import picocli.CommandLine;\n import picocli.CommandLine.Model.CommandSpec;\n \n-@CommandLine.Command(\n-    name = \"jar\",\n-    showAtFileInUsageHelp = true,\n-    description = \"Containerize a jar\",\n-    hidden = true)\n+@CommandLine.Command(name = \"jar\", showAtFileInUsageHelp = true, description = \"Containerize a jar\")\n public class Jar implements Callable<Integer> {\n \n   @CommandLine.Spec\n@@ -161,13 +157,6 @@ public class Jar implements Callable<Integer> {\n \n   @Override\n   public Integer call() {\n-    try {\n-      // Temporarily disable the command, but allow to proceed in tests.\n-      Class.forName(\"org.junit.Test\");\n-    } catch (ClassNotFoundException ex) {\n-      throw new UnsupportedOperationException(\"jar command not implemented\");\n-    }\n-\n     commonCliOptions.validate();\n     SingleThreadedExecutor executor = new SingleThreadedExecutor();\n     try {",
      "parent_sha": "e5776d0f275fc32879d5794c1722acdf418e46ee"
    }
  },
  {
    "oid": "945329159d2418c00084721d689a510d203331d1",
    "message": "Fix wrong hashCode (#2349)",
    "date": "2020-03-20T16:11:12Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/945329159d2418c00084721d689a510d203331d1",
    "details": {
      "sha": "7db374fcdbe21f99197452762b02319b4d5cfe4a",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/configuration/ContainerConfiguration.java",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/945329159d2418c00084721d689a510d203331d1/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fconfiguration%2FContainerConfiguration.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/945329159d2418c00084721d689a510d203331d1/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fconfiguration%2FContainerConfiguration.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fconfiguration%2FContainerConfiguration.java?ref=945329159d2418c00084721d689a510d203331d1",
      "patch": "@@ -373,6 +373,13 @@ public boolean equals(Object other) {\n   @VisibleForTesting\n   public int hashCode() {\n     return Objects.hash(\n-        creationTime, entrypoint, programArguments, environmentMap, exposedPorts, labels, user);\n+        creationTime,\n+        entrypoint,\n+        programArguments,\n+        environmentMap,\n+        exposedPorts,\n+        labels,\n+        user,\n+        workingDirectory);\n   }\n }",
      "parent_sha": "f66214b8467e06ace57038334c5cebdf8b360007"
    }
  },
  {
    "oid": "ecc378d517734224e5660addf606aea37ab8eacc",
    "message": "standard way of server listening (#2137)",
    "date": "2019-11-08T21:51:36Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/ecc378d517734224e5660addf606aea37ab8eacc",
    "details": {
      "sha": "f4b0facf636c661dbb57b68ad6b4844426513eb0",
      "filename": "jib-core/src/test/java/com/google/cloud/tools/jib/http/TestWebServer.java",
      "status": "modified",
      "additions": 26,
      "deletions": 18,
      "changes": 44,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/ecc378d517734224e5660addf606aea37ab8eacc/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fhttp%2FTestWebServer.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/ecc378d517734224e5660addf606aea37ab8eacc/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fhttp%2FTestWebServer.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fhttp%2FTestWebServer.java?ref=ecc378d517734224e5660addf606aea37ab8eacc",
      "patch": "@@ -45,12 +45,13 @@\n public class TestWebServer implements Closeable {\n \n   private final boolean https;\n+  private final int numThreads;\n+  private final List<String> responses;\n+\n   private final ServerSocket serverSocket;\n   private final ExecutorService executorService;\n-  private final Semaphore threadsStarted;\n-  private final StringBuffer inputRead = new StringBuffer(); // StringBuilder not thread-safe\n-\n-  private final List<String> responses;\n+  private final Semaphore serverStarted = new Semaphore(1);\n+  private final StringBuilder inputRead = new StringBuilder();\n \n   public TestWebServer(boolean https)\n       throws IOException, InterruptedException, GeneralSecurityException, URISyntaxException {\n@@ -66,13 +67,11 @@ public TestWebServer(boolean https, List<String> responses, int numThreads)\n       throws IOException, InterruptedException, GeneralSecurityException, URISyntaxException {\n     this.https = https;\n     this.responses = responses;\n+    this.numThreads = numThreads;\n     serverSocket = https ? createHttpsServerSocket() : new ServerSocket(0);\n-    threadsStarted = new Semaphore(1 - numThreads);\n-    executorService = Executors.newFixedThreadPool(numThreads);\n-    for (int i = 0; i < numThreads; i++) {\n-      ignoreReturn(executorService.submit(this::serveResponses));\n-    }\n-    threadsStarted.acquire();\n+    executorService = Executors.newFixedThreadPool(numThreads + 1);\n+    ignoreReturn(executorService.submit(this::listen));\n+    serverStarted.acquire();\n   }\n \n   public int getLocalPort() {\n@@ -108,9 +107,17 @@ private ServerSocket createHttpsServerSocket()\n     return sslContext.getServerSocketFactory().createServerSocket(0);\n   }\n \n-  private Void serveResponses() throws IOException {\n-    threadsStarted.release();\n-    try (Socket socket = serverSocket.accept()) {\n+  private Void listen() throws IOException {\n+    serverStarted.release();\n+    for (int i = 0; i < numThreads; i++) {\n+      Socket socket = serverSocket.accept();\n+      ignoreReturn(executorService.submit(() -> serveResponses(socket)));\n+    }\n+    return null;\n+  }\n+\n+  private Void serveResponses(Socket socket) throws IOException {\n+    try (Socket toClose = socket) {\n       InputStream in = socket.getInputStream();\n       OutputStream out = socket.getOutputStream();\n \n@@ -125,11 +132,12 @@ private Void serveResponses() throws IOException {\n         for (String line = reader.readLine();\n             line != null && !line.isEmpty(); // An empty line marks the end of an HTTP request.\n             line = reader.readLine()) {\n-          if (firstByte == -1) {\n-            inputRead.append(line + \"\\n\");\n-          } else {\n-            inputRead.append(((char) firstByte) + line + \"\\n\");\n-            firstByte = -1;\n+          synchronized (inputRead) {\n+            if (firstByte != -1) {\n+              inputRead.append((char) firstByte);\n+              firstByte = -1;\n+            }\n+            inputRead.append(line).append('\\n');\n           }\n         }\n         out.write(response.getBytes(StandardCharsets.UTF_8));",
      "parent_sha": "230909703f70e64221455e8ee0d9ff1a4b36c757"
    }
  },
  {
    "oid": "a39d58021748f5bf70e4c8d0dc166d7f79aeace9",
    "message": "fix typo (#2266)",
    "date": "2020-02-05T15:54:20Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/a39d58021748f5bf70e4c8d0dc166d7f79aeace9",
    "details": {
      "sha": "0ebc56a4a7327782cc49a83c8c1cb994c97ce36e",
      "filename": "jib-core/src/test/java/com/google/cloud/tools/jib/registry/AuthenticationMethodRetrieverTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/a39d58021748f5bf70e4c8d0dc166d7f79aeace9/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FAuthenticationMethodRetrieverTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/a39d58021748f5bf70e4c8d0dc166d7f79aeace9/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FAuthenticationMethodRetrieverTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FAuthenticationMethodRetrieverTest.java?ref=a39d58021748f5bf70e4c8d0dc166d7f79aeace9",
      "patch": "@@ -97,7 +97,7 @@ public void testHandleHttpResponseException_invalidStatusCode() throws RegistryE\n   }\n \n   @Test\n-  public void tsetHandleHttpResponseException_noHeader() throws ResponseException {\n+  public void testHandleHttpResponseException_noHeader() throws ResponseException {\n     Mockito.when(mockResponseException.getStatusCode())\n         .thenReturn(HttpStatusCodes.STATUS_CODE_UNAUTHORIZED);\n     Mockito.when(mockResponseException.getHeaders()).thenReturn(mockHeaders);",
      "parent_sha": "c588ea7b1bbf670df8ec70f09e0a103cc9733d21"
    }
  },
  {
    "oid": "5b531fce4d1fb89bd63f88bcfe10a6061a3a5e58",
    "message": "Use AbsoluteUnixPath for LayerEntry (#1032)",
    "date": "2018-09-25T22:52:00Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/5b531fce4d1fb89bd63f88bcfe10a6061a3a5e58",
    "details": {
      "sha": "b251065d27b8dd0bb6f0c46f1ae1488c638d27a5",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/image/LayerEntry.java",
      "status": "modified",
      "additions": 1,
      "deletions": 20,
      "changes": 21,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/5b531fce4d1fb89bd63f88bcfe10a6061a3a5e58/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fimage%2FLayerEntry.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/5b531fce4d1fb89bd63f88bcfe10a6061a3a5e58/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fimage%2FLayerEntry.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fimage%2FLayerEntry.java?ref=5b531fce4d1fb89bd63f88bcfe10a6061a3a5e58",
      "patch": "@@ -17,10 +17,8 @@\n package com.google.cloud.tools.jib.image;\n \n import com.google.cloud.tools.jib.filesystem.AbsoluteUnixPath;\n-import com.google.common.base.Preconditions;\n import java.nio.file.Path;\n import java.util.Objects;\n-import java.util.StringJoiner;\n \n /**\n  * Represents an entry in the layer. A layer consists of many entries that can be converted into tar\n@@ -36,23 +34,6 @@\n  */\n public class LayerEntry {\n \n-  /**\n-   * Stringifies {@code path} in Unix form. The path must be absolute.\n-   *\n-   * @param path the path\n-   * @return the string form of the absolute path\n-   */\n-  private static String toUnixPath(Path path) {\n-    Preconditions.checkArgument(\n-        path.getRoot() != null, \"Tried to stringify a non-absolute path: %s\", path);\n-\n-    StringJoiner pathJoiner = new StringJoiner(\"/\", \"/\", \"\");\n-    for (Path pathComponent : path) {\n-      pathJoiner.add(pathComponent.toString());\n-    }\n-    return pathJoiner.toString();\n-  }\n-\n   private final Path sourceFile;\n   private final AbsoluteUnixPath extractionPath;\n \n@@ -108,7 +89,7 @@ public AbsoluteUnixPath getExtractionPath() {\n    * @return the source file path\n    */\n   public String getAbsoluteSourceFileString() {\n-    return toUnixPath(sourceFile.toAbsolutePath());\n+    return AbsoluteUnixPath.fromPath(sourceFile.toAbsolutePath()).toString();\n   }\n \n   /**",
      "parent_sha": "5446d45e87623b5894cef59a9f55c9a6932d57c5"
    }
  },
  {
    "oid": "4de2fd94a70a0617a2e24550a4b7acf7220b93a8",
    "message": "Fixes validation log message for 'format' parameter. (#324)",
    "date": "2018-05-30T14:45:40Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/4de2fd94a70a0617a2e24550a4b7acf7220b93a8",
    "details": {
      "sha": "311ac13a5c0f28726afd7fe282ab51667ce7d09b",
      "filename": "jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/BuildImageMojo.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/4de2fd94a70a0617a2e24550a4b7acf7220b93a8/jib-maven-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FBuildImageMojo.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/4de2fd94a70a0617a2e24550a4b7acf7220b93a8/jib-maven-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FBuildImageMojo.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-maven-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FBuildImageMojo.java?ref=4de2fd94a70a0617a2e24550a4b7acf7220b93a8",
      "patch": "@@ -62,10 +62,10 @@ private Class<? extends BuildableManifestTemplate> getManifestTemplateClass() {\n \n   @Override\n   public void execute() throws MojoExecutionException, MojoFailureException {\n-    // Validate 'imageFormat'.\n+    // Validates 'format'.\n     if (Arrays.stream(ImageFormat.values()).noneMatch(value -> value.name().equals(getFormat()))) {\n       throw new MojoFailureException(\n-          \"<imageFormat> parameter is configured with value '\"\n+          \"<format> parameter is configured with value '\"\n               + getFormat()\n               + \"', but the only valid configuration options are '\"\n               + ImageFormat.Docker",
      "parent_sha": "10947d8b6bde8cb277e89540737a80458a36e0ad"
    }
  },
  {
    "oid": "e8a46540db4a20ccc274a1ec1f4a6109d17768c6",
    "message": "Refactor StepsRunner for consistent loop pattern (#2772)",
    "date": "2020-09-21T15:13:02Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/e8a46540db4a20ccc274a1ec1f4a6109d17768c6",
    "details": {
      "sha": "dc578f6beccd9ceffb63e35daf8bb414592f82b4",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java",
      "status": "modified",
      "additions": 93,
      "deletions": 63,
      "changes": 156,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/e8a46540db4a20ccc274a1ec1f4a6109d17768c6/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FStepsRunner.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/e8a46540db4a20ccc274a1ec1f4a6109d17768c6/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FStepsRunner.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FStepsRunner.java?ref=e8a46540db4a20ccc274a1ec1f4a6109d17768c6",
      "patch": "@@ -18,7 +18,6 @@\n \n import com.google.cloud.tools.jib.blob.BlobDescriptor;\n import com.google.cloud.tools.jib.builder.ProgressEventDispatcher;\n-import com.google.cloud.tools.jib.builder.ProgressEventDispatcher.Factory;\n import com.google.cloud.tools.jib.builder.steps.LocalBaseImageSteps.LocalImage;\n import com.google.cloud.tools.jib.builder.steps.PullBaseImageStep.ImagesAndRegistryClient;\n import com.google.cloud.tools.jib.configuration.BuildContext;\n@@ -187,7 +186,7 @@ public StepsRunner registryPushSteps() {\n     stepsToRun.add(this::buildManifestListOrSingleManifest);\n \n     // push to registry\n-    stepsToRun.add(this::pushBaseImageLayers);\n+    stepsToRun.add(this::pushBaseImagesLayers);\n     stepsToRun.add(this::pushApplicationLayers);\n     stepsToRun.add(this::pushContainerConfigurations);\n     stepsToRun.add(this::checkManifestInTargetRegistry);\n@@ -240,7 +239,7 @@ private void addRetrievalSteps(boolean layersRequiredLocally) {\n     } else {\n       // Otherwise default to RegistryImage\n       stepsToRun.add(this::pullBaseImages);\n-      stepsToRun.add(() -> obtainBaseImageLayers(layersRequiredLocally));\n+      stepsToRun.add(() -> obtainBaseImagesLayers(layersRequiredLocally));\n     }\n   }\n \n@@ -309,7 +308,7 @@ private void pullBaseImages() {\n         executorService.submit(new PullBaseImageStep(buildContext, childProgressDispatcherFactory));\n   }\n \n-  private void obtainBaseImageLayers(boolean layersRequiredLocally) {\n+  private void obtainBaseImagesLayers(boolean layersRequiredLocally) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n@@ -327,28 +326,37 @@ private void obtainBaseImageLayers(boolean layersRequiredLocally) {\n                       results.baseImagesAndRegistryClient.get().images.size());\n \n               Map<Image, List<Future<PreparedLayer>>> baseImagesAndLayers = new HashMap<>();\n-              for (Image image : results.baseImagesAndRegistryClient.get().images) {\n+              for (Image baseImage : results.baseImagesAndRegistryClient.get().images) {\n                 List<Future<PreparedLayer>> layers =\n-                    scheduleCallables(\n-                        layersRequiredLocally\n-                            ? ObtainBaseImageLayerStep.makeListForForcedDownload(\n-                                buildContext,\n-                                progressDispatcher.newChildProducer(),\n-                                image,\n-                                results.baseImagesAndRegistryClient.get().registryClient)\n-                            : ObtainBaseImageLayerStep.makeListForSelectiveDownload(\n-                                buildContext,\n-                                progressDispatcher.newChildProducer(),\n-                                image,\n-                                results.baseImagesAndRegistryClient.get().registryClient,\n-                                results.targetRegistryClient.get()));\n-                baseImagesAndLayers.put(image, layers);\n+                    obtainBaseImageLayers(\n+                        baseImage, layersRequiredLocally, progressDispatcher.newChildProducer());\n+                baseImagesAndLayers.put(baseImage, layers);\n               }\n               return baseImagesAndLayers;\n             });\n   }\n \n-  private void pushBaseImageLayers() {\n+  private List<Future<PreparedLayer>> obtainBaseImageLayers(\n+      Image baseImage,\n+      boolean layersRequiredLocally,\n+      ProgressEventDispatcher.Factory progressDispatcherFactory)\n+      throws InterruptedException, ExecutionException {\n+    return scheduleCallables(\n+        layersRequiredLocally\n+            ? ObtainBaseImageLayerStep.makeListForForcedDownload(\n+                buildContext,\n+                progressDispatcherFactory,\n+                baseImage,\n+                results.baseImagesAndRegistryClient.get().registryClient)\n+            : ObtainBaseImageLayerStep.makeListForSelectiveDownload(\n+                buildContext,\n+                progressDispatcherFactory,\n+                baseImage,\n+                results.baseImagesAndRegistryClient.get().registryClient,\n+                results.targetRegistryClient.get()));\n+  }\n+\n+  private void pushBaseImagesLayers() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n@@ -365,25 +373,32 @@ private void pushBaseImageLayers() {\n                       \"scheduling pushing base image layers\",\n                       results.baseImagesAndLayers.get().size());\n \n-              Map<Image, List<Future<BlobDescriptor>>> pushResults = new HashMap<>();\n+              Map<Image, List<Future<BlobDescriptor>>> layerPushResults = new HashMap<>();\n               for (Map.Entry<Image, List<Future<PreparedLayer>>> entry :\n                   results.baseImagesAndLayers.get().entrySet()) {\n                 Image baseImage = entry.getKey();\n-                List<Future<PreparedLayer>> baseImageLayers = entry.getValue();\n-\n-                List<Future<BlobDescriptor>> baseImageLayerPushResult =\n-                    scheduleCallables(\n-                        PushLayerStep.makeList(\n-                            buildContext,\n-                            progressDispatcher.newChildProducer(),\n-                            results.targetRegistryClient.get(),\n-                            Verify.verifyNotNull(baseImageLayers)));\n-                pushResults.put(baseImage, baseImageLayerPushResult);\n+                List<Future<PreparedLayer>> baseLayers = entry.getValue();\n+\n+                List<Future<BlobDescriptor>> pushResults =\n+                    pushBaseImageLayers(baseLayers, progressDispatcher.newChildProducer());\n+                layerPushResults.put(baseImage, pushResults);\n               }\n-              return pushResults;\n+              return layerPushResults;\n             });\n   }\n \n+  private List<Future<BlobDescriptor>> pushBaseImageLayers(\n+      List<Future<PreparedLayer>> baseLayers,\n+      ProgressEventDispatcher.Factory progressDispatcherFactory)\n+      throws InterruptedException, ExecutionException {\n+    return scheduleCallables(\n+        PushLayerStep.makeList(\n+            buildContext,\n+            progressDispatcherFactory,\n+            results.targetRegistryClient.get(),\n+            Verify.verifyNotNull(baseLayers)));\n+  }\n+\n   private void buildAndCacheApplicationLayers() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n@@ -413,26 +428,32 @@ private void buildImages() {\n               Map<Image, Future<Image>> baseImagesAndBuiltImages = new HashMap<>();\n               for (Map.Entry<Image, List<Future<PreparedLayer>>> entry :\n                   results.baseImagesAndLayers.get().entrySet()) {\n-                ProgressEventDispatcher.Factory progressDispatcherFactory =\n-                    progressDispatcher.newChildProducer();\n+                Image baseImage = entry.getKey();\n+                List<Future<PreparedLayer>> baseLayers = entry.getValue();\n \n                 Future<Image> builtImage =\n-                    executorService.submit(\n-                        () ->\n-                            new BuildImageStep(\n-                                    buildContext,\n-                                    progressDispatcherFactory,\n-                                    entry.getKey(), // base Image\n-                                    realizeFutures(\n-                                        Verify.verifyNotNull(entry.getValue())), // layers\n-                                    realizeFutures(Verify.verifyNotNull(results.applicationLayers)))\n-                                .call());\n-                baseImagesAndBuiltImages.put(entry.getKey() /* base Image */, builtImage);\n+                    buildImage(baseImage, baseLayers, progressDispatcher.newChildProducer());\n+                baseImagesAndBuiltImages.put(baseImage, builtImage);\n               }\n               return baseImagesAndBuiltImages;\n             });\n   }\n \n+  private Future<Image> buildImage(\n+      Image baseImage,\n+      List<Future<PreparedLayer>> baseLayers,\n+      ProgressEventDispatcher.Factory progressDispatcherFactory) {\n+    return executorService.submit(\n+        () ->\n+            new BuildImageStep(\n+                    buildContext,\n+                    progressDispatcherFactory,\n+                    baseImage,\n+                    realizeFutures(baseLayers),\n+                    realizeFutures(Verify.verifyNotNull(results.applicationLayers)))\n+                .call());\n+  }\n+\n   private void buildManifestListOrSingleManifest() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n@@ -464,27 +485,32 @@ private void pushContainerConfigurations() {\n                       \"scheduling pushing container configurations\",\n                       results.baseImagesAndBuiltImages.get().size());\n \n-              Map<Image, Future<BlobDescriptor>> pushResults = new HashMap<>();\n+              Map<Image, Future<BlobDescriptor>> configPushResults = new HashMap<>();\n               for (Map.Entry<Image, Future<Image>> entry :\n                   results.baseImagesAndBuiltImages.get().entrySet()) {\n-                ProgressEventDispatcher.Factory progressDispatcherFactory =\n-                    progressDispatcher.newChildProducer();\n-\n-                Future<BlobDescriptor> configPushResult =\n-                    executorService.submit(\n-                        () ->\n-                            new PushContainerConfigurationStep(\n-                                    buildContext,\n-                                    progressDispatcherFactory,\n-                                    results.targetRegistryClient.get(),\n-                                    entry.getValue().get() /* built image */)\n-                                .call());\n-                pushResults.put(entry.getKey() /* base image */, configPushResult);\n+                Image baseImage = entry.getKey();\n+                Future<Image> builtImage = entry.getValue();\n+\n+                Future<BlobDescriptor> pushResult =\n+                    pushContainerConfiguration(builtImage, progressDispatcher.newChildProducer());\n+                configPushResults.put(baseImage, pushResult);\n               }\n-              return pushResults;\n+              return configPushResults;\n             });\n   }\n \n+  private Future<BlobDescriptor> pushContainerConfiguration(\n+      Future<Image> builtImage, ProgressEventDispatcher.Factory progressDispatcherFactory) {\n+    return executorService.submit(\n+        () ->\n+            new PushContainerConfigurationStep(\n+                    buildContext,\n+                    progressDispatcherFactory,\n+                    results.targetRegistryClient.get(),\n+                    builtImage.get())\n+                .call());\n+  }\n+\n   private void pushApplicationLayers() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n@@ -537,16 +563,20 @@ private void pushImages() {\n               List<Future<BuildResult>> buildResults = new ArrayList<>();\n               for (Map.Entry<Image, Future<Image>> entry :\n                   results.baseImagesAndBuiltImages.get().entrySet()) {\n+                Image baseImage = entry.getKey();\n+                Future<Image> builtImage = entry.getValue();\n+\n                 buildResults.add(\n-                    pushImage(\n-                        entry.getValue(), entry.getKey(), progressDispatcher.newChildProducer()));\n+                    pushImage(baseImage, builtImage, progressDispatcher.newChildProducer()));\n               }\n               return buildResults;\n             });\n   }\n \n   private Future<BuildResult> pushImage(\n-      Future<Image> builtImage, Image baseImage, Factory progressDispatcherFactory) {\n+      Image baseImage,\n+      Future<Image> builtImage,\n+      ProgressEventDispatcher.Factory progressDispatcherFactory) {\n     return executorService.submit(\n         () -> {\n           realizeFutures(",
      "parent_sha": "11e21ab51e96a00291472f3c5fab21755ef703c1"
    }
  },
  {
    "oid": "917e2c0e314361c3415f981504cac07df20114bd",
    "message": "Write after reading input (#1624)",
    "date": "2019-04-15T14:34:17Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/917e2c0e314361c3415f981504cac07df20114bd",
    "details": {
      "sha": "3633b3330232179e48a863c03a68d81145922f33",
      "filename": "jib-core/src/test/java/com/google/cloud/tools/jib/http/TestWebServer.java",
      "status": "modified",
      "additions": 12,
      "deletions": 6,
      "changes": 18,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/917e2c0e314361c3415f981504cac07df20114bd/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fhttp%2FTestWebServer.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/917e2c0e314361c3415f981504cac07df20114bd/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fhttp%2FTestWebServer.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fhttp%2FTestWebServer.java?ref=917e2c0e314361c3415f981504cac07df20114bd",
      "patch": "@@ -17,9 +17,11 @@\n package com.google.cloud.tools.jib.http;\n \n import com.google.common.io.Resources;\n+import java.io.BufferedReader;\n import java.io.Closeable;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.InputStreamReader;\n import java.net.ServerSocket;\n import java.net.Socket;\n import java.net.URISyntaxException;\n@@ -43,7 +45,7 @@ public class TestWebServer implements Closeable {\n   private final ServerSocket serverSocket;\n   private final ExecutorService executorService = Executors.newSingleThreadExecutor();\n   private final Semaphore threadStarted = new Semaphore(0);\n-  private final StringBuffer inputRead = new StringBuffer();\n+  private final StringBuilder inputRead = new StringBuilder();\n \n   public TestWebServer(boolean https)\n       throws IOException, InterruptedException, GeneralSecurityException, URISyntaxException {\n@@ -89,14 +91,18 @@ private ServerSocket createServerSocket(boolean https)\n   private Void serve200() throws IOException {\n     threadStarted.release();\n     try (Socket socket = serverSocket.accept()) {\n-      String response = \"HTTP/1.1 200 OK\\nContent-Length:12\\n\\nHello World!\";\n-      socket.getOutputStream().write(response.getBytes(StandardCharsets.UTF_8));\n-      socket.getOutputStream().flush();\n \n       InputStream in = socket.getInputStream();\n-      for (int ch = in.read(); ch != -1; ch = in.read()) {\n-        inputRead.append((char) ch);\n+      BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n+      for (String line = reader.readLine();\n+          line != null && !line.isEmpty(); // An empty line marks the end of an HTTP request.\n+          line = reader.readLine()) {\n+        inputRead.append(line + \"\\n\");\n       }\n+\n+      String response = \"HTTP/1.1 200 OK\\nContent-Length:12\\n\\nHello World!\";\n+      socket.getOutputStream().write(response.getBytes(StandardCharsets.UTF_8));\n+      socket.getOutputStream().flush();\n     }\n     return null;\n   }",
      "parent_sha": "4976cb09ffcdfa92dbc2a7e94ae357e56c5701b9"
    }
  },
  {
    "oid": "fdffc6fdc71e0c370fe14bd185172c92572937dd",
    "message": "Fix progress display tests ignoring locale (#1444)",
    "date": "2019-01-23T22:15:31Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/fdffc6fdc71e0c370fe14bd185172c92572937dd",
    "details": {
      "sha": "cd57690e5e418eb5bcbc66c8d2522d714f39cef2",
      "filename": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/logging/ProgressDisplayGeneratorTest.java",
      "status": "modified",
      "additions": 8,
      "deletions": 4,
      "changes": 12,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/fdffc6fdc71e0c370fe14bd185172c92572937dd/jib-plugins-common%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2Flogging%2FProgressDisplayGeneratorTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/fdffc6fdc71e0c370fe14bd185172c92572937dd/jib-plugins-common%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2Flogging%2FProgressDisplayGeneratorTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-plugins-common%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2Flogging%2FProgressDisplayGeneratorTest.java?ref=fdffc6fdc71e0c370fe14bd185172c92572937dd",
      "patch": "@@ -25,24 +25,28 @@\n /** Tests for {@link com.google.cloud.tools.jib.plugins.common.logging.ProgressDisplayGenerator}. */\n public class ProgressDisplayGeneratorTest {\n \n+  private static String getBar(String bar, double value) {\n+    return String.format(\"%s %.1f%% complete\", bar, value);\n+  }\n+\n   @Test\n   public void testGenerateProgressDisplay_progressBar_0() {\n     Assert.assertEquals(\n-        Arrays.asList(\"Executing tasks:\", \"[                              ] 0.0% complete\"),\n+        Arrays.asList(\"Executing tasks:\", getBar(\"[                              ]\", 0.0)),\n         ProgressDisplayGenerator.generateProgressDisplay(0, Collections.emptyList()));\n   }\n \n   @Test\n   public void testGenerateProgressDisplay_progressBar_50() {\n     Assert.assertEquals(\n-        Arrays.asList(\"Executing tasks:\", \"[===============               ] 50.0% complete\"),\n+        Arrays.asList(\"Executing tasks:\", getBar(\"[===============               ]\", 50.0)),\n         ProgressDisplayGenerator.generateProgressDisplay(0.5, Collections.emptyList()));\n   }\n \n   @Test\n   public void testGenerateProgressDisplay_progressBar_100() {\n     Assert.assertEquals(\n-        Arrays.asList(\"Executing tasks:\", \"[==============================] 100.0% complete\"),\n+        Arrays.asList(\"Executing tasks:\", getBar(\"[==============================]\", 100.0)),\n         ProgressDisplayGenerator.generateProgressDisplay(1, Collections.emptyList()));\n   }\n \n@@ -56,7 +60,7 @@ public void testGenerateProgressDisplay_unfinishedTasks() {\n     Assert.assertEquals(\n         Arrays.asList(\n             \"Executing tasks:\",\n-            \"[===============               ] 50.0% complete\",\n+            getBar(\"[===============               ]\", 50.0),\n             \"> childLeftDown\",\n             \"> childRight\"),\n         ProgressDisplayGenerator.generateProgressDisplay(",
      "parent_sha": "66afa6047de88f4e8fed9b3e0d581f70ce94ca3a"
    }
  },
  {
    "oid": "7f506195a9c42303f3029ef58a42e392d1c7508c",
    "message": "rename field 'builder'. (#3403)\n\nFix for sonar issue: A field should not duplicate the name of its containing class",
    "date": "2021-08-12T00:34:36Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/7f506195a9c42303f3029ef58a42e392d1c7508c",
    "details": {
      "sha": "fb410268c570c5b025a6d9f66c9e343fa481738d",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/api/LayerConfiguration.java",
      "status": "modified",
      "additions": 13,
      "deletions": 12,
      "changes": 25,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/7f506195a9c42303f3029ef58a42e392d1c7508c/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fapi%2FLayerConfiguration.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/7f506195a9c42303f3029ef58a42e392d1c7508c/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fapi%2FLayerConfiguration.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fapi%2FLayerConfiguration.java?ref=7f506195a9c42303f3029ef58a42e392d1c7508c",
      "patch": "@@ -42,7 +42,7 @@ public class LayerConfiguration {\n   /** Builds a {@link LayerConfiguration}. */\n   public static class Builder {\n \n-    private FileEntriesLayer.Builder builder = FileEntriesLayer.builder();\n+    private FileEntriesLayer.Builder layerBuilder = FileEntriesLayer.builder();\n \n     private Builder() {}\n \n@@ -53,7 +53,7 @@ private Builder() {}\n      * @return this\n      */\n     public Builder setName(String name) {\n-      builder.setName(name);\n+      layerBuilder.setName(name);\n       return this;\n     }\n \n@@ -64,7 +64,7 @@ public Builder setName(String name) {\n      * @return this\n      */\n     public Builder setEntries(List<LayerEntry> entries) {\n-      builder.setEntries(\n+      layerBuilder.setEntries(\n           entries.stream().map(LayerEntry::toFileEntry).collect(Collectors.toList()));\n       return this;\n     }\n@@ -76,7 +76,7 @@ public Builder setEntries(List<LayerEntry> entries) {\n      * @return this\n      */\n     public Builder addEntry(LayerEntry entry) {\n-      builder.addEntry(entry.toFileEntry());\n+      layerBuilder.addEntry(entry.toFileEntry());\n       return this;\n     }\n \n@@ -99,7 +99,7 @@ public Builder addEntry(LayerEntry entry) {\n      * @return this\n      */\n     public Builder addEntry(Path sourceFile, AbsoluteUnixPath pathInContainer) {\n-      builder.addEntry(sourceFile, pathInContainer);\n+      layerBuilder.addEntry(sourceFile, pathInContainer);\n       return this;\n     }\n \n@@ -119,7 +119,7 @@ public Builder addEntry(Path sourceFile, AbsoluteUnixPath pathInContainer) {\n      */\n     public Builder addEntry(\n         Path sourceFile, AbsoluteUnixPath pathInContainer, FilePermissions permissions) {\n-      builder.addEntry(sourceFile, pathInContainer, permissions);\n+      layerBuilder.addEntry(sourceFile, pathInContainer, permissions);\n       return this;\n     }\n \n@@ -137,7 +137,7 @@ public Builder addEntry(\n      */\n     public Builder addEntry(\n         Path sourceFile, AbsoluteUnixPath pathInContainer, Instant modificationTime) {\n-      builder.addEntry(sourceFile, pathInContainer, modificationTime);\n+      layerBuilder.addEntry(sourceFile, pathInContainer, modificationTime);\n       return this;\n     }\n \n@@ -161,7 +161,8 @@ public Builder addEntry(\n         AbsoluteUnixPath pathInContainer,\n         FilePermissions permissions,\n         Instant modificationTime) {\n-      builder.addEntry(new FileEntry(sourceFile, pathInContainer, permissions, modificationTime));\n+      layerBuilder.addEntry(\n+          new FileEntry(sourceFile, pathInContainer, permissions, modificationTime));\n       return this;\n     }\n \n@@ -182,7 +183,7 @@ public Builder addEntry(\n      */\n     public Builder addEntryRecursive(Path sourceFile, AbsoluteUnixPath pathInContainer)\n         throws IOException {\n-      builder.addEntryRecursive(sourceFile, pathInContainer);\n+      layerBuilder.addEntryRecursive(sourceFile, pathInContainer);\n       return this;\n     }\n \n@@ -203,7 +204,7 @@ public Builder addEntryRecursive(\n         AbsoluteUnixPath pathInContainer,\n         FilePermissionsProvider filePermissionProvider)\n         throws IOException {\n-      builder.addEntryRecursive(sourceFile, pathInContainer, filePermissionProvider);\n+      layerBuilder.addEntryRecursive(sourceFile, pathInContainer, filePermissionProvider);\n       return this;\n     }\n \n@@ -227,7 +228,7 @@ public Builder addEntryRecursive(\n         FilePermissionsProvider filePermissionProvider,\n         ModificationTimeProvider modificationTimeProvider)\n         throws IOException {\n-      builder.addEntryRecursive(\n+      layerBuilder.addEntryRecursive(\n           sourceFile, pathInContainer, filePermissionProvider, modificationTimeProvider);\n       return this;\n     }\n@@ -238,7 +239,7 @@ public Builder addEntryRecursive(\n      * @return the built {@link LayerConfiguration}\n      */\n     public LayerConfiguration build() {\n-      return new LayerConfiguration(builder.build());\n+      return new LayerConfiguration(layerBuilder.build());\n     }\n   }\n ",
      "parent_sha": "03a9507b3f3a2961c53691e8e22dd42194c4e005"
    }
  },
  {
    "oid": "fe8cf8b3cab5197b5c0c5f575de2e981f44accd4",
    "message": "Fix regex bug (#680)\n\n* Fix regex bug\r\n* [-]+  -->  -+",
    "date": "2018-07-20T17:46:33Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/fe8cf8b3cab5197b5c0c5f575de2e981f44accd4",
    "details": {
      "sha": "cef5a181ffef16aa08607535374adc698fedb51f",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/image/ImageReference.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/fe8cf8b3cab5197b5c0c5f575de2e981f44accd4/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fimage%2FImageReference.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/fe8cf8b3cab5197b5c0c5f575de2e981f44accd4/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fimage%2FImageReference.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fimage%2FImageReference.java?ref=fe8cf8b3cab5197b5c0c5f575de2e981f44accd4",
      "patch": "@@ -54,8 +54,7 @@ public class ImageReference {\n    *\n    * <p>A separator is either an underscore, a dot, two underscores, or any number of dashes.\n    */\n-  private static final String REPOSITORY_COMPONENT_REGEX =\n-      \"[a-z\\\\d]+(?:(?:[_.]|__|[-]*)[a-z\\\\d]+)*\";\n+  private static final String REPOSITORY_COMPONENT_REGEX = \"[a-z\\\\d]+(?:(?:[_.]|__|-+)[a-z\\\\d]+)*\";\n \n   /** Matches all repetitions of {@code REPOSITORY_COMPONENT_REGEX} separated by a backslash. */\n   private static final String REPOSITORY_REGEX =",
      "parent_sha": "518f046206198eeb8fcc8ffb379169ed50cedbbd"
    }
  },
  {
    "oid": "177ba33248e422411a74d130ba9974861f9353f5",
    "message": "Do not fail when attempting to delete temp directory (#1439)",
    "date": "2019-01-22T15:14:25Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/177ba33248e422411a74d130ba9974861f9353f5",
    "details": {
      "sha": "99977dddbb7a209cb196770f3cd091e750636998",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/filesystem/TemporaryDirectory.java",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/177ba33248e422411a74d130ba9974861f9353f5/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Ffilesystem%2FTemporaryDirectory.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/177ba33248e422411a74d130ba9974861f9353f5/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Ffilesystem%2FTemporaryDirectory.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Ffilesystem%2FTemporaryDirectory.java?ref=177ba33248e422411a74d130ba9974861f9353f5",
      "patch": "@@ -19,7 +19,9 @@\n import com.google.common.io.MoreFiles;\n import com.google.common.io.RecursiveDeleteOption;\n import java.io.Closeable;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.nio.file.FileSystemException;\n import java.nio.file.Files;\n import java.nio.file.Path;\n \n@@ -53,7 +55,11 @@ public Path getDirectory() {\n   @Override\n   public void close() throws IOException {\n     if (Files.exists(temporaryDirectory)) {\n-      MoreFiles.deleteRecursively(temporaryDirectory, RecursiveDeleteOption.ALLOW_INSECURE);\n+      try {\n+        MoreFiles.deleteRecursively(temporaryDirectory, RecursiveDeleteOption.ALLOW_INSECURE);\n+      } catch (FileNotFoundException | FileSystemException ex) {\n+        // TODO log error; deletion is best-effort\n+      }\n     }\n   }\n }",
      "parent_sha": "653ed72f36d0d5467d61757e2b3cd389c06ce496"
    }
  },
  {
    "oid": "3166426a1dd16b68b5b14d636bbb119fe197ad4c",
    "message": "Fix FileOperationsTest since tryLock() can return null (#1269)",
    "date": "2018-11-21T19:27:17Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/3166426a1dd16b68b5b14d636bbb119fe197ad4c",
    "details": {
      "sha": "ac751a9ecd70edadcd0b117f25b159370d0f8329",
      "filename": "jib-core/src/test/java/com/google/cloud/tools/jib/filesystem/FileOperationsTest.java",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/3166426a1dd16b68b5b14d636bbb119fe197ad4c/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Ffilesystem%2FFileOperationsTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/3166426a1dd16b68b5b14d636bbb119fe197ad4c/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Ffilesystem%2FFileOperationsTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Ffilesystem%2FFileOperationsTest.java?ref=3166426a1dd16b68b5b14d636bbb119fe197ad4c",
      "patch": "@@ -26,6 +26,7 @@\n import java.net.URISyntaxException;\n import java.nio.channels.Channels;\n import java.nio.channels.FileChannel;\n+import java.nio.channels.FileLock;\n import java.nio.channels.OverlappingFileLockException;\n import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n@@ -44,9 +45,10 @@ private static void verifyWriteWithLock(Path file) throws IOException {\n     OutputStream fileOutputStream = FileOperations.newLockingOutputStream(file);\n \n     // Checks that the file was locked.\n-    try {\n-      FileChannel.open(file, StandardOpenOption.READ).tryLock(0, Long.MAX_VALUE, true);\n-      Assert.fail(\"Lock attempt should have failed\");\n+    try (FileChannel channel = FileChannel.open(file, StandardOpenOption.READ)) {\n+      // locking should either fail and return null or throw an OverlappingFileLockException\n+      FileLock lock = channel.tryLock(0, Long.MAX_VALUE, true);\n+      Assert.assertNull(\"Lock attempt should have failed\", lock);\n \n     } catch (OverlappingFileLockException ex) {\n       // pass",
      "parent_sha": "882c85b39fcf03abed1235788eb4af73f3d4dd3e"
    }
  },
  {
    "oid": "b0174eb35e008286f828000152f7a6abbae86ab5",
    "message": "clean up (#1515)",
    "date": "2019-02-27T19:11:29Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/b0174eb35e008286f828000152f7a6abbae86ab5",
    "details": {
      "sha": "f870911d26550d7b536b69afabbfbed5989b5fa9",
      "filename": "jib-core/src/test/java/com/google/cloud/tools/jib/http/WithServerConnectionTest.java",
      "status": "modified",
      "additions": 3,
      "deletions": 10,
      "changes": 13,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/b0174eb35e008286f828000152f7a6abbae86ab5/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fhttp%2FWithServerConnectionTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/b0174eb35e008286f828000152f7a6abbae86ab5/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fhttp%2FWithServerConnectionTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fhttp%2FWithServerConnectionTest.java?ref=b0174eb35e008286f828000152f7a6abbae86ab5",
      "patch": "@@ -16,11 +16,10 @@\n \n package com.google.cloud.tools.jib.http;\n \n-import java.io.ByteArrayOutputStream;\n+import com.google.cloud.tools.jib.blob.Blobs;\n import java.io.IOException;\n import java.net.URISyntaxException;\n import java.net.URL;\n-import java.nio.charset.StandardCharsets;\n import java.security.GeneralSecurityException;\n import javax.net.ssl.SSLException;\n import org.junit.Assert;\n@@ -38,10 +37,7 @@ public void testGet()\n       Response response = connection.send(\"GET\", new Request.Builder().build());\n \n       Assert.assertEquals(200, response.getStatusCode());\n-\n-      ByteArrayOutputStream out = new ByteArrayOutputStream();\n-      response.getBody().writeTo(out);\n-      Assert.assertEquals(\"Hello World!\", new String(out.toByteArray(), StandardCharsets.UTF_8));\n+      Assert.assertEquals(\"Hello World!\", Blobs.writeToString(response.getBody()));\n     }\n   }\n \n@@ -85,10 +81,7 @@ public void testInsecureConnection()\n       Response response = connection.send(\"GET\", new Request.Builder().build());\n \n       Assert.assertEquals(200, response.getStatusCode());\n-\n-      ByteArrayOutputStream out = new ByteArrayOutputStream();\n-      response.getBody().writeTo(out);\n-      Assert.assertEquals(\"Hello World!\", new String(out.toByteArray(), StandardCharsets.UTF_8));\n+      Assert.assertEquals(\"Hello World!\", Blobs.writeToString(response.getBody()));\n     }\n   }\n }",
      "parent_sha": "f36a57c67b08e1b104131e93266a42c3c65877a0"
    }
  },
  {
    "oid": "e252965fbc51b47f00f5f590136b61a19023f098",
    "message": "fix: make DockerClientResolver#resolve threadsafe (#3993)\n\n* Fix for #3981.\r\n* Use an instance of ServiceLoader per a call to DockerClientResolver.dockerClients() rather than sharing an instance between all of them, to avoid using a ServiceLoader instance concurrently",
    "date": "2023-05-10T18:48:16Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/e252965fbc51b47f00f5f590136b61a19023f098",
    "details": {
      "sha": "025114013caf03044e60cbf02615d0783f2b3a3c",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/docker/DockerClientResolver.java",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/e252965fbc51b47f00f5f590136b61a19023f098/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fdocker%2FDockerClientResolver.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/e252965fbc51b47f00f5f590136b61a19023f098/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fdocker%2FDockerClientResolver.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fdocker%2FDockerClientResolver.java?ref=e252965fbc51b47f00f5f590136b61a19023f098",
      "patch": "@@ -23,9 +23,6 @@\n \n public class DockerClientResolver {\n \n-  private static final ServiceLoader<DockerClient> dockerClients =\n-      ServiceLoader.load(DockerClient.class);\n-\n   private DockerClientResolver() {}\n \n   /**\n@@ -35,6 +32,7 @@ private DockerClientResolver() {}\n    * @return dockerClient if any is found\n    */\n   public static Optional<DockerClient> resolve(Map<String, String> parameters) {\n+    ServiceLoader<DockerClient> dockerClients = ServiceLoader.load(DockerClient.class);\n     for (DockerClient dockerClient : dockerClients) {\n       if (dockerClient.supported(parameters)) {\n         return Optional.of(dockerClient);",
      "parent_sha": "dd5d60f972b90ed4fdc1960bd8272eac15c3cfea"
    }
  },
  {
    "oid": "c2cc4365f1fbc0ad8cebf66881695e27d181253b",
    "message": "Migrate tests to use Truth framework (second round) (#3169)",
    "date": "2021-03-29T19:24:42Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/c2cc4365f1fbc0ad8cebf66881695e27d181253b",
    "details": {
      "sha": "484dd60ae48885148c53f215c0ed62914a06e75f",
      "filename": "jib-plugins-common/src/test/java/com/google/cloud/tools/jib/plugins/common/PluginConfigurationProcessorTest.java",
      "status": "modified",
      "additions": 192,
      "deletions": 226,
      "changes": 418,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/c2cc4365f1fbc0ad8cebf66881695e27d181253b/jib-plugins-common%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FPluginConfigurationProcessorTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/c2cc4365f1fbc0ad8cebf66881695e27d181253b/jib-plugins-common%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FPluginConfigurationProcessorTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-plugins-common%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FPluginConfigurationProcessorTest.java?ref=c2cc4365f1fbc0ad8cebf66881695e27d181253b",
      "patch": "@@ -18,11 +18,12 @@\n \n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n-import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertThrows;\n-import static org.junit.Assert.fail;\n import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n import static org.mockito.Mockito.when;\n \n import com.google.cloud.tools.jib.api.CacheDirectoryCreationException;\n@@ -46,8 +47,8 @@\n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.io.Resources;\n+import com.google.common.truth.Correspondence;\n import java.io.File;\n-import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.net.URISyntaxException;\n import java.nio.file.Files;\n@@ -60,10 +61,7 @@\n import java.util.List;\n import java.util.Optional;\n import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n import javax.annotation.Nullable;\n-import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n@@ -80,30 +78,18 @@\n @RunWith(MockitoJUnitRunner.class)\n public class PluginConfigurationProcessorTest {\n \n+  private static final Correspondence<FileEntry, Path> SOURCE_FILE_OF =\n+      Correspondence.transforming(FileEntry::getSourceFile, \"has sourceFile of\");\n+  private static final Correspondence<FileEntry, String> EXTRACTION_PATH_OF =\n+      Correspondence.transforming(\n+          entry -> entry.getExtractionPath().toString(), \"has extractionPath of\");\n+\n   private static BuildContext getBuildContext(JibContainerBuilder jibContainerBuilder)\n       throws InvalidImageReferenceException, CacheDirectoryCreationException {\n     return JibContainerBuilderTestHelper.toBuildContext(\n         jibContainerBuilder, Containerizer.to(RegistryImage.named(\"ignored\")));\n   }\n \n-  private static <T> void assertLayerEntriesUnordered(\n-      List<T> expectedPaths, List<FileEntry> entries, Function<FileEntry, T> fieldSelector) {\n-    List<T> expected = expectedPaths.stream().sorted().collect(Collectors.toList());\n-    List<T> actual = entries.stream().map(fieldSelector).sorted().collect(Collectors.toList());\n-    assertEquals(expected, actual);\n-  }\n-\n-  private static void assertSourcePathsUnordered(\n-      List<Path> expectedPaths, List<FileEntry> entries) {\n-    assertLayerEntriesUnordered(expectedPaths, entries, FileEntry::getSourceFile);\n-  }\n-\n-  private static void assertExtractionPathsUnordered(\n-      List<String> expectedPaths, List<FileEntry> entries) {\n-    assertLayerEntriesUnordered(\n-        expectedPaths, entries, layerEntry -> layerEntry.getExtractionPath().toString());\n-  }\n-\n   @Rule public final RestoreSystemProperties systemPropertyRestorer = new RestoreSystemProperties();\n   @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();\n \n@@ -170,15 +156,16 @@ public void testPluginConfigurationProcessor_defaults()\n           InvalidCreationTimeException {\n     BuildContext buildContext = getBuildContext(processCommonConfiguration());\n \n-    assertEquals(\n-        Arrays.asList(\"java\", \"-cp\", \"/app/resources:/app/classes:/app/libs/*\", \"java.lang.Object\"),\n-        buildContext.getContainerConfiguration().getEntrypoint());\n+    assertThat(buildContext.getContainerConfiguration().getEntrypoint())\n+        .containsExactly(\n+            \"java\", \"-cp\", \"/app/resources:/app/classes:/app/libs/*\", \"java.lang.Object\")\n+        .inOrder();\n \n     verify(containerizer).setBaseImageLayersCache(Containerizer.DEFAULT_BASE_CACHE_DIRECTORY);\n     verify(containerizer).setApplicationLayersCache(Paths.get(\"cache\"));\n \n     ArgumentMatcher<LogEvent> isLogWarn = logEvent -> logEvent.getLevel() == LogEvent.Level.WARN;\n-    verify(logger, Mockito.never()).accept(Mockito.argThat(isLogWarn));\n+    verify(logger, never()).accept(argThat(isLogWarn));\n   }\n \n   @Test\n@@ -201,28 +188,28 @@ public void testPluginConfigurationProcessor_extraDirectory()\n             .getLayerConfigurations()\n             .stream()\n             .filter(layer -> layer.getName().equals(\"extra files\"))\n-            .collect(Collectors.toList())\n-            .get(0)\n+            .findFirst()\n+            .get()\n             .getEntries();\n \n-    assertSourcePathsUnordered(\n-        Arrays.asList(\n+    assertThat(extraFiles)\n+        .comparingElementsUsing(SOURCE_FILE_OF)\n+        .containsExactly(\n             extraDirectory.resolve(\"a\"),\n             extraDirectory.resolve(\"a/b\"),\n             extraDirectory.resolve(\"a/b/bar\"),\n             extraDirectory.resolve(\"c\"),\n             extraDirectory.resolve(\"c/cat\"),\n-            extraDirectory.resolve(\"foo\")),\n-        extraFiles);\n-    assertExtractionPathsUnordered(\n-        Arrays.asList(\n+            extraDirectory.resolve(\"foo\"));\n+    assertThat(extraFiles)\n+        .comparingElementsUsing(EXTRACTION_PATH_OF)\n+        .containsExactly(\n             \"/target/dir/a\",\n             \"/target/dir/a/b\",\n             \"/target/dir/a/b/bar\",\n             \"/target/dir/c\",\n             \"/target/dir/c/cat\",\n-            \"/target/dir/foo\"),\n-        extraFiles);\n+            \"/target/dir/foo\");\n \n     Optional<FileEntry> fooEntry =\n         extraFiles\n@@ -232,7 +219,7 @@ public void testPluginConfigurationProcessor_extraDirectory()\n                     layerEntry.getExtractionPath().equals(AbsoluteUnixPath.get(\"/target/dir/foo\")))\n             .findFirst();\n     assertThat(fooEntry).isPresent();\n-    assertEquals(\"123\", fooEntry.get().getPermissions().toOctalString());\n+    assertThat(fooEntry.get().getPermissions().toOctalString()).isEqualTo(\"123\");\n   }\n \n   @Test\n@@ -264,10 +251,10 @@ public void testEntrypoint()\n \n     BuildContext buildContext = getBuildContext(processCommonConfiguration());\n \n-    assertEquals(\n-        Arrays.asList(\"custom\", \"entrypoint\"),\n-        buildContext.getContainerConfiguration().getEntrypoint());\n-    Mockito.verifyNoInteractions(logger);\n+    assertThat(buildContext.getContainerConfiguration().getEntrypoint())\n+        .containsExactly(\"custom\", \"entrypoint\")\n+        .inOrder();\n+    verifyNoInteractions(logger);\n   }\n \n   @Test\n@@ -277,8 +264,8 @@ public void testComputeEntrypoint_inheritKeyword()\n     when(rawConfiguration.getEntrypoint())\n         .thenReturn(Optional.of(Collections.singletonList(\"INHERIT\")));\n \n-    Assert.assertNull(\n-        PluginConfigurationProcessor.computeEntrypoint(rawConfiguration, projectProperties));\n+    assertThat(PluginConfigurationProcessor.computeEntrypoint(rawConfiguration, projectProperties))\n+        .isNull();\n   }\n \n   @Test\n@@ -287,41 +274,42 @@ public void testComputeEntrypoint_inheritKeywordInNonSingletonList()\n           InvalidContainerizingModeException {\n     when(rawConfiguration.getEntrypoint()).thenReturn(Optional.of(Arrays.asList(\"INHERIT\", \"\")));\n \n-    Assert.assertNotNull(\n-        PluginConfigurationProcessor.computeEntrypoint(rawConfiguration, projectProperties));\n+    assertThat(PluginConfigurationProcessor.computeEntrypoint(rawConfiguration, projectProperties))\n+        .isNotNull();\n   }\n \n   @Test\n   public void testComputeEntrypoint_default()\n       throws MainClassInferenceException, InvalidAppRootException, IOException,\n           InvalidContainerizingModeException {\n-    assertEquals(\n-        Arrays.asList(\"java\", \"-cp\", \"/app/resources:/app/classes:/app/libs/*\", \"java.lang.Object\"),\n-        PluginConfigurationProcessor.computeEntrypoint(rawConfiguration, projectProperties));\n+    assertThat(PluginConfigurationProcessor.computeEntrypoint(rawConfiguration, projectProperties))\n+        .containsExactly(\n+            \"java\", \"-cp\", \"/app/resources:/app/classes:/app/libs/*\", \"java.lang.Object\")\n+        .inOrder();\n   }\n \n   @Test\n   public void testComputeEntrypoint_packaged()\n       throws MainClassInferenceException, InvalidAppRootException, IOException,\n           InvalidContainerizingModeException {\n     when(rawConfiguration.getContainerizingMode()).thenReturn(\"packaged\");\n-    assertEquals(\n-        Arrays.asList(\"java\", \"-cp\", \"/app/classpath/*:/app/libs/*\", \"java.lang.Object\"),\n-        PluginConfigurationProcessor.computeEntrypoint(rawConfiguration, projectProperties));\n+    assertThat(PluginConfigurationProcessor.computeEntrypoint(rawConfiguration, projectProperties))\n+        .containsExactly(\"java\", \"-cp\", \"/app/classpath/*:/app/libs/*\", \"java.lang.Object\")\n+        .inOrder();\n   }\n \n   @Test\n   public void testComputeEntrypoint_expandClasspathDependencies()\n       throws MainClassInferenceException, InvalidAppRootException, IOException,\n           InvalidContainerizingModeException {\n     when(rawConfiguration.getExpandClasspathDependencies()).thenReturn(true);\n-    assertEquals(\n-        Arrays.asList(\n+    assertThat(PluginConfigurationProcessor.computeEntrypoint(rawConfiguration, projectProperties))\n+        .containsExactly(\n             \"java\",\n             \"-cp\",\n             \"/app/resources:/app/classes:/app/libs/foo-1.jar:/app/libs/bar-2.jar\",\n-            \"java.lang.Object\"),\n-        PluginConfigurationProcessor.computeEntrypoint(rawConfiguration, projectProperties));\n+            \"java.lang.Object\")\n+        .inOrder();\n   }\n \n   @Test\n@@ -337,8 +325,8 @@ public void testEntrypoint_defaultWarPackaging()\n \n     BuildContext buildContext = getBuildContext(processCommonConfiguration());\n \n-    Assert.assertNull(buildContext.getContainerConfiguration().getEntrypoint());\n-    Mockito.verifyNoInteractions(logger);\n+    assertThat(buildContext.getContainerConfiguration().getEntrypoint()).isNull();\n+    verifyNoInteractions(logger);\n   }\n \n   @Test\n@@ -354,12 +342,13 @@ public void testEntrypoint_defaultNonWarPackaging()\n \n     BuildContext buildContext = getBuildContext(processCommonConfiguration());\n \n-    assertEquals(\n-        Arrays.asList(\"java\", \"-cp\", \"/app/resources:/app/classes:/app/libs/*\", \"java.lang.Object\"),\n-        buildContext.getContainerConfiguration().getEntrypoint());\n+    assertThat(buildContext.getContainerConfiguration().getEntrypoint())\n+        .containsExactly(\n+            \"java\", \"-cp\", \"/app/resources:/app/classes:/app/libs/*\", \"java.lang.Object\")\n+        .inOrder();\n \n     ArgumentMatcher<LogEvent> isLogWarn = logEvent -> logEvent.getLevel() == LogEvent.Level.WARN;\n-    verify(logger, Mockito.never()).accept(Mockito.argThat(isLogWarn));\n+    verify(logger, never()).accept(argThat(isLogWarn));\n   }\n \n   @Test\n@@ -376,13 +365,13 @@ public void testEntrypoint_extraClasspathNonWarPackaging()\n \n     BuildContext buildContext = getBuildContext(processCommonConfiguration());\n \n-    assertEquals(\n-        Arrays.asList(\n-            \"java\", \"-cp\", \"/foo:/app/resources:/app/classes:/app/libs/*\", \"java.lang.Object\"),\n-        buildContext.getContainerConfiguration().getEntrypoint());\n+    assertThat(buildContext.getContainerConfiguration().getEntrypoint())\n+        .containsExactly(\n+            \"java\", \"-cp\", \"/foo:/app/resources:/app/classes:/app/libs/*\", \"java.lang.Object\")\n+        .inOrder();\n \n     ArgumentMatcher<LogEvent> isLogWarn = logEvent -> logEvent.getLevel() == LogEvent.Level.WARN;\n-    verify(logger, Mockito.never()).accept(Mockito.argThat(isLogWarn));\n+    verify(logger, never()).accept(argThat(isLogWarn));\n   }\n \n   @Test\n@@ -397,7 +386,7 @@ public void testUser()\n \n     BuildContext buildContext = getBuildContext(processCommonConfiguration());\n \n-    assertEquals(\"customUser\", buildContext.getContainerConfiguration().getUser());\n+    assertThat(buildContext.getContainerConfiguration().getUser()).isEqualTo(\"customUser\");\n   }\n \n   @Test\n@@ -410,7 +399,7 @@ public void testUser_null()\n           InvalidCreationTimeException {\n     BuildContext buildContext = getBuildContext(processCommonConfiguration());\n \n-    Assert.assertNull(buildContext.getContainerConfiguration().getUser());\n+    assertThat(buildContext.getContainerConfiguration().getUser()).isNull();\n   }\n \n   @Test\n@@ -427,9 +416,9 @@ public void testEntrypoint_warningOnJvmFlags()\n \n     BuildContext buildContext = getBuildContext(processCommonConfiguration());\n \n-    assertEquals(\n-        Arrays.asList(\"custom\", \"entrypoint\"),\n-        buildContext.getContainerConfiguration().getEntrypoint());\n+    assertThat(buildContext.getContainerConfiguration().getEntrypoint())\n+        .containsExactly(\"custom\", \"entrypoint\")\n+        .inOrder();\n     verify(projectProperties)\n         .log(\n             LogEvent.warn(\n@@ -451,9 +440,9 @@ public void testEntrypoint_warningOnMainclass()\n \n     BuildContext buildContext = getBuildContext(processCommonConfiguration());\n \n-    assertEquals(\n-        Arrays.asList(\"custom\", \"entrypoint\"),\n-        buildContext.getContainerConfiguration().getEntrypoint());\n+    assertThat(buildContext.getContainerConfiguration().getEntrypoint())\n+        .containsExactly(\"custom\", \"entrypoint\")\n+        .inOrder();\n     verify(projectProperties)\n         .log(\n             LogEvent.warn(\n@@ -475,9 +464,9 @@ public void testEntrypoint_warningOnExpandClasspathDependencies()\n \n     BuildContext buildContext = getBuildContext(processCommonConfiguration());\n \n-    assertEquals(\n-        Arrays.asList(\"custom\", \"entrypoint\"),\n-        buildContext.getContainerConfiguration().getEntrypoint());\n+    assertThat(buildContext.getContainerConfiguration().getEntrypoint())\n+        .containsExactly(\"custom\", \"entrypoint\")\n+        .inOrder();\n     verify(projectProperties)\n         .log(\n             LogEvent.warn(\n@@ -497,7 +486,7 @@ public void testEntrypoint_warningOnMainclassForWar()\n \n     BuildContext buildContext = getBuildContext(processCommonConfiguration());\n \n-    Assert.assertNull(buildContext.getContainerConfiguration().getEntrypoint());\n+    assertThat(buildContext.getContainerConfiguration().getEntrypoint()).isNull();\n     verify(projectProperties)\n         .log(\n             LogEvent.warn(\n@@ -517,7 +506,7 @@ public void testEntrypoint_warningOnExpandClasspathDependenciesForWar()\n \n     BuildContext buildContext = getBuildContext(processCommonConfiguration());\n \n-    Assert.assertNull(buildContext.getContainerConfiguration().getEntrypoint());\n+    assertThat(buildContext.getContainerConfiguration().getEntrypoint()).isNull();\n     verify(projectProperties)\n         .log(\n             LogEvent.warn(\n@@ -537,10 +526,10 @@ public void testEntrypointClasspath_nonDefaultAppRoot()\n \n     BuildContext buildContext = getBuildContext(processCommonConfiguration());\n \n-    assertEquals(\n-        Arrays.asList(\n-            \"java\", \"-cp\", \"/my/app/resources:/my/app/classes:/my/app/libs/*\", \"java.lang.Object\"),\n-        buildContext.getContainerConfiguration().getEntrypoint());\n+    assertThat(buildContext.getContainerConfiguration().getEntrypoint())\n+        .containsExactly(\n+            \"java\", \"-cp\", \"/my/app/resources:/my/app/classes:/my/app/libs/*\", \"java.lang.Object\")\n+        .inOrder();\n   }\n \n   @Test\n@@ -555,16 +544,15 @@ public void testWebAppEntrypoint_inheritedFromBaseImage()\n \n     BuildContext buildContext = getBuildContext(processCommonConfiguration());\n \n-    Assert.assertNull(buildContext.getContainerConfiguration().getEntrypoint());\n+    assertThat(buildContext.getContainerConfiguration().getEntrypoint()).isNull();\n   }\n \n   @Test\n   public void testGetAppRootChecked() throws InvalidAppRootException {\n     when(rawConfiguration.getAppRoot()).thenReturn(\"/some/root\");\n \n-    assertEquals(\n-        AbsoluteUnixPath.get(\"/some/root\"),\n-        PluginConfigurationProcessor.getAppRootChecked(rawConfiguration, projectProperties));\n+    assertThat(PluginConfigurationProcessor.getAppRootChecked(rawConfiguration, projectProperties))\n+        .isEqualTo(AbsoluteUnixPath.get(\"/some/root\"));\n   }\n \n   @Test\n@@ -611,19 +599,17 @@ public void testGetAppRootChecked_defaultNonWarProject() throws InvalidAppRootEx\n     when(rawConfiguration.getAppRoot()).thenReturn(\"\");\n     when(projectProperties.isWarProject()).thenReturn(false);\n \n-    assertEquals(\n-        AbsoluteUnixPath.get(\"/app\"),\n-        PluginConfigurationProcessor.getAppRootChecked(rawConfiguration, projectProperties));\n+    assertThat(PluginConfigurationProcessor.getAppRootChecked(rawConfiguration, projectProperties))\n+        .isEqualTo(AbsoluteUnixPath.get(\"/app\"));\n   }\n \n   @Test\n   public void testGetAppRootChecked_defaultWarProject() throws InvalidAppRootException {\n     when(rawConfiguration.getAppRoot()).thenReturn(\"\");\n     when(projectProperties.isWarProject()).thenReturn(true);\n \n-    assertEquals(\n-        AbsoluteUnixPath.get(\"/jetty/webapps/ROOT\"),\n-        PluginConfigurationProcessor.getAppRootChecked(rawConfiguration, projectProperties));\n+    assertThat(PluginConfigurationProcessor.getAppRootChecked(rawConfiguration, projectProperties))\n+        .isEqualTo(AbsoluteUnixPath.get(\"/jetty/webapps/ROOT\"));\n   }\n \n   @Test\n@@ -648,8 +634,7 @@ public void testGetWorkingDirectoryChecked() throws InvalidWorkingDirectoryExcep\n \n     Optional<AbsoluteUnixPath> checkedPath =\n         PluginConfigurationProcessor.getWorkingDirectoryChecked(rawConfiguration);\n-    assertThat(checkedPath).isPresent();\n-    assertEquals(AbsoluteUnixPath.get(\"/valid/path\"), checkedPath.get());\n+    assertThat(checkedPath).hasValue(AbsoluteUnixPath.get(\"/valid/path\"));\n   }\n \n   @Test\n@@ -675,97 +660,83 @@ public void testGetDefaultBaseImage_nonWarPackaging()\n       throws IncompatibleBaseImageJavaVersionException {\n     when(projectProperties.isWarProject()).thenReturn(false);\n \n-    assertEquals(\n-        \"gcr.io/distroless/java:8\",\n-        PluginConfigurationProcessor.getDefaultBaseImage(projectProperties));\n+    assertThat(PluginConfigurationProcessor.getDefaultBaseImage(projectProperties))\n+        .isEqualTo(\"gcr.io/distroless/java:8\");\n   }\n \n   @Test\n   public void testGetDefaultBaseImage_warProject()\n       throws IncompatibleBaseImageJavaVersionException {\n     when(projectProperties.isWarProject()).thenReturn(true);\n \n-    assertEquals(\n-        \"gcr.io/distroless/java/jetty:java8\",\n-        PluginConfigurationProcessor.getDefaultBaseImage(projectProperties));\n+    assertThat(PluginConfigurationProcessor.getDefaultBaseImage(projectProperties))\n+        .isEqualTo(\"gcr.io/distroless/java/jetty:java8\");\n   }\n \n   @Test\n   public void testGetDefaultBaseImage_chooseJava8Distroless()\n       throws IncompatibleBaseImageJavaVersionException {\n     when(projectProperties.getMajorJavaVersion()).thenReturn(6);\n-    assertEquals(\n-        \"gcr.io/distroless/java:8\",\n-        PluginConfigurationProcessor.getDefaultBaseImage(projectProperties));\n+    assertThat(PluginConfigurationProcessor.getDefaultBaseImage(projectProperties))\n+        .isEqualTo(\"gcr.io/distroless/java:8\");\n \n     when(projectProperties.getMajorJavaVersion()).thenReturn(7);\n-    assertEquals(\n-        \"gcr.io/distroless/java:8\",\n-        PluginConfigurationProcessor.getDefaultBaseImage(projectProperties));\n+    assertThat(PluginConfigurationProcessor.getDefaultBaseImage(projectProperties))\n+        .isEqualTo(\"gcr.io/distroless/java:8\");\n \n     when(projectProperties.getMajorJavaVersion()).thenReturn(8);\n-    assertEquals(\n-        \"gcr.io/distroless/java:8\",\n-        PluginConfigurationProcessor.getDefaultBaseImage(projectProperties));\n+    assertThat(PluginConfigurationProcessor.getDefaultBaseImage(projectProperties))\n+        .isEqualTo(\"gcr.io/distroless/java:8\");\n   }\n \n   @Test\n   public void testGetDefaultBaseImage_chooseJava11Distroless()\n       throws IncompatibleBaseImageJavaVersionException {\n     when(projectProperties.getMajorJavaVersion()).thenReturn(9);\n-    assertEquals(\n-        \"gcr.io/distroless/java:11\",\n-        PluginConfigurationProcessor.getDefaultBaseImage(projectProperties));\n+    assertThat(PluginConfigurationProcessor.getDefaultBaseImage(projectProperties))\n+        .isEqualTo(\"gcr.io/distroless/java:11\");\n \n     when(projectProperties.getMajorJavaVersion()).thenReturn(10);\n-    assertEquals(\n-        \"gcr.io/distroless/java:11\",\n-        PluginConfigurationProcessor.getDefaultBaseImage(projectProperties));\n+    assertThat(PluginConfigurationProcessor.getDefaultBaseImage(projectProperties))\n+        .isEqualTo(\"gcr.io/distroless/java:11\");\n \n     when(projectProperties.getMajorJavaVersion()).thenReturn(11);\n-    assertEquals(\n-        \"gcr.io/distroless/java:11\",\n-        PluginConfigurationProcessor.getDefaultBaseImage(projectProperties));\n+    assertThat(PluginConfigurationProcessor.getDefaultBaseImage(projectProperties))\n+        .isEqualTo(\"gcr.io/distroless/java:11\");\n   }\n \n   @Test\n   public void testGetDefaultBaseImage_chooseJava8JettyDistroless()\n       throws IncompatibleBaseImageJavaVersionException {\n     when(projectProperties.getMajorJavaVersion()).thenReturn(6);\n     when(projectProperties.isWarProject()).thenReturn(true);\n-    assertEquals(\n-        \"gcr.io/distroless/java/jetty:java8\",\n-        PluginConfigurationProcessor.getDefaultBaseImage(projectProperties));\n+    assertThat(PluginConfigurationProcessor.getDefaultBaseImage(projectProperties))\n+        .isEqualTo(\"gcr.io/distroless/java/jetty:java8\");\n \n     when(projectProperties.getMajorJavaVersion()).thenReturn(7);\n-    assertEquals(\n-        \"gcr.io/distroless/java/jetty:java8\",\n-        PluginConfigurationProcessor.getDefaultBaseImage(projectProperties));\n+    assertThat(PluginConfigurationProcessor.getDefaultBaseImage(projectProperties))\n+        .isEqualTo(\"gcr.io/distroless/java/jetty:java8\");\n \n     when(projectProperties.getMajorJavaVersion()).thenReturn(8);\n-    assertEquals(\n-        \"gcr.io/distroless/java/jetty:java8\",\n-        PluginConfigurationProcessor.getDefaultBaseImage(projectProperties));\n+    assertThat(PluginConfigurationProcessor.getDefaultBaseImage(projectProperties))\n+        .isEqualTo(\"gcr.io/distroless/java/jetty:java8\");\n   }\n \n   @Test\n   public void testGetDefaultBaseImage_chooseJava11JettyDistroless()\n       throws IncompatibleBaseImageJavaVersionException {\n     when(projectProperties.getMajorJavaVersion()).thenReturn(9);\n     when(projectProperties.isWarProject()).thenReturn(true);\n-    assertEquals(\n-        \"gcr.io/distroless/java/jetty:java11\",\n-        PluginConfigurationProcessor.getDefaultBaseImage(projectProperties));\n+    assertThat(PluginConfigurationProcessor.getDefaultBaseImage(projectProperties))\n+        .isEqualTo(\"gcr.io/distroless/java/jetty:java11\");\n \n     when(projectProperties.getMajorJavaVersion()).thenReturn(10);\n-    assertEquals(\n-        \"gcr.io/distroless/java/jetty:java11\",\n-        PluginConfigurationProcessor.getDefaultBaseImage(projectProperties));\n+    assertThat(PluginConfigurationProcessor.getDefaultBaseImage(projectProperties))\n+        .isEqualTo(\"gcr.io/distroless/java/jetty:java11\");\n \n     when(projectProperties.getMajorJavaVersion()).thenReturn(11);\n-    assertEquals(\n-        \"gcr.io/distroless/java/jetty:java11\",\n-        PluginConfigurationProcessor.getDefaultBaseImage(projectProperties));\n+    assertThat(PluginConfigurationProcessor.getDefaultBaseImage(projectProperties))\n+        .isEqualTo(\"gcr.io/distroless/java/jetty:java11\");\n   }\n \n   @Test\n@@ -787,7 +758,7 @@ public void testGetJavaContainerBuilderWithBaseImage_dockerBase()\n           CacheDirectoryCreationException {\n     when(rawConfiguration.getFromImage()).thenReturn(Optional.of(\"docker://ima.ge/name\"));\n     ImageConfiguration result = getCommonImageConfiguration();\n-    assertEquals(\"ima.ge/name\", result.getImage().toString());\n+    assertThat(result.getImage().toString()).isEqualTo(\"ima.ge/name\");\n     assertThat(result.getDockerClient()).isPresent();\n     assertThat(result.getTarPath()).isEmpty();\n   }\n@@ -798,7 +769,7 @@ public void testGetJavaContainerBuilderWithBaseImage_tarBase()\n           CacheDirectoryCreationException {\n     when(rawConfiguration.getFromImage()).thenReturn(Optional.of(\"tar:///path/to.tar\"));\n     ImageConfiguration result = getCommonImageConfiguration();\n-    assertEquals(Paths.get(\"/path/to.tar\"), result.getTarPath().get());\n+    assertThat(result.getTarPath()).hasValue(Paths.get(\"/path/to.tar\"));\n     assertThat(result.getDockerClient()).isEmpty();\n   }\n \n@@ -808,7 +779,7 @@ public void testGetJavaContainerBuilderWithBaseImage_registry()\n           CacheDirectoryCreationException {\n     when(rawConfiguration.getFromImage()).thenReturn(Optional.of(\"ima.ge/name\"));\n     ImageConfiguration result = getCommonImageConfiguration();\n-    assertEquals(\"ima.ge/name\", result.getImage().toString());\n+    assertThat(result.getImage().toString()).isEqualTo(\"ima.ge/name\");\n     assertThat(result.getDockerClient()).isEmpty();\n     assertThat(result.getTarPath()).isEmpty();\n   }\n@@ -819,85 +790,81 @@ public void testGetJavaContainerBuilderWithBaseImage_registryWithPrefix()\n           CacheDirectoryCreationException {\n     when(rawConfiguration.getFromImage()).thenReturn(Optional.of(\"registry://ima.ge/name\"));\n     ImageConfiguration result = getCommonImageConfiguration();\n-    assertEquals(\"ima.ge/name\", result.getImage().toString());\n+    assertThat(result.getImage().toString()).isEqualTo(\"ima.ge/name\");\n     assertThat(result.getDockerClient()).isEmpty();\n     assertThat(result.getTarPath()).isEmpty();\n   }\n \n   @Test\n-  public void testGetJavaContainerBuilderWithBaseImage_incompatibleJava8BaseImage()\n-      throws InvalidImageReferenceException, FileNotFoundException {\n+  public void testGetJavaContainerBuilderWithBaseImage_incompatibleJava8BaseImage() {\n     when(projectProperties.getMajorJavaVersion()).thenReturn(11);\n \n     when(rawConfiguration.getFromImage()).thenReturn(Optional.of(\"gcr.io/distroless/java:8\"));\n-    try {\n-      PluginConfigurationProcessor.getJavaContainerBuilderWithBaseImage(\n-          rawConfiguration, projectProperties, inferredAuthProvider);\n-      fail();\n-    } catch (IncompatibleBaseImageJavaVersionException ex) {\n-      assertEquals(8, ex.getBaseImageMajorJavaVersion());\n-      assertEquals(11, ex.getProjectMajorJavaVersion());\n-    }\n+    IncompatibleBaseImageJavaVersionException exception1 =\n+        assertThrows(\n+            IncompatibleBaseImageJavaVersionException.class,\n+            () ->\n+                PluginConfigurationProcessor.getJavaContainerBuilderWithBaseImage(\n+                    rawConfiguration, projectProperties, inferredAuthProvider));\n+    assertThat(exception1.getBaseImageMajorJavaVersion()).isEqualTo(8);\n+    assertThat(exception1.getProjectMajorJavaVersion()).isEqualTo(11);\n \n     when(rawConfiguration.getFromImage()).thenReturn(Optional.of(\"gcr.io/distroless/java:latest\"));\n-    try {\n-      PluginConfigurationProcessor.getJavaContainerBuilderWithBaseImage(\n-          rawConfiguration, projectProperties, inferredAuthProvider);\n-      fail();\n-    } catch (IncompatibleBaseImageJavaVersionException ex) {\n-      assertEquals(8, ex.getBaseImageMajorJavaVersion());\n-      assertEquals(11, ex.getProjectMajorJavaVersion());\n-    }\n+    IncompatibleBaseImageJavaVersionException exception2 =\n+        assertThrows(\n+            IncompatibleBaseImageJavaVersionException.class,\n+            () ->\n+                PluginConfigurationProcessor.getJavaContainerBuilderWithBaseImage(\n+                    rawConfiguration, projectProperties, inferredAuthProvider));\n+    assertThat(exception2.getBaseImageMajorJavaVersion()).isEqualTo(8);\n+    assertThat(exception2.getProjectMajorJavaVersion()).isEqualTo(11);\n   }\n \n   @Test\n-  public void testGetJavaContainerBuilderWithBaseImage_incompatibleJava11BaseImage()\n-      throws InvalidImageReferenceException, FileNotFoundException {\n+  public void testGetJavaContainerBuilderWithBaseImage_incompatibleJava11BaseImage() {\n     when(projectProperties.getMajorJavaVersion()).thenReturn(15);\n \n     when(rawConfiguration.getFromImage()).thenReturn(Optional.of(\"gcr.io/distroless/java:11\"));\n-    try {\n-      PluginConfigurationProcessor.getJavaContainerBuilderWithBaseImage(\n-          rawConfiguration, projectProperties, inferredAuthProvider);\n-      fail();\n-    } catch (IncompatibleBaseImageJavaVersionException ex) {\n-      assertEquals(11, ex.getBaseImageMajorJavaVersion());\n-      assertEquals(15, ex.getProjectMajorJavaVersion());\n-    }\n+    IncompatibleBaseImageJavaVersionException exception =\n+        assertThrows(\n+            IncompatibleBaseImageJavaVersionException.class,\n+            () ->\n+                PluginConfigurationProcessor.getJavaContainerBuilderWithBaseImage(\n+                    rawConfiguration, projectProperties, inferredAuthProvider));\n+    assertThat(exception.getBaseImageMajorJavaVersion()).isEqualTo(11);\n+    assertThat(exception.getProjectMajorJavaVersion()).isEqualTo(15);\n   }\n \n   @Test\n-  public void testGetJavaContainerBuilderWithBaseImage_incompatibleJava8JettyBaseImage()\n-      throws InvalidImageReferenceException, FileNotFoundException {\n+  public void testGetJavaContainerBuilderWithBaseImage_incompatibleJava8JettyBaseImage() {\n     when(projectProperties.getMajorJavaVersion()).thenReturn(11);\n \n     when(rawConfiguration.getFromImage())\n         .thenReturn(Optional.of(\"gcr.io/distroless/java/jetty:java8\"));\n-    try {\n-      PluginConfigurationProcessor.getJavaContainerBuilderWithBaseImage(\n-          rawConfiguration, projectProperties, inferredAuthProvider);\n-      fail();\n-    } catch (IncompatibleBaseImageJavaVersionException ex) {\n-      assertEquals(8, ex.getBaseImageMajorJavaVersion());\n-      assertEquals(11, ex.getProjectMajorJavaVersion());\n-    }\n+    IncompatibleBaseImageJavaVersionException exception =\n+        assertThrows(\n+            IncompatibleBaseImageJavaVersionException.class,\n+            () ->\n+                PluginConfigurationProcessor.getJavaContainerBuilderWithBaseImage(\n+                    rawConfiguration, projectProperties, inferredAuthProvider));\n+    assertThat(exception.getBaseImageMajorJavaVersion()).isEqualTo(8);\n+    assertThat(exception.getProjectMajorJavaVersion()).isEqualTo(11);\n   }\n \n   @Test\n-  public void testGetJavaContainerBuilderWithBaseImage_incompatibleJava11JettyBaseImage()\n-      throws InvalidImageReferenceException, FileNotFoundException {\n+  public void testGetJavaContainerBuilderWithBaseImage_incompatibleJava11JettyBaseImage() {\n     when(projectProperties.getMajorJavaVersion()).thenReturn(15);\n \n     when(rawConfiguration.getFromImage())\n         .thenReturn(Optional.of(\"gcr.io/distroless/java/jetty:java11\"));\n-    try {\n-      PluginConfigurationProcessor.getJavaContainerBuilderWithBaseImage(\n-          rawConfiguration, projectProperties, inferredAuthProvider);\n-      fail();\n-    } catch (IncompatibleBaseImageJavaVersionException ex) {\n-      assertEquals(11, ex.getBaseImageMajorJavaVersion());\n-      assertEquals(15, ex.getProjectMajorJavaVersion());\n-    }\n+    IncompatibleBaseImageJavaVersionException exception =\n+        assertThrows(\n+            IncompatibleBaseImageJavaVersionException.class,\n+            () ->\n+                PluginConfigurationProcessor.getJavaContainerBuilderWithBaseImage(\n+                    rawConfiguration, projectProperties, inferredAuthProvider));\n+    assertThat(exception.getBaseImageMajorJavaVersion()).isEqualTo(11);\n+    assertThat(exception.getProjectMajorJavaVersion()).isEqualTo(15);\n   }\n \n   // https://github.com/GoogleContainerTools/jib/issues/1995\n@@ -908,47 +875,46 @@ public void testGetJavaContainerBuilderWithBaseImage_java12BaseImage()\n     when(projectProperties.getMajorJavaVersion()).thenReturn(12);\n     when(rawConfiguration.getFromImage()).thenReturn(Optional.of(\"regis.try/java12image\"));\n     ImageConfiguration imageConfiguration = getCommonImageConfiguration();\n-    assertEquals(\"regis.try\", imageConfiguration.getImageRegistry());\n-    assertEquals(\"java12image\", imageConfiguration.getImageRepository());\n+    assertThat(imageConfiguration.getImageRegistry()).isEqualTo(\"regis.try\");\n+    assertThat(imageConfiguration.getImageRepository()).isEqualTo(\"java12image\");\n   }\n \n   @Test\n-  public void testGetJavaContainerBuilderWithBaseImage_java12NoBaseImage()\n-      throws InvalidImageReferenceException, IOException {\n+  public void testGetJavaContainerBuilderWithBaseImage_java12NoBaseImage() {\n     when(projectProperties.getMajorJavaVersion()).thenReturn(12);\n     when(rawConfiguration.getFromImage()).thenReturn(Optional.empty());\n-    try {\n-      PluginConfigurationProcessor.getJavaContainerBuilderWithBaseImage(\n-          rawConfiguration, projectProperties, inferredAuthProvider);\n-      fail();\n-    } catch (IncompatibleBaseImageJavaVersionException ex) {\n-      assertEquals(11, ex.getBaseImageMajorJavaVersion());\n-      assertEquals(12, ex.getProjectMajorJavaVersion());\n-    }\n+    IncompatibleBaseImageJavaVersionException exception =\n+        assertThrows(\n+            IncompatibleBaseImageJavaVersionException.class,\n+            () ->\n+                PluginConfigurationProcessor.getJavaContainerBuilderWithBaseImage(\n+                    rawConfiguration, projectProperties, inferredAuthProvider));\n+    assertThat(exception.getBaseImageMajorJavaVersion()).isEqualTo(11);\n+    assertThat(exception.getProjectMajorJavaVersion()).isEqualTo(12);\n   }\n \n   @Test\n   public void testGetPlatformsSet() throws InvalidPlatformException {\n     Mockito.<List<?>>when(rawConfiguration.getPlatforms())\n         .thenReturn(Arrays.asList(new TestPlatformConfiguration(\"testArchitecture\", \"testOs\")));\n \n-    assertEquals(\n-        ImmutableSet.of(new Platform(\"testArchitecture\", \"testOs\")),\n-        PluginConfigurationProcessor.getPlatformsSet(rawConfiguration));\n+    assertThat(PluginConfigurationProcessor.getPlatformsSet(rawConfiguration))\n+        .containsExactly(new Platform(\"testArchitecture\", \"testOs\"));\n   }\n \n   @Test\n   public void testGetPlatformsSet_architectureMissing() {\n     TestPlatformConfiguration platform = new TestPlatformConfiguration(null, \"testOs\");\n     Mockito.<List<?>>when(rawConfiguration.getPlatforms()).thenReturn(Arrays.asList(platform));\n \n-    try {\n-      PluginConfigurationProcessor.getPlatformsSet(rawConfiguration);\n-      fail();\n-    } catch (InvalidPlatformException ex) {\n-      assertEquals(\"platform configuration is missing an architecture value\", ex.getMessage());\n-      assertEquals(\"architecture=<missing>, os=testOs\", ex.getInvalidPlatform());\n-    }\n+    InvalidPlatformException exception =\n+        assertThrows(\n+            InvalidPlatformException.class,\n+            () -> PluginConfigurationProcessor.getPlatformsSet(rawConfiguration));\n+    assertThat(exception)\n+        .hasMessageThat()\n+        .isEqualTo(\"platform configuration is missing an architecture value\");\n+    assertThat(exception.getInvalidPlatform()).isEqualTo(\"architecture=<missing>, os=testOs\");\n   }\n \n   @Test\n@@ -960,17 +926,19 @@ public void testGetPlatformsSet_osMissing() {\n         assertThrows(\n             InvalidPlatformException.class,\n             () -> PluginConfigurationProcessor.getPlatformsSet(rawConfiguration));\n-    assertEquals(\"platform configuration is missing an OS value\", exception.getMessage());\n-    assertEquals(\"architecture=testArchitecture, os=<missing>\", exception.getInvalidPlatform());\n+    assertThat(exception)\n+        .hasMessageThat()\n+        .isEqualTo(\"platform configuration is missing an OS value\");\n+    assertThat(exception.getInvalidPlatform())\n+        .isEqualTo(\"architecture=testArchitecture, os=<missing>\");\n   }\n \n   @Test\n   public void testGetValidVolumesList() throws InvalidContainerVolumeException {\n     when(rawConfiguration.getVolumes()).thenReturn(Collections.singletonList(\"/some/root\"));\n \n-    assertEquals(\n-        ImmutableSet.of(AbsoluteUnixPath.get(\"/some/root\")),\n-        PluginConfigurationProcessor.getVolumesSet(rawConfiguration));\n+    assertThat(PluginConfigurationProcessor.getVolumesSet(rawConfiguration))\n+        .containsExactly(AbsoluteUnixPath.get(\"/some/root\"));\n   }\n \n   @Test\n@@ -1025,7 +993,6 @@ public void testGetCreationTime_useCurrentTimestamp() throws InvalidCreationTime\n     Instant now = Instant.now().minusSeconds(2);\n     Instant time =\n         PluginConfigurationProcessor.getCreationTime(\"USE_CURRENT_TIMESTAMP\", projectProperties);\n-    assertThat(time.isAfter(now)).isTrue();\n     assertThat(time).isGreaterThan(now);\n   }\n \n@@ -1111,17 +1078,16 @@ public void getAllFiles_expandsDirectories() throws IOException {\n     File rootFile = temporaryFolder.newFile(\"file\");\n     File folder = temporaryFolder.newFolder(\"folder\");\n     File folderFile = temporaryFolder.newFile(\"folder/file2\");\n-    assertEquals(\n-        ImmutableSet.of(rootFile.toPath().toAbsolutePath(), folderFile.toPath().toAbsolutePath()),\n-        PluginConfigurationProcessor.getAllFiles(\n-            ImmutableSet.of(rootFile.toPath(), folder.toPath())));\n+    assertThat(\n+            PluginConfigurationProcessor.getAllFiles(\n+                ImmutableSet.of(rootFile.toPath(), folder.toPath())))\n+        .containsExactly(rootFile.toPath().toAbsolutePath(), folderFile.toPath().toAbsolutePath());\n   }\n \n   @Test\n   public void getAllFiles_doesntBreakForNonExistentFiles() throws IOException {\n     Path testPath = Paths.get(\"/a/file/that/doesnt/exist\");\n-    Assert.assertFalse(Files.exists(testPath));\n-    assertEquals(\n-        ImmutableSet.of(), PluginConfigurationProcessor.getAllFiles(ImmutableSet.of(testPath)));\n+    assertThat(Files.exists(testPath)).isFalse();\n+    assertThat(PluginConfigurationProcessor.getAllFiles(ImmutableSet.of(testPath))).isEmpty();\n   }\n }",
      "parent_sha": "5dd6ba41b32ac792920d52e8b9e09587c06b19c6"
    }
  },
  {
    "oid": "acd23345899e93ab0785bc2cfab79e81ba9f7039",
    "message": "Remove out-of-scope tests in `GradleProjectProperties` (#3112)\n\n* clean up tests\r\n\r\n* Update jib-gradle-plugin/src/test/java/com/google/cloud/tools/jib/gradle/GradleProjectPropertiesTest.java\r\n\r\nCo-authored-by: Mridula <66699525+mpeddada1@users.noreply.github.com>\r\n\r\n* Update jib-gradle-plugin/src/test/java/com/google/cloud/tools/jib/gradle/GradleProjectPropertiesTest.java\r\n\r\nCo-authored-by: Mridula <66699525+mpeddada1@users.noreply.github.com>\r\n\r\n* assert building JibContainerBuilder\r\n\r\nCo-authored-by: Mridula <66699525+mpeddada1@users.noreply.github.com>",
    "date": "2021-03-08T17:03:24Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/acd23345899e93ab0785bc2cfab79e81ba9f7039",
    "details": {
      "sha": "871faeff12c78834338f9b7b526de1b7bda69bfc",
      "filename": "jib-gradle-plugin/src/test/java/com/google/cloud/tools/jib/gradle/GradleProjectPropertiesTest.java",
      "status": "modified",
      "additions": 26,
      "deletions": 80,
      "changes": 106,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/acd23345899e93ab0785bc2cfab79e81ba9f7039/jib-gradle-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FGradleProjectPropertiesTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/acd23345899e93ab0785bc2cfab79e81ba9f7039/jib-gradle-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FGradleProjectPropertiesTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-gradle-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FGradleProjectPropertiesTest.java?ref=acd23345899e93ab0785bc2cfab79e81ba9f7039",
      "patch": "@@ -236,10 +236,9 @@ public void testGetMajorJavaVersion_jvm11() {\n   }\n \n   @Test\n-  public void testCreateContainerBuilder_correctFiles()\n+  public void testCreateContainerBuilder_correctSourceFiles()\n       throws URISyntaxException, InvalidImageReferenceException, CacheDirectoryCreationException {\n-    BuildContext buildContext = setupBuildContext(\"/app\");\n-    ContainerBuilderLayers layers = new ContainerBuilderLayers(buildContext);\n+    ContainerBuilderLayers layers = new ContainerBuilderLayers(setupBuildContext());\n \n     Path applicationDirectory = getResource(\"gradle/application\");\n     assertThat(layers.snapshotsLayer.getEntries())\n@@ -302,10 +301,9 @@ public void testCreateContainerBuilder_noClassesFiles()\n   }\n \n   @Test\n-  public void testCreateContainerBuilder_nonDefaultAppRoot()\n+  public void testCreateContainerBuilder_correctExtractionPaths()\n       throws InvalidImageReferenceException, CacheDirectoryCreationException {\n-    BuildContext buildContext = setupBuildContext(\"/my/app\");\n-    ContainerBuilderLayers layers = new ContainerBuilderLayers(buildContext);\n+    ContainerBuilderLayers layers = new ContainerBuilderLayers(setupBuildContext());\n \n     assertThat(layers.dependenciesLayer.getEntries())\n         .comparingElementsUsing(EXTRACTION_PATH_OF)\n@@ -330,41 +328,13 @@ public void testCreateContainerBuilder_nonDefaultAppRoot()\n         .containsExactly(\"/my/app/classes/HelloWorld.class\", \"/my/app/classes/some.class\");\n   }\n \n-  @Test\n-  public void testCreateContainerBuilder_defaultAppRoot()\n-      throws InvalidImageReferenceException, CacheDirectoryCreationException {\n-    BuildContext buildContext = setupBuildContext(JavaContainerBuilder.DEFAULT_APP_ROOT);\n-    ContainerBuilderLayers layers = new ContainerBuilderLayers(buildContext);\n-    assertThat(layers.dependenciesLayer.getEntries())\n-        .comparingElementsUsing(EXTRACTION_PATH_OF)\n-        .containsExactly(\n-            \"/app/libs/dependency-1.0.0-770.jar\",\n-            \"/app/libs/dependency-1.0.0-200.jar\",\n-            \"/app/libs/dependency-1.0.0-480.jar\",\n-            \"/app/libs/libraryA.jar\",\n-            \"/app/libs/libraryB.jar\",\n-            \"/app/libs/library.jarC.jar\");\n-    assertThat(layers.snapshotsLayer.getEntries())\n-        .comparingElementsUsing(EXTRACTION_PATH_OF)\n-        .containsExactly(\"/app/libs/dependencyX-1.0.0-SNAPSHOT.jar\");\n-    assertThat(layers.resourcesLayer.getEntries())\n-        .comparingElementsUsing(EXTRACTION_PATH_OF)\n-        .containsExactly(\n-            \"/app/resources/resourceA\", \"/app/resources/resourceB\", \"/app/resources/world\");\n-    assertThat(layers.classesLayer.getEntries())\n-        .comparingElementsUsing(EXTRACTION_PATH_OF)\n-        .containsExactly(\"/app/classes/HelloWorld.class\", \"/app/classes/some.class\");\n-  }\n-\n   @Test\n   public void testCreateContainerBuilder_war()\n       throws URISyntaxException, IOException, InvalidImageReferenceException,\n           CacheDirectoryCreationException {\n-    Path webAppDirectory = getResource(\"gradle/webapp\");\n-    Path unzipTarget = setUpWarProject(webAppDirectory);\n+    Path unzipTarget = setUpWarProject(getResource(\"gradle/webapp\"));\n \n-    BuildContext buildContext = setupBuildContext(\"/my/app\");\n-    ContainerBuilderLayers layers = new ContainerBuilderLayers(buildContext);\n+    ContainerBuilderLayers layers = new ContainerBuilderLayers(setupBuildContext());\n     assertThat(layers.dependenciesLayer.getEntries())\n         .comparingElementsUsing(SOURCE_FILE_OF)\n         .containsExactly(unzipTarget.resolve(\"WEB-INF/lib/dependency-1.0.0.jar\"));\n@@ -420,63 +390,39 @@ public void testCreateContainerBuilder_war()\n             \"/my/app/WEB-INF/classes/package/Other.class\");\n   }\n \n-  @Test\n-  public void testCreateContainerBuilder_defaultWebAppRoot()\n-      throws URISyntaxException, IOException, InvalidImageReferenceException,\n-          CacheDirectoryCreationException {\n-    Path unzipTarget = setUpWarProject(getResource(\"gradle/webapp\"));\n-\n-    BuildContext buildContext = setupBuildContext(JavaContainerBuilder.DEFAULT_WEB_APP_ROOT);\n-    ContainerBuilderLayers layers = new ContainerBuilderLayers(buildContext);\n-    assertThat(layers.dependenciesLayer.getEntries())\n-        .comparingElementsUsing(SOURCE_FILE_OF)\n-        .containsExactly(unzipTarget.resolve(\"WEB-INF/lib/dependency-1.0.0.jar\"));\n-    assertThat(layers.snapshotsLayer.getEntries())\n-        .comparingElementsUsing(SOURCE_FILE_OF)\n-        .containsExactly(unzipTarget.resolve(\"WEB-INF/lib/dependencyX-1.0.0-SNAPSHOT.jar\"));\n-    assertThat(layers.resourcesLayer.getEntries())\n-        .comparingElementsUsing(SOURCE_FILE_OF)\n-        .containsExactly(\n-            unzipTarget.resolve(\"META-INF\"),\n-            unzipTarget.resolve(\"META-INF/context.xml\"),\n-            unzipTarget.resolve(\"Test.jsp\"),\n-            unzipTarget.resolve(\"WEB-INF\"),\n-            unzipTarget.resolve(\"WEB-INF/classes\"),\n-            unzipTarget.resolve(\"WEB-INF/classes/empty_dir\"),\n-            unzipTarget.resolve(\"WEB-INF/classes/package\"),\n-            unzipTarget.resolve(\"WEB-INF/classes/package/test.properties\"),\n-            unzipTarget.resolve(\"WEB-INF/lib\"),\n-            unzipTarget.resolve(\"WEB-INF/web.xml\"));\n-    assertThat(layers.classesLayer.getEntries())\n-        .comparingElementsUsing(SOURCE_FILE_OF)\n-        .containsExactly(\n-            unzipTarget.resolve(\"WEB-INF/classes/HelloWorld.class\"),\n-            unzipTarget.resolve(\"WEB-INF/classes/empty_dir\"),\n-            unzipTarget.resolve(\"WEB-INF/classes/package\"),\n-            unzipTarget.resolve(\"WEB-INF/classes/package/Other.class\"));\n-  }\n-\n   @Test\n   public void testCreateContainerBuilder_noErrorIfWebInfClassesDoesNotExist()\n-      throws IOException, InvalidImageReferenceException, CacheDirectoryCreationException {\n+      throws IOException, InvalidImageReferenceException {\n     temporaryFolder.newFolder(\"WEB-INF\", \"lib\");\n     setUpWarProject(temporaryFolder.getRoot().toPath());\n-    setupBuildContext(\"/anything\"); // should pass\n+\n+    assertThat(\n+            gradleProjectProperties.createJibContainerBuilder(\n+                JavaContainerBuilder.from(\"ignored\"), ContainerizingMode.EXPLODED))\n+        .isNotNull();\n   }\n \n   @Test\n   public void testCreateContainerBuilder_noErrorIfWebInfLibDoesNotExist()\n-      throws IOException, InvalidImageReferenceException, CacheDirectoryCreationException {\n+      throws IOException, InvalidImageReferenceException {\n     temporaryFolder.newFolder(\"WEB-INF\", \"classes\");\n     setUpWarProject(temporaryFolder.getRoot().toPath());\n-    setupBuildContext(\"/anything\"); // should pass\n+\n+    assertThat(\n+            gradleProjectProperties.createJibContainerBuilder(\n+                JavaContainerBuilder.from(\"ignored\"), ContainerizingMode.EXPLODED))\n+        .isNotNull();\n   }\n \n   @Test\n   public void testCreateContainerBuilder_noErrorIfWebInfDoesNotExist()\n-      throws IOException, InvalidImageReferenceException, CacheDirectoryCreationException {\n+      throws IOException, InvalidImageReferenceException {\n     setUpWarProject(temporaryFolder.getRoot().toPath());\n-    setupBuildContext(\"/anything\"); // should pass\n+\n+    assertThat(\n+            gradleProjectProperties.createJibContainerBuilder(\n+                JavaContainerBuilder.from(\"ignored\"), ContainerizingMode.EXPLODED))\n+        .isNotNull();\n   }\n \n   @Test\n@@ -533,11 +479,11 @@ public void testGetDependencies() throws URISyntaxException {\n         .inOrder();\n   }\n \n-  private BuildContext setupBuildContext(String appRoot)\n+  private BuildContext setupBuildContext()\n       throws InvalidImageReferenceException, CacheDirectoryCreationException {\n     JavaContainerBuilder javaContainerBuilder =\n         JavaContainerBuilder.from(RegistryImage.named(\"base\"))\n-            .setAppRoot(AbsoluteUnixPath.get(appRoot))\n+            .setAppRoot(AbsoluteUnixPath.get(\"/my/app\"))\n             .setModificationTimeProvider((ignored1, ignored2) -> EPOCH_PLUS_32);\n     JibContainerBuilder jibContainerBuilder =\n         gradleProjectProperties.createJibContainerBuilder(",
      "parent_sha": "ccfd75eb29e23c0d68f3126bf2352f8e3714137e"
    }
  },
  {
    "oid": "40a455c16d729809078f52e3076388b3fcfd3a4d",
    "message": "fix sonar bug to call Optional#isPresent. (#3397)\n\nFixes sonar issue of 'Call Optional#isPresent()\" before accessing the value.'",
    "date": "2021-08-09T23:55:55Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/40a455c16d729809078f52e3076388b3fcfd3a4d",
    "details": {
      "sha": "a61d277d80519f40f8535af44dc3b569cbd2d120",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/image/json/JsonToImageTranslator.java",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/40a455c16d729809078f52e3076388b3fcfd3a4d/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fimage%2Fjson%2FJsonToImageTranslator.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/40a455c16d729809078f52e3076388b3fcfd3a4d/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fimage%2Fjson%2FJsonToImageTranslator.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fimage%2Fjson%2FJsonToImageTranslator.java?ref=40a455c16d729809078f52e3076388b3fcfd3a4d",
      "patch": "@@ -37,6 +37,7 @@\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n import javax.annotation.Nullable;\n@@ -80,9 +81,10 @@ public static Image toImage(V21ManifestTemplate manifestTemplate)\n       imageBuilder.addLayer(new DigestOnlyLayer(digest));\n     }\n \n-    if (manifestTemplate.getContainerConfiguration().isPresent()) {\n-      configureBuilderWithContainerConfiguration(\n-          imageBuilder, manifestTemplate.getContainerConfiguration().get());\n+    Optional<ContainerConfigurationTemplate> configuration =\n+        manifestTemplate.getContainerConfiguration();\n+    if (configuration.isPresent()) {\n+      configureBuilderWithContainerConfiguration(imageBuilder, configuration.get());\n     }\n     return imageBuilder.build();\n   }",
      "parent_sha": "822b86b75ec8f2061f36e4a74aaaa33781cbdfa3"
    }
  },
  {
    "oid": "06cd55cb87e1cd90740303d793f74b62d8c43068",
    "message": "Fixes broken JibPluginIntegrationTest. (#463)",
    "date": "2018-06-28T19:53:34Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/06cd55cb87e1cd90740303d793f74b62d8c43068",
    "details": {
      "sha": "22173150d53c59a429e55040be740f2de2821c73",
      "filename": "jib-gradle-plugin/src/integration-test/java/com/google/cloud/tools/jib/gradle/JibPluginIntegrationTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/06cd55cb87e1cd90740303d793f74b62d8c43068/jib-gradle-plugin%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FJibPluginIntegrationTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/06cd55cb87e1cd90740303d793f74b62d8c43068/jib-gradle-plugin%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FJibPluginIntegrationTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-gradle-plugin%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FJibPluginIntegrationTest.java?ref=06cd55cb87e1cd90740303d793f74b62d8c43068",
      "patch": "@@ -109,9 +109,7 @@ public void testBuild_simple() throws IOException, InterruptedException {\n       Assert.assertThat(\n           ex.getMessage(),\n           CoreMatchers.containsString(\n-              \"Obtaining project build output files failed; make sure you have compiled your \"\n-                  + \"project before trying to build the image. (Did you accidentally run \\\"gradle \"\n-                  + \"clean jib\\\" instead of \\\"gradle clean compileJava jib\\\"?)\"));\n+              \"No classes files were found - did you compile your project?\"));\n     }\n \n     Assert.assertEquals(",
      "parent_sha": "a057f282efdd61f5af51baa0703e765d0ddf85d5"
    }
  },
  {
    "oid": "ee5625503b63dda715362e63a3347a8516b33c19",
    "message": "Fix example comment in JibExtension (#2904)\n\nThe example comment uses `exposedPorts` to define which ports the container should expose, the `ContainerParameters` class does not have such a property. The correct property name is `ports`.",
    "date": "2020-11-30T19:23:50Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/ee5625503b63dda715362e63a3347a8516b33c19",
    "details": {
      "sha": "993d1c16737461444b6f5ba3cf777af645feb4e1",
      "filename": "jib-gradle-plugin/src/main/java/com/google/cloud/tools/jib/gradle/JibExtension.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/ee5625503b63dda715362e63a3347a8516b33c19/jib-gradle-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FJibExtension.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/ee5625503b63dda715362e63a3347a8516b33c19/jib-gradle-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FJibExtension.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-gradle-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FJibExtension.java?ref=ee5625503b63dda715362e63a3347a8516b33c19",
      "patch": "@@ -52,7 +52,7 @@\n  *     jvmFlags = ['-Xms512m', '-Xdebug']\n  *     mainClass = 'com.mycompany.myproject.Main'\n  *     args = ['arg1', 'arg2']\n- *     exposedPorts = ['1000', '2000-2010', '3000']\n+ *     ports = ['1000', '2000-2010', '3000']\n  *     format = OCI\n  *     appRoot = '/app'\n  *   }",
      "parent_sha": "8d34a28a156894867c6fdd8416a9f03cdf04d863"
    }
  },
  {
    "oid": "c5e35fc2c0975b9d77a00b2f8d79f31b7b049537",
    "message": "Switch key and value of builtImagesAndBaseImages (#2769)",
    "date": "2020-09-18T17:46:31Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/c5e35fc2c0975b9d77a00b2f8d79f31b7b049537",
    "details": {
      "sha": "c2cd10763840e086948fbd9c5eddcce5ad11b169",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java",
      "status": "modified",
      "additions": 23,
      "deletions": 19,
      "changes": 42,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/c5e35fc2c0975b9d77a00b2f8d79f31b7b049537/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FStepsRunner.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/c5e35fc2c0975b9d77a00b2f8d79f31b7b049537/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FStepsRunner.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FStepsRunner.java?ref=c5e35fc2c0975b9d77a00b2f8d79f31b7b049537",
      "patch": "@@ -71,17 +71,17 @@ private static <E> Future<E> failedFuture() {\n     private Future<ImagesAndRegistryClient> baseImagesAndRegistryClient = failedFuture();\n     private Future<Map<Image, List<Future<PreparedLayer>>>> baseImagesAndLayers = failedFuture();\n     @Nullable private List<Future<PreparedLayer>> applicationLayers;\n-    private Future<Map<Future<Image>, Image>> builtImagesAndBaseImages = failedFuture();\n+    private Future<Map<Image, Future<Image>>> baseImagesAndBuiltImages = failedFuture();\n     private Future<ManifestTemplate> manifestListOrSingleManifest = failedFuture();\n     private Future<RegistryClient> targetRegistryClient = failedFuture();\n-    public Future<Map<Image, List<Future<BlobDescriptor>>>> baseImagesAndLayerPushResults =\n+    private Future<Map<Image, List<Future<BlobDescriptor>>>> baseImagesAndLayerPushResults =\n         failedFuture();\n     private Future<List<Future<BlobDescriptor>>> applicationLayerPushResults = failedFuture();\n     private Future<Map<Future<Image>, Future<BlobDescriptor>>>\n         builtImagesAndContainerConfigurationPushResults = failedFuture();\n     private Future<Optional<ManifestAndDigest<ManifestTemplate>>> manifestCheckResult =\n         failedFuture();\n-    public Future<List<Future<BuildResult>>> imagePushResults = failedFuture();\n+    private Future<List<Future<BuildResult>>> imagePushResults = failedFuture();\n     private Future<BuildResult> buildResult = failedFuture();\n   }\n \n@@ -249,7 +249,7 @@ private void authenticateBearerPush() {\n \n     results.targetRegistryClient =\n         executorService.submit(\n-            () -> new AuthenticatePushStep(buildContext, childProgressDispatcherFactory).call());\n+            new AuthenticatePushStep(buildContext, childProgressDispatcherFactory));\n   }\n \n   private void saveDocker() {\n@@ -258,6 +258,7 @@ private void saveDocker() {\n     Preconditions.checkArgument(dockerClient.isPresent());\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n+\n     assignLocalImageResult(\n         executorService.submit(\n             LocalBaseImageSteps.retrieveDockerDaemonLayersStep(\n@@ -272,6 +273,7 @@ private void extractTar() {\n     Preconditions.checkArgument(tarPath.isPresent());\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n+\n     assignLocalImageResult(\n         executorService.submit(\n             LocalBaseImageSteps.retrieveTarLayersStep(\n@@ -394,7 +396,8 @@ private void buildAndCacheApplicationLayers() {\n   private void buildImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n-    results.builtImagesAndBaseImages =\n+\n+    results.baseImagesAndBuiltImages =\n         executorService.submit(\n             () -> {\n               // TODO: ideally, progressDispatcher should be closed at the right moment, after the\n@@ -406,11 +409,12 @@ private void buildImages() {\n                   childProgressDispatcherFactory.create(\n                       \"scheduling building manifests\", results.baseImagesAndLayers.get().size());\n \n-              Map<Future<Image>, Image> builtImagesAndBaseImages = new HashMap<>();\n+              Map<Image, Future<Image>> baseImagesAndBuiltImages = new HashMap<>();\n               for (Map.Entry<Image, List<Future<PreparedLayer>>> entry :\n                   results.baseImagesAndLayers.get().entrySet()) {\n                 ProgressEventDispatcher.Factory progressDispatcherFactory =\n                     progressDispatcher.newChildProducer();\n+\n                 Future<Image> builtImage =\n                     executorService.submit(\n                         () ->\n@@ -422,9 +426,9 @@ private void buildImages() {\n                                         Verify.verifyNotNull(entry.getValue())), // layers\n                                     realizeFutures(Verify.verifyNotNull(results.applicationLayers)))\n                                 .call());\n-                builtImagesAndBaseImages.put(builtImage, entry.getKey() /* base Image */);\n+                baseImagesAndBuiltImages.put(entry.getKey() /* base Image */, builtImage);\n               }\n-              return builtImagesAndBaseImages;\n+              return baseImagesAndBuiltImages;\n             });\n   }\n \n@@ -438,7 +442,7 @@ private void buildManifestListOrSingleManifest() {\n                 new BuildManifestListOrSingleManifestStep(\n                         buildContext,\n                         childProgressDispatcherFactory,\n-                        realizeFutures(results.builtImagesAndBaseImages.get().keySet()))\n+                        realizeFutures(results.baseImagesAndBuiltImages.get().values()))\n                     .call());\n   }\n \n@@ -457,10 +461,10 @@ private void pushContainerConfigurations() {\n               ProgressEventDispatcher progressDispatcher =\n                   childProgressDispatcherFactory.create(\n                       \"scheduling pushing container configurations\",\n-                      results.builtImagesAndBaseImages.get().size());\n+                      results.baseImagesAndBuiltImages.get().size());\n \n               Map<Future<Image>, Future<BlobDescriptor>> pushResults = new HashMap<>();\n-              for (Future<Image> builtImage : results.builtImagesAndBaseImages.get().keySet()) {\n+              for (Future<Image> builtImage : results.baseImagesAndBuiltImages.get().values()) {\n                 ProgressEventDispatcher.Factory progressDispatcherFactory =\n                     progressDispatcher.newChildProducer();\n                 Future<BlobDescriptor> configPushResult =\n@@ -523,16 +527,16 @@ private void pushImages() {\n               ProgressEventDispatcher progressDispatcher =\n                   childProgressDispatcherFactory.create(\n                       \"scheduling pushing manifests\",\n-                      results.builtImagesAndBaseImages.get().size());\n+                      results.baseImagesAndBuiltImages.get().size());\n \n               realizeFutures(results.applicationLayerPushResults.get());\n \n               List<Future<BuildResult>> buildResults = new ArrayList<>();\n-              for (Map.Entry<Future<Image>, Image> entry :\n-                  results.builtImagesAndBaseImages.get().entrySet()) {\n+              for (Map.Entry<Image, Future<Image>> entry :\n+                  results.baseImagesAndBuiltImages.get().entrySet()) {\n                 buildResults.add(\n                     pushImage(\n-                        entry.getKey(), entry.getValue(), progressDispatcher.newChildProducer()));\n+                        entry.getValue(), entry.getKey(), progressDispatcher.newChildProducer()));\n               }\n               return buildResults;\n             });\n@@ -600,10 +604,10 @@ private void loadDocker(DockerClient dockerClient) {\n         executorService.submit(\n             () -> {\n               Verify.verify(\n-                  results.builtImagesAndBaseImages.get().size() == 1,\n+                  results.baseImagesAndBuiltImages.get().size() == 1,\n                   \"multi-platform image building not supported when pushing to Docker engine\");\n               Image builtImage =\n-                  results.builtImagesAndBaseImages.get().keySet().iterator().next().get();\n+                  results.baseImagesAndBuiltImages.get().values().iterator().next().get();\n               return new LoadDockerStep(\n                       buildContext, childProgressDispatcherFactory, dockerClient, builtImage)\n                   .call();\n@@ -618,10 +622,10 @@ private void writeTarFile(Path outputPath) {\n         executorService.submit(\n             () -> {\n               Verify.verify(\n-                  results.builtImagesAndBaseImages.get().size() == 1,\n+                  results.baseImagesAndBuiltImages.get().size() == 1,\n                   \"multi-platform image building not supported when building a local tar image\");\n               Image builtImage =\n-                  results.builtImagesAndBaseImages.get().keySet().iterator().next().get();\n+                  results.baseImagesAndBuiltImages.get().values().iterator().next().get();\n \n               return new WriteTarFileStep(\n                       buildContext, childProgressDispatcherFactory, outputPath, builtImage)",
      "parent_sha": "faff19bd59737e10db4425e47b7e6c9904e83833"
    }
  },
  {
    "oid": "22f9492742bc2f85284fb3c8a610673403cf0bc3",
    "message": "Suppresses warning about ignored Future in FinalizingStep. (#1342)",
    "date": "2018-12-12T20:18:52Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/22f9492742bc2f85284fb3c8a610673403cf0bc3",
    "details": {
      "sha": "d1810cd134e30604a242240450f70a960422cdcb",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/FinalizingStep.java",
      "status": "modified",
      "additions": 8,
      "deletions": 6,
      "changes": 14,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/22f9492742bc2f85284fb3c8a610673403cf0bc3/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FFinalizingStep.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/22f9492742bc2f85284fb3c8a610673403cf0bc3/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FFinalizingStep.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FFinalizingStep.java?ref=22f9492742bc2f85284fb3c8a610673403cf0bc3",
      "patch": "@@ -27,6 +27,7 @@\n import java.util.List;\n import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n \n /** Logs the message before finalizing an image build. */\n class FinalizingStep implements AsyncStep<Void>, Callable<Void> {\n@@ -74,12 +75,13 @@ public Void call() throws ExecutionException {\n       asyncDependencies.addSteps(NonBlockingSteps.get(wrappedDependency));\n     }\n \n-    // TODO: Don't let future error be suppressed\n-    asyncDependencies.whenAllSucceed(\n-        () -> {\n-          buildConfiguration.getEventDispatcher().dispatch(LogEvent.lifecycle(\"Finalizing...\"));\n-          return null;\n-        });\n+    // This suppresses any exceptions of this future.\n+    Future<Void> ignored =\n+        asyncDependencies.whenAllSucceed(\n+            () -> {\n+              buildConfiguration.getEventDispatcher().dispatch(LogEvent.lifecycle(\"Finalizing...\"));\n+              return null;\n+            });\n \n     return null;\n   }",
      "parent_sha": "5374e884cbfb3ebfd7216248da732a55f92a3131"
    }
  },
  {
    "oid": "c4c0c9f6635c03e3862cf39bc6c169d33263d0ac",
    "message": "Fix class cast exception (#2128)",
    "date": "2019-11-06T21:50:56Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/c4c0c9f6635c03e3862cf39bc6c169d33263d0ac",
    "details": {
      "sha": "fa0e92daf246ca0d760d0271ab3f504f8b0d8841",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/api/RegistryUnauthorizedException.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/c4c0c9f6635c03e3862cf39bc6c169d33263d0ac/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fapi%2FRegistryUnauthorizedException.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/c4c0c9f6635c03e3862cf39bc6c169d33263d0ac/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fapi%2FRegistryUnauthorizedException.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fapi%2FRegistryUnauthorizedException.java?ref=c4c0c9f6635c03e3862cf39bc6c169d33263d0ac",
      "patch": "@@ -44,6 +44,6 @@ public String getImageReference() {\n   }\n \n   public HttpResponseException getHttpResponseException() {\n-    return (HttpResponseException) getCause();\n+    return (HttpResponseException) getCause().getCause();\n   }\n }",
      "parent_sha": "9ea9033a8c82532303746565f5a9c02934252cca"
    }
  },
  {
    "oid": "be6c283eb0947fffbb42c639062b62788c47300a",
    "message": "Parallelizes pushing to multiple tags. (#1028)",
    "date": "2018-09-24T20:09:24Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/be6c283eb0947fffbb42c639062b62788c47300a",
    "details": {
      "sha": "5a3fb7ea4987a54ceca4213cc111e4544965b571",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PushImageStep.java",
      "status": "modified",
      "additions": 12,
      "deletions": 9,
      "changes": 21,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/be6c283eb0947fffbb42c639062b62788c47300a/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPushImageStep.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/be6c283eb0947fffbb42c639062b62788c47300a/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPushImageStep.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPushImageStep.java?ref=be6c283eb0947fffbb42c639062b62788c47300a",
      "patch": "@@ -23,12 +23,10 @@\n import com.google.cloud.tools.jib.image.json.BuildableManifestTemplate;\n import com.google.cloud.tools.jib.image.json.ImageToJsonTranslator;\n import com.google.cloud.tools.jib.registry.RegistryClient;\n-import com.google.cloud.tools.jib.registry.RegistryException;\n import com.google.common.collect.ImmutableList;\n import com.google.common.util.concurrent.Futures;\n import com.google.common.util.concurrent.ListenableFuture;\n import com.google.common.util.concurrent.ListeningExecutorService;\n-import java.io.IOException;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.Callable;\n@@ -96,10 +94,11 @@ public Void call() throws ExecutionException, InterruptedException {\n     return Futures.whenAllSucceed(dependenciesBuilder.build())\n         .call(this::afterPushSteps, listeningExecutorService)\n         .get()\n+        .get()\n         .get();\n   }\n \n-  private ListenableFuture<Void> afterPushSteps() throws ExecutionException {\n+  private ListenableFuture<ListenableFuture<Void>> afterPushSteps() throws ExecutionException {\n     List<ListenableFuture<?>> dependencies = new ArrayList<>();\n     for (AsyncStep<PushBlobStep> pushBlobStepStep : NonBlockingSteps.get(pushBaseImageLayersStep)) {\n       dependencies.add(NonBlockingSteps.get(pushBlobStepStep).getFuture());\n@@ -114,7 +113,7 @@ private ListenableFuture<Void> afterPushSteps() throws ExecutionException {\n         .call(this::afterAllPushed, listeningExecutorService);\n   }\n \n-  private Void afterAllPushed() throws IOException, RegistryException, ExecutionException {\n+  private ListenableFuture<Void> afterAllPushed() throws ExecutionException {\n     try (Timer ignored = new Timer(buildConfiguration.getBuildLogger(), DESCRIPTION)) {\n       RegistryClient registryClient =\n           buildConfiguration\n@@ -134,13 +133,17 @@ private Void afterAllPushed() throws IOException, RegistryException, ExecutionEx\n                   NonBlockingSteps.get(NonBlockingSteps.get(pushContainerConfigurationStep))));\n \n       // Pushes to all target image tags.\n-      // TODO: Parallelize.\n+      List<ListenableFuture<Void>> pushAllTagsFutures = new ArrayList<>();\n       for (String tag : buildConfiguration.getAllTargetImageTags()) {\n-        buildConfiguration.getBuildLogger().info(\"Tagging with \" + tag + \"...\");\n-        registryClient.pushManifest(manifestTemplate, tag);\n+        pushAllTagsFutures.add(\n+            listeningExecutorService.submit(\n+                () -> {\n+                  buildConfiguration.getBuildLogger().info(\"Tagging with \" + tag + \"...\");\n+                  registryClient.pushManifest(manifestTemplate, tag);\n+                  return null;\n+                }));\n       }\n+      return Futures.whenAllSucceed(pushAllTagsFutures).call(() -> null, listeningExecutorService);\n     }\n-\n-    return null;\n   }\n }",
      "parent_sha": "6875a05ab0bbbf6a7769bedf4ac720da09e0a07c"
    }
  },
  {
    "oid": "9217975afaab77e9c10a21fcb335f2b17d3fc301",
    "message": "Adding functionality to push base image layers and push container config to the registry (#2656)\n\n* Adding functionality to push base image layers and push container configurations\r\n\r\n* Changing variable names",
    "date": "2020-08-05T17:57:53Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/9217975afaab77e9c10a21fcb335f2b17d3fc301",
    "details": {
      "sha": "84d82558a02262222b3df031c6ed800241ee8814",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java",
      "status": "modified",
      "additions": 55,
      "deletions": 25,
      "changes": 80,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/9217975afaab77e9c10a21fcb335f2b17d3fc301/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FStepsRunner.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/9217975afaab77e9c10a21fcb335f2b17d3fc301/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FStepsRunner.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FStepsRunner.java?ref=9217975afaab77e9c10a21fcb335f2b17d3fc301",
      "patch": "@@ -71,9 +71,10 @@ private static <E> Future<E> failedFuture() {\n     @Nullable private List<Future<PreparedLayer>> applicationLayers;\n     private Future<List<Future<Image>>> builtImages = failedFuture();\n     private Future<RegistryClient> targetRegistryClient = failedFuture();\n-    private Future<List<Future<BlobDescriptor>>> baseImageLayerPushResults = failedFuture();\n+    private Future<List<List<Future<BlobDescriptor>>>> baseImageLayerPushResults = failedFuture();\n     private Future<List<Future<BlobDescriptor>>> applicationLayerPushResults = failedFuture();\n-    private Future<BlobDescriptor> containerConfigurationPushResult = failedFuture();\n+    private Future<Map<Future<Image>, Future<BlobDescriptor>>>\n+        builtImagesAndContainerConfigurationPushResults = failedFuture();\n     private Future<BuildResult> buildResult = failedFuture();\n     private Future<Optional<ManifestAndDigest<ManifestTemplate>>> manifestCheckResult =\n         failedFuture();\n@@ -332,17 +333,21 @@ private void pushBaseImageLayers() {\n \n     results.baseImageLayerPushResults =\n         executorService.submit(\n-            () ->\n-                scheduleCallables(\n-                    PushLayerStep.makeList(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        Verify.verifyNotNull(\n-                            results\n-                                .baseImagesAndLayers\n-                                .get()\n-                                .get(results.baseImagesAndRegistryClient.get().images.get(0))))));\n+            () -> {\n+              List<List<Future<BlobDescriptor>>> pushResults = new ArrayList<>();\n+              for (List<Future<PreparedLayer>> baseImageLayers :\n+                  results.baseImagesAndLayers.get().values()) {\n+                List<Future<BlobDescriptor>> baseImageLayerPushResult =\n+                    scheduleCallables(\n+                        PushLayerStep.makeList(\n+                            buildContext,\n+                            childProgressDispatcherFactory,\n+                            results.targetRegistryClient.get(),\n+                            Verify.verifyNotNull(baseImageLayers)));\n+                pushResults.add(baseImageLayerPushResult);\n+              }\n+              return pushResults;\n+            });\n   }\n \n   private void buildAndCacheApplicationLayers() {\n@@ -384,15 +389,24 @@ private void pushContainerConfiguration() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n-    results.containerConfigurationPushResult =\n+    results.builtImagesAndContainerConfigurationPushResults =\n         executorService.submit(\n-            () ->\n-                new PushContainerConfigurationStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.targetRegistryClient.get(),\n-                        results.builtImages.get().get(0).get())\n-                    .call());\n+            () -> {\n+              Map<Future<Image>, Future<BlobDescriptor>> pushResults = new HashMap<>();\n+              for (Future<Image> builtImage : results.builtImages.get()) {\n+                Future<BlobDescriptor> configPushResult =\n+                    executorService.submit(\n+                        () ->\n+                            new PushContainerConfigurationStep(\n+                                    buildContext,\n+                                    childProgressDispatcherFactory,\n+                                    results.targetRegistryClient.get(),\n+                                    builtImage.get())\n+                                .call());\n+                pushResults.put(builtImage, configPushResult);\n+              }\n+              return pushResults;\n+            });\n   }\n \n   private void pushApplicationLayers() {\n@@ -421,7 +435,12 @@ private void checkImageInTargetRegistry() {\n                         buildContext,\n                         childProgressDispatcherFactory,\n                         results.targetRegistryClient.get(),\n-                        results.containerConfigurationPushResult.get(),\n+                        Verify.verifyNotNull(\n+                                results\n+                                    .builtImagesAndContainerConfigurationPushResults\n+                                    .get()\n+                                    .get(results.builtImages.get().get(0)))\n+                            .get(),\n                         results.builtImages.get().get(0).get())\n                     .call());\n   }\n@@ -433,7 +452,7 @@ private void pushImages() {\n     results.buildResult =\n         executorService.submit(\n             () -> {\n-              realizeFutures(results.baseImageLayerPushResults.get());\n+              realizeFutures(results.baseImageLayerPushResults.get().get(0));\n               realizeFutures(results.applicationLayerPushResults.get());\n \n               List<Future<BuildResult>> manifestPushResults =\n@@ -442,14 +461,25 @@ private void pushImages() {\n                           buildContext,\n                           childProgressDispatcherFactory,\n                           results.targetRegistryClient.get(),\n-                          results.containerConfigurationPushResult.get(),\n+                          Verify.verifyNotNull(\n+                                  results\n+                                      .builtImagesAndContainerConfigurationPushResults\n+                                      .get()\n+                                      .get(results.builtImages.get().get(0)))\n+                              .get(),\n                           results.builtImages.get().get(0).get(),\n                           results.manifestCheckResult.get().isPresent()));\n               realizeFutures(manifestPushResults);\n               return manifestPushResults.isEmpty()\n                   ? new BuildResult(\n                       results.manifestCheckResult.get().get().getDigest(),\n-                      results.containerConfigurationPushResult.get().getDigest())\n+                      Verify.verifyNotNull(\n+                              results\n+                                  .builtImagesAndContainerConfigurationPushResults\n+                                  .get()\n+                                  .get(results.builtImages.get().get(0)))\n+                          .get()\n+                          .getDigest())\n                   // Manifest pushers return the same BuildResult.\n                   : manifestPushResults.get(0).get();\n             });",
      "parent_sha": "da43811fbefffd8a1e63a9e6d342ee3f8bf0e6a6"
    }
  },
  {
    "oid": "fde35111cafd1ca00dda3beafabd3576e70531c2",
    "message": "Add more documentation for when InterruptedException is thrown in UpdateChecker (#3369)",
    "date": "2021-08-03T14:44:29Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/fde35111cafd1ca00dda3beafabd3576e70531c2",
    "details": {
      "sha": "6b2d1367287810543f0a1b8c6d6b84ab1fb0618d",
      "filename": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/fde35111cafd1ca00dda3beafabd3576e70531c2/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FUpdateChecker.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/fde35111cafd1ca00dda3beafabd3576e70531c2/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FUpdateChecker.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FUpdateChecker.java?ref=fde35111cafd1ca00dda3beafabd3576e70531c2",
      "patch": "@@ -145,8 +145,9 @@ public static Optional<String> finishUpdateCheck(Future<Optional<String>> update\n     if (updateMessageFuture.isDone()) {\n       try {\n         return updateMessageFuture.get();\n-      } catch (InterruptedException | ExecutionException ignored) {\n-        // Fail silently;\n+      } catch (InterruptedException | ExecutionException ex) {\n+        // No need to restore the interrupted status. The intention here is to silently consume any\n+        // kind of error\n       }\n     }\n     updateMessageFuture.cancel(true);",
      "parent_sha": "a92ded13a67b02834e96ec6ba430fc074aced2b2"
    }
  },
  {
    "oid": "6e197e88da735f9d567f4ef5f9f32f62005c79f2",
    "message": "Migrate to Truth and refactor test in MavenProjectProperites (#3114)\n\n* Migrate to Truth and refactor code\r\n\r\n* more cleanups\r\n\r\n* more cleanups\r\n\r\n* Split a test into two\r\n\r\n* assert buildng a JibContainerBuilder",
    "date": "2021-03-08T17:05:26Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/6e197e88da735f9d567f4ef5f9f32f62005c79f2",
    "details": {
      "sha": "ae5e50a0551dd730da87467892c997f7edc1e85b",
      "filename": "jib-maven-plugin/src/test/java/com/google/cloud/tools/jib/maven/MavenProjectPropertiesTest.java",
      "status": "modified",
      "additions": 405,
      "deletions": 473,
      "changes": 878,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/6e197e88da735f9d567f4ef5f9f32f62005c79f2/jib-maven-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FMavenProjectPropertiesTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/6e197e88da735f9d567f4ef5f9f32f62005c79f2/jib-maven-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FMavenProjectPropertiesTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-maven-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FMavenProjectPropertiesTest.java?ref=6e197e88da735f9d567f4ef5f9f32f62005c79f2",
      "patch": "@@ -16,6 +16,12 @@\n \n package com.google.cloud.tools.jib.maven;\n \n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth8.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n import com.google.cloud.tools.jib.api.CacheDirectoryCreationException;\n import com.google.cloud.tools.jib.api.Containerizer;\n import com.google.cloud.tools.jib.api.InvalidImageReferenceException;\n@@ -32,10 +38,10 @@\n import com.google.cloud.tools.jib.filesystem.TempDirectoryProvider;\n import com.google.cloud.tools.jib.maven.extension.JibMavenPluginExtension;\n import com.google.cloud.tools.jib.plugins.common.ContainerizingMode;\n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.io.ByteStreams;\n import com.google.common.io.Resources;\n+import com.google.common.truth.Correspondence;\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n@@ -44,6 +50,7 @@\n import java.nio.file.Path;\n import java.nio.file.Paths;\n import java.time.Instant;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n@@ -52,9 +59,9 @@\n import java.util.Properties;\n import java.util.Set;\n import java.util.StringJoiner;\n-import java.util.function.Function;\n import java.util.function.Supplier;\n import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n import org.apache.maven.artifact.Artifact;\n import org.apache.maven.artifact.DefaultArtifact;\n import org.apache.maven.execution.MavenExecutionRequest;\n@@ -68,7 +75,6 @@\n import org.codehaus.plexus.archiver.zip.ZipEntry;\n import org.codehaus.plexus.archiver.zip.ZipOutputStream;\n import org.codehaus.plexus.util.xml.Xpp3Dom;\n-import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n@@ -82,99 +88,38 @@\n @RunWith(MockitoJUnitRunner.class)\n public class MavenProjectPropertiesTest {\n \n-  private static final ContainerizingMode DEFAULT_CONTAINERIZING_MODE = ContainerizingMode.EXPLODED;\n-  private static final Instant SAMPLE_FILE_MODIFICATION_TIME = Instant.ofEpochSecond(32);\n+  private static final Correspondence<FileEntry, Path> SOURCE_FILE_OF =\n+      Correspondence.transforming(FileEntry::getSourceFile, \"has sourceFile of\");\n+  private static final Correspondence<FileEntry, String> EXTRACTION_PATH_OF =\n+      Correspondence.transforming(\n+          entry -> entry.getExtractionPath().toString(), \"has extractionPath of\");\n+\n+  private static final Instant EPOCH_PLUS_32 = Instant.ofEpochSecond(32);\n \n   /** Helper for reading back layers in a {@link BuildContext}. */\n   private static class ContainerBuilderLayers {\n \n-    private final List<FileEntriesLayer> resourcesLayers;\n-    private final List<FileEntriesLayer> classesLayers;\n-    private final List<FileEntriesLayer> dependenciesLayers;\n-    private final List<FileEntriesLayer> snapshotsLayers;\n-    private final List<FileEntriesLayer> extraFilesLayers;\n+    @Nullable private final FileEntriesLayer resourcesLayer;\n+    @Nullable private final FileEntriesLayer classesLayer;\n+    @Nullable private final FileEntriesLayer dependenciesLayer;\n+    @Nullable private final FileEntriesLayer snapshotsLayer;\n+    @Nullable private final FileEntriesLayer extraFilesLayer;\n \n     private ContainerBuilderLayers(BuildContext buildContext) {\n-      resourcesLayers = getLayerConfigurationsByName(buildContext, LayerType.RESOURCES.getName());\n-      classesLayers = getLayerConfigurationsByName(buildContext, LayerType.CLASSES.getName());\n-      dependenciesLayers =\n-          getLayerConfigurationsByName(buildContext, LayerType.DEPENDENCIES.getName());\n-      snapshotsLayers =\n-          getLayerConfigurationsByName(buildContext, LayerType.SNAPSHOT_DEPENDENCIES.getName());\n-      extraFilesLayers =\n-          getLayerConfigurationsByName(buildContext, LayerType.EXTRA_FILES.getName());\n+      resourcesLayer = getLayerByName(buildContext, LayerType.RESOURCES.getName());\n+      classesLayer = getLayerByName(buildContext, LayerType.CLASSES.getName());\n+      dependenciesLayer = getLayerByName(buildContext, LayerType.DEPENDENCIES.getName());\n+      snapshotsLayer = getLayerByName(buildContext, LayerType.SNAPSHOT_DEPENDENCIES.getName());\n+      extraFilesLayer = getLayerByName(buildContext, LayerType.EXTRA_FILES.getName());\n     }\n-  }\n-\n-  private static List<FileEntriesLayer> getLayerConfigurationsByName(\n-      BuildContext buildContext, String name) {\n-    return buildContext\n-        .getLayerConfigurations()\n-        .stream()\n-        .filter(layer -> layer.getName().equals(name))\n-        .collect(Collectors.toList());\n-  }\n \n-  private static <T> void assertLayerEntriesUnordered(\n-      List<T> expectedPaths, List<FileEntry> entries, Function<FileEntry, T> fieldSelector) {\n-    List<T> expected = expectedPaths.stream().sorted().collect(Collectors.toList());\n-    List<T> actual = entries.stream().map(fieldSelector).sorted().collect(Collectors.toList());\n-    Assert.assertEquals(expected, actual);\n-  }\n-\n-  private static void assertSourcePathsUnordered(\n-      List<Path> expectedPaths, List<FileEntry> entries) {\n-    assertLayerEntriesUnordered(expectedPaths, entries, FileEntry::getSourceFile);\n-  }\n-\n-  private static void assertExtractionPathsUnordered(\n-      List<String> expectedPaths, List<FileEntry> entries) {\n-    assertLayerEntriesUnordered(\n-        expectedPaths, entries, layerEntry -> layerEntry.getExtractionPath().toString());\n-  }\n-\n-  private static void assertModificationTime(Instant instant, List<FileEntriesLayer> layers) {\n-    for (FileEntriesLayer layer : layers) {\n-      for (FileEntry entry : layer.getEntries()) {\n-        String message = \"wrong time: \" + entry.getSourceFile() + \"-->\" + entry.getExtractionPath();\n-        Assert.assertEquals(message, instant, entry.getModificationTime());\n-      }\n+    @Nullable\n+    private static FileEntriesLayer getLayerByName(BuildContext buildContext, String name) {\n+      List<FileEntriesLayer> layers = buildContext.getLayerConfigurations();\n+      return layers.stream().filter(layer -> layer.getName().equals(name)).findFirst().orElse(null);\n     }\n   }\n \n-  private static void assertNonDefaultAppRoot(BuildContext buildContext) {\n-    ContainerBuilderLayers layers = new ContainerBuilderLayers(buildContext);\n-    assertExtractionPathsUnordered(\n-        Arrays.asList(\n-            \"/my/app/libs/dependency-1.0.0-770.jar\",\n-            \"/my/app/libs/dependency-1.0.0-200.jar\",\n-            \"/my/app/libs/dependency-1.0.0-480.jar\",\n-            \"/my/app/libs/libraryA.jar\",\n-            \"/my/app/libs/libraryB.jar\",\n-            \"/my/app/libs/library.jarC.jar\"),\n-        layers.dependenciesLayers.get(0).getEntries());\n-    assertExtractionPathsUnordered(\n-        Collections.singletonList(\"/my/app/libs/dependencyX-1.0.0-SNAPSHOT.jar\"),\n-        layers.snapshotsLayers.get(0).getEntries());\n-    assertExtractionPathsUnordered(\n-        Arrays.asList(\n-            \"/my/app/resources/directory\",\n-            \"/my/app/resources/directory/somefile\",\n-            \"/my/app/resources/package\",\n-            \"/my/app/resources/resourceA\",\n-            \"/my/app/resources/resourceB\",\n-            \"/my/app/resources/world\"),\n-        layers.resourcesLayers.get(0).getEntries());\n-    assertExtractionPathsUnordered(\n-        Arrays.asList(\n-            \"/my/app/classes/HelloWorld.class\",\n-            \"/my/app/classes/directory\",\n-            \"/my/app/classes/package\",\n-            \"/my/app/classes/package/some.class\",\n-            \"/my/app/classes/some.class\"),\n-        layers.classesLayers.get(0).getEntries());\n-  }\n-\n   private static Path getResource(String path) throws URISyntaxException {\n     return Paths.get(Resources.getResource(path).toURI());\n   }\n@@ -202,8 +147,8 @@ private static Path zipUpDirectory(Path sourceRoot, Path targetZip) throws IOExc\n   }\n \n   private static Artifact newArtifact(Path sourceJar) {\n-    Artifact artifact = Mockito.mock(Artifact.class);\n-    Mockito.when(artifact.getFile()).thenReturn(sourceJar.toFile());\n+    Artifact artifact = mock(Artifact.class);\n+    when(artifact.getFile()).thenReturn(sourceJar.toFile());\n     return artifact;\n   }\n \n@@ -247,11 +192,11 @@ private static Xpp3Dom addXpp3DomChild(Xpp3Dom parent, String name, String value\n \n   @Before\n   public void setUp() throws IOException, URISyntaxException {\n-    Mockito.when(mockLog.isDebugEnabled()).thenReturn(true);\n-    Mockito.when(mockLog.isWarnEnabled()).thenReturn(true);\n-    Mockito.when(mockLog.isErrorEnabled()).thenReturn(true);\n+    when(mockLog.isDebugEnabled()).thenReturn(true);\n+    when(mockLog.isWarnEnabled()).thenReturn(true);\n+    when(mockLog.isErrorEnabled()).thenReturn(true);\n \n-    Mockito.when(mockMavenSession.getRequest()).thenReturn(mockMavenRequest);\n+    when(mockMavenSession.getRequest()).thenReturn(mockMavenRequest);\n     mavenProjectProperties =\n         new MavenProjectProperties(\n             mockJibPluginDescriptor,\n@@ -265,8 +210,8 @@ public void setUp() throws IOException, URISyntaxException {\n     Path outputPath = getResource(\"maven/application/output\");\n     Path dependenciesPath = getResource(\"maven/application/dependencies\");\n \n-    Mockito.when(mockMavenProject.getBuild()).thenReturn(mockBuild);\n-    Mockito.when(mockBuild.getOutputDirectory()).thenReturn(outputPath.toString());\n+    when(mockMavenProject.getBuild()).thenReturn(mockBuild);\n+    when(mockBuild.getOutputDirectory()).thenReturn(outputPath.toString());\n \n     Set<Artifact> artifacts =\n         ImmutableSet.of(\n@@ -279,281 +224,275 @@ public void setUp() throws IOException, URISyntaxException {\n             // repository\n             testRepository.findArtifact(\"com.test\", \"dependency\", \"1.0.0\"),\n             testRepository.findArtifact(\"com.test\", \"dependencyX\", \"1.0.0-SNAPSHOT\"));\n-    Mockito.when(mockMavenProject.getArtifacts()).thenReturn(artifacts);\n+    when(mockMavenProject.getArtifacts()).thenReturn(artifacts);\n \n     Path emptyDirectory =\n         getResource(\"maven/webapp\").resolve(\"final-name/WEB-INF/classes/empty_dir\");\n     Files.createDirectories(emptyDirectory);\n \n-    Mockito.when(mockMavenProject.getProperties()).thenReturn(mockMavenProperties);\n+    when(mockMavenProject.getProperties()).thenReturn(mockMavenProperties);\n   }\n \n   @Test\n   public void testGetMainClassFromJar_success() {\n-    Mockito.when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getConfiguration()).thenReturn(pluginConfiguration);\n+    when(mockPlugin.getConfiguration()).thenReturn(pluginConfiguration);\n     Xpp3Dom archive = new Xpp3Dom(\"archive\");\n     Xpp3Dom manifest = new Xpp3Dom(\"manifest\");\n     pluginConfiguration.addChild(archive);\n     archive.addChild(manifest);\n     manifest.addChild(newXpp3Dom(\"mainClass\", \"some.main.class\"));\n \n-    Assert.assertEquals(\"some.main.class\", mavenProjectProperties.getMainClassFromJarPlugin());\n+    assertThat(mavenProjectProperties.getMainClassFromJarPlugin()).isEqualTo(\"some.main.class\");\n   }\n \n   @Test\n   public void testGetMainClassFromJar_missingMainClass() {\n-    Mockito.when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getConfiguration()).thenReturn(pluginConfiguration);\n+    when(mockPlugin.getConfiguration()).thenReturn(pluginConfiguration);\n     Xpp3Dom archive = new Xpp3Dom(\"archive\");\n     archive.addChild(new Xpp3Dom(\"manifest\"));\n     pluginConfiguration.addChild(archive);\n \n-    Assert.assertNull(mavenProjectProperties.getMainClassFromJarPlugin());\n+    assertThat(mavenProjectProperties.getMainClassFromJarPlugin()).isNull();\n   }\n \n   @Test\n   public void testGetMainClassFromJar_missingManifest() {\n-    Mockito.when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getConfiguration()).thenReturn(pluginConfiguration);\n+    when(mockPlugin.getConfiguration()).thenReturn(pluginConfiguration);\n     pluginConfiguration.addChild(new Xpp3Dom(\"archive\"));\n \n-    Assert.assertNull(mavenProjectProperties.getMainClassFromJarPlugin());\n+    assertThat(mavenProjectProperties.getMainClassFromJarPlugin()).isNull();\n   }\n \n   @Test\n   public void testGetMainClassFromJar_missingArchive() {\n-    Mockito.when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getConfiguration()).thenReturn(pluginConfiguration);\n+    when(mockPlugin.getConfiguration()).thenReturn(pluginConfiguration);\n \n-    Assert.assertNull(mavenProjectProperties.getMainClassFromJarPlugin());\n+    assertThat(mavenProjectProperties.getMainClassFromJarPlugin()).isNull();\n   }\n \n   @Test\n   public void testGetMainClassFromJar_missingConfiguration() {\n-    Mockito.when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n         .thenReturn(mockPlugin);\n \n-    Assert.assertNull(mavenProjectProperties.getMainClassFromJarPlugin());\n+    assertThat(mavenProjectProperties.getMainClassFromJarPlugin()).isNull();\n   }\n \n   @Test\n   public void testGetMainClassFromJar_missingPlugin() {\n-    Assert.assertNull(mavenProjectProperties.getMainClassFromJarPlugin());\n+    assertThat(mavenProjectProperties.getMainClassFromJarPlugin()).isNull();\n   }\n \n   @Test\n   public void testIsWarProject() {\n-    Assert.assertFalse(mavenProjectProperties.isWarProject());\n+    assertThat(mavenProjectProperties.isWarProject()).isFalse();\n   }\n \n   @Test\n   public void testGetVersionFromString() {\n-    Assert.assertEquals(8, MavenProjectProperties.getVersionFromString(\"1.8\"));\n-    Assert.assertEquals(8, MavenProjectProperties.getVersionFromString(\"1.8.0_123\"));\n-    Assert.assertEquals(11, MavenProjectProperties.getVersionFromString(\"11\"));\n-    Assert.assertEquals(11, MavenProjectProperties.getVersionFromString(\"11.0.1\"));\n+    assertThat(MavenProjectProperties.getVersionFromString(\"1.8\")).isEqualTo(8);\n+    assertThat(MavenProjectProperties.getVersionFromString(\"1.8.0_123\")).isEqualTo(8);\n+    assertThat(MavenProjectProperties.getVersionFromString(\"11\")).isEqualTo(11);\n+    assertThat(MavenProjectProperties.getVersionFromString(\"11.0.1\")).isEqualTo(11);\n \n-    Assert.assertEquals(0, MavenProjectProperties.getVersionFromString(\"asdfasdf\"));\n-    Assert.assertEquals(0, MavenProjectProperties.getVersionFromString(\"\"));\n-    Assert.assertEquals(0, MavenProjectProperties.getVersionFromString(\"11abc\"));\n-    Assert.assertEquals(0, MavenProjectProperties.getVersionFromString(\"1.abc\"));\n+    assertThat(MavenProjectProperties.getVersionFromString(\"asdfasdf\")).isEqualTo(0);\n+    assertThat(MavenProjectProperties.getVersionFromString(\"\")).isEqualTo(0);\n+    assertThat(MavenProjectProperties.getVersionFromString(\"11abc\")).isEqualTo(0);\n+    assertThat(MavenProjectProperties.getVersionFromString(\"1.abc\")).isEqualTo(0);\n   }\n \n   @Test\n   public void testGetMajorJavaVersion_undefinedDefaultsTo6() {\n-    Assert.assertEquals(6, mavenProjectProperties.getMajorJavaVersion());\n+    assertThat(mavenProjectProperties.getMajorJavaVersion()).isEqualTo(6);\n   }\n \n   @Test\n   public void testGetMajorJavaVersion_targetProperty() {\n-    Mockito.when(mockMavenProperties.getProperty(\"maven.compiler.target\")).thenReturn(\"1.8\");\n-    Assert.assertEquals(8, mavenProjectProperties.getMajorJavaVersion());\n+    when(mockMavenProperties.getProperty(\"maven.compiler.target\")).thenReturn(\"1.8\");\n+    assertThat(mavenProjectProperties.getMajorJavaVersion()).isEqualTo(8);\n \n-    Mockito.when(mockMavenProperties.getProperty(\"maven.compiler.target\")).thenReturn(\"1.7\");\n-    Assert.assertEquals(7, mavenProjectProperties.getMajorJavaVersion());\n+    when(mockMavenProperties.getProperty(\"maven.compiler.target\")).thenReturn(\"1.7\");\n+    assertThat(mavenProjectProperties.getMajorJavaVersion()).isEqualTo(7);\n \n-    Mockito.when(mockMavenProperties.getProperty(\"maven.compiler.target\")).thenReturn(\"11\");\n-    Assert.assertEquals(11, mavenProjectProperties.getMajorJavaVersion());\n+    when(mockMavenProperties.getProperty(\"maven.compiler.target\")).thenReturn(\"11\");\n+    assertThat(mavenProjectProperties.getMajorJavaVersion()).isEqualTo(11);\n   }\n \n   @Test\n   public void testValidateBaseImageVersion_releaseProperty() {\n-    Mockito.when(mockMavenProperties.getProperty(\"maven.compiler.release\")).thenReturn(\"1.8\");\n-    Assert.assertEquals(8, mavenProjectProperties.getMajorJavaVersion());\n+    when(mockMavenProperties.getProperty(\"maven.compiler.release\")).thenReturn(\"1.8\");\n+    assertThat(mavenProjectProperties.getMajorJavaVersion()).isEqualTo(8);\n \n-    Mockito.when(mockMavenProperties.getProperty(\"maven.compiler.release\")).thenReturn(\"1.7\");\n-    Assert.assertEquals(7, mavenProjectProperties.getMajorJavaVersion());\n+    when(mockMavenProperties.getProperty(\"maven.compiler.release\")).thenReturn(\"1.7\");\n+    assertThat(mavenProjectProperties.getMajorJavaVersion()).isEqualTo(7);\n \n-    Mockito.when(mockMavenProperties.getProperty(\"maven.compiler.release\")).thenReturn(\"9\");\n-    Assert.assertEquals(9, mavenProjectProperties.getMajorJavaVersion());\n+    when(mockMavenProperties.getProperty(\"maven.compiler.release\")).thenReturn(\"9\");\n+    assertThat(mavenProjectProperties.getMajorJavaVersion()).isEqualTo(9);\n   }\n \n   @Test\n   public void testValidateBaseImageVersion_compilerPluginTarget() {\n-    Mockito.when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-compiler-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-compiler-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getConfiguration()).thenReturn(pluginConfiguration);\n+    when(mockPlugin.getConfiguration()).thenReturn(pluginConfiguration);\n     Xpp3Dom compilerTarget = new Xpp3Dom(\"target\");\n     pluginConfiguration.addChild(compilerTarget);\n \n     compilerTarget.setValue(\"1.8\");\n-    Assert.assertEquals(8, mavenProjectProperties.getMajorJavaVersion());\n+    assertThat(mavenProjectProperties.getMajorJavaVersion()).isEqualTo(8);\n \n     compilerTarget.setValue(\"1.6\");\n-    Assert.assertEquals(6, mavenProjectProperties.getMajorJavaVersion());\n+    assertThat(mavenProjectProperties.getMajorJavaVersion()).isEqualTo(6);\n \n     compilerTarget.setValue(\"13\");\n-    Assert.assertEquals(13, mavenProjectProperties.getMajorJavaVersion());\n+    assertThat(mavenProjectProperties.getMajorJavaVersion()).isEqualTo(13);\n   }\n \n   @Test\n   public void testValidateBaseImageVersion_compilerPluginRelease() {\n-    Mockito.when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-compiler-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-compiler-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getConfiguration()).thenReturn(pluginConfiguration);\n+    when(mockPlugin.getConfiguration()).thenReturn(pluginConfiguration);\n     Xpp3Dom compilerRelease = new Xpp3Dom(\"release\");\n     pluginConfiguration.addChild(compilerRelease);\n \n     compilerRelease.setValue(\"1.8\");\n-    Assert.assertEquals(8, mavenProjectProperties.getMajorJavaVersion());\n+    assertThat(mavenProjectProperties.getMajorJavaVersion()).isEqualTo(8);\n \n     compilerRelease.setValue(\"10\");\n-    Assert.assertEquals(10, mavenProjectProperties.getMajorJavaVersion());\n-\n-    compilerRelease.setValue(\"13\");\n-    Assert.assertEquals(13, mavenProjectProperties.getMajorJavaVersion());\n+    assertThat(mavenProjectProperties.getMajorJavaVersion()).isEqualTo(10);\n   }\n \n   @Test\n   public void isProgressFooterEnabled() {\n-    Mockito.when(mockMavenRequest.isInteractiveMode()).thenReturn(false);\n-    Assert.assertFalse(MavenProjectProperties.isProgressFooterEnabled(mockMavenSession));\n+    when(mockMavenRequest.isInteractiveMode()).thenReturn(false);\n+    assertThat(MavenProjectProperties.isProgressFooterEnabled(mockMavenSession)).isFalse();\n   }\n \n   @Test\n   public void testCreateContainerBuilder_correctFiles()\n       throws URISyntaxException, IOException, InvalidImageReferenceException,\n           CacheDirectoryCreationException {\n-    BuildContext buildContext = setUpBuildContext(\"/app\", DEFAULT_CONTAINERIZING_MODE);\n-    ContainerBuilderLayers layers = new ContainerBuilderLayers(buildContext);\n+    ContainerBuilderLayers layers = new ContainerBuilderLayers(setUpBuildContext());\n \n     Path dependenciesPath = getResource(\"maven/application/dependencies\");\n     Path applicationDirectory = getResource(\"maven/application\");\n-    assertSourcePathsUnordered(\n-        ImmutableList.of(\n+    assertThat(layers.dependenciesLayer.getEntries())\n+        .comparingElementsUsing(SOURCE_FILE_OF)\n+        .containsExactly(\n             testRepository.artifactPathOnDisk(\"com.test\", \"dependency\", \"1.0.0\"),\n             dependenciesPath.resolve(\"more/dependency-1.0.0.jar\"),\n             dependenciesPath.resolve(\"another/one/dependency-1.0.0.jar\"),\n             dependenciesPath.resolve(\"libraryA.jar\"),\n             dependenciesPath.resolve(\"libraryB.jar\"),\n-            dependenciesPath.resolve(\"library.jarC.jar\")),\n-        layers.dependenciesLayers.get(0).getEntries());\n-    assertSourcePathsUnordered(\n-        ImmutableList.of(\n-            testRepository.artifactPathOnDisk(\"com.test\", \"dependencyX\", \"1.0.0-SNAPSHOT\")),\n-        layers.snapshotsLayers.get(0).getEntries());\n-    assertSourcePathsUnordered(\n-        ImmutableList.of(\n+            dependenciesPath.resolve(\"library.jarC.jar\"));\n+    assertThat(layers.snapshotsLayer.getEntries())\n+        .comparingElementsUsing(SOURCE_FILE_OF)\n+        .containsExactly(\n+            testRepository.artifactPathOnDisk(\"com.test\", \"dependencyX\", \"1.0.0-SNAPSHOT\"));\n+    assertThat(layers.resourcesLayer.getEntries())\n+        .comparingElementsUsing(SOURCE_FILE_OF)\n+        .containsExactly(\n             applicationDirectory.resolve(\"output/directory\"),\n             applicationDirectory.resolve(\"output/directory/somefile\"),\n             applicationDirectory.resolve(\"output/package\"),\n             applicationDirectory.resolve(\"output/resourceA\"),\n             applicationDirectory.resolve(\"output/resourceB\"),\n-            applicationDirectory.resolve(\"output/world\")),\n-        layers.resourcesLayers.get(0).getEntries());\n-    assertSourcePathsUnordered(\n-        ImmutableList.of(\n+            applicationDirectory.resolve(\"output/world\"));\n+    assertThat(layers.classesLayer.getEntries())\n+        .comparingElementsUsing(SOURCE_FILE_OF)\n+        .containsExactly(\n             applicationDirectory.resolve(\"output/HelloWorld.class\"),\n             applicationDirectory.resolve(\"output/directory\"),\n             applicationDirectory.resolve(\"output/package\"),\n             applicationDirectory.resolve(\"output/package/some.class\"),\n-            applicationDirectory.resolve(\"output/some.class\")),\n-        layers.classesLayers.get(0).getEntries());\n+            applicationDirectory.resolve(\"output/some.class\"));\n \n-    assertModificationTime(SAMPLE_FILE_MODIFICATION_TIME, layers.dependenciesLayers);\n-    assertModificationTime(SAMPLE_FILE_MODIFICATION_TIME, layers.snapshotsLayers);\n-    assertModificationTime(SAMPLE_FILE_MODIFICATION_TIME, layers.resourcesLayers);\n-    assertModificationTime(SAMPLE_FILE_MODIFICATION_TIME, layers.classesLayers);\n-  }\n-\n-  @Test\n-  public void testCreateContainerBuilder_nonDefaultAppRoot()\n-      throws IOException, InvalidImageReferenceException, CacheDirectoryCreationException {\n-    BuildContext buildContext = setUpBuildContext(\"/my/app\", DEFAULT_CONTAINERIZING_MODE);\n-    assertNonDefaultAppRoot(buildContext);\n+    List<FileEntry> allFileEntries = new ArrayList<>();\n+    allFileEntries.addAll(layers.dependenciesLayer.getEntries());\n+    allFileEntries.addAll(layers.snapshotsLayer.getEntries());\n+    allFileEntries.addAll(layers.resourcesLayer.getEntries());\n+    allFileEntries.addAll(layers.classesLayer.getEntries());\n+    Set<Instant> modificationTimes =\n+        allFileEntries.stream().map(FileEntry::getModificationTime).collect(Collectors.toSet());\n+    assertThat(modificationTimes).containsExactly(EPOCH_PLUS_32);\n   }\n \n   @Test\n   public void testCreateContainerBuilder_packagedMode()\n       throws InvalidImageReferenceException, IOException, CacheDirectoryCreationException,\n           URISyntaxException {\n     Path jar = temporaryFolder.newFile(\"final-name.jar\").toPath();\n-    Mockito.when(mockBuild.getDirectory()).thenReturn(temporaryFolder.getRoot().toString());\n-    Mockito.when(mockBuild.getFinalName()).thenReturn(\"final-name\");\n+    when(mockBuild.getDirectory()).thenReturn(temporaryFolder.getRoot().toString());\n+    when(mockBuild.getFinalName()).thenReturn(\"final-name\");\n \n-    BuildContext buildContext = setUpBuildContext(\"/app-root\", ContainerizingMode.PACKAGED);\n-\n-    ContainerBuilderLayers layers = new ContainerBuilderLayers(buildContext);\n-    Assert.assertEquals(1, layers.dependenciesLayers.size());\n-    Assert.assertEquals(1, layers.snapshotsLayers.size());\n-    Assert.assertEquals(0, layers.resourcesLayers.size());\n-    Assert.assertEquals(0, layers.classesLayers.size());\n-    Assert.assertEquals(1, layers.extraFilesLayers.size());\n+    ContainerBuilderLayers layers =\n+        new ContainerBuilderLayers(setUpBuildContext(ContainerizingMode.PACKAGED));\n \n     Path dependenciesPath = getResource(\"maven/application/dependencies\");\n-    assertSourcePathsUnordered(\n-        Arrays.asList(\n+    assertThat(layers.dependenciesLayer).isNotNull();\n+    assertThat(layers.dependenciesLayer.getEntries())\n+        .comparingElementsUsing(SOURCE_FILE_OF)\n+        .containsExactly(\n             testRepository.artifactPathOnDisk(\"com.test\", \"dependency\", \"1.0.0\"),\n             dependenciesPath.resolve(\"more/dependency-1.0.0.jar\"),\n             dependenciesPath.resolve(\"another/one/dependency-1.0.0.jar\"),\n             dependenciesPath.resolve(\"libraryA.jar\"),\n             dependenciesPath.resolve(\"libraryB.jar\"),\n-            dependenciesPath.resolve(\"library.jarC.jar\")),\n-        layers.dependenciesLayers.get(0).getEntries());\n-    assertSourcePathsUnordered(\n-        Arrays.asList(\n-            testRepository.artifactPathOnDisk(\"com.test\", \"dependencyX\", \"1.0.0-SNAPSHOT\")),\n-        layers.snapshotsLayers.get(0).getEntries());\n-    assertSourcePathsUnordered(Arrays.asList(jar), layers.extraFilesLayers.get(0).getEntries());\n-\n-    assertExtractionPathsUnordered(\n-        Arrays.asList(\n-            \"/app-root/libs/dependency-1.0.0-200.jar\",\n-            \"/app-root/libs/dependency-1.0.0-480.jar\",\n-            \"/app-root/libs/dependency-1.0.0-770.jar\",\n-            \"/app-root/libs/library.jarC.jar\",\n-            \"/app-root/libs/libraryA.jar\",\n-            \"/app-root/libs/libraryB.jar\"),\n-        layers.dependenciesLayers.get(0).getEntries());\n-    assertExtractionPathsUnordered(\n-        Arrays.asList(\"/app-root/libs/dependencyX-1.0.0-SNAPSHOT.jar\"),\n-        layers.snapshotsLayers.get(0).getEntries());\n-    assertExtractionPathsUnordered(\n-        Arrays.asList(\"/app-root/classpath/final-name.jar\"),\n-        layers.extraFilesLayers.get(0).getEntries());\n+            dependenciesPath.resolve(\"library.jarC.jar\"));\n+    assertThat(layers.snapshotsLayer).isNotNull();\n+    assertThat(layers.snapshotsLayer.getEntries())\n+        .comparingElementsUsing(SOURCE_FILE_OF)\n+        .containsExactly(\n+            testRepository.artifactPathOnDisk(\"com.test\", \"dependencyX\", \"1.0.0-SNAPSHOT\"));\n+    assertThat(layers.extraFilesLayer).isNotNull();\n+    assertThat(layers.extraFilesLayer.getEntries())\n+        .comparingElementsUsing(SOURCE_FILE_OF)\n+        .containsExactly(jar);\n+    assertThat(layers.resourcesLayer).isNull();\n+    assertThat(layers.classesLayer).isNull();\n+\n+    assertThat(layers.dependenciesLayer.getEntries())\n+        .comparingElementsUsing(EXTRACTION_PATH_OF)\n+        .containsExactly(\n+            \"/my/app/libs/dependency-1.0.0-200.jar\",\n+            \"/my/app/libs/dependency-1.0.0-480.jar\",\n+            \"/my/app/libs/dependency-1.0.0-770.jar\",\n+            \"/my/app/libs/library.jarC.jar\",\n+            \"/my/app/libs/libraryA.jar\",\n+            \"/my/app/libs/libraryB.jar\");\n+    assertThat(layers.snapshotsLayer.getEntries())\n+        .comparingElementsUsing(EXTRACTION_PATH_OF)\n+        .containsExactly(\"/my/app/libs/dependencyX-1.0.0-SNAPSHOT.jar\");\n+    assertThat(layers.extraFilesLayer.getEntries())\n+        .comparingElementsUsing(EXTRACTION_PATH_OF)\n+        .containsExactly(\"/my/app/classpath/final-name.jar\");\n   }\n \n   @Test\n-  public void testCreateContainerBuilder_warNonDefaultAppRoot()\n+  public void testCreateContainerBuilder_war_correctSourceFilePaths()\n       throws URISyntaxException, IOException, InvalidImageReferenceException,\n           CacheDirectoryCreationException {\n     Path unzipTarget = setUpWar(getResource(\"maven/webapp/final-name\"));\n \n-    BuildContext buildContext = setUpBuildContext(\"/my/app\", DEFAULT_CONTAINERIZING_MODE);\n-    ContainerBuilderLayers layers = new ContainerBuilderLayers(buildContext);\n-    assertSourcePathsUnordered(\n-        ImmutableList.of(unzipTarget.resolve(\"WEB-INF/lib/dependency-1.0.0.jar\")),\n-        layers.dependenciesLayers.get(0).getEntries());\n-    assertSourcePathsUnordered(\n-        ImmutableList.of(unzipTarget.resolve(\"WEB-INF/lib/dependencyX-1.0.0-SNAPSHOT.jar\")),\n-        layers.snapshotsLayers.get(0).getEntries());\n-    assertSourcePathsUnordered(\n-        ImmutableList.of(\n+    ContainerBuilderLayers layers = new ContainerBuilderLayers(setUpBuildContext());\n+    assertThat(layers.dependenciesLayer.getEntries())\n+        .comparingElementsUsing(SOURCE_FILE_OF)\n+        .containsExactly(unzipTarget.resolve(\"WEB-INF/lib/dependency-1.0.0.jar\"));\n+    assertThat(layers.snapshotsLayer.getEntries())\n+        .comparingElementsUsing(SOURCE_FILE_OF)\n+        .containsExactly(unzipTarget.resolve(\"WEB-INF/lib/dependencyX-1.0.0-SNAPSHOT.jar\"));\n+    assertThat(layers.resourcesLayer.getEntries())\n+        .comparingElementsUsing(SOURCE_FILE_OF)\n+        .containsExactly(\n             unzipTarget.resolve(\"META-INF\"),\n             unzipTarget.resolve(\"META-INF/context.xml\"),\n             unzipTarget.resolve(\"Test.jsp\"),\n@@ -563,24 +502,32 @@ public void testCreateContainerBuilder_warNonDefaultAppRoot()\n             unzipTarget.resolve(\"WEB-INF/classes/package\"),\n             unzipTarget.resolve(\"WEB-INF/classes/package/test.properties\"),\n             unzipTarget.resolve(\"WEB-INF/lib\"),\n-            unzipTarget.resolve(\"WEB-INF/web.xml\")),\n-        layers.resourcesLayers.get(0).getEntries());\n-    assertSourcePathsUnordered(\n-        ImmutableList.of(\n+            unzipTarget.resolve(\"WEB-INF/web.xml\"));\n+    assertThat(layers.classesLayer.getEntries())\n+        .comparingElementsUsing(SOURCE_FILE_OF)\n+        .containsExactly(\n             unzipTarget.resolve(\"WEB-INF/classes/HelloWorld.class\"),\n             unzipTarget.resolve(\"WEB-INF/classes/empty_dir\"),\n             unzipTarget.resolve(\"WEB-INF/classes/package\"),\n-            unzipTarget.resolve(\"WEB-INF/classes/package/Other.class\")),\n-        layers.classesLayers.get(0).getEntries());\n-\n-    assertExtractionPathsUnordered(\n-        Collections.singletonList(\"/my/app/WEB-INF/lib/dependency-1.0.0.jar\"),\n-        layers.dependenciesLayers.get(0).getEntries());\n-    assertExtractionPathsUnordered(\n-        Collections.singletonList(\"/my/app/WEB-INF/lib/dependencyX-1.0.0-SNAPSHOT.jar\"),\n-        layers.snapshotsLayers.get(0).getEntries());\n-    assertExtractionPathsUnordered(\n-        Arrays.asList(\n+            unzipTarget.resolve(\"WEB-INF/classes/package/Other.class\"));\n+  }\n+\n+  @Test\n+  public void testCreateContainerBuilder_war_correctExtractionPaths()\n+      throws URISyntaxException, IOException, InvalidImageReferenceException,\n+          CacheDirectoryCreationException {\n+    setUpWar(getResource(\"maven/webapp/final-name\"));\n+\n+    ContainerBuilderLayers layers = new ContainerBuilderLayers(setUpBuildContext());\n+    assertThat(layers.dependenciesLayer.getEntries())\n+        .comparingElementsUsing(EXTRACTION_PATH_OF)\n+        .containsExactly(\"/my/app/WEB-INF/lib/dependency-1.0.0.jar\");\n+    assertThat(layers.snapshotsLayer.getEntries())\n+        .comparingElementsUsing(EXTRACTION_PATH_OF)\n+        .containsExactly(\"/my/app/WEB-INF/lib/dependencyX-1.0.0-SNAPSHOT.jar\");\n+    assertThat(layers.resourcesLayer.getEntries())\n+        .comparingElementsUsing(EXTRACTION_PATH_OF)\n+        .containsExactly(\n             \"/my/app/META-INF\",\n             \"/my/app/META-INF/context.xml\",\n             \"/my/app/Test.jsp\",\n@@ -590,74 +537,73 @@ public void testCreateContainerBuilder_warNonDefaultAppRoot()\n             \"/my/app/WEB-INF/classes/package\",\n             \"/my/app/WEB-INF/classes/package/test.properties\",\n             \"/my/app/WEB-INF/lib\",\n-            \"/my/app/WEB-INF/web.xml\"),\n-        layers.resourcesLayers.get(0).getEntries());\n-    assertExtractionPathsUnordered(\n-        Arrays.asList(\n+            \"/my/app/WEB-INF/web.xml\");\n+    assertThat(layers.classesLayer.getEntries())\n+        .comparingElementsUsing(EXTRACTION_PATH_OF)\n+        .containsExactly(\n             \"/my/app/WEB-INF/classes/HelloWorld.class\",\n             \"/my/app/WEB-INF/classes/empty_dir\",\n             \"/my/app/WEB-INF/classes/package\",\n-            \"/my/app/WEB-INF/classes/package/Other.class\"),\n-        layers.classesLayers.get(0).getEntries());\n-  }\n-\n-  @Test\n-  public void testCreateContainerBuilder_jarNonDefaultAppRoot()\n-      throws IOException, InvalidImageReferenceException, CacheDirectoryCreationException {\n-    // Test when the default packaging is set\n-    Mockito.when(mockMavenProject.getPackaging()).thenReturn(\"jar\");\n-    BuildContext buildContext = setUpBuildContext(\"/my/app\", DEFAULT_CONTAINERIZING_MODE);\n-    assertNonDefaultAppRoot(buildContext);\n+            \"/my/app/WEB-INF/classes/package/Other.class\");\n   }\n \n   @Test\n   public void testCreateContainerBuilder_noErrorIfWebInfDoesNotExist()\n-      throws IOException, InvalidImageReferenceException, CacheDirectoryCreationException {\n+      throws IOException, InvalidImageReferenceException {\n     setUpWar(temporaryFolder.newFolder(\"final-name\").toPath());\n \n-    setUpBuildContext(\"/anything\", DEFAULT_CONTAINERIZING_MODE); // should pass\n+    assertThat(\n+            mavenProjectProperties.createJibContainerBuilder(\n+                JavaContainerBuilder.from(\"ignored\"), ContainerizingMode.EXPLODED))\n+        .isNotNull();\n   }\n \n   @Test\n   public void testCreateContainerBuilder_noErrorIfWebInfLibDoesNotExist()\n-      throws IOException, InvalidImageReferenceException, CacheDirectoryCreationException {\n+      throws IOException, InvalidImageReferenceException {\n     temporaryFolder.newFolder(\"final-name\", \"WEB-INF\", \"classes\");\n     setUpWar(temporaryFolder.getRoot().toPath());\n \n-    setUpBuildContext(\"/anything\", DEFAULT_CONTAINERIZING_MODE); // should pass\n+    assertThat(\n+            mavenProjectProperties.createJibContainerBuilder(\n+                JavaContainerBuilder.from(\"ignored\"), ContainerizingMode.EXPLODED))\n+        .isNotNull();\n   }\n \n   @Test\n   public void testCreateContainerBuilder_noErrorIfWebInfClassesDoesNotExist()\n-      throws IOException, InvalidImageReferenceException, CacheDirectoryCreationException {\n+      throws IOException, InvalidImageReferenceException {\n     temporaryFolder.newFolder(\"final-name\", \"WEB-INF\", \"lib\");\n     setUpWar(temporaryFolder.getRoot().toPath());\n \n-    setUpBuildContext(\"/anything\", DEFAULT_CONTAINERIZING_MODE); // should pass\n+    assertThat(\n+            mavenProjectProperties.createJibContainerBuilder(\n+                JavaContainerBuilder.from(\"ignored\"), ContainerizingMode.EXPLODED))\n+        .isNotNull();\n   }\n \n   @Test\n   public void testIsWarProject_warPackagingIsWar() {\n-    Mockito.when(mockMavenProject.getPackaging()).thenReturn(\"war\");\n-    Assert.assertTrue(mavenProjectProperties.isWarProject());\n+    when(mockMavenProject.getPackaging()).thenReturn(\"war\");\n+    assertThat(mavenProjectProperties.isWarProject()).isTrue();\n   }\n \n   @Test\n   public void testIsWarProject_gwtAppPackagingIsWar() {\n-    Mockito.when(mockMavenProject.getPackaging()).thenReturn(\"gwt-app\");\n-    Assert.assertTrue(mavenProjectProperties.isWarProject());\n+    when(mockMavenProject.getPackaging()).thenReturn(\"gwt-app\");\n+    assertThat(mavenProjectProperties.isWarProject()).isTrue();\n   }\n \n   @Test\n   public void testIsWarProject_jarPackagingIsNotWar() {\n-    Mockito.when(mockMavenProject.getPackaging()).thenReturn(\"jar\");\n-    Assert.assertFalse(mavenProjectProperties.isWarProject());\n+    when(mockMavenProject.getPackaging()).thenReturn(\"jar\");\n+    assertThat(mavenProjectProperties.isWarProject()).isFalse();\n   }\n \n   @Test\n   public void testIsWarProject_gwtLibPackagingIsNotWar() {\n-    Mockito.when(mockMavenProject.getPackaging()).thenReturn(\"gwt-lib\");\n-    Assert.assertFalse(mavenProjectProperties.isWarProject());\n+    when(mockMavenProject.getPackaging()).thenReturn(\"gwt-lib\");\n+    assertThat(mavenProjectProperties.isWarProject()).isFalse();\n   }\n \n   @Test\n@@ -678,70 +624,66 @@ public void testClassifyDependencies() {\n             newArtifact(\"com.test\", \"projectB\", \"1.0-SNAPSHOT\"),\n             newArtifact(\"com.test\", \"projectC\", \"3.0\"));\n \n-    Map<LayerType, List<Path>> classifyDependencies =\n+    Map<LayerType, List<Path>> classified =\n         mavenProjectProperties.classifyDependencies(artifacts, projectArtifacts);\n \n-    Assert.assertEquals(\n-        classifyDependencies.get(LayerType.DEPENDENCIES),\n-        ImmutableList.of(\n+    assertThat(classified.get(LayerType.DEPENDENCIES))\n+        .containsExactly(\n             newArtifact(\"com.test\", \"dependencyA\", \"1.0\").getFile().toPath(),\n-            newArtifact(\"com.test\", \"dependencyD\", \"4.0\").getFile().toPath()));\n+            newArtifact(\"com.test\", \"dependencyD\", \"4.0\").getFile().toPath());\n \n-    Assert.assertEquals(\n-        classifyDependencies.get(LayerType.SNAPSHOT_DEPENDENCIES),\n-        ImmutableList.of(\n+    assertThat(classified.get(LayerType.SNAPSHOT_DEPENDENCIES))\n+        .containsExactly(\n             newArtifact(\"com.test\", \"dependencyB\", \"4.0-SNAPSHOT\").getFile().toPath(),\n-            newArtifact(\"com.test\", \"dependencyC\", \"1.0-SNAPSHOT\").getFile().toPath()));\n+            newArtifact(\"com.test\", \"dependencyC\", \"1.0-SNAPSHOT\").getFile().toPath());\n \n-    Assert.assertEquals(\n-        classifyDependencies.get(LayerType.PROJECT_DEPENDENCIES),\n-        ImmutableList.of(\n+    assertThat(classified.get(LayerType.PROJECT_DEPENDENCIES))\n+        .containsExactly(\n             newArtifact(\"com.test\", \"projectA\", \"1.0\").getFile().toPath(),\n             newArtifact(\"com.test\", \"projectB\", \"1.0-SNAPSHOT\").getFile().toPath(),\n-            newArtifact(\"com.test\", \"projectC\", \"3.0\").getFile().toPath()));\n+            newArtifact(\"com.test\", \"projectC\", \"3.0\").getFile().toPath());\n   }\n \n   @Test\n   public void testGetProjectDependencies() {\n-    MavenProject rootPomProject = Mockito.mock(MavenProject.class);\n-    MavenProject jibSubModule = Mockito.mock(MavenProject.class);\n-    MavenProject sharedLibSubModule = Mockito.mock(MavenProject.class);\n-    Mockito.when(mockMavenSession.getProjects())\n+    MavenProject rootPomProject = mock(MavenProject.class);\n+    MavenProject jibSubModule = mock(MavenProject.class);\n+    MavenProject sharedLibSubModule = mock(MavenProject.class);\n+    when(mockMavenSession.getProjects())\n         .thenReturn(Arrays.asList(rootPomProject, sharedLibSubModule, jibSubModule));\n \n-    Artifact nullFileArtifact = Mockito.mock(Artifact.class);\n+    Artifact nullFileArtifact = mock(Artifact.class);\n     Artifact projectJar = newArtifact(\"com.test\", \"my-app\", \"1.0\");\n     Artifact sharedLibJar = newArtifact(\"com.test\", \"shared-lib\", \"1.0\");\n \n-    Mockito.when(rootPomProject.getArtifact()).thenReturn(nullFileArtifact);\n-    Mockito.when(jibSubModule.getArtifact()).thenReturn(projectJar);\n-    Mockito.when(sharedLibSubModule.getArtifact()).thenReturn(sharedLibJar);\n+    when(rootPomProject.getArtifact()).thenReturn(nullFileArtifact);\n+    when(jibSubModule.getArtifact()).thenReturn(projectJar);\n+    when(sharedLibSubModule.getArtifact()).thenReturn(sharedLibJar);\n \n-    Mockito.when(mockMavenProject.getArtifact()).thenReturn(projectJar);\n+    when(mockMavenProject.getArtifact()).thenReturn(projectJar);\n \n-    Assert.assertEquals(\n-        ImmutableSet.of(sharedLibJar), mavenProjectProperties.getProjectDependencies());\n+    assertThat(mavenProjectProperties.getProjectDependencies()).containsExactly(sharedLibJar);\n   }\n \n   @Test\n   public void testGetChildValue_null() {\n-    Assert.assertFalse(MavenProjectProperties.getChildValue(null).isPresent());\n-    Assert.assertFalse(MavenProjectProperties.getChildValue(null, \"foo\", \"bar\").isPresent());\n+    assertThat(MavenProjectProperties.getChildValue(null)).isEmpty();\n+    assertThat(MavenProjectProperties.getChildValue(null, \"foo\", \"bar\")).isEmpty();\n   }\n \n   @Test\n   public void testGetChildValue_noPathGiven() {\n     Xpp3Dom root = newXpp3Dom(\"root\", \"value\");\n \n-    Assert.assertEquals(Optional.of(\"value\"), MavenProjectProperties.getChildValue(root));\n+    assertThat(MavenProjectProperties.getChildValue(root)).isEqualTo(Optional.of(\"value\"));\n   }\n \n   @Test\n   public void testGetChildValue_noChild() {\n     Xpp3Dom root = newXpp3Dom(\"root\", \"value\");\n \n-    Assert.assertFalse(MavenProjectProperties.getChildValue(root, \"foo\").isPresent());\n-    Assert.assertFalse(MavenProjectProperties.getChildValue(root, \"foo\", \"bar\").isPresent());\n+    assertThat(MavenProjectProperties.getChildValue(root, \"foo\")).isEmpty();\n+    assertThat(MavenProjectProperties.getChildValue(root, \"foo\", \"bar\")).isEmpty();\n   }\n \n   @Test\n@@ -750,10 +692,10 @@ public void testGetChildValue_childPathMatched() {\n     Xpp3Dom foo = addXpp3DomChild(root, \"foo\", \"foo\");\n     addXpp3DomChild(foo, \"bar\", \"bar\");\n \n-    Assert.assertEquals(Optional.of(\"foo\"), MavenProjectProperties.getChildValue(root, \"foo\"));\n-    Assert.assertEquals(\n-        Optional.of(\"bar\"), MavenProjectProperties.getChildValue(root, \"foo\", \"bar\"));\n-    Assert.assertEquals(Optional.of(\"bar\"), MavenProjectProperties.getChildValue(foo, \"bar\"));\n+    assertThat(MavenProjectProperties.getChildValue(root, \"foo\")).isEqualTo(Optional.of(\"foo\"));\n+    assertThat(MavenProjectProperties.getChildValue(root, \"foo\", \"bar\"))\n+        .isEqualTo(Optional.of(\"bar\"));\n+    assertThat(MavenProjectProperties.getChildValue(foo, \"bar\")).isEqualTo(Optional.of(\"bar\"));\n   }\n \n   @Test\n@@ -762,366 +704,356 @@ public void testGetChildValue_notFullyMatched() {\n     Xpp3Dom foo = addXpp3DomChild(root, \"foo\", \"foo\");\n \n     addXpp3DomChild(foo, \"bar\", \"bar\");\n-    Assert.assertFalse(MavenProjectProperties.getChildValue(root, \"baz\").isPresent());\n-    Assert.assertFalse(MavenProjectProperties.getChildValue(root, \"foo\", \"baz\").isPresent());\n+    assertThat(MavenProjectProperties.getChildValue(root, \"baz\")).isEmpty();\n+    assertThat(MavenProjectProperties.getChildValue(root, \"foo\", \"baz\")).isEmpty();\n   }\n \n   @Test\n   public void testGetChildValue_nullValue() {\n     Xpp3Dom root = new Xpp3Dom(\"root\");\n     addXpp3DomChild(root, \"foo\", null);\n \n-    Assert.assertFalse(MavenProjectProperties.getChildValue(root).isPresent());\n-    Assert.assertFalse(MavenProjectProperties.getChildValue(root, \"foo\").isPresent());\n+    assertThat(MavenProjectProperties.getChildValue(root)).isEmpty();\n+    assertThat(MavenProjectProperties.getChildValue(root, \"foo\")).isEmpty();\n   }\n \n   @Test\n   public void testGetSpringBootRepackageConfiguration_pluginNotApplied() {\n-    Assert.assertEquals(\n-        Optional.empty(), mavenProjectProperties.getSpringBootRepackageConfiguration());\n+    assertThat(mavenProjectProperties.getSpringBootRepackageConfiguration()).isEmpty();\n   }\n \n   @Test\n   public void testGetSpringBootRepackageConfiguration_noConfigurationBlock() {\n-    Mockito.when(mockMavenProject.getPlugin(\"org.springframework.boot:spring-boot-maven-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.springframework.boot:spring-boot-maven-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n-    Mockito.when(mockPluginExecution.getGoals()).thenReturn(Arrays.asList(\"repackage\"));\n-    Mockito.when(mockPluginExecution.getConfiguration()).thenReturn(null);\n-    Assert.assertEquals(\n-        Optional.of(new Xpp3Dom(\"configuration\")),\n-        mavenProjectProperties.getSpringBootRepackageConfiguration());\n+    when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n+    when(mockPluginExecution.getGoals()).thenReturn(Arrays.asList(\"repackage\"));\n+    when(mockPluginExecution.getConfiguration()).thenReturn(null);\n+    assertThat(mavenProjectProperties.getSpringBootRepackageConfiguration())\n+        .isEqualTo(Optional.of(new Xpp3Dom(\"configuration\")));\n   }\n \n   @Test\n   public void testGetSpringBootRepackageConfiguration_noExecutions() {\n-    Mockito.when(mockMavenProject.getPlugin(\"org.springframework.boot:spring-boot-maven-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.springframework.boot:spring-boot-maven-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getExecutions()).thenReturn(Collections.emptyList());\n-    Assert.assertEquals(\n-        Optional.empty(), mavenProjectProperties.getSpringBootRepackageConfiguration());\n+    when(mockPlugin.getExecutions()).thenReturn(Collections.emptyList());\n+    assertThat(mavenProjectProperties.getSpringBootRepackageConfiguration()).isEmpty();\n   }\n \n   @Test\n   public void testGetSpringBootRepackageConfiguration_noRepackageGoal() {\n-    Mockito.when(mockMavenProject.getPlugin(\"org.springframework.boot:spring-boot-maven-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.springframework.boot:spring-boot-maven-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n-    Mockito.when(mockPluginExecution.getGoals()).thenReturn(Arrays.asList(\"goal\", \"foo\", \"bar\"));\n-    Assert.assertEquals(\n-        Optional.empty(), mavenProjectProperties.getSpringBootRepackageConfiguration());\n+    when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n+    when(mockPluginExecution.getGoals()).thenReturn(Arrays.asList(\"goal\", \"foo\", \"bar\"));\n+    assertThat(mavenProjectProperties.getSpringBootRepackageConfiguration()).isEmpty();\n   }\n \n   @Test\n   public void testGetSpringBootRepackageConfiguration_repackageGoal() {\n-    Mockito.when(mockMavenProject.getPlugin(\"org.springframework.boot:spring-boot-maven-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.springframework.boot:spring-boot-maven-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n-    Mockito.when(mockPluginExecution.getGoals()).thenReturn(Arrays.asList(\"goal\", \"repackage\"));\n-    Mockito.when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n-    Assert.assertEquals(\n-        Optional.of(pluginConfiguration),\n-        mavenProjectProperties.getSpringBootRepackageConfiguration());\n+    when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n+    when(mockPluginExecution.getGoals()).thenReturn(Arrays.asList(\"goal\", \"repackage\"));\n+    when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n+    assertThat(mavenProjectProperties.getSpringBootRepackageConfiguration())\n+        .isEqualTo(Optional.of(pluginConfiguration));\n   }\n \n   @Test\n   public void testGetSpringBootRepackageConfiguration_skipped() {\n-    Mockito.when(mockMavenProject.getPlugin(\"org.springframework.boot:spring-boot-maven-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.springframework.boot:spring-boot-maven-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n-    Mockito.when(mockPluginExecution.getGoals()).thenReturn(Arrays.asList(\"repackage\"));\n-    Mockito.when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n+    when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n+    when(mockPluginExecution.getGoals()).thenReturn(Arrays.asList(\"repackage\"));\n+    when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n     addXpp3DomChild(pluginConfiguration, \"skip\", \"true\");\n-    Assert.assertEquals(\n-        Optional.empty(), mavenProjectProperties.getSpringBootRepackageConfiguration());\n+    assertThat(mavenProjectProperties.getSpringBootRepackageConfiguration()).isEmpty();\n   }\n \n   @Test\n   public void testGetSpringBootRepackageConfiguration_skipNotTrue() {\n-    Mockito.when(mockMavenProject.getPlugin(\"org.springframework.boot:spring-boot-maven-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.springframework.boot:spring-boot-maven-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n-    Mockito.when(mockPluginExecution.getGoals()).thenReturn(Arrays.asList(\"repackage\"));\n-    Mockito.when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n+    when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n+    when(mockPluginExecution.getGoals()).thenReturn(Arrays.asList(\"repackage\"));\n+    when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n     addXpp3DomChild(pluginConfiguration, \"skip\", null);\n-    Assert.assertEquals(\n-        Optional.of(pluginConfiguration),\n-        mavenProjectProperties.getSpringBootRepackageConfiguration());\n+    assertThat(mavenProjectProperties.getSpringBootRepackageConfiguration())\n+        .isEqualTo(Optional.of(pluginConfiguration));\n   }\n \n   @Test\n   public void testGetJarArtifact() throws IOException {\n-    Mockito.when(mockBuild.getDirectory()).thenReturn(Paths.get(\"/foo/bar\").toString());\n-    Mockito.when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n+    when(mockBuild.getDirectory()).thenReturn(Paths.get(\"/foo/bar\").toString());\n+    when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n \n-    Assert.assertEquals(\n-        Paths.get(\"/foo/bar/helloworld-1.jar\"), mavenProjectProperties.getJarArtifact());\n+    assertThat(mavenProjectProperties.getJarArtifact())\n+        .isEqualTo(Paths.get(\"/foo/bar/helloworld-1.jar\"));\n   }\n \n   @Test\n   public void testGetJarArtifact_outputDirectoryFromJarPlugin() throws IOException {\n-    Mockito.when(mockMavenProject.getBasedir()).thenReturn(new File(\"/should/ignore\"));\n-    Mockito.when(mockBuild.getDirectory()).thenReturn(\"/should/ignore\");\n-    Mockito.when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n+    when(mockMavenProject.getBasedir()).thenReturn(new File(\"/should/ignore\"));\n+    when(mockBuild.getDirectory()).thenReturn(\"/should/ignore\");\n+    when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n \n-    Mockito.when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n-    Mockito.when(mockPluginExecution.getId()).thenReturn(\"default-jar\");\n-    Mockito.when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n+    when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n+    when(mockPluginExecution.getId()).thenReturn(\"default-jar\");\n+    when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n     addXpp3DomChild(pluginConfiguration, \"outputDirectory\", Paths.get(\"/jar/out\").toString());\n \n-    Assert.assertEquals(\n-        Paths.get(\"/jar/out/helloworld-1.jar\"), mavenProjectProperties.getJarArtifact());\n+    assertThat(mavenProjectProperties.getJarArtifact())\n+        .isEqualTo(Paths.get(\"/jar/out/helloworld-1.jar\"));\n   }\n \n   @Test\n   public void testGetJarArtifact_relativeOutputDirectoryFromJarPlugin() throws IOException {\n-    Mockito.when(mockMavenProject.getBasedir()).thenReturn(new File(\"/base/dir\"));\n-    Mockito.when(mockBuild.getDirectory()).thenReturn(temporaryFolder.getRoot().toString());\n-    Mockito.when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n+    when(mockMavenProject.getBasedir()).thenReturn(new File(\"/base/dir\"));\n+    when(mockBuild.getDirectory()).thenReturn(temporaryFolder.getRoot().toString());\n+    when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n \n-    Mockito.when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n-    Mockito.when(mockPluginExecution.getId()).thenReturn(\"default-jar\");\n-    Mockito.when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n+    when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n+    when(mockPluginExecution.getId()).thenReturn(\"default-jar\");\n+    when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n     addXpp3DomChild(pluginConfiguration, \"outputDirectory\", Paths.get(\"relative\").toString());\n \n-    Assert.assertEquals(\n-        Paths.get(\"/base/dir/relative/helloworld-1.jar\"), mavenProjectProperties.getJarArtifact());\n+    assertThat(mavenProjectProperties.getJarArtifact())\n+        .isEqualTo(Paths.get(\"/base/dir/relative/helloworld-1.jar\"));\n   }\n \n   @Test\n   public void testGetJarArtifact_classifier() throws IOException {\n-    Mockito.when(mockBuild.getDirectory()).thenReturn(Paths.get(\"/foo/bar\").toString());\n-    Mockito.when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n+    when(mockBuild.getDirectory()).thenReturn(Paths.get(\"/foo/bar\").toString());\n+    when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n \n-    Mockito.when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n-    Mockito.when(mockPluginExecution.getId()).thenReturn(\"default-jar\");\n-    Mockito.when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n+    when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n+    when(mockPluginExecution.getId()).thenReturn(\"default-jar\");\n+    when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n     addXpp3DomChild(pluginConfiguration, \"classifier\", \"a-class\");\n \n-    Assert.assertEquals(\n-        Paths.get(\"/foo/bar/helloworld-1-a-class.jar\"), mavenProjectProperties.getJarArtifact());\n+    assertThat(mavenProjectProperties.getJarArtifact())\n+        .isEqualTo(Paths.get(\"/foo/bar/helloworld-1-a-class.jar\"));\n   }\n \n   @Test\n   public void testGetJarArtifact_executionIdNotMatched() throws IOException {\n-    Mockito.when(mockBuild.getDirectory()).thenReturn(Paths.get(\"/foo/bar\").toString());\n-    Mockito.when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n+    when(mockBuild.getDirectory()).thenReturn(Paths.get(\"/foo/bar\").toString());\n+    when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n \n-    Mockito.when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n-    Mockito.when(mockPluginExecution.getId()).thenReturn(\"no-id-match\");\n+    when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n+    when(mockPluginExecution.getId()).thenReturn(\"no-id-match\");\n     Mockito.lenient().when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n     addXpp3DomChild(pluginConfiguration, \"outputDirectory\", \"/should/ignore\");\n     addXpp3DomChild(pluginConfiguration, \"classifier\", \"a-class\");\n \n-    Assert.assertEquals(\n-        Paths.get(\"/foo/bar/helloworld-1.jar\"), mavenProjectProperties.getJarArtifact());\n+    assertThat(mavenProjectProperties.getJarArtifact())\n+        .isEqualTo(Paths.get(\"/foo/bar/helloworld-1.jar\"));\n   }\n \n   @Test\n   public void testGetJarArtifact_originalJarCopiedIfSpringBoot() throws IOException {\n     temporaryFolder.newFile(\"helloworld-1.jar.original\");\n-    Mockito.when(mockBuild.getDirectory()).thenReturn(temporaryFolder.getRoot().toString());\n-    Mockito.when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n+    when(mockBuild.getDirectory()).thenReturn(temporaryFolder.getRoot().toString());\n+    when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n \n     setUpSpringBootFatJar();\n     Path tempDirectory = temporaryFolder.newFolder(\"tmp\").toPath();\n-    Mockito.when(mockTempDirectoryProvider.newDirectory()).thenReturn(tempDirectory);\n+    when(mockTempDirectoryProvider.newDirectory()).thenReturn(tempDirectory);\n \n-    Assert.assertEquals(\n-        tempDirectory.resolve(\"helloworld-1.original.jar\"),\n-        mavenProjectProperties.getJarArtifact());\n+    assertThat(mavenProjectProperties.getJarArtifact())\n+        .isEqualTo(tempDirectory.resolve(\"helloworld-1.original.jar\"));\n \n     mavenProjectProperties.waitForLoggingThread();\n-    Mockito.verify(mockLog)\n-        .info(\"Spring Boot repackaging (fat JAR) detected; using the original JAR\");\n+    verify(mockLog).info(\"Spring Boot repackaging (fat JAR) detected; using the original JAR\");\n   }\n \n   @Test\n   public void testGetJarArtifact_originalJarIfSpringBoot_differentDirectories() throws IOException {\n-    Mockito.when(mockMavenProject.getBasedir()).thenReturn(new File(\"/should/ignore\"));\n-    Mockito.when(mockBuild.getDirectory()).thenReturn(\"/should/ignore\");\n-    Mockito.when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n+    when(mockMavenProject.getBasedir()).thenReturn(new File(\"/should/ignore\"));\n+    when(mockBuild.getDirectory()).thenReturn(\"/should/ignore\");\n+    when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n \n-    Mockito.when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n-    Mockito.when(mockPluginExecution.getId()).thenReturn(\"default-jar\");\n-    Mockito.when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n+    when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n+    when(mockPluginExecution.getId()).thenReturn(\"default-jar\");\n+    when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n     addXpp3DomChild(pluginConfiguration, \"outputDirectory\", Paths.get(\"/jar/out\").toString());\n \n     setUpSpringBootFatJar();\n \n-    Assert.assertEquals(\n-        Paths.get(\"/jar/out/helloworld-1.jar\"), mavenProjectProperties.getJarArtifact());\n+    assertThat(mavenProjectProperties.getJarArtifact())\n+        .isEqualTo(Paths.get(\"/jar/out/helloworld-1.jar\"));\n \n     mavenProjectProperties.waitForLoggingThread();\n-    Mockito.verify(mockLog)\n-        .info(\"Spring Boot repackaging (fat JAR) detected; using the original JAR\");\n+    verify(mockLog).info(\"Spring Boot repackaging (fat JAR) detected; using the original JAR\");\n   }\n \n   @Test\n   public void testGetJarArtifact_originalJarIfSpringBoot_differentFinalNames() throws IOException {\n     Path buildDirectory = temporaryFolder.newFolder(\"target\").toPath();\n     Files.createFile(buildDirectory.resolve(\"helloworld-1.jar\"));\n-    Mockito.when(mockMavenProject.getBasedir()).thenReturn(temporaryFolder.getRoot());\n-    Mockito.when(mockBuild.getDirectory()).thenReturn(buildDirectory.toString());\n-    Mockito.when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n+    when(mockMavenProject.getBasedir()).thenReturn(temporaryFolder.getRoot());\n+    when(mockBuild.getDirectory()).thenReturn(buildDirectory.toString());\n+    when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n \n-    Mockito.when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n-    Mockito.when(mockPluginExecution.getId()).thenReturn(\"default-jar\");\n-    Mockito.when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n+    when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n+    when(mockPluginExecution.getId()).thenReturn(\"default-jar\");\n+    when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n     addXpp3DomChild(pluginConfiguration, \"outputDirectory\", \"target\");\n \n     Xpp3Dom bootPluginConfiguration = setUpSpringBootFatJar();\n     addXpp3DomChild(bootPluginConfiguration, \"finalName\", \"boot-helloworld-1\");\n \n-    Assert.assertEquals(\n-        buildDirectory.resolve(\"helloworld-1.jar\"), mavenProjectProperties.getJarArtifact());\n+    assertThat(mavenProjectProperties.getJarArtifact())\n+        .isEqualTo(buildDirectory.resolve(\"helloworld-1.jar\"));\n \n     mavenProjectProperties.waitForLoggingThread();\n-    Mockito.verify(mockLog)\n-        .info(\"Spring Boot repackaging (fat JAR) detected; using the original JAR\");\n+    verify(mockLog).info(\"Spring Boot repackaging (fat JAR) detected; using the original JAR\");\n   }\n \n   @Test\n   public void testGetJarArtifact_originalJarIfSpringBoot_differentClassifier() throws IOException {\n     Path buildDirectory = temporaryFolder.newFolder(\"target\").toPath();\n     Files.createFile(buildDirectory.resolve(\"helloworld-1.jar\"));\n-    Mockito.when(mockMavenProject.getBasedir()).thenReturn(temporaryFolder.getRoot());\n-    Mockito.when(mockBuild.getDirectory()).thenReturn(buildDirectory.toString());\n-    Mockito.when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n+    when(mockMavenProject.getBasedir()).thenReturn(temporaryFolder.getRoot());\n+    when(mockBuild.getDirectory()).thenReturn(buildDirectory.toString());\n+    when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n \n-    Mockito.when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n-    Mockito.when(mockPluginExecution.getId()).thenReturn(\"default-jar\");\n-    Mockito.when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n+    when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n+    when(mockPluginExecution.getId()).thenReturn(\"default-jar\");\n+    when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n     addXpp3DomChild(pluginConfiguration, \"outputDirectory\", \"target\");\n \n     Xpp3Dom bootPluginConfiguration = setUpSpringBootFatJar();\n     addXpp3DomChild(bootPluginConfiguration, \"classifier\", \"boot-class\");\n \n-    Assert.assertEquals(\n-        buildDirectory.resolve(\"helloworld-1.jar\"), mavenProjectProperties.getJarArtifact());\n+    assertThat(mavenProjectProperties.getJarArtifact())\n+        .isEqualTo(buildDirectory.resolve(\"helloworld-1.jar\"));\n \n     mavenProjectProperties.waitForLoggingThread();\n-    Mockito.verify(mockLog)\n-        .info(\"Spring Boot repackaging (fat JAR) detected; using the original JAR\");\n+    verify(mockLog).info(\"Spring Boot repackaging (fat JAR) detected; using the original JAR\");\n   }\n \n   @Test\n   public void testGetJarArtifact_originalJarCopiedIfSpringBoot_sameDirectory() throws IOException {\n     Path buildDirectory = temporaryFolder.newFolder(\"target\").toPath();\n     Files.createFile(buildDirectory.resolve(\"helloworld-1.jar.original\"));\n-    Mockito.when(mockMavenProject.getBasedir()).thenReturn(temporaryFolder.getRoot());\n-    Mockito.when(mockBuild.getDirectory()).thenReturn(buildDirectory.toString());\n-    Mockito.when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n+    when(mockMavenProject.getBasedir()).thenReturn(temporaryFolder.getRoot());\n+    when(mockBuild.getDirectory()).thenReturn(buildDirectory.toString());\n+    when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n \n-    Mockito.when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-jar-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n-    Mockito.when(mockPluginExecution.getId()).thenReturn(\"default-jar\");\n-    Mockito.when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n+    when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n+    when(mockPluginExecution.getId()).thenReturn(\"default-jar\");\n+    when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n     addXpp3DomChild(pluginConfiguration, \"outputDirectory\", \"target\");\n \n     setUpSpringBootFatJar();\n     Path tempDirectory = temporaryFolder.newFolder(\"tmp\").toPath();\n-    Mockito.when(mockTempDirectoryProvider.newDirectory()).thenReturn(tempDirectory);\n+    when(mockTempDirectoryProvider.newDirectory()).thenReturn(tempDirectory);\n \n-    Assert.assertEquals(\n-        tempDirectory.resolve(\"helloworld-1.original.jar\"),\n-        mavenProjectProperties.getJarArtifact());\n+    assertThat(mavenProjectProperties.getJarArtifact())\n+        .isEqualTo(tempDirectory.resolve(\"helloworld-1.original.jar\"));\n \n     mavenProjectProperties.waitForLoggingThread();\n-    Mockito.verify(mockLog)\n-        .info(\"Spring Boot repackaging (fat JAR) detected; using the original JAR\");\n+    verify(mockLog).info(\"Spring Boot repackaging (fat JAR) detected; using the original JAR\");\n   }\n \n   @Test\n   public void testGetWarArtifact() {\n-    Mockito.when(mockBuild.getDirectory()).thenReturn(Paths.get(\"/foo/bar\").toString());\n-    Mockito.when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n+    when(mockBuild.getDirectory()).thenReturn(Paths.get(\"/foo/bar\").toString());\n+    when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n \n-    Assert.assertEquals(\n-        Paths.get(\"/foo/bar/helloworld-1.war\"), mavenProjectProperties.getWarArtifact());\n+    assertThat(mavenProjectProperties.getWarArtifact())\n+        .isEqualTo(Paths.get(\"/foo/bar/helloworld-1.war\"));\n   }\n \n   @Test\n   public void testGetWarArtifact_warNameProperty() {\n-    Mockito.when(mockBuild.getDirectory()).thenReturn(Paths.get(\"/foo/bar\").toString());\n-    Mockito.when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n+    when(mockBuild.getDirectory()).thenReturn(Paths.get(\"/foo/bar\").toString());\n+    when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n \n-    Mockito.when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-war-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-war-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n-    Mockito.when(mockPluginExecution.getId()).thenReturn(\"default-war\");\n-    Mockito.when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n+    when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n+    when(mockPluginExecution.getId()).thenReturn(\"default-war\");\n+    when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n     addXpp3DomChild(pluginConfiguration, \"warName\", \"baz\");\n \n-    Assert.assertEquals(Paths.get(\"/foo/bar/baz.war\"), mavenProjectProperties.getWarArtifact());\n+    assertThat(mavenProjectProperties.getWarArtifact()).isEqualTo(Paths.get(\"/foo/bar/baz.war\"));\n   }\n \n   @Test\n   public void testGetWarArtifact_noWarNameProperty() {\n-    Mockito.when(mockBuild.getDirectory()).thenReturn(Paths.get(\"/foo/bar\").toString());\n-    Mockito.when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n+    when(mockBuild.getDirectory()).thenReturn(Paths.get(\"/foo/bar\").toString());\n+    when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n \n-    Mockito.when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-war-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-war-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n-    Mockito.when(mockPluginExecution.getId()).thenReturn(\"default-war\");\n+    when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n+    when(mockPluginExecution.getId()).thenReturn(\"default-war\");\n     Mockito.lenient().when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n \n-    Assert.assertEquals(\n-        Paths.get(\"/foo/bar/helloworld-1.war\"), mavenProjectProperties.getWarArtifact());\n+    assertThat(mavenProjectProperties.getWarArtifact())\n+        .isEqualTo(Paths.get(\"/foo/bar/helloworld-1.war\"));\n   }\n \n   @Test\n   public void testGetWarArtifact_executionIdNotMatched() {\n-    Mockito.when(mockBuild.getDirectory()).thenReturn(Paths.get(\"/foo/bar\").toString());\n-    Mockito.when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n+    when(mockBuild.getDirectory()).thenReturn(Paths.get(\"/foo/bar\").toString());\n+    when(mockBuild.getFinalName()).thenReturn(\"helloworld-1\");\n \n-    Mockito.when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-war-plugin\"))\n+    when(mockMavenProject.getPlugin(\"org.apache.maven.plugins:maven-war-plugin\"))\n         .thenReturn(mockPlugin);\n-    Mockito.when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n-    Mockito.when(mockPluginExecution.getId()).thenReturn(\"no-id-match\");\n+    when(mockPlugin.getExecutions()).thenReturn(Arrays.asList(mockPluginExecution));\n+    when(mockPluginExecution.getId()).thenReturn(\"no-id-match\");\n     Mockito.lenient().when(mockPluginExecution.getConfiguration()).thenReturn(pluginConfiguration);\n     addXpp3DomChild(pluginConfiguration, \"warName\", \"baz\");\n \n-    Assert.assertEquals(\n-        Paths.get(\"/foo/bar/helloworld-1.war\"), mavenProjectProperties.getWarArtifact());\n+    assertThat(mavenProjectProperties.getWarArtifact())\n+        .isEqualTo(Paths.get(\"/foo/bar/helloworld-1.war\"));\n   }\n \n   @Test\n   public void testGetDependencies() throws URISyntaxException {\n-    Assert.assertEquals(\n-        Arrays.asList(\n+    assertThat(mavenProjectProperties.getDependencies())\n+        .containsExactly(\n             getResource(\"maven/application/dependencies/library.jarC.jar\"),\n             getResource(\"maven/application/dependencies/libraryB.jar\"),\n             getResource(\"maven/application/dependencies/libraryA.jar\"),\n             getResource(\"maven/application/dependencies/more/dependency-1.0.0.jar\"),\n             getResource(\"maven/application/dependencies/another/one/dependency-1.0.0.jar\"),\n             testRepository.artifactPathOnDisk(\"com.test\", \"dependency\", \"1.0.0\"),\n-            testRepository.artifactPathOnDisk(\"com.test\", \"dependencyX\", \"1.0.0-SNAPSHOT\")),\n-        mavenProjectProperties.getDependencies());\n+            testRepository.artifactPathOnDisk(\"com.test\", \"dependencyX\", \"1.0.0-SNAPSHOT\"));\n+  }\n+\n+  private BuildContext setUpBuildContext()\n+      throws InvalidImageReferenceException, IOException, CacheDirectoryCreationException {\n+    return setUpBuildContext(ContainerizingMode.EXPLODED);\n   }\n \n-  private BuildContext setUpBuildContext(String appRoot, ContainerizingMode containerizingMode)\n+  private BuildContext setUpBuildContext(ContainerizingMode containerizingMode)\n       throws InvalidImageReferenceException, IOException, CacheDirectoryCreationException {\n     JavaContainerBuilder javaContainerBuilder =\n         JavaContainerBuilder.from(RegistryImage.named(\"base\"))\n-            .setAppRoot(AbsoluteUnixPath.get(appRoot))\n-            .setModificationTimeProvider((ignored1, ignored2) -> SAMPLE_FILE_MODIFICATION_TIME);\n+            .setAppRoot(AbsoluteUnixPath.get(\"/my/app\"))\n+            .setModificationTimeProvider((ignored1, ignored2) -> EPOCH_PLUS_32);\n     JibContainerBuilder jibContainerBuilder =\n         mavenProjectProperties.createJibContainerBuilder(javaContainerBuilder, containerizingMode);\n     return JibContainerBuilderTestHelper.toBuildContext(\n@@ -1130,27 +1062,27 @@ private BuildContext setUpBuildContext(String appRoot, ContainerizingMode contai\n \n   private Path setUpWar(Path explodedWar) throws IOException {\n     Path fakeMavenBuildDirectory = temporaryFolder.getRoot().toPath();\n-    Mockito.when(mockBuild.getDirectory()).thenReturn(fakeMavenBuildDirectory.toString());\n-    Mockito.when(mockBuild.getFinalName()).thenReturn(\"final-name\");\n-    Mockito.when(mockMavenProject.getPackaging()).thenReturn(\"war\");\n+    when(mockBuild.getDirectory()).thenReturn(fakeMavenBuildDirectory.toString());\n+    when(mockBuild.getFinalName()).thenReturn(\"final-name\");\n+    when(mockMavenProject.getPackaging()).thenReturn(\"war\");\n \n     zipUpDirectory(explodedWar, fakeMavenBuildDirectory.resolve(\"final-name.war\"));\n \n     // Make \"MavenProjectProperties\" use this folder to explode the WAR into.\n     Path unzipTarget = temporaryFolder.newFolder(\"exploded\").toPath();\n-    Mockito.when(mockTempDirectoryProvider.newDirectory()).thenReturn(unzipTarget);\n+    when(mockTempDirectoryProvider.newDirectory()).thenReturn(unzipTarget);\n     return unzipTarget;\n   }\n \n   private Xpp3Dom setUpSpringBootFatJar() {\n     Xpp3Dom pluginConfiguration = new Xpp3Dom(\"configuration\");\n-    PluginExecution execution = Mockito.mock(PluginExecution.class);\n-    Plugin plugin = Mockito.mock(Plugin.class);\n-    Mockito.when(mockMavenProject.getPlugin(\"org.springframework.boot:spring-boot-maven-plugin\"))\n+    PluginExecution execution = mock(PluginExecution.class);\n+    Plugin plugin = mock(Plugin.class);\n+    when(mockMavenProject.getPlugin(\"org.springframework.boot:spring-boot-maven-plugin\"))\n         .thenReturn(plugin);\n-    Mockito.when(plugin.getExecutions()).thenReturn(Arrays.asList(execution));\n-    Mockito.when(execution.getGoals()).thenReturn(Arrays.asList(\"repackage\"));\n-    Mockito.when(execution.getConfiguration()).thenReturn(pluginConfiguration);\n+    when(plugin.getExecutions()).thenReturn(Arrays.asList(execution));\n+    when(execution.getGoals()).thenReturn(Arrays.asList(\"repackage\"));\n+    when(execution.getConfiguration()).thenReturn(pluginConfiguration);\n     return pluginConfiguration;\n   }\n }",
      "parent_sha": "acd23345899e93ab0785bc2cfab79e81ba9f7039"
    }
  },
  {
    "oid": "c5a6a1f0a92ad8a727f6a40982a450bcd1055b5a",
    "message": "fix output matches for integration test (#2248)",
    "date": "2020-01-26T18:50:34Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/c5a6a1f0a92ad8a727f6a40982a450bcd1055b5a",
    "details": {
      "sha": "7cb04f3ece950adba0378f1949fa65ac8be74760",
      "filename": "jib-gradle-plugin/src/integration-test/java/com/google/cloud/tools/jib/gradle/SingleProjectIntegrationTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/c5a6a1f0a92ad8a727f6a40982a450bcd1055b5a/jib-gradle-plugin%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FSingleProjectIntegrationTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/c5a6a1f0a92ad8a727f6a40982a450bcd1055b5a/jib-gradle-plugin%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FSingleProjectIntegrationTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-gradle-plugin%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FSingleProjectIntegrationTest.java?ref=c5a6a1f0a92ad8a727f6a40982a450bcd1055b5a",
      "patch": "@@ -275,7 +275,7 @@ public void testDockerDaemon_simpleOnJava11()\n \n     String targetImage = \"localhost:6000/simpleimage:gradle\" + System.nanoTime();\n     Assert.assertEquals(\n-        \"Hello, world. \\n\",\n+        \"Hello, world. \\n1970-01-01T00:00:01Z\\n\",\n         JibRunHelper.buildToDockerDaemonAndRun(\n             simpleTestProject, targetImage, \"build-java11.gradle\"));\n   }",
      "parent_sha": "d3615a6df6f0f7e2654466128e685ea7ee73958a"
    }
  },
  {
    "oid": "d895e783a1ed315faa544554f12ceb40ca912071",
    "message": "Close JarFile after instantiating (#2854)",
    "date": "2020-10-22T17:13:57Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/d895e783a1ed315faa544554f12ceb40ca912071",
    "details": {
      "sha": "3cae7874993e20bfc8d441f147feb9a44c0fcff5",
      "filename": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/jar/JarProcessor.java",
      "status": "modified",
      "additions": 9,
      "deletions": 7,
      "changes": 16,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/d895e783a1ed315faa544554f12ceb40ca912071/jib-cli%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2Fjar%2FJarProcessor.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/d895e783a1ed315faa544554f12ceb40ca912071/jib-cli%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2Fjar%2FJarProcessor.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-cli%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2Fjar%2FJarProcessor.java?ref=d895e783a1ed315faa544554f12ceb40ca912071",
      "patch": "@@ -59,11 +59,12 @@ public enum JarType {\n    * @throws IOException if I/O error occurs when opening the file\n    */\n   public static JarType determineJarType(Path jarPath) throws IOException {\n-    JarFile jarFile = new JarFile(jarPath.toFile());\n-    if (jarFile.getEntry(\"BOOT-INF\") != null) {\n-      return JarType.SPRING_BOOT;\n+    try (JarFile jarFile = new JarFile(jarPath.toFile())) {\n+      if (jarFile.getEntry(\"BOOT-INF\") != null) {\n+        return JarType.SPRING_BOOT;\n+      }\n+      return JarType.STANDARD;\n     }\n-    return JarType.STANDARD;\n   }\n \n   /**\n@@ -84,9 +85,10 @@ public static List<FileEntriesLayer> explodeStandardJar(Path jarPath, Path tempD\n     // Get dependencies from Class-Path in the jar's manifest and add a layer with these\n     // dependencies as entries. If Class-Path is not present in the jar's manifest then skip adding\n     // a dependencies layer.\n-    JarFile jarFile = new JarFile(jarPath.toFile());\n-    String classPath =\n-        jarFile.getManifest().getMainAttributes().getValue(Attributes.Name.CLASS_PATH);\n+    String classPath = null;\n+    try (JarFile jarFile = new JarFile(jarPath.toFile())) {\n+      classPath = jarFile.getManifest().getMainAttributes().getValue(Attributes.Name.CLASS_PATH);\n+    }\n     if (classPath != null) {\n       List<Path> dependencies =\n           Splitter.onPattern(\"\\\\s+\")",
      "parent_sha": "ed815c3db094b539bbf902035143bd17fe95d86f"
    }
  },
  {
    "oid": "bca456dcba97a8ff8ba5348fa6ac5381a117a8c3",
    "message": "Make sure items aren't null in BuildConfiguration.Builder collections (#470)",
    "date": "2018-06-29T15:08:25Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/bca456dcba97a8ff8ba5348fa6ac5381a117a8c3",
    "details": {
      "sha": "6e279f5e235b7e40a61494a33d0a9e487a8c3bd6",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/BuildConfiguration.java",
      "status": "modified",
      "additions": 18,
      "deletions": 13,
      "changes": 31,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/bca456dcba97a8ff8ba5348fa6ac5381a117a8c3/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2FBuildConfiguration.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/bca456dcba97a8ff8ba5348fa6ac5381a117a8c3/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2FBuildConfiguration.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2FBuildConfiguration.java?ref=bca456dcba97a8ff8ba5348fa6ac5381a117a8c3",
      "patch": "@@ -21,11 +21,11 @@\n import com.google.cloud.tools.jib.image.json.BuildableManifestTemplate;\n import com.google.cloud.tools.jib.image.json.V22ManifestTemplate;\n import com.google.cloud.tools.jib.registry.credentials.RegistryCredentials;\n+import com.google.common.base.Preconditions;\n import com.google.common.base.Splitter;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import javax.annotation.Nullable;\n@@ -44,10 +44,10 @@ public static class Builder {\n     @Nullable private String targetImageCredentialHelperName;\n     @Nullable private RegistryCredentials knownTargetRegistryCredentials;\n     @Nullable private String mainClass;\n-    private List<String> javaArguments = new ArrayList<>();\n-    private List<String> jvmFlags = new ArrayList<>();\n-    private Map<String, String> environmentMap = new HashMap<>();\n-    private List<String> exposedPorts = new ArrayList<>();\n+    private ImmutableList<String> javaArguments = ImmutableList.of();\n+    private ImmutableList<String> jvmFlags = ImmutableList.of();\n+    private ImmutableMap<String, String> environmentMap = ImmutableMap.of();\n+    private ImmutableList<String> exposedPorts = ImmutableList.of();\n     private Class<? extends BuildableManifestTemplate> targetFormat = V22ManifestTemplate.class;\n     @Nullable private CacheConfiguration applicationLayersCacheConfiguration;\n     @Nullable private CacheConfiguration baseImageLayersCacheConfiguration;\n@@ -98,28 +98,33 @@ public Builder setMainClass(@Nullable String mainClass) {\n \n     public Builder setJavaArguments(@Nullable List<String> javaArguments) {\n       if (javaArguments != null) {\n-        this.javaArguments = javaArguments;\n+        Preconditions.checkArgument(!javaArguments.contains(null));\n+        this.javaArguments = ImmutableList.copyOf(javaArguments);\n       }\n       return this;\n     }\n \n     public Builder setJvmFlags(@Nullable List<String> jvmFlags) {\n       if (jvmFlags != null) {\n-        this.jvmFlags = jvmFlags;\n+        Preconditions.checkArgument(!jvmFlags.contains(null));\n+        this.jvmFlags = ImmutableList.copyOf(jvmFlags);\n       }\n       return this;\n     }\n \n     public Builder setEnvironment(@Nullable Map<String, String> environmentMap) {\n       if (environmentMap != null) {\n-        this.environmentMap = environmentMap;\n+        Preconditions.checkArgument(\n+            !environmentMap.containsKey(null) && !environmentMap.containsValue(null));\n+        this.environmentMap = ImmutableMap.copyOf(environmentMap);\n       }\n       return this;\n     }\n \n     public Builder setExposedPorts(@Nullable List<String> exposedPorts) {\n       if (exposedPorts != null) {\n-        this.exposedPorts = exposedPorts;\n+        Preconditions.checkArgument(!exposedPorts.contains(null));\n+        this.exposedPorts = ImmutableList.copyOf(exposedPorts);\n       }\n       return this;\n     }\n@@ -198,10 +203,10 @@ public BuildConfiguration build() {\n               targetImageCredentialHelperName,\n               knownTargetRegistryCredentials,\n               mainClass,\n-              ImmutableList.copyOf(javaArguments),\n-              ImmutableList.copyOf(jvmFlags),\n-              ImmutableMap.copyOf(environmentMap),\n-              ImmutableList.copyOf(exposedPorts),\n+              javaArguments,\n+              jvmFlags,\n+              environmentMap,\n+              exposedPorts,\n               targetFormat,\n               applicationLayersCacheConfiguration,\n               baseImageLayersCacheConfiguration,",
      "parent_sha": "072ee24928cee6c476eaa1359c0de6b19e96f752"
    }
  },
  {
    "oid": "52075147a4f8ee65388a318ce0eb50057a89528b",
    "message": "Use --password-stdin for docker login in integration tests instead of -p (#914)",
    "date": "2018-08-31T16:33:01Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/52075147a4f8ee65388a318ce0eb50057a89528b",
    "details": {
      "sha": "d2e867bc0cbf35e62b5e20903b746ac40582c191",
      "filename": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/registry/LocalRegistry.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/52075147a4f8ee65388a318ce0eb50057a89528b/jib-core%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FLocalRegistry.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/52075147a4f8ee65388a318ce0eb50057a89528b/jib-core%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FLocalRegistry.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FLocalRegistry.java?ref=52075147a4f8ee65388a318ce0eb50057a89528b",
      "patch": "@@ -141,7 +141,8 @@ public void pullAndPushToLocal(String from, String to) throws IOException, Inter\n \n   private void login() throws IOException, InterruptedException {\n     if (username != null && password != null) {\n-      new Command(\"docker\", \"login\", \"localhost:\" + port, \"-u\", username, \"-p\", password).run();\n+      new Command(\"docker\", \"login\", \"localhost:\" + port, \"-u\", username, \"--password-stdin\")\n+          .run(password.getBytes(StandardCharsets.UTF_8));\n     }\n   }\n ",
      "parent_sha": "3694767a12ed86d0a28eaaab18a60f69c06d3ff7"
    }
  },
  {
    "oid": "2fd6edce8c115c3f9fd625f3d6962db105ea7f02",
    "message": "Use SystemSocketFactory instead of the default factory for SSL socket factory (#2592)\n\n* Solving https://github.com/GoogleContainerTools/jib/issues/2585\r\n* Using ApacheHttpTransport.newDefaultHttpClientBuilder() instead of constructing a complete new instance.\r\n* Applied formatting.",
    "date": "2020-07-16T19:54:22Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/2fd6edce8c115c3f9fd625f3d6962db105ea7f02",
    "details": {
      "sha": "bb8a820b580bd04e73cc3f4828114fe586c7781d",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/http/FailoverHttpClient.java",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/2fd6edce8c115c3f9fd625f3d6962db105ea7f02/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fhttp%2FFailoverHttpClient.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/2fd6edce8c115c3f9fd625f3d6962db105ea7f02/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fhttp%2FFailoverHttpClient.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fhttp%2FFailoverHttpClient.java?ref=2fd6edce8c115c3f9fd625f3d6962db105ea7f02",
      "patch": "@@ -39,6 +39,7 @@\n import java.util.function.Supplier;\n import javax.net.ssl.SSLException;\n import org.apache.http.conn.ssl.NoopHostnameVerifier;\n+import org.apache.http.conn.ssl.SSLConnectionSocketFactory;\n import org.apache.http.impl.client.HttpClientBuilder;\n \n /**\n@@ -97,7 +98,10 @@ private static HttpTransport getSecureHttpTransport() {\n     //\n     // A new ApacheHttpTransport needs to be created for each connection because otherwise HTTP\n     // connection persistence causes the connection to throw NoHttpResponseException.\n-    return new ApacheHttpTransport();\n+    HttpClientBuilder httpClientBuilder =\n+        ApacheHttpTransport.newDefaultHttpClientBuilder()\n+            .setSSLSocketFactory(SSLConnectionSocketFactory.getSystemSocketFactory());\n+    return new ApacheHttpTransport(httpClientBuilder.build());\n   }\n \n   private static HttpTransport getInsecureHttpTransport() {",
      "parent_sha": "e2ba286d6b1580bd4f7ef0967787fea69a16c8ac"
    }
  },
  {
    "oid": "493441c4f3bb21489a88dc2655f4fd0ffc196f74",
    "message": "Fix tag backslash error message (#195)",
    "date": "2018-03-23T22:19:23Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/493441c4f3bb21489a88dc2655f4fd0ffc196f74",
    "details": {
      "sha": "ec4b56bf3ecdd9aec48fa42beadeb2cb32ab6d21",
      "filename": "jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/BuildImageMojo.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/493441c4f3bb21489a88dc2655f4fd0ffc196f74/jib-maven-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FBuildImageMojo.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/493441c4f3bb21489a88dc2655f4fd0ffc196f74/jib-maven-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FBuildImageMojo.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-maven-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FBuildImageMojo.java?ref=493441c4f3bb21489a88dc2655f4fd0ffc196f74",
      "patch": "@@ -280,9 +280,9 @@ private void validateParameters() throws MojoFailureException {\n         getLog().error(\"Invalid format for 'tag'\");\n       }\n \n-      // 'tag' must not contain backslashes.\n+      // 'tag' must not contain forward slashes.\n       if (tag.indexOf('/') >= 0) {\n-        getLog().error(\"'tag' cannot contain backslashes\");\n+        getLog().error(\"'tag' cannot contain '/'\");\n         throw new MojoFailureException(\"Invalid configuration parameters\");\n       }\n     }",
      "parent_sha": "a8aeb8b7d4b0837c6590304722366c1f78862388"
    }
  },
  {
    "oid": "b3f130648f8c892edcc30bb83d115e14e6613bee",
    "message": "Always return a loopback address (#2596)",
    "date": "2020-07-17T00:07:25Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/b3f130648f8c892edcc30bb83d115e14e6613bee",
    "details": {
      "sha": "eaa394400af3db72ee7f38713aac0716ff86919e",
      "filename": "jib-core/src/test/java/com/google/cloud/tools/jib/http/TestWebServer.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/b3f130648f8c892edcc30bb83d115e14e6613bee/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fhttp%2FTestWebServer.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/b3f130648f8c892edcc30bb83d115e14e6613bee/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fhttp%2FTestWebServer.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fhttp%2FTestWebServer.java?ref=b3f130648f8c892edcc30bb83d115e14e6613bee",
      "patch": "@@ -23,6 +23,7 @@\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n+import java.net.InetAddress;\n import java.net.ServerSocket;\n import java.net.Socket;\n import java.net.URISyntaxException;\n@@ -90,8 +91,8 @@ public int getLocalPort() {\n   }\n \n   public String getEndpoint() {\n-    String host = serverSocket.getInetAddress().getHostAddress();\n-    return (https ? \"https\" : \"http\") + \"://\" + host + \":\" + serverSocket.getLocalPort();\n+    String localhost = InetAddress.getLoopbackAddress().getHostAddress();\n+    return (https ? \"https\" : \"http\") + \"://\" + localhost + \":\" + serverSocket.getLocalPort();\n   }\n \n   @Override",
      "parent_sha": "2fd6edce8c115c3f9fd625f3d6962db105ea7f02"
    }
  },
  {
    "oid": "7ffea5caf80daf249f3162c19379f5990e391f83",
    "message": "test: Modify resource file for flaking integration test that compares two build times (#3772)\n\nFollowing same setup as testExecute_simple(), to avoid local registry caching in first time",
    "date": "2022-09-09T14:04:22Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/7ffea5caf80daf249f3162c19379f5990e391f83",
    "details": {
      "sha": "6b9d9ed7fbeecbb303df8d3c7f7f082468a2fefd",
      "filename": "jib-maven-plugin/src/integration-test/java/com/google/cloud/tools/jib/maven/BuildImageMojoIntegrationTest.java",
      "status": "modified",
      "additions": 19,
      "deletions": 2,
      "changes": 21,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/7ffea5caf80daf249f3162c19379f5990e391f83/jib-maven-plugin%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FBuildImageMojoIntegrationTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/7ffea5caf80daf249f3162c19379f5990e391f83/jib-maven-plugin%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FBuildImageMojoIntegrationTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-maven-plugin%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FBuildImageMojoIntegrationTest.java?ref=7ffea5caf80daf249f3162c19379f5990e391f83",
      "patch": "@@ -339,7 +339,7 @@ public void setUp() throws IOException, InterruptedException {\n     localRegistry.pullAndPushToLocal(\"gcr.io/distroless/java:latest\", \"distroless/java\");\n \n     // Make sure resource file has a consistent value at the beginning of each test\n-    // (testExecute_simple overwrites it)\n+    // (testExecute_simple and testBuild_tarBase overwrite it)\n     Files.write(\n         simpleTestProject\n             .getProjectRoot()\n@@ -434,11 +434,28 @@ public void testBuild_tarBase() throws IOException, InterruptedException, Verifi\n             + \"/simplewithtarbase:maven\"\n             + System.nanoTime();\n \n+    Instant before = Instant.now();\n+\n+    // The target registry these tests push to would already have all the layers cached from before,\n+    // causing this test to fail sometimes with the second build being a bit slower than the first\n+    // build. This file change makes sure that a new layer is always pushed the first time to solve\n+    // this issue.\n+    Files.write(\n+        simpleTestProject\n+            .getProjectRoot()\n+            .resolve(\"src\")\n+            .resolve(\"main\")\n+            .resolve(\"resources\")\n+            .resolve(\"world\"),\n+        before.toString().getBytes(StandardCharsets.UTF_8));\n+\n     assertThat(\n             buildAndRunFromLocalBase(\n                 simpleTestProject.getProjectRoot(), targetImage, \"tar://\" + path, true))\n         .isEqualTo(\n-            \"Hello, world. An argument.\\n1970-01-01T00:00:01Z\\nrw-r--r--\\nrw-r--r--\\nfoo\\ncat\\n\"\n+            \"Hello, \"\n+                + before\n+                + \". An argument.\\n1970-01-01T00:00:01Z\\nrw-r--r--\\nrw-r--r--\\nfoo\\ncat\\n\"\n                 + \"1970-01-01T00:00:01Z\\n1970-01-01T00:00:01Z\\n\");\n   }\n ",
      "parent_sha": "724a4ad41a9d3b936886925776954c08fc05184c"
    }
  },
  {
    "oid": "672fc37b6812f9218f3508425e546ef57e5736c1",
    "message": "Add assertions and migrate to Truth (#3371)\n\n* Add assertions and migrate to Truth\r\n\r\n* parametrize tests to reduce code smells",
    "date": "2021-08-03T16:23:56Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/672fc37b6812f9218f3508425e546ef57e5736c1",
    "details": {
      "sha": "0a4b9d711b6d6317e35cd6fbd3cd0947f4cd6fdc",
      "filename": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/BuildFileSpecTest.java",
      "status": "modified",
      "additions": 106,
      "deletions": 152,
      "changes": 258,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/672fc37b6812f9218f3508425e546ef57e5736c1/jib-cli%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2Fbuildfile%2FBuildFileSpecTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/672fc37b6812f9218f3508425e546ef57e5736c1/jib-cli%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2Fbuildfile%2FBuildFileSpecTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-cli%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2Fbuildfile%2FBuildFileSpecTest.java?ref=672fc37b6812f9218f3508425e546ef57e5736c1",
      "patch": "@@ -16,22 +16,21 @@\n \n package com.google.cloud.tools.jib.cli.buildfile;\n \n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth8.assertThat;\n+import static org.junit.Assert.assertThrows;\n+\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n import com.google.cloud.tools.jib.api.Ports;\n import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n import com.google.cloud.tools.jib.api.buildplan.ImageFormat;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.ImmutableSet;\n import java.nio.file.Paths;\n import java.time.Instant;\n import java.util.Arrays;\n import java.util.Collection;\n-import org.hamcrest.CoreMatchers;\n-import org.hamcrest.MatcherAssert;\n-import org.junit.Assert;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.Parameterized;\n@@ -71,119 +70,103 @@ public void testBuildFileSpec_full() throws JsonProcessingException {\n             + \"      archive: /something.tgz\\n\";\n \n     BuildFileSpec parsed = mapper.readValue(data, BuildFileSpec.class);\n-    Assert.assertEquals(\"v1alpha1\", parsed.getApiVersion());\n-    Assert.assertEquals(\"BuildFile\", parsed.getKind());\n-    Assert.assertEquals(\"gcr.io/example/jib\", parsed.getFrom().get().getImage());\n-    Assert.assertEquals(Instant.ofEpochMilli(1), parsed.getCreationTime().get());\n-    Assert.assertEquals(ImageFormat.OCI, parsed.getFormat().get());\n-    Assert.assertEquals(ImmutableMap.of(\"env_key\", \"env_value\"), parsed.getEnvironment());\n-    Assert.assertEquals(ImmutableMap.of(\"label_key\", \"label_value\"), parsed.getLabels());\n-    Assert.assertEquals(ImmutableSet.of(AbsoluteUnixPath.get(\"/my/volume\")), parsed.getVolumes());\n-    Assert.assertEquals(Ports.parse(ImmutableList.of(\"8080\")), parsed.getExposedPorts());\n-    Assert.assertEquals(\"username\", parsed.getUser().get());\n-    Assert.assertEquals(AbsoluteUnixPath.get(\"/workspace\"), parsed.getWorkingDirectory().get());\n-    Assert.assertEquals(ImmutableList.of(\"java\", \"-jar\"), parsed.getEntrypoint().get());\n-    Assert.assertEquals(ImmutableList.of(\"myjar.jar\"), parsed.getCmd().get());\n-    Assert.assertEquals(\n-        \"some layer\", ((ArchiveLayerSpec) parsed.getLayers().get().getEntries().get(0)).getName());\n-    Assert.assertEquals(\n-        Paths.get(\"/something.tgz\"),\n-        ((ArchiveLayerSpec) parsed.getLayers().get().getEntries().get(0)).getArchive());\n+    assertThat(parsed.getApiVersion()).isEqualTo(\"v1alpha1\");\n+    assertThat(parsed.getKind()).isEqualTo(\"BuildFile\");\n+    assertThat(parsed.getFrom().get().getImage()).isEqualTo(\"gcr.io/example/jib\");\n+    assertThat(parsed.getCreationTime().get()).isEqualTo(Instant.ofEpochMilli(1));\n+    assertThat(parsed.getFormat().get()).isEqualTo(ImageFormat.OCI);\n+    assertThat(parsed.getEnvironment()).containsExactly(\"env_key\", \"env_value\");\n+    assertThat(parsed.getLabels()).containsExactly(\"label_key\", \"label_value\");\n+    assertThat(parsed.getVolumes()).containsExactly(AbsoluteUnixPath.get(\"/my/volume\"));\n+    assertThat(parsed.getExposedPorts()).isEqualTo(Ports.parse(ImmutableList.of(\"8080\")));\n+    assertThat(parsed.getUser().get()).isEqualTo(\"username\");\n+    assertThat(parsed.getWorkingDirectory().get()).isEqualTo(AbsoluteUnixPath.get(\"/workspace\"));\n+    assertThat(parsed.getEntrypoint().get()).containsExactly(\"java\", \"-jar\").inOrder();\n+    assertThat(parsed.getCmd().get()).containsExactly(\"myjar.jar\");\n+    assertThat(((ArchiveLayerSpec) parsed.getLayers().get().getEntries().get(0)).getName())\n+        .isEqualTo(\"some layer\");\n+    assertThat(((ArchiveLayerSpec) parsed.getLayers().get().getEntries().get(0)).getArchive())\n+        .isEqualTo(Paths.get(\"/something.tgz\"));\n   }\n \n   @Test\n   public void testBuildFileSpec_apiVersionRequired() {\n     String data = \"kind: BuildFile\\n\";\n \n-    try {\n-      mapper.readValue(data, BuildFileSpec.class);\n-      Assert.fail();\n-    } catch (JsonProcessingException jpe) {\n-      MatcherAssert.assertThat(\n-          jpe.getMessage(),\n-          CoreMatchers.startsWith(\"Missing required creator property 'apiVersion'\"));\n-    }\n+    JsonProcessingException exception =\n+        assertThrows(\n+            JsonProcessingException.class, () -> mapper.readValue(data, BuildFileSpec.class));\n+    assertThat(exception)\n+        .hasMessageThat()\n+        .startsWith(\"Missing required creator property 'apiVersion'\");\n   }\n \n   @Test\n   public void testBuildFileSpec_apiVersionNotNull() {\n     String data = \"apiVersion: null\\n\" + \"kind: BuildFile\\n\";\n \n-    try {\n-      mapper.readValue(data, BuildFileSpec.class);\n-      Assert.fail();\n-    } catch (JsonProcessingException jpe) {\n-      MatcherAssert.assertThat(\n-          jpe.getMessage(), CoreMatchers.containsString(\"Property 'apiVersion' cannot be null\"));\n-    }\n+    JsonProcessingException exception =\n+        assertThrows(\n+            JsonProcessingException.class, () -> mapper.readValue(data, BuildFileSpec.class));\n+    assertThat(exception).hasMessageThat().contains(\"Property 'apiVersion' cannot be null\");\n   }\n \n   @Test\n   public void testBuildFileSpec_apiVersionNotEmpty() {\n     String data = \"apiVersion: ''\\n\" + \"kind: BuildFile\\n\";\n \n-    try {\n-      mapper.readValue(data, BuildFileSpec.class);\n-      Assert.fail();\n-    } catch (JsonProcessingException jpe) {\n-      MatcherAssert.assertThat(\n-          jpe.getMessage(),\n-          CoreMatchers.containsString(\"Property 'apiVersion' cannot be an empty string\"));\n-    }\n+    JsonProcessingException exception =\n+        assertThrows(\n+            JsonProcessingException.class, () -> mapper.readValue(data, BuildFileSpec.class));\n+    assertThat(exception)\n+        .hasMessageThat()\n+        .contains(\"Property 'apiVersion' cannot be an empty string\");\n   }\n \n   @Test\n   public void testBuildFileSpec_kindRequired() {\n     String data = \"apiVersion: v1alpha1\\n\";\n \n-    try {\n-      mapper.readValue(data, BuildFileSpec.class);\n-      Assert.fail();\n-    } catch (JsonProcessingException jpe) {\n-      MatcherAssert.assertThat(\n-          jpe.getMessage(), CoreMatchers.startsWith(\"Missing required creator property 'kind'\"));\n-    }\n+    JsonProcessingException exception =\n+        assertThrows(\n+            JsonProcessingException.class, () -> mapper.readValue(data, BuildFileSpec.class));\n+    assertThat(exception).hasMessageThat().startsWith(\"Missing required creator property 'kind'\");\n   }\n \n   @Test\n   public void testBuildFileSpec_kindMustBeBuildFile() {\n     String data = \"apiVersion: v1alpha1\\n\" + \"kind: NotBuildFile\\n\";\n \n-    try {\n-      mapper.readValue(data, BuildFileSpec.class);\n-      Assert.fail();\n-    } catch (JsonProcessingException jpe) {\n-      MatcherAssert.assertThat(\n-          jpe.getMessage(),\n-          CoreMatchers.containsString(\"Property 'kind' must be 'BuildFile' but is 'NotBuildFile'\"));\n-    }\n+    JsonProcessingException exception =\n+        assertThrows(\n+            JsonProcessingException.class, () -> mapper.readValue(data, BuildFileSpec.class));\n+    assertThat(exception)\n+        .hasMessageThat()\n+        .contains(\"Property 'kind' must be 'BuildFile' but is 'NotBuildFile'\");\n   }\n \n   @Test\n   public void testBuildFileSpec_kindNotNull() {\n     String data = \"apiVersion: v1alpha1\\n\" + \"kind: null\\n\";\n \n-    try {\n-      mapper.readValue(data, BuildFileSpec.class);\n-      Assert.fail();\n-    } catch (JsonProcessingException jpe) {\n-      MatcherAssert.assertThat(\n-          jpe.getMessage(), CoreMatchers.containsString(\"Property 'kind' cannot be null\"));\n-    }\n+    JsonProcessingException exception =\n+        assertThrows(\n+            JsonProcessingException.class, () -> mapper.readValue(data, BuildFileSpec.class));\n+    assertThat(exception).hasMessageThat().contains(\"Property 'kind' cannot be null\");\n   }\n \n   @Test\n   public void testBuildFileSpec_nullCollections() throws JsonProcessingException {\n     String data = \"apiVersion: v1alpha1\\n\" + \"kind: BuildFile\\n\";\n \n     BuildFileSpec parsed = mapper.readValue(data, BuildFileSpec.class);\n-    Assert.assertEquals(ImmutableMap.of(), parsed.getEnvironment());\n-    Assert.assertEquals(ImmutableMap.of(), parsed.getLabels());\n-    Assert.assertEquals(ImmutableSet.of(), parsed.getVolumes());\n-    Assert.assertEquals(ImmutableSet.of(), parsed.getExposedPorts());\n+    assertThat(parsed.getEnvironment()).isEmpty();\n+    assertThat(parsed.getLabels()).isEmpty();\n+    assertThat(parsed.getVolumes()).isEmpty();\n+    assertThat(parsed.getExposedPorts()).isEmpty();\n     // entrypoint and cmd CAN be not present\n-    Assert.assertFalse(parsed.getEntrypoint().isPresent());\n-    Assert.assertFalse(parsed.getCmd().isPresent());\n+    assertThat(parsed.getEntrypoint()).isEmpty();\n+    assertThat(parsed.getCmd()).isEmpty();\n   }\n \n   @RunWith(Parameterized.class)\n@@ -201,43 +184,38 @@ public void testBuildFileSpec_noNullEntries() {\n       String data =\n           \"apiVersion: v1alpha1\\n\" + \"kind: BuildFile\\n\" + fieldName + \": ['first', null]\";\n \n-      try {\n-        mapper.readValue(data, BuildFileSpec.class);\n-        Assert.fail();\n-      } catch (JsonProcessingException ex) {\n-        Assert.assertEquals(\n-            \"Property '\" + fieldName + \"' cannot contain null entries\", ex.getCause().getMessage());\n-      }\n+      JsonProcessingException exception =\n+          assertThrows(\n+              JsonProcessingException.class, () -> mapper.readValue(data, BuildFileSpec.class));\n+      assertThat(exception)\n+          .hasMessageThat()\n+          .contains(\"Property '\" + fieldName + \"' cannot contain null entries\");\n     }\n \n     @Test\n     public void testBuildFileSpec_noEmptyEntries() {\n       String data = \"apiVersion: v1alpha1\\n\" + \"kind: BuildFile\\n\" + fieldName + \": ['first', ' ']\";\n \n-      try {\n-        mapper.readValue(data, BuildFileSpec.class);\n-        Assert.fail();\n-      } catch (JsonProcessingException ex) {\n-        Assert.assertEquals(\n-            \"Property '\" + fieldName + \"' cannot contain empty strings\",\n-            ex.getCause().getMessage());\n-      }\n+      JsonProcessingException exception =\n+          assertThrows(\n+              JsonProcessingException.class, () -> mapper.readValue(data, BuildFileSpec.class));\n+      assertThat(exception)\n+          .hasMessageThat()\n+          .contains(\"Property '\" + fieldName + \"' cannot contain empty strings\");\n     }\n \n     @Test\n     public void testBuildFileSpec_emptyOkay() throws JsonProcessingException {\n       String data = \"apiVersion: v1alpha1\\n\" + \"kind: BuildFile\\n\" + fieldName + \": []\";\n \n-      mapper.readValue(data, BuildFileSpec.class);\n-      // pass\n+      assertThat(mapper.readValue(data, BuildFileSpec.class)).isNotNull();\n     }\n \n     @Test\n     public void testBuildFileSpec_nullOkay() throws JsonProcessingException {\n       String data = \"apiVersion: v1alpha1\\n\" + \"kind: BuildFile\\n\" + fieldName + \": null\";\n \n-      mapper.readValue(data, BuildFileSpec.class);\n-      // pass\n+      assertThat(mapper.readValue(data, BuildFileSpec.class)).isNotNull();\n     }\n   }\n \n@@ -255,47 +233,56 @@ public static Collection<Object[]> data() {\n     @Test\n     public void testBuildFileSpec_noEmptyValues() {\n       String data = \"apiVersion: v1alpha1\\n\" + \"kind: BuildFile\\n\" + fieldName + \": ' '\";\n-\n-      try {\n-        mapper.readValue(data, BuildFileSpec.class);\n-        Assert.fail();\n-      } catch (JsonProcessingException ex) {\n-        Assert.assertEquals(\n-            \"Property '\" + fieldName + \"' cannot be an empty string\", ex.getCause().getMessage());\n-      }\n+      JsonProcessingException exception =\n+          assertThrows(\n+              JsonProcessingException.class, () -> mapper.readValue(data, BuildFileSpec.class));\n+      assertThat(exception)\n+          .hasMessageThat()\n+          .contains(\"Property '\" + fieldName + \"' cannot be an empty string\");\n     }\n \n     @Test\n     public void testBuildFileSpec_nullOkay() throws JsonProcessingException {\n       String data = \"apiVersion: v1alpha1\\n\" + \"kind: BuildFile\\n\" + fieldName + \": null\";\n \n-      mapper.readValue(data, BuildFileSpec.class);\n-      // pass\n+      assertThat(mapper.readValue(data, BuildFileSpec.class)).isNotNull();\n     }\n   }\n \n   @RunWith(Parameterized.class)\n   public static class OptionalStringMapTests {\n \n     @Parameterized.Parameters(name = \"{0}\")\n-    public static Collection<Object[]> data() {\n-      return Arrays.asList(new Object[][] {{\"environment\"}, {\"labels\"}});\n+    public static Collection<Object[]> invalidMapEntries() {\n+      return Arrays.asList(\n+          new Object[][] {\n+            {\"environment\", \"  key: null\", \"' cannot contain null values\"},\n+            {\"environment\", \"  key: ' '\", \"' cannot contain empty string values\"},\n+            {\"environment\", \"  ' ': value\", \"' cannot contain empty string keys\"},\n+            {\"labels\", \"  key: null\", \"' cannot contain null values\"},\n+            {\"labels\", \"  key: ' '\", \"' cannot contain empty string values\"},\n+            {\"labels\", \"  ' ': value\", \"' cannot contain empty string keys\"},\n+          });\n     }\n \n     @Parameterized.Parameter public String fieldName;\n \n+    @Parameterized.Parameter(1)\n+    public String input;\n+\n+    @Parameterized.Parameter(2)\n+    public String expectedErrorMessage;\n+\n     @Test\n-    public void testBuildFileSpec_noNullValues() {\n-      String data =\n-          \"apiVersion: v1alpha1\\n\" + \"kind: BuildFile\\n\" + fieldName + \":\\n\" + \"  key: null\";\n-\n-      try {\n-        mapper.readValue(data, BuildFileSpec.class);\n-        Assert.fail();\n-      } catch (JsonProcessingException ex) {\n-        Assert.assertEquals(\n-            \"Property '\" + fieldName + \"' cannot contain null values\", ex.getCause().getMessage());\n-      }\n+    public void testBuildFileSpec_invalidMapEntries() {\n+      String data = \"apiVersion: v1alpha1\\n\" + \"kind: BuildFile\\n\" + fieldName + \":\\n\" + input;\n+\n+      JsonProcessingException exception =\n+          assertThrows(\n+              JsonProcessingException.class, () -> mapper.readValue(data, BuildFileSpec.class));\n+      assertThat(exception)\n+          .hasMessageThat()\n+          .contains(\"Property '\" + fieldName + expectedErrorMessage);\n     }\n \n     /**\n@@ -307,54 +294,21 @@ public void testBuildFileSpec_yamlNullKeysPass() throws JsonProcessingException\n       String data =\n           \"apiVersion: v1alpha1\\n\" + \"kind: BuildFile\\n\" + fieldName + \":\\n\" + \"  null: value\";\n \n-      mapper.readValue(data, BuildFileSpec.class);\n-      // pass\n-    }\n-\n-    @Test\n-    public void testBuildFileSpec_noEmptyValues() {\n-      String data =\n-          \"apiVersion: v1alpha1\\n\" + \"kind: BuildFile\\n\" + fieldName + \":\\n\" + \"  key: ' '\";\n-\n-      try {\n-        mapper.readValue(data, BuildFileSpec.class);\n-        Assert.fail();\n-      } catch (JsonProcessingException ex) {\n-        Assert.assertEquals(\n-            \"Property '\" + fieldName + \"' cannot contain empty string values\",\n-            ex.getCause().getMessage());\n-      }\n-    }\n-\n-    @Test\n-    public void testBuildFileSpec_noEmptyKeys() {\n-      String data =\n-          \"apiVersion: v1alpha1\\n\" + \"kind: BuildFile\\n\" + fieldName + \":\\n\" + \"  ' ': value\";\n-\n-      try {\n-        mapper.readValue(data, BuildFileSpec.class);\n-        Assert.fail();\n-      } catch (JsonProcessingException ex) {\n-        Assert.assertEquals(\n-            \"Property '\" + fieldName + \"' cannot contain empty string keys\",\n-            ex.getCause().getMessage());\n-      }\n+      assertThat(mapper.readValue(data, BuildFileSpec.class)).isNotNull();\n     }\n \n     @Test\n     public void testBuildFileSpec_emptyOkay() throws JsonProcessingException {\n       String data = \"apiVersion: v1alpha1\\n\" + \"kind: BuildFile\\n\" + fieldName + \": {}\";\n \n-      mapper.readValue(data, BuildFileSpec.class);\n-      // pass\n+      assertThat(mapper.readValue(data, BuildFileSpec.class)).isNotNull();\n     }\n \n     @Test\n     public void testBuildFileSpec_nullOkay() throws JsonProcessingException {\n       String data = \"apiVersion: v1alpha1\\n\" + \"kind: BuildFile\\n\" + fieldName + \": null\";\n \n-      mapper.readValue(data, BuildFileSpec.class);\n-      // pass\n+      assertThat(mapper.readValue(data, BuildFileSpec.class)).isNotNull();\n     }\n   }\n }",
      "parent_sha": "fde35111cafd1ca00dda3beafabd3576e70531c2"
    }
  },
  {
    "oid": "611ef1649fc8b2c23f9ba319524ea4135a9cb6e2",
    "message": "Fix BuildImageMojoIntegrationTest (#1829)",
    "date": "2019-07-05T21:27:54Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/611ef1649fc8b2c23f9ba319524ea4135a9cb6e2",
    "details": {
      "sha": "645c6cb9af0c4cc6180d96ea4a0b44adb727e933",
      "filename": "jib-maven-plugin/src/test/java/com/google/cloud/tools/jib/maven/BuildImageMojoIntegrationTest.java",
      "status": "modified",
      "additions": 12,
      "deletions": 6,
      "changes": 18,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/611ef1649fc8b2c23f9ba319524ea4135a9cb6e2/jib-maven-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FBuildImageMojoIntegrationTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/611ef1649fc8b2c23f9ba319524ea4135a9cb6e2/jib-maven-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FBuildImageMojoIntegrationTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-maven-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FBuildImageMojoIntegrationTest.java?ref=611ef1649fc8b2c23f9ba319524ea4135a9cb6e2",
      "patch": "@@ -546,24 +546,30 @@ public void testExecute_jibContainerizeSkips() throws VerificationException, IOE\n \n   @Test\n   public void testExecute_jibRequireVersion_ok() throws VerificationException, IOException {\n-    String targetImage = \"simpleimage:maven\" + System.nanoTime();\n+    String targetImage = \"localhost:6000/simpleimage:maven\" + System.nanoTime();\n \n-    Instant before = Instant.now();\n     Verifier verifier = new Verifier(simpleTestProject.getProjectRoot().toString());\n-    // this plugin should match 1.0\n-    verifier.setSystemProperty(\"jib.requiredVersion\", \"1.0\");\n     verifier.setSystemProperty(\"_TARGET_IMAGE\", targetImage);\n+    // properties required to push to :6000 for plain pom.xml\n+    verifier.setSystemProperty(\"jib.to.auth.username\", \"testuser2\");\n+    verifier.setSystemProperty(\"jib.to.auth.password\", \"testpassword2\");\n+    verifier.setSystemProperty(\"sendCredentialsOverHttp\", \"true\");\n+    verifier.setSystemProperty(\"jib.allowInsecureRegistries\", \"true\");\n+    // this test plugin should match 1.0\n+    verifier.setSystemProperty(\"jib.requiredVersion\", \"1.0\");\n     verifier.executeGoals(Arrays.asList(\"package\", \"jib:build\"));\n     verifier.verifyErrorFreeLog();\n   }\n \n   @Test\n   public void testExecute_jibRequireVersion_fail() throws IOException {\n-    String targetImage = \"simpleimage:maven\" + System.nanoTime();\n+    String targetImage = \"localhost:6000/simpleimage:maven\" + System.nanoTime();\n     try {\n       Verifier verifier = new Verifier(simpleTestProject.getProjectRoot().toString());\n-      verifier.setSystemProperty(\"jib.requiredVersion\", \"[,1.0]\");\n+      // other properties aren't required as this should fail due to jib.requiredVersion\n       verifier.setSystemProperty(\"_TARGET_IMAGE\", targetImage);\n+      // this plugin should be > 1.0 and so jib:build should fail\n+      verifier.setSystemProperty(\"jib.requiredVersion\", \"[,1.0]\");\n       verifier.executeGoals(Arrays.asList(\"package\", \"jib:build\"));\n       Assert.fail();\n     } catch (VerificationException ex) {",
      "parent_sha": "051d3e5e7f615a9d0b1bcea86c433fc0a41a7744"
    }
  },
  {
    "oid": "c04dba3222b285ffe3f252593b1b2c985d19fc48",
    "message": "Cast operand as long (#3393)",
    "date": "2021-08-06T20:11:12Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/c04dba3222b285ffe3f252593b1b2c985d19fc48",
    "details": {
      "sha": "9238d675f57014513bf53417eb551c90147b9e42",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/c04dba3222b285ffe3f252593b1b2c985d19fc48/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPullBaseImageStep.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/c04dba3222b285ffe3f252593b1b2c985d19fc48/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPullBaseImageStep.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPullBaseImageStep.java?ref=c04dba3222b285ffe3f252593b1b2c985d19fc48",
      "patch": "@@ -320,7 +320,7 @@ private List<Image> pullBaseImages(\n       Set<Platform> platforms = buildContext.getContainerConfiguration().getPlatforms();\n       try (ProgressEventDispatcher progressDispatcher2 =\n           childProgressDispatcherFactory.create(\n-              \"pulling platform-specific manifests and container configs\", 2 * platforms.size())) {\n+              \"pulling platform-specific manifests and container configs\", 2L * platforms.size())) {\n         // If a manifest list, search for the manifests matching the given platforms.\n         for (Platform platform : platforms) {\n           String message = \"Searching for architecture=%s, os=%s in the base image manifest list\";",
      "parent_sha": "ed0ab8565b649c72f83f4a92ebf0638c7cbb6e7b"
    }
  },
  {
    "oid": "f66214b8467e06ace57038334c5cebdf8b360007",
    "message": "For config generation use create and move of temp file (#2341)",
    "date": "2020-03-20T01:26:08Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/f66214b8467e06ace57038334c5cebdf8b360007",
    "details": {
      "sha": "43fc426e411d90e9a7a2523f5cb7007bd749b2f4",
      "filename": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/UpdateChecker.java",
      "status": "modified",
      "additions": 28,
      "deletions": 3,
      "changes": 31,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/f66214b8467e06ace57038334c5cebdf8b360007/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FUpdateChecker.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/f66214b8467e06ace57038334c5cebdf8b360007/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FUpdateChecker.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FUpdateChecker.java?ref=f66214b8467e06ace57038334c5cebdf8b360007",
      "patch": "@@ -32,9 +32,11 @@\n import java.io.OutputStream;\n import java.net.URL;\n import java.nio.charset.StandardCharsets;\n+import java.nio.file.AtomicMoveNotSupportedException;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n import java.time.Duration;\n import java.time.Instant;\n import java.time.format.DateTimeParseException;\n@@ -47,6 +49,8 @@\n /** Checks if Jib is up-to-date. */\n public class UpdateChecker {\n \n+  private static final String CONFIG_FILENAME = \"config.json\";\n+\n   /** JSON template for the configuration file used to enable/disable update checks. */\n   @VisibleForTesting\n   static class ConfigJsonTemplate implements JsonTemplate {\n@@ -97,7 +101,7 @@ static Optional<String> performUpdateCheck(\n       return Optional.empty();\n     }\n \n-    Path configFile = configDir.resolve(\"config.json\");\n+    Path configFile = configDir.resolve(CONFIG_FILENAME);\n     Path lastUpdateCheck = configDir.resolve(\"lastUpdateCheck\");\n \n     try {\n@@ -123,12 +127,33 @@ static Optional<String> performUpdateCheck(\n         // Generate config file if it doesn't exist\n         ConfigJsonTemplate config = new ConfigJsonTemplate();\n         Files.createDirectories(configDir);\n-        try (OutputStream outputStream = Files.newOutputStream(configFile)) {\n+        Path tempConfigFile = configDir.resolve(CONFIG_FILENAME + \".tmp\");\n+        try (OutputStream outputStream = Files.newOutputStream(tempConfigFile)) {\n           JsonTemplateMapper.writeTo(config, outputStream);\n+          // Attempts an atomic move first, and falls back to non-atomic if the file system does not\n+          // support atomic moves.\n+          try {\n+            Files.move(\n+                tempConfigFile,\n+                configFile,\n+                StandardCopyOption.ATOMIC_MOVE,\n+                StandardCopyOption.REPLACE_EXISTING);\n+          } catch (AtomicMoveNotSupportedException ignored) {\n+            Files.move(tempConfigFile, configFile, StandardCopyOption.REPLACE_EXISTING);\n+          }\n         } catch (IOException ex) {\n           // If attempt to generate new config file failed, delete so we can try again next time\n           log.accept(LogEvent.debug(\"Failed to generate global Jib config; \" + ex.getMessage()));\n-          Files.deleteIfExists(configFile);\n+          try {\n+            Files.deleteIfExists(tempConfigFile);\n+          } catch (IOException cleanupEx) {\n+            log.accept(\n+                LogEvent.debug(\n+                    \"Failed to cleanup \"\n+                        + tempConfigFile.toString()\n+                        + \" -- \"\n+                        + cleanupEx.getMessage()));\n+          }\n         }\n       }\n ",
      "parent_sha": "693bda00709857326bd8f953ee24dfec24ee6526"
    }
  },
  {
    "oid": "cfd6621b1bb8e693f9d167b4d33f599dfd82a7a6",
    "message": "Reduce visibility (#1372)",
    "date": "2018-12-20T19:47:50Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/cfd6621b1bb8e693f9d167b4d33f599dfd82a7a6",
    "details": {
      "sha": "606b9afa511937b7acea61122e93b8ff062ee2d5",
      "filename": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/PluginConfigurationProcessor.java",
      "status": "modified",
      "additions": 68,
      "deletions": 66,
      "changes": 134,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/cfd6621b1bb8e693f9d167b4d33f599dfd82a7a6/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FPluginConfigurationProcessor.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/cfd6621b1bb8e693f9d167b4d33f599dfd82a7a6/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FPluginConfigurationProcessor.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FPluginConfigurationProcessor.java?ref=cfd6621b1bb8e693f9d167b4d33f599dfd82a7a6",
      "patch": "@@ -55,72 +55,6 @@\n  */\n public class PluginConfigurationProcessor {\n \n-  /**\n-   * Compute the container entrypoint, in this order:\n-   *\n-   * <ol>\n-   *   <li>null (inheriting from the base image), if the user specified value is {@code INHERIT}\n-   *   <li>the user specified one, if set\n-   *   <li>for a WAR project, null (it must be inherited from base image)\n-   *   <li>for a non-WAR project, by resolving the main class\n-   * </ol>\n-   *\n-   * @param rawConfiguration raw configuration data\n-   * @param projectProperties used for providing additional information\n-   * @return the entrypoint\n-   * @throws MainClassInferenceException if no valid main class is configured or discovered\n-   * @throws InvalidAppRootException if {@code appRoot} value is not an absolute Unix path\n-   */\n-  @Nullable\n-  public static List<String> computeEntrypoint(\n-      RawConfiguration rawConfiguration, ProjectProperties projectProperties)\n-      throws MainClassInferenceException, InvalidAppRootException {\n-    Optional<List<String>> rawEntrypoint = rawConfiguration.getEntrypoint();\n-    if (rawEntrypoint.isPresent() && !rawEntrypoint.get().isEmpty()) {\n-      if (rawConfiguration.getMainClass().isPresent()\n-          || !rawConfiguration.getJvmFlags().isEmpty()) {\n-        new DefaultEventDispatcher(projectProperties.getEventHandlers())\n-            .dispatch(\n-                LogEvent.warn(\"mainClass and jvmFlags are ignored when entrypoint is specified\"));\n-      }\n-\n-      if (rawEntrypoint.get().size() == 1 && \"INHERIT\".equals(rawEntrypoint.get().get(0))) {\n-        return null;\n-      }\n-      return rawEntrypoint.get();\n-    }\n-\n-    if (projectProperties.isWarProject()) {\n-      return null;\n-    }\n-\n-    AbsoluteUnixPath appRoot = getAppRootChecked(rawConfiguration, projectProperties);\n-    String mainClass =\n-        MainClassResolver.resolveMainClass(\n-            rawConfiguration.getMainClass().orElse(null), projectProperties);\n-    return JavaEntrypointConstructor.makeDefaultEntrypoint(\n-        appRoot, rawConfiguration.getJvmFlags(), mainClass);\n-  }\n-\n-  /**\n-   * Gets the suitable value for the base image. If the raw base image parameter is null, returns\n-   * {@code \"gcr.io/distroless/java/jetty\"} for WAR projects or {@code \"gcr.io/distroless/java\"} for\n-   * non-WAR.\n-   *\n-   * @param rawConfiguration raw configuration data\n-   * @param projectProperties used for providing additional information\n-   * @return the base image\n-   */\n-  public static String getBaseImage(\n-      RawConfiguration rawConfiguration, ProjectProperties projectProperties) {\n-    return rawConfiguration\n-        .getFromImage()\n-        .orElse(\n-            projectProperties.isWarProject()\n-                ? \"gcr.io/distroless/java/jetty\"\n-                : \"gcr.io/distroless/java\");\n-  }\n-\n   public static PluginConfigurationProcessor processCommonConfigurationForDockerDaemonImage(\n       RawConfiguration rawConfiguration,\n       InferredAuthProvider inferredAuthProvider,\n@@ -280,6 +214,74 @@ static PluginConfigurationProcessor processCommonConfiguration(\n         isTargetImageCredentialPresent);\n   }\n \n+  /**\n+   * Compute the container entrypoint, in this order:\n+   *\n+   * <ol>\n+   *   <li>null (inheriting from the base image), if the user specified value is {@code INHERIT}\n+   *   <li>the user specified one, if set\n+   *   <li>for a WAR project, null (it must be inherited from base image)\n+   *   <li>for a non-WAR project, by resolving the main class\n+   * </ol>\n+   *\n+   * @param rawConfiguration raw configuration data\n+   * @param projectProperties used for providing additional information\n+   * @return the entrypoint\n+   * @throws MainClassInferenceException if no valid main class is configured or discovered\n+   * @throws InvalidAppRootException if {@code appRoot} value is not an absolute Unix path\n+   */\n+  @Nullable\n+  @VisibleForTesting\n+  static List<String> computeEntrypoint(\n+      RawConfiguration rawConfiguration, ProjectProperties projectProperties)\n+      throws MainClassInferenceException, InvalidAppRootException {\n+    Optional<List<String>> rawEntrypoint = rawConfiguration.getEntrypoint();\n+    if (rawEntrypoint.isPresent() && !rawEntrypoint.get().isEmpty()) {\n+      if (rawConfiguration.getMainClass().isPresent()\n+          || !rawConfiguration.getJvmFlags().isEmpty()) {\n+        new DefaultEventDispatcher(projectProperties.getEventHandlers())\n+            .dispatch(\n+                LogEvent.warn(\"mainClass and jvmFlags are ignored when entrypoint is specified\"));\n+      }\n+\n+      if (rawEntrypoint.get().size() == 1 && \"INHERIT\".equals(rawEntrypoint.get().get(0))) {\n+        return null;\n+      }\n+      return rawEntrypoint.get();\n+    }\n+\n+    if (projectProperties.isWarProject()) {\n+      return null;\n+    }\n+\n+    AbsoluteUnixPath appRoot = getAppRootChecked(rawConfiguration, projectProperties);\n+    String mainClass =\n+        MainClassResolver.resolveMainClass(\n+            rawConfiguration.getMainClass().orElse(null), projectProperties);\n+    return JavaEntrypointConstructor.makeDefaultEntrypoint(\n+        appRoot, rawConfiguration.getJvmFlags(), mainClass);\n+  }\n+\n+  /**\n+   * Gets the suitable value for the base image. If the raw base image parameter is null, returns\n+   * {@code \"gcr.io/distroless/java/jetty\"} for WAR projects or {@code \"gcr.io/distroless/java\"} for\n+   * non-WAR.\n+   *\n+   * @param rawConfiguration raw configuration data\n+   * @param projectProperties used for providing additional information\n+   * @return the base image\n+   */\n+  @VisibleForTesting\n+  static String getBaseImage(\n+      RawConfiguration rawConfiguration, ProjectProperties projectProperties) {\n+    return rawConfiguration\n+        .getFromImage()\n+        .orElse(\n+            projectProperties.isWarProject()\n+                ? \"gcr.io/distroless/java/jetty\"\n+                : \"gcr.io/distroless/java\");\n+  }\n+\n   /**\n    * Parses the list of raw volumes directories to a set of {@link AbsoluteUnixPath}\n    *",
      "parent_sha": "c8c639679a51389c46c7196e2c55e1c41bffe7de"
    }
  },
  {
    "oid": "e4ca3d509221de6a237ba5a8a4b4d6b6a7ba3709",
    "message": "Migrate to Truth and remove warning suppressions (#3120)\n\n* Migrate to Truth\r\n* cleanups",
    "date": "2021-03-08T22:19:50Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/e4ca3d509221de6a237ba5a8a4b4d6b6a7ba3709",
    "details": {
      "sha": "77c2be016a153c195787df161eb1f361345b3320",
      "filename": "jib-gradle-plugin/src/test/java/com/google/cloud/tools/jib/gradle/JibPluginTest.java",
      "status": "modified",
      "additions": 90,
      "deletions": 119,
      "changes": 209,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/e4ca3d509221de6a237ba5a8a4b4d6b6a7ba3709/jib-gradle-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FJibPluginTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/e4ca3d509221de6a237ba5a8a4b4d6b6a7ba3709/jib-gradle-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FJibPluginTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-gradle-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FJibPluginTest.java?ref=e4ca3d509221de6a237ba5a8a4b4d6b6a7ba3709",
      "patch": "@@ -16,14 +16,17 @@\n \n package com.google.cloud.tools.jib.gradle;\n \n+import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.assertThrows;\n+\n import com.google.common.collect.ImmutableList;\n+import com.google.common.truth.Correspondence;\n import java.io.IOException;\n import java.io.InputStream;\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.util.Arrays;\n import java.util.Set;\n-import java.util.stream.Collectors;\n import org.gradle.api.GradleException;\n import org.gradle.api.Project;\n import org.gradle.api.Task;\n@@ -34,10 +37,7 @@\n import org.gradle.testfixtures.ProjectBuilder;\n import org.gradle.testkit.runner.GradleRunner;\n import org.gradle.testkit.runner.UnexpectedBuildFailure;\n-import org.hamcrest.CoreMatchers;\n-import org.hamcrest.MatcherAssert;\n import org.junit.After;\n-import org.junit.Assert;\n import org.junit.Assume;\n import org.junit.Rule;\n import org.junit.Test;\n@@ -52,6 +52,12 @@ public class JibPluginTest {\n           JibPlugin.BUILD_DOCKER_TASK_NAME,\n           JibPlugin.BUILD_TAR_TASK_NAME);\n \n+  private static final Correspondence<Object, Task> PROVIDES_TASK_OF =\n+      Correspondence.from(\n+          (object, task) ->\n+              object instanceof TaskProvider && ((TaskProvider<?>) object).get().equals(task),\n+          \"provides task of\");\n+\n   private static boolean isJava8Runtime() {\n     return System.getProperty(\"java.version\").startsWith(\"1.8.\");\n   }\n@@ -97,68 +103,58 @@ public void testCheckGradleVersion_fail() throws IOException {\n             .withProjectDir(testProjectRoot.getRoot())\n             .withPluginClasspath()\n             .withGradleVersion(\"4.3\");\n-    try {\n-      gradleRunner.build();\n-      Assert.fail();\n-    } catch (UnexpectedBuildFailure ex) {\n-      Assert.assertTrue(\n-          ex.getMessage()\n-              .contains(\n-                  \"Detected Gradle 4.3, but jib requires \"\n-                      + JibPlugin.GRADLE_MIN_VERSION\n-                      + \" or higher. You can upgrade by running 'gradle wrapper --gradle-version=\"\n-                      + JibPlugin.GRADLE_MIN_VERSION.getVersion()\n-                      + \"'.\"));\n-    }\n+\n+    Exception exception = assertThrows(UnexpectedBuildFailure.class, () -> gradleRunner.build());\n+    assertThat(exception)\n+        .hasMessageThat()\n+        .contains(\n+            \"Detected Gradle 4.3, but jib requires \"\n+                + JibPlugin.GRADLE_MIN_VERSION\n+                + \" or higher. You can upgrade by running 'gradle wrapper --gradle-version=\"\n+                + JibPlugin.GRADLE_MIN_VERSION.getVersion()\n+                + \"'.\");\n   }\n \n   @Test\n   public void testCheckJibVersionNames() {\n     // These identifiers will be baked into Skaffold and should not be changed\n-    Assert.assertEquals(JibPlugin.REQUIRED_VERSION_PROPERTY_NAME, \"jib.requiredVersion\");\n-    Assert.assertEquals(\n-        JibPlugin.SKAFFOLD_CHECK_REQUIRED_VERSION_TASK_NAME, \"_skaffoldFailIfJibOutOfDate\");\n+    assertThat(JibPlugin.REQUIRED_VERSION_PROPERTY_NAME).isEqualTo(\"jib.requiredVersion\");\n+    assertThat(JibPlugin.SKAFFOLD_CHECK_REQUIRED_VERSION_TASK_NAME)\n+        .isEqualTo(\"_skaffoldFailIfJibOutOfDate\");\n   }\n \n   @Test\n   public void testCheckJibVersionInvoked() {\n     Project project = createProject();\n     System.setProperty(JibPlugin.REQUIRED_VERSION_PROPERTY_NAME, \"10000.0\"); // not here yet\n-    try {\n-      project.getPluginManager().apply(\"com.google.cloud.tools.jib\");\n-      Assert.fail(\"should have failed\");\n-    } catch (GradleException ex) {\n-      // Gradle tests aren't run from a jar and so don't have an identifiable plugin version\n-      Assert.assertEquals(\n-          \"Failed to apply plugin [id 'com.google.cloud.tools.jib']\", ex.getMessage());\n-      Assert.assertEquals(\"Could not determine Jib plugin version\", ex.getCause().getMessage());\n-    }\n+\n+    Exception exception =\n+        assertThrows(\n+            GradleException.class,\n+            () -> project.getPluginManager().apply(\"com.google.cloud.tools.jib\"));\n+    // Gradle tests aren't run from a jar and so don't have an identifiable plugin version\n+    assertThat(exception)\n+        .hasMessageThat()\n+        .isEqualTo(\"Failed to apply plugin [id 'com.google.cloud.tools.jib']\");\n+    assertThat(exception.getCause())\n+        .hasMessageThat()\n+        .isEqualTo(\"Could not determine Jib plugin version\");\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n   @Test\n   public void testWebAppProject() {\n     Project project = createProject(\"java\", \"war\", \"com.google.cloud.tools.jib\");\n \n     TaskContainer tasks = project.getTasks();\n     Task warTask = tasks.getByPath(\":war\");\n-    Assert.assertNotNull(warTask);\n+    assertThat(warTask).isNotNull();\n \n     for (String taskName : KNOWN_JIB_TASKS) {\n-      Set<Task> taskDependencies =\n-          tasks\n-              .getByPath(taskName)\n-              .getDependsOn()\n-              .stream()\n-              .filter(TaskProvider.class::isInstance)\n-              .map(it -> ((TaskProvider<?>) it).get())\n-              .collect(Collectors.toSet());\n-\n-      Assert.assertTrue(taskDependencies.contains(warTask));\n+      Set<Object> taskDependencies = tasks.getByPath(taskName).getDependsOn();\n+      assertThat(taskDependencies).comparingElementsUsing(PROVIDES_TASK_OF).contains(warTask);\n     }\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n   @Test\n   public void testWebAppProject_bootWar() {\n     Project project =\n@@ -167,24 +163,17 @@ public void testWebAppProject_bootWar() {\n     TaskContainer tasks = project.getTasks();\n     Task warTask = tasks.getByPath(\":war\");\n     Task bootWarTask = tasks.getByPath(\":bootWar\");\n-    Assert.assertNotNull(warTask);\n-    Assert.assertNotNull(bootWarTask);\n+    assertThat(warTask).isNotNull();\n+    assertThat(bootWarTask).isNotNull();\n \n     for (String taskName : KNOWN_JIB_TASKS) {\n-      Set<Task> taskDependencies =\n-          tasks\n-              .getByPath(taskName)\n-              .getDependsOn()\n-              .stream()\n-              .filter(TaskProvider.class::isInstance)\n-              .map(it -> ((TaskProvider<?>) it).get())\n-              .collect(Collectors.toSet());\n-\n-      Assert.assertTrue(taskDependencies.containsAll(Arrays.asList(warTask, bootWarTask)));\n+      Set<Object> taskDependencies = tasks.getByPath(taskName).getDependsOn();\n+      assertThat(taskDependencies)\n+          .comparingElementsUsing(PROVIDES_TASK_OF)\n+          .containsAtLeast(warTask, bootWarTask);\n     }\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n   @Test\n   public void testWebAppProject_bootWarDisabled() {\n     Project project =\n@@ -195,20 +184,14 @@ public void testWebAppProject_bootWarDisabled() {\n \n     Task warTask = tasks.getByPath(\":war\");\n     Task bootWarTask = tasks.getByPath(\":bootWar\");\n-    Assert.assertNotNull(warTask);\n-    Assert.assertNotNull(bootWarTask);\n+    assertThat(warTask).isNotNull();\n+    assertThat(bootWarTask).isNotNull();\n \n     for (String taskName : KNOWN_JIB_TASKS) {\n-      Set<Task> taskDependencies =\n-          tasks\n-              .getByPath(taskName)\n-              .getDependsOn()\n-              .stream()\n-              .filter(TaskProvider.class::isInstance)\n-              .map(it -> ((TaskProvider<?>) it).get())\n-              .collect(Collectors.toSet());\n-\n-      Assert.assertTrue(taskDependencies.containsAll(Arrays.asList(warTask, bootWarTask)));\n+      Set<Object> taskDependencies = tasks.getByPath(taskName).getDependsOn();\n+      assertThat(taskDependencies)\n+          .comparingElementsUsing(PROVIDES_TASK_OF)\n+          .containsAtLeast(warTask, bootWarTask);\n     }\n   }\n \n@@ -218,8 +201,8 @@ public void testSpringBootJarProject_nonPackagedMode() {\n         createProject(\"java\", \"org.springframework.boot\", \"com.google.cloud.tools.jib\");\n \n     Jar jar = (Jar) project.getTasks().getByPath(\":jar\");\n-    Assert.assertFalse(jar.getEnabled());\n-    Assert.assertEquals(\"\", jar.getArchiveClassifier().get());\n+    assertThat(jar.getEnabled()).isFalse();\n+    assertThat(jar.getArchiveClassifier().get()).isEmpty();\n   }\n \n   @Test\n@@ -230,8 +213,8 @@ public void testSpringBootJarProject_packagedMode() {\n     jibExtension.setContainerizingMode(\"packaged\");\n \n     Jar jar = (Jar) project.getTasks().getByPath(\":jar\");\n-    Assert.assertTrue(jar.getEnabled());\n-    Assert.assertEquals(\"original\", jar.getArchiveClassifier().get());\n+    assertThat(jar.getEnabled()).isTrue();\n+    assertThat(jar.getArchiveClassifier().get()).isEqualTo(\"original\");\n   }\n \n   @Test\n@@ -244,8 +227,8 @@ public void testSpringBootJarProject_packagedMode_jarClassifierSet() {\n     jarTask.configure(task -> ((Jar) task).getArchiveClassifier().set(\"jar-classifier\"));\n \n     Jar jar = (Jar) project.getTasks().getByPath(\":jar\");\n-    Assert.assertTrue(jar.getEnabled());\n-    Assert.assertEquals(\"jar-classifier\", jar.getArchiveClassifier().get());\n+    assertThat(jar.getEnabled()).isTrue();\n+    assertThat(jar.getArchiveClassifier().get()).isEqualTo(\"jar-classifier\");\n   }\n \n   @Test\n@@ -258,8 +241,8 @@ public void testSpringBootJarProject_packagedMode_bootJarClassifierSet() {\n     bootJarTask.configure(task -> ((Jar) task).getArchiveClassifier().set(\"boot-classifier\"));\n \n     Jar jar = (Jar) project.getTasks().getByPath(\":jar\");\n-    Assert.assertTrue(jar.getEnabled());\n-    Assert.assertEquals(\"\", jar.getArchiveClassifier().get());\n+    assertThat(jar.getEnabled()).isTrue();\n+    assertThat(jar.getArchiveClassifier().get()).isEmpty();\n   }\n \n   @Test\n@@ -271,20 +254,15 @@ public void testSpringBootJarProject_packagedMode_jarEnabled() {\n     project.getTasks().named(\"jar\").configure(task -> task.setEnabled(true));\n \n     TaskContainer tasks = project.getTasks();\n-    try {\n-      tasks.getByPath(\":jar\");\n-      Assert.fail();\n-    } catch (GradleException ex) {\n-      MatcherAssert.assertThat(\n-          ex.getCause().getMessage(),\n-          CoreMatchers.startsWith(\n-              \"Both 'bootJar' and 'jar' tasks are enabled, but they write their jar file into the \"\n-                  + \"same location at \"));\n-      MatcherAssert.assertThat(\n-          ex.getCause().getMessage(),\n-          CoreMatchers.endsWith(\n-              \"root.jar. Did you forget to set 'archiveClassifier' on either task?\"));\n-    }\n+    Exception exception = assertThrows(GradleException.class, () -> tasks.getByPath(\":jar\"));\n+    assertThat(exception.getCause())\n+        .hasMessageThat()\n+        .startsWith(\n+            \"Both 'bootJar' and 'jar' tasks are enabled, but they write their jar file into the \"\n+                + \"same location at \");\n+    assertThat(exception.getCause())\n+        .hasMessageThat()\n+        .endsWith(\"root.jar. Did you forget to set 'archiveClassifier' on either task?\");\n   }\n \n   @Test\n@@ -298,8 +276,8 @@ public void testSpringBootJarProject_packagedMode_jarEnabledAndClassifierSet() {\n     jarTask.configure(task -> ((Jar) task).getArchiveClassifier().set(\"jar-classifier\"));\n \n     Jar jar = (Jar) project.getTasks().getByPath(\":jar\");\n-    Assert.assertTrue(jar.getEnabled());\n-    Assert.assertEquals(\"jar-classifier\", jar.getArchiveClassifier().get());\n+    assertThat(jar.getEnabled()).isTrue();\n+    assertThat(jar.getArchiveClassifier().get()).isEqualTo(\"jar-classifier\");\n   }\n \n   @Test\n@@ -311,9 +289,9 @@ public void testSpringBootJarProject_packagedMode_jarEnabledAndBootJarClassifier\n     TaskProvider<Task> bootJarTask = project.getTasks().named(\"bootJar\");\n     bootJarTask.configure(task -> ((Jar) task).getArchiveClassifier().set(\"boot-classifier\"));\n \n-    Jar jarTask = (Jar) project.getTasks().getByPath(\":jar\");\n-    Assert.assertTrue(jarTask.getEnabled());\n-    Assert.assertEquals(\"\", jarTask.getArchiveClassifier().get());\n+    Jar jar = (Jar) project.getTasks().getByPath(\":jar\");\n+    assertThat(jar.getEnabled()).isTrue();\n+    assertThat(jar.getArchiveClassifier().get()).isEmpty();\n   }\n \n   @Test\n@@ -326,9 +304,9 @@ public void testSpringBootJarProject_packagedMode_jarEnabledAndBootJarDisabled()\n     project.getTasks().named(\"bootJar\").configure(task -> task.setEnabled(false));\n \n     Jar jar = (Jar) project.getTasks().getByPath(\":jar\");\n-    Assert.assertTrue(jar.getEnabled());\n-    Assert.assertFalse(project.getTasks().getByPath(\":bootJar\").getEnabled());\n-    Assert.assertEquals(\"\", jar.getArchiveClassifier().get());\n+    assertThat(jar.getEnabled()).isTrue();\n+    assertThat(project.getTasks().getByPath(\":bootJar\").getEnabled()).isFalse();\n+    assertThat(jar.getArchiveClassifier().get()).isEmpty();\n   }\n \n   @Test\n@@ -344,22 +322,18 @@ public void testSpringBootJarProject_packagedMode_jarEnabledAndBootJarDisabled()\n     project.getTasks().named(\"bootJar\").configure(task -> task.setEnabled(false));\n \n     Jar jar = (Jar) project.getTasks().getByPath(\":jar\");\n-    Assert.assertTrue(jar.getEnabled());\n-    Assert.assertFalse(project.getTasks().getByPath(\":bootJar\").getEnabled());\n-    Assert.assertEquals(\"jar-classifier\", jar.getArchiveClassifier().get());\n+    assertThat(jar.getEnabled()).isTrue();\n+    assertThat(project.getTasks().getByPath(\":bootJar\").getEnabled()).isFalse();\n+    assertThat(jar.getArchiveClassifier().get()).isEqualTo(\"jar-classifier\");\n   }\n \n   @Test\n   public void testNonWebAppProject() {\n     Project project = createProject(\"java\", \"com.google.cloud.tools.jib\");\n \n     TaskContainer tasks = project.getTasks();\n-    try {\n-      tasks.getByPath(\":war\");\n-      Assert.fail();\n-    } catch (UnknownTaskException ex) {\n-      Assert.assertNotNull(ex.getMessage());\n-    }\n+    Exception exception = assertThrows(UnknownTaskException.class, () -> tasks.getByPath(\":war\"));\n+    assertThat(exception).hasMessageThat().isNotNull();\n   }\n \n   @Test\n@@ -368,26 +342,23 @@ public void testJibTaskGroupIsSet() {\n \n     TaskContainer tasks = project.getTasks();\n     KNOWN_JIB_TASKS.forEach(\n-        taskName -> Assert.assertEquals(taskName, \"Jib\", tasks.getByPath(taskName).getGroup()));\n+        taskName -> assertThat(tasks.getByPath(taskName).getGroup()).isEqualTo(\"Jib\"));\n   }\n \n   @Test\n   public void testLazyEvalForImageAndTags() {\n     // TODO: Pass in `-Djib.console=plain` as argument for build and remove filtering for cyan\n     // coloring regex once [#2764](https://github.com/GoogleContainerTools/jib/issues/2764) is\n     // submitted.\n-    try {\n-      testProject.build(JibPlugin.BUILD_IMAGE_TASK_NAME);\n-      Assert.fail(\"Expect this to fail\");\n-    } catch (UnexpectedBuildFailure ex) {\n-      String output = ex.getBuildResult().getOutput().trim();\n-      String cleanOutput = output.replace(\"\\u001B[36m\", \"\").replace(\"\\u001B[0m\", \"\");\n-\n-      MatcherAssert.assertThat(\n-          cleanOutput,\n-          CoreMatchers.containsString(\n-              \"Containerizing application to updated-image, updated-image:updated-tag, updated-image:tag2\"));\n-    }\n+    UnexpectedBuildFailure exception =\n+        assertThrows(\n+            UnexpectedBuildFailure.class, () -> testProject.build(JibPlugin.BUILD_IMAGE_TASK_NAME));\n+\n+    String output = exception.getBuildResult().getOutput().trim();\n+    String cleanOutput = output.replace(\"\\u001B[36m\", \"\").replace(\"\\u001B[0m\", \"\");\n+    assertThat(cleanOutput)\n+        .contains(\n+            \"Containerizing application to updated-image, updated-image:updated-tag, updated-image:tag2\");\n   }\n \n   private Project createProject(String... plugins) {",
      "parent_sha": "f884fa1bed7cb31871cff8a5f919d781660eedf2"
    }
  },
  {
    "oid": "4a31c035a0b6ceea0cef62bcae8b77380fb3c591",
    "message": "Avoid duplicated call (#3718)",
    "date": "2022-08-02T14:49:10Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/4a31c035a0b6ceea0cef62bcae8b77380fb3c591",
    "details": {
      "sha": "2a6676e1d2decb1a773bc69cd25f11b88f861864",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/LocalBaseImageSteps.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/4a31c035a0b6ceea0cef62bcae8b77380fb3c591/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FLocalBaseImageSteps.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/4a31c035a0b6ceea0cef62bcae8b77380fb3c591/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FLocalBaseImageSteps.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FLocalBaseImageSteps.java?ref=4a31c035a0b6ceea0cef62bcae8b77380fb3c591",
      "patch": "@@ -119,7 +119,7 @@ static Callable<LocalImage> retrieveDockerDaemonLayersStep(\n         }\n \n         Path tarPath = tempDirectoryProvider.newDirectory().resolve(\"out.tar\");\n-        long size = dockerClient.inspect(imageReference).getSize();\n+        long size = dockerImageDetails.getSize();\n         try (ProgressEventDispatcher dockerProgress =\n                 progressEventDispatcher\n                     .newChildProducer()",
      "parent_sha": "9027c8dafb8ee12b9d37e1521caf62dfbcc3d374"
    }
  },
  {
    "oid": "ce518164c227bfcdf150b3fbd621f45fdcdf4376",
    "message": "Fix last modified time test (#2364)",
    "date": "2020-03-26T22:19:06Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/ce518164c227bfcdf150b3fbd621f45fdcdf4376",
    "details": {
      "sha": "fcf04122000bb7177b77f7e3967a843d89fcfac8",
      "filename": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/LayerDefinitionParserTest.java",
      "status": "modified",
      "additions": 17,
      "deletions": 11,
      "changes": 28,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/ce518164c227bfcdf150b3fbd621f45fdcdf4376/jib-cli%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2FLayerDefinitionParserTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/ce518164c227bfcdf150b3fbd621f45fdcdf4376/jib-cli%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2FLayerDefinitionParserTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-cli%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2FLayerDefinitionParserTest.java?ref=ce518164c227bfcdf150b3fbd621f45fdcdf4376",
      "patch": "@@ -210,28 +210,34 @@ public void testConvert_sourceDestinationPermissions() throws Exception {\n \n   @Test\n   public void testConvert_sourceDestinationTimestamps() throws Exception {\n-    File root = temporaryFolder.getRoot();\n-    File subdir = new File(root, \"sub\");\n-    Assert.assertTrue(subdir.mkdir());\n-    File file = new File(subdir, \"file.txt\");\n-    Files.copy(new ByteArrayInputStream(\"foo\".getBytes(StandardCharsets.UTF_8)), file.toPath());\n+    Path root = temporaryFolder.getRoot().toPath();\n+    Path subdir = root.resolve(\"sub\");\n+    Files.createDirectory(subdir);\n+    Path file = subdir.resolve(\"file.txt\");\n+    Files.copy(new ByteArrayInputStream(\"foo\".getBytes(StandardCharsets.UTF_8)), file);\n \n     FileEntriesLayer result = fixture.convert(root.toString() + \",/dest,timestamps=actual\");\n     Assert.assertEquals(3, result.getEntries().size());\n \n     FileEntry layerEntry = result.getEntries().get(0);\n-    Assert.assertEquals(root.toPath(), layerEntry.getSourceFile());\n+    Assert.assertEquals(root, layerEntry.getSourceFile());\n     Assert.assertEquals(AbsoluteUnixPath.get(\"/dest\"), layerEntry.getExtractionPath());\n-    Assert.assertEquals(root.lastModified(), layerEntry.getModificationTime().toEpochMilli());\n+    Assert.assertEquals(\n+        Files.getLastModifiedTime(root).toMillis(),\n+        layerEntry.getModificationTime().toEpochMilli());\n \n     layerEntry = result.getEntries().get(1);\n-    Assert.assertEquals(subdir.toPath(), layerEntry.getSourceFile());\n+    Assert.assertEquals(subdir, layerEntry.getSourceFile());\n     Assert.assertEquals(AbsoluteUnixPath.get(\"/dest/sub\"), layerEntry.getExtractionPath());\n-    Assert.assertEquals(subdir.lastModified(), layerEntry.getModificationTime().toEpochMilli());\n+    Assert.assertEquals(\n+        Files.getLastModifiedTime(subdir).toMillis(),\n+        layerEntry.getModificationTime().toEpochMilli());\n \n     layerEntry = result.getEntries().get(2);\n-    Assert.assertEquals(file.toPath(), layerEntry.getSourceFile());\n+    Assert.assertEquals(file, layerEntry.getSourceFile());\n     Assert.assertEquals(AbsoluteUnixPath.get(\"/dest/sub/file.txt\"), layerEntry.getExtractionPath());\n-    Assert.assertEquals(file.lastModified(), layerEntry.getModificationTime().toEpochMilli());\n+    Assert.assertEquals(\n+        Files.getLastModifiedTime(file).toMillis(),\n+        layerEntry.getModificationTime().toEpochMilli());\n   }\n }",
      "parent_sha": "1d11799c6b7900a756f3369dd30a470b03f547dd"
    }
  },
  {
    "oid": "ee2e25c79ccc053999efb4de544db3c3aabd409a",
    "message": "fix test (#2099)",
    "date": "2019-10-24T21:34:02Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/ee2e25c79ccc053999efb4de544db3c3aabd409a",
    "details": {
      "sha": "74fab1eb8c133a27cbbc4f369f2cfd466978dc78",
      "filename": "jib-core/src/test/java/com/google/cloud/tools/jib/registry/RegistryAuthenticatorTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/ee2e25c79ccc053999efb4de544db3c3aabd409a/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FRegistryAuthenticatorTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/ee2e25c79ccc053999efb4de544db3c3aabd409a/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FRegistryAuthenticatorTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FRegistryAuthenticatorTest.java?ref=ee2e25c79ccc053999efb4de544db3c3aabd409a",
      "patch": "@@ -218,7 +218,7 @@ public void testUserAgent()\n   @Test\n   public void testSourceImage_differentSourceRepository()\n       throws IOException, InterruptedException, GeneralSecurityException, URISyntaxException {\n-    try (TestWebServer server = new TestWebServer(false)) {\n+    try (TestWebServer server = new TestWebServer(false, 2)) {\n       try {\n         RegistryEndpointRequestProperties registryEndpointRequestProperties =\n             new RegistryEndpointRequestProperties(\"someserver\", \"someimage\", \"anotherimage\");\n@@ -235,7 +235,7 @@ public void testSourceImage_differentSourceRepository()\n       Assert.assertThat(\n           server.getInputRead(),\n           CoreMatchers.containsString(\n-              \"scope=repository:someimage:pull,push&scope=repository:anotherimage:pull\"));\n+              \"scope=repository:someimage:pull,push&scope=repository:anotherimage:pull \"));\n     }\n   }\n ",
      "parent_sha": "1e86c61b6708729e1afedeb692edd941c7c8ac3f"
    }
  },
  {
    "oid": "d455edee4c0b9995fee1ab0d92abb9ad60dc52ca",
    "message": "Remove unthrown exception (#602)",
    "date": "2018-07-13T16:19:04Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/d455edee4c0b9995fee1ab0d92abb9ad60dc52ca",
    "details": {
      "sha": "cecf83e1f2acd9416acb383e652521fc883d2031",
      "filename": "jib-maven-plugin/src/test/java/com/google/cloud/tools/jib/maven/MavenSourceFilesConfigurationTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/d455edee4c0b9995fee1ab0d92abb9ad60dc52ca/jib-maven-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FMavenSourceFilesConfigurationTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/d455edee4c0b9995fee1ab0d92abb9ad60dc52ca/jib-maven-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FMavenSourceFilesConfigurationTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-maven-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FMavenSourceFilesConfigurationTest.java?ref=d455edee4c0b9995fee1ab0d92abb9ad60dc52ca",
      "patch": "@@ -27,7 +27,6 @@\n import org.apache.maven.artifact.Artifact;\n import org.apache.maven.model.Build;\n import org.apache.maven.project.MavenProject;\n-import org.codehaus.plexus.component.repository.exception.ComponentLookupException;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Rule;\n@@ -49,7 +48,7 @@ public class MavenSourceFilesConfigurationTest {\n   private MavenSourceFilesConfiguration testMavenSourceFilesConfiguration;\n \n   @Before\n-  public void setUp() throws IOException, URISyntaxException, ComponentLookupException {\n+  public void setUp() throws IOException, URISyntaxException {\n     Path sourcePath = Paths.get(Resources.getResource(\"application/source\").toURI());\n     Path outputPath = Paths.get(Resources.getResource(\"application/output\").toURI());\n ",
      "parent_sha": "ec9edc41371a81d16a021f8e2aa156ee256e8d5a"
    }
  },
  {
    "oid": "0a195610f93ef771fd319032cc79edaec17259ba",
    "message": "improve manifest list error message with help links (#2409)\n\n* improve manifest list error message with help links",
    "date": "2020-04-16T19:57:50Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/0a195610f93ef771fd319032cc79edaec17259ba",
    "details": {
      "sha": "ccc4b52d08fd7b77c6cea24527b236361c335b2c",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PullBaseImageStep.java",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/0a195610f93ef771fd319032cc79edaec17259ba/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPullBaseImageStep.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/0a195610f93ef771fd319032cc79edaec17259ba/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPullBaseImageStep.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPullBaseImageStep.java?ref=0a195610f93ef771fd319032cc79edaec17259ba",
      "patch": "@@ -270,8 +270,12 @@ private ManifestAndDigest<?> obtainPlatformSpecificImageManifest(\n     List<String> digests = manifestListTemplate.getDigestsForPlatform(\"amd64\", \"linux\");\n     if (digests.size() == 0) {\n       String errorMessage =\n-          \"Unable to find amd64/linux manifest in manifest list at: \"\n-              + buildContext.getBaseImageConfiguration().getImage();\n+          buildContext.getBaseImageConfiguration().getImage()\n+              + \" is a manifest list, but the list does not contain an image manifest for amd64/linux.\"\n+              + \" If your intention was to use a non-amd64/linux base image,\"\n+              + \" see https://github.com/GoogleContainerTools/jib/blob/master/docs/faq.md#how-do-i-specify-a-platform-in-the-manifest-list-or-oci-index-of-a-base-image\"\n+              + \" to learn how to specify a manifest instead of a manifest list, until Jib fixes\"\n+              + \" https://github.com/GoogleContainerTools/jib/issues/1567 to allow specifying architecture and OS.\";\n       buildContext.getEventHandlers().dispatch(LogEvent.error(errorMessage));\n       throw new RegistryException(errorMessage);\n     }",
      "parent_sha": "b2c5a881d724c47634835c6c50234f53624086e7"
    }
  },
  {
    "oid": "74dd1e36b0dab75de1b2e5be08e4f83da64abd6b",
    "message": "fix variable naming (#1892)",
    "date": "2019-08-06T19:17:37Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/74dd1e36b0dab75de1b2e5be08e4f83da64abd6b",
    "details": {
      "sha": "433e2601047c95f57389ca59ed12f99bfee5f916",
      "filename": "jib-maven-plugin/src/test/java/com/google/cloud/tools/jib/maven/MavenProjectPropertiesTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/74dd1e36b0dab75de1b2e5be08e4f83da64abd6b/jib-maven-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FMavenProjectPropertiesTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/74dd1e36b0dab75de1b2e5be08e4f83da64abd6b/jib-maven-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FMavenProjectPropertiesTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-maven-plugin%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FMavenProjectPropertiesTest.java?ref=74dd1e36b0dab75de1b2e5be08e4f83da64abd6b",
      "patch": "@@ -676,11 +676,11 @@ private BuildConfiguration setupBuildConfiguration(\n         JavaContainerBuilder.from(RegistryImage.named(\"base\"))\n             .setAppRoot(AbsoluteUnixPath.get(appRoot))\n             .setModificationTimeProvider((ignored1, ignored2) -> SAMPLE_FILE_MODIFICATION_TIME);\n-    JibContainerBuilder JibContainerBuilder =\n+    JibContainerBuilder jibContainerBuilder =\n         new MavenProjectProperties(mockMavenProject, mockMavenSession, mockLog)\n             .createJibContainerBuilder(javaContainerBuilder, containerizingMode);\n     return JibContainerBuilderTestHelper.toBuildConfiguration(\n-        JibContainerBuilder,\n+        jibContainerBuilder,\n         Containerizer.to(RegistryImage.named(\"to\"))\n             .setExecutorService(MoreExecutors.newDirectExecutorService()));\n   }",
      "parent_sha": "187c2e038c15e52ea53366b828834c6f7fa963ef"
    }
  },
  {
    "oid": "d1a01a12706866e76d947a35a1e72652a4605207",
    "message": "Add assertions to tests (#3383)",
    "date": "2021-08-05T15:39:25Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/d1a01a12706866e76d947a35a1e72652a4605207",
    "details": {
      "sha": "a20dbc6c692eb8f0a45b094072819aa1ba1f3bd1",
      "filename": "jib-cli/src/test/java/com/google/cloud/tools/jib/cli/buildfile/CopySpecTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/d1a01a12706866e76d947a35a1e72652a4605207/jib-cli%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2Fbuildfile%2FCopySpecTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/d1a01a12706866e76d947a35a1e72652a4605207/jib-cli%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2Fbuildfile%2FCopySpecTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-cli%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2Fbuildfile%2FCopySpecTest.java?ref=d1a01a12706866e76d947a35a1e72652a4605207",
      "patch": "@@ -16,6 +16,8 @@\n \n package com.google.cloud.tools.jib.cli.buildfile;\n \n+import static com.google.common.truth.Truth.assertThat;\n+\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n@@ -207,16 +209,14 @@ public void testCopySpec_noEmptyEntries() {\n     public void testCopySpec_emptyOkay() throws JsonProcessingException {\n       String data = \"src: target/classes\\n\" + \"dest: /app/classes\\n\" + fieldName + \": []\";\n \n-      mapper.readValue(data, CopySpec.class);\n-      // pass\n+      assertThat(mapper.readValue(data, CopySpec.class)).isNotNull();\n     }\n \n     @Test\n     public void testCopySpec_nullOkay() throws JsonProcessingException {\n       String data = \"src: target/classes\\n\" + \"dest: /app/classes\\n\" + fieldName + \": null\";\n \n-      mapper.readValue(data, CopySpec.class);\n-      // pass\n+      assertThat(mapper.readValue(data, CopySpec.class)).isNotNull();\n     }\n   }\n }",
      "parent_sha": "4af346380f9cadaa635a3f9f25d88b70226b88cb"
    }
  },
  {
    "oid": "6a95e72ab01d38455de9f3c5c81049c0210ffaea",
    "message": "fix sonar blocker -- no assertion in test case. (#3377)\n\nfixes this sonar code-smell.",
    "date": "2021-08-03T21:03:15Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/6a95e72ab01d38455de9f3c5c81049c0210ffaea",
    "details": {
      "sha": "9939387c640bb5256ce72be96a62cefa3a4f59ea",
      "filename": "jib-core/src/test/java/com/google/cloud/tools/jib/configuration/ContainerConfigurationTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/6a95e72ab01d38455de9f3c5c81049c0210ffaea/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fconfiguration%2FContainerConfigurationTest.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/6a95e72ab01d38455de9f3c5c81049c0210ffaea/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fconfiguration%2FContainerConfigurationTest.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fconfiguration%2FContainerConfigurationTest.java?ref=6a95e72ab01d38455de9f3c5c81049c0210ffaea",
      "patch": "@@ -114,11 +114,11 @@ public void testBuilder_nullValues() {\n   @SuppressWarnings(\"JdkObsolete\") // for hashtable\n   public void testBuilder_environmentMapTypes() {\n     // Can accept empty environment.\n-    ContainerConfiguration.builder().setEnvironment(ImmutableMap.of()).build();\n-\n+    Assert.assertNotNull(\n+        ContainerConfiguration.builder().setEnvironment(ImmutableMap.of()).build());\n     // Can handle other map types (https://github.com/GoogleContainerTools/jib/issues/632)\n-    ContainerConfiguration.builder().setEnvironment(new TreeMap<>());\n-    ContainerConfiguration.builder().setEnvironment(new Hashtable<>());\n+    Assert.assertNotNull(ContainerConfiguration.builder().setEnvironment(new TreeMap<>()));\n+    Assert.assertNotNull(ContainerConfiguration.builder().setEnvironment(new Hashtable<>()));\n   }\n \n   @Test",
      "parent_sha": "672fc37b6812f9218f3508425e546ef57e5736c1"
    }
  },
  {
    "oid": "7486d56662165d22a92ed2860479152c6569465f",
    "message": "Make Error Prone happy (#707)",
    "date": "2018-07-24T23:00:15Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/7486d56662165d22a92ed2860479152c6569465f",
    "details": {
      "sha": "37d1e971de05c68eee527a5ef16c8f21325f56e3",
      "filename": "jib-core/src/test/java/com/google/cloud/tools/jib/http/TestWebServer.java",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/7486d56662165d22a92ed2860479152c6569465f/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fhttp%2FTestWebServer.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/7486d56662165d22a92ed2860479152c6569465f/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fhttp%2FTestWebServer.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fhttp%2FTestWebServer.java?ref=7486d56662165d22a92ed2860479152c6569465f",
      "patch": "@@ -24,6 +24,7 @@\n import java.nio.charset.StandardCharsets;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n import java.util.concurrent.Semaphore;\n \n /** Simple local web server for testing. */\n@@ -35,7 +36,7 @@ class TestWebServer implements Closeable {\n \n   TestWebServer() throws IOException, InterruptedException {\n     serverSocket = new ServerSocket(0);\n-    executorService.submit(this::serve200);\n+    ignoreReturn(executorService.submit(this::serve200));\n     threadStarted.acquire();\n   }\n \n@@ -62,4 +63,8 @@ private Void serve200() throws IOException {\n     }\n     return null;\n   }\n+\n+  private void ignoreReturn(Future<Void> future) {\n+    // do nothing; to make Error Prone happy\n+  }\n }",
      "parent_sha": "0f8dd028304e81584d482940a391fe27814c9829"
    }
  },
  {
    "oid": "c8c5e8816f0d2e16b4075437c0f1053730ed4dd7",
    "message": " Better naming for CacheMetadata identity function parameters. (#536)",
    "date": "2018-07-11T16:29:58Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/c8c5e8816f0d2e16b4075437c0f1053730ed4dd7",
    "details": {
      "sha": "fd8e38a74f37182e7a40d169f7587dfad2d2086a",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/cache/CacheMetadata.java",
      "status": "modified",
      "additions": 28,
      "deletions": 22,
      "changes": 50,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/c8c5e8816f0d2e16b4075437c0f1053730ed4dd7/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcache%2FCacheMetadata.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/c8c5e8816f0d2e16b4075437c0f1053730ed4dd7/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcache%2FCacheMetadata.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcache%2FCacheMetadata.java?ref=c8c5e8816f0d2e16b4075437c0f1053730ed4dd7",
      "patch": "@@ -23,6 +23,9 @@\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Streams;\n import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.function.BiPredicate;\n+import java.util.function.Predicate;\n import javax.annotation.Nullable;\n \n /**\n@@ -75,28 +78,31 @@ static boolean doLayerEntriesMatchMetadataEntries(\n       if (layerEntries.size() != metadataEntries.size()) {\n         return false;\n       }\n-      return Streams.zip(\n-              layerEntries.stream(),\n-              metadataEntries.stream(),\n-              (layerEntry, metadataEntry) -> {\n-                // Checks extraction path not equal.\n-                if (!layerEntry.getExtractionPath().equals(metadataEntry.getExtractionPath())) {\n-                  return true;\n-                }\n-\n-                // Checks source files not equal.\n-                if (layerEntry.getSourceFiles().size()\n-                    != metadataEntry.getSourceFilesStrings().size()) {\n-                  return true;\n-                }\n-                return Streams.zip(\n-                        layerEntry.getSourceFiles().stream(),\n-                        metadataEntry.getSourceFilesStrings().stream(),\n-                        (sourceFile, sourceFileString) ->\n-                            !sourceFile.equals(Paths.get(sourceFileString)))\n-                    .anyMatch(isNotEqual -> isNotEqual);\n-              })\n-          .noneMatch(isNotEqual -> isNotEqual);\n+      return pairwiseCompareAllPass(\n+          layerEntries,\n+          metadataEntries,\n+          (layerEntry, metadataEntry) -> {\n+            // Checks extraction path not equal.\n+            if (!layerEntry.getExtractionPath().equals(metadataEntry.getExtractionPath())) {\n+              return false;\n+            }\n+\n+            // Checks for any source file not equal.\n+            if (layerEntry.getSourceFiles().size()\n+                != metadataEntry.getSourceFilesStrings().size()) {\n+              return false;\n+            }\n+            return pairwiseCompareAllPass(\n+                layerEntry.getSourceFiles(),\n+                metadataEntry.getSourceFilesStrings(),\n+                (sourceFile, sourceFileString) -> sourceFile.equals(Paths.get(sourceFileString)));\n+          });\n+    }\n+\n+    private static <A, B> boolean pairwiseCompareAllPass(\n+        List<A> listA, List<B> listB, BiPredicate<A, B> compare) {\n+      return Streams.zip(listA.stream(), listB.stream(), compare::test)\n+          .allMatch(Predicate.isEqual(true));\n     }\n \n     private final ImageLayers<CachedLayerWithMetadata> layers;",
      "parent_sha": "1c60e74c3eb8ead475bfc469679d44835027f233"
    }
  },
  {
    "oid": "29f90e13ee0fc5687b6a7a23fd72cc4cbda54da8",
    "message": "Use artifact ID instead of project name in SkaffoldInitMojo (#2090)",
    "date": "2019-10-23T15:11:25Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/29f90e13ee0fc5687b6a7a23fd72cc4cbda54da8",
    "details": {
      "sha": "c9ff150bc7ba966399f450f668a127c163190cc6",
      "filename": "jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/skaffold/SkaffoldInitMojo.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/29f90e13ee0fc5687b6a7a23fd72cc4cbda54da8/jib-maven-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2Fskaffold%2FSkaffoldInitMojo.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/29f90e13ee0fc5687b6a7a23fd72cc4cbda54da8/jib-maven-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2Fskaffold%2FSkaffoldInitMojo.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-maven-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2Fskaffold%2FSkaffoldInitMojo.java?ref=29f90e13ee0fc5687b6a7a23fd72cc4cbda54da8",
      "patch": "@@ -47,7 +47,7 @@ public void execute() throws MojoExecutionException {\n     SkaffoldInitOutput skaffoldInitOutput = new SkaffoldInitOutput();\n     skaffoldInitOutput.setImage(getTargetImage());\n     if (project.getParent() != null && project.getParent().getFile() != null) {\n-      skaffoldInitOutput.setProject(project.getName());\n+      skaffoldInitOutput.setProject(project.getArtifactId());\n     }\n     System.out.println(\"\\nBEGIN JIB JSON\");\n     try {",
      "parent_sha": "4d8efc902d40945fe5ed296d3bf55f0d42119fef"
    }
  },
  {
    "oid": "3ba06f929cb1e6a77603d13f220c5d77d869aa78",
    "message": "Fix child progress dispatcher factory (#2699)\n\n* Fixing concurrent progress dispatcher\r\n\r\n* Removing un-related changes\r\n\r\n* Add multiple progress dispatchers for concurrent build processes\r\n\r\n* Progress Dispatcher Fix",
    "date": "2020-08-13T15:15:09Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/3ba06f929cb1e6a77603d13f220c5d77d869aa78",
    "details": {
      "sha": "70e2cacd4f5be6618246a4f6f6d568a867a1b99e",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java",
      "status": "modified",
      "additions": 61,
      "deletions": 6,
      "changes": 67,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/3ba06f929cb1e6a77603d13f220c5d77d869aa78/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FStepsRunner.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/3ba06f929cb1e6a77603d13f220c5d77d869aa78/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FStepsRunner.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FStepsRunner.java?ref=3ba06f929cb1e6a77603d13f220c5d77d869aa78",
      "patch": "@@ -304,22 +304,33 @@ private void pullBaseImages() {\n   private void obtainBaseImageLayers(boolean layersRequiredLocally) {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n+\n     results.baseImagesAndLayers =\n         executorService.submit(\n             () -> {\n+              // TODO: ideally, progressDispatcher should be closed at the right moment, after the\n+              // scheduled threads have completed. However, it can be tricky and cumbersome to track\n+              // completion, so it may just be better to delay closing until everything ends. At\n+              // least, we must ensure that it's not closed prematurely. (Garbage collection doesn't\n+              // auto-close it wit the current implementation.)\n+              ProgressEventDispatcher progressDispatcher =\n+                  childProgressDispatcherFactory.create(\n+                      \"scheduling obtaining base image layers\",\n+                      results.baseImagesAndRegistryClient.get().images.size());\n+\n               Map<Image, List<Future<PreparedLayer>>> baseImagesAndLayers = new HashMap<>();\n               for (Image image : results.baseImagesAndRegistryClient.get().images) {\n                 List<Future<PreparedLayer>> layers =\n                     scheduleCallables(\n                         layersRequiredLocally\n                             ? ObtainBaseImageLayerStep.makeListForForcedDownload(\n                                 buildContext,\n-                                childProgressDispatcherFactory,\n+                                progressDispatcher.newChildProducer(),\n                                 image,\n                                 results.baseImagesAndRegistryClient.get().registryClient)\n                             : ObtainBaseImageLayerStep.makeListForSelectiveDownload(\n                                 buildContext,\n-                                childProgressDispatcherFactory,\n+                                progressDispatcher.newChildProducer(),\n                                 image,\n                                 results.baseImagesAndRegistryClient.get().registryClient,\n                                 results.targetRegistryClient.get()));\n@@ -336,6 +347,16 @@ private void pushBaseImageLayers() {\n     results.baseImagesAndLayerPushResults =\n         executorService.submit(\n             () -> {\n+              // TODO: ideally, progressDispatcher should be closed at the right moment, after the\n+              // scheduled threads have completed. However, it can be tricky and cumbersome to track\n+              // completion, so it may just be better to delay closing until everything ends. At\n+              // least, we must ensure that it's not closed prematurely. (Garbage collection doesn't\n+              // auto-close it wit the current implementation.)\n+              ProgressEventDispatcher progressDispatcher =\n+                  childProgressDispatcherFactory.create(\n+                      \"scheduling pushing base image layers\",\n+                      results.baseImagesAndLayers.get().size());\n+\n               Map<Image, List<Future<BlobDescriptor>>> pushResults = new HashMap<>();\n               for (Map.Entry<Image, List<Future<PreparedLayer>>> entry :\n                   results.baseImagesAndLayers.get().entrySet()) {\n@@ -346,7 +367,7 @@ private void pushBaseImageLayers() {\n                     scheduleCallables(\n                         PushLayerStep.makeList(\n                             buildContext,\n-                            childProgressDispatcherFactory,\n+                            progressDispatcher.newChildProducer(),\n                             results.targetRegistryClient.get(),\n                             Verify.verifyNotNull(baseImageLayers)));\n                 pushResults.put(baseImage, baseImageLayerPushResult);\n@@ -371,15 +392,26 @@ private void buildImages() {\n     results.builtImagesAndBaseImages =\n         executorService.submit(\n             () -> {\n+              // TODO: ideally, progressDispatcher should be closed at the right moment, after the\n+              // scheduled threads have completed. However, it can be tricky and cumbersome to track\n+              // completion, so it may just be better to delay closing until everything ends. At\n+              // least, we must ensure that it's not closed prematurely. (Garbage collection doesn't\n+              // auto-close it wit the current implementation.)\n+              ProgressEventDispatcher progressDispatcher =\n+                  childProgressDispatcherFactory.create(\n+                      \"scheduling building manifests\", results.baseImagesAndLayers.get().size());\n+\n               Map<Future<Image>, Image> builtImagesAndBaseImages = new HashMap<>();\n               for (Map.Entry<Image, List<Future<PreparedLayer>>> entry :\n                   results.baseImagesAndLayers.get().entrySet()) {\n+                ProgressEventDispatcher.Factory progressDispatcherFactory =\n+                    progressDispatcher.newChildProducer();\n                 Future<Image> builtImage =\n                     executorService.submit(\n                         () ->\n                             new BuildImageStep(\n                                     buildContext,\n-                                    childProgressDispatcherFactory,\n+                                    progressDispatcherFactory,\n                                     entry.getKey(), // base Image\n                                     realizeFutures(\n                                         Verify.verifyNotNull(entry.getValue())), // layers\n@@ -398,14 +430,26 @@ private void pushContainerConfigurations() {\n     results.builtImagesAndContainerConfigurationPushResults =\n         executorService.submit(\n             () -> {\n+              // TODO: ideally, progressDispatcher should be closed at the right moment, after the\n+              // scheduled threads have completed. However, it can be tricky and cumbersome to track\n+              // completion, so it may just be better to delay closing until everything ends. At\n+              // least, we must ensure that it's not closed prematurely. (Garbage collection doesn't\n+              // auto-close it wit the current implementation.)\n+              ProgressEventDispatcher progressDispatcher =\n+                  childProgressDispatcherFactory.create(\n+                      \"scheduling pushing container configurations\",\n+                      results.builtImagesAndBaseImages.get().size());\n+\n               Map<Future<Image>, Future<BlobDescriptor>> pushResults = new HashMap<>();\n               for (Future<Image> builtImage : results.builtImagesAndBaseImages.get().keySet()) {\n+                ProgressEventDispatcher.Factory progressDispatcherFactory =\n+                    progressDispatcher.newChildProducer();\n                 Future<BlobDescriptor> configPushResult =\n                     executorService.submit(\n                         () ->\n                             new PushContainerConfigurationStep(\n                                     buildContext,\n-                                    childProgressDispatcherFactory,\n+                                    progressDispatcherFactory,\n                                     results.targetRegistryClient.get(),\n                                     builtImage.get())\n                                 .call());\n@@ -459,13 +503,24 @@ private void pushImages() {\n     results.buildResults =\n         executorService.submit(\n             () -> {\n+              // TODO: ideally, progressDispatcher should be closed at the right moment, after the\n+              // scheduled threads have completed. However, it can be tricky and cumbersome to track\n+              // completion, so it may just be better to delay closing until everything ends. At\n+              // least, we must ensure that it's not closed prematurely. (Garbage collection doesn't\n+              // auto-close it wit the current implementation.)\n+              ProgressEventDispatcher progressDispatcher =\n+                  childProgressDispatcherFactory.create(\n+                      \"scheduling pushing manifests\",\n+                      results.builtImagesAndBaseImages.get().size());\n+\n               realizeFutures(results.applicationLayerPushResults.get());\n \n               List<Future<BuildResult>> buildResults = new ArrayList<>();\n               for (Map.Entry<Future<Image>, Image> entry :\n                   results.builtImagesAndBaseImages.get().entrySet()) {\n                 buildResults.add(\n-                    pushImage(entry.getKey(), entry.getValue(), childProgressDispatcherFactory));\n+                    pushImage(\n+                        entry.getKey(), entry.getValue(), progressDispatcher.newChildProducer()));\n               }\n               return buildResults;\n             });",
      "parent_sha": "cf427cb70f0dc8b3d881033174d2df6fc0825a0b"
    }
  },
  {
    "oid": "86e1750795b19086ce73190b73473b2b1feb06e7",
    "message": "Minor refactor (#2379)",
    "date": "2020-04-02T14:14:22Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/86e1750795b19086ce73190b73473b2b1feb06e7",
    "details": {
      "sha": "42d77e33ddc9baa992d13340de3b90712659dab3",
      "filename": "jib-plugins-common/src/main/java/com/google/cloud/tools/jib/plugins/common/PluginConfigurationProcessor.java",
      "status": "modified",
      "additions": 4,
      "deletions": 7,
      "changes": 11,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/86e1750795b19086ce73190b73473b2b1feb06e7/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FPluginConfigurationProcessor.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/86e1750795b19086ce73190b73473b2b1feb06e7/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FPluginConfigurationProcessor.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-plugins-common%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fplugins%2Fcommon%2FPluginConfigurationProcessor.java?ref=86e1750795b19086ce73190b73473b2b1feb06e7",
      "patch": "@@ -31,6 +31,7 @@\n import com.google.cloud.tools.jib.api.TarImage;\n import com.google.cloud.tools.jib.api.buildplan.AbsoluteUnixPath;\n import com.google.cloud.tools.jib.api.buildplan.FileEntriesLayer;\n+import com.google.cloud.tools.jib.api.buildplan.ImageFormat;\n import com.google.cloud.tools.jib.api.buildplan.LayerObject;\n import com.google.cloud.tools.jib.frontend.CredentialRetrieverFactory;\n import com.google.cloud.tools.jib.global.JibSystemProperties;\n@@ -120,7 +121,8 @@ public static JibBuildRunner createJibBuildRunnerForDockerDaemonImage(\n     Containerizer containerizer = Containerizer.to(targetImage);\n     JibContainerBuilder jibContainerBuilder =\n         processCommonConfiguration(\n-            rawConfiguration, inferredAuthProvider, projectProperties, containerizer);\n+                rawConfiguration, inferredAuthProvider, projectProperties, containerizer)\n+            .setFormat(ImageFormat.Docker);\n \n     return JibBuildRunner.forBuildToDockerDaemon(\n             jibContainerBuilder,\n@@ -178,9 +180,6 @@ public static JibBuildRunner createJibBuildRunnerForTarImage(\n         processCommonConfiguration(\n             rawConfiguration, inferredAuthProvider, projectProperties, containerizer);\n \n-    // Note Docker build doesn't set the configured format.\n-    jibContainerBuilder.setFormat(rawConfiguration.getImageFormat());\n-\n     return JibBuildRunner.forBuildTar(\n             jibContainerBuilder,\n             containerizer,\n@@ -252,9 +251,6 @@ public static JibBuildRunner createJibBuildRunnerForRegistryImage(\n         processCommonConfiguration(\n             rawConfiguration, inferredAuthProvider, projectProperties, containerizer);\n \n-    // Note Docker build doesn't set the configured format.\n-    jibContainerBuilder.setFormat(rawConfiguration.getImageFormat());\n-\n     return JibBuildRunner.forBuildImage(\n             jibContainerBuilder,\n             containerizer,\n@@ -373,6 +369,7 @@ static JibContainerBuilder processCommonConfiguration(\n             .createJibContainerBuilder(\n                 javaContainerBuilder,\n                 getContainerizingModeChecked(rawConfiguration, projectProperties))\n+            .setFormat(rawConfiguration.getImageFormat())\n             .setEntrypoint(computeEntrypoint(rawConfiguration, projectProperties))\n             .setProgramArguments(rawConfiguration.getProgramArguments().orElse(null))\n             .setEnvironment(rawConfiguration.getEnvironment())",
      "parent_sha": "f8e4071f7123ea21ff9b235187d5ea293342a046"
    }
  },
  {
    "oid": "a5c099e48f1ecacb9be74d8b6d0ee88b79944eca",
    "message": "Make gradle nested getters public (#460)",
    "date": "2018-06-28T15:53:15Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/a5c099e48f1ecacb9be74d8b6d0ee88b79944eca",
    "details": {
      "sha": "065288823cecbc53b218c185377d97b51e1e1c40",
      "filename": "jib-gradle-plugin/src/main/java/com/google/cloud/tools/jib/gradle/JibExtension.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/a5c099e48f1ecacb9be74d8b6d0ee88b79944eca/jib-gradle-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FJibExtension.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/a5c099e48f1ecacb9be74d8b6d0ee88b79944eca/jib-gradle-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FJibExtension.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-gradle-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FJibExtension.java?ref=a5c099e48f1ecacb9be74d8b6d0ee88b79944eca",
      "patch": "@@ -189,19 +189,19 @@ String getTargetImage() {\n \n   @Nested\n   @Optional\n-  ImageConfiguration getFrom() {\n+  public ImageConfiguration getFrom() {\n     return from;\n   }\n \n   @Nested\n   @Optional\n-  ImageConfiguration getTo() {\n+  public ImageConfiguration getTo() {\n     return to;\n   }\n \n   @Nested\n   @Optional\n-  ContainerParameters getContainer() {\n+  public ContainerParameters getContainer() {\n     return container;\n   }\n ",
      "parent_sha": "369e30d0f67ceba656e7600035259f941963c688"
    }
  },
  {
    "oid": "a1a709730617a26db4203b99455403756af400ef",
    "message": "remove expression that's always false. (#3418)\n\nFixes sonar code smell.\r\nremoved classFile == null is always false. And the case where classFile is empty is covered by the catch block.",
    "date": "2021-08-13T20:11:51Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/a1a709730617a26db4203b99455403756af400ef",
    "details": {
      "sha": "9ac923e76bc0f087ff3151983dc6fcfc57204243",
      "filename": "jib-cli/src/main/java/com/google/cloud/tools/jib/cli/ArtifactProcessors.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/a1a709730617a26db4203b99455403756af400ef/jib-cli%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2FArtifactProcessors.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/a1a709730617a26db4203b99455403756af400ef/jib-cli%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2FArtifactProcessors.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-cli%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fcli%2FArtifactProcessors.java?ref=a1a709730617a26db4203b99455403756af400ef",
      "patch": "@@ -146,7 +146,7 @@ public static Integer determineJavaMajorVersion(Path jarPath) throws IOException\n                   new DataInputStream(loader.getResourceAsStream(jarEntry))) {\n \n             // Check magic number\n-            if (classFile == null || classFile.readInt() != 0xCAFEBABE) {\n+            if (classFile.readInt() != 0xCAFEBABE) {\n               throw new IllegalArgumentException(\n                   \"The class file (\" + jarEntry + \") is of an invalid format.\");\n             }",
      "parent_sha": "77b43c1f80401d8304b853d018d94b76e2a842b6"
    }
  },
  {
    "oid": "ec98737d9744d8c8c69ad80b36027b3846fdda0e",
    "message": "Adds helpful suggestion for if 'classes' task not found on project. (#448)",
    "date": "2018-06-26T17:03:40Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/ec98737d9744d8c8c69ad80b36027b3846fdda0e",
    "details": {
      "sha": "d98cabf9903e49ea6653baae2f23fc7299bb74db",
      "filename": "jib-gradle-plugin/src/main/java/com/google/cloud/tools/jib/gradle/JibPlugin.java",
      "status": "modified",
      "additions": 14,
      "deletions": 4,
      "changes": 18,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/ec98737d9744d8c8c69ad80b36027b3846fdda0e/jib-gradle-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FJibPlugin.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/ec98737d9744d8c8c69ad80b36027b3846fdda0e/jib-gradle-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FJibPlugin.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-gradle-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FJibPlugin.java?ref=ec98737d9744d8c8c69ad80b36027b3846fdda0e",
      "patch": "@@ -21,6 +21,7 @@\n import org.gradle.api.Plugin;\n import org.gradle.api.Project;\n import org.gradle.api.Task;\n+import org.gradle.api.UnknownTaskException;\n import org.gradle.util.GradleVersion;\n \n public class JibPlugin implements Plugin<Project> {\n@@ -58,11 +59,20 @@ public void apply(Project project) {\n     // Has all tasks depend on the 'classes' task.\n     project.afterEvaluate(\n         projectAfterEvaluation -> {\n-          Task classesTask = projectAfterEvaluation.getTasks().getByPath(\"classes\");\n+          try {\n+            Task classesTask = projectAfterEvaluation.getTasks().getByPath(\"classes\");\n \n-          buildImageTask.dependsOn(classesTask);\n-          dockerContextTask.dependsOn(classesTask);\n-          buildDockerTask.dependsOn(classesTask);\n+            buildImageTask.dependsOn(classesTask);\n+            dockerContextTask.dependsOn(classesTask);\n+            buildDockerTask.dependsOn(classesTask);\n+\n+          } catch (UnknownTaskException ex) {\n+            throw new GradleException(\n+                \"Could not find task 'classes' on project \"\n+                    + projectAfterEvaluation.getDisplayName()\n+                    + \" - perhaps you did not apply the 'java' plugin?\",\n+                ex);\n+          }\n         });\n   }\n ",
      "parent_sha": "db871715f7f01e872d912b568b0577848ce7ddf9"
    }
  },
  {
    "oid": "2dbfe44f9ab6f3753705f78c8640b549fb8e89fd",
    "message": "build multiple base Images concurrently (#2652)\n\n* Adding multi-image building\r\n\r\n* Fixing structure names\r\n\r\n* Style Fixes",
    "date": "2020-08-03T20:04:39Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/2dbfe44f9ab6f3753705f78c8640b549fb8e89fd",
    "details": {
      "sha": "491748d8d62459b98dfbe1ff46b0c173ba1c510d",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/StepsRunner.java",
      "status": "modified",
      "additions": 31,
      "deletions": 27,
      "changes": 58,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/2dbfe44f9ab6f3753705f78c8640b549fb8e89fd/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FStepsRunner.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/2dbfe44f9ab6f3753705f78c8640b549fb8e89fd/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FStepsRunner.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FStepsRunner.java?ref=2dbfe44f9ab6f3753705f78c8640b549fb8e89fd",
      "patch": "@@ -69,7 +69,7 @@ private static <E> Future<E> failedFuture() {\n     private Future<ImagesAndRegistryClient> baseImagesAndRegistryClient = failedFuture();\n     private Future<Map<Image, List<Future<PreparedLayer>>>> baseImagesAndLayers = failedFuture();\n     @Nullable private List<Future<PreparedLayer>> applicationLayers;\n-    private Future<Image> builtImage = failedFuture();\n+    private Future<List<Future<Image>>> builtImages = failedFuture();\n     private Future<RegistryClient> targetRegistryClient = failedFuture();\n     private Future<List<Future<BlobDescriptor>>> baseImageLayerPushResults = failedFuture();\n     private Future<List<Future<BlobDescriptor>>> applicationLayerPushResults = failedFuture();\n@@ -137,7 +137,7 @@ public StepsRunner dockerLoadSteps(DockerClient dockerClient) {\n \n     addRetrievalSteps(true); // always pull layers for docker builds\n     stepsToRun.add(this::buildAndCacheApplicationLayers);\n-    stepsToRun.add(this::buildImage);\n+    stepsToRun.add(this::buildImages);\n \n     // load to Docker\n     stepsToRun.add(() -> loadDocker(dockerClient));\n@@ -155,7 +155,7 @@ public StepsRunner tarBuildSteps(Path outputPath) {\n \n     addRetrievalSteps(true); // always pull layers for tar builds\n     stepsToRun.add(this::buildAndCacheApplicationLayers);\n-    stepsToRun.add(this::buildImage);\n+    stepsToRun.add(this::buildImages);\n \n     // create a tar\n     stepsToRun.add(() -> writeTarFile(outputPath));\n@@ -176,7 +176,7 @@ public StepsRunner registryPushSteps() {\n \n     addRetrievalSteps(layersRequiredLocally);\n     stepsToRun.add(this::buildAndCacheApplicationLayers);\n-    stepsToRun.add(this::buildImage);\n+    stepsToRun.add(this::buildImages);\n \n     // push to registry\n     stepsToRun.add(this::pushBaseImageLayers);\n@@ -230,7 +230,7 @@ private void addRetrievalSteps(boolean layersRequiredLocally) {\n \n     } else {\n       // Otherwise default to RegistryImage\n-      stepsToRun.add(this::pullBaseImage);\n+      stepsToRun.add(this::pullBaseImages);\n       stepsToRun.add(() -> obtainBaseImageLayers(layersRequiredLocally));\n     }\n   }\n@@ -290,7 +290,7 @@ private void assignLocalImageResult(Future<LocalImage> localImage) {\n                     localImage.get().layers));\n   }\n \n-  private void pullBaseImage() {\n+  private void pullBaseImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n \n@@ -355,25 +355,29 @@ private void buildAndCacheApplicationLayers() {\n                 buildContext, childProgressDispatcherFactory));\n   }\n \n-  private void buildImage() {\n+  private void buildImages() {\n     ProgressEventDispatcher.Factory childProgressDispatcherFactory =\n         Verify.verifyNotNull(rootProgressDispatcher).newChildProducer();\n-\n-    results.builtImage =\n+    results.builtImages =\n         executorService.submit(\n-            () ->\n-                new BuildImageStep(\n-                        buildContext,\n-                        childProgressDispatcherFactory,\n-                        results.baseImagesAndRegistryClient.get().images.get(0),\n-                        realizeFutures(\n-                            Verify.verifyNotNull(\n-                                results\n-                                    .baseImagesAndLayers\n-                                    .get()\n-                                    .get(results.baseImagesAndRegistryClient.get().images.get(0)))),\n-                        realizeFutures(Verify.verifyNotNull(results.applicationLayers)))\n-                    .call());\n+            () -> {\n+              List<Future<Image>> builtImages = new ArrayList<>();\n+              for (Map.Entry<Image, List<Future<PreparedLayer>>> entry :\n+                  results.baseImagesAndLayers.get().entrySet()) {\n+                Future<Image> builtImage =\n+                    executorService.submit(\n+                        () ->\n+                            new BuildImageStep(\n+                                    buildContext,\n+                                    childProgressDispatcherFactory,\n+                                    entry.getKey(),\n+                                    realizeFutures(Verify.verifyNotNull(entry.getValue())),\n+                                    realizeFutures(Verify.verifyNotNull(results.applicationLayers)))\n+                                .call());\n+                builtImages.add(builtImage);\n+              }\n+              return builtImages;\n+            });\n   }\n \n   private void pushContainerConfiguration() {\n@@ -387,7 +391,7 @@ private void pushContainerConfiguration() {\n                         buildContext,\n                         childProgressDispatcherFactory,\n                         results.targetRegistryClient.get(),\n-                        results.builtImage.get())\n+                        results.builtImages.get().get(0).get())\n                     .call());\n   }\n \n@@ -418,7 +422,7 @@ private void checkImageInTargetRegistry() {\n                         childProgressDispatcherFactory,\n                         results.targetRegistryClient.get(),\n                         results.containerConfigurationPushResult.get(),\n-                        results.builtImage.get())\n+                        results.builtImages.get().get(0).get())\n                     .call());\n   }\n \n@@ -439,7 +443,7 @@ private void pushImages() {\n                           childProgressDispatcherFactory,\n                           results.targetRegistryClient.get(),\n                           results.containerConfigurationPushResult.get(),\n-                          results.builtImage.get(),\n+                          results.builtImages.get().get(0).get(),\n                           results.manifestCheckResult.get().isPresent()));\n               realizeFutures(manifestPushResults);\n               return manifestPushResults.isEmpty()\n@@ -462,7 +466,7 @@ private void loadDocker(DockerClient dockerClient) {\n                         buildContext,\n                         childProgressDispatcherFactory,\n                         dockerClient,\n-                        results.builtImage.get())\n+                        results.builtImages.get().get(0).get())\n                     .call());\n   }\n \n@@ -477,7 +481,7 @@ private void writeTarFile(Path outputPath) {\n                         buildContext,\n                         childProgressDispatcherFactory,\n                         outputPath,\n-                        results.builtImage.get())\n+                        results.builtImages.get().get(0).get())\n                     .call());\n   }\n ",
      "parent_sha": "a98cdfebdb3519216b079630059960c2fa49442a"
    }
  },
  {
    "oid": "c9de0092bd5c75c9c4c26a5d85a1e3e6ba31b5d1",
    "message": "Adapting push image steps to use the manifest digest instead of tags when pushing for images for manifest list. (#2713)\n\n* Adding abbility to push untagged images for a manifest list\r\n\r\n* Updating progress dispatcher\r\n\r\n* Refactor code\r\n\r\n* Renaming the tag to qualifier\r\n\r\nCo-authored-by: Chanseok Oh <chanseok@google.com>",
    "date": "2020-08-21T21:23:15Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/c9de0092bd5c75c9c4c26a5d85a1e3e6ba31b5d1",
    "details": {
      "sha": "8df7308856b0f0834b9f38439d9c6c6496a82b76",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/PushImageStep.java",
      "status": "modified",
      "additions": 18,
      "deletions": 12,
      "changes": 30,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/c9de0092bd5c75c9c4c26a5d85a1e3e6ba31b5d1/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPushImageStep.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/c9de0092bd5c75c9c4c26a5d85a1e3e6ba31b5d1/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPushImageStep.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FPushImageStep.java?ref=c9de0092bd5c75c9c4c26a5d85a1e3e6ba31b5d1",
      "patch": "@@ -32,6 +32,7 @@\n import com.google.cloud.tools.jib.registry.RegistryClient;\n import com.google.common.collect.ImmutableList;\n import java.io.IOException;\n+import java.util.Collections;\n import java.util.Set;\n import java.util.concurrent.Callable;\n \n@@ -51,13 +52,15 @@ static ImmutableList<PushImageStep> makeList(\n       Image builtImage,\n       boolean manifestAlreadyExists)\n       throws IOException {\n+    boolean singlePlatform = buildContext.getContainerConfiguration().getPlatforms().size() == 1;\n     Set<String> tags = buildContext.getAllTargetImageTags();\n+    int numPushers = singlePlatform ? tags.size() : 1;\n \n     EventHandlers eventHandlers = buildContext.getEventHandlers();\n     try (TimerEventDispatcher ignored =\n             new TimerEventDispatcher(eventHandlers, \"Preparing manifest pushers\");\n-        ProgressEventDispatcher progressEventDispatcher =\n-            progressEventDispatcherFactory.create(\"launching manifest pushers\", tags.size())) {\n+        ProgressEventDispatcher progressDispatcher =\n+            progressEventDispatcherFactory.create(\"launching manifest pushers\", numPushers)) {\n \n       if (JibSystemProperties.skipExistingImages() && manifestAlreadyExists) {\n         eventHandlers.dispatch(\n@@ -73,15 +76,18 @@ static ImmutableList<PushImageStep> makeList(\n \n       DescriptorDigest manifestDigest = Digests.computeJsonDigest(manifestTemplate);\n \n-      return tags.stream()\n+      Set<String> imageQualifiers =\n+          singlePlatform ? tags : Collections.singleton(manifestDigest.toString());\n+      return imageQualifiers\n+          .stream()\n           .map(\n-              tag ->\n+              qualifier ->\n                   new PushImageStep(\n                       buildContext,\n-                      progressEventDispatcher.newChildProducer(),\n+                      progressDispatcher.newChildProducer(),\n                       registryClient,\n                       manifestTemplate,\n-                      tag,\n+                      qualifier,\n                       manifestDigest,\n                       containerConfigurationDigestAndSize.getDigest()))\n           .collect(ImmutableList.toImmutableList());\n@@ -93,7 +99,7 @@ static ImmutableList<PushImageStep> makeList(\n \n   private final BuildableManifestTemplate manifestTemplate;\n   private final RegistryClient registryClient;\n-  private final String tag;\n+  private final String imageQualifier;\n   private final DescriptorDigest imageDigest;\n   private final DescriptorDigest imageId;\n \n@@ -102,14 +108,14 @@ static ImmutableList<PushImageStep> makeList(\n       ProgressEventDispatcher.Factory progressEventDispatcherFactory,\n       RegistryClient registryClient,\n       BuildableManifestTemplate manifestTemplate,\n-      String tag,\n+      String imageQualifier,\n       DescriptorDigest imageDigest,\n       DescriptorDigest imageId) {\n     this.buildContext = buildContext;\n     this.progressEventDispatcherFactory = progressEventDispatcherFactory;\n     this.registryClient = registryClient;\n     this.manifestTemplate = manifestTemplate;\n-    this.tag = tag;\n+    this.imageQualifier = imageQualifier;\n     this.imageDigest = imageDigest;\n     this.imageId = imageId;\n   }\n@@ -119,10 +125,10 @@ public BuildResult call() throws IOException, RegistryException {\n     EventHandlers eventHandlers = buildContext.getEventHandlers();\n     try (TimerEventDispatcher ignored = new TimerEventDispatcher(eventHandlers, DESCRIPTION);\n         ProgressEventDispatcher ignored2 =\n-            progressEventDispatcherFactory.create(\"pushing manifest for \" + tag, 1)) {\n-      eventHandlers.dispatch(LogEvent.info(\"Pushing manifest for \" + tag + \"...\"));\n+            progressEventDispatcherFactory.create(\"pushing manifest for \" + imageQualifier, 1)) {\n+      eventHandlers.dispatch(LogEvent.info(\"Pushing manifest for \" + imageQualifier + \"...\"));\n \n-      registryClient.pushManifest(manifestTemplate, tag);\n+      registryClient.pushManifest(manifestTemplate, imageQualifier);\n       return new BuildResult(imageDigest, imageId);\n     }\n   }",
      "parent_sha": "48ba32bf63401211d9091370732380c54aae020d"
    }
  },
  {
    "oid": "4c51b4250cbdb357a9630187e9aa3c3633cbbcf3",
    "message": "Rename Maven extension config name (#2448)",
    "date": "2020-05-05T17:32:08Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/4c51b4250cbdb357a9630187e9aa3c3633cbbcf3",
    "details": {
      "sha": "cbd5ceded77301c2392948b8261952b65a551522",
      "filename": "jib-maven-plugin/src/main/java/com/google/cloud/tools/jib/maven/JibPluginConfiguration.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/4c51b4250cbdb357a9630187e9aa3c3633cbbcf3/jib-maven-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FJibPluginConfiguration.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/4c51b4250cbdb357a9630187e9aa3c3633cbbcf3/jib-maven-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FJibPluginConfiguration.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-maven-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fmaven%2FJibPluginConfiguration.java?ref=4c51b4250cbdb357a9630187e9aa3c3633cbbcf3",
      "patch": "@@ -271,7 +271,7 @@ public Map<String, String> getProperties() {\n   @Parameter(property = PropertyNames.SKIP)\n   private boolean skip;\n \n-  @Parameter private List<ExtensionParameters> extensions = Collections.emptyList();\n+  @Parameter private List<ExtensionParameters> pluginExtensions = Collections.emptyList();\n \n   @Component protected SettingsDecrypter settingsDecrypter;\n \n@@ -675,7 +675,7 @@ boolean isSkipped() {\n   }\n \n   List<ExtensionParameters> getPluginExtensions() {\n-    return extensions;\n+    return pluginExtensions;\n   }\n \n   /**",
      "parent_sha": "2b6f6ca9523590ca90f54c996762c687fbc5a1b0"
    }
  },
  {
    "oid": "4005c45ff437973d0481244034f806c7b71164ec",
    "message": "Removes UncheckedIOException hack in DirectoryWalker. (#165)",
    "date": "2018-03-14T16:14:48Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/4005c45ff437973d0481244034f806c7b71164ec",
    "details": {
      "sha": "5fd45e84c977cb556decdb94832a2bdcbe165259",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/filesystem/DirectoryWalker.java",
      "status": "modified",
      "additions": 9,
      "deletions": 15,
      "changes": 24,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/4005c45ff437973d0481244034f806c7b71164ec/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Ffilesystem%2FDirectoryWalker.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/4005c45ff437973d0481244034f806c7b71164ec/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Ffilesystem%2FDirectoryWalker.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Ffilesystem%2FDirectoryWalker.java?ref=4005c45ff437973d0481244034f806c7b71164ec",
      "patch": "@@ -17,9 +17,11 @@\n package com.google.cloud.tools.jib.filesystem;\n \n import java.io.IOException;\n-import java.io.UncheckedIOException;\n import java.nio.file.Files;\n+import java.nio.file.NotDirectoryException;\n import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n /** Recursively applies a function to each file in a directory. */\n@@ -28,9 +30,9 @@ public class DirectoryWalker {\n   private final Path rootDir;\n \n   /** Initialize with a root directory to walk. */\n-  public DirectoryWalker(Path rootDir) {\n+  public DirectoryWalker(Path rootDir) throws NotDirectoryException {\n     if (!Files.isDirectory(rootDir)) {\n-      throw new IllegalArgumentException(\"rootDir must be a directory\");\n+      throw new NotDirectoryException(rootDir + \" is not a directory\");\n     }\n     this.rootDir = rootDir;\n   }\n@@ -41,18 +43,10 @@ public DirectoryWalker(Path rootDir) {\n    */\n   public void walk(PathConsumer pathConsumer) throws IOException {\n     try (Stream<Path> fileStream = Files.walk(rootDir)) {\n-      fileStream.forEach(\n-          path -> {\n-            try {\n-              pathConsumer.accept(path);\n-\n-            } catch (IOException ex) {\n-              throw new UncheckedIOException(ex);\n-            }\n-          });\n-\n-    } catch (UncheckedIOException ex) {\n-      throw ex.getCause();\n+      List<Path> files = fileStream.collect(Collectors.toList());\n+      for (Path path : files) {\n+        pathConsumer.accept(path);\n+      }\n     }\n   }\n }",
      "parent_sha": "4e0240669b951ae748e53a3ac72a575d6e3acf7b"
    }
  },
  {
    "oid": "e60c485e43513090d968a8f87a3ec528f3f3c1ce",
    "message": "Remove recursion from files task (#1052)",
    "date": "2018-09-27T17:53:30Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/e60c485e43513090d968a8f87a3ec528f3f3c1ce",
    "details": {
      "sha": "9a4e5347c1381f81d516afe7a0092a5c57e7a74a",
      "filename": "jib-gradle-plugin/src/main/java/com/google/cloud/tools/jib/gradle/FilesTask.java",
      "status": "modified",
      "additions": 27,
      "deletions": 16,
      "changes": 43,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/e60c485e43513090d968a8f87a3ec528f3f3c1ce/jib-gradle-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FFilesTask.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/e60c485e43513090d968a8f87a3ec528f3f3c1ce/jib-gradle-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FFilesTask.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-gradle-plugin%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fgradle%2FFilesTask.java?ref=e60c485e43513090d968a8f87a3ec528f3f3c1ce",
      "patch": "@@ -20,6 +20,8 @@\n import java.io.File;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n import java.util.HashSet;\n import java.util.Set;\n import javax.annotation.Nullable;\n@@ -96,25 +98,35 @@ private static void printProjectFiles(Project project) {\n   }\n \n   /**\n-   * Recursive function for printing out a project's artifacts. Calls itself when it encounters a\n-   * project dependency.\n+   * Collects a project's project dependencies, including all transitive project dependencies.\n    *\n-   * @param project the project to list the artifacts for\n-   * @param projectDependenciesResult the set of project dependencies encountered. When a project\n-   *     dependency is encountered, it is added to this set.\n+   * @param project the project to find the project dependencies for\n+   * @return the set of project dependencies\n    */\n-  private static void findProjectDependencies(\n-      Project project, Set<ProjectDependency> projectDependenciesResult) {\n-    for (Configuration configuration :\n-        project.getConfigurations().getByName(\"runtime\").getHierarchy()) {\n-      for (Dependency dependency : configuration.getDependencies()) {\n-        if (dependency instanceof ProjectDependency) {\n-          projectDependenciesResult.add((ProjectDependency) dependency);\n-          findProjectDependencies(\n-              ((ProjectDependency) dependency).getDependencyProject(), projectDependenciesResult);\n+  private static Set<ProjectDependency> findProjectDependencies(Project project) {\n+    Set<ProjectDependency> projectDependencies = new HashSet<>();\n+    Deque<Project> projects = new ArrayDeque<>();\n+    projects.push(project);\n+\n+    while (!projects.isEmpty()) {\n+      Project currentProject = projects.pop();\n+\n+      // Search through all dependencies\n+      for (Configuration configuration :\n+          currentProject.getConfigurations().getByName(\"runtime\").getHierarchy()) {\n+        for (Dependency dependency : configuration.getDependencies()) {\n+          if (dependency instanceof ProjectDependency) {\n+            // If this is a project dependency, save it\n+            ProjectDependency projectDependency = (ProjectDependency) dependency;\n+            if (!projectDependencies.contains(projectDependency)) {\n+              projects.push(projectDependency.getDependencyProject());\n+              projectDependencies.add(projectDependency);\n+            }\n+          }\n         }\n       }\n     }\n+    return projectDependencies;\n   }\n \n   @Nullable private JibExtension jibExtension;\n@@ -142,8 +154,7 @@ public void listFiles() {\n     }\n \n     // Find project dependencies\n-    Set<ProjectDependency> projectDependencies = new HashSet<>();\n-    findProjectDependencies(project, projectDependencies);\n+    Set<ProjectDependency> projectDependencies = findProjectDependencies(project);\n \n     Set<File> projectDependencyJars = new HashSet<>();\n     for (ProjectDependency projectDependency : projectDependencies) {",
      "parent_sha": "6f69b50bb28521f706c9a2ffe7011e77d142c81a"
    }
  },
  {
    "oid": "084c428efa91c93f4a384cd8313aea392355ddee",
    "message": "fix javadoc comment for manifest list json template (#1810)\n\n* fix javadoc comment for manifest list json template",
    "date": "2019-06-25T17:24:19Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/084c428efa91c93f4a384cd8313aea392355ddee",
    "details": {
      "sha": "f758411e27ce020f39446ba4bbd62749c2948f65",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/image/json/V22ManifestListTemplate.java",
      "status": "modified",
      "additions": 1,
      "deletions": 7,
      "changes": 8,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/084c428efa91c93f4a384cd8313aea392355ddee/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fimage%2Fjson%2FV22ManifestListTemplate.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/084c428efa91c93f4a384cd8313aea392355ddee/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fimage%2Fjson%2FV22ManifestListTemplate.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fimage%2Fjson%2FV22ManifestListTemplate.java?ref=084c428efa91c93f4a384cd8313aea392355ddee",
      "patch": "@@ -92,13 +92,7 @@ public List<String> getDigestsForPlatform(String architecture, String os) {\n         .collect(Collectors.toList());\n   }\n \n-  /**\n-   * Template for inner JSON object representing content descriptor for a layer or container\n-   * configuration.\n-   *\n-   * @see <a href=\"https://github.com/opencontainers/image-spec/blob/master/descriptor.md\">OCI\n-   *     Content Descriptors</a>\n-   */\n+  /** Template for inner JSON object representing a single platform specific manifest. */\n   static class ManifestDescriptorTemplate implements JsonTemplate {\n \n     @JsonIgnoreProperties(ignoreUnknown = true)",
      "parent_sha": "740c2acca5485aa547abe32791a4614155382217"
    }
  },
  {
    "oid": "bf805cda9e2b2fcc9f0d3b6d5f914e22aff7fcbb",
    "message": "Fix registry credential retrieval order (#402)",
    "date": "2018-06-14T19:30:25Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/bf805cda9e2b2fcc9f0d3b6d5f914e22aff7fcbb",
    "details": {
      "sha": "4dcccec735eee02cbb930a719662ff9837832cc6",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/builder/steps/RetrieveRegistryCredentialsStep.java",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/bf805cda9e2b2fcc9f0d3b6d5f914e22aff7fcbb/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FRetrieveRegistryCredentialsStep.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/bf805cda9e2b2fcc9f0d3b6d5f914e22aff7fcbb/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FRetrieveRegistryCredentialsStep.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fbuilder%2Fsteps%2FRetrieveRegistryCredentialsStep.java?ref=bf805cda9e2b2fcc9f0d3b6d5f914e22aff7fcbb",
      "patch": "@@ -138,18 +138,6 @@ public Authorization call() throws IOException, NonexistentDockerCredentialHelpe\n         return knownRegistryCredentials.getAuthorization();\n       }\n \n-      // Tries to get registry credentials from the Docker config.\n-      try {\n-        Authorization dockerConfigAuthorization = dockerConfigCredentialRetriever.retrieve();\n-        if (dockerConfigAuthorization != null) {\n-          buildLogger.info(\"Using credentials from Docker config for \" + registry);\n-          return dockerConfigAuthorization;\n-        }\n-\n-      } catch (IOException ex) {\n-        buildLogger.info(\"Unable to parse Docker config\");\n-      }\n-\n       // Tries to infer common credential helpers for known registries.\n       for (String registrySuffix : COMMON_CREDENTIAL_HELPERS.keySet()) {\n         if (registry.endsWith(registrySuffix)) {\n@@ -173,6 +161,18 @@ public Authorization call() throws IOException, NonexistentDockerCredentialHelpe\n         }\n       }\n \n+      // Tries to get registry credentials from the Docker config.\n+      try {\n+        Authorization dockerConfigAuthorization = dockerConfigCredentialRetriever.retrieve();\n+        if (dockerConfigAuthorization != null) {\n+          buildLogger.info(\"Using credentials from Docker config for \" + registry);\n+          return dockerConfigAuthorization;\n+        }\n+\n+      } catch (IOException ex) {\n+        buildLogger.info(\"Unable to parse Docker config\");\n+      }\n+\n       /*\n        * If no credentials found, give an info (not warning because in most cases, the base image is\n        * public and does not need extra credentials) and return null.",
      "parent_sha": "390e2edd67a87805be95a4b9f381ddbc3b9b908d"
    }
  },
  {
    "oid": "508bcdacbfc7b06ea2967d3b6c903dec59d47193",
    "message": "Fixes FileOperations#copy for possible duplicate directories. (#459)",
    "date": "2018-06-28T16:18:28Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/508bcdacbfc7b06ea2967d3b6c903dec59d47193",
    "details": {
      "sha": "2f93e5550e017e5907c493d198d8029c63ca5e52",
      "filename": "jib-core/src/main/java/com/google/cloud/tools/jib/filesystem/FileOperations.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/508bcdacbfc7b06ea2967d3b6c903dec59d47193/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Ffilesystem%2FFileOperations.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/508bcdacbfc7b06ea2967d3b6c903dec59d47193/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Ffilesystem%2FFileOperations.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Ffilesystem%2FFileOperations.java?ref=508bcdacbfc7b06ea2967d3b6c903dec59d47193",
      "patch": "@@ -38,7 +38,7 @@ public static void copy(ImmutableList<Path> sourceFiles, Path destDir) throws IO\n             // Creates the same path in the destDir.\n             Path destPath = destDir.resolve(sourceFile.getParent().relativize(path));\n             if (Files.isDirectory(path)) {\n-              Files.createDirectory(destPath);\n+              Files.createDirectories(destPath);\n             } else {\n               Files.copy(path, destPath);\n             }",
      "parent_sha": "a5c099e48f1ecacb9be74d8b6d0ee88b79944eca"
    }
  },
  {
    "oid": "cb78087f2738ab214af739b915e7279b4fcf6aa1",
    "message": "Temporary fix for registry not having htpassword (#2538)",
    "date": "2020-06-22T18:52:45Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/cb78087f2738ab214af739b915e7279b4fcf6aa1",
    "details": {
      "sha": "d84be897fb0976f0d51efa0727693192b989aec9",
      "filename": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/registry/LocalRegistry.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/cb78087f2738ab214af739b915e7279b4fcf6aa1/jib-core%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FLocalRegistry.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/cb78087f2738ab214af739b915e7279b4fcf6aa1/jib-core%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FLocalRegistry.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FLocalRegistry.java?ref=cb78087f2738ab214af739b915e7279b4fcf6aa1",
      "patch": "@@ -76,7 +76,7 @@ public void start() throws IOException, InterruptedException {\n                   \"--rm\",\n                   \"--entrypoint\",\n                   \"htpasswd\",\n-                  \"registry:2\",\n+                  \"registry:2.7.0\", // TODO: correctly fix this when using latest\n                   \"-Bbn\",\n                   username,\n                   password)",
      "parent_sha": "4fd4650c2a8fcb4b13b60bdd3ff9449235bf02e8"
    }
  },
  {
    "oid": "537d744a437c405791114bb2f51c5bb6004496f4",
    "message": "Fixes macOS auth integration test. (#836)",
    "date": "2018-08-13T22:23:59Z",
    "url": "https://github.com/GoogleContainerTools/jib/commit/537d744a437c405791114bb2f51c5bb6004496f4",
    "details": {
      "sha": "7c698d70fa2ef963b1035decf39f69b57b0f68a8",
      "filename": "jib-core/src/integration-test/java/com/google/cloud/tools/jib/registry/LocalRegistry.java",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/GoogleContainerTools/jib/blob/537d744a437c405791114bb2f51c5bb6004496f4/jib-core%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FLocalRegistry.java",
      "raw_url": "https://github.com/GoogleContainerTools/jib/raw/537d744a437c405791114bb2f51c5bb6004496f4/jib-core%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FLocalRegistry.java",
      "contents_url": "https://api.github.com/repos/GoogleContainerTools/jib/contents/jib-core%2Fsrc%2Fintegration-test%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Ftools%2Fjib%2Fregistry%2FLocalRegistry.java?ref=537d744a437c405791114bb2f51c5bb6004496f4",
      "patch": "@@ -21,6 +21,7 @@\n import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n import java.nio.file.Path;\n+import java.nio.file.Paths;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.UUID;\n@@ -73,7 +74,10 @@ protected void before() throws IOException, InterruptedException {\n                   username,\n                   password)\n               .run();\n-      Path tempFolder = Files.createTempDirectory(\"auth\");\n+      // Creates the temporary directory in /tmp since that is one of the default directories\n+      // mounted into Docker.\n+      // See: https://docs.docker.com/docker-for-mac/osxfs\n+      Path tempFolder = Files.createTempDirectory(Paths.get(\"/tmp\"), \"\");\n       Files.write(\n           tempFolder.resolve(\"htpasswd\"), credentialString.getBytes(StandardCharsets.UTF_8));\n ",
      "parent_sha": "cb64ed4f5decf00b6a0a22fb742e5c31205d34b4"
    }
  }
]