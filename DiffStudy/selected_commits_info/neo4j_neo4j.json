[
  {
    "oid": "73b85c7f29c22e3401ff95975fea3b353ee98795",
    "message": "Revert \"Tentative fix Windows build for url path in documention tests\"\n\nThis reverts commit e30d6f002fd301334b33021b7438b1271213232e.",
    "date": "2014-03-07T12:54:46Z",
    "url": "https://github.com/neo4j/neo4j/commit/73b85c7f29c22e3401ff95975fea3b353ee98795",
    "details": {
      "sha": "1d95a5cc664e4ff9f784d424d6ba097a7e3dee97",
      "filename": "community/cypher/docs/graphgist/src/test/java/org/neo4j/doc/cypherdoc/BlockTest.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/neo4j/neo4j/blob/73b85c7f29c22e3401ff95975fea3b353ee98795/community%2Fcypher%2Fdocs%2Fgraphgist%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fdoc%2Fcypherdoc%2FBlockTest.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/73b85c7f29c22e3401ff95975fea3b353ee98795/community%2Fcypher%2Fdocs%2Fgraphgist%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fdoc%2Fcypherdoc%2FBlockTest.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fcypher%2Fdocs%2Fgraphgist%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fdoc%2Fcypherdoc%2FBlockTest.java?ref=73b85c7f29c22e3401ff95975fea3b353ee98795",
      "patch": "@@ -145,7 +145,7 @@ public void graph()\n                         containsString( \"cypherdoc-xyz\" ),\n                         containsString( \".svg\" ), containsString( \"neoviz\" ) ) );\n     }\n-\n+   \n     @Test\n     public void graphWithoutId()\n     {\n@@ -226,15 +226,15 @@ public void should_replace_filenames_in_queries()\n \n         when( engine.prettify( httpQuery.capture() ) ).\n                 thenReturn( \"apa\" );\n-        state = new State( engine, database, new File( File.listRoots()[0], \"something\" ), \"http://myurl\" );\n+        state = new State( engine, database, new File( \"/dev/null\" ), \"http://myurl\" );\n         state.knownFiles.add( \"my_file.csv\" );\n \n \n         // when\n         block.process( state );\n \n         // then\n-        assertThat( fileQuery.getValue(), containsString( \"file:\" + File.listRoots()[0] + \"something/my_file.csv\" ) );\n+        assertThat( fileQuery.getValue(), containsString( \"file:/dev/null/my_file.csv\" ) );\n         assertThat( httpQuery.getValue(), containsString( \"http://myurl/my_file.csv\" ) );\n     }\n }",
      "parent_sha": "e30d6f002fd301334b33021b7438b1271213232e"
    }
  },
  {
    "oid": "73998f281162b71ec300c51682206e7c72a53049",
    "message": "Converts TestLongerShortString to junit5",
    "date": "2019-02-22T20:30:37Z",
    "url": "https://github.com/neo4j/neo4j/commit/73998f281162b71ec300c51682206e7c72a53049",
    "details": {
      "sha": "a64e49ecb7a4ed72d3bd22d9f19e33bba7e10c10",
      "filename": "community/record-storage-engine/src/test/java/org/neo4j/kernel/impl/store/TestLongerShortString.java",
      "status": "modified",
      "additions": 22,
      "deletions": 19,
      "changes": 41,
      "blob_url": "https://github.com/neo4j/neo4j/blob/73998f281162b71ec300c51682206e7c72a53049/community%2Frecord-storage-engine%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fstore%2FTestLongerShortString.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/73998f281162b71ec300c51682206e7c72a53049/community%2Frecord-storage-engine%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fstore%2FTestLongerShortString.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Frecord-storage-engine%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fstore%2FTestLongerShortString.java?ref=73998f281162b71ec300c51682206e7c72a53049",
      "patch": "@@ -19,28 +19,31 @@\n  */\n package org.neo4j.kernel.impl.store;\n \n-import org.junit.Rule;\n-import org.junit.Test;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n \n import java.util.ArrayList;\n import java.util.List;\n \n import org.neo4j.kernel.impl.store.record.PropertyBlock;\n+import org.neo4j.test.extension.Inject;\n+import org.neo4j.test.extension.RandomExtension;\n import org.neo4j.test.rule.RandomRule;\n import org.neo4j.values.storable.Values;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n import static org.neo4j.kernel.impl.store.format.standard.PropertyRecordFormat.DEFAULT_PAYLOAD_SIZE;\n \n-public class TestLongerShortString\n+@ExtendWith( RandomExtension.class )\n+class TestLongerShortString\n {\n-    @Rule\n-    public final RandomRule random = new RandomRule();\n+    @Inject\n+    protected RandomRule random;\n \n     @Test\n-    public void testMasks()\n+    void testMasks()\n     {\n         assertEquals( 0, 1 & LongerShortString.invertedBitMask( LongerShortString.NUMERICAL ) );\n         assertEquals( 0, 2 & LongerShortString.invertedBitMask( LongerShortString.DATE ) );\n@@ -51,27 +54,27 @@ public void testMasks()\n     }\n \n     @Test\n-    public void canEncodeEmptyString()\n+    void canEncodeEmptyString()\n     {\n         assertCanEncodeAndDecodeToSame( \"\" );\n     }\n \n     @Test\n-    public void canEncodeNumerical()\n+    void canEncodeNumerical()\n     {\n         assertCanEncodeAndDecodeToSame( \"12345678901234567890\" );\n         assertCanEncodeAndDecodeToSame( \"12345678901234567890 +-.,' 321,3\" );\n     }\n \n     @Test\n-    public void canEncodeDate()\n+    void canEncodeDate()\n     {\n         assertCanEncodeAndDecodeToSame( \"2011-10-10 12:45:22+0200\" );\n         assertCanEncodeAndDecodeToSame( \"2011/10/10 12:45:22+0200\" );\n     }\n \n     @Test\n-    public void testRandomStrings()\n+    void testRandomStrings()\n     {\n         for ( int i = 0; i < 1000; i++ )\n         {\n@@ -91,22 +94,22 @@ public void testRandomStrings()\n     }\n \n     @Test\n-    public void canEncodeEmailAndUri()\n+    void canEncodeEmailAndUri()\n     {\n         assertCanEncodeAndDecodeToSame( \"mattias@neotechnology.com\" );\n         assertCanEncodeAndDecodeToSame( \"http://domain:7474/\" );\n     }\n \n     @Test\n-    public void canEncodeLower()\n+    void canEncodeLower()\n     {\n         assertCanEncodeAndDecodeToSame( \"folder/generators/templates/controller.ext\" );\n         assertCanEncodeAndDecodeToSame( \"folder/generators/templates/controller.extr\" );\n         assertCannotEncode( \"folder/generators/templates/controller.extra\" );\n     }\n \n     @Test\n-    public void canEncodeLowerHex()\n+    void canEncodeLowerHex()\n     {\n         assertCanEncodeAndDecodeToSame( \"da39a3ee5e6b4b0d3255bfef95601890afd80709\" ); // sha1hex('') len=40\n         assertCanEncodeAndDecodeToSame(\n@@ -117,7 +120,7 @@ public void canEncodeLowerHex()\n     }\n \n     @Test\n-    public void canEncodeUpperHex()\n+    void canEncodeUpperHex()\n     {\n         assertCanEncodeAndDecodeToSame( \"DA39A3EE5E6B4B0D3255BFEF95601890AFD80709\" ); // sha1HEX('') len=40\n         assertCanEncodeAndDecodeToSame(\n@@ -128,14 +131,14 @@ public void canEncodeUpperHex()\n     }\n \n     @Test\n-    public void checkMarginalFit()\n+    void checkMarginalFit()\n     {\n         assertCanEncodeAndDecodeToSame( \"^aaaaaaaaaaaaaaaaaaaaaaaaaa\" );\n         assertCannotEncode( \"^aaaaaaaaaaaaaaaaaaaaaaaaaaa\" );\n     }\n \n     @Test\n-    public void canEncodeUUIDString()\n+    void canEncodeUUIDString()\n     {\n         assertCanEncodeAndDecodeToSame( \"81fe144f-484b-4a34-8e36-17a021540318\" );\n     }",
      "parent_sha": "b4cc0fdb12a357c77980fcf3d2cfbefa5082c05f"
    }
  },
  {
    "oid": "4098161ac1eae14f5a4c46b01c06e05516cf2e44",
    "message": "More frequent background ID maintenance\n\nWhen doing deletions and then rapidly doing creations thereafter,\nwith the expectancy that those deleted IDs could be reused immediately\nthat would sometimes not be the case since the background maintenance\nhadn't run yet.",
    "date": "2021-08-25T06:17:37Z",
    "url": "https://github.com/neo4j/neo4j/commit/4098161ac1eae14f5a4c46b01c06e05516cf2e44",
    "details": {
      "sha": "04fa236a318ee0ca646cf7f3ac94598f749d45c6",
      "filename": "community/id-generator/src/main/java/org/neo4j/internal/id/BufferedIdController.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/neo4j/neo4j/blob/4098161ac1eae14f5a4c46b01c06e05516cf2e44/community%2Fid-generator%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Finternal%2Fid%2FBufferedIdController.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/4098161ac1eae14f5a4c46b01c06e05516cf2e44/community%2Fid-generator%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Finternal%2Fid%2FBufferedIdController.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fid-generator%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Finternal%2Fid%2FBufferedIdController.java?ref=4098161ac1eae14f5a4c46b01c06e05516cf2e44",
      "patch": "@@ -58,7 +58,7 @@ public BufferedIdController( BufferingIdGeneratorFactory bufferingIdGeneratorFac\n     public void start()\n     {\n         var monitoringParams = JobMonitoringParams.systemJob( databaseName, \"ID generator maintenance\" );\n-        jobHandle = scheduler.scheduleRecurring( Group.STORAGE_MAINTENANCE, monitoringParams, () -> maintenance( false ), 300, MILLISECONDS );\n+        jobHandle = scheduler.scheduleRecurring( Group.STORAGE_MAINTENANCE, monitoringParams, () -> maintenance( true ), 200, MILLISECONDS );\n     }\n \n     @Override",
      "parent_sha": "48b735b95b68f9c8a92959f2f876d58f163c7770"
    }
  },
  {
    "oid": "593a623aa3b80b899e94d65ed27492e2a3c7b0fe",
    "message": "Added some more verifications (number of nodes, relationships, properties...)\n\n\ngit-svn-id: https://svn.neo4j.org/laboratory/components/ha/src@5248 0b971d98-bb2f-0410-8247-b05b2b5feb2a",
    "date": "2010-08-18T13:12:11Z",
    "url": "https://github.com/neo4j/neo4j/commit/593a623aa3b80b899e94d65ed27492e2a3c7b0fe",
    "details": {
      "sha": "3b165b8538b28609f71b561142be2562a5d38d53",
      "filename": "enterprise/test/java/slavetest/AbstractHaTest.java",
      "status": "modified",
      "additions": 73,
      "deletions": 10,
      "changes": 83,
      "blob_url": "https://github.com/neo4j/neo4j/blob/593a623aa3b80b899e94d65ed27492e2a3c7b0fe/enterprise%2Ftest%2Fjava%2Fslavetest%2FAbstractHaTest.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/593a623aa3b80b899e94d65ed27492e2a3c7b0fe/enterprise%2Ftest%2Fjava%2Fslavetest%2FAbstractHaTest.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/enterprise%2Ftest%2Fjava%2Fslavetest%2FAbstractHaTest.java?ref=593a623aa3b80b899e94d65ed27492e2a3c7b0fe",
      "patch": "@@ -12,6 +12,7 @@\n import java.util.Set;\n \n import org.apache.commons.io.FileUtils;\n+import org.junit.Before;\n import org.junit.Test;\n import org.neo4j.graphdb.Direction;\n import org.neo4j.graphdb.DynamicRelationshipType;\n@@ -31,42 +32,77 @@ public abstract class AbstractHaTest\n     static final File SKELETON_DB_PATH = new File( DBS_PATH, \"skeleton\" );\n     static final Map<String, String> INDEX_CONFIG = MapUtil.stringMap( \"index\", \"true\" );\n     \n+    private boolean expectsResults;\n+    private int nodeCount;\n+    private int relCount;\n+    private int nodePropCount;\n+    private int relPropCount;\n+    private int nodeIndexPropCount;\n+    \n     protected static File dbPath( int num )\n     {\n         return new File( DBS_PATH, \"\" + num );\n     }\n+    \n+    @Before\n+    public void clearExpectedResults()\n+    {\n+        expectsResults = false;\n+    }\n \n-    public static void verify( VerifyDbContext refDb, VerifyDbContext... dbs )\n+    public void verify( VerifyDbContext refDb, VerifyDbContext... dbs )\n     {\n         for ( VerifyDbContext otherDb : dbs )\n         {\n+            int vNodeCount = 0;\n+            int vRelCount = 0;\n+            int vNodePropCount = 0;\n+            int vRelPropCount = 0;\n+            int vNodeIndexPropCount = 0;\n+            \n             Set<Node> otherNodes = IteratorUtil.addToCollection( otherDb.db.getAllNodes().iterator(),\n                     new HashSet<Node>() );\n             for ( Node node : refDb.db.getAllNodes() )\n             {\n                 Node otherNode = otherDb.db.getNodeById( node.getId() );\n-                verifyNode( node, otherNode, refDb, otherDb );\n+                int[] counts = verifyNode( node, otherNode, refDb, otherDb );\n+                vRelCount += counts[0];\n+                vNodePropCount += counts[1];\n+                vRelPropCount += counts[2];\n+                vNodeIndexPropCount += counts[3];\n                 otherNodes.remove( otherNode );\n+                vNodeCount++;\n             }\n             assertTrue( otherNodes.isEmpty() );\n+            \n+            if ( expectsResults )\n+            {\n+                assertEquals( nodeCount, vNodeCount );\n+                assertEquals( relCount, vRelCount );\n+                assertEquals( nodePropCount, vNodePropCount );\n+                assertEquals( relPropCount, vRelPropCount );\n+                assertEquals( nodeIndexPropCount, vNodeIndexPropCount );\n+            }\n         }\n     }\n-\n-    private static void verifyNode( Node node, Node otherNode,\n+    \n+    private static int[] verifyNode( Node node, Node otherNode,\n             VerifyDbContext refDb, VerifyDbContext otherDb )\n     {\n-        verifyProperties( node, otherNode );\n-        verifyIndex( node, otherNode, refDb, otherDb );\n+        int vNodePropCount = verifyProperties( node, otherNode );\n+        int vNodeIndexPropCount = verifyIndex( node, otherNode, refDb, otherDb );\n         Set<Long> otherRelIds = new HashSet<Long>();\n         for ( Relationship otherRel : otherNode.getRelationships( Direction.OUTGOING ) )\n         {\n             otherRelIds.add( otherRel.getId() );\n         }\n         \n+        int vRelCount = 0;\n+        int vRelPropCount = 0;\n         for ( Relationship rel : node.getRelationships( Direction.OUTGOING ) )\n         {\n             Relationship otherRel = otherDb.db.getRelationshipById( rel.getId() );\n-            verifyProperties( rel, otherRel );\n+            vRelPropCount += verifyProperties( rel, otherRel );\n             if ( rel.getStartNode().getId() != otherRel.getStartNode().getId() )\n             {\n                 throw new RuntimeException( \"Start node differs on \" + rel );\n@@ -80,21 +116,24 @@ private static void verifyNode( Node node, Node otherNode,\n                 throw new RuntimeException( \"Type differs on \" + rel );\n             }\n             otherRelIds.remove( rel.getId() );\n+            vRelCount++;\n         }\n         \n         if ( !otherRelIds.isEmpty() )\n         {\n             throw new RuntimeException( \"Other node \" + otherNode + \" has more relationships \" +\n                     otherRelIds );\n         }\n+        return new int[] { vRelCount, vNodePropCount, vRelPropCount, vNodeIndexPropCount };\n     }\n \n-    private static void verifyIndex( Node node, Node otherNode, VerifyDbContext refDb,\n+    private static int verifyIndex( Node node, Node otherNode, VerifyDbContext refDb,\n             VerifyDbContext otherDb )\n     {\n+        int count = 0;\n         if ( refDb.index == null || otherDb.index == null )\n         {\n-            return;\n+            return count;\n         }\n         \n         Set<String> otherKeys = new HashSet<String>();\n@@ -105,6 +144,7 @@ private static void verifyIndex( Node node, Node otherNode, VerifyDbContext refD\n                 otherKeys.add( key );\n             }\n         }\n+        count = otherKeys.size();\n         \n         for ( String key : node.getPropertyKeys() )\n         {\n@@ -118,15 +158,17 @@ private static void verifyIndex( Node node, Node otherNode, VerifyDbContext refD\n             throw new RuntimeException( \"Other node \" + otherNode + \" has more indexing: \" +\n                     otherKeys );\n         }\n+        return count;\n     }\n \n     private static boolean isIndexed( Node node, VerifyDbContext db, String key )\n     {\n         return db.index.getSingleNode( key, node.getProperty( key ) ) != null;\n     }\n \n-    private static void verifyProperties( PropertyContainer entity, PropertyContainer otherEntity )\n+    private static int verifyProperties( PropertyContainer entity, PropertyContainer otherEntity )\n     {\n+        int count = 0;\n         Set<String> otherKeys = IteratorUtil.addToCollection(\n                 otherEntity.getPropertyKeys().iterator(), new HashSet<String>() );\n         for ( String key : entity.getPropertyKeys() )\n@@ -139,12 +181,14 @@ private static void verifyProperties( PropertyContainer entity, PropertyContaine\n                         value1 + \", \" + value2 );\n             }\n             otherKeys.remove( key );\n+            count++;\n         }\n         if ( !otherKeys.isEmpty() )\n         {\n             throw new RuntimeException( \"Other node \" + otherEntity + \" has more properties: \" +\n                     otherKeys );\n         }\n+        return count;\n     }\n \n     public static <T> void assertCollection( Collection<T> collection, T... expectedItems )\n@@ -202,13 +246,15 @@ protected final void initializeDbs( int numSlaves ) throws Exception\n     @Test\n     public void slaveCreateNode() throws Exception\n     {\n+        setExpectedResults( 3, 2, 2, 2, 0 );\n         initializeDbs( 1 );\n         executeJob( new CommonJobs.CreateSomeEntitiesJob(), 0 );\n     }\n     \n     @Test\n     public void testMultipleSlaves() throws Exception\n     {\n+        setExpectedResults( 2, 1, 1, 1, 0 );\n         initializeDbs( 3 );\n         executeJob( new CommonJobs.CreateSubRefNodeJob( CommonJobs.REL_TYPE.name(), null, null ), 0 );\n         executeJob( new CommonJobs.SetSubRefPropertyJob( \"name\", \"Hello\" ), 1 );\n@@ -231,6 +277,7 @@ public void testMultipleSlaves() throws Exception\n     @Test\n     public void testSlaveConstraintViolation() throws Exception\n     {\n+        setExpectedResults( 2, 1, 0, 1, 0 );\n         initializeDbs( 1 );\n         \n         Long nodeId = executeJob( new CommonJobs.CreateSubRefNodeJob(\n@@ -242,6 +289,7 @@ public void testSlaveConstraintViolation() throws Exception\n     @Test\n     public void testMasterConstrainViolation() throws Exception\n     {\n+        setExpectedResults( 2, 1, 1, 1, 0 );\n         initializeDbs( 1 );\n         \n         Long nodeId = executeJob( new CommonJobs.CreateSubRefNodeJob( CommonJobs.REL_TYPE.name(),\n@@ -254,6 +302,7 @@ public void testMasterConstrainViolation() throws Exception\n     @Test\n     public void testGetRelationships() throws Exception\n     {\n+        setExpectedResults( 3, 2, 0, 0, 0 );\n         initializeDbs( 1 );\n         \n         assertEquals( (Integer) 1, executeJob( new CommonJobs.CreateSubRefNodeWithRelCountJob(\n@@ -269,6 +318,7 @@ public void testGetRelationships() throws Exception\n     @Test\n     public void testNoTransaction() throws Exception\n     {\n+        setExpectedResults( 2, 1, 0, 1, 0 );\n         initializeDbs( 1 );\n         \n         executeJobOnMaster( new CommonJobs.CreateSubRefNodeJob(\n@@ -280,6 +330,7 @@ public void testNoTransaction() throws Exception\n     @Test\n     public void testNodeDeleted() throws Exception\n     {\n+        setExpectedResults( 1, 0, 0, 0, 0 );\n         initializeDbs( 1 );\n         \n         Long nodeId = executeJobOnMaster( new CommonJobs.CreateNodeJob() );\n@@ -317,6 +368,7 @@ public void testDeadlock() throws Exception\n     @Test\n     public void createNodeAndIndex() throws Exception\n     {\n+        setExpectedResults( 2, 0, 1, 0, 1 );\n         initializeDbs( 1, INDEX_CONFIG );\n         executeJob( new CommonJobs.CreateNodeAndIndexJob(), 0 );\n     }\n@@ -353,4 +405,15 @@ public void run()\n             }\n         }\n     }\n+    \n+    protected void setExpectedResults( int nodeCount, int relCount,\n+            int nodePropCount, int relPropCount, int nodeIndexPropCount )\n+    {\n+        this.expectsResults = true;\n+        this.nodeCount = nodeCount;\n+        this.relCount = relCount;\n+        this.nodePropCount = nodePropCount;\n+        this.relPropCount = relPropCount;\n+        this.nodeIndexPropCount = nodeIndexPropCount;\n+    }\n }",
      "parent_sha": "f716f695362b8a74f15076d93904603b64816284"
    }
  },
  {
    "oid": "a76b7a192a603313906837d5da6ce091edf96956",
    "message": "Fix a data race in the profiler that could lead to an NPE, and prevent the profiles from being captured.",
    "date": "2018-11-27T16:05:42Z",
    "url": "https://github.com/neo4j/neo4j/commit/a76b7a192a603313906837d5da6ce091edf96956",
    "details": {
      "sha": "2b5a2a7ab1afc7b5d62e877549d20d2205b9f12b",
      "filename": "community/common/src/main/java/org/neo4j/resources/SamplingProfiler.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/neo4j/neo4j/blob/a76b7a192a603313906837d5da6ce091edf96956/community%2Fcommon%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fresources%2FSamplingProfiler.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/a76b7a192a603313906837d5da6ce091edf96956/community%2Fcommon%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fresources%2FSamplingProfiler.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fcommon%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fresources%2FSamplingProfiler.java?ref=a76b7a192a603313906837d5da6ce091edf96956",
      "patch": "@@ -20,10 +20,10 @@\n package org.neo4j.resources;\n \n import java.io.PrintStream;\n-import java.util.ArrayList;\n import java.util.Map;\n import java.util.PriorityQueue;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicLong;\n@@ -33,7 +33,7 @@ class SamplingProfiler implements Profiler\n {\n     private static final long DEFAULT_SAMPLE_INTERVAL_NANOS = TimeUnit.MILLISECONDS.toNanos( 1 );\n \n-    private final ArrayList<Thread> samplerThreads = new ArrayList<>();\n+    private final ConcurrentLinkedQueue<Thread> samplerThreads = new ConcurrentLinkedQueue<>();\n     private final AtomicBoolean stopped = new AtomicBoolean();\n     private final ConcurrentHashMap<Thread,Sample> samples = new ConcurrentHashMap<>();\n     private final AtomicLong sampleIntervalNanos = new AtomicLong( DEFAULT_SAMPLE_INTERVAL_NANOS );\n@@ -51,12 +51,12 @@ public void reset()\n     public void finish() throws InterruptedException\n     {\n         stopped.set( true );\n-        for ( Thread thread : samplerThreads )\n+        Thread thread;\n+        while ( (thread = samplerThreads.poll()) != null )\n         {\n             thread.interrupt();\n             thread.join();\n         }\n-        samplerThreads.clear();\n     }\n \n     @Override",
      "parent_sha": "94a0271fd03c45d3cef1a4ab7b654016a4443068"
    }
  },
  {
    "oid": "8a830b3afd9c417af3a1692e55835443db1c05b3",
    "message": "Use a privileged action to obtain the Unsafe.\n\nThis makes it possible for the code that depends on UnsafeUtils to work in sandboxed runtimes that has been configured to trust UnsafeUtil.",
    "date": "2014-12-03T12:40:14Z",
    "url": "https://github.com/neo4j/neo4j/commit/8a830b3afd9c417af3a1692e55835443db1c05b3",
    "details": {
      "sha": "87051fc409d7fd9dbcf96d083eec7ea780581d9d",
      "filename": "community/io/src/main/java/org/neo4j/io/pagecache/impl/muninn/UnsafeUtil.java",
      "status": "modified",
      "additions": 90,
      "deletions": 38,
      "changes": 128,
      "blob_url": "https://github.com/neo4j/neo4j/blob/8a830b3afd9c417af3a1692e55835443db1c05b3/community%2Fio%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fio%2Fpagecache%2Fimpl%2Fmuninn%2FUnsafeUtil.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/8a830b3afd9c417af3a1692e55835443db1c05b3/community%2Fio%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fio%2Fpagecache%2Fimpl%2Fmuninn%2FUnsafeUtil.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fio%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fio%2Fpagecache%2Fimpl%2Fmuninn%2FUnsafeUtil.java?ref=8a830b3afd9c417af3a1692e55835443db1c05b3",
      "patch": "@@ -26,8 +26,11 @@\n import java.lang.invoke.MethodType;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n import java.nio.ByteBuffer;\n import java.nio.ByteOrder;\n+import java.security.AccessController;\n+import java.security.PrivilegedExceptionAction;\n \n public final class UnsafeUtil\n {\n@@ -53,26 +56,19 @@ public final class UnsafeUtil\n \n     static\n     {\n-        Unsafe theUnsafe = null;\n-        Object sentinelBase = null;\n-        long sentinelOffset = 0;\n+        unsafe = getUnsafe();\n+\n         try\n         {\n-            Field unsafeField = Unsafe.class.getDeclaredField( \"theUnsafe\" );\n-            unsafeField.setAccessible( true );\n-            theUnsafe = (Unsafe) unsafeField.get( null );\n-\n             Field field = UnsafeUtil.class.getDeclaredField( \"nullSentinel\" );\n-            sentinelBase = theUnsafe.staticFieldBase( field );\n-            sentinelOffset = theUnsafe.staticFieldOffset( field );\n+            nullSentinelBase = unsafe.staticFieldBase( field );\n+            nullSentinelOffset = unsafe.staticFieldOffset( field );\n         }\n-        catch ( NoSuchFieldException | IllegalAccessException e )\n+        catch ( NoSuchFieldException e )\n         {\n-            e.printStackTrace();\n+            throw new LinkageError( \"Inaccessible field: 'nullSentinel'\", e );\n         }\n-        unsafe = theUnsafe;\n-        nullSentinelBase = sentinelBase;\n-        nullSentinelOffset = sentinelOffset;\n+\n         MethodHandles.Lookup lookup = MethodHandles.lookup();\n         getAndAddInt = getGetAndAddIntMethodHandle( lookup );\n         getAndSetObject = getGetAndSetObjectMethodHandle( lookup );\n@@ -134,6 +130,45 @@ public final class UnsafeUtil\n         storeByteOrderIsNative = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;\n     }\n \n+    private static Unsafe getUnsafe()\n+    {\n+        try\n+        {\n+            return AccessController.doPrivileged( new PrivilegedExceptionAction<Unsafe>()\n+            {\n+                @Override\n+                public Unsafe run() throws Exception\n+                {\n+                    try\n+                    {\n+                        return Unsafe.getUnsafe();\n+                    }\n+                    catch ( Exception e )\n+                    {\n+                        Class<Unsafe> type = Unsafe.class;\n+                        Field[] fields = type.getDeclaredFields();\n+                        for ( Field field : fields )\n+                        {\n+                            if ( Modifier.isStatic( field.getModifiers() )\n+                                 && type.isAssignableFrom( field.getType() ) )\n+                            {\n+                                field.setAccessible( true );\n+                                return type.cast( field.get( null ) );\n+                            }\n+                        }\n+                        LinkageError error = new LinkageError( \"No static field of type sun.misc.Unsafe\" );\n+                        error.addSuppressed( e );\n+                        throw error;\n+                    }\n+                }\n+            } );\n+        }\n+        catch ( Exception e )\n+        {\n+            throw new LinkageError( \"Cannot access sun.misc.Unsafe\", e );\n+        }\n+    }\n+\n     private static MethodHandle getGetAndAddIntMethodHandle(\n             MethodHandles.Lookup lookup )\n     {\n@@ -172,26 +207,35 @@ public static long getFieldOffset( Class<?> type, String field )\n         }\n         catch ( NoSuchFieldException e )\n         {\n-            throw new Error( e );\n+            String message = \"Could not get offset of '\" + field + \"' field on type \" + type;\n+            throw new LinkageError( message, e );\n         }\n     }\n \n     public static int getAndAddInt( Object obj, long offset, int delta )\n     {\n-        // The Java 8 specific version:\n         if ( getAndAddInt != null )\n         {\n-            try\n-            {\n-                return (int) getAndAddInt.invokeExact( unsafe, obj, offset, delta );\n-            }\n-            catch ( Throwable throwable )\n-            {\n-                throw new AssertionError( \"Unexpected intrinsic failure\", throwable );\n-            }\n+            return getAndAddInt_java8( obj, offset, delta );\n+        }\n+\n+        return getAndAddInt_java7( obj, offset, delta );\n+    }\n+\n+    private static int getAndAddInt_java8( Object obj, long offset, int delta )\n+    {\n+        try\n+        {\n+            return (int) getAndAddInt.invokeExact( unsafe, obj, offset, delta );\n         }\n+        catch ( Throwable throwable )\n+        {\n+            throw new LinkageError( \"Unexpected 'getAndAddInt' intrinsic failure\", throwable );\n+        }\n+    }\n \n-        // The Java 7 version:\n+    private static int getAndAddInt_java7( Object obj, long offset, int delta )\n+    {\n         int x;\n         do\n         {\n@@ -215,20 +259,28 @@ public static boolean compareAndSwapObject(\n \n     public static Object getAndSetObject( Object obj, long offset, Object newValue )\n     {\n-        // The Java 8 specific version:\n         if ( getAndSetObject != null )\n         {\n-            try\n-            {\n-                return getAndSetObject.invokeExact( unsafe, obj, offset, newValue );\n-            }\n-            catch ( Throwable throwable )\n-            {\n-                throw new AssertionError( \"Unexpected intrinsic failure\", throwable );\n-            }\n+            return getAndSetObject_java8( obj, offset, newValue );\n         }\n \n-        // The Java 7 version:\n+        return getAndSetObject_java7( obj, offset, newValue );\n+    }\n+\n+    private static Object getAndSetObject_java8( Object obj, long offset, Object newValue )\n+    {\n+        try\n+        {\n+            return getAndSetObject.invokeExact( unsafe, obj, offset, newValue );\n+        }\n+        catch ( Throwable throwable )\n+        {\n+            throw new LinkageError( \"Unexpected 'getAndSetObject' intrinsic failure\", throwable );\n+        }\n+    }\n+\n+    private static Object getAndSetObject_java7( Object obj, long offset, Object newValue )\n+    {\n         Object current;\n         do\n         {\n@@ -335,7 +387,7 @@ public static void setMemory( long address, long bytes, byte value )\n         unsafe.setMemory( address, bytes, value );\n     }\n \n-    public static ByteBuffer newDirectByteBuffer(long addr, int cap) throws Exception\n+    public static ByteBuffer newDirectByteBuffer( long addr, int cap ) throws Exception\n     {\n         if ( directByteBufferCtor == null )\n         {\n@@ -363,11 +415,11 @@ public static ByteBuffer newDirectByteBuffer(long addr, int cap) throws Exceptio\n      */\n     public static void retainReference( Object obj )\n     {\n-        Object sentinel = UnsafeUtil.getObjectVolatile( nullSentinelBase, nullSentinelOffset );\n+        Object sentinel = getObjectVolatile( nullSentinelBase, nullSentinelOffset );\n \n         if ( sentinel == obj )\n         {\n-            UnsafeUtil.putObjectVolatile( nullSentinelBase, nullSentinelOffset, obj );\n+            putObjectVolatile( nullSentinelBase, nullSentinelOffset, obj );\n         }\n     }\n }",
      "parent_sha": "af3656309c50c04ce27c1eaa98a17be7694931a8"
    }
  },
  {
    "oid": "364359eff7c542bedfab766672952f15b4e60a2c",
    "message": "Update RecordStore documentation to mention RecordLoad.FORCE_NORMAL.",
    "date": "2020-03-31T09:00:03Z",
    "url": "https://github.com/neo4j/neo4j/commit/364359eff7c542bedfab766672952f15b4e60a2c",
    "details": {
      "sha": "bc2ac28cc65586c29db9815eddb4698f740b617c",
      "filename": "community/record-storage-engine/src/main/java/org/neo4j/kernel/impl/store/RecordStore.java",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/neo4j/neo4j/blob/364359eff7c542bedfab766672952f15b4e60a2c/community%2Frecord-storage-engine%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fstore%2FRecordStore.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/364359eff7c542bedfab766672952f15b4e60a2c/community%2Frecord-storage-engine%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fstore%2FRecordStore.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Frecord-storage-engine%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fstore%2FRecordStore.java?ref=364359eff7c542bedfab766672952f15b4e60a2c",
      "patch": "@@ -100,14 +100,16 @@ public interface RecordStore<RECORD extends AbstractBaseRecord> extends IdSequen\n      * be different behavior, although the {@code target} record will be marked with the specified\n      * {@code id} after participating in this method call.\n      * <ul>\n-     * <li>{@link RecordLoad#CHECK}: As little data as possible is read to determine whether or not the record\n-     *     is in use. If not in use then no more data will be loaded into the target record and\n-     *     the the data of the record will be {@link AbstractBaseRecord#clear() cleared}.</li>\n+     * <li>{@link RecordLoad#CHECK}: As little data as possible is read to determine whether the record\n+     *     is in use or not. If not in use then no more data will be loaded into the target record and\n+     *     the data of the record will be {@link AbstractBaseRecord#clear() cleared}.</li>\n      * <li>{@link RecordLoad#NORMAL}: Just like {@link RecordLoad#CHECK}, but with the difference that\n      *     an {@link InvalidRecordException} will be thrown if the record isn't in use.</li>\n      * <li>{@link RecordLoad#FORCE}: The entire contents of the record will be loaded into the target record\n      *     regardless if the record is in use or not. This leaves no guarantees about the data in the record\n      *     after this method call, except that the id will be the specified {@code id}.\n+     * <li>{@link RecordLoad#FORCE_NORMAL}: Similar to {@link RecordLoad#FORCE}, except the sanity checks on\n+     *     the record data is always enabled.</li>\n      *\n      * @param id the id of the record to load.\n      * @param target record where data will be loaded into. This record will have its id set to the specified\n@@ -307,7 +309,7 @@ default void updateRecord( RECORD record , PageCursorTracer cursorTracer )\n      * cloned if you want to save it for later.\n      * @param visitor {@link Visitor} notified about all records.\n      * @param cursorTracer underlying page cursor tracer.\n-     * @throws Exception on error reading from store.\n+     * @throws EXCEPTION on error reading from store.\n      */\n     <EXCEPTION extends Exception> void scanAllRecords( Visitor<RECORD,EXCEPTION> visitor, PageCursorTracer cursorTracer ) throws EXCEPTION;\n ",
      "parent_sha": "b43ad3fa7bd40b7517af0c7fe2f9ff84371373ac"
    }
  },
  {
    "oid": "762f3fc4d7778e4c7b7c9c79f21ee3ff60b2165a",
    "message": "Fix windows paths for neo4j command tests",
    "date": "2022-05-31T06:35:56Z",
    "url": "https://github.com/neo4j/neo4j/commit/762f3fc4d7778e4c7b7c9c79f21ee3ff60b2165a",
    "details": {
      "sha": "62a4f3aa33c712ebc8bcd8858c8f08f228486b10",
      "filename": "community/neo4j/src/test/java/org/neo4j/server/startup/Neo4jCommandTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/neo4j/neo4j/blob/762f3fc4d7778e4c7b7c9c79f21ee3ff60b2165a/community%2Fneo4j%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fserver%2Fstartup%2FNeo4jCommandTest.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/762f3fc4d7778e4c7b7c9c79f21ee3ff60b2165a/community%2Fneo4j%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fserver%2Fstartup%2FNeo4jCommandTest.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fneo4j%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fserver%2Fstartup%2FNeo4jCommandTest.java?ref=762f3fc4d7778e4c7b7c9c79f21ee3ff60b2165a",
      "patch": "@@ -405,7 +405,7 @@ void shouldNotComplainOnPluginSettingWithStrictValidation() throws IOException {\n \n             // Start with strict validation\n             addConf(GraphDatabaseSettings.strict_config_validation, \"true\");\n-            addConf(GraphDatabaseSettings.plugin_dir, maybePlugins.toString());\n+            addConf(GraphDatabaseSettings.plugin_dir, maybePlugins.toString().replace(\"\\\\\", \"\\\\\\\\\"));\n             addConf(MyPluginSetting.setting, \"foo\");\n             assertThat(execute(\"start\")).isEqualTo(EXIT_CODE_OK);\n             assertThat(err.toString()).isEmpty();",
      "parent_sha": "57490652b7a4591038c862c7f99f943cc7adf3f7"
    }
  },
  {
    "oid": "eeb4f3fa8128e60d616dfee182e2d9b83f57392d",
    "message": "Only allow upgrade procedures on system database\n\nAlso fix the mode from DBMS to READ or WRITE",
    "date": "2020-05-28T10:07:03Z",
    "url": "https://github.com/neo4j/neo4j/commit/eeb4f3fa8128e60d616dfee182e2d9b83f57392d",
    "details": {
      "sha": "7b22937e33c3fff91eaa19fbccd4ed4006cb885d",
      "filename": "community/community-it/kernel-it/src/test/java/org/neo4j/kernel/impl/api/integrationtest/ProcedureITBase.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/neo4j/neo4j/blob/eeb4f3fa8128e60d616dfee182e2d9b83f57392d/community%2Fcommunity-it%2Fkernel-it%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fapi%2Fintegrationtest%2FProcedureITBase.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/eeb4f3fa8128e60d616dfee182e2d9b83f57392d/community%2Fcommunity-it%2Fkernel-it%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fapi%2Fintegrationtest%2FProcedureITBase.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fcommunity-it%2Fkernel-it%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fapi%2Fintegrationtest%2FProcedureITBase.java?ref=eeb4f3fa8128e60d616dfee182e2d9b83f57392d",
      "patch": "@@ -260,10 +260,10 @@ default List<Object[]> getExpectedEnterpriseProcs()\n                         stringArray( \"reader\", \"editor\", \"publisher\", \"architect\", \"admin\" ), \"DBMS\" ),\n                 proc( \"dbms.upgradeStatus\", \"() :: (status :: STRING?, description :: STRING?, resolution :: STRING?)\",\n                         \"Report the current status of the system database sub-graph schema.\",\n-                        stringArray( \"admin\" ), \"DBMS\" ),\n+                        stringArray( \"admin\" ), \"READ\" ),\n                 proc( \"dbms.upgrade\", \"() :: (status :: STRING?, upgradeResult :: STRING?)\",\n                         \"Upgrade the system database schema if it is not the current schema.\",\n-                        stringArray( \"admin\" ), \"DBMS\" )\n+                        stringArray( \"admin\" ), \"WRITE\" )\n         ));\n         return result;\n     }",
      "parent_sha": "6fdfd585d6b15f346ca8a74cecfc001d5021091c"
    }
  },
  {
    "oid": "70f1720bdceab9bb7e3f81de67eeef7d048cbfb5",
    "message": "Cleaned up a bit\n\n\ngit-svn-id: https://svn.neo4j.org/components/ha/trunk/src@6886 0b971d98-bb2f-0410-8247-b05b2b5feb2a",
    "date": "2010-11-11T19:14:58Z",
    "url": "https://github.com/neo4j/neo4j/commit/70f1720bdceab9bb7e3f81de67eeef7d048cbfb5",
    "details": {
      "sha": "53b33af169a36d4e283539202825543b35439287",
      "filename": "community/test/java/slavetest/StartHaDb.java",
      "status": "modified",
      "additions": 78,
      "deletions": 41,
      "changes": 119,
      "blob_url": "https://github.com/neo4j/neo4j/blob/70f1720bdceab9bb7e3f81de67eeef7d048cbfb5/community%2Ftest%2Fjava%2Fslavetest%2FStartHaDb.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/70f1720bdceab9bb7e3f81de67eeef7d048cbfb5/community%2Ftest%2Fjava%2Fslavetest%2FStartHaDb.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Ftest%2Fjava%2Fslavetest%2FStartHaDb.java?ref=70f1720bdceab9bb7e3f81de67eeef7d048cbfb5",
      "patch": "@@ -24,7 +24,6 @@\n import java.io.IOException;\n import java.util.Date;\n \n-import org.apache.commons.io.FileUtils;\n import org.neo4j.graphdb.GraphDatabaseService;\n import org.neo4j.helpers.collection.MapUtil;\n import org.neo4j.kernel.Config;\n@@ -35,63 +34,101 @@ public class StartHaDb\n {\n     public static final File PATH = new File( \"var/hadb\" );\n \n-    static final String HA_SERVER = \"172.16.2.33:5559\";\n+    static final String ME = \"172.16.1.242:5559\";\n+    static final int MY_MACHINE_ID = 2;\n         \n-//            \"1\", \"172.16.2.33:5559\", // JS\n-//            \"2\", \"172.16.1.242:5559\", // MP\n-//            \"3\", \"172.16.4.14:5559\" // TI\n+    static final String[] ZOO_KEEPER_SERVERS = new String[] {\n+        \"172.16.2.33:2181\",\n+        \"172.16.1.242:2181\",\n+        \"172.16.4.14:2181\",\n+    };\n \n     public static void main( String[] args ) throws Exception\n     {\n         NeoStoreUtil store = new NeoStoreUtil( PATH.getPath() );\n         System.out.println( \"Starting store: createTime=\" + new Date( store.getCreationTime() ) +\n                 \" identifier=\" + store.getStoreId() + \" last committed tx=\" + store.getLastCommittedTx() );\n-        final GraphDatabaseService db = new HighlyAvailableGraphDatabase( PATH.getPath(), MapUtil.stringMap(\n-                HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"1\",\n-                HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS, join( StartZooKeeperServer.ZOO_KEEPER_SERVERS, \",\" ),\n-                HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVER, HA_SERVER,\n-                HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SKELETON_DB_PATH, figureOutNiceTmpDir(),\n+        GraphDatabaseService db = startDb();\n+        System.out.println( \"Waiting for ENTER (for clean shutdown)\" );\n+        System.in.read();\n+        db.shutdown();\n+//        doStuff( db );\n+    }\n+\n+    private static GraphDatabaseService startDb() throws IOException\n+    {\n+        return new HighlyAvailableGraphDatabase( PATH.getPath(), MapUtil.stringMap(\n+                HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + MY_MACHINE_ID,\n+                HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS, join( ZOO_KEEPER_SERVERS, \",\" ),\n+                HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVER, ME,\n                 Config.ENABLE_REMOTE_SHELL, \"true\",\n                 Config.KEEP_LOGICAL_LOGS, \"true\" ) );\n-        \n-        \n-//        Transaction tx = db.beginTx();\n-//        try\n+    }\n+    \n+//    private static void doStuff( GraphDatabaseService db ) throws IOException\n+//    {\n+//        RelationshipType refType = DynamicRelationshipType.withName( \"MATTIAS_REF\" );\n+//        RelationshipType type = DynamicRelationshipType.withName( \"JOHAN_IS_NOOB\" );\n+//        long time = System.currentTimeMillis();\n+//        int txCount = 0;\n+//        while ( System.currentTimeMillis() - time < 60000 )\n //        {\n-//            Node node = db.createNode();\n-//            while ( true )\n+//            Transaction tx = db.beginTx();\n+//            boolean restarted = false;\n+//            try\n //            {\n-//                Thread.sleep( 5000 );\n+//                Node refNode = db.getReferenceNode();\n+//                refNode.setProperty( \"name\", \"MP\" + System.currentTimeMillis() );\n+//                Node myRefNode = db.createNode();\n+//                refNode.createRelationshipTo( myRefNode, refType );\n+//                for ( int i = 0; i < 20; i++ )\n+//                {\n+//                    Node node = db.createNode();\n+//                    Relationship rel = myRefNode.createRelationshipTo( node, type );\n+//                    rel.setProperty( \"something\", i );\n+//                }\n+//                tx.success();\n+//\n+//                if ( Math.random() < 0.33 )\n+//                {\n+//                    db.shutdown();\n+//                    db = startDb();\n+//                    restarted = true;\n+//                }\n //            }\n+//            finally\n+//            {\n+//                if ( !restarted )\n+//                {\n+//                    tx.finish();\n+//                }\n+//            }\n+//            verifyDb( db );\n+//\n+//            if ( ++txCount % 100 == 0 ) System.out.println( txCount );\n //        }\n-//        finally\n-//        {\n-//            tx.finish();\n-//        }\n-//        Runtime.getRuntime().addShutdownHook( new Thread()\n+//        System.out.println( \"done \" + txCount );\n+//    }\n+//\n+//    private static void verifyDb( GraphDatabaseService db )\n+//    {\n+//        for ( Node node : db.getAllNodes() )\n //        {\n-//            public void run()\n+//            for ( String key : node.getPropertyKeys() )\n //            {\n-//                db.shutdown();\n+//                node.getProperty( key );\n //            }\n-//        } );\n-    }\n-    \n-    private static String figureOutNiceTmpDir() throws IOException\n-    {\n-        File tmpFile = File.createTempFile( \"test\", \"test\" );\n-        File tmpDir = tmpFile.getParentFile();\n-        tmpFile.delete();\n-        File tmpDbDir = new File( tmpDir, \"hadb-backup\" );\n-        \n-        if ( !tmpDbDir.exists() )\n-        {\n-            FileUtils.copyDirectory( PATH, tmpDbDir );\n-        }\n-        return tmpDbDir.getAbsolutePath();\n-    }\n+//            for ( Relationship rel : node.getRelationships( Direction.OUTGOING ) )\n+//            {\n+//                for ( String key : rel.getPropertyKeys() )\n+//                {\n+//                    rel.getProperty( key );\n+//                }\n+//            }\n+//        }\n+//    }\n \n-    private static String join( String[] strings, String delimiter )\n+    public static String join( String[] strings, String delimiter )\n     {\n         StringBuilder builder = new StringBuilder();\n         for ( String string : strings )",
      "parent_sha": "17f285dedd6dc8cbc65d57fad5f8306b3443b6a6"
    }
  },
  {
    "oid": "e4117756a58cc9742d952d41d03e5da55f2904f3",
    "message": "Added parsing of command line args for port and RMI name.\n\n\ngit-svn-id: https://svn.neo4j.org/projects/shell/trunk@14 0b971d98-bb2f-0410-8247-b05b2b5feb2a",
    "date": "2007-05-27T08:07:57Z",
    "url": "https://github.com/neo4j/neo4j/commit/e4117756a58cc9742d952d41d03e5da55f2904f3",
    "details": {
      "sha": "adc234df6385354f25be392035bb1e120822dfbf",
      "filename": "community/src/java/org/neo4j/util/shell/StartRemoteClient.java",
      "status": "modified",
      "additions": 27,
      "deletions": 2,
      "changes": 29,
      "blob_url": "https://github.com/neo4j/neo4j/blob/e4117756a58cc9742d952d41d03e5da55f2904f3/community%2Fsrc%2Fjava%2Forg%2Fneo4j%2Futil%2Fshell%2FStartRemoteClient.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/e4117756a58cc9742d952d41d03e5da55f2904f3/community%2Fsrc%2Fjava%2Forg%2Fneo4j%2Futil%2Fshell%2FStartRemoteClient.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fsrc%2Fjava%2Forg%2Fneo4j%2Futil%2Fshell%2FStartRemoteClient.java?ref=e4117756a58cc9742d952d41d03e5da55f2904f3",
      "patch": "@@ -4,9 +4,34 @@ public class StartRemoteClient\n {\n \tpublic static void main( String[] args ) throws Exception\n \t{\n-\t\t// For now, just check localhost, default port/name\n \t\tShellServer server = ShellLobby.getInstance().findRemoteServer(\n-\t\t\tAbstractServer.DEFAULT_PORT, AbstractServer.DEFAULT_NAME );\n+\t\t\tgetPort( args ), getShellName( args ) );\n \t\tShellLobby.getInstance().startClient( server );\n \t}\n+\t\n+\tprivate static int getPort( String[] args )\n+\t{\n+\t\ttry\n+\t\t{\n+\t\t\treturn args[ 0 ] != null ? Integer.parseInt( args [ 0 ] ) :\n+\t\t\t\tAbstractServer.DEFAULT_PORT;\n+\t\t}\n+\t\tcatch ( ArrayIndexOutOfBoundsException e )\n+\t\t// Intentionally let NumberFormat propagate out to user\n+\t\t{\n+\t\t\treturn AbstractServer.DEFAULT_PORT;\n+\t\t}\n+\t}\n+\t\n+\tprivate static String getShellName( String[] args )\n+\t{\n+\t\ttry\n+\t\t{\n+\t\t\treturn args[ 1 ] != null ? args [ 1 ] : AbstractServer.DEFAULT_NAME;\n+\t\t}\n+\t\tcatch ( ArrayIndexOutOfBoundsException e )\n+\t\t{\n+\t\t\treturn AbstractServer.DEFAULT_NAME;\n+\t\t}\n+\t}\n }",
      "parent_sha": "8dd399530a69f892972b89f82b760fc90e574c6e"
    }
  },
  {
    "oid": "54c3072927bdeef7f0cab0be70c89d3543779afa",
    "message": "Move field to be closer with the rest of the fields\n\nTo improve readability.",
    "date": "2018-10-12T09:16:06Z",
    "url": "https://github.com/neo4j/neo4j/commit/54c3072927bdeef7f0cab0be70c89d3543779afa",
    "details": {
      "sha": "5aa16789b4e89303eb72c03197e362ede82dadbf",
      "filename": "community/bolt/src/main/java/org/neo4j/bolt/v1/runtime/TransactionStateMachine.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/neo4j/neo4j/blob/54c3072927bdeef7f0cab0be70c89d3543779afa/community%2Fbolt%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fbolt%2Fv1%2Fruntime%2FTransactionStateMachine.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/54c3072927bdeef7f0cab0be70c89d3543779afa/community%2Fbolt%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fbolt%2Fv1%2Fruntime%2FTransactionStateMachine.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fbolt%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fbolt%2Fv1%2Fruntime%2FTransactionStateMachine.java?ref=54c3072927bdeef7f0cab0be70c89d3543779afa",
      "patch": "@@ -546,6 +546,8 @@ static class MutableTransactionState\n         /** The current pending result, if present */\n         BoltResult currentResult;\n \n+        BoltResultHandle currentResultHandle;\n+\n         final Clock clock;\n \n         /** A re-usable statement metadata instance that always represents the currently running statement */\n@@ -558,8 +560,6 @@ public String[] fieldNames()\n             }\n         };\n \n-        BoltResultHandle currentResultHandle;\n-\n         private MutableTransactionState( AuthenticationResult authenticationResult, Clock clock )\n         {\n             this.clock = clock;",
      "parent_sha": "91ee743d094d65fdaa5298656a4d2b86549f5150"
    }
  },
  {
    "oid": "c273bbd8945d277b6a0b5fe762cc9bc41fd5f797",
    "message": "Try making PageList.isBoundTo faster.",
    "date": "2018-04-27T12:24:12Z",
    "url": "https://github.com/neo4j/neo4j/commit/c273bbd8945d277b6a0b5fe762cc9bc41fd5f797",
    "details": {
      "sha": "0bdb4d4805bebd8dcff877d3b909ca6ffa9b4490",
      "filename": "community/io/src/main/java/org/neo4j/io/pagecache/impl/muninn/PageList.java",
      "status": "modified",
      "additions": 7,
      "deletions": 3,
      "changes": 10,
      "blob_url": "https://github.com/neo4j/neo4j/blob/c273bbd8945d277b6a0b5fe762cc9bc41fd5f797/community%2Fio%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fio%2Fpagecache%2Fimpl%2Fmuninn%2FPageList.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/c273bbd8945d277b6a0b5fe762cc9bc41fd5f797/community%2Fio%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fio%2Fpagecache%2Fimpl%2Fmuninn%2FPageList.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fio%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fio%2Fpagecache%2Fimpl%2Fmuninn%2FPageList.java?ref=c273bbd8945d277b6a0b5fe762cc9bc41fd5f797",
      "patch": "@@ -58,10 +58,11 @@ class PageList\n     private static final int UNBOUND_LAST_MODIFIED_TX_ID = -1;\n     private static final long MASK_USAGE_COUNT = 0x07;\n     private static final long MASK_NOT_USAGE_COUNT = ~MASK_USAGE_COUNT;\n-    private static final int MAX_USAGE_COUNT = 4;\n-    private static final int MASK_NOT_FILE_PAGE_ID = 0xFFFFFF;\n+    private static final long MAX_USAGE_COUNT = 4;\n+    private static final long MASK_NOT_FILE_PAGE_ID = 0xFFFFFF;\n     private static final int SHIFT_FILE_PAGE_ID = 24;\n     private static final int SHIFT_SWAPPER_ID = 3;\n+    private static final int SHIFT_PARTIAL_FILE_PAGE_ID = SHIFT_FILE_PAGE_ID - SHIFT_SWAPPER_ID;\n     private static final long MASK_SHIFTED_SWAPPER_ID = 0b1_11111_11111_11111_11111;\n     private static final long MASK_NOT_SWAPPER_ID = ~(MASK_SHIFTED_SWAPPER_ID << SHIFT_SWAPPER_ID);\n     private static final long UNBOUND_PAGE_BINDING = PageCursor.UNBOUND_PAGE_ID << SHIFT_FILE_PAGE_ID;\n@@ -450,7 +451,10 @@ public boolean isLoaded( long pageRef )\n \n     public boolean isBoundTo( long pageRef, int swapperId, long filePageId )\n     {\n-        return getSwapperId( pageRef ) == swapperId && getFilePageId( pageRef ) == filePageId;\n+        long address = offPageBinding( pageRef );\n+        long expectedBinding = (filePageId << SHIFT_PARTIAL_FILE_PAGE_ID) + swapperId;\n+        long actualBinding = UnsafeUtil.getLong( address ) >>> SHIFT_SWAPPER_ID;\n+        return expectedBinding == actualBinding;\n     }\n \n     public void fault( long pageRef, PageSwapper swapper, int swapperId, long filePageId, PageFaultEvent event )",
      "parent_sha": "3f960822f3800dda20059799c11182f7a6d531ba"
    }
  },
  {
    "oid": "713e3815b10fdbcbc423559a35195e9a319ccdc4",
    "message": "Change the enum to follow the java naming convention",
    "date": "2018-03-15T10:12:48Z",
    "url": "https://github.com/neo4j/neo4j/commit/713e3815b10fdbcbc423559a35195e9a319ccdc4",
    "details": {
      "sha": "98243652fa9dc2cb7bd9d12248b5d9c0c1d950ff",
      "filename": "community/server/src/main/java/org/neo4j/server/rest/transactional/Neo4jJsonCodec.java",
      "status": "modified",
      "additions": 32,
      "deletions": 12,
      "changes": 44,
      "blob_url": "https://github.com/neo4j/neo4j/blob/713e3815b10fdbcbc423559a35195e9a319ccdc4/community%2Fserver%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fserver%2Frest%2Ftransactional%2FNeo4jJsonCodec.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/713e3815b10fdbcbc423559a35195e9a319ccdc4/community%2Fserver%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fserver%2Frest%2Ftransactional%2FNeo4jJsonCodec.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fserver%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fserver%2Frest%2Ftransactional%2FNeo4jJsonCodec.java?ref=713e3815b10fdbcbc423559a35195e9a319ccdc4",
      "patch": "@@ -52,7 +52,27 @@ public class Neo4jJsonCodec extends ObjectMapper\n {\n     private enum Neo4jJsonMetaType\n     {\n-        node, relationship, datetime, time, localdatetime, date, localtime, duration, point\n+        NODE( \"node\" ),\n+        RELATIONSHIP( \"relationship\" ),\n+        DATE_TIME( \"datetime\" ),\n+        TIME( \"time\" ),\n+        LOCAL_DATE_TIME( \"localdatetime\" ),\n+        DATE( \"date\" ),\n+        LOCAL_TIME( \"localtime\" ),\n+        DURATION( \"duration\" ),\n+        POINT( \"point\" );\n+\n+        private final String code;\n+\n+        Neo4jJsonMetaType( final String code )\n+        {\n+            this.code = code;\n+        }\n+\n+        String code()\n+        {\n+            return this.code;\n+        }\n     }\n \n     private TransitionalPeriodTransactionMessContainer container;\n@@ -238,15 +258,15 @@ void writeMeta( JsonGenerator out, Object value ) throws IOException\n             Node node = (Node) value;\n             try ( TransactionStateChecker stateChecker = TransactionStateChecker.create( container ) )\n             {\n-                writeNodeOrRelationshipMeta( out, node.getId(), Neo4jJsonMetaType.node, stateChecker.isNodeDeletedInCurrentTx( node.getId() ) );\n+                writeNodeOrRelationshipMeta( out, node.getId(), Neo4jJsonMetaType.NODE, stateChecker.isNodeDeletedInCurrentTx( node.getId() ) );\n             }\n         }\n         else if ( value instanceof Relationship )\n         {\n             Relationship relationship = (Relationship) value;\n             try ( TransactionStateChecker transactionStateChecker = TransactionStateChecker.create( container ) )\n             {\n-                writeNodeOrRelationshipMeta( out, relationship.getId(), Neo4jJsonMetaType.relationship,\n+                writeNodeOrRelationshipMeta( out, relationship.getId(), Neo4jJsonMetaType.RELATIONSHIP,\n                         transactionStateChecker.isRelationshipDeletedInCurrentTx( relationship.getId() ) );\n             }\n         }\n@@ -279,7 +299,7 @@ else if ( value instanceof Temporal )\n         }\n         else if ( value instanceof TemporalAmount )\n         {\n-            writeObjectMeta( out, Neo4jJsonMetaType.duration );\n+            writeObjectMeta( out, Neo4jJsonMetaType.DURATION );\n         }\n         else\n         {\n@@ -292,7 +312,7 @@ private Neo4jJsonMetaType parseGeometryType( Geometry value ) throws IOException\n         Neo4jJsonMetaType type = null;\n         if ( value instanceof Point )\n         {\n-            type = Neo4jJsonMetaType.point;\n+            type = Neo4jJsonMetaType.POINT;\n         }\n         if ( type == null )\n         {\n@@ -307,23 +327,23 @@ private Neo4jJsonMetaType parseTemporalType( Temporal value )\n         Neo4jJsonMetaType type = null;\n         if ( value instanceof ZonedDateTime )\n         {\n-            type = Neo4jJsonMetaType.datetime;\n+            type = Neo4jJsonMetaType.DATE_TIME;\n         }\n         else if ( value instanceof LocalDate )\n         {\n-            type = Neo4jJsonMetaType.date;\n+            type = Neo4jJsonMetaType.DATE;\n         }\n         else if ( value instanceof OffsetTime )\n         {\n-            type = Neo4jJsonMetaType.time;\n+            type = Neo4jJsonMetaType.TIME;\n         }\n         else if ( value instanceof LocalDateTime )\n         {\n-            type = Neo4jJsonMetaType.localdatetime;\n+            type = Neo4jJsonMetaType.LOCAL_DATE_TIME;\n         }\n         else if ( value instanceof LocalTime )\n         {\n-            type = Neo4jJsonMetaType.localtime;\n+            type = Neo4jJsonMetaType.LOCAL_TIME;\n         }\n         if ( type == null )\n         {\n@@ -356,7 +376,7 @@ private void writeObjectMeta( JsonGenerator out, Neo4jJsonMetaType type )\n         out.writeStartObject();\n         try\n         {\n-            out.writeStringField( \"type\", type.name() );\n+            out.writeStringField( \"type\", type.code() );\n         }\n         finally\n         {\n@@ -372,7 +392,7 @@ private void writeNodeOrRelationshipMeta( JsonGenerator out, long id, Neo4jJsonM\n         try\n         {\n             out.writeNumberField( \"id\", id );\n-            out.writeStringField( \"type\", type.name() );\n+            out.writeStringField( \"type\", type.code() );\n             out.writeBooleanField( \"deleted\", isDeleted );\n         }\n         finally",
      "parent_sha": "aef96dabd1084685a92939f9616d4b339fa6749a"
    }
  },
  {
    "oid": "000277034fa25e5afe5200438385a0f2e043f7cd",
    "message": "Update RWLockTest to use global common timeouts instead of custom.",
    "date": "2019-11-15T10:01:39Z",
    "url": "https://github.com/neo4j/neo4j/commit/000277034fa25e5afe5200438385a0f2e043f7cd",
    "details": {
      "sha": "7e7a6543de2f060f2505735eb91ef300baff6bb8",
      "filename": "community/kernel/src/test/java/org/neo4j/kernel/impl/locking/community/RWLockTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 8,
      "changes": 9,
      "blob_url": "https://github.com/neo4j/neo4j/blob/000277034fa25e5afe5200438385a0f2e043f7cd/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Flocking%2Fcommunity%2FRWLockTest.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/000277034fa25e5afe5200438385a0f2e043f7cd/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Flocking%2Fcommunity%2FRWLockTest.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Flocking%2Fcommunity%2FRWLockTest.java?ref=000277034fa25e5afe5200438385a0f2e043f7cd",
      "patch": "@@ -22,7 +22,6 @@\n import org.junit.jupiter.api.AfterAll;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.Timeout;\n \n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.ExecutorService;\n@@ -43,7 +42,6 @@\n \n class RWLockTest\n {\n-    private static final long TEST_TIMEOUT_SECS = 10;\n \n     private static ExecutorService executor;\n \n@@ -99,7 +97,6 @@ void assertReadLockDoesNotLeakMemory()\n      * into a waiting list, wait till resource will be free and grab it.\n      */\n     @Test\n-    @Timeout( TEST_TIMEOUT_SECS )\n     void testWaitingWriterLock() throws Exception\n     {\n         RagManager ragManager = new RagManager();\n@@ -145,7 +142,6 @@ void testWaitingWriterLock() throws Exception\n     }\n \n     @Test\n-    @Timeout( TEST_TIMEOUT_SECS )\n     void testWaitingReaderLock() throws Exception\n     {\n         RagManager ragManager = new RagManager();\n@@ -185,7 +181,6 @@ void testWaitingReaderLock() throws Exception\n     }\n \n     @Test\n-    @Timeout( TEST_TIMEOUT_SECS )\n     void testThreadRemovedFromWaitingListOnDeadlock() throws Exception\n     {\n         RagManager ragManager = mock( RagManager.class );\n@@ -331,16 +326,14 @@ void testDeadlockDetection() throws Exception\n         executor.execute( readerLockNode1 );\n \n         // Deadlock should occur\n-        assertTrue(\n-            deadLockDetector.await( TEST_TIMEOUT_SECS, TimeUnit.SECONDS ), \"Deadlock was detected as expected.\" );\n+        assertTrue( deadLockDetector.await( 100, TimeUnit.SECONDS ), \"Deadlock was detected as expected.\" );\n \n         lockNode3.releaseWriteLock( client3Transaction );\n         lockNode2.releaseWriteLock( client2Transaction );\n         lockNode1.releaseWriteLock( client1Transaction );\n     }\n \n     @Test\n-    @Timeout( TEST_TIMEOUT_SECS )\n     void testLockRequestsTermination() throws Exception\n     {\n         // given",
      "parent_sha": "410912f3502de820fbf3d782a370117c074a6133"
    }
  },
  {
    "oid": "654b4fff31301023680aaeb11f5ab85588e8e776",
    "message": "Keeps logical logs\n\n\ngit-svn-id: https://svn.neo4j.org/laboratory/components/ha/src@5166 0b971d98-bb2f-0410-8247-b05b2b5feb2a",
    "date": "2010-08-16T11:32:54Z",
    "url": "https://github.com/neo4j/neo4j/commit/654b4fff31301023680aaeb11f5ab85588e8e776",
    "details": {
      "sha": "10a2d5f414252e435ead7e2cbd5a882fe08cfcf8",
      "filename": "enterprise/test/java/slavetest/StartHaDb.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/neo4j/neo4j/blob/654b4fff31301023680aaeb11f5ab85588e8e776/enterprise%2Ftest%2Fjava%2Fslavetest%2FStartHaDb.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/654b4fff31301023680aaeb11f5ab85588e8e776/enterprise%2Ftest%2Fjava%2Fslavetest%2FStartHaDb.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/enterprise%2Ftest%2Fjava%2Fslavetest%2FStartHaDb.java?ref=654b4fff31301023680aaeb11f5ab85588e8e776",
      "patch": "@@ -27,7 +27,8 @@ public static void main( String[] args ) throws Exception\n                 HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"1\",\n                 HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS, join( StartZooKeeperServer.ZOO_KEEPER_SERVERS, \",\" ),\n                 HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVERS, toHaServerFormat( HA_SERVERS ),\n-                \"enable_remote_shell\", \"true\" ) );\n+                \"enable_remote_shell\", \"true\",\n+                \"keep_logical_logs\", \"true\" ) );\n //        Runtime.getRuntime().addShutdownHook( new Thread()\n //        {\n //            public void run()",
      "parent_sha": "fac4c4bbec661b21253ba62365ea9bf3fd850c58"
    }
  },
  {
    "oid": "2a691fa2780ab1df56763a1f04062a7316bc6c68",
    "message": "FIxed test on UserServiceTest to use new User creation",
    "date": "2016-06-09T12:05:51Z",
    "url": "https://github.com/neo4j/neo4j/commit/2a691fa2780ab1df56763a1f04062a7316bc6c68",
    "details": {
      "sha": "ea526e61981c6ce157e81cf9164a98c98b8386e7",
      "filename": "community/server/src/test/java/org/neo4j/server/rest/dbms/UserServiceTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/neo4j/neo4j/blob/2a691fa2780ab1df56763a1f04062a7316bc6c68/community%2Fserver%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fserver%2Frest%2Fdbms%2FUserServiceTest.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/2a691fa2780ab1df56763a1f04062a7316bc6c68/community%2Fserver%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fserver%2Frest%2Fdbms%2FUserServiceTest.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fserver%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fserver%2Frest%2Fdbms%2FUserServiceTest.java?ref=2a691fa2780ab1df56763a1f04062a7316bc6c68",
      "patch": "@@ -65,7 +65,8 @@ public String getName()\n             return \"neo4j\";\n         }\n     };\n-    private static final User NEO4J_USER = new User( \"neo4j\", Credential.forPassword( \"neo4j\" ), true );\n+    private static final User NEO4J_USER = new User.Builder( \"neo4j\", Credential.forPassword( \"neo4j\" ))\n+            .withRequiredPasswordChange( true ).build();\n \n     private final PasswordPolicy passwordPolicy = new BasicPasswordPolicy();\n     private final InMemoryUserRepository userRepository = new InMemoryUserRepository();",
      "parent_sha": "f47efa32b4d659cf913a29dc01e811305050994b"
    }
  },
  {
    "oid": "f0565eb002b93fcb25d1020d3b8007576507985c",
    "message": "Rename variable.",
    "date": "2016-08-16T14:24:25Z",
    "url": "https://github.com/neo4j/neo4j/commit/f0565eb002b93fcb25d1020d3b8007576507985c",
    "details": {
      "sha": "d73869ade6c6428369d5cd2a6d1c6eaeca34066c",
      "filename": "enterprise/core-edge/src/main/java/org/neo4j/coreedge/core/consensus/ConsensusModule.java",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/neo4j/neo4j/blob/f0565eb002b93fcb25d1020d3b8007576507985c/enterprise%2Fcore-edge%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fcoreedge%2Fcore%2Fconsensus%2FConsensusModule.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/f0565eb002b93fcb25d1020d3b8007576507985c/enterprise%2Fcore-edge%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fcoreedge%2Fcore%2Fconsensus%2FConsensusModule.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/enterprise%2Fcore-edge%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fcoreedge%2Fcore%2Fconsensus%2FConsensusModule.java?ref=f0565eb002b93fcb25d1020d3b8007576507985c",
      "patch": "@@ -143,8 +143,8 @@ public ConsensusModule( MemberId myself, final PlatformModule platformModule, Ra\n             throw new RuntimeException( e );\n         }\n \n-        long electionTimeout1 = config.get( CoreEdgeClusterSettings.leader_election_timeout );\n-        long heartbeatInterval = electionTimeout1 / 3;\n+        long electionTimeout = config.get( CoreEdgeClusterSettings.leader_election_timeout );\n+        long heartbeatInterval = electionTimeout / 3;\n \n         Integer expectedClusterSize = config.get( CoreEdgeClusterSettings.expected_core_cluster_size );\n \n@@ -154,22 +154,22 @@ public ConsensusModule( MemberId myself, final PlatformModule platformModule, Ra\n                 new SendToMyself( myself, loggingOutbound );\n \n         raftMembershipManager = new RaftMembershipManager( leaderOnlyReplicator, memberSetBuilder, raftLog, logProvider,\n-               expectedClusterSize, electionTimeout1, systemUTC(),\n+               expectedClusterSize, electionTimeout, systemUTC(),\n                config.get( CoreEdgeClusterSettings.join_catch_up_timeout ), raftMembershipStorage\n         );\n \n         life.add( raftMembershipManager );\n \n         RaftLogShippingManager logShipping =\n                 new RaftLogShippingManager( loggingOutbound, logProvider, raftLog, systemUTC(),\n-                        myself, raftMembershipManager, electionTimeout1,\n+                        myself, raftMembershipManager, electionTimeout,\n                         config.get( CoreEdgeClusterSettings.catchup_batch_size ),\n                         config.get( CoreEdgeClusterSettings.log_shipping_max_lag ), inFlightMap );\n \n         raftTimeoutService = new DelayedRenewableTimeoutService( systemUTC(), logProvider );\n \n         raftMachine =\n-                new RaftMachine( myself, termState, voteState, raftLog, electionTimeout1,\n+                new RaftMachine( myself, termState, voteState, raftLog, electionTimeout,\n                         heartbeatInterval, raftTimeoutService, loggingOutbound, logProvider, raftMembershipManager,\n                         logShipping, inFlightMap, platformModule.monitors );\n ",
      "parent_sha": "1b2a9fce630ae48434fa8feafd06587a4c28bdb3"
    }
  },
  {
    "oid": "dd5607428a0c67ef17c63b95204b03ee639604f1",
    "message": "Changed the way resources are read in, hopefully deals with jars and files now.\n\ngit-svn-id: https://svn.neo4j.org/components/server/trunk@6638 0b971d98-bb2f-0410-8247-b05b2b5feb2a",
    "date": "2010-11-03T17:50:40Z",
    "url": "https://github.com/neo4j/neo4j/commit/dd5607428a0c67ef17c63b95204b03ee639604f1",
    "details": {
      "sha": "e015626b8caf6cd7f103116c48441d36db0876e6",
      "filename": "packaging/src/main/java/org/neo4j/server/web/Jetty6WebServer.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/neo4j/neo4j/blob/dd5607428a0c67ef17c63b95204b03ee639604f1/packaging%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fserver%2Fweb%2FJetty6WebServer.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/dd5607428a0c67ef17c63b95204b03ee639604f1/packaging%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fserver%2Fweb%2FJetty6WebServer.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/packaging%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fserver%2Fweb%2FJetty6WebServer.java?ref=dd5607428a0c67ef17c63b95204b03ee639604f1",
      "patch": "@@ -30,7 +30,6 @@\n import org.mortbay.jetty.servlet.Context;\n import org.mortbay.jetty.servlet.ServletHolder;\n import org.mortbay.jetty.webapp.WebAppContext;\n-import org.mortbay.resource.FileResource;\n import org.mortbay.resource.Resource;\n import org.mortbay.thread.QueuedThreadPool;\n \n@@ -58,7 +57,7 @@ public void start() {\n             webadmin.setServer(jetty);\n             webadmin.setContextPath(\"/\" + contentContextPath);\n             URL url = getClass().getClassLoader().getResource(contentResourcePath).toURI().toURL();\n-            final Resource resource = new FileResource(url);\n+            final Resource resource = Resource.newResource(url);\n             webadmin.setBaseResource(resource);\n             jetty.addHandler(webadmin);\n         } catch (Exception e) {",
      "parent_sha": "e03696365430bcca389cc1b8fdacb2dd896cbba7"
    }
  },
  {
    "oid": "75bd69359eddc5545907a905e065186f6e99530b",
    "message": "Fix internal setting namespace",
    "date": "2022-04-22T06:11:19Z",
    "url": "https://github.com/neo4j/neo4j/commit/75bd69359eddc5545907a905e065186f6e99530b",
    "details": {
      "sha": "180d1244f79eb4a339b7a244e086b812ecba1e0d",
      "filename": "community/configuration/src/main/java/org/neo4j/configuration/GraphDatabaseInternalSettings.java",
      "status": "modified",
      "additions": 1,
      "deletions": 6,
      "changes": 7,
      "blob_url": "https://github.com/neo4j/neo4j/blob/75bd69359eddc5545907a905e065186f6e99530b/community%2Fconfiguration%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fconfiguration%2FGraphDatabaseInternalSettings.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/75bd69359eddc5545907a905e065186f6e99530b/community%2Fconfiguration%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fconfiguration%2FGraphDatabaseInternalSettings.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fconfiguration%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fconfiguration%2FGraphDatabaseInternalSettings.java?ref=75bd69359eddc5545907a905e065186f6e99530b",
      "patch": "@@ -286,14 +286,9 @@ public enum CypherWorkerManagement\n     }\n     @Internal\n     @Description( \"The worker management determines how the Cypher parallel runtime will distribute query execution work between multiple threads.\" )\n-    public static final Setting<CypherWorkerManagement> cypher_worker_management = newBuilder( \"unsupported.cypher.worker_management\",\n+    public static final Setting<CypherWorkerManagement> cypher_worker_management = newBuilder( \"internal.cypher.worker_management\",\n             ofEnum( CypherWorkerManagement.class ), CypherWorkerManagement.DEFAULT ).build();\n \n-    @Internal\n-    @Description( \"Feature flag to force produce result to always be in a separate pipeline\" )\n-    public static final Setting<Boolean> produce_result_in_separate_pipeline =\n-            newBuilder( \"unsupported.cypher.produce_result_in_separate_pipeline\", BOOL, false ).build();\n-\n     public enum CypherOperatorEngine\n     {\n         DEFAULT, COMPILED, INTERPRETED",
      "parent_sha": "cfb174e5a04b75a8fc64e519ac478a23eae3b557"
    }
  },
  {
    "oid": "10541fa9d884569e3e18a15164f6fbaa1ed0516e",
    "message": "Fixes synchronization issue with delivery of learn messages on instance join\n\nThis makes sure that learn messages sent from us for us are treated as internal\n messages. That way they will be synchronously processed before any other\n incoming messages.\nThis is expected to solve some intermittent test failures.",
    "date": "2013-02-07T11:11:37Z",
    "url": "https://github.com/neo4j/neo4j/commit/10541fa9d884569e3e18a15164f6fbaa1ed0516e",
    "details": {
      "sha": "e76536e082faa572c0012285e4a96c5260a5c102",
      "filename": "enterprise/cluster/src/main/java/org/neo4j/cluster/protocol/atomicbroadcast/multipaxos/ProposerState.java",
      "status": "modified",
      "additions": 13,
      "deletions": 4,
      "changes": 17,
      "blob_url": "https://github.com/neo4j/neo4j/blob/10541fa9d884569e3e18a15164f6fbaa1ed0516e/enterprise%2Fcluster%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fcluster%2Fprotocol%2Fatomicbroadcast%2Fmultipaxos%2FProposerState.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/10541fa9d884569e3e18a15164f6fbaa1ed0516e/enterprise%2Fcluster%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fcluster%2Fprotocol%2Fatomicbroadcast%2Fmultipaxos%2FProposerState.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/enterprise%2Fcluster%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fcluster%2Fprotocol%2Fatomicbroadcast%2Fmultipaxos%2FProposerState.java?ref=10541fa9d884569e3e18a15164f6fbaa1ed0516e",
      "patch": "@@ -322,10 +322,19 @@ else if ( instance.clientValue )\n                                         // configuration changes\n                                         for ( URI learner : context.getLearners() )\n                                         {\n-                                            outgoing.offer( message.copyHeadersTo( Message.to( LearnerMessage\n-                                                    .learn, learner,\n-                                                    new LearnerMessage.LearnState( instance.value_2 ) ),\n-                                                    InstanceId.INSTANCE ) );\n+                                            if ( learner.equals( context.clusterContext.getMe() ))\n+                                            {\n+                                                outgoing.offer( message.copyHeadersTo( Message.internal( LearnerMessage\n+                                                        .learn, new LearnerMessage.LearnState( instance.value_2 ) ),\n+                                                        InstanceId.INSTANCE ) );\n+                                            }\n+                                            else\n+                                            {\n+                                                outgoing.offer( message.copyHeadersTo( Message.to( LearnerMessage\n+                                                        .learn, learner,\n+                                                        new LearnerMessage.LearnState( instance.value_2 ) ),\n+                                                        InstanceId.INSTANCE ) );\n+                                            }\n                                         }\n \n                                         // Tell joiner of this cluster configuration change",
      "parent_sha": "ab6a6de746152e8ef28e8b4c4395fd5d8d4d38a5"
    }
  },
  {
    "oid": "4e9a5faef986175e9544720ce9477089075e6757",
    "message": "Do not interrupt threads running on a scheduled timer\n\nSome of the threads running on a timer in core-edge will end up\n doing I/O ops when updating the instance state. This can, during\n shutdown, cause ClosedByInterruptException and leave the instance\n in an unknown state.\nThis change ensures that shutting down the scheduler service will allow\n threads to complete uninterruptibly.",
    "date": "2015-12-01T13:32:26Z",
    "url": "https://github.com/neo4j/neo4j/commit/4e9a5faef986175e9544720ce9477089075e6757",
    "details": {
      "sha": "814818e37b1b84992dd43507f7eb40b06aef3eed",
      "filename": "enterprise/core-edge/src/main/java/org/neo4j/coreedge/raft/ScheduledTimeoutService.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/neo4j/neo4j/blob/4e9a5faef986175e9544720ce9477089075e6757/enterprise%2Fcore-edge%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fcoreedge%2Fraft%2FScheduledTimeoutService.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/4e9a5faef986175e9544720ce9477089075e6757/enterprise%2Fcore-edge%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fcoreedge%2Fraft%2FScheduledTimeoutService.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/enterprise%2Fcore-edge%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fcoreedge%2Fraft%2FScheduledTimeoutService.java?ref=4e9a5faef986175e9544720ce9477089075e6757",
      "patch": "@@ -160,7 +160,7 @@ public void start() throws Throwable\n     @Override\n     public void stop() throws Throwable\n     {\n-        jobHandle.cancel( true );\n+        jobHandle.cancel( false );\n         scheduler.shutdown();\n     }\n ",
      "parent_sha": "98930086672e11f61ed3adf7e05430617b14568b"
    }
  },
  {
    "oid": "83df8df8db7ebbf647910e8f2be7689bc16b611b",
    "message": "Fix compilation after forward merge.",
    "date": "2017-12-19T18:43:54Z",
    "url": "https://github.com/neo4j/neo4j/commit/83df8df8db7ebbf647910e8f2be7689bc16b611b",
    "details": {
      "sha": "a3ba1130ab4745805ab6e2abac7a5dfa1b1cffaf",
      "filename": "community/kernel/src/test/java/org/neo4j/kernel/impl/transaction/log/checkpoint/CheckPointThresholdTestSupport.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/neo4j/neo4j/blob/83df8df8db7ebbf647910e8f2be7689bc16b611b/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Ftransaction%2Flog%2Fcheckpoint%2FCheckPointThresholdTestSupport.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/83df8df8db7ebbf647910e8f2be7689bc16b611b/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Ftransaction%2Flog%2Fcheckpoint%2FCheckPointThresholdTestSupport.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Ftransaction%2Flog%2Fcheckpoint%2FCheckPointThresholdTestSupport.java?ref=83df8df8db7ebbf647910e8f2be7689bc16b611b",
      "patch": "@@ -55,7 +55,7 @@ public class CheckPointThresholdTestSupport\n     @Before\n     public void setUp()\n     {\n-        config = Config.empty();\n+        config = Config.defaults();\n         clock = Clocks.fakeClock();\n         logPruning = LogPruning.NO_PRUNING;\n         logProvider = NullLogProvider.getInstance();",
      "parent_sha": "c3cc904112d608b3d38a019747350db46d52b928"
    }
  },
  {
    "oid": "a0d47b33a01adc380877c78b869484a0452ce357",
    "message": "Don't test with null string array",
    "date": "2017-08-06T18:01:17Z",
    "url": "https://github.com/neo4j/neo4j/commit/a0d47b33a01adc380877c78b869484a0452ce357",
    "details": {
      "sha": "97d363cc7b601236c6de7c3c909c49e4146d6099",
      "filename": "community/kernel/src/test/java/org/neo4j/kernel/impl/index/schema/combined/CombinedIndexTestHelp.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/neo4j/neo4j/blob/a0d47b33a01adc380877c78b869484a0452ce357/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Findex%2Fschema%2Fcombined%2FCombinedIndexTestHelp.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/a0d47b33a01adc380877c78b869484a0452ce357/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Findex%2Fschema%2Fcombined%2FCombinedIndexTestHelp.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Findex%2Fschema%2Fcombined%2FCombinedIndexTestHelp.java?ref=a0d47b33a01adc380877c78b869484a0452ce357",
      "patch": "@@ -66,7 +66,7 @@ class CombinedIndexTestHelp\n                     Values.floatArray( new float[]{9.10f, 11.12f} ),\n                     Values.doubleArray( new double[]{13.14, 15.16} ),\n                     Values.charArray( new char[2] ),\n-                    Values.stringArray( new String[2] ),\n+                    Values.stringArray( new String[]{\"a\", \"b\"} ),\n                     Values.NO_VALUE\n             };\n ",
      "parent_sha": "c3455430a6eead535ced44382531047a15f60cae"
    }
  },
  {
    "oid": "fb98841c11ffa54697129a84df508f15d057585e",
    "message": "Add a state check to avoid starting multiple fulltext applier threads, and increase the population transaction timeout to 10 hours to patiently wait for very long recovery times if necessary",
    "date": "2017-09-19T12:09:21Z",
    "url": "https://github.com/neo4j/neo4j/commit/fb98841c11ffa54697129a84df508f15d057585e",
    "details": {
      "sha": "abd6683d5f792c3772cbe287814c17fc04b098f6",
      "filename": "enterprise/fulltext-addon/src/main/java/org/neo4j/kernel/api/impl/fulltext/FulltextUpdateApplier.java",
      "status": "modified",
      "additions": 9,
      "deletions": 3,
      "changes": 12,
      "blob_url": "https://github.com/neo4j/neo4j/blob/fb98841c11ffa54697129a84df508f15d057585e/enterprise%2Ffulltext-addon%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fapi%2Fimpl%2Ffulltext%2FFulltextUpdateApplier.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/fb98841c11ffa54697129a84df508f15d057585e/enterprise%2Ffulltext-addon%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fapi%2Fimpl%2Ffulltext%2FFulltextUpdateApplier.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/enterprise%2Ffulltext-addon%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fapi%2Fimpl%2Ffulltext%2FFulltextUpdateApplier.java?ref=fb98841c11ffa54697129a84df508f15d057585e",
      "patch": "@@ -26,6 +26,7 @@\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n import java.util.function.Predicate;\n import java.util.function.Supplier;\n import java.util.stream.Collectors;\n@@ -48,14 +49,13 @@ class FulltextUpdateApplier\n {\n     private static final FulltextIndexUpdate STOP_SIGNAL = () -> null;\n     private final LinkedBlockingQueue<FulltextIndexUpdate> workQueue;\n-    private final ApplierThread workerThread;\n     private final Log log;\n+    private ApplierThread workerThread;\n \n     FulltextUpdateApplier( Log log )\n     {\n         this.log = log;\n         workQueue = new LinkedBlockingQueue<>();\n-        workerThread = new ApplierThread( workQueue, log );\n     }\n \n     <E extends Entity> BinaryLatch updatePropertyData( Map<Long,Map<String,Object>> state, WritableFulltext index ) throws\n@@ -149,7 +149,7 @@ private BinaryLatch enqueuePopulateIndex( WritableFulltext index, GraphDatabaseS\n         {\n             PartitionedIndexWriter indexWriter = index.getIndexWriter();\n             String[] indexedPropertyKeys = index.properties().toArray( new String[0] );\n-            try ( Transaction tx = db.beginTx() )\n+            try ( Transaction ignore = db.beginTx( 10, TimeUnit.HOURS ) )\n             {\n                 ResourceIterable<? extends Entity> entities = entitySupplier.get();\n                 for ( Entity entity : entities )\n@@ -184,6 +184,11 @@ private void enqueueUpdate( FulltextIndexUpdate update ) throws IOException\n \n     void start()\n     {\n+        if ( workerThread != null )\n+        {\n+            throw new IllegalStateException( workerThread.getName() + \" already started.\" );\n+        }\n+        workerThread = new ApplierThread( workQueue, log );\n         workerThread.start();\n     }\n \n@@ -199,6 +204,7 @@ void stop()\n         try\n         {\n             workerThread.join();\n+            workerThread = null;\n         }\n         catch ( InterruptedException e )\n         {",
      "parent_sha": "f8cebab60611c41a4bceeb6205878a07eec62e32"
    }
  },
  {
    "oid": "39474ddf8419f83b553ae0d5f38ab4fdf4904afa",
    "message": "Added test to avoid regression\n\nThe test has been introduced to reproduce an inconsistent issue\npresent in 2.2.2 and it can reproduce the problem at every run.\n\nThe problem details are the following:\n- adding a property to the node from a slave\n- changing such introduced property from the master\n- causes to introduce twice the property key in the property chain\n\nThe original issue in 2.2.2 was caused by a cache poisoning (the cache\non the master didn't contain the added property from the slave) which\ncannot be reproduced in later versions of the product.",
    "date": "2015-08-06T08:41:49Z",
    "url": "https://github.com/neo4j/neo4j/commit/39474ddf8419f83b553ae0d5f38ab4fdf4904afa",
    "details": {
      "sha": "448663cda816d055303bcbb0385251e2b6b34990",
      "filename": "enterprise/ha/src/test/java/org/neo4j/ha/HaCacheIT.java",
      "status": "modified",
      "additions": 104,
      "deletions": 4,
      "changes": 108,
      "blob_url": "https://github.com/neo4j/neo4j/blob/39474ddf8419f83b553ae0d5f38ab4fdf4904afa/enterprise%2Fha%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fha%2FHaCacheIT.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/39474ddf8419f83b553ae0d5f38ab4fdf4904afa/enterprise%2Fha%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fha%2FHaCacheIT.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/enterprise%2Fha%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fha%2FHaCacheIT.java?ref=39474ddf8419f83b553ae0d5f38ab4fdf4904afa",
      "patch": "@@ -19,29 +19,36 @@\n  */\n package org.neo4j.ha;\n \n-import java.util.ArrayList;\n-import java.util.List;\n-\n import org.junit.Rule;\n import org.junit.Test;\n \n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.neo4j.consistency.ConsistencyCheckService;\n+import org.neo4j.graphdb.GraphDatabaseService;\n import org.neo4j.graphdb.Node;\n import org.neo4j.graphdb.Relationship;\n import org.neo4j.graphdb.Transaction;\n+import org.neo4j.helpers.progress.ProgressMonitorFactory;\n+import org.neo4j.io.fs.FileUtils;\n+import org.neo4j.kernel.configuration.Config;\n import org.neo4j.kernel.ha.HighlyAvailableGraphDatabase;\n+import org.neo4j.kernel.impl.util.StringLogger;\n import org.neo4j.test.TargetDirectory.TestDirectory;\n import org.neo4j.test.ha.ClusterManager;\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n-\n import static org.neo4j.graphdb.DynamicRelationshipType.withName;\n import static org.neo4j.graphdb.factory.GraphDatabaseSettings.cache_type;\n import static org.neo4j.graphdb.factory.GraphDatabaseSettings.dense_node_threshold;\n import static org.neo4j.helpers.collection.IteratorUtil.count;\n import static org.neo4j.helpers.collection.MapUtil.stringMap;\n import static org.neo4j.kernel.ha.HaSettings.tx_push_factor;\n import static org.neo4j.test.TargetDirectory.forTest;\n+import static org.neo4j.test.ha.ClusterManager.allSeesAllAsAvailable;\n import static org.neo4j.test.ha.ClusterManager.clusterOfSize;\n \n public class HaCacheIT\n@@ -125,6 +132,99 @@ public void shouldUpdateSlaveCacheWhenRemovingRelationshipGroupFromDenseNode() t\n         }\n     }\n \n+    /*\n+     * This test has been introduced to reproduce an inconsistent issue present in 2.2.2 and it can reproduce the\n+     * problem at every run.\n+     *\n+     * The problem details are the following:\n+     * - adding a property to the node from a slave\n+     * - changing such introduced property from the master\n+     * - causes to introduce twice the property key in the property chain\n+     *\n+     * The original issue in 2.2.2 was caused by a cache poisoning (the cache on the master didn't contain the added\n+     * property from the slave) which cannot be reproduced in later versions of the product.\n+     *\n+     * This test has been added only to make sure we do not regress and introduce this problem once again.\n+     */\n+    @Test\n+    public void duplicatePropertyWhenAddingChangingAPropertyFromSlaveAndMasterRespectively() throws Throwable\n+    {\n+        File storeDir = root.directory( \"ha-cluster\" );\n+        FileUtils.deleteRecursively( storeDir );\n+        ClusterManager clusterManager = new ClusterManager(\n+                new ClusterManager.Builder( storeDir ).withProvider( clusterOfSize( 3 ) )\n+        );\n+\n+        clusterManager.start();\n+        ClusterManager.ManagedCluster cluster = clusterManager.getDefaultCluster();\n+        cluster.await( allSeesAllAsAvailable() );\n+\n+        long id = init( cluster.getMaster() );\n+        cluster.sync();\n+\n+        GraphDatabaseService slave = cluster.getAnySlave();\n+\n+        // when\n+        // adding a new property by writing on the slave\n+        try ( Transaction tx = slave.beginTx() )\n+        {\n+            Node node = slave.getNodeById( id );\n+            node.setProperty( \"1\", 1 );\n+\n+            tx.success();\n+        }\n+\n+        Thread.sleep( 100 );\n+\n+        // and changing the introduced property on the master\n+        GraphDatabaseService master = cluster.getMaster();\n+        try ( Transaction tx = master.beginTx() )\n+        {\n+            Node node = master.getNodeById( id );\n+            node.setProperty( \"1\", 0 );\n+            tx.success();\n+        }\n+\n+        clusterManager.stop();\n+        clusterManager.shutdown();\n+\n+        // then there should be no property key duplications in the property chain\n+        String masterStoreDir = new File( storeDir, \"neo4j.ha/server1\" ).getAbsolutePath();\n+        ConsistencyCheckService.Result result =\n+                new ConsistencyCheckService().runFullConsistencyCheck( masterStoreDir, new Config(),\n+                        ProgressMonitorFactory.NONE, StringLogger.SYSTEM_ERR );\n+\n+        assertTrue( result.isSuccessful() );\n+    }\n+\n+    private long init( GraphDatabaseService db )\n+    {\n+        // create 2 prop keys before hand and \"the node\" used in the test\n+        long id;\n+        try ( Transaction tx = db.beginTx() )\n+        {\n+            Node theNode = db.createNode();\n+            id = theNode.getId();\n+            for ( int i = 0; i < 1; i++ )\n+            {\n+                Node node = db.createNode();\n+                node.setProperty( \"\" + i, \"\" + i );\n+            }\n+            tx.success();\n+        }\n+\n+\n+        // set one property on the node\n+        try ( Transaction tx = db.beginTx() )\n+        {\n+            Node node = db.getNodeById( id );\n+            node.setProperty( \"0\", 0 );\n+            tx.success();\n+        }\n+\n+        return id;\n+    }\n+\n     private String joinLines( Iterable<String> lines )\n     {\n         StringBuilder result = new StringBuilder();",
      "parent_sha": "9a0d11c9764ff66cfaa8db0aa8d429ce2cf34090"
    }
  },
  {
    "oid": "f9f68916c10e360ae9cdfe965297ebceca109118",
    "message": "Fix compilation error",
    "date": "2016-05-18T09:05:36Z",
    "url": "https://github.com/neo4j/neo4j/commit/f9f68916c10e360ae9cdfe965297ebceca109118",
    "details": {
      "sha": "e6975f61b3805479ef7bf5b638e1987bab2ea29d",
      "filename": "enterprise/core-edge/src/test/java/org/neo4j/coreedge/scenarios/CorePruningIT.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/neo4j/neo4j/blob/f9f68916c10e360ae9cdfe965297ebceca109118/enterprise%2Fcore-edge%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fcoreedge%2Fscenarios%2FCorePruningIT.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/f9f68916c10e360ae9cdfe965297ebceca109118/enterprise%2Fcore-edge%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fcoreedge%2Fscenarios%2FCorePruningIT.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/enterprise%2Fcore-edge%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fcoreedge%2Fscenarios%2FCorePruningIT.java?ref=f9f68916c10e360ae9cdfe965297ebceca109118",
      "patch": "@@ -25,6 +25,7 @@\n \n import java.io.File;\n import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n \n import org.neo4j.coreedge.discovery.Cluster;\n import org.neo4j.coreedge.discovery.TestOnlyDiscoveryServiceFactory;\n@@ -50,7 +51,7 @@ public class CorePruningIT\n     private Cluster cluster;\n \n     @After\n-    public void shutdown()\n+    public void shutdown() throws ExecutionException, InterruptedException\n     {\n         if ( cluster != null )\n         {",
      "parent_sha": "aead9ae45d71e7719607b1abe0e0220800b7fecf"
    }
  },
  {
    "oid": "9357f5a5b2e5ffa025ea5626e7906527367956bf",
    "message": "handle imports",
    "date": "2019-10-11T21:57:44Z",
    "url": "https://github.com/neo4j/neo4j/commit/9357f5a5b2e5ffa025ea5626e7906527367956bf",
    "details": {
      "sha": "230c6c067e9084e354461657ddb517d4f950c461",
      "filename": "community/push-to-cloud/src/test/java/org/neo4j/pushtocloud/PushToCloudCommandTest.java",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/neo4j/neo4j/blob/9357f5a5b2e5ffa025ea5626e7906527367956bf/community%2Fpush-to-cloud%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fpushtocloud%2FPushToCloudCommandTest.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/9357f5a5b2e5ffa025ea5626e7906527367956bf/community%2Fpush-to-cloud%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fpushtocloud%2FPushToCloudCommandTest.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fpush-to-cloud%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fpushtocloud%2FPushToCloudCommandTest.java?ref=9357f5a5b2e5ffa025ea5626e7906527367956bf",
      "patch": "@@ -51,7 +51,14 @@\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n import static org.neo4j.helpers.collection.Iterators.array;\n-import static org.neo4j.pushtocloud.PushToCloudCommand.*;\n+import static org.neo4j.pushtocloud.PushToCloudCommand.ARG_BOLT_URI;\n+import static org.neo4j.pushtocloud.PushToCloudCommand.ARG_DATABASE;\n+import static org.neo4j.pushtocloud.PushToCloudCommand.ARG_CONFIRMED;\n+import static org.neo4j.pushtocloud.PushToCloudCommand.ARG_DUMP;\n+import static org.neo4j.pushtocloud.PushToCloudCommand.ARG_DUMP_TO;\n+import static org.neo4j.pushtocloud.PushToCloudCommand.ARG_PASSWORD;\n+import static org.neo4j.pushtocloud.PushToCloudCommand.ARG_USERNAME;\n+import static org.neo4j.pushtocloud.PushToCloudCommand.ARG_OVERWRITE;\n \n public class PushToCloudCommandTest\n {",
      "parent_sha": "49dde3d3a79bbeedfbdd767b6997a1cfa99b80e1"
    }
  },
  {
    "oid": "81254f47d61e17967c7b2fc2606b162dc806acc3",
    "message": "Change vocabulary label scan store -> label index",
    "date": "2017-03-07T12:57:37Z",
    "url": "https://github.com/neo4j/neo4j/commit/81254f47d61e17967c7b2fc2606b162dc806acc3",
    "details": {
      "sha": "a9669745e43d0ab8b67ddba2add5e9b366d4d795",
      "filename": "community/consistency-check/src/main/java/org/neo4j/consistency/ConsistencyCheckSettings.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/neo4j/neo4j/blob/81254f47d61e17967c7b2fc2606b162dc806acc3/community%2Fconsistency-check%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fconsistency%2FConsistencyCheckSettings.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/81254f47d61e17967c7b2fc2606b162dc806acc3/community%2Fconsistency-check%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fconsistency%2FConsistencyCheckSettings.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fconsistency-check%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fconsistency%2FConsistencyCheckSettings.java?ref=81254f47d61e17967c7b2fc2606b162dc806acc3",
      "patch": "@@ -39,8 +39,7 @@ public class ConsistencyCheckSettings implements LoadableConfig\n             \"However, the check is very expensive in time and memory, so it is skipped by default.\")\n     public static final Setting<Boolean> consistency_check_property_owners = setting( \"tools.consistency_checker.check_property_owners\", BOOLEAN, FALSE );\n \n-    @Description(\"Perform checks on the label scan store. Checking this store is more expensive than \" +\n-            \"checking the native stores, so it may be useful to turn off this check for very large databases.\")\n+    @Description(\"Perform checks on label indexes.\")\n     public static final Setting<Boolean> consistency_check_label_scan_store = setting( \"tools.consistency_checker.check_label_scan_store\", BOOLEAN, TRUE );\n \n     @Description(\"Perform checks on indexes. Checking indexes is more expensive than \" +",
      "parent_sha": "e080cd1e37819aeac1ba949388056f3f3dbdb297"
    }
  },
  {
    "oid": "26c2d7daa4787e6f27b58a01e3bc55b526197b17",
    "message": "Limit DynamicArray chunk size to less than Integer.MAX_VALUE\n\nEven though arrays are indexes by ints, they don't actually have the full 31\nbit range available for their length. It's JVM implementation specific, but the\nmaximum array size is somewhere slightly less than Integer.MAX_VALUE.\nFor this reason we specify the maximum chunk size to be Integer.MAX_VALUE minus\nShort.MAX_VALUE. This is more than enough room for at least HotSpot, as far as\nthe author is aware.\n\nNo test because of how implementation specific it is, and how trivial the\nchange is.",
    "date": "2017-07-12T12:46:18Z",
    "url": "https://github.com/neo4j/neo4j/commit/26c2d7daa4787e6f27b58a01e3bc55b526197b17",
    "details": {
      "sha": "6809bd139553f9a65caa4acf2e35b9956e76497f",
      "filename": "community/kernel/src/main/java/org/neo4j/unsafe/impl/batchimport/cache/NumberArrayFactory.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/neo4j/neo4j/blob/26c2d7daa4787e6f27b58a01e3bc55b526197b17/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Funsafe%2Fimpl%2Fbatchimport%2Fcache%2FNumberArrayFactory.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/26c2d7daa4787e6f27b58a01e3bc55b526197b17/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Funsafe%2Fimpl%2Fbatchimport%2Fcache%2FNumberArrayFactory.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Funsafe%2Fimpl%2Fbatchimport%2Fcache%2FNumberArrayFactory.java?ref=26c2d7daa4787e6f27b58a01e3bc55b526197b17",
      "patch": "@@ -315,7 +315,8 @@ public ByteArray newByteArray( long length, byte[] defaultValue, long base )\n \n         private long fractionOf( long length )\n         {\n-            return min( length / 10, Integer.MAX_VALUE );\n+            int maxArraySize = Integer.MAX_VALUE - Short.MAX_VALUE;\n+            return min( length / 10, maxArraySize );\n         }\n \n         @Override",
      "parent_sha": "898b57149eb06fc3d33780f52061c8f3d7efdd07"
    }
  },
  {
    "oid": "579259aa76d2368ed8294602dfd412bcb59f8456",
    "message": "Clarifies TODO comment in CommittedTransactionRepresentation",
    "date": "2014-07-09T12:27:11Z",
    "url": "https://github.com/neo4j/neo4j/commit/579259aa76d2368ed8294602dfd412bcb59f8456",
    "details": {
      "sha": "d2d11b0ea0c59dd88024abf5726dd7fe3ee3bde0",
      "filename": "community/kernel/src/main/java/org/neo4j/kernel/impl/transaction/xaframework/CommittedTransactionRepresentation.java",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/neo4j/neo4j/blob/579259aa76d2368ed8294602dfd412bcb59f8456/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Ftransaction%2Fxaframework%2FCommittedTransactionRepresentation.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/579259aa76d2368ed8294602dfd412bcb59f8456/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Ftransaction%2Fxaframework%2FCommittedTransactionRepresentation.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Ftransaction%2Fxaframework%2FCommittedTransactionRepresentation.java?ref=579259aa76d2368ed8294602dfd412bcb59f8456",
      "patch": "@@ -26,9 +26,10 @@\n  * itself, a Start and Commit entry. This is the thing that {@link LogicalTransactionStore} returns when\n  * asked for a transaction via a cursor.\n  */\n-// TODO 2.2-future make this visitable in the same way TransactionRepresentation is, if necessary\n-// TODO The way it is setup now, it means that the TransactionRepresentation has to be wholly in memory before\n-// TODO acting on it, which precludes the ability to stream the thing. This may not be good short term.\n+\n+// TODO 2.2-future This class should not be used for transferring transactions around. HA communication should\n+// TODO 2.2-future happen via channel.transferTo() calls. This class should be used only for local iteration\n+// TODO 2.2-future over the log, which theoretically should be only recovery and LogPosition discovery\n public class CommittedTransactionRepresentation\n {\n     private final LogEntry.Start startEntry;",
      "parent_sha": "9e2cc55e3a2deb70df23031f2acbc73ef2337a36"
    }
  },
  {
    "oid": "266ac6e6ee73e985f52b4c50198f5be427a5292e",
    "message": "Fix a typo.",
    "date": "2018-07-19T13:58:05Z",
    "url": "https://github.com/neo4j/neo4j/commit/266ac6e6ee73e985f52b4c50198f5be427a5292e",
    "details": {
      "sha": "cfbafa1b87153d21b7c0f6bfd909a173d43ed0a3",
      "filename": "community/kernel/src/main/java/org/neo4j/kernel/impl/util/dbstructure/DbStructureCollector.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/neo4j/neo4j/blob/266ac6e6ee73e985f52b4c50198f5be427a5292e/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Futil%2Fdbstructure%2FDbStructureCollector.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/266ac6e6ee73e985f52b4c50198f5be427a5292e/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Futil%2Fdbstructure%2FDbStructureCollector.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Futil%2Fdbstructure%2FDbStructureCollector.java?ref=266ac6e6ee73e985f52b4c50198f5be427a5292e",
      "patch": "@@ -390,20 +390,20 @@ public Pair<String[],String[]> next()\n                     //TODO: Add support for composite indexes\n                     SchemaDescriptor next = iterator.next();\n                     EntityType type = next.entityType();\n-                    String[] enetityTokens;\n+                    String[] entityTokens;\n                     switch ( type )\n                     {\n                     case NODE:\n-                        enetityTokens = labels.byIdOrFail( next.getEntityTokenIds() );\n+                        entityTokens = labels.byIdOrFail( next.getEntityTokenIds() );\n                         break;\n                     case RELATIONSHIP:\n-                        enetityTokens = relationshipTypes.byIdOrFail( next.getEntityTokenIds() );\n+                        entityTokens = relationshipTypes.byIdOrFail( next.getEntityTokenIds() );\n                         break;\n                     default:\n                         throw new IllegalStateException( \"Indexing is not supported for EntityType: \" + type );\n                     }\n                     String[] propertyKeyNames = propertyKeys.byIdOrFail( next.getPropertyIds() );\n-                    return Pair.of( enetityTokens, propertyKeyNames );\n+                    return Pair.of( entityTokens, propertyKeyNames );\n                 }\n \n                 @Override",
      "parent_sha": "f00903dfeecb83a82ae62b73a23e08b25e17a2a4"
    }
  },
  {
    "oid": "b19d69adb51729ae9a017c9fccdbec1ecec0637f",
    "message": "Improve assertions in NodeCursorTest",
    "date": "2017-05-08T12:20:10Z",
    "url": "https://github.com/neo4j/neo4j/commit/b19d69adb51729ae9a017c9fccdbec1ecec0637f",
    "details": {
      "sha": "198fbd5cc9ec16647f7ce7e44e84cee3da7f2e89",
      "filename": "community/kernel/src/test/java/org/neo4j/kernel/impl/api/store/NodeCursorTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 8,
      "changes": 10,
      "blob_url": "https://github.com/neo4j/neo4j/blob/b19d69adb51729ae9a017c9fccdbec1ecec0637f/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fapi%2Fstore%2FNodeCursorTest.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/b19d69adb51729ae9a017c9fccdbec1ecec0637f/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fapi%2Fstore%2FNodeCursorTest.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fapi%2Fstore%2FNodeCursorTest.java?ref=b19d69adb51729ae9a017c9fccdbec1ecec0637f",
      "patch": "@@ -296,14 +296,8 @@ public void check( NodeItem node )\n                     asSet( asArray( state.getNodeState( node.id() ).labelDiffSets().getAdded() ) );\n             assertEquals( expectedLabels, node.labels() );\n             assertEquals( StatementConstants.NO_SUCH_PROPERTY, node.nextPropertyId() );\n-            if ( node.isDense() )\n-            {\n-                assertEquals( StatementConstants.NO_SUCH_RELATIONSHIP, node.nextGroupId() );\n-            }\n-            else\n-            {\n-                assertEquals( StatementConstants.NO_SUCH_RELATIONSHIP, node.nextRelationshipId() );\n-            }\n+            assertFalse( node.isDense() );\n+            assertEquals( StatementConstants.NO_SUCH_RELATIONSHIP, node.nextRelationshipId() );\n             PrimitiveIntIterator iterator = expectedLabels.iterator();\n             while ( iterator.hasNext() )\n             {",
      "parent_sha": "627753b6a5872ea3049b21d2ebebd4ec07c801ee"
    }
  },
  {
    "oid": "ac8b8d6199b71e0e3de84afc9d4af7021fb8a60a",
    "message": "fixing URL encoding of scripts",
    "date": "2011-05-29T18:46:01Z",
    "url": "https://github.com/neo4j/neo4j/commit/ac8b8d6199b71e0e3de84afc9d4af7021fb8a60a",
    "details": {
      "sha": "32fa655958354147107fc6adca8e016b0fd39094",
      "filename": "gremlin-plugin/src/test/java/org/neo4j/server/plugin/gremlin/TestGremlin.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/neo4j/neo4j/blob/ac8b8d6199b71e0e3de84afc9d4af7021fb8a60a/gremlin-plugin%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fserver%2Fplugin%2Fgremlin%2FTestGremlin.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/ac8b8d6199b71e0e3de84afc9d4af7021fb8a60a/gremlin-plugin%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fserver%2Fplugin%2Fgremlin%2FTestGremlin.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/gremlin-plugin%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fserver%2Fplugin%2Fgremlin%2FTestGremlin.java?ref=ac8b8d6199b71e0e3de84afc9d4af7021fb8a60a",
      "patch": "@@ -47,7 +47,7 @@ public void testGremlinPostURLEncoded() throws UnsupportedEncodingException\n     {\n         String response = gen.get()\n         .expectedStatus( Status.OK.getStatusCode() )\n-        .payload( \"script=\" + URLEncoder.encode( \"i=g.v(\"+data.get().get( \"I\" ).getId() +\");i.outE.inV\", \"UTF-8\") )\n+        .payload( \"script=\" + URLEncoder.encode( \"i = g.v(\"+data.get().get( \"I\" ).getId() +\");i.outE.inV\", \"UTF-8\") )\n         .payloadType( MediaType.APPLICATION_FORM_URLENCODED_TYPE )\n         .post( ENDPOINT )\n         .entity();",
      "parent_sha": "07ee79efc51f3c62e4a49dad831ad5224bda3fee"
    }
  },
  {
    "oid": "51dee0d163bce912ec9bf50a301e3276f3589944",
    "message": "Re-greening the build while I'm refactoring under the covers.\n\ngit-svn-id: https://svn.neo4j.org/components/server/trunk@8095 0b971d98-bb2f-0410-8247-b05b2b5feb2a",
    "date": "2010-12-22T16:17:26Z",
    "url": "https://github.com/neo4j/neo4j/commit/51dee0d163bce912ec9bf50a301e3276f3589944",
    "details": {
      "sha": "d033ded3150c3d5a8892a4aabed8d9439e5ddb28",
      "filename": "enterprise/src/functionaltest/java/org/neo4j/server/ServerConfigTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/neo4j/neo4j/blob/51dee0d163bce912ec9bf50a301e3276f3589944/enterprise%2Fsrc%2Ffunctionaltest%2Fjava%2Forg%2Fneo4j%2Fserver%2FServerConfigTest.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/51dee0d163bce912ec9bf50a301e3276f3589944/enterprise%2Fsrc%2Ffunctionaltest%2Fjava%2Forg%2Fneo4j%2Fserver%2FServerConfigTest.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/enterprise%2Fsrc%2Ffunctionaltest%2Fjava%2Forg%2Fneo4j%2Fserver%2FServerConfigTest.java?ref=51dee0d163bce912ec9bf50a301e3276f3589944",
      "patch": "@@ -28,11 +28,12 @@\n import java.io.IOException;\n \n import org.junit.After;\n+import org.junit.Ignore;\n import org.junit.Test;\n \n import com.sun.jersey.api.client.Client;\n import com.sun.jersey.api.client.ClientResponse;\n-\n+@Ignore\n public class ServerConfigTest {\n \n     private NeoServer server;",
      "parent_sha": "ad7dcc945bebf3f76543f5a5435abb4691583252"
    }
  },
  {
    "oid": "a4d809157393e46228d57cf543ec861394a01122",
    "message": "Typo.",
    "date": "2013-04-16T21:54:14Z",
    "url": "https://github.com/neo4j/neo4j/commit/a4d809157393e46228d57cf543ec861394a01122",
    "details": {
      "sha": "069561dc756335f4a58ab508c1252109216af57f",
      "filename": "community/embedded-examples/src/test/java/org/neo4j/examples/Neo4jBasicDocTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/neo4j/neo4j/blob/a4d809157393e46228d57cf543ec861394a01122/community%2Fembedded-examples%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fexamples%2FNeo4jBasicDocTest.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/a4d809157393e46228d57cf543ec861394a01122/community%2Fembedded-examples%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fexamples%2FNeo4jBasicDocTest.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fembedded-examples%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fexamples%2FNeo4jBasicDocTest.java?ref=a4d809157393e46228d57cf543ec861394a01122",
      "patch": "@@ -100,7 +100,7 @@ public void shouldCreateNode()\n \n         // The node should have an id greater than 0, which is the id of the\n         // reference node.\n-        assertThat( n.getId(), is( greaterThan( 0l ) ) );\n+        assertThat( n.getId(), is( greaterThan( 0L ) ) );\n \n         // Retrieve a node by using the id of the created node. The id's and\n         // property should match.",
      "parent_sha": "81909070a934fcd6732deecae18e48d2586cbee0"
    }
  },
  {
    "oid": "66853a8d64dd281fda2171b1fb76bb6ed7b06249",
    "message": "adjusting the snippet",
    "date": "2011-09-08T13:44:14Z",
    "url": "https://github.com/neo4j/neo4j/commit/66853a8d64dd281fda2171b1fb76bb6ed7b06249",
    "details": {
      "sha": "54ea3e57497c391940eabf6d40f95fca9d70002f",
      "filename": "community/embedded-examples/src/test/java/org/neo4j/examples/ShortDocumentationExamplesTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/neo4j/neo4j/blob/66853a8d64dd281fda2171b1fb76bb6ed7b06249/community%2Fembedded-examples%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fexamples%2FShortDocumentationExamplesTest.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/66853a8d64dd281fda2171b1fb76bb6ed7b06249/community%2Fembedded-examples%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fexamples%2FShortDocumentationExamplesTest.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fembedded-examples%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fexamples%2FShortDocumentationExamplesTest.java?ref=66853a8d64dd281fda2171b1fb76bb6ed7b06249",
      "patch": "@@ -100,14 +100,15 @@ public Evaluation evaluate( Path path )\n             }\n         } );\n         \n-        // END SNIPPET: traverser\n         org.neo4j.graphdb.traversal.Traverser results = td.traverse( start );\n         int count = 0;\n+        //we should get two paths back, through Pet1 and Pet3\n         for(Path path : results)\n         {\n             count ++;\n         }\n         assertEquals(2, count);\n+        // END SNIPPET: traverser\n     }\n     \n     public String createGraphViz( String name )",
      "parent_sha": "eb5608cb8dbd747bc03e5487e5a1b87a4154a9da"
    }
  },
  {
    "oid": "68ef7b055d82bf14e04c948a22050d286ab3a84f",
    "message": "Fix StoreMigrationIT on Windows by using shorter paths for test directories",
    "date": "2017-01-19T11:06:12Z",
    "url": "https://github.com/neo4j/neo4j/commit/68ef7b055d82bf14e04c948a22050d286ab3a84f",
    "details": {
      "sha": "01ebbcbb25e9e789b2e453b33ada52c2989bbb81",
      "filename": "enterprise/kernel/src/test/java/org/neo4j/kernel/impl/storemigration/StoreMigrationIT.java",
      "status": "modified",
      "additions": 9,
      "deletions": 7,
      "changes": 16,
      "blob_url": "https://github.com/neo4j/neo4j/blob/68ef7b055d82bf14e04c948a22050d286ab3a84f/enterprise%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fstoremigration%2FStoreMigrationIT.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/68ef7b055d82bf14e04c948a22050d286ab3a84f/enterprise%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fstoremigration%2FStoreMigrationIT.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/enterprise%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fstoremigration%2FStoreMigrationIT.java?ref=68ef7b055d82bf14e04c948a22050d286ab3a84f",
      "patch": "@@ -43,8 +43,6 @@\n import org.neo4j.graphdb.factory.EnterpriseGraphDatabaseFactory;\n import org.neo4j.graphdb.factory.GraphDatabaseFactory;\n import org.neo4j.graphdb.factory.GraphDatabaseSettings;\n-import org.neo4j.graphdb.schema.ConstraintDefinition;\n-import org.neo4j.graphdb.schema.IndexDefinition;\n import org.neo4j.helpers.Service;\n import org.neo4j.helpers.collection.MapUtil;\n import org.neo4j.helpers.progress.ProgressMonitorFactory;\n@@ -114,10 +112,10 @@ public static Iterable<Object[]> data() throws IOException\n                     legacyStoreVersionCheck, toFormat );\n             for ( RecordFormats fromFormat : recordFormatses )\n             {\n-                File db = new File( dir, fromFormat.storeVersion() + toFormat.storeVersion() );\n+                File db = new File( dir, baseDirName( toFormat, fromFormat ) );\n                 try\n                 {\n-                    createDb( fromFormat, pageCache, fs, db );\n+                    createDb( fromFormat, db );\n                     if ( !upgradableDatabase.hasCurrentVersion( db ) )\n                     {\n                         upgradableDatabase.checkUpgradeable( db );\n@@ -135,6 +133,11 @@ public static Iterable<Object[]> data() throws IOException\n         return data;\n     }\n \n+    private static String baseDirName(RecordFormats toFormat, RecordFormats fromFormat)\n+    {\n+        return fromFormat.storeVersion() + toFormat.storeVersion();\n+    }\n+\n     private static void addIfNotThere( RecordFormats f, ArrayList<RecordFormats> recordFormatses )\n     {\n         for ( RecordFormats format : recordFormatses )\n@@ -177,8 +180,7 @@ public RecordFormats newInstance()\n         }\n     }\n \n-    private static void createDb( RecordFormats recordFormat, PageCache pageCache, FileSystemAbstraction fs,\n-            File storeDir ) throws IOException\n+    private static void createDb( RecordFormats recordFormat, File storeDir ) throws IOException\n     {\n         GraphDatabaseService database = new GraphDatabaseFactory().newEmbeddedDatabaseBuilder( storeDir )\n                 .setConfig( GraphDatabaseSettings.allow_store_upgrade, Settings.TRUE )\n@@ -195,7 +197,7 @@ public StoreMigrationIT( RecordFormats from, RecordFormats to )\n     @Test\n     public void shouldMigrate() throws Exception\n     {\n-        File db = testDir.directory( from.toString() + to.toString() );\n+        File db = testDir.directory( baseDirName( to, from ) );\n         FileSystemAbstraction fs = fileSystemRule.get();\n         fs.deleteRecursively( db );\n         GraphDatabaseService database = getGraphDatabaseService( db, from.storeVersion() );",
      "parent_sha": "cca00f0cc872a77277710aa6376f0215a005e9b7"
    }
  },
  {
    "oid": "a0870e824aba7fabdceb43430d3b4bdff097c832",
    "message": "Fixed a ConcurrentModificationException problem when rotating logs and listing store files",
    "date": "2012-01-18T09:55:13Z",
    "url": "https://github.com/neo4j/neo4j/commit/a0870e824aba7fabdceb43430d3b4bdff097c832",
    "details": {
      "sha": "0d15f63e304c2fce046d933dd4984ed22ff46a5c",
      "filename": "community/lucene-index/src/main/java/org/neo4j/index/impl/lucene/LuceneDataSource.java",
      "status": "modified",
      "additions": 10,
      "deletions": 2,
      "changes": 12,
      "blob_url": "https://github.com/neo4j/neo4j/blob/a0870e824aba7fabdceb43430d3b4bdff097c832/community%2Flucene-index%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Findex%2Fimpl%2Flucene%2FLuceneDataSource.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/a0870e824aba7fabdceb43430d3b4bdff097c832/community%2Flucene-index%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Findex%2Fimpl%2Flucene%2FLuceneDataSource.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Flucene-index%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Findex%2Fimpl%2Flucene%2FLuceneDataSource.java?ref=a0870e824aba7fabdceb43430d3b4bdff097c832",
      "patch": "@@ -369,10 +369,11 @@ public XaTransaction create( int identifier )\n             return createTransaction( identifier, this.getLogicalLog() );\n         }\n \n+        @SuppressWarnings( \"unchecked\" )\n         @Override\n         public void flushAll()\n         {\n-            for ( Map.Entry<IndexIdentifier, IndexWriter> entry : indexWriters.entrySet() )\n+            for ( Map.Entry<IndexIdentifier, IndexWriter> entry : getAllIndexWriters() )\n             {\n                 try\n                 {\n@@ -409,6 +410,12 @@ void getReadLock()\n         lock.readLock().lock();\n     }\n \n+    @SuppressWarnings( \"rawtypes\" )\n+    private synchronized Map.Entry[] getAllIndexWriters()\n+    {\n+        return indexWriters.entrySet().toArray( new Map.Entry[indexWriters.size()] );\n+    }\n+\n     void releaseReadLock()\n     {\n         lock.readLock().unlock();\n@@ -762,13 +769,14 @@ public XaContainer getXaContainer()\n         return this.xaContainer;\n     }\n \n+    @SuppressWarnings( \"unchecked\" )\n     @Override\n     public ClosableIterable<File> listStoreFiles( boolean includeLogicalLogs ) throws IOException\n     {   // Never include logical logs since they are of little importance\n         final Collection<File> files = new ArrayList<File>();\n         final Collection<SnapshotDeletionPolicy> snapshots = new ArrayList<SnapshotDeletionPolicy>();\n         makeSureAllIndexesAreInstantiated();\n-        for ( Map.Entry<IndexIdentifier, IndexWriter> writer : indexWriters.entrySet() )\n+        for ( Map.Entry<IndexIdentifier, IndexWriter> writer : getAllIndexWriters() )\n         {\n             SnapshotDeletionPolicy deletionPolicy = (SnapshotDeletionPolicy)\n                     writer.getValue().getConfig().getIndexDeletionPolicy();",
      "parent_sha": "ecc04d5e084a80da286cd4690fc9d419e8b73861"
    }
  },
  {
    "oid": "6d7a7613bb523cf4748662512e9b5d08ba5a130f",
    "message": "Close channel after flush in FileUtils::tryForceDirectory",
    "date": "2022-03-09T10:19:00Z",
    "url": "https://github.com/neo4j/neo4j/commit/6d7a7613bb523cf4748662512e9b5d08ba5a130f",
    "details": {
      "sha": "6a34e486c1d7a2ab5650250baeb01ff0fd127d02",
      "filename": "community/io/src/main/java/org/neo4j/io/fs/FileUtils.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/neo4j/neo4j/blob/6d7a7613bb523cf4748662512e9b5d08ba5a130f/community%2Fio%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fio%2Ffs%2FFileUtils.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/6d7a7613bb523cf4748662512e9b5d08ba5a130f/community%2Fio%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fio%2Ffs%2FFileUtils.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fio%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fio%2Ffs%2FFileUtils.java?ref=6d7a7613bb523cf4748662512e9b5d08ba5a130f",
      "patch": "@@ -504,8 +504,10 @@ else if ( !isDirectory( directory ) )\n         // Attempts to fsync the directory, guaranting e.g. file creation/deletion/rename events are durable\n         // See http://mail.openjdk.java.net/pipermail/nio-dev/2015-May/003140.html\n         // See also https://github.com/apache/lucene-solr/commit/7bea628bf3961a10581833935e4c1b61ad708c5c\n-        FileChannel directoryChannel = FileChannel.open( directory, singleton( READ ) );\n-        directoryChannel.force( true );\n+        try ( FileChannel directoryChannel = FileChannel.open( directory, singleton( READ ) ) )\n+        {\n+            directoryChannel.force( true );\n+        }\n     }\n \n     public static boolean isDirectoryEmpty( Path directory ) throws IOException",
      "parent_sha": "875388d8d4347b6bd50a3a966308c9f05683eaeb"
    }
  },
  {
    "oid": "7bef57858a69d1c3615f50f1790a3bf2af125efb",
    "message": "Removed the supplier-of-supplier latent bug reported by DG.",
    "date": "2015-12-23T13:06:52Z",
    "url": "https://github.com/neo4j/neo4j/commit/7bef57858a69d1c3615f50f1790a3bf2af125efb",
    "details": {
      "sha": "f9052293ec73fd6f235299ce15ec77374cea18d7",
      "filename": "enterprise/core-edge/src/main/java/org/neo4j/coreedge/server/core/EnterpriseCoreEditionModule.java",
      "status": "modified",
      "additions": 19,
      "deletions": 14,
      "changes": 33,
      "blob_url": "https://github.com/neo4j/neo4j/blob/7bef57858a69d1c3615f50f1790a3bf2af125efb/enterprise%2Fcore-edge%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fcoreedge%2Fserver%2Fcore%2FEnterpriseCoreEditionModule.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/7bef57858a69d1c3615f50f1790a3bf2af125efb/enterprise%2Fcore-edge%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fcoreedge%2Fserver%2Fcore%2FEnterpriseCoreEditionModule.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/enterprise%2Fcore-edge%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fcoreedge%2Fserver%2Fcore%2FEnterpriseCoreEditionModule.java?ref=7bef57858a69d1c3615f50f1790a3bf2af125efb",
      "patch": "@@ -164,7 +164,8 @@ public EnterpriseCoreEditionModule( final PlatformModule platformModule,\n         ListenSocketAddress raftListenAddress = config.get( CoreEdgeClusterSettings.raft_listen_address );\n         RaftServer<CoreMember> raftServer = new RaftServer<>( marshall, raftListenAddress, logProvider );\n \n-        final DelayedRenewableTimeoutService raftTimeoutService = new DelayedRenewableTimeoutService( Clock.SYSTEM_CLOCK, logProvider );\n+        final DelayedRenewableTimeoutService raftTimeoutService = new DelayedRenewableTimeoutService( Clock\n+                .SYSTEM_CLOCK, logProvider );\n \n         File raftLogsDirectory = createRaftLogsDirectory( platformModule.storeDir, fileSystem );\n         NaiveDurableRaftLog raftLog = new NaiveDurableRaftLog( fileSystem, raftLogsDirectory,\n@@ -177,8 +178,7 @@ public EnterpriseCoreEditionModule( final PlatformModule platformModule,\n         life.add( termStore );\n         life.add( voteStore );\n \n-        Supplier<DatabaseHealth> databaseHealthSupplier = (Supplier) () -> dependencies.provideDependency( DatabaseHealth.class );\n-\n+        Supplier<DatabaseHealth> databaseHealthSupplier = dependencies.provideDependency( DatabaseHealth.class );\n \n         RaftStorageExceptionHandler raftStorageExceptionHandler =\n                 new RaftStorageExceptionHandler( databaseHealthSupplier );\n@@ -193,11 +193,13 @@ public EnterpriseCoreEditionModule( final PlatformModule platformModule,\n \n         LocalSessionPool localSessionPool = new LocalSessionPool( myself );\n \n-        ReplicatedLockStateMachine replicatedLockStateMachine = new ReplicatedLockStateMachine( myself, replicator );\n+        ReplicatedLockStateMachine<CoreMember> replicatedLockStateMachine = new ReplicatedLockStateMachine<>( myself, replicator );\n \n-        commitProcessFactory = createCommitProcessFactory( replicator, localSessionPool, replicatedLockStateMachine, dependencies, SYSTEM_CLOCK );\n+        commitProcessFactory = createCommitProcessFactory( replicator, localSessionPool, replicatedLockStateMachine,\n+                dependencies, SYSTEM_CLOCK );\n \n-        ReplicatedIdAllocationStateMachine idAllocationStateMachine = new ReplicatedIdAllocationStateMachine( myself, new InMemoryIdAllocationStateStore() );\n+        ReplicatedIdAllocationStateMachine idAllocationStateMachine = new ReplicatedIdAllocationStateMachine( myself,\n+                new InMemoryIdAllocationStateStore() );\n         replicator.subscribe( idAllocationStateMachine );\n \n         // TODO: AllocationChunk should be configurable and per type. The retry timeout should also be configurable.\n@@ -208,7 +210,7 @@ public EnterpriseCoreEditionModule( final PlatformModule platformModule,\n \n         long electionTimeout = config.get( CoreEdgeClusterSettings.leader_election_timeout );\n         MembershipWaiter<CoreMember> membershipWaiter =\n-                new MembershipWaiter<>( myself, platformModule.jobScheduler, electionTimeout*4, logProvider );\n+                new MembershipWaiter<>( myself, platformModule.jobScheduler, electionTimeout * 4, logProvider );\n \n         ReplicatedIdGeneratorFactory replicatedIdGeneratorFactory =\n                 createIdGeneratorFactory( fileSystem, idRangeAcquirer, logProvider );\n@@ -250,7 +252,8 @@ public EnterpriseCoreEditionModule( final PlatformModule platformModule,\n                 channelInitializer ) );\n         channelInitializer.setOwner( coreToCoreClient );\n \n-        lockManager = dependencies.satisfyDependency( createLockManager( config, logging, replicator, myself, replicatedLockStateMachine ) );\n+        lockManager = dependencies.satisfyDependency( createLockManager( config, logging, replicator, myself,\n+                replicatedLockStateMachine ) );\n \n         CatchupServer catchupServer = new CatchupServer( logProvider,\n                 new StoreIdSupplier( platformModule ),\n@@ -261,13 +264,14 @@ public EnterpriseCoreEditionModule( final PlatformModule platformModule,\n                 config.get( CoreEdgeClusterSettings.transaction_listen_address ) );\n \n         life.add( CoreServerStartupProcess.createLifeSupport(\n-                platformModule.dataSourceManager, replicatedIdGeneratorFactory, raft, new RaftLogReplay( raftLog, logProvider ), raftServer,\n+                platformModule.dataSourceManager, replicatedIdGeneratorFactory, raft, new RaftLogReplay( raftLog,\n+                        logProvider ), raftServer,\n                 catchupServer, raftTimeoutService, membershipWaiter,\n                 config.get( CoreEdgeClusterSettings.join_catch_up_timeout ),\n                 new RecoverTransactionLogState( dependencies, logProvider,\n                         relationshipTypeTokenHolder, propertyKeyTokenHolder, labelTokenHolder ),\n                 tokenLife\n-        ));\n+        ) );\n     }\n \n     public boolean isLeader()\n@@ -293,7 +297,8 @@ private File createRaftLogsDirectory( File dir, FileSystemAbstraction fileSystem\n \n     public static CommitProcessFactory createCommitProcessFactory( final Replicator replicator,\n                                                                    final LocalSessionPool localSessionPool,\n-                                                                   CurrentReplicatedLockState currentReplicatedLockState,\n+                                                                   CurrentReplicatedLockState\n+                                                                           currentReplicatedLockState,\n                                                                    final Dependencies dependencies,\n                                                                    final Clock clock )\n     {\n@@ -323,7 +328,7 @@ private static RaftInstance<CoreMember> createRaft( LifeSupport life,\n                                                         MessageLogger<AdvertisedSocketAddress> messageLogger,\n                                                         RaftLog raftLog,\n                                                         TermStore termStore,\n-                                                        VoteStore voteStore,\n+                                                        VoteStore<CoreMember> voteStore,\n                                                         CoreMember myself,\n                                                         LogProvider logProvider,\n                                                         RaftServer<CoreMember> raftServer,\n@@ -406,11 +411,11 @@ protected ReplicatedIdGeneratorFactory createIdGeneratorFactory( FileSystemAbstr\n     }\n \n     protected Locks createLockManager( final Config config, final LogService logging, final Replicator replicator,\n-                                       CoreMember myself, ReplicatedLockStateMachine replicatedLockStateMachine )\n+                                       CoreMember myself, ReplicatedLockStateMachine<CoreMember> replicatedLockStateMachine )\n     {\n         Locks local = CommunityEditionModule.createLockManager( config, logging );\n \n-        return new LeaderOnlyLockManager( myself, replicator, local, replicatedLockStateMachine );\n+        return new LeaderOnlyLockManager<CoreMember>( myself, replicator, local, replicatedLockStateMachine );\n     }\n \n     protected TransactionHeaderInformationFactory createHeaderInformationFactory()",
      "parent_sha": "0b0e481938b2e72455b46777309a4d76a29556b2"
    }
  },
  {
    "oid": "73071152336bb9c75aa772dfd4748efdefb0b51f",
    "message": "Use junit 5",
    "date": "2018-09-07T14:58:46Z",
    "url": "https://github.com/neo4j/neo4j/commit/73071152336bb9c75aa772dfd4748efdefb0b51f",
    "details": {
      "sha": "62cbd275ef04d15981791810647fbc9fb33bc6cc",
      "filename": "community/random-values/src/test/java/org/neo4j/values/storable/TextValueFuzzTest.java",
      "status": "modified",
      "additions": 12,
      "deletions": 8,
      "changes": 20,
      "blob_url": "https://github.com/neo4j/neo4j/blob/73071152336bb9c75aa772dfd4748efdefb0b51f/community%2Frandom-values%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fvalues%2Fstorable%2FTextValueFuzzTest.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/73071152336bb9c75aa772dfd4748efdefb0b51f/community%2Frandom-values%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fvalues%2Fstorable%2FTextValueFuzzTest.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Frandom-values%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fvalues%2Fstorable%2FTextValueFuzzTest.java?ref=73071152336bb9c75aa772dfd4748efdefb0b51f",
      "patch": "@@ -19,22 +19,26 @@\n  */\n package org.neo4j.values.storable;\n \n-import org.junit.Rule;\n-import org.junit.Test;\n \n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import org.neo4j.test.extension.Inject;\n+import org.neo4j.test.extension.RandomExtension;\n import org.neo4j.test.rule.RandomRule;\n \n import static org.neo4j.values.storable.StringHelpers.assertConsistent;\n \n+@ExtendWith( RandomExtension.class )\n public class TextValueFuzzTest\n {\n-    @Rule\n+    @Inject\n     public RandomRule random = new RandomRule();\n \n     private static final int ITERATIONS = 1000;\n \n     @Test\n-    public void shouldCompareTo()\n+    void shouldCompareTo()\n     {\n         for ( int i = 0; i < ITERATIONS; i++ )\n         {\n@@ -44,7 +48,7 @@ public void shouldCompareTo()\n     }\n \n     @Test\n-    public void shouldAdd()\n+    void shouldAdd()\n     {\n         for ( int i = 0; i < ITERATIONS; i++ )\n         {\n@@ -53,7 +57,7 @@ public void shouldAdd()\n     }\n \n     @Test\n-    public void shouldComputeLength()\n+    void shouldComputeLength()\n     {\n         for ( int i = 0; i < ITERATIONS; i++ )\n         {\n@@ -62,7 +66,7 @@ public void shouldComputeLength()\n     }\n \n     @Test\n-    public void shouldReverse()\n+    void shouldReverse()\n     {\n         for ( int i = 0; i < ITERATIONS; i++ )\n         {\n@@ -71,7 +75,7 @@ public void shouldReverse()\n     }\n \n     @Test\n-    public void shouldTrim()\n+    void shouldTrim()\n     {\n         for ( int i = 0; i < ITERATIONS; i++ )\n         {",
      "parent_sha": "4ff5278d1de683aa5c3cc5f2978bd42368734710"
    }
  },
  {
    "oid": "26996d8a0b9c38c52fc53ee336bdba055fc5da6b",
    "message": "Fix the procedure listing for tests.",
    "date": "2019-11-08T15:10:44Z",
    "url": "https://github.com/neo4j/neo4j/commit/26996d8a0b9c38c52fc53ee336bdba055fc5da6b",
    "details": {
      "sha": "ebd72a65f3a237b5e6ac709aa7533b452ee0d825",
      "filename": "community/community-it/kernel-it/src/test/java/org/neo4j/kernel/impl/api/integrationtest/ProcedureITBase.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/neo4j/neo4j/blob/26996d8a0b9c38c52fc53ee336bdba055fc5da6b/community%2Fcommunity-it%2Fkernel-it%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fapi%2Fintegrationtest%2FProcedureITBase.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/26996d8a0b9c38c52fc53ee336bdba055fc5da6b/community%2Fcommunity-it%2Fkernel-it%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fapi%2Fintegrationtest%2FProcedureITBase.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fcommunity-it%2Fkernel-it%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fapi%2Fintegrationtest%2FProcedureITBase.java?ref=26996d8a0b9c38c52fc53ee336bdba055fc5da6b",
      "patch": "@@ -134,7 +134,8 @@ default List<Object[]> getExpectedCommunityProcs()  // they have a column for ro\n                         startsWith( \"Create a relationship full-text index for the given relationship types and properties.\" ),\n                         stringArray( \"architect\", \"admin\" ), \"SCHEMA\", false ),\n                 proc( \"db.index.fulltext.drop\", \"(indexName :: STRING?) :: VOID\", \"Drop the specified index.\", stringArray( \"architect\", \"admin\" ), \"SCHEMA\",\n-                        false ), proc( \"db.index.fulltext.listAvailableAnalyzers\", \"() :: (analyzer :: STRING?, description :: STRING?)\",\n+                        false ),\n+                proc( \"db.index.fulltext.listAvailableAnalyzers\", \"() :: (analyzer :: STRING?, description :: STRING?, stopwords :: LIST? OF STRING?)\",\n                         \"List the available analyzers that the full-text indexes can be configured with.\",\n                         stringArray( \"reader\", \"editor\", \"publisher\", \"architect\", \"admin\" ), \"READ\" ),\n                 proc( \"db.index.fulltext.queryNodes\", \"(indexName :: STRING?, queryString :: STRING?) :: (node :: NODE?, score :: FLOAT?)\",",
      "parent_sha": "78aeab1a5531f1d611745cbe521c72e52bbd85a0"
    }
  },
  {
    "oid": "c437d87af2e49d5badbd15ab2473df8552b47042",
    "message": "Cleanup of rolling upgrade code\n\n- Add missing @Override\n- Use System.lineSeparator() and StringJoiner in tests\n- Remove unused code\n- Extract helper method SystemGraphComponents.componentsToUpgrade",
    "date": "2020-09-07T16:32:26Z",
    "url": "https://github.com/neo4j/neo4j/commit/c437d87af2e49d5badbd15ab2473df8552b47042",
    "details": {
      "sha": "3788d35f56e4ab86cbe2c42d3dd2a0a4a6fd18ec",
      "filename": "community/kernel/src/main/java/org/neo4j/dbms/database/SystemGraphComponents.java",
      "status": "modified",
      "additions": 12,
      "deletions": 13,
      "changes": 25,
      "blob_url": "https://github.com/neo4j/neo4j/blob/c437d87af2e49d5badbd15ab2473df8552b47042/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fdbms%2Fdatabase%2FSystemGraphComponents.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/c437d87af2e49d5badbd15ab2473df8552b47042/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fdbms%2Fdatabase%2FSystemGraphComponents.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fdbms%2Fdatabase%2FSystemGraphComponents.java?ref=c437d87af2e49d5badbd15ab2473df8552b47042",
      "patch": "@@ -67,11 +67,13 @@ public void forEach( Consumer<SystemGraphComponent> process )\n         components.forEach( process );\n     }\n \n+    @Override\n     public String component()\n     {\n         return \"system-graph\";\n     }\n \n+    @Override\n     public SystemGraphComponent.Status detect( Transaction tx )\n     {\n         return components.stream().map( c -> c.detect( tx ) ).reduce( SystemGraphComponent.Status::with ).orElse( SystemGraphComponent.Status.CURRENT );\n@@ -107,17 +109,11 @@ public Optional<Exception> initializeSystemGraph( GraphDatabaseService system )\n         return Optional.empty();\n     }\n \n+    @Override\n     public Optional<Exception> upgradeToCurrent( GraphDatabaseService system )\n     {\n-        List<SystemGraphComponent> componentsToUpgrade = new ArrayList<>();\n-        SystemGraphComponent.executeWithFullAccess( system, tx -> components.stream().filter( c ->\n-        {\n-            Status status = c.detect( tx );\n-            return status == Status.UNSUPPORTED_BUT_CAN_UPGRADE || status == Status.REQUIRES_UPGRADE;\n-        } ).forEach( componentsToUpgrade::add ) );\n-\n         List<Exception> errors = new ArrayList<>();\n-        for ( SystemGraphComponent component : componentsToUpgrade )\n+        for ( SystemGraphComponent component : componentsToUpgrade( system ) )\n         {\n             Optional<Exception> exception = component.upgradeToCurrent( system );\n             exception.ifPresent( errors::add );\n@@ -139,11 +135,14 @@ public Optional<Exception> upgradeToCurrent( GraphDatabaseService system )\n         return Optional.empty();\n     }\n \n-    public static final SystemGraphComponents NO_OP = new SystemGraphComponents()\n+    private List<SystemGraphComponent> componentsToUpgrade( GraphDatabaseService system )\n     {\n-        public void register( SystemGraphComponent initializer )\n+        List<SystemGraphComponent> componentsToUpgrade = new ArrayList<>();\n+        SystemGraphComponent.executeWithFullAccess( system, tx -> components.stream().filter( c ->\n         {\n-            // No sub-components can exist in order to disabled initialization\n-        }\n-    };\n+                        Status status = c.detect( tx );\n+            return status == Status.UNSUPPORTED_BUT_CAN_UPGRADE || status == Status.REQUIRES_UPGRADE;\n+        } ).forEach( componentsToUpgrade::add ) );\n+        return componentsToUpgrade;\n+    }\n }",
      "parent_sha": "d07bb583d68efe8d65df8f67f16c87abd0ef669c"
    }
  },
  {
    "oid": "534017752f73bce3545c062269bdcb083c7bc98b",
    "message": "Enable deferred locking by default",
    "date": "2016-07-21T09:28:04Z",
    "url": "https://github.com/neo4j/neo4j/commit/534017752f73bce3545c062269bdcb083c7bc98b",
    "details": {
      "sha": "c805f92a7935958c9996231e08ae465a443ce2dc",
      "filename": "community/kernel/src/main/java/org/neo4j/kernel/impl/factory/GraphDatabaseFacadeFactory.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/neo4j/neo4j/blob/534017752f73bce3545c062269bdcb083c7bc98b/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Ffactory%2FGraphDatabaseFacadeFactory.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/534017752f73bce3545c062269bdcb083c7bc98b/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Ffactory%2FGraphDatabaseFacadeFactory.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Ffactory%2FGraphDatabaseFacadeFactory.java?ref=534017752f73bce3545c062269bdcb083c7bc98b",
      "patch": "@@ -90,7 +90,7 @@ public static class Configuration\n         // Kept here to have it not be publicly documented. community none\n         public static final Setting<String> lock_manager = setting( \"lock_manager\", Settings.STRING, \"\" );\n         public static final Setting<Boolean> deferred_locking =\n-                setting( \"deferred_locking\", Settings.BOOLEAN, Settings.FALSE );\n+                setting( \"deferred_locking\", Settings.BOOLEAN, Settings.TRUE );\n         public static final Setting<String> tracer =\n                 setting( \"dbms.tracer\", Settings.STRING, (String) null ); // 'null' default.\n ",
      "parent_sha": "a569888b8eca52c8490c4d1e89b6e1ec4734c487"
    }
  },
  {
    "oid": "70b57882cd5040ae14fdcee995a54ca0814da742",
    "message": "Add tests for logging unauthorized operations",
    "date": "2016-09-12T15:49:26Z",
    "url": "https://github.com/neo4j/neo4j/commit/70b57882cd5040ae14fdcee995a54ca0814da742",
    "details": {
      "sha": "c968fae2e4b8bb80a186aa16cd5f18730c944b42",
      "filename": "enterprise/security/src/test/java/org/neo4j/server/security/enterprise/auth/AuthProceduresLoggingTest.java",
      "status": "modified",
      "additions": 38,
      "deletions": 1,
      "changes": 39,
      "blob_url": "https://github.com/neo4j/neo4j/blob/70b57882cd5040ae14fdcee995a54ca0814da742/enterprise%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fserver%2Fsecurity%2Fenterprise%2Fauth%2FAuthProceduresLoggingTest.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/70b57882cd5040ae14fdcee995a54ca0814da742/enterprise%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fserver%2Fsecurity%2Fenterprise%2Fauth%2FAuthProceduresLoggingTest.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/enterprise%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fserver%2Fsecurity%2Fenterprise%2Fauth%2FAuthProceduresLoggingTest.java?ref=70b57882cd5040ae14fdcee995a54ca0814da742",
      "patch": "@@ -42,6 +42,7 @@\n \n import static org.neo4j.logging.AssertableLogProvider.inLog;\n import static org.neo4j.server.security.enterprise.auth.AuthProcedures.PERMISSION_DENIED;\n+import static org.neo4j.server.security.enterprise.auth.PredefinedRolesBuilder.ADMIN;\n import static org.neo4j.server.security.enterprise.auth.PredefinedRolesBuilder.ARCHITECT;\n import static org.neo4j.server.security.enterprise.auth.PredefinedRolesBuilder.READER;\n \n@@ -119,6 +120,15 @@ public void shouldLogCreatingUserWithBadPassword() throws Throwable\n                 error( \"[admin]: tried to create user `%s`: %s\", \"mats\", \"A password cannot be empty.\" ) );\n     }\n \n+    @Test\n+    public void shouldLogUnauthorizedCreatingUser() throws Throwable\n+    {\n+        authProcedures.authSubject = matsSubject;\n+        catchAuthorizationViolation( () -> authProcedures.createUser( \"andres\", \"\", true ) );\n+\n+        log.assertExactly( error( \"[mats]: tried to create user `%s`: %s\", \"andres\", PERMISSION_DENIED ) );\n+    }\n+\n     @Test\n     public void shouldLogDeletingUser() throws Throwable\n     {\n@@ -138,6 +148,15 @@ public void shouldLogDeletingNonExistentUser() throws Throwable\n         log.assertExactly( error( \"[admin]: tried to delete user `%s`: %s\", \"andres\", \"User 'andres' does not exist.\" ) );\n     }\n \n+    @Test\n+    public void shouldLogUnauthorizedDeleteUser() throws Throwable\n+    {\n+        authProcedures.authSubject = matsSubject;\n+        catchAuthorizationViolation( () -> authProcedures.deleteUser( ADMIN ) );\n+\n+        log.assertExactly( error( \"[mats]: tried to delete user `%s`: %s\", ADMIN, PERMISSION_DENIED ) );\n+    }\n+\n     @Test\n     public void shouldLogAddingRoleToUser() throws Throwable\n     {\n@@ -160,6 +179,15 @@ public void shouldLogFailureToAddRoleToUser() throws Throwable\n                 error( \"[admin]: tried to add role `%s` to user `%s`: %s\", \"null\", \"mats\", \"Role 'null' does not exist.\" ) );\n     }\n \n+    @Test\n+    public void shouldLogUnauthorizedAddingRole() throws Throwable\n+    {\n+        authProcedures.authSubject = matsSubject;\n+        catchAuthorizationViolation( () -> authProcedures.addRoleToUser( ADMIN, \"mats\" ) );\n+\n+        log.assertExactly( error( \"[mats]: tried to add role `%s` to user `%s`: %s\", ADMIN, \"mats\", PERMISSION_DENIED ) );\n+    }\n+\n     @Test\n     public void shouldLogRemovalOfRoleFromUser() throws Throwable\n     {\n@@ -194,6 +222,15 @@ public void shouldLogFailureToRemoveRoleFromUser() throws Throwable\n         );\n     }\n \n+    @Test\n+    public void shouldLogUnauthorizedRemovingRole() throws Throwable\n+    {\n+        authProcedures.authSubject = matsSubject;\n+        catchAuthorizationViolation( () -> authProcedures.removeRoleFromUser( ADMIN, ADMIN ) );\n+\n+        log.assertExactly( error( \"[mats]: tried to remove role `%s` from user `%s`: %s\", ADMIN, ADMIN, PERMISSION_DENIED ) );\n+    }\n+\n     @Test\n     public void shouldLogPasswordChanges() throws IOException, InvalidArgumentsException\n     {\n@@ -253,7 +290,7 @@ public void shouldLogFailureToChangeOwnPassword() throws Throwable\n     }\n \n     @Test\n-    public void shouldLogUnauthorizedFailureToChangePassword() throws Throwable\n+    public void shouldLogUnauthorizedChangePassword() throws Throwable\n     {\n         // Given\n         authProcedures.createUser( \"andres\", \"neo4j\", true );",
      "parent_sha": "f6b0406217e043eed0b7807c73adf84dd353a532"
    }
  },
  {
    "oid": "0d068f7587325817634aacbcde901da922936815",
    "message": "PublicApi annotation processor includes diff",
    "date": "2020-04-02T07:52:38Z",
    "url": "https://github.com/neo4j/neo4j/commit/0d068f7587325817634aacbcde901da922936815",
    "details": {
      "sha": "0a1a7299bcc0f1a268cdd1bca22955b8278cc92a",
      "filename": "annotations/src/main/java/org/neo4j/annotations/api/PublicApiAnnotationProcessor.java",
      "status": "modified",
      "additions": 28,
      "deletions": 1,
      "changes": 29,
      "blob_url": "https://github.com/neo4j/neo4j/blob/0d068f7587325817634aacbcde901da922936815/annotations%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fannotations%2Fapi%2FPublicApiAnnotationProcessor.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/0d068f7587325817634aacbcde901da922936815/annotations%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fannotations%2Fapi%2FPublicApiAnnotationProcessor.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/annotations%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fannotations%2Fapi%2FPublicApiAnnotationProcessor.java?ref=0d068f7587325817634aacbcde901da922936815",
      "patch": "@@ -31,6 +31,7 @@\n import java.util.Locale;\n import java.util.Set;\n import java.util.TreeSet;\n+import java.util.stream.Stream;\n import javax.annotation.processing.AbstractProcessor;\n import javax.annotation.processing.ProcessingEnvironment;\n import javax.annotation.processing.RoundEnvironment;\n@@ -200,8 +201,10 @@ private void generateSignature() throws IOException\n                     newSignature = newSignature.replace( \"\\r\\n\", \"\\n\" );\n                     if ( !oldSignature.equals( newSignature ) )\n                     {\n+                        StringBuilder diff = diff( oldSignaturePath );\n                         error( format( \"Public API signature mismatch. The generated signature, %s, does not match the old signature in %s.%n\" +\n-                                \"Specify `-Doverwrite` to maven to replace it.\", path, oldSignaturePath ) );\n+                                \"Specify `-Doverwrite` to maven to replace it. Changed public elements, compared to the committed PublicApi.txt:%n%s%n\",\n+                                path, oldSignaturePath, diff ) );\n                     }\n                 }\n                 else\n@@ -212,6 +215,30 @@ private void generateSignature() throws IOException\n         }\n     }\n \n+    private StringBuilder diff( Path oldSignaturePath ) throws IOException\n+    {\n+        Set<String> oldLines = new HashSet<>();\n+        try ( Stream<String> lines = Files.lines( oldSignaturePath, UTF_8 ) )\n+        {\n+            lines.forEach( oldLines::add );\n+        }\n+        StringBuilder diff = new StringBuilder();\n+        diffSide( diff, oldLines, publicElements, '-' );\n+        diffSide( diff, publicElements, oldLines, '+' );\n+        return diff;\n+    }\n+\n+    private void diffSide( StringBuilder diff, Set<String> left, Set<String> right, char diffSign )\n+    {\n+        for ( String oldPublicElement : left )\n+        {\n+            if ( !right.contains( oldPublicElement ) )\n+            {\n+                diff.append( diffSign ).append( oldPublicElement ).append( format( \"%n\" ) );\n+            }\n+        }\n+    }\n+\n     private static Path getAndAssertParent( Path path, String name )\n     {\n         Path parent = path.getParent();",
      "parent_sha": "7370f1a78c09d3a6c9556823caede37ede957bb1"
    }
  },
  {
    "oid": "eb73be3dfb91bf337a0e7a00b9ec3f6aa1b3d19c",
    "message": "Fix test",
    "date": "2017-03-02T11:05:43Z",
    "url": "https://github.com/neo4j/neo4j/commit/eb73be3dfb91bf337a0e7a00b9ec3f6aa1b3d19c",
    "details": {
      "sha": "7f52dcfeb20271c1c7dd23a41baaf6b7de5af56a",
      "filename": "community/kernel/src/test/java/org/neo4j/kernel/configuration/ConfigTest.java",
      "status": "modified",
      "additions": 9,
      "deletions": 5,
      "changes": 14,
      "blob_url": "https://github.com/neo4j/neo4j/blob/eb73be3dfb91bf337a0e7a00b9ec3f6aa1b3d19c/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fconfiguration%2FConfigTest.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/eb73be3dfb91bf337a0e7a00b9ec3f6aa1b3d19c/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fconfiguration%2FConfigTest.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fconfiguration%2FConfigTest.java?ref=eb73be3dfb91bf337a0e7a00b9ec3f6aa1b3d19c",
      "patch": "@@ -205,17 +205,21 @@ public void shouldLogDeprecationWarnings()\n         File confFile = testDirectory.file( \"test.conf\" );\n         assertTrue( confFile.createNewFile() );\n \n-        Config first = Config(\n-                stringMap( GraphDatabaseSettings.strict_config_validation.name(), \"false\",\n-                        MySettingsWithDefaults.oldHello.name(), \"baah\",\n-                        MySettingsWithDefaults.oldSetting.name(), \"booh\" ) );\n+        Config config =\n+                new Config( Optional.of( confFile ),\n+                        stringMap( MySettingsWithDefaults.oldHello.name(), \"baah\",\n+                                MySettingsWithDefaults.oldSetting.name(), \"booh\" ),\n+                        s -> {},\n+                        Collections.emptyList(), Optional.empty(),\n+                        Arrays.asList( mySettingsWithDefaults, myMigratingSettings ) );\n \n         // When\n-        first.setLogger( log );\n+        config.setLogger( log );\n \n         // Then\n         verify( log ).warn( \"%s is deprecated. Replaced by %s\", MySettingsWithDefaults.oldHello.name(),\n                 MySettingsWithDefaults.hello.name() );\n+        verify( log ).warn( \"%s is deprecated.\", MySettingsWithDefaults.oldSetting.name() );\n         verifyNoMoreInteractions( log );\n     }\n ",
      "parent_sha": "89714f858873ff5b7986a94e196ea35fd9d18c6a"
    }
  },
  {
    "oid": "e0cf645eb8881c19b678689455604772734dd971",
    "message": "handle ValueGroup.ANYTHING in initValueAsLowest and initValueAsHighest",
    "date": "2021-12-30T10:32:37Z",
    "url": "https://github.com/neo4j/neo4j/commit/e0cf645eb8881c19b678689455604772734dd971",
    "details": {
      "sha": "711a1c2120d420a4695ff7c3a100fc4b2cdfb32e",
      "filename": "community/kernel/src/main/java/org/neo4j/kernel/impl/index/schema/GenericKey.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/neo4j/neo4j/blob/e0cf645eb8881c19b678689455604772734dd971/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Findex%2Fschema%2FGenericKey.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/e0cf645eb8881c19b678689455604772734dd971/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Findex%2Fschema%2FGenericKey.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Findex%2Fschema%2FGenericKey.java?ref=e0cf645eb8881c19b678689455604772734dd971",
      "patch": "@@ -129,14 +129,14 @@ void initializeToDummyValueInternal()\n     void initValueAsLowest( ValueGroup valueGroup )\n     {\n         clear();\n-        type = valueGroup == ValueGroup.UNKNOWN ? getLowestByValueGroup() : getTypesByGroup()[valueGroup.ordinal()];\n+        type = valueGroup == ValueGroup.UNKNOWN || valueGroup == ValueGroup.ANYTHING ? getLowestByValueGroup() : getTypesByGroup()[valueGroup.ordinal()];\n         type.initializeAsLowest( this );\n     }\n \n     void initValueAsHighest( ValueGroup valueGroup )\n     {\n         clear();\n-        type = valueGroup == ValueGroup.UNKNOWN ? getHighestByValueGroup() : getTypesByGroup()[valueGroup.ordinal()];\n+        type = valueGroup == ValueGroup.UNKNOWN || valueGroup == ValueGroup.ANYTHING ? getHighestByValueGroup() : getTypesByGroup()[valueGroup.ordinal()];\n         type.initializeAsHighest( this );\n     }\n ",
      "parent_sha": "d33e9cf6329ccbee4d64e8678e6eb7de4c51e8b1"
    }
  },
  {
    "oid": "23a2abbf34e86bb09b5bf758e6db7cedfa2e9533",
    "message": "Name change: NumberFullScanNonUniqueIndexSamplerTest -> FullScanNonUniqueIndexSamplerTest",
    "date": "2019-06-11T08:42:28Z",
    "url": "https://github.com/neo4j/neo4j/commit/23a2abbf34e86bb09b5bf758e6db7cedfa2e9533",
    "details": {
      "sha": "71981fc8fef560e707de171ea333a58f235a3f06",
      "filename": "community/kernel/src/test/java/org/neo4j/kernel/impl/index/schema/FullScanNonUniqueIndexSamplerTest.java",
      "status": "renamed",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/neo4j/neo4j/blob/23a2abbf34e86bb09b5bf758e6db7cedfa2e9533/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Findex%2Fschema%2FFullScanNonUniqueIndexSamplerTest.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/23a2abbf34e86bb09b5bf758e6db7cedfa2e9533/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Findex%2Fschema%2FFullScanNonUniqueIndexSamplerTest.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Findex%2Fschema%2FFullScanNonUniqueIndexSamplerTest.java?ref=23a2abbf34e86bb09b5bf758e6db7cedfa2e9533",
      "patch": "@@ -44,7 +44,7 @@\n import static org.neo4j.values.storable.RandomValues.typesOfGroup;\n import static org.neo4j.values.storable.ValueGroup.NUMBER;\n \n-public class NumberFullScanNonUniqueIndexSamplerTest extends NativeIndexTestUtil<GenericKey,NativeIndexValue>\n+public class FullScanNonUniqueIndexSamplerTest extends NativeIndexTestUtil<GenericKey,NativeIndexValue>\n {\n     private static final ConfiguredSpaceFillingCurveSettingsCache configuredSettings = new ConfiguredSpaceFillingCurveSettingsCache( Config.defaults() );\n     private static final IndexSpecificSpaceFillingCurveSettingsCache specificSettings =",
      "previous_filename": "community/kernel/src/test/java/org/neo4j/kernel/impl/index/schema/NumberFullScanNonUniqueIndexSamplerTest.java",
      "parent_sha": "c4272c830e64a630234e7c3178638d9be5eb9bec"
    }
  },
  {
    "oid": "a092c9e1c6a7abdc423601b158e62ed095490126",
    "message": "Update status mapping for LockAcquisitionTimeout and LockClientStopped ()\n\n- update LockAcquisitionTimeout to be TransientError\r\n- update LockClientStopped to be ClientError\r\n\r\nAs by drivers team request.",
    "date": "2022-05-30T19:12:21Z",
    "url": "https://github.com/neo4j/neo4j/commit/a092c9e1c6a7abdc423601b158e62ed095490126",
    "details": {
      "sha": "adaf17b8f64dc917178998825b7bc3af098b53a6",
      "filename": "community/common/src/main/java/org/neo4j/kernel/api/exceptions/Status.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/neo4j/neo4j/blob/a092c9e1c6a7abdc423601b158e62ed095490126/community%2Fcommon%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fapi%2Fexceptions%2FStatus.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/a092c9e1c6a7abdc423601b158e62ed095490126/community%2Fcommon%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fapi%2Fexceptions%2FStatus.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fcommon%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fapi%2Fexceptions%2FStatus.java?ref=a092c9e1c6a7abdc423601b158e62ed095490126",
      "patch": "@@ -136,7 +136,7 @@ enum Transaction implements Status {\n                         + \"You may however chain bookmarks generated from system database with bookmarks from another database.\"),\n         Terminated(ClientError, \"Explicitly terminated by the user.\"),\n         LockAcquisitionTimeout(\n-                ClientError, \"Unable to acquire lock within configured timeout (db.lock.acquisition.timeout).\"),\n+                TransientError, \"Unable to acquire lock within configured timeout (db.lock.acquisition.timeout).\"),\n \n         // database errors\n         TransactionStartFailed(DatabaseError, \"The database was unable to start the transaction.\"),\n@@ -161,7 +161,7 @@ enum Transaction implements Status {\n                 \"Transaction has seen state which has been invalidated by applied updates while \"\n                         + \"transaction was active. Transaction may succeed if retried.\"),\n         LockClientStopped(\n-                TransientError,\n+                ClientError,\n                 \"The transaction has been terminated, so no more locks can be acquired. This can occur because the \"\n                         + \"transaction ran longer than the configured transaction timeout, or because a human operator manually \"\n                         + \"terminated the transaction, or because the database is shutting down.\"),",
      "parent_sha": "9252db3d43589c39cae8c2a0a85f260c5d4aa2f7"
    }
  },
  {
    "oid": "2c192d29681d0033a2ec401e7a2f44466ecc5b89",
    "message": "Fixed a test\n\ngit-svn-id: https://svn.neo4j.org/components/server/trunk@7819 0b971d98-bb2f-0410-8247-b05b2b5feb2a",
    "date": "2010-12-17T11:46:52Z",
    "url": "https://github.com/neo4j/neo4j/commit/2c192d29681d0033a2ec401e7a2f44466ecc5b89",
    "details": {
      "sha": "4a2831599380b6e1ea61699a61bc42bb8b85d252",
      "filename": "enterprise/src/test/java/org/neo4j/server/rest/web/DatabaseActionsTest.java",
      "status": "modified",
      "additions": 280,
      "deletions": 220,
      "changes": 500,
      "blob_url": "https://github.com/neo4j/neo4j/blob/2c192d29681d0033a2ec401e7a2f44466ecc5b89/enterprise%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fserver%2Frest%2Fweb%2FDatabaseActionsTest.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/2c192d29681d0033a2ec401e7a2f44466ecc5b89/enterprise%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fserver%2Frest%2Fweb%2FDatabaseActionsTest.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/enterprise%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fserver%2Frest%2Fweb%2FDatabaseActionsTest.java?ref=2c192d29681d0033a2ec401e7a2f44466ecc5b89",
      "patch": "@@ -57,14 +57,19 @@\n import static org.junit.Assert.*;\n import static org.neo4j.server.rest.repr.RepresentationTestBase.serialize;\n \n-public class DatabaseActionsTest {\n+public class DatabaseActionsTest\n+{\n \n     private static final URI BASE_URI;\n-    static {\n-        try {\n-            BASE_URI = new URI(\"http://neo4j.org/\");\n-        } catch (URISyntaxException e) {\n-            throw new RuntimeException(e);\n+\n+    static\n+    {\n+        try\n+        {\n+            BASE_URI = new URI( \"http://neo4j.org/\" );\n+        } catch ( URISyntaxException e )\n+        {\n+            throw new RuntimeException( e );\n         }\n     }\n \n@@ -73,10 +78,11 @@ public class DatabaseActionsTest {\n     private Database database;\n \n     @Before\n-    public void clearDb() throws IOException {\n-        database = new Database(ServerTestUtils.createTempDir().getAbsolutePath());\n+    public void clearDb() throws IOException\n+    {\n+        database = new Database( ServerTestUtils.createTempDir().getAbsolutePath() );\n \n-        graphdbHelper = new GraphDbHelper(database);\n+        graphdbHelper = new GraphDbHelper( database );\n         this.actions = new DatabaseActions( database, null );\n     }\n \n@@ -86,32 +92,39 @@ public void shutdownDatabase()\n         this.database.shutdown();\n     }\n \n-    private long createNode(Map<String, Object> properties) throws DatabaseBlockedException {\n+    private long createNode( Map<String, Object> properties ) throws DatabaseBlockedException\n+    {\n \n         long nodeId;\n         Transaction tx = database.graph.beginTx();\n-        try {\n+        try\n+        {\n             Node node = database.graph.createNode();\n-            for (Map.Entry<String, Object> entry : properties.entrySet()) {\n-                node.setProperty(entry.getKey(), entry.getValue());\n+            for ( Map.Entry<String, Object> entry : properties.entrySet() )\n+            {\n+                node.setProperty( entry.getKey(), entry.getValue() );\n             }\n             nodeId = node.getId();\n             tx.success();\n-        } finally {\n+        } finally\n+        {\n             tx.finish();\n         }\n         return nodeId;\n     }\n \n \n     @Test\n-    public void createdNodeShouldBeInDatabase() throws Exception {\n+    public void createdNodeShouldBeInDatabase() throws Exception\n+    {\n         NodeRepresentation noderep = actions.createNode( Collections.<String, Object>emptyMap() );\n \n         Transaction tx = database.graph.beginTx();\n-        try {\n-            assertNotNull(database.graph.getNodeById(noderep.getId()));\n-        } finally {\n+        try\n+        {\n+            assertNotNull( database.graph.getNodeById( noderep.getId() ) );\n+        } finally\n+        {\n             tx.finish();\n         }\n     }\n@@ -120,7 +133,7 @@ public void createdNodeShouldBeInDatabase() throws Exception {\n     public void nodeInDatabaseShouldBeRetreivable() throws DatabaseBlockedException,\n             NodeNotFoundException\n     {\n-        long nodeId = new GraphDbHelper(database).createNode();\n+        long nodeId = new GraphDbHelper( database ).createNode();\n         assertNotNull( actions.getNode( nodeId ) );\n     }\n \n@@ -130,15 +143,17 @@ public void shouldBeAbleToStorePropertiesInAnExistingNode() throws DatabaseBlock\n     {\n         long nodeId = graphdbHelper.createNode();\n         Map<String, Object> properties = new HashMap<String, Object>();\n-        properties.put(\"foo\", \"bar\");\n-        properties.put(\"baz\", 17);\n+        properties.put( \"foo\", \"bar\" );\n+        properties.put( \"baz\", 17 );\n         actions.setAllNodeProperties( nodeId, properties );\n \n         Transaction tx = database.graph.beginTx();\n-        try {\n-            Node node = database.graph.getNodeById(nodeId);\n-            assertHasProperties(node, properties);\n-        } finally {\n+        try\n+        {\n+            Node node = database.graph.getNodeById( nodeId );\n+            assertHasProperties( node, properties );\n+        } finally\n+        {\n             tx.finish();\n         }\n     }\n@@ -150,24 +165,28 @@ public void shouldOverwriteExistingProperties() throws DatabaseBlockedException,\n \n         long nodeId;\n         Transaction tx = database.graph.beginTx();\n-        try {\n+        try\n+        {\n             Node node = database.graph.createNode();\n-            node.setProperty(\"remove me\", \"trash\");\n+            node.setProperty( \"remove me\", \"trash\" );\n             nodeId = node.getId();\n             tx.success();\n-        } finally {\n+        } finally\n+        {\n             tx.finish();\n         }\n         Map<String, Object> properties = new HashMap<String, Object>();\n-        properties.put(\"foo\", \"bar\");\n-        properties.put(\"baz\", 17);\n+        properties.put( \"foo\", \"bar\" );\n+        properties.put( \"baz\", 17 );\n         actions.setAllNodeProperties( nodeId, properties );\n         tx = database.graph.beginTx();\n-        try {\n-            Node node = database.graph.getNodeById(nodeId);\n-            assertHasProperties(node, properties);\n-            assertNull(node.getProperty(\"remove me\", null));\n-        } finally {\n+        try\n+        {\n+            Node node = database.graph.getNodeById( nodeId );\n+            assertHasProperties( node, properties );\n+            assertNull( node.getProperty( \"remove me\", null ) );\n+        } finally\n+        {\n             tx.finish();\n         }\n     }\n@@ -179,23 +198,26 @@ public void shouldBeAbleToGetPropertiesOnNode() throws DatabaseBlockedException,\n \n         long nodeId;\n         Map<String, Object> properties = new HashMap<String, Object>();\n-        properties.put(\"foo\", \"bar\");\n-        properties.put(\"neo\", \"Thomas A. Anderson\");\n+        properties.put( \"foo\", \"bar\" );\n+        properties.put( \"neo\", \"Thomas A. Anderson\" );\n         properties.put( \"number\", 15L );\n         Transaction tx = database.graph.beginTx();\n-        try {\n+        try\n+        {\n             Node node = database.graph.createNode();\n-            for (Map.Entry<String, Object> entry : properties.entrySet()) {\n-                node.setProperty(entry.getKey(), entry.getValue());\n+            for ( Map.Entry<String, Object> entry : properties.entrySet() )\n+            {\n+                node.setProperty( entry.getKey(), entry.getValue() );\n             }\n             nodeId = node.getId();\n             tx.success();\n-        } finally {\n+        } finally\n+        {\n             tx.finish();\n         }\n \n         Map<String, Object> readProperties = serialize( actions.getAllNodeProperties( nodeId ) );\n-        assertEquals(properties, readProperties);\n+        assertEquals( properties, readProperties );\n     }\n \n     @Test\n@@ -204,28 +226,30 @@ public void shouldRemoveNodeWithNoRelationsFromDBOnDelete() throws DatabaseBlock\n     {\n         long nodeId;\n         Transaction tx = database.graph.beginTx();\n-        try {\n+        try\n+        {\n             Node node = database.graph.createNode();\n             nodeId = node.getId();\n             tx.success();\n-        } finally {\n+        } finally\n+        {\n             tx.finish();\n         }\n \n         int nodeCount = graphdbHelper.getNumberOfNodes();\n-        actions.deleteNode(nodeId);\n-        assertEquals(nodeCount - 1, graphdbHelper.getNumberOfNodes());\n+        actions.deleteNode( nodeId );\n+        assertEquals( nodeCount - 1, graphdbHelper.getNumberOfNodes() );\n     }\n \n     @Test\n     public void shouldBeAbleToSetPropertyOnNode() throws DatabaseBlockedException,\n             PropertyValueException, NodeNotFoundException\n     {\n-        long nodeId = createNode(Collections.<String, Object> emptyMap());\n+        long nodeId = createNode( Collections.<String, Object>emptyMap() );\n         String key = \"foo\";\n         Object value = \"bar\";\n-        actions.setNodeProperty(nodeId, key, value);\n-        assertEquals(Collections.singletonMap(key, value), graphdbHelper.getNodeProperties(nodeId));\n+        actions.setNodeProperty( nodeId, key, value );\n+        assertEquals( Collections.singletonMap( key, value ), graphdbHelper.getNodeProperties( nodeId ) );\n     }\n \n     @Test\n@@ -234,7 +258,7 @@ public void shouldBeAbleToGetPropertyOnNode() throws DatabaseBlockedException,\n     {\n         String key = \"foo\";\n         Object value = \"bar\";\n-        long nodeId = createNode(Collections.singletonMap(key, (Object) value));\n+        long nodeId = createNode( Collections.singletonMap( key, (Object)value ) );\n         assertEquals( value, serialize( actions.getNodeProperty( nodeId, key ) ) );\n     }\n \n@@ -243,82 +267,92 @@ public void shouldBeAbleToRemoveNodeProperties() throws DatabaseBlockedException\n             NodeNotFoundException\n     {\n         Map<String, Object> properties = new HashMap<String, Object>();\n-        properties.put(\"foo\", \"bar\");\n-        properties.put(\"number\", 15);\n-        long nodeId = createNode(properties);\n+        properties.put( \"foo\", \"bar\" );\n+        properties.put( \"number\", 15 );\n+        long nodeId = createNode( properties );\n         actions.removeAllNodeProperties( nodeId );\n \n         Transaction tx = database.graph.beginTx();\n-        try {\n-            Node node = database.graph.getNodeById(nodeId);\n-            assertEquals(false, node.getPropertyKeys().iterator().hasNext());\n+        try\n+        {\n+            Node node = database.graph.getNodeById( nodeId );\n+            assertEquals( false, node.getPropertyKeys().iterator().hasNext() );\n             tx.success();\n-        } finally {\n+        } finally\n+        {\n             tx.finish();\n         }\n     }\n \n     @Test\n-    public void shouldStoreRelationshipsBetweenTwoExistingNodes() throws Exception {\n+    public void shouldStoreRelationshipsBetweenTwoExistingNodes() throws Exception\n+    {\n         int relationshipCount = graphdbHelper.getNumberOfRelationships();\n         actions.createRelationship( graphdbHelper.createNode(), graphdbHelper.createNode(),\n                 \"LOVES\", Collections.<String, Object>emptyMap() );\n-        assertEquals(relationshipCount + 1, graphdbHelper.getNumberOfRelationships());\n+        assertEquals( relationshipCount + 1, graphdbHelper.getNumberOfRelationships() );\n     }\n \n     @Test\n-    public void shouldStoreSuppliedPropertiesWhenCreatingRelationship() throws Exception {\n+    public void shouldStoreSuppliedPropertiesWhenCreatingRelationship() throws Exception\n+    {\n         Map<String, Object> properties = new HashMap<String, Object>();\n-        properties.put(\"string\", \"value\");\n-        properties.put(\"integer\", 17);\n+        properties.put( \"string\", \"value\" );\n+        properties.put( \"integer\", 17 );\n         long relId = actions.createRelationship( graphdbHelper.createNode(),\n                 graphdbHelper.createNode(), \"LOVES\", properties ).getId();\n \n         Transaction tx = database.graph.beginTx();\n-        try {\n-            Relationship rel = database.graph.getRelationshipById(relId);\n-            for (String key : rel.getPropertyKeys()) {\n-                assertTrue(\"extra property stored\", properties.containsKey(key));\n+        try\n+        {\n+            Relationship rel = database.graph.getRelationshipById( relId );\n+            for ( String key : rel.getPropertyKeys() )\n+            {\n+                assertTrue( \"extra property stored\", properties.containsKey( key ) );\n             }\n-            for (Map.Entry<String, Object> entry : properties.entrySet()) {\n-                assertEquals(entry.getValue(), rel.getProperty(entry.getKey()));\n+            for ( Map.Entry<String, Object> entry : properties.entrySet() )\n+            {\n+                assertEquals( entry.getValue(), rel.getProperty( entry.getKey() ) );\n             }\n-        } finally {\n+        } finally\n+        {\n             tx.finish();\n         }\n     }\n \n     @Test\n-    public void shouldNotCreateRelationshipBetweenNonExistentNodes() throws Exception {\n+    public void shouldNotCreateRelationshipBetweenNonExistentNodes() throws Exception\n+    {\n         long nodeId = graphdbHelper.createNode();\n         Map<String, Object> properties = Collections.<String, Object>emptyMap();\n-        try {\n+        try\n+        {\n             actions.createRelationship( nodeId, nodeId * 1000, \"Loves\", properties );\n             fail();\n-        }\n-        catch ( EndNodeNotFoundException e )\n+        } catch ( EndNodeNotFoundException e )\n         {\n             // ok\n         }\n-        try {\n+        try\n+        {\n             actions.createRelationship( nodeId * 1000, nodeId, \"Loves\", properties );\n             fail();\n-        }\n-        catch ( StartNodeNotFoundException e )\n+        } catch ( StartNodeNotFoundException e )\n         {\n             // ok\n         }\n     }\n \n     @Test\n-    public void shouldNotCreateRelationshipWithSameStartAsEndNode() throws Exception {\n+    public void shouldNotCreateRelationshipWithSameStartAsEndNode() throws Exception\n+    {\n         long nodeId = graphdbHelper.createNode();\n         Map<String, Object> properties = Collections.<String, Object>emptyMap();\n-        try {\n+        try\n+        {\n             actions.createRelationship( nodeId, nodeId, \"Loves\", properties );\n             fail();\n-        }\n-        catch ( StartNodeSameAsEndNodeException e )\n+        } catch ( StartNodeSameAsEndNodeException e )\n         {\n             // ok\n         }\n@@ -329,18 +363,20 @@ public void shouldBeAbleToRemoveNodeProperty() throws DatabaseBlockedException,\n             NodeNotFoundException, NoSuchPropertyException\n     {\n         Map<String, Object> properties = new HashMap<String, Object>();\n-        properties.put(\"foo\", \"bar\");\n-        properties.put(\"number\", 15);\n-        long nodeId = createNode(properties);\n-        actions.removeNodeProperty(nodeId, \"foo\");\n+        properties.put( \"foo\", \"bar\" );\n+        properties.put( \"number\", 15 );\n+        long nodeId = createNode( properties );\n+        actions.removeNodeProperty( nodeId, \"foo\" );\n \n         Transaction tx = database.graph.beginTx();\n-        try {\n-            Node node = database.graph.getNodeById(nodeId);\n-            assertEquals(15, node.getProperty(\"number\"));\n-            assertEquals(false, node.hasProperty(\"foo\"));\n+        try\n+        {\n+            Node node = database.graph.getNodeById( nodeId );\n+            assertEquals( 15, node.getProperty( \"number\" ) );\n+            assertEquals( false, node.hasProperty( \"foo\" ) );\n             tx.success();\n-        } finally {\n+        } finally\n+        {\n             tx.finish();\n         }\n     }\n@@ -350,9 +386,9 @@ public void shouldReturnTrueIfNodePropertyRemoved() throws DatabaseBlockedExcept\n             NodeNotFoundException, NoSuchPropertyException\n     {\n         Map<String, Object> properties = new HashMap<String, Object>();\n-        properties.put(\"foo\", \"bar\");\n-        properties.put(\"number\", 15);\n-        long nodeId = createNode(properties);\n+        properties.put( \"foo\", \"bar\" );\n+        properties.put( \"number\", 15 );\n+        long nodeId = createNode( properties );\n         actions.removeNodeProperty( nodeId, \"foo\" );\n     }\n \n@@ -361,17 +397,17 @@ public void shouldReturnFalseIfNodePropertyNotRemoved() throws DatabaseBlockedEx\n             NodeNotFoundException, NoSuchPropertyException\n     {\n         Map<String, Object> properties = new HashMap<String, Object>();\n-        properties.put(\"foo\", \"bar\");\n-        properties.put(\"number\", 15);\n-        long nodeId = createNode(properties);\n+        properties.put( \"foo\", \"bar\" );\n+        properties.put( \"number\", 15 );\n+        long nodeId = createNode( properties );\n         actions.removeNodeProperty( nodeId, \"baz\" );\n     }\n \n     @Test\n     public void shouldBeAbleToRetrieveARelationship() throws DatabaseBlockedException,\n             RelationshipNotFoundException\n     {\n-        long relationship = graphdbHelper.createRelationship(\"ENJOYED\");\n+        long relationship = graphdbHelper.createRelationship( \"ENJOYED\" );\n         assertNotNull( actions.getRelationship( relationship ) );\n     }\n \n@@ -382,54 +418,59 @@ public void shouldBeAbleToGetPropertiesOnRelationship() throws DatabaseBlockedEx\n \n         long relationshipId;\n         Map<String, Object> properties = new HashMap<String, Object>();\n-        properties.put(\"foo\", \"bar\");\n-        properties.put(\"neo\", \"Thomas A. Anderson\");\n+        properties.put( \"foo\", \"bar\" );\n+        properties.put( \"neo\", \"Thomas A. Anderson\" );\n         properties.put( \"number\", 15L );\n         Transaction tx = database.graph.beginTx();\n-        try {\n+        try\n+        {\n             Node startNode = database.graph.createNode();\n             Node endNode = database.graph.createNode();\n-            Relationship relationship = startNode.createRelationshipTo(endNode, DynamicRelationshipType.withName(\"knows\"));\n-            for (Map.Entry<String, Object> entry : properties.entrySet()) {\n-                relationship.setProperty(entry.getKey(), entry.getValue());\n+            Relationship relationship = startNode.createRelationshipTo( endNode, DynamicRelationshipType.withName( \"knows\" ) );\n+            for ( Map.Entry<String, Object> entry : properties.entrySet() )\n+            {\n+                relationship.setProperty( entry.getKey(), entry.getValue() );\n             }\n             relationshipId = relationship.getId();\n             tx.success();\n-        } finally {\n+        } finally\n+        {\n             tx.finish();\n         }\n \n         Map<String, Object> readProperties = serialize( actions.getAllRelationshipProperties( relationshipId ) );\n-        assertEquals(properties, readProperties);\n+        assertEquals( properties, readProperties );\n     }\n \n     @Test\n     public void shouldBeAbleToRetrieveASinglePropertyFromARelationship()\n             throws DatabaseBlockedException, NoSuchPropertyException, RelationshipNotFoundException\n     {\n         Map<String, Object> properties = new HashMap<String, Object>();\n-        properties.put(\"foo\", \"bar\");\n-        properties.put(\"neo\", \"Thomas A. Anderson\");\n+        properties.put( \"foo\", \"bar\" );\n+        properties.put( \"neo\", \"Thomas A. Anderson\" );\n         properties.put( \"number\", 15L );\n \n-        long relationshipId = graphdbHelper.createRelationship(\"LOVES\");\n-        graphdbHelper.setRelationshipProperties(relationshipId, properties);\n+        long relationshipId = graphdbHelper.createRelationship( \"LOVES\" );\n+        graphdbHelper.setRelationshipProperties( relationshipId, properties );\n \n         Object relationshipProperty = serialize( actions.getRelationshipProperty( relationshipId, \"foo\" ) );\n-        assertEquals(\"bar\", relationshipProperty);\n+        assertEquals( \"bar\", relationshipProperty );\n     }\n \n     @Test\n     public void shouldBeAbleToDeleteARelationship() throws DatabaseBlockedException,\n             RelationshipNotFoundException\n     {\n-        long relationshipId = graphdbHelper.createRelationship(\"LOVES\");\n+        long relationshipId = graphdbHelper.createRelationship( \"LOVES\" );\n \n         actions.deleteRelationship( relationshipId );\n-        try {\n-            graphdbHelper.getRelationship(relationshipId);\n+        try\n+        {\n+            graphdbHelper.getRelationship( relationshipId );\n             fail();\n-        } catch (NotFoundException e) {\n+        } catch ( NotFoundException e )\n+        {\n         }\n     }\n \n@@ -489,98 +530,105 @@ public void shouldNotGetAnyRelationshipsWhenRetrievingFromNodeWithoutRelationshi\n     public void shouldBeAbleToSetRelationshipProperties() throws DatabaseBlockedException,\n             PropertyValueException, RelationshipNotFoundException\n     {\n-        long relationshipId = graphdbHelper.createRelationship(\"KNOWS\");\n+        long relationshipId = graphdbHelper.createRelationship( \"KNOWS\" );\n         Map<String, Object> properties = new HashMap<String, Object>();\n-        properties.put(\"foo\", \"bar\");\n-        properties.put(\"number\", 10);\n+        properties.put( \"foo\", \"bar\" );\n+        properties.put( \"number\", 10 );\n         actions.setAllRelationshipProperties( relationshipId, properties );\n-        assertEquals(properties, graphdbHelper.getRelationshipProperties(relationshipId));\n+        assertEquals( properties, graphdbHelper.getRelationshipProperties( relationshipId ) );\n     }\n \n     @Test\n     public void shouldBeAbleToSetRelationshipProperty() throws DatabaseBlockedException,\n             PropertyValueException, RelationshipNotFoundException\n     {\n-        long relationshipId = graphdbHelper.createRelationship(\"KNOWS\");\n+        long relationshipId = graphdbHelper.createRelationship( \"KNOWS\" );\n         String key = \"foo\";\n         Object value = \"bar\";\n-        actions.setRelationshipProperty(relationshipId, key, value);\n-        assertEquals(Collections.singletonMap(key, value), graphdbHelper.getRelationshipProperties(relationshipId));\n+        actions.setRelationshipProperty( relationshipId, key, value );\n+        assertEquals( Collections.singletonMap( key, value ), graphdbHelper.getRelationshipProperties( relationshipId ) );\n     }\n \n     @Test\n     public void shouldRemoveRelationProperties() throws DatabaseBlockedException,\n             RelationshipNotFoundException\n     {\n-        long relId = graphdbHelper.createRelationship(\"PAIR-PROGRAMS_WITH\");\n+        long relId = graphdbHelper.createRelationship( \"PAIR-PROGRAMS_WITH\" );\n         Map<String, Object> map = new HashMap<String, Object>();\n-        map.put(\"foo\", \"bar\");\n-        map.put(\"baz\", 22);\n-        graphdbHelper.setRelationshipProperties(relId, map);\n+        map.put( \"foo\", \"bar\" );\n+        map.put( \"baz\", 22 );\n+        graphdbHelper.setRelationshipProperties( relId, map );\n \n         actions.removeAllRelationshipProperties( relId );\n \n-        assertTrue(graphdbHelper.getRelationshipProperties(relId).isEmpty());\n+        assertTrue( graphdbHelper.getRelationshipProperties( relId ).isEmpty() );\n     }\n \n     @Test\n     public void shouldRemoveRelationshipProperty() throws DatabaseBlockedException,\n             RelationshipNotFoundException, NoSuchPropertyException\n     {\n-        long relId = graphdbHelper.createRelationship(\"PAIR-PROGRAMS_WITH\");\n+        long relId = graphdbHelper.createRelationship( \"PAIR-PROGRAMS_WITH\" );\n         Map<String, Object> map = new HashMap<String, Object>();\n-        map.put(\"foo\", \"bar\");\n-        map.put(\"baz\", 22);\n-        graphdbHelper.setRelationshipProperties(relId, map);\n+        map.put( \"foo\", \"bar\" );\n+        map.put( \"baz\", 22 );\n+        graphdbHelper.setRelationshipProperties( relId, map );\n \n         actions.removeRelationshipProperty( relId, \"foo\" );\n-        assertEquals(1, graphdbHelper.getRelationshipProperties(relId).size());\n+        assertEquals( 1, graphdbHelper.getRelationshipProperties( relId ).size() );\n     }\n \n     @SuppressWarnings( \"unchecked\" )\n     private void verifyRelReps( int expectedSize, ListRepresentation repr )\n     {\n         List<Object> relreps = serialize( repr );\n-        assertEquals(expectedSize, relreps.size());\n+        assertEquals( expectedSize, relreps.size() );\n         for ( Object relrep : relreps )\n         {\n-            RelationshipRepresentationTest.verifySerialisation( (Map<String, Object>) relrep );\n+            RelationshipRepresentationTest.verifySerialisation( (Map<String, Object>)relrep );\n         }\n     }\n \n-    private void assertHasProperties(PropertyContainer container, Map<String, Object> properties) {\n-        for (Map.Entry<String, Object> entry : properties.entrySet()) {\n-            assertEquals(entry.getValue(), container.getProperty(entry.getKey()));\n+    private void assertHasProperties( PropertyContainer container, Map<String, Object> properties )\n+    {\n+        for ( Map.Entry<String, Object> entry : properties.entrySet() )\n+        {\n+            assertEquals( entry.getValue(), container.getProperty( entry.getKey() ) );\n         }\n     }\n \n     @Test\n-    public void shouldBeAbleToIndexNode() throws DatabaseBlockedException {\n+    public void shouldBeAbleToIndexNode() throws DatabaseBlockedException\n+    {\n         String key = \"mykey\";\n         String value = \"myvalue\";\n         long nodeId = graphdbHelper.createNode();\n         String indexName = \"node\";\n+\n+        actions.createNodeIndex( MapUtil.map( \"name\", indexName ) );\n+\n         assertFalse( serialize( actions.getIndexedNodes( indexName, key, value ) ).iterator().hasNext() );\n         actions.addToNodeIndex( indexName, key, value, nodeId );\n-        assertEquals(Arrays.asList(nodeId), graphdbHelper.getIndexedNodes( indexName, key, value));\n+        assertEquals( Arrays.asList( nodeId ), graphdbHelper.getIndexedNodes( indexName, key, value ) );\n     }\n \n     @Test\n-    public void shouldBeAbleToFulltextIndex() throws DatabaseBlockedException {\n+    public void shouldBeAbleToFulltextIndex() throws DatabaseBlockedException\n+    {\n         String key = \"key\";\n         String value = \"the value with spaces\";\n         long nodeId = graphdbHelper.createNode();\n         String indexName = \"fulltext-node\";\n         graphdbHelper.createNodeFullTextIndex( indexName );\n-        assertFalse( serialize(actions.getIndexedNodes(indexName, key, value )).iterator().hasNext() );\n-        actions.addToNodeIndex(indexName, key, value, nodeId);\n-        assertEquals(Arrays.asList(nodeId), graphdbHelper.getIndexedNodes(indexName, key, value));\n-        assertEquals(Arrays.asList(nodeId), graphdbHelper.getIndexedNodes(indexName, key, \"the value with spaces\"));\n-        assertEquals(Arrays.asList(nodeId), graphdbHelper.queryIndexedNodes(indexName, key, \"the\"));\n-        assertEquals(Arrays.asList(nodeId), graphdbHelper.queryIndexedNodes(indexName, key, \"value\"));\n-        assertEquals(Arrays.asList(nodeId), graphdbHelper.queryIndexedNodes(indexName, key, \"with\"));\n-        assertEquals(Arrays.asList(nodeId), graphdbHelper.queryIndexedNodes(indexName, key, \"spaces\"));\n-        assertTrue(graphdbHelper.getIndexedNodes(indexName, key, \"nohit\").isEmpty());\n+        assertFalse( serialize( actions.getIndexedNodes( indexName, key, value ) ).iterator().hasNext() );\n+        actions.addToNodeIndex( indexName, key, value, nodeId );\n+        assertEquals( Arrays.asList( nodeId ), graphdbHelper.getIndexedNodes( indexName, key, value ) );\n+        assertEquals( Arrays.asList( nodeId ), graphdbHelper.getIndexedNodes( indexName, key, \"the value with spaces\" ) );\n+        assertEquals( Arrays.asList( nodeId ), graphdbHelper.queryIndexedNodes( indexName, key, \"the\" ) );\n+        assertEquals( Arrays.asList( nodeId ), graphdbHelper.queryIndexedNodes( indexName, key, \"value\" ) );\n+        assertEquals( Arrays.asList( nodeId ), graphdbHelper.queryIndexedNodes( indexName, key, \"with\" ) );\n+        assertEquals( Arrays.asList( nodeId ), graphdbHelper.queryIndexedNodes( indexName, key, \"spaces\" ) );\n+        assertTrue( graphdbHelper.getIndexedNodes( indexName, key, \"nohit\" ).isEmpty() );\n     }\n \n     @Test\n@@ -592,65 +640,69 @@ public void shouldBeAbleToGetReferenceNode() throws DatabaseBlockedException,\n     }\n \n     @Test\n-    public void shouldGetExtendedNodeRepresentationsWhenGettingFromIndex() throws DatabaseBlockedException {\n+    public void shouldGetExtendedNodeRepresentationsWhenGettingFromIndex() throws DatabaseBlockedException\n+    {\n         String key = \"mykey3\";\n         String value = \"value\";\n \n         long nodeId = graphdbHelper.createNode();\n         String indexName = \"node\";\n-        graphdbHelper.addNodeToIndex( indexName, key, value, nodeId);\n+        graphdbHelper.addNodeToIndex( indexName, key, value, nodeId );\n         int counter = 0;\n         for ( Object rep : serialize( actions.getIndexedNodes( indexName, key, value ) ) )\n         {\n-            Map<String, Object> serialized = (Map<String, Object>) rep;\n-            NodeRepresentationTest.verifySerialisation(serialized);\n-            assertNotNull(serialized.get(\"indexed\"));\n+            Map<String, Object> serialized = (Map<String, Object>)rep;\n+            NodeRepresentationTest.verifySerialisation( serialized );\n+            assertNotNull( serialized.get( \"indexed\" ) );\n             counter++;\n         }\n-        assertEquals(1, counter);\n+        assertEquals( 1, counter );\n     }\n \n     @Test\n-    public void shouldBeAbleToRemoveNodeFromIndex() throws DatabaseBlockedException {\n+    public void shouldBeAbleToRemoveNodeFromIndex() throws DatabaseBlockedException\n+    {\n         String key = \"mykey2\";\n         String value = \"myvalue\";\n         String value2 = \"myvalue2\";\n         String indexName = \"node\";\n         long nodeId = graphdbHelper.createNode();\n         actions.addToNodeIndex( indexName, key, value, nodeId );\n         actions.addToNodeIndex( indexName, key, value2, nodeId );\n-        assertEquals(1, graphdbHelper.getIndexedNodes(indexName, key, value).size());\n-        assertEquals(1, graphdbHelper.getIndexedNodes(indexName, key, value2).size());\n+        assertEquals( 1, graphdbHelper.getIndexedNodes( indexName, key, value ).size() );\n+        assertEquals( 1, graphdbHelper.getIndexedNodes( indexName, key, value2 ).size() );\n         actions.removeFromNodeIndex( indexName, key, value, nodeId );\n-        assertEquals(0, graphdbHelper.getIndexedNodes(indexName, key, value).size());\n-        assertEquals(1, graphdbHelper.getIndexedNodes(indexName, key, value2).size());\n+        assertEquals( 0, graphdbHelper.getIndexedNodes( indexName, key, value ).size() );\n+        assertEquals( 1, graphdbHelper.getIndexedNodes( indexName, key, value2 ).size() );\n         actions.removeFromNodeIndex( indexName, key, value2, nodeId );\n-        assertEquals(0, graphdbHelper.getIndexedNodes(indexName, key, value).size());\n-        assertEquals(0, graphdbHelper.getIndexedNodes(indexName, key, value2).size());\n+        assertEquals( 0, graphdbHelper.getIndexedNodes( indexName, key, value ).size() );\n+        assertEquals( 0, graphdbHelper.getIndexedNodes( indexName, key, value2 ).size() );\n     }\n \n-    private long createBasicTraversableGraph() throws DatabaseBlockedException {\n+    private long createBasicTraversableGraph() throws DatabaseBlockedException\n+    {\n         // (Root)\n         // / \\\n         // (Mattias) (Johan)\n         // / / \\\n         // (Emil) (Peter) (Tobias)\n \n-        long startNode = graphdbHelper.createNode(MapUtil.map(\"name\", \"Root\"));\n-        long child1_l1 = graphdbHelper.createNode(MapUtil.map(\"name\", \"Mattias\"));\n-        graphdbHelper.createRelationship(\"knows\", startNode, child1_l1);\n-        long child2_l1 = graphdbHelper.createNode(MapUtil.map(\"name\", \"Johan\"));\n-        graphdbHelper.createRelationship(\"knows\", startNode, child2_l1);\n-        long child1_l2 = graphdbHelper.createNode(MapUtil.map(\"name\", \"Emil\"));\n-        graphdbHelper.createRelationship(\"knows\", child2_l1, child1_l2);\n-        long child1_l3 = graphdbHelper.createNode(MapUtil.map(\"name\", \"Peter\"));\n-        graphdbHelper.createRelationship(\"knows\", child1_l2, child1_l3);\n-        long child2_l3 = graphdbHelper.createNode(MapUtil.map(\"name\", \"Tobias\"));\n-        graphdbHelper.createRelationship(\"loves\", child1_l2, child2_l3);\n+        long startNode = graphdbHelper.createNode( MapUtil.map( \"name\", \"Root\" ) );\n+        long child1_l1 = graphdbHelper.createNode( MapUtil.map( \"name\", \"Mattias\" ) );\n+        graphdbHelper.createRelationship( \"knows\", startNode, child1_l1 );\n+        long child2_l1 = graphdbHelper.createNode( MapUtil.map( \"name\", \"Johan\" ) );\n+        graphdbHelper.createRelationship( \"knows\", startNode, child2_l1 );\n+        long child1_l2 = graphdbHelper.createNode( MapUtil.map( \"name\", \"Emil\" ) );\n+        graphdbHelper.createRelationship( \"knows\", child2_l1, child1_l2 );\n+        long child1_l3 = graphdbHelper.createNode( MapUtil.map( \"name\", \"Peter\" ) );\n+        graphdbHelper.createRelationship( \"knows\", child1_l2, child1_l3 );\n+        long child2_l3 = graphdbHelper.createNode( MapUtil.map( \"name\", \"Tobias\" ) );\n+        graphdbHelper.createRelationship( \"loves\", child1_l2, child2_l3 );\n         return startNode;\n     }\n \n-    private long[] createMoreComplexGraph() throws DatabaseBlockedException {\n+    private long[] createMoreComplexGraph() throws DatabaseBlockedException\n+    {\n         // (a)\n         // / \\\n         // v v\n@@ -666,140 +718,148 @@ private long[] createMoreComplexGraph() throws DatabaseBlockedException {\n         long e = graphdbHelper.createNode();\n         long f = graphdbHelper.createNode();\n         long g = graphdbHelper.createNode();\n-        graphdbHelper.createRelationship(\"to\", a, c);\n-        graphdbHelper.createRelationship(\"to\", a, d);\n-        graphdbHelper.createRelationship(\"to\", c, b);\n-        graphdbHelper.createRelationship(\"to\", d, e);\n-        graphdbHelper.createRelationship(\"to\", b, f);\n-        graphdbHelper.createRelationship(\"to\", c, f);\n-        graphdbHelper.createRelationship(\"to\", f, g);\n-        graphdbHelper.createRelationship(\"to\", d, g);\n-        graphdbHelper.createRelationship(\"to\", e, g);\n-        graphdbHelper.createRelationship(\"to\", c, g);\n-        return new long[] { a, g };\n+        graphdbHelper.createRelationship( \"to\", a, c );\n+        graphdbHelper.createRelationship( \"to\", a, d );\n+        graphdbHelper.createRelationship( \"to\", c, b );\n+        graphdbHelper.createRelationship( \"to\", d, e );\n+        graphdbHelper.createRelationship( \"to\", b, f );\n+        graphdbHelper.createRelationship( \"to\", c, f );\n+        graphdbHelper.createRelationship( \"to\", f, g );\n+        graphdbHelper.createRelationship( \"to\", d, g );\n+        graphdbHelper.createRelationship( \"to\", e, g );\n+        graphdbHelper.createRelationship( \"to\", c, g );\n+        return new long[]{a, g};\n     }\n \n     @Test\n-    public void shouldBeAbleToTraverseWithDefaultParameters() throws DatabaseBlockedException {\n+    public void shouldBeAbleToTraverseWithDefaultParameters() throws DatabaseBlockedException\n+    {\n         long startNode = createBasicTraversableGraph();\n         List<Object> hits = serialize( actions.traverse( startNode, new HashMap<String, Object>(),\n                 TraverserReturnType.node ) );\n-        assertEquals(2, hits.size());\n+        assertEquals( 2, hits.size() );\n     }\n \n     @Test\n-    public void shouldBeAbleToTraverseDepthTwo() throws DatabaseBlockedException {\n+    public void shouldBeAbleToTraverseDepthTwo() throws DatabaseBlockedException\n+    {\n         long startNode = createBasicTraversableGraph();\n         List<Object> hits = serialize( actions.traverse( startNode, MapUtil.map(\n                 \"max depth\", 2 ), TraverserReturnType.node ) );\n-        assertEquals(3, hits.size());\n+        assertEquals( 3, hits.size() );\n     }\n \n     @Test\n-    public void shouldBeAbleToTraverseEverything() throws DatabaseBlockedException {\n+    public void shouldBeAbleToTraverseEverything() throws DatabaseBlockedException\n+    {\n         long startNode = createBasicTraversableGraph();\n         List<Object> hits = serialize( actions.traverse( startNode, MapUtil.map(\n                 \"return filter\", MapUtil.map( \"language\", \"javascript\", \"body\", \"true;\" ),\n                 \"max depth\", 10 ), TraverserReturnType.node ) );\n-        assertEquals(6, hits.size());\n+        assertEquals( 6, hits.size() );\n         hits = serialize( actions.traverse( startNode, MapUtil.map( \"return filter\", MapUtil.map(\n                 \"language\", \"builtin\", \"name\", \"all\" ), \"max depth\", 10 ), TraverserReturnType.node ) );\n-        assertEquals(6, hits.size());\n+        assertEquals( 6, hits.size() );\n     }\n \n     @Test\n-    public void shouldBeAbleToUseCustomReturnFilter() throws DatabaseBlockedException {\n+    public void shouldBeAbleToUseCustomReturnFilter() throws DatabaseBlockedException\n+    {\n         long startNode = createBasicTraversableGraph();\n         List<Object> hits = serialize( actions.traverse( startNode, MapUtil.map( \"prune evaluator\",\n                 MapUtil.map( \"language\", \"builtin\", \"name\", \"none\" ),\n-                \"return filter\", MapUtil.map(\"language\", \"javascript\", \"body\", \"position.endNode().getProperty( 'name' ).contains( 'o' )\")),\n+                \"return filter\", MapUtil.map( \"language\", \"javascript\", \"body\", \"position.endNode().getProperty( 'name' ).contains( 'o' )\" ) ),\n                 TraverserReturnType.node ) );\n-        assertEquals(3, hits.size());\n+        assertEquals( 3, hits.size() );\n     }\n \n     @Test\n-    public void shouldBeAbleToTraverseWithMaxDepthAndPruneEvaluatorCombined() throws DatabaseBlockedException {\n+    public void shouldBeAbleToTraverseWithMaxDepthAndPruneEvaluatorCombined() throws DatabaseBlockedException\n+    {\n         long startNode = createBasicTraversableGraph();\n         List<Object> hits = serialize( actions.traverse( startNode, MapUtil.map( \"max depth\", 2,\n                 \"prune evaluator\", MapUtil.map( \"language\", \"javascript\", \"body\",\n-                        \"position.endNode().getProperty('name').equals('Emil')\" ) ),\n+                \"position.endNode().getProperty('name').equals('Emil')\" ) ),\n                 TraverserReturnType.node ) );\n-        assertEquals(3, hits.size());\n+        assertEquals( 3, hits.size() );\n         hits = serialize( actions.traverse( startNode, MapUtil.map( \"max depth\", 1,\n                 \"prune evaluator\", MapUtil.map( \"language\", \"javascript\", \"body\",\n-                        \"position.endNode().getProperty('name').equals('Emil')\" ) ),\n+                \"position.endNode().getProperty('name').equals('Emil')\" ) ),\n                 TraverserReturnType.node ) );\n-        assertEquals(2, hits.size());\n+        assertEquals( 2, hits.size() );\n     }\n \n     @Test\n-    public void shouldBeAbleToGetRelationshipsIfSpecified() throws DatabaseBlockedException {\n+    public void shouldBeAbleToGetRelationshipsIfSpecified() throws DatabaseBlockedException\n+    {\n         long startNode = createBasicTraversableGraph();\n         ListRepresentation traverse = actions.traverse( startNode, new HashMap<String, Object>(),\n                 TraverserReturnType.relationship );\n         List<Object> hits = serialize( traverse );\n         for ( Object hit : hits )\n         {\n-            RelationshipRepresentationTest.verifySerialisation( (Map<String, Object>) hit );\n+            RelationshipRepresentationTest.verifySerialisation( (Map<String, Object>)hit );\n         }\n     }\n \n     @Test\n-    public void shouldBeAbleToGetPathsIfSpecified() throws DatabaseBlockedException {\n+    public void shouldBeAbleToGetPathsIfSpecified() throws DatabaseBlockedException\n+    {\n         long startNode = createBasicTraversableGraph();\n         List<Object> hits = serialize( actions.traverse( startNode, new HashMap<String, Object>(),\n                 TraverserReturnType.path ) );\n \n         for ( Object hit : hits )\n         {\n-            Map<String,Object> map = (Map<String, Object>)hit;\n-            assertThat(map, hasKey(\"start\"));\n-            assertThat(map, hasKey(\"end\"));\n-            assertThat(map, hasKey(\"length\"));\n+            Map<String, Object> map = (Map<String, Object>)hit;\n+            assertThat( map, hasKey( \"start\" ) );\n+            assertThat( map, hasKey( \"end\" ) );\n+            assertThat( map, hasKey( \"length\" ) );\n         }\n     }\n \n     @Test\n-    public void shouldBeAbleToGetShortestPaths() throws Exception {\n+    public void shouldBeAbleToGetShortestPaths() throws Exception\n+    {\n         long[] nodes = createMoreComplexGraph();\n \n         // /paths\n-        List<Object> result = serialize( actions.findPaths( nodes[0], nodes[1], MapUtil.map(\n+        List<Object> result = serialize( actions.findPaths( nodes[ 0 ], nodes[ 1 ], MapUtil.map(\n                 \"max depth\", 2, \"algorithm\", \"shortestPath\", \"relationships\", MapUtil.map( \"type\",\n-                        \"to\", \"direction\", \"out\" ) ) ) );\n+                \"to\", \"direction\", \"out\" ) ) ) );\n         assertPaths( 2, nodes, 2, result );\n \n         // /path\n-        Map<String, Object> path = serialize( actions.findSinglePath( nodes[0], nodes[1],\n+        Map<String, Object> path = serialize( actions.findSinglePath( nodes[ 0 ], nodes[ 1 ],\n                 MapUtil.map( \"max depth\", 2, \"algorithm\", \"shortestPath\", \"relationships\",\n                         MapUtil.map( \"type\", \"to\", \"direction\", \"out\" ) ) ) );\n         assertPaths( 1, nodes, 2, Arrays.<Object>asList( path ) );\n \n         // /path {single: false} (has no effect)\n-        path = serialize( actions.findSinglePath( nodes[0], nodes[1], MapUtil.map( \"max depth\", 2,\n+        path = serialize( actions.findSinglePath( nodes[ 0 ], nodes[ 1 ], MapUtil.map( \"max depth\", 2,\n                 \"algorithm\", \"shortestPath\", \"relationships\", MapUtil.map( \"type\", \"to\",\n-                        \"direction\", \"out\" ), \"single\", false ) ) );\n+                \"direction\", \"out\" ), \"single\", false ) ) );\n         assertPaths( 1, nodes, 2, Arrays.<Object>asList( path ) );\n     }\n \n-    @Test(expected = NotFoundException.class)\n+    @Test( expected = NotFoundException.class )\n     public void shouldHandleNoFoundPathsCorrectly()\n     {\n         long[] nodes = createMoreComplexGraph();\n-        serialize( actions.findSinglePath( nodes[0], nodes[1], MapUtil.map( \"max depth\", 2,\n+        serialize( actions.findSinglePath( nodes[ 0 ], nodes[ 1 ], MapUtil.map( \"max depth\", 2,\n                 \"algorithm\", \"shortestPath\", \"relationships\", MapUtil.map( \"type\", \"to\",\n-                        \"direction\", \"in\" ), \"single\", false ) ) );\n+                \"direction\", \"in\" ), \"single\", false ) ) );\n     }\n \n     private void assertPaths( int numPaths, long[] nodes, int length, List<Object> result )\n     {\n-        assertEquals(numPaths, result.size());\n+        assertEquals( numPaths, result.size() );\n         for ( Object path : result )\n         {\n-            Map<String, Object> serialized = (Map<String, Object>) path;\n-            assertTrue(serialized.get(\"start\").toString().endsWith(\"/\" + nodes[0]));\n-            assertTrue(serialized.get(\"end\").toString().endsWith(\"/\" + nodes[1]));\n-            assertEquals(length, serialized.get(\"length\"));\n+            Map<String, Object> serialized = (Map<String, Object>)path;\n+            assertTrue( serialized.get( \"start\" ).toString().endsWith( \"/\" + nodes[ 0 ] ) );\n+            assertTrue( serialized.get( \"end\" ).toString().endsWith( \"/\" + nodes[ 1 ] ) );\n+            assertEquals( length, serialized.get( \"length\" ) );\n         }\n     }\n }",
      "parent_sha": "a0ba581c61a1c644033123ff007f92fa88240912"
    }
  },
  {
    "oid": "64397824f78114baea5ab70ef6efac389e5ef124",
    "message": "Handle more transient errors in IdReusabilityStressTesting stress test",
    "date": "2017-08-14T17:31:03Z",
    "url": "https://github.com/neo4j/neo4j/commit/64397824f78114baea5ab70ef6efac389e5ef124",
    "details": {
      "sha": "9a208ebf6e4dab8b25cbefb7fc749b971ab8319f",
      "filename": "stresstests/src/test/java/org/neo4j/causalclustering/stresstests/IdReusabilityStressTesting.java",
      "status": "modified",
      "additions": 18,
      "deletions": 9,
      "changes": 27,
      "blob_url": "https://github.com/neo4j/neo4j/blob/64397824f78114baea5ab70ef6efac389e5ef124/stresstests%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fcausalclustering%2Fstresstests%2FIdReusabilityStressTesting.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/64397824f78114baea5ab70ef6efac389e5ef124/stresstests%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fcausalclustering%2Fstresstests%2FIdReusabilityStressTesting.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/stresstests%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fcausalclustering%2Fstresstests%2FIdReusabilityStressTesting.java?ref=64397824f78114baea5ab70ef6efac389e5ef124",
      "patch": "@@ -47,13 +47,15 @@\n import org.neo4j.graphdb.Relationship;\n import org.neo4j.graphdb.RelationshipType;\n import org.neo4j.graphdb.TransactionFailureException;\n+import org.neo4j.graphdb.security.WriteOperationsNotAllowedException;\n import org.neo4j.helper.RepeatUntilCallable;\n import org.neo4j.helpers.collection.Iterables;\n import org.neo4j.io.fs.DefaultFileSystemAbstraction;\n import org.neo4j.io.fs.FileUtils;\n import org.neo4j.kernel.impl.store.MetaDataStore;\n import org.neo4j.kernel.impl.store.format.standard.Standard;\n import org.neo4j.kernel.impl.store.id.IdContainer;\n+import org.neo4j.storageengine.api.lock.AcquireLockTimeoutException;\n import org.neo4j.test.causalclustering.ClusterRule;\n import org.neo4j.test.rule.fs.DefaultFileSystemRule;\n \n@@ -180,16 +182,23 @@ private void createInitialData( Cluster cluster ) throws Exception\n     {\n         for ( int i = 0; i < 1_000; i++ )\n         {\n-            cluster.coreTx( ( db, tx ) ->\n+            try\n             {\n-                for ( int j = 0; j < 1_000; j++ )\n+                cluster.coreTx( ( db, tx ) ->\n                 {\n-                    Node start = db.createNode();\n-                    Node end = db.createNode();\n-                    start.createRelationshipTo( end, RELATIONSHIP_TYPE );\n-                }\n-                tx.success();\n-            } );\n+                    for ( int j = 0; j < 1_000; j++ )\n+                    {\n+                        Node start = db.createNode();\n+                        Node end = db.createNode();\n+                        start.createRelationshipTo( end, RELATIONSHIP_TYPE );\n+                    }\n+                    tx.success();\n+                } );\n+            }\n+            catch ( WriteOperationsNotAllowedException e )\n+            {\n+                // skip\n+            }\n         }\n     }\n \n@@ -201,7 +210,7 @@ private static boolean isTransient( Throwable e )\n         }\n \n         if ( e instanceof  TimeoutException || e instanceof DatabaseShutdownException ||\n-                e instanceof TransactionFailureException )\n+                e instanceof TransactionFailureException || e instanceof AcquireLockTimeoutException )\n         {\n             return true;\n         }",
      "parent_sha": "d619578e642f221aaa4d2788a06084094917278c"
    }
  },
  {
    "oid": "828a0bf3159d05e2232fb64031f76a0d5dd320a5",
    "message": "JavaDoc error fixed\n\ngit-svn-id: https://svn.neo4j.org/components/graph-algo/trunk@5654 0b971d98-bb2f-0410-8247-b05b2b5feb2a",
    "date": "2010-09-15T07:59:43Z",
    "url": "https://github.com/neo4j/neo4j/commit/828a0bf3159d05e2232fb64031f76a0d5dd320a5",
    "details": {
      "sha": "6045615c74b4bb346ed2182145d76c1d31ac5c34",
      "filename": "community/src/main/java/org/neo4j/graphalgo/impl/shortestpath/Dijkstra.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/neo4j/neo4j/blob/828a0bf3159d05e2232fb64031f76a0d5dd320a5/community%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fgraphalgo%2Fimpl%2Fshortestpath%2FDijkstra.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/828a0bf3159d05e2232fb64031f76a0d5dd320a5/community%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fgraphalgo%2Fimpl%2Fshortestpath%2FDijkstra.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fgraphalgo%2Fimpl%2Fshortestpath%2FDijkstra.java?ref=828a0bf3159d05e2232fb64031f76a0d5dd320a5",
      "patch": "@@ -130,7 +130,7 @@ public void reset()\n      * @param startCost Starting cost for both the start node and the end node\n      * @param startNode the start node\n      * @param endNode the end node\n-     * @param costRelationType the relationship that should be included in the\n+     * @param costRelationTypes the relationship that should be included in the\n      *            path\n      * @param relationDirection relationship direction to follow\n      * @param costEvaluator the cost function per relationship",
      "parent_sha": "101ce62b8ce5780e66c26544039e7553b4ebfb2d"
    }
  },
  {
    "oid": "8e7a46b64f65458b299d5b40b6dfc641dc8a6bc7",
    "message": "Fix kill query tests",
    "date": "2018-08-21T20:18:57Z",
    "url": "https://github.com/neo4j/neo4j/commit/8e7a46b64f65458b299d5b40b6dfc641dc8a6bc7",
    "details": {
      "sha": "4e9ec13df374d5f208cdfbb4f619f32aac08abe6",
      "filename": "enterprise/security/src/test/java/org/neo4j/server/security/enterprise/auth/BuiltInProceduresInteractionTestBase.java",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/neo4j/neo4j/blob/8e7a46b64f65458b299d5b40b6dfc641dc8a6bc7/enterprise%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fserver%2Fsecurity%2Fenterprise%2Fauth%2FBuiltInProceduresInteractionTestBase.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/8e7a46b64f65458b299d5b40b6dfc641dc8a6bc7/enterprise%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fserver%2Fsecurity%2Fenterprise%2Fauth%2FBuiltInProceduresInteractionTestBase.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/enterprise%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fserver%2Fsecurity%2Fenterprise%2Fauth%2FBuiltInProceduresInteractionTestBase.java?ref=8e7a46b64f65458b299d5b40b6dfc641dc8a6bc7",
      "patch": "@@ -50,6 +50,7 @@\n \n import org.neo4j.graphdb.ResourceIterator;\n import org.neo4j.graphdb.factory.GraphDatabaseSettings;\n+import org.neo4j.helpers.collection.Iterators;\n import org.neo4j.kernel.api.KernelTransaction;\n import org.neo4j.kernel.enterprise.builtinprocs.QueryId;\n import org.neo4j.kernel.impl.coreapi.InternalTransaction;\n@@ -530,8 +531,8 @@ public void queryWaitingForLocksShouldBeKilledBeforeLocksAreReleased() throws Th\n                 \"CALL dbms.listQueries() YIELD query, queryId \" +\n                 \"WITH query, queryId WHERE query = '\" + query2 + \"'\" +\n                 \"CALL dbms.killQuery(queryId) YIELD queryId AS killedId \" +\n-                \"RETURN 1\",\n-                itr -> assertThat( itr.hasNext(), equalTo( true ) ) );\n+                        \"RETURN 1\",\n+                itr -> assertThat( Iterators.count( itr ), equalTo( 1L ) ) ); // consume iterator so resources are closed\n \n         tx2.closeAndAssertSomeTermination();\n \n@@ -595,9 +596,7 @@ public void shouldSelfKillQuery()\n                 \"WITH * WHERE query CONTAINS 'Hello' CALL dbms.killQuery(id) YIELD username \" +\n                 \"RETURN count(username) AS count, username\",\n                 emptyMap(),\n-                r ->\n-                {\n-                }\n+                Iterators::count // consume result to flush any errors\n         );\n \n         assertThat( result, containsString( \"Explicitly terminated by the user.\" ) );",
      "parent_sha": "ad4b3f4d2b231342ba3496d284ce5676a726b970"
    }
  },
  {
    "oid": "609b19ee3cf1808b3cb247048bb506d42ab59e76",
    "message": "Oops\n\ngit-svn-id: https://svn.neo4j.org/components/server/trunk@7874 0b971d98-bb2f-0410-8247-b05b2b5feb2a",
    "date": "2010-12-20T12:26:50Z",
    "url": "https://github.com/neo4j/neo4j/commit/609b19ee3cf1808b3cb247048bb506d42ab59e76",
    "details": {
      "sha": "1042e1c2d51922c192a68f9c7fd37641a1a69e2f",
      "filename": "advanced/src/main/java/org/neo4j/server/rest/repr/DefaultFormat.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/neo4j/neo4j/blob/609b19ee3cf1808b3cb247048bb506d42ab59e76/advanced%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fserver%2Frest%2Frepr%2FDefaultFormat.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/609b19ee3cf1808b3cb247048bb506d42ab59e76/advanced%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fserver%2Frest%2Frepr%2FDefaultFormat.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/advanced%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fserver%2Frest%2Frepr%2FDefaultFormat.java?ref=609b19ee3cf1808b3cb247048bb506d42ab59e76",
      "patch": "@@ -42,7 +42,7 @@ public class DefaultFormat extends RepresentationFormat\n     public DefaultFormat( RepresentationFormat inner,\n                           Collection<MediaType> supported, MediaType... requested )\n     {\n-        super( new MediaType( \"N/A\", \"N/A\" ) );\n+        super( MediaType.APPLICATION_JSON_TYPE );\n \n         this.inner = inner;\n         this.supported = supported;",
      "parent_sha": "83c8842f77698afdfca01038245741e1956da84f"
    }
  },
  {
    "oid": "ec59edd175678d927cd9856826aa15f4067f7bea",
    "message": "Avoid creating files in /tmp, there are issues with renaming these files.\n\n\ngit-svn-id: https://svn.neo4j.org/components/kernel/branches/ha@5649 0b971d98-bb2f-0410-8247-b05b2b5feb2a",
    "date": "2010-09-14T14:56:34Z",
    "url": "https://github.com/neo4j/neo4j/commit/ec59edd175678d927cd9856826aa15f4067f7bea",
    "details": {
      "sha": "ab83d4de5eb1e4254a89ac2c15b14523d7fe1778",
      "filename": "community/src/main/java/org/neo4j/kernel/impl/transaction/xaframework/XaLogicalLog.java",
      "status": "modified",
      "additions": 13,
      "deletions": 8,
      "changes": 21,
      "blob_url": "https://github.com/neo4j/neo4j/blob/ec59edd175678d927cd9856826aa15f4067f7bea/community%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Ftransaction%2Fxaframework%2FXaLogicalLog.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/ec59edd175678d927cd9856826aa15f4067f7bea/community%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Ftransaction%2Fxaframework%2FXaLogicalLog.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Ftransaction%2Fxaframework%2FXaLogicalLog.java?ref=ec59edd175678d927cd9856826aa15f4067f7bea",
      "patch": "@@ -999,12 +999,7 @@ private void assertLogCanContainTx( long txId, long prevTxId ) throws IOExceptio\n     public synchronized ReadableByteChannel getPreparedTransaction( int identifier )\n             throws IOException\n     {\n-        File writeOutDir = new File( storeDir, \"tmp-write-outs\" );\n-        if ( !writeOutDir.exists() )\n-        {\n-            writeOutDir.mkdir();\n-        }\n-        File txFile = File.createTempFile( \"temp-write-out-\", \"-\" + identifier , writeOutDir );\n+        File txFile = createTempFile( \"temp-write-out\", \"-\" + identifier );\n         FileChannel log = (FileChannel) getLogicalLogOrMyself( logVersion, 0 );\n         List<LogEntry> logEntryList = extractPreparedTransactionFromLog( identifier, log );\n         log.close();\n@@ -1016,7 +1011,7 @@ public synchronized ReadableByteChannel getPreparedTransaction( int identifier )\n     private void writeOutLogEntryList( List<LogEntry> logEntryList, File txFile, boolean tempWriteOutFirst ) throws IOException\n     {\n         int identifier = logEntryList.get( 0 ).getIdentifier();\n-        File tempFile = tempWriteOutFirst ? File.createTempFile( \"extracted-tx-\", \"-\" + identifier ) : txFile;\n+        File tempFile = tempWriteOutFirst ? createTempFile( \"extracted-tx-\", \"-\" + identifier ) : txFile;\n         msgLog.logMessage( \"write out log entry list to file:\" + tempFile );\n         FileChannel txLog = new RandomAccessFile( tempFile, \"rw\" ).getChannel();\n         LogBuffer buf = new DirectMappedLogBuffer( txLog );\n@@ -1035,6 +1030,16 @@ private void writeOutLogEntryList( List<LogEntry> logEntryList, File txFile, boo\n             }\n         }\n     }\n+\n+    private File createTempFile( String prefix, String suffix ) throws IOException\n+    {\n+        File writeOutDir = new File( storeDir, \"tmp-write-outs\" );\n+        if ( !writeOutDir.exists() )\n+        {\n+            writeOutDir.mkdir();\n+        }\n+        return File.createTempFile( prefix, suffix, writeOutDir );\n+    }\n     \n     private List<LogEntry> extractLogEntryList( long txId ) throws IOException\n     {\n@@ -1083,7 +1088,7 @@ public synchronized ReadableByteChannel getCommittedTransaction( long txId )\n         throws IOException\n     {\n         String name = fileName + \".tx_\" + txId;\n-        File txFile = new File( storeDir, name );\n+        File txFile = new File( name );\n         List<LogEntry> logEntryList = extractLogEntryList( txId );\n         writeOutLogEntryList( logEntryList, txFile, true );\n         ReadableByteChannel result = new RandomAccessFile( txFile, \"r\" ).getChannel();",
      "parent_sha": "c3bff2104fcfa9613021b977429cef8a6f419108"
    }
  },
  {
    "oid": "d106bed36ec12f5dcd84158a4fc6bdf52b23bb36",
    "message": "Use Eclipse Collections UnifiedSet when schema cache computes related indexes.",
    "date": "2019-11-28T11:05:55Z",
    "url": "https://github.com/neo4j/neo4j/commit/d106bed36ec12f5dcd84158a4fc6bdf52b23bb36",
    "details": {
      "sha": "f9e7fb74695fb60d1918a2bd9fab7f2ceaf58a69",
      "filename": "community/record-storage-engine/src/main/java/org/neo4j/internal/recordstorage/SchemaCache.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/neo4j/neo4j/blob/d106bed36ec12f5dcd84158a4fc6bdf52b23bb36/community%2Frecord-storage-engine%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Finternal%2Frecordstorage%2FSchemaCache.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/d106bed36ec12f5dcd84158a4fc6bdf52b23bb36/community%2Frecord-storage-engine%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Finternal%2Frecordstorage%2FSchemaCache.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Frecord-storage-engine%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Finternal%2Frecordstorage%2FSchemaCache.java?ref=d106bed36ec12f5dcd84158a4fc6bdf52b23bb36",
      "patch": "@@ -21,6 +21,7 @@\n \n import org.eclipse.collections.api.map.primitive.MutableLongObjectMap;\n import org.eclipse.collections.impl.map.mutable.primitive.LongObjectHashMap;\n+import org.eclipse.collections.impl.set.mutable.UnifiedSet;\n \n import java.util.Collection;\n import java.util.Collections;\n@@ -384,7 +385,7 @@ <T extends SchemaDescriptorSupplier> Set<T> getSchemaRelatedTo( SchemaDescriptor\n                 return Collections.emptySet();\n             }\n \n-            Set<T> descriptors = new HashSet<>();\n+            Set<T> descriptors = UnifiedSet.newSet();\n             if ( propertyListIsComplete )\n             {\n                 set.matchingDescriptorsForCompleteListOfProperties( descriptors, changedEntityTokens, properties );",
      "parent_sha": "258aeda474b06fc2824136a7c9f49bb5ee91683e"
    }
  },
  {
    "oid": "14a8505fb3bd27d2024d4fb611ee6f9807b486b2",
    "message": "Fix typo: persisNodeLabelIndex -> persistNodeLabelIndex",
    "date": "2022-03-17T14:42:33Z",
    "url": "https://github.com/neo4j/neo4j/commit/14a8505fb3bd27d2024d4fb611ee6f9807b486b2",
    "details": {
      "sha": "e2f1093326f29a21808d8b63eab1cf6ac23ef8fe",
      "filename": "community/record-storage-engine/src/main/java/org/neo4j/kernel/impl/storemigration/RecordStorageMigrator.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/neo4j/neo4j/blob/14a8505fb3bd27d2024d4fb611ee6f9807b486b2/community%2Frecord-storage-engine%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fstoremigration%2FRecordStorageMigrator.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/14a8505fb3bd27d2024d4fb611ee6f9807b486b2/community%2Frecord-storage-engine%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fstoremigration%2FRecordStorageMigrator.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Frecord-storage-engine%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fstoremigration%2FRecordStorageMigrator.java?ref=14a8505fb3bd27d2024d4fb611ee6f9807b486b2",
      "patch": "@@ -291,7 +291,7 @@ public void migrate( DatabaseLayout directoryLayoutArg, DatabaseLayout migration\n                     var dstTokensHolders = createTokenHolders( dstStore, dstCursors );\n                     try ( var schemaStore44Reader = getSchemaStore44Reader( migrationLayout, oldFormat, idGeneratorFactory, dstStore, dstTokensHolders ) )\n                     {\n-                        persisNodeLabelIndex( dstAccess );\n+                        persistNodeLabelIndex( dstAccess );\n                         filterOurBtreeIndexes( schemaStore44Reader, dstCursors, dstAccess, dstTokensHolders,\n                                                directoryLayoutArg.getDatabaseName().equals( SYSTEM_DATABASE_NAME ) );\n                     }\n@@ -321,7 +321,7 @@ private long getValueOrDefault( MetaDataStore oldMetadataStore, int id, MetaData\n      *    {@link IndexDescriptor#INJECTED_NLI} will be injected by {@link org.neo4j.internal.recordstorage.SchemaStorage}\n      *    when reading schema rules. In this case we materialise this injected rule with a new real id (instead of -2).\n      */\n-    private static void persisNodeLabelIndex( SchemaRuleMigrationAccess dstAccess ) throws KernelException\n+    private static void persistNodeLabelIndex( SchemaRuleMigrationAccess dstAccess ) throws KernelException\n     {\n         SchemaRule foundNLIThatNeedsUpdate = null;\n         Iterable<SchemaRule> all = dstAccess.getAll();",
      "parent_sha": "dc4cce57e3752b790c389a963d90e984fcb715bd"
    }
  },
  {
    "oid": "d1cade2f22afc78de9fd5f1c2952e5da2d8216da",
    "message": "Update test to junit 5.\nTest setting restriction.",
    "date": "2018-09-13T15:25:24Z",
    "url": "https://github.com/neo4j/neo4j/commit/d1cade2f22afc78de9fd5f1c2952e5da2d8216da",
    "details": {
      "sha": "98ccbe551ff769736cdcd29db881409a38662a13",
      "filename": "community/kernel/src/test/java/org/neo4j/kernel/configuration/SettingsTest.java",
      "status": "modified",
      "additions": 61,
      "deletions": 77,
      "changes": 138,
      "blob_url": "https://github.com/neo4j/neo4j/blob/d1cade2f22afc78de9fd5f1c2952e5da2d8216da/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fconfiguration%2FSettingsTest.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/d1cade2f22afc78de9fd5f1c2952e5da2d8216da/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fconfiguration%2FSettingsTest.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fconfiguration%2FSettingsTest.java?ref=d1cade2f22afc78de9fd5f1c2952e5da2d8216da",
      "patch": "@@ -19,9 +19,7 @@\n  */\n package org.neo4j.kernel.configuration;\n \n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n+import org.junit.jupiter.api.Test;\n \n import java.io.File;\n import java.net.URI;\n@@ -37,14 +35,15 @@\n import org.neo4j.graphdb.config.Setting;\n import org.neo4j.graphdb.factory.GraphDatabaseSettings;\n \n+import static org.apache.commons.lang3.StringUtils.EMPTY;\n import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsString;\n import static org.hamcrest.Matchers.greaterThan;\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.nullValue;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertThat;\n-import static org.junit.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.neo4j.helpers.collection.MapUtil.stringMap;\n import static org.neo4j.kernel.configuration.Settings.DURATION;\n import static org.neo4j.kernel.configuration.Settings.INTEGER;\n@@ -54,6 +53,7 @@\n import static org.neo4j.kernel.configuration.Settings.STRING;\n import static org.neo4j.kernel.configuration.Settings.STRING_LIST;\n import static org.neo4j.kernel.configuration.Settings.buildSetting;\n+import static org.neo4j.kernel.configuration.Settings.except;\n import static org.neo4j.kernel.configuration.Settings.list;\n import static org.neo4j.kernel.configuration.Settings.matches;\n import static org.neo4j.kernel.configuration.Settings.max;\n@@ -62,13 +62,10 @@\n import static org.neo4j.kernel.configuration.Settings.range;\n import static org.neo4j.kernel.configuration.Settings.setting;\n \n-public class SettingsTest\n+class SettingsTest\n {\n-    @Rule\n-    public ExpectedException expect = ExpectedException.none();\n-\n     @Test\n-    public void parsesAbsolutePaths()\n+    void parsesAbsolutePaths()\n     {\n         File absolutePath = new File( \"some/path\" ).getAbsoluteFile();\n         File thePath = Settings.PATH.apply( absolutePath.toString() );\n@@ -77,50 +74,48 @@ public void parsesAbsolutePaths()\n     }\n \n     @Test\n-    public void doesntAllowRelativePaths()\n+    void doesntAllowRelativePaths()\n     {\n         File relativePath = new File( \"some/path\" );\n \n-        expect.expect( IllegalArgumentException.class );\n-        Settings.PATH.apply( relativePath.toString() );\n+        assertThrows( IllegalArgumentException.class, () -> Settings.PATH.apply( relativePath.toString() ) );\n     }\n \n     @Test\n-    public void pathSettingsProvideDefaultValues()\n+    void pathSettingsProvideDefaultValues()\n     {\n         File theDefault = new File( \"/some/path\" ).getAbsoluteFile();\n         Setting<File> setting = pathSetting( \"some.setting\", theDefault.getAbsolutePath() );\n         assertThat( Config.defaults().get( setting ), is( theDefault ) );\n     }\n \n     @Test\n-    public void pathSettingsAreNullIfThereIsNoValueAndNoDefault()\n+    void pathSettingsAreNullIfThereIsNoValueAndNoDefault()\n     {\n         Setting<File> setting = pathSetting( \"some.setting\", NO_DEFAULT );\n         assertThat( Config.defaults().get( setting ), is( nullValue() ) );\n     }\n \n     @Test\n-    public void shouldHaveAUsefulToStringWhichIsUsedAsTheValidValuesInDocumentation()\n+    void shouldHaveAUsefulToStringWhichIsUsedAsTheValidValuesInDocumentation()\n     {\n-        assertThat( pathSetting( \"\", NO_DEFAULT ).toString(), containsString( \"A filesystem path\" ) );\n+        assertThat( pathSetting( EMPTY, NO_DEFAULT ).toString(), containsString( \"A filesystem path\" ) );\n     }\n \n     @Test\n-    public void testInteger()\n+    void testInteger()\n     {\n         Setting<Integer> setting = setting( \"foo\", INTEGER, \"3\" );\n \n         // Ok\n         assertThat( setting.apply( map( stringMap( \"foo\", \"4\" ) ) ), equalTo( 4 ) );\n \n         // Bad\n-        expect.expect( InvalidSettingException.class );\n-        setting.apply( map( stringMap( \"foo\", \"bar\" ) ) );\n+        assertThrows( InvalidSettingException.class, () -> setting.apply( map( stringMap( \"foo\", \"bar\" ) ) ) );\n     }\n \n     @Test\n-    public void testList()\n+    void testList()\n     {\n         Setting<List<Integer>> setting = setting( \"foo\", list( \",\", INTEGER ), \"1,2,3,4\" );\n         assertThat( setting.apply( map( stringMap() ) ).toString(), equalTo( \"[1, 2, 3, 4]\" ) );\n@@ -139,7 +134,7 @@ public void testList()\n     }\n \n     @Test\n-    public void testStringList()\n+    void testStringList()\n     {\n         Setting<List<String>> setting1 = setting( \"apa\", STRING_LIST, \"foo,bar,baz\" );\n         assertEquals( Arrays.asList( \"foo\", \"bar\", \"baz\" ), setting1.apply( map( stringMap() ) ) );\n@@ -152,118 +147,108 @@ public void testStringList()\n     }\n \n     @Test\n-    public void testMin()\n+    void testMin()\n     {\n         Setting<Integer> setting = buildSetting( \"foo\", INTEGER, \"3\" ).constraint( min( 2 ) ).build();\n \n         // Ok\n         assertThat( setting.apply( map( stringMap( \"foo\", \"4\" ) ) ), equalTo( 4 ) );\n \n         // Bad\n-        expect.expect( InvalidSettingException.class );\n-        setting.apply( map( stringMap( \"foo\", \"1\" ) ) );\n+        assertThrows( InvalidSettingException.class, () -> setting.apply( map( stringMap( \"foo\", \"1\" ) ) ) );\n     }\n \n     @Test\n-    public void testMax()\n+    void exceptDoesNoAllowForbiddenValues()\n+    {\n+        Setting<String> restrictedSetting = buildSetting( \"foo\", STRING, \"test\" ).constraint( except( \"a\", \"b\", \"c\" ) ).build();\n+        assertEquals( \"test\", restrictedSetting.apply( map( stringMap() ) ) );\n+        assertEquals( \"d\", restrictedSetting.apply( map( stringMap( \"foo\", \"d\" ) ) ) );\n+        assertThrows( InvalidSettingException.class, () -> restrictedSetting.apply( map( stringMap( \"foo\", \"a\" ) ) ) );\n+        assertThrows( InvalidSettingException.class, () -> restrictedSetting.apply( map( stringMap( \"foo\", \"b\" ) ) ) );\n+        InvalidSettingException exception =\n+                assertThrows( InvalidSettingException.class, () -> restrictedSetting.apply( map( stringMap( \"foo\", \"c\" ) ) ) );\n+        assertThat( exception.getMessage(), containsString( \"not allowed value is: c\" ) );\n+    }\n+\n+    @Test\n+    void testMax()\n     {\n         Setting<Integer> setting = buildSetting( \"foo\", INTEGER, \"3\" ).constraint( max( 5 ) ).build();\n \n         // Ok\n         assertThat( setting.apply( map( stringMap( \"foo\", \"4\" ) ) ), equalTo( 4 ) );\n \n         // Bad\n-        expect.expect( InvalidSettingException.class );\n-        setting.apply( map( stringMap( \"foo\", \"7\" ) ) );\n+        assertThrows( InvalidSettingException.class, () -> setting.apply( map( stringMap( \"foo\", \"7\" ) ) ) );\n     }\n \n     @Test\n-    public void testRange()\n+    void testRange()\n     {\n         Setting<Integer> setting = buildSetting( \"foo\", INTEGER, \"3\" ).constraint( range( 2, 5 ) ).build();\n \n         // Ok\n         assertThat( setting.apply( map( stringMap( \"foo\", \"4\" ) ) ), equalTo( 4 ) );\n \n         // Bad\n-        try\n-        {\n-            setting.apply( map( stringMap( \"foo\", \"1\" ) ) );\n-            fail();\n-        }\n-        catch ( InvalidSettingException e )\n-        {\n-            // Ok\n-        }\n-\n-        try\n-        {\n-            setting.apply( map( stringMap( \"foo\", \"6\" ) ) );\n-            fail();\n-        }\n-        catch ( InvalidSettingException e )\n-        {\n-            // Ok\n-        }\n+        assertThrows( InvalidSettingException.class, () -> setting.apply( map( stringMap( \"foo\", \"1\" ) ) ) );\n+        assertThrows( InvalidSettingException.class, () -> setting.apply( map( stringMap( \"foo\", \"6\" ) ) ) );\n     }\n \n     @Test\n-    public void testMatches()\n+    void testMatches()\n     {\n         Setting<String> setting = buildSetting( \"foo\", STRING, \"abc\" ).constraint(  matches( \"a*b*c*\" ) ).build();\n \n         // Ok\n         assertThat( setting.apply( map( stringMap( \"foo\", \"aaabbbccc\" ) ) ), equalTo( \"aaabbbccc\" ) );\n \n         // Bad\n-        expect.expect( InvalidSettingException.class );\n-        setting.apply( map( stringMap( \"foo\", \"cba\" ) ) );\n+        assertThrows( InvalidSettingException.class, () -> setting.apply( map( stringMap( \"foo\", \"cba\" ) ) ) );\n     }\n \n     @Test\n-    public void testDurationWithBrokenDefault()\n+    void testDurationWithBrokenDefault()\n     {\n         // Notice that the default value is less that the minimum\n         Setting<Duration> setting = buildSetting( \"foo.bar\", DURATION, \"1s\" ).constraint( min( DURATION.apply( \"3s\" ) ) ).build();\n-        expect.expect( InvalidSettingException.class );\n-        setting.apply( map( stringMap() ) );\n+        assertThrows( InvalidSettingException.class, () -> setting.apply( map( stringMap() ) ) );\n     }\n \n     @Test\n-    public void testDurationWithValueNotWithinConstraint()\n+    void testDurationWithValueNotWithinConstraint()\n     {\n         Setting<Duration> setting = buildSetting( \"foo.bar\", DURATION, \"3s\" ).constraint( min( DURATION.apply( \"3s\" ) ) ).build();\n-        expect.expect( InvalidSettingException.class );\n-        setting.apply( map( stringMap( \"foo.bar\", \"2s\" ) ) );\n+        assertThrows( InvalidSettingException.class, () -> setting.apply( map( stringMap( \"foo.bar\", \"2s\" ) ) ) );\n     }\n \n     @Test\n-    public void testDuration()\n+    void testDuration()\n     {\n         Setting<Duration> setting = buildSetting( \"foo.bar\", DURATION, \"3s\").constraint( min( DURATION.apply( \"3s\" ) ) ).build();\n         assertThat( setting.apply( map( stringMap( \"foo.bar\", \"4s\" ) ) ), equalTo( Duration.ofSeconds( 4 ) ) );\n     }\n \n     @Test\n-    public void badDurationMissingNumber()\n+    void badDurationMissingNumber()\n     {\n         Setting<Duration> setting = buildSetting( \"foo.bar\", DURATION ).build();\n-        expect.expect( InvalidSettingException.class );\n-        expect.expectMessage( \"Missing numeric value\" );\n-        setting.apply( map( stringMap( \"foo.bar\", \"ms\" ) ) );\n+        InvalidSettingException exception = assertThrows( InvalidSettingException.class, () -> setting.apply( map( stringMap( \"foo.bar\", \"ms\" ) ) ) );\n+        assertThat( exception.getMessage(), containsString( \"Missing numeric value\" ) );\n     }\n \n     @Test\n-    public void badDurationInvalidUnit()\n+    void badDurationInvalidUnit()\n     {\n         Setting<Duration> setting = buildSetting( \"foo.bar\", DURATION ).build();\n-        expect.expect( InvalidSettingException.class );\n-        expect.expectMessage( \"Unrecognized unit 'gigaseconds'\" );\n-        setting.apply( map( stringMap( \"foo.bar\", \"2gigaseconds\" ) ) );\n+        InvalidSettingException exception =\n+                assertThrows( InvalidSettingException.class, () -> setting.apply( map( stringMap( \"foo.bar\", \"2gigaseconds\" ) ) ) );\n+        assertThat( exception.getMessage(), containsString( \"Unrecognized unit 'gigaseconds'\" ) );\n     }\n \n     @Test\n-    public void testDefault()\n+    void testDefault()\n     {\n         Setting<Integer> setting = setting( \"foo\", INTEGER, \"3\" );\n \n@@ -272,7 +257,7 @@ public void testDefault()\n     }\n \n     @Test\n-    public void testPaths()\n+    void testPaths()\n     {\n         File directory = new File( \"myDirectory\" );\n         Setting<File> config = buildSetting( \"config\", PATH, new File( directory, \"config.properties\" ).getAbsolutePath() ).constraint(\n@@ -282,7 +267,7 @@ public void testPaths()\n     }\n \n     @Test\n-    public void testInheritOneLevel()\n+    void testInheritOneLevel()\n     {\n         Setting<Integer> root = setting( \"root\", INTEGER, \"4\" );\n         Setting<Integer> setting = buildSetting( \"foo\", INTEGER ).inherits( root ).build();\n@@ -293,7 +278,7 @@ public void testInheritOneLevel()\n     }\n \n     @Test\n-    public void testInheritHierarchy()\n+    void testInheritHierarchy()\n     {\n         // Test hierarchies\n         Setting<String> a = setting( \"A\", STRING, \"A\" ); // A defaults to A\n@@ -312,7 +297,7 @@ public void testInheritHierarchy()\n     }\n \n     @Test\n-    public void testLogicalLogRotationThreshold()\n+    void testLogicalLogRotationThreshold()\n     {\n         // WHEN\n         Setting<Long> setting = GraphDatabaseSettings.logical_log_rotation_threshold;\n@@ -327,7 +312,7 @@ public void testLogicalLogRotationThreshold()\n     }\n \n     @Test\n-    public void testNormalizedRelativeURI()\n+    void testNormalizedRelativeURI()\n     {\n         // Given\n         Setting<URI> uri = setting( \"mySetting\", NORMALIZED_RELATIVE_URI, \"http://localhost:7474///db///data///\" );\n@@ -337,15 +322,14 @@ public void testNormalizedRelativeURI()\n     }\n \n     @Test\n-    public void onlySingleInheritanceShouldBeAllowed()\n+    void onlySingleInheritanceShouldBeAllowed()\n     {\n         Setting<String> a = setting( \"A\", STRING, \"A\" );\n         Setting<String> b = setting( \"B\", STRING, \"B\" );\n-        expect.expect( AssertionError.class );\n-        Setting<String> c = buildSetting( \"C\", STRING, \"C\" ).inherits( a ).inherits( b ).build();\n+        assertThrows( AssertionError.class, () -> buildSetting( \"C\", STRING, \"C\" ).inherits( a ).inherits( b ).build() );\n     }\n \n-    public static <From, To> Function<From,To> map( final Map<From,To> map )\n+    private static <From, To> Function<From,To> map( final Map<From,To> map )\n     {\n         return map::get;\n     }",
      "parent_sha": "21f9604c017be1a307c9d401a0067a7df6bb4c63"
    }
  },
  {
    "oid": "c0a8d0d3f7e9ac20142e822ba6022970812a4068",
    "message": "Move the procedure cache into the StoreLayerModule\n\nIt had nothing to do with the other cache stuff in the CacheModule.\nIt should probably be encapsulated as a store, and the fact that it's currently just a \"cache\" should be made transparent.\nBut that's for later.",
    "date": "2015-11-16T11:01:51Z",
    "url": "https://github.com/neo4j/neo4j/commit/c0a8d0d3f7e9ac20142e822ba6022970812a4068",
    "details": {
      "sha": "409004c936279de85154701c4661a145dfcad89d",
      "filename": "community/kernel/src/main/java/org/neo4j/kernel/NeoStoreDataSource.java",
      "status": "modified",
      "additions": 15,
      "deletions": 32,
      "changes": 47,
      "blob_url": "https://github.com/neo4j/neo4j/blob/c0a8d0d3f7e9ac20142e822ba6022970812a4068/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2FNeoStoreDataSource.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/c0a8d0d3f7e9ac20142e822ba6022970812a4068/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2FNeoStoreDataSource.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2FNeoStoreDataSource.java?ref=c0a8d0d3f7e9ac20142e822ba6022970812a4068",
      "patch": "@@ -189,8 +189,6 @@ public class NeoStoreDataSource implements NeoStoresSupplier, Lifecycle, IndexPr\n     private interface CacheModule\n     {\n         UpdateableSchemaState updateableSchemaState();\n-\n-        ProcedureCache procedureCache();\n     }\n \n     private interface StoreLayerModule\n@@ -207,6 +205,7 @@ private interface StoreLayerModule\n         IntegrityValidator integrityValidator();\n         SchemaIndexProviderMap schemaIndexProviderMap();\n         CacheAccessBackDoor cacheAccess();\n+        ProcedureCache procedureCache();\n \n         void loadSchemaCache();\n     }\n@@ -511,12 +510,11 @@ public void start() throws IOException\n             LegacyIndexApplierLookup legacyIndexApplierLookup =\n                     dependencies.satisfyDependency( new LegacyIndexApplierLookup.Direct( legacyIndexProviderLookup ) );\n \n-            CacheModule cacheModule = buildCaches(\n-                    labelTokens, relationshipTypeTokens, propertyKeyTokenHolder );\n+            CacheModule cacheModule = buildCaches();\n \n             // TODO Introduce a StorageEngine abstraction at the StoreLayerModule boundary\n             storeLayerModule = buildStoreLayer(\n-                    propertyKeyTokenHolder, labelTokens, relationshipTypeTokens, cacheModule,\n+                    propertyKeyTokenHolder, labelTokens, relationshipTypeTokens,\n                     cacheModule.updateableSchemaState()::clear );\n \n             TransactionLogModule transactionLogModule =\n@@ -536,7 +534,7 @@ public void start() throws IOException\n                     storeLayerModule.indexUpdatesValidator(),\n                     storeLayerModule.storeLayer(),\n                     cacheModule.updateableSchemaState(), storeLayerModule.labelScanStore(),\n-                    storeLayerModule.schemaIndexProviderMap(), cacheModule.procedureCache() );\n+                    storeLayerModule.schemaIndexProviderMap(), storeLayerModule.procedureCache() );\n \n \n             // Do these assignments last so that we can ensure no cyclical dependencies exist\n@@ -611,35 +609,12 @@ private void upgradeStore( File storeDir, StoreUpgrader storeMigrationProcess, S\n         storeMigrationProcess.migrateIfNeeded( storeDir, upgradableDatabase, indexProvider );\n     }\n \n-    private CacheModule buildCaches( LabelTokenHolder labelTokens, RelationshipTypeTokenHolder relationshipTypeTokens,\n-            PropertyKeyTokenHolder propertyKeyTokenHolder )\n+    private CacheModule buildCaches()\n     {\n         final UpdateableSchemaState updateableSchemaState = new KernelSchemaStateStore( logProvider );\n \n-        final ProcedureCache procedureCache = new ProcedureCache();\n-\n-        life.add( new LifecycleAdapter()\n-        {\n-            @Override\n-            public void start() throws Throwable\n-            {\n-                storeLayerModule.loadSchemaCache();\n-            }\n-\n-            @Override\n-            public void stop() throws Throwable\n-            {\n-            }\n-        } );\n-\n         return new CacheModule()\n         {\n-            @Override\n-            public ProcedureCache procedureCache()\n-            {\n-                return procedureCache;\n-            }\n-\n             @Override\n             public UpdateableSchemaState updateableSchemaState()\n             {\n@@ -651,7 +626,7 @@ public UpdateableSchemaState updateableSchemaState()\n     private StoreLayerModule buildStoreLayer(\n             PropertyKeyTokenHolder propertyKeyTokenHolder, LabelTokenHolder labelTokens,\n             RelationshipTypeTokenHolder relationshipTypeTokens,\n-            CacheModule cacheModule, Runnable schemaStateChangeCallback )\n+            Runnable schemaStateChangeCallback )\n     {\n         life.add( new LifecycleAdapter()\n         {\n@@ -668,6 +643,7 @@ public void start() throws IOException\n                         storeLayerModule.neoStores().getLabelTokenStore().getTokens( Integer.MAX_VALUE ) );\n \n                 storeLayerModule.neoStores().rebuildCountStoreIfNeeded(); // TODO: move this to counts store lifecycle\n+                storeLayerModule.loadSchemaCache();\n             }\n         } );\n \n@@ -682,6 +658,7 @@ public void start() throws IOException\n         final SchemaCache schemaCache;\n         final CacheAccessBackDoor cacheAccess;\n         final StoreReadLayer storeLayer;\n+        final ProcedureCache procedureCache;\n \n         try\n         {\n@@ -709,7 +686,7 @@ public void start() throws IOException\n             schemaCache = new SchemaCache( constraintSemantics, Collections.<SchemaRule>emptyList() );\n             cacheAccess = new BridgingCacheAccess( schemaCache, schemaStateChangeCallback,\n                     propertyKeyTokenHolder, relationshipTypeTokens, labelTokens );\n-            ProcedureCache procedureCache = cacheModule.procedureCache();\n+            procedureCache = new ProcedureCache();\n             SchemaStorage schemaStorage = new SchemaStorage( neoStores.getSchemaStore() );\n             DiskLayer diskLayer = new DiskLayer( propertyKeyTokenHolder, labelTokens, relationshipTypeTokens, schemaStorage,\n                     neoStores, indexingService, storeStatementFactory( neoStores ) );\n@@ -777,6 +754,12 @@ public CacheAccessBackDoor cacheAccess()\n                 return cacheAccess;\n             }\n \n+            @Override\n+            public ProcedureCache procedureCache()\n+            {\n+                return procedureCache;\n+            }\n+\n             @Override\n             public void loadSchemaCache()\n             {",
      "parent_sha": "6fbfb67235afe40c4e6c586cead72a0d49c303d7"
    }
  },
  {
    "oid": "3e7de298ff1bd869532017980e87dcb88777e27c",
    "message": "Fixed a typo and -v doesn't override -p or -r\n\n\ngit-svn-id: https://svn.neo4j.org/components/neo/trunk@1050 0b971d98-bb2f-0410-8247-b05b2b5feb2a",
    "date": "2008-04-09T07:56:39Z",
    "url": "https://github.com/neo4j/neo4j/commit/3e7de298ff1bd869532017980e87dcb88777e27c",
    "details": {
      "sha": "c2c31f83f00780b45afeb59022f251569f43b2c3",
      "filename": "advanced/src/java/org/neo4j/impl/shell/apps/Ls.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/neo4j/neo4j/blob/3e7de298ff1bd869532017980e87dcb88777e27c/advanced%2Fsrc%2Fjava%2Forg%2Fneo4j%2Fimpl%2Fshell%2Fapps%2FLs.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/3e7de298ff1bd869532017980e87dcb88777e27c/advanced%2Fsrc%2Fjava%2Forg%2Fneo4j%2Fimpl%2Fshell%2Fapps%2FLs.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/advanced%2Fsrc%2Fjava%2Forg%2Fneo4j%2Fimpl%2Fshell%2Fapps%2FLs.java?ref=3e7de298ff1bd869532017980e87dcb88777e27c",
      "patch": "@@ -54,7 +54,7 @@ public Ls()\n \t\tthis.addValueType( \"f\", new OptionContext( OptionValueType.MUST,\n \t\t\t\"Filters property keys/relationship types (regexp string)\" ) );\n \t\tthis.addValueType( \"e\", new OptionContext( OptionValueType.MUST,\n-\t\t\t\"Temporarily select a connected relationship to do the\" +\n+\t\t\t\"Temporarily select a connected relationship to do the \" +\n \t\t\t\"operation on\" ) );\n \t}\n \t\n@@ -72,9 +72,9 @@ protected String exec( AppCommandParser parser, Session session,\n \t\tboolean verbose = parser.options().containsKey( \"v\" );\n \t\tboolean displayValues = verbose || !parser.options().containsKey( \"q\" );\n \t\tboolean displayProperties =\n-\t\t\tverbose || parser.options().containsKey( \"p\" );\n+\t\t\tparser.options().containsKey( \"p\" );\n \t\tboolean displayRelationships =\n-\t\t\tverbose || parser.options().containsKey( \"r\" );\n+\t\t\tparser.options().containsKey( \"r\" );\n \t\tString filter = parser.options().get( \"f\" );\n \t\tif ( !displayProperties && !displayRelationships )\n \t\t{",
      "parent_sha": "077438c8cd81d5906d06084c8fac4fab79974ff8"
    }
  },
  {
    "oid": "d715d76c0ba9a3264e7e02d402074a943e882757",
    "message": "Clarified the usage of Object in procedures",
    "date": "2017-10-17T07:39:24Z",
    "url": "https://github.com/neo4j/neo4j/commit/d715d76c0ba9a3264e7e02d402074a943e882757",
    "details": {
      "sha": "9e90cd6e0eff67d710171ddb0b3ea8d45ba3da87",
      "filename": "community/kernel/src/main/java/org/neo4j/procedure/Procedure.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/neo4j/neo4j/blob/d715d76c0ba9a3264e7e02d402074a943e882757/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fprocedure%2FProcedure.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/d715d76c0ba9a3264e7e02d402074a943e882757/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fprocedure%2FProcedure.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fprocedure%2FProcedure.java?ref=d715d76c0ba9a3264e7e02d402074a943e882757",
      "patch": "@@ -53,7 +53,7 @@\n  *     <li>{@link org.neo4j.graphdb.Path}</li>\n  *     <li>{@link java.util.Map} with key {@link String} and value of any type in this list, including {@link java.util.Map}</li>\n  *     <li>{@link java.util.List} with element type of any type in this list, including {@link java.util.List}</li>\n- *     <li>{@link Object}, meaning any valid input types</li>\n+ *     <li>{@link Object}, meaning any of the valid input types above</li>\n  * </ul>\n  *\n  * <h2>Output declaration</h2>\n@@ -74,7 +74,7 @@\n  *     <li>{@link org.neo4j.graphdb.Path}</li>\n  *     <li>{@link java.util.Map} with key {@link String} and value of any type in this list, including {@link java.util.Map}</li>\n  *     <li>{@link java.util.List} of elements of any valid field type, including {@link java.util.List}</li>\n- *     <li>{@link Object}, meaning any of the valid field types</li>\n+ *     <li>{@link Object}, meaning any of the valid field types above</li>\n  * </ul>\n  *\n  * <h2>Resource declarations</h2>",
      "parent_sha": "3398ca28bce429b4a7b8c8af96227ed5888f7281"
    }
  },
  {
    "oid": "746acf97ae2bec64e442bbf9459b5d9b3f8d404a",
    "message": "Make NestedTransactionLocksIT more readable.",
    "date": "2013-11-13T15:36:16Z",
    "url": "https://github.com/neo4j/neo4j/commit/746acf97ae2bec64e442bbf9459b5d9b3f8d404a",
    "details": {
      "sha": "36be7ea3e04997ecb4ac94af9c257756fba17224",
      "filename": "community/kernel/src/test/java/org/neo4j/kernel/impl/core/NestedTransactionLocksIT.java",
      "status": "modified",
      "additions": 31,
      "deletions": 13,
      "changes": 44,
      "blob_url": "https://github.com/neo4j/neo4j/blob/746acf97ae2bec64e442bbf9459b5d9b3f8d404a/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fcore%2FNestedTransactionLocksIT.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/746acf97ae2bec64e442bbf9459b5d9b3f8d404a/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fcore%2FNestedTransactionLocksIT.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fcore%2FNestedTransactionLocksIT.java?ref=746acf97ae2bec64e442bbf9459b5d9b3f8d404a",
      "patch": "@@ -19,6 +19,7 @@\n  */\n package org.neo4j.kernel.impl.core;\n \n+import java.util.concurrent.ExecutionException;\n import java.util.concurrent.Future;\n import java.util.concurrent.TimeoutException;\n \n@@ -79,17 +80,30 @@ public void nestedTransactionCanAcquireLocksFromTransactionObject() throws Excep\n     {\n         // given\n         Node resource = createNode();\n-        Transaction realTx = db.beginTx();\n+\n+        Transaction outerTx = db.beginTx();\n         Transaction nestedTx = db.beginTx();\n-        assertNotSame( realTx, nestedTx );\n-        OtherThreadExecutor<Void> otherTx = new OtherThreadExecutor<>( \"other thread\", null );\n-        \n-        // when\n-        Lock lock = nestedTx.acquireWriteLock( resource );\n-        Future<Lock> future = otherTx.executeDontWait( acquireWriteLock( resource ) );\n-        otherTx.waitUntilWaiting();\n-        \n-        // then\n+        assertNotSame( outerTx, nestedTx );\n+\n+        try ( OtherThreadExecutor<Void> otherThread = new OtherThreadExecutor<>( \"other thread\", null ) )\n+        {\n+            // when\n+            Lock lock = nestedTx.acquireWriteLock( resource );\n+            Future<Lock> future = tryToAcquireSameLockOnAnotherThread( resource, otherThread );\n+\n+            // then\n+            acquireOnOtherThreadTimesOut( future );\n+\n+            // and when\n+            lock.release();\n+\n+            //then\n+            assertNotNull( future.get() );\n+        }\n+    }\n+\n+    private void acquireOnOtherThreadTimesOut( Future<Lock> future ) throws InterruptedException, ExecutionException\n+    {\n         try\n         {\n             future.get( 1, SECONDS );\n@@ -98,9 +112,13 @@ public void nestedTransactionCanAcquireLocksFromTransactionObject() throws Excep\n         catch ( TimeoutException e )\n         {   // Good\n         }\n-        lock.release();\n-        assertNotNull( future.get() );\n-        otherTx.close();\n+    }\n+\n+    private Future<Lock> tryToAcquireSameLockOnAnotherThread( Node resource, OtherThreadExecutor<Void> otherThread ) throws TimeoutException\n+    {\n+        Future<Lock> future = otherThread.executeDontWait( acquireWriteLock( resource ) );\n+        otherThread.waitUntilWaiting();\n+        return future;\n     }\n \n     private Node createNode()",
      "parent_sha": "cf55343057553a57e1cbb732380edb42a4aaccd0"
    }
  },
  {
    "oid": "c5a8514e5e571c41837b4637e848c666ac2c7b48",
    "message": "Truncate and evict old channel before creation of new one for tx logs.",
    "date": "2019-07-13T18:16:01Z",
    "url": "https://github.com/neo4j/neo4j/commit/c5a8514e5e571c41837b4637e848c666ac2c7b48",
    "details": {
      "sha": "1836ebc9a60d6e902daf1658bbeeade01e6c6201",
      "filename": "community/kernel/src/main/java/org/neo4j/kernel/impl/transaction/log/files/TransactionLogFile.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/neo4j/neo4j/blob/c5a8514e5e571c41837b4637e848c666ac2c7b48/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Ftransaction%2Flog%2Ffiles%2FTransactionLogFile.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/c5a8514e5e571c41837b4637e848c666ac2c7b48/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Ftransaction%2Flog%2Ffiles%2FTransactionLogFile.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Ftransaction%2Flog%2Ffiles%2FTransactionLogFile.java?ref=c5a8514e5e571c41837b4637e848c666ac2c7b48",
      "patch": "@@ -219,6 +219,9 @@ private PhysicalLogVersionedStoreChannel rotate( LogVersionedStoreChannel curren\n          * transaction complete in the log we're rotating away. Awesome.\n          */\n         writer.prepareForFlush().flush();\n+        currentLog.truncate( currentLog.position() );\n+        tryEvictFromSystemCache( currentLog );\n+\n         /*\n          * The log version is now in the store, flushed and persistent. If we crash\n          * now, on recovery we'll attempt to open the version we're about to create\n@@ -229,8 +232,6 @@ private PhysicalLogVersionedStoreChannel rotate( LogVersionedStoreChannel curren\n          * into transaction log that was just rotated.\n          */\n         PhysicalLogVersionedStoreChannel newLog = logFiles.createLogChannelForVersion( newLogVersion, context::committingTransactionId );\n-        tryEvictFromSystemCache( currentLog );\n-        currentLog.truncate( currentLog.position() );\n         currentLog.close();\n         return newLog;\n     }",
      "parent_sha": "37ddf3d43b93de2bd164a685132bcba681207670"
    }
  },
  {
    "oid": "0956812697bda34df6cf5e04d9d7b4647cfcee02",
    "message": "Rework of ConcurrentAccessIT to hopefully make it faster\n\nConcurrentAccessIT takes ~10min in CI. It was using a CyclicBarrier\nwith calls to its await() method in various places. Not quite sure\nit was used properly, so simplified it using a DoubleLatch\nas well as lowered num workers/requests. It still tests the same thing,\nwhich is to make sure that bolt can serve concurrent connections.",
    "date": "2022-11-25T08:16:55Z",
    "url": "https://github.com/neo4j/neo4j/commit/0956812697bda34df6cf5e04d9d7b4647cfcee02",
    "details": {
      "sha": "358e947514c72b7690891dc68109e84d0808c733",
      "filename": "community/community-it/bolt-it/src/test/java/org/neo4j/bolt/tx/ConcurrentAccessIT.java",
      "status": "modified",
      "additions": 38,
      "deletions": 42,
      "changes": 80,
      "blob_url": "https://github.com/neo4j/neo4j/blob/0956812697bda34df6cf5e04d9d7b4647cfcee02/community%2Fcommunity-it%2Fbolt-it%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fbolt%2Ftx%2FConcurrentAccessIT.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/0956812697bda34df6cf5e04d9d7b4647cfcee02/community%2Fcommunity-it%2Fbolt-it%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fbolt%2Ftx%2FConcurrentAccessIT.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fcommunity-it%2Fbolt-it%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fbolt%2Ftx%2FConcurrentAccessIT.java?ref=0956812697bda34df6cf5e04d9d7b4647cfcee02",
      "patch": "@@ -21,13 +21,14 @@\n \n import static org.assertj.core.api.InstanceOfAssertFactories.list;\n import static org.neo4j.bolt.testing.assertions.BoltConnectionAssertions.assertThat;\n+import static org.neo4j.util.concurrent.Futures.getAllResults;\n \n import java.io.IOException;\n-import java.util.concurrent.BrokenBarrierException;\n-import java.util.concurrent.CyclicBarrier;\n+import java.util.ArrayList;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicInteger;\n import org.assertj.core.api.Assertions;\n import org.neo4j.bolt.test.annotation.BoltTestExtension;\n@@ -38,6 +39,8 @@\n import org.neo4j.bolt.testing.messages.BoltWire;\n import org.neo4j.bolt.transport.Neo4jWithSocketExtension;\n import org.neo4j.function.ThrowingConsumer;\n+import org.neo4j.internal.batchimport.HighestId;\n+import org.neo4j.test.DoubleLatch;\n import org.neo4j.test.extension.testdirectory.EphemeralTestDirectoryExtension;\n \n /**\n@@ -50,55 +53,48 @@\n @Neo4jWithSocketExtension\n @BoltTestExtension\n public class ConcurrentAccessIT {\n-\n-    private static final int NUM_WORKERS = 5;\n-    private static final int NUM_REQUESTS = 1_000;\n+    private static final int NUM_WORKERS = 4;\n+    private static final int NUM_REQUESTS = 100;\n \n     private void runWorkload(\n             ConnectionProvider connectionProvider,\n             int nWorkers,\n             int nTimes,\n             ThrowingConsumer<TransportConnection, IOException> workload)\n-            throws InterruptedException, BrokenBarrierException, TimeoutException {\n-        var pool = Executors.newFixedThreadPool(nWorkers);\n+            throws InterruptedException, ExecutionException {\n+        var barrier = new DoubleLatch(nWorkers);\n+        var tasks = new ArrayList<Callable<Void>>();\n+        var numActiveWorkers = new AtomicInteger();\n+        var highestNumConcurrentWorkers = new HighestId();\n+        for (var i = 0; i < nWorkers; ++i) {\n+            tasks.add(() -> {\n+                // acquire an authenticated connection\n+                var connection = connectionProvider.create();\n+\n+                // wait for all parties to reach the barrier point in order to synchronize startup\n+                barrier.startAndWaitForAllToStart();\n+                highestNumConcurrentWorkers.offer(numActiveWorkers.incrementAndGet());\n+\n+                // execute the actual workload n times\n+                for (var j = 0; j < nTimes; ++j) {\n+                    workload.accept(connection);\n+                }\n+\n+                // wait till all parties manage to execute the entire workload\n+                barrier.finishAndWaitForAllToFinish();\n+                return null;\n+            });\n+        }\n \n+        var pool = Executors.newFixedThreadPool(nWorkers);\n         try {\n-            var barrier = new CyclicBarrier(nWorkers + 1);\n-            var errorCounter = new AtomicInteger();\n-\n-            for (int i = 0; i < nWorkers; ++i) {\n-                pool.submit(() -> {\n-                    try {\n-                        // acquire an authenticated connection\n-                        var connection = connectionProvider.create();\n-\n-                        // wait for all parties to reach the barrier point in order to synchronize startup\n-                        barrier.await();\n-\n-                        // execute the actual workload n times\n-                        for (var j = 0; j < nTimes; ++j) {\n-                            workload.accept(connection);\n-                        }\n-\n-                        // wait till all parties manage to execute the entire workload\n-                        barrier.await();\n-                    } catch (Throwable ex) {\n-                        ex.printStackTrace();\n-\n-                        errorCounter.incrementAndGet();\n-                    }\n-                });\n-            }\n-\n-            // wait until all workers managed to acquire a connection and start processing\n-            barrier.await(1, TimeUnit.MINUTES);\n+            var futures = pool.invokeAll(tasks);\n \n-            // wait until all workers complete their assignment\n-            barrier.await(5, TimeUnit.MINUTES);\n+            // when\n+            getAllResults(futures);\n \n-            // ensure that no errors were reported, otherwise forcefully fail the test (errors will be reported to\n-            // stderr)\n-            Assertions.assertThat(errorCounter).hasValue(0);\n+            // then no exception is thrown, and\n+            Assertions.assertThat(highestNumConcurrentWorkers.get()).isEqualTo(nWorkers);\n         } finally {\n             pool.shutdownNow();\n             pool.awaitTermination(30, TimeUnit.SECONDS);",
      "parent_sha": "c0cf60df970d0194e1a0f01ab4a128eb86c3b1d1"
    }
  },
  {
    "oid": "d9f391465d4d7ff056554e451db69271a2676a3b",
    "message": "Extract private helper for access checks",
    "date": "2016-10-11T13:53:22Z",
    "url": "https://github.com/neo4j/neo4j/commit/d9f391465d4d7ff056554e451db69271a2676a3b",
    "details": {
      "sha": "796e5e0e13b2fd67c692cb58e115162089542518",
      "filename": "community/kernel/src/main/java/org/neo4j/kernel/impl/api/KernelStatement.java",
      "status": "modified",
      "additions": 14,
      "deletions": 20,
      "changes": 34,
      "blob_url": "https://github.com/neo4j/neo4j/blob/d9f391465d4d7ff056554e451db69271a2676a3b/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fapi%2FKernelStatement.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/d9f391465d4d7ff056554e451db69271a2676a3b/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fapi%2FKernelStatement.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fapi%2FKernelStatement.java?ref=d9f391465d4d7ff056554e451db69271a2676a3b",
      "patch": "@@ -20,6 +20,7 @@\n package org.neo4j.kernel.impl.api;\n \n import java.util.Optional;\n+import java.util.function.Supplier;\n \n import org.neo4j.graphdb.NotInTransactionException;\n import org.neo4j.graphdb.TransactionTerminatedException;\n@@ -90,11 +91,7 @@ public KernelStatement( KernelTransactionImplementation transaction,\n     @Override\n     public ReadOperations readOperations()\n     {\n-        if( !transaction.mode().allowsReads() )\n-        {\n-            throw transaction.mode().onViolation(\n-                    String.format( \"Read operations are not allowed for '%s'.\", transaction.mode().name() ) );\n-        }\n+        assertAllows( () -> transaction.mode().allowsReads(), \"Read\" );\n         return facade;\n     }\n \n@@ -109,11 +106,7 @@ public TokenWriteOperations tokenWriteOperations()\n     {\n         accessCapability.assertCanWrite();\n \n-        if ( !transaction.mode().allowsWrites() )\n-        {\n-            throw transaction.mode().onViolation(\n-                    String.format( \"Write operations are not allowed for '%s'.\", transaction.mode().name() ) );\n-        }\n+        assertAllows( () -> transaction.mode().allowsWrites(), \"Write\" );\n         return facade;\n     }\n \n@@ -123,11 +116,7 @@ public DataWriteOperations dataWriteOperations()\n     {\n         accessCapability.assertCanWrite();\n \n-        if( !transaction.mode().allowsWrites() )\n-        {\n-            throw transaction.mode().onViolation(\n-                    String.format( \"Write operations are not allowed for '%s'.\", transaction.mode().name() ) );\n-        }\n+        assertAllows( () -> transaction.mode().allowsWrites(), \"Write\" );\n         transaction.upgradeToDataWrites();\n         return facade;\n     }\n@@ -138,11 +127,7 @@ public SchemaWriteOperations schemaWriteOperations()\n     {\n         accessCapability.assertCanWrite();\n \n-        if( !transaction.mode().allowsSchemaWrites() )\n-        {\n-            throw transaction.mode().onViolation(\n-                    String.format( \"Schema operations are not allowed for '%s'.\", transaction.mode().name() ) );\n-        }\n+        assertAllows( () -> transaction.mode().allowsSchemaWrites(), \"Schema\" );\n         transaction.upgradeToSchemaWrites();\n         return facade;\n     }\n@@ -266,4 +251,13 @@ public KernelTransactionImplementation getTransaction()\n     {\n         return transaction;\n     }\n+\n+    private void assertAllows( Supplier<Boolean> allows, String mode )\n+    {\n+        if ( !allows.get() )\n+        {\n+            throw transaction.mode().onViolation(\n+                    String.format( \"%s operations are not allowed for '%s'.\", mode, transaction.mode().name() ) );\n+        }\n+    }\n }",
      "parent_sha": "fc5c144894fea9418623dcdf1bdae71323dfdc0f"
    }
  },
  {
    "oid": "e2ad28707052cccebc66a53eae4ad771f962e255",
    "message": "Escape url string that clashes with doc markup",
    "date": "2016-09-22T07:12:33Z",
    "url": "https://github.com/neo4j/neo4j/commit/e2ad28707052cccebc66a53eae4ad771f962e255",
    "details": {
      "sha": "b486db575241e3f2da6f5cafd0493bc1ff71d89f",
      "filename": "enterprise/security/src/main/java/org/neo4j/server/security/enterprise/auth/SecuritySettings.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/neo4j/neo4j/blob/e2ad28707052cccebc66a53eae4ad771f962e255/enterprise%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fserver%2Fsecurity%2Fenterprise%2Fauth%2FSecuritySettings.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/e2ad28707052cccebc66a53eae4ad771f962e255/enterprise%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fserver%2Fsecurity%2Fenterprise%2Fauth%2FSecuritySettings.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/enterprise%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fserver%2Fsecurity%2Fenterprise%2Fauth%2FSecuritySettings.java?ref=e2ad28707052cccebc66a53eae4ad771f962e255",
      "patch": "@@ -65,8 +65,8 @@ public class SecuritySettings\n             setting( \"dbms.security.realms.plugin.authorization_enabled\", BOOLEAN, \"false\" );\n \n     @Description( \"URL of LDAP server (with protocol, hostname and port) to use for authentication and authorization. \" +\n-                  \"If no protocol is specified the default will be 'ldap://'. To use LDAPS, \" +\n-                  \"set the protocol and port, e.g. 'ldaps://ldap.example.com:636'\" )\n+                  \"If no protocol is specified the default will be `ldap://`. To use LDAPS, \" +\n+                  \"set the protocol and port, e.g. `ldaps://ldap.example.com:636`\" )\n     public static final Setting<String> ldap_server =\n             setting( \"dbms.security.realms.ldap.host\", STRING, \"0.0.0.0:389\" );\n ",
      "parent_sha": "a442d283590fa58dc8d5d095f8292a9a0a8b3b70"
    }
  },
  {
    "oid": "8dd423151ba368d654d44f753c94920126b1236b",
    "message": "Added a simple recursive directory delete method that is tolerant of locking delays, for use on windows",
    "date": "2011-05-03T08:43:42Z",
    "url": "https://github.com/neo4j/neo4j/commit/8dd423151ba368d654d44f753c94920126b1236b",
    "details": {
      "sha": "82a8fe58c20f608ede9ce7af8c5fc47606f382cb",
      "filename": "community/kernel/src/main/java/org/neo4j/kernel/impl/util/FileUtils.java",
      "status": "modified",
      "additions": 48,
      "deletions": 5,
      "changes": 53,
      "blob_url": "https://github.com/neo4j/neo4j/blob/8dd423151ba368d654d44f753c94920126b1236b/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Futil%2FFileUtils.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/8dd423151ba368d654d44f753c94920126b1236b/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Futil%2FFileUtils.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Futil%2FFileUtils.java?ref=8dd423151ba368d654d44f753c94920126b1236b",
      "patch": "@@ -22,13 +22,56 @@\n import java.io.File;\n import java.io.IOException;\n import java.nio.channels.FileChannel;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Stack;\n \n import org.neo4j.graphdb.NotFoundException;\n \n public class FileUtils\n {\n     private static int WINDOWS_RETRY_COUNT = 3;\n \n+    public static void deleteRecursively( File directory )\n+    throws IOException\n+    {\n+        Stack<File> stack = new Stack<File>();\n+        List<File> temp = new LinkedList<File>();\n+        stack.push(directory.getAbsoluteFile());\n+        while(!stack.isEmpty())\n+        {\n+            File top = stack.pop();\n+            if (top.listFiles() != null)\n+            {\n+                for (File child : top.listFiles()) {\n+                    if (child.isFile()) {\n+                        if ( !deleteFile( child ) )\n+                        {\n+                            throw new IOException( \"Failed to delete \"\n+                                    + child.getCanonicalPath() );\n+                        }\n+                    } else {\n+                        temp.add(child);\n+                    }\n+                }\n+            }\n+            if (top.listFiles() == null || top.listFiles().length == 0) {\n+                if ( !deleteFile( top ) )\n+                {\n+                    throw new IOException( \"Failed to delete \"\n+                            + top.getCanonicalPath() );\n+                }\n+            } else {\n+                stack.push(top);\n+                for (File f : temp)\n+                {\n+                    stack.push(f);\n+                }\n+            }\n+            temp.clear();\n+        }\n+    }\n+\n     public static boolean deleteFile( File file )\n     {\n         if ( !file.exists() )\n@@ -49,18 +92,18 @@ public static boolean deleteFile( File file )\n         while ( !deleted && count <= WINDOWS_RETRY_COUNT );\n         return deleted;\n     }\n-    \n+\n     public static boolean renameFile( File srcFile, File renameToFile )\n     {\n         if ( !srcFile.exists() )\n         {\n             throw new NotFoundException( \"Source file[\" + srcFile.getName()\n-                + \"] not found\" );\n+                    + \"] not found\" );\n         }\n         if ( renameToFile.exists() )\n         {\n             throw new NotFoundException( \"Target file[\" + renameToFile.getName()\n-                + \"] already exists\" );\n+                    + \"] already exists\" );\n         }\n         int count = 0;\n         boolean renamed = false;\n@@ -78,7 +121,7 @@ public static boolean renameFile( File srcFile, File renameToFile )\n     }\n \n     public static void truncateFile( FileChannel fileChannel, long position )\n-        throws IOException\n+    throws IOException\n     {\n         int count = 0;\n         boolean success = false;\n@@ -116,7 +159,7 @@ private static void waitSome()\n         } // ok\n         System.gc();\n     }\n-    \n+\n     public static String fixSeparatorsInPath( String path )\n     {\n         String fileSeparator = System.getProperty( \"file.separator\" );",
      "parent_sha": "e2bce2ab7f6358852b667b9e43be841c34c7ac38"
    }
  },
  {
    "oid": "7e0b3dc544382180e3556c55188bd9dd223f71f4",
    "message": "Just renaming some hungarian-ly named variable.\n\ngit-svn-id: https://svn.neo4j.org/components/server/trunk@6898 0b971d98-bb2f-0410-8247-b05b2b5feb2a",
    "date": "2010-11-12T17:34:25Z",
    "url": "https://github.com/neo4j/neo4j/commit/7e0b3dc544382180e3556c55188bd9dd223f71f4",
    "details": {
      "sha": "e9c4d9ddaa0241e1f9b09688ebac54b080c6288c",
      "filename": "community/src/main/java/org/neo4j/server/osgi/HostBridge.java",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/neo4j/neo4j/blob/7e0b3dc544382180e3556c55188bd9dd223f71f4/community%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fserver%2Fosgi%2FHostBridge.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/7e0b3dc544382180e3556c55188bd9dd223f71f4/community%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fserver%2Fosgi%2FHostBridge.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fserver%2Fosgi%2FHostBridge.java?ref=7e0b3dc544382180e3556c55188bd9dd223f71f4",
      "patch": "@@ -26,23 +26,23 @@\n \n public class HostBridge implements BundleActivator\n {\n-    private BundleContext m_context = null;\n+    private BundleContext context = null;\n \n     public void start(BundleContext context)\n     {\n-        m_context = context;\n+        this.context = context;\n     }\n \n     public void stop(BundleContext context)\n     {\n-        m_context = null;\n+        context = null;\n     }\n \n     public Bundle[] getBundles()\n     {\n-        if (m_context != null)\n+        if (context != null)\n         {\n-            return m_context.getBundles();\n+            return context.getBundles();\n         }\n         return null;\n     }",
      "parent_sha": "22e086e06a60083836656de85d34c01792a1553d"
    }
  },
  {
    "oid": "4e736c4c93c8b15ae8647da679346f5437701230",
    "message": "Rewrite multi chunked transaction tests to use probes ()\n\nRewrite to use tracers based probes instead of magical string with predefined sizes.",
    "date": "2023-03-01T23:08:00Z",
    "url": "https://github.com/neo4j/neo4j/commit/4e736c4c93c8b15ae8647da679346f5437701230",
    "details": {
      "sha": "05b1acf326ebf41a1cab6f8ce74270f8d616247f",
      "filename": "community/kernel/src/main/java/org/neo4j/kernel/impl/api/KernelTransactionImplementation.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/neo4j/neo4j/blob/4e736c4c93c8b15ae8647da679346f5437701230/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fapi%2FKernelTransactionImplementation.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/4e736c4c93c8b15ae8647da679346f5437701230/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fapi%2FKernelTransactionImplementation.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fapi%2FKernelTransactionImplementation.java?ref=4e736c4c93c8b15ae8647da679346f5437701230",
      "patch": "@@ -1071,6 +1071,7 @@ public long commit(\n         public void rollback(TransactionRollbackEvent rollbackEvent) {\n             if (transactionPayload != null) {\n                 try {\n+                    validateCurrentKernelVersion();\n                     rollbackBatches(rollbackEvent);\n                     writeRollbackEntry(rollbackEvent);\n                 } catch (Exception e) {\n@@ -1083,7 +1084,6 @@ public void rollback(TransactionRollbackEvent rollbackEvent) {\n \n         private void writeRollbackEntry(TransactionRollbackEvent transactionRollbackEvent)\n                 throws TransactionFailureException {\n-            validateCurrentKernelVersion();\n             var chunkMetadata = new ChunkMetadata(\n                     false,\n                     true,",
      "parent_sha": "848439c5de5f171a87be2c36e552fa53ff4c09f4"
    }
  },
  {
    "oid": "c8418f81960d7d8d39c1080fd745911c507920db",
    "message": "Setting path changed",
    "date": "2018-12-12T14:37:59Z",
    "url": "https://github.com/neo4j/neo4j/commit/c8418f81960d7d8d39c1080fd745911c507920db",
    "details": {
      "sha": "b2c3cfde1e92e5bf9667f40b44b216938abfc2d2",
      "filename": "community/neo4j-harness/src/test/java/org/neo4j/harness/JUnitRuleTestIT.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/neo4j/neo4j/blob/c8418f81960d7d8d39c1080fd745911c507920db/community%2Fneo4j-harness%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fharness%2FJUnitRuleTestIT.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/c8418f81960d7d8d39c1080fd745911c507920db/community%2Fneo4j-harness%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fharness%2FJUnitRuleTestIT.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fneo4j-harness%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fharness%2FJUnitRuleTestIT.java?ref=c8418f81960d7d8d39c1080fd745911c507920db",
      "patch": "@@ -26,11 +26,11 @@\n import java.io.File;\n import java.util.List;\n \n-import org.neo4j.dbms.DatabaseManagementSystemSettings;\n import org.neo4j.graphdb.GraphDatabaseService;\n import org.neo4j.graphdb.Label;\n import org.neo4j.graphdb.Result;\n import org.neo4j.graphdb.Transaction;\n+import org.neo4j.graphdb.factory.GraphDatabaseSettings;\n import org.neo4j.harness.extensionpackage.MyUnmanagedExtension;\n import org.neo4j.harness.junit.Neo4jRule;\n import org.neo4j.helpers.collection.Iterators;\n@@ -116,8 +116,8 @@ public void shouldRuleWorkWithExistingDirectory() throws Throwable\n     {\n         // given a data folder, create /databases/graph.db sub-folders.\n         File existingDir = testDirectory.directory( \"existing\" );\n-        File storeDir = Config.defaults( DatabaseManagementSystemSettings.data_directory, existingDir.toPath().toString() )\n-                .get( DatabaseManagementSystemSettings.database_path );\n+        File storeDir = Config.defaults( GraphDatabaseSettings.data_directory, existingDir.toPath().toString() )\n+                .get( GraphDatabaseSettings.database_path );\n         GraphDatabaseService db = new TestGraphDatabaseFactory().newEmbeddedDatabase( storeDir );\n \n         try",
      "parent_sha": "b15bb14f225da8efbffe5b15cc06ed9fd9a39293"
    }
  },
  {
    "oid": "178a525c249aa23cfba17b84ec87a4ee657fcf1d",
    "message": "tighter testing",
    "date": "2011-05-29T08:07:03Z",
    "url": "https://github.com/neo4j/neo4j/commit/178a525c249aa23cfba17b84ec87a4ee657fcf1d",
    "details": {
      "sha": "0b89c643d8a98bee4b34dbaef0b08e143a3ec93f",
      "filename": "gremlin-plugin/src/test/java/org/neo4j/server/plugin/gremlin/TestGremlin.java",
      "status": "modified",
      "additions": 14,
      "deletions": 9,
      "changes": 23,
      "blob_url": "https://github.com/neo4j/neo4j/blob/178a525c249aa23cfba17b84ec87a4ee657fcf1d/gremlin-plugin%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fserver%2Fplugin%2Fgremlin%2FTestGremlin.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/178a525c249aa23cfba17b84ec87a4ee657fcf1d/gremlin-plugin%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fserver%2Fplugin%2Fgremlin%2FTestGremlin.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/gremlin-plugin%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fserver%2Fplugin%2Fgremlin%2FTestGremlin.java?ref=178a525c249aa23cfba17b84ec87a4ee657fcf1d",
      "patch": "@@ -8,6 +8,7 @@\n import javax.ws.rs.core.MediaType;\n import javax.ws.rs.core.Response.Status;\n \n+import org.junit.After;\n import org.junit.AfterClass;\n import org.junit.Before;\n import org.junit.BeforeClass;\n@@ -44,10 +45,6 @@ public class TestGremlin implements GraphHolder\n     @Graph( value = { \"I know you\" } )\n     public void testGremlinPostURLEncoded()\n     {\n-        \n-        server = new WrappingNeoServerBootstrapper(\n-                graphdb );\n-        server.start();\n         String response = gen.get()\n         .expectedStatus( Status.OK.getStatusCode() )\n         .payload( \"script=g.v(2).outE.inV\" )\n@@ -56,7 +53,6 @@ public void testGremlinPostURLEncoded()\n         .entity();\n         System.out.println(response);\n         assertTrue(response.contains( \"you\" ));\n-        server.stop();\n         \n     }\n \n@@ -69,9 +65,7 @@ public void testGremlinPostJSON()\n     {\n         assertTrue(data.get().size() == 2);\n         \n-        server = new WrappingNeoServerBootstrapper(\n-                graphdb );\n-        server.start();\n+        \n         String response = gen.get()\n         .expectedStatus( Status.OK.getStatusCode() )\n         .payload( \"{\\\"script\\\":\\\"g.v(4).outE.inV\\\"}\" )\n@@ -80,7 +74,6 @@ public void testGremlinPostJSON()\n         .entity();\n         System.out.println(response);\n         assertTrue(response.contains( \"you\" ));\n-        server.stop();\n         \n     }\n     @BeforeClass\n@@ -100,4 +93,16 @@ public GraphDatabaseService graphdb()\n     {\n         return graphdb;\n     }\n+    \n+    @Before\n+    public void startServer() {\n+        server = new WrappingNeoServerBootstrapper(\n+                graphdb );\n+        server.start();\n+    }\n+    \n+    @After\n+    public void shutdownServer() {\n+        server.stop();\n+    }\n }",
      "parent_sha": "b396d1e02be793033884c43479ba150023f86a7a"
    }
  },
  {
    "oid": "7a23b130b38e5c61b7c13e1195c5def98b5f0b7c",
    "message": "Fix Neo4j Desktop file openening fallback",
    "date": "2013-11-21T15:49:34Z",
    "url": "https://github.com/neo4j/neo4j/commit/7a23b130b38e5c61b7c13e1195c5def98b5f0b7c",
    "details": {
      "sha": "37998d933d3d3f7e8091734ce878aa4129bb2b11",
      "filename": "packaging/neo4j-desktop/src/main/java/org/neo4j/desktop/config/Environment.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/neo4j/neo4j/blob/7a23b130b38e5c61b7c13e1195c5def98b5f0b7c/packaging%2Fneo4j-desktop%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fdesktop%2Fconfig%2FEnvironment.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/7a23b130b38e5c61b7c13e1195c5def98b5f0b7c/packaging%2Fneo4j-desktop%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fdesktop%2Fconfig%2FEnvironment.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/packaging%2Fneo4j-desktop%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fdesktop%2Fconfig%2FEnvironment.java?ref=7a23b130b38e5c61b7c13e1195c5def98b5f0b7c",
      "patch": "@@ -90,7 +90,7 @@ public void editFile( File file ) throws IOException\n                 e.printStackTrace( System.out );\n             }\n         }\n-        else if ( OperatingSystemFamily.WINDOWS.isDetected() )\n+        if ( OperatingSystemFamily.WINDOWS.isDetected() )\n         {\n             getRuntime().exec( new String[]{\"rundll32\", \"url.dll,FileProtocolHandler\", file.getAbsolutePath()} );\n             return;",
      "parent_sha": "9e93aa93bb056ea1f6f12ef2169037cb5a483e00"
    }
  },
  {
    "oid": "988c165fd6521312497640600c8a799a682e6a13",
    "message": "Fixed some functional tests by declaring in/out MediaTypes\n\ngit-svn-id: https://svn.neo4j.org/components/server/trunk@7808 0b971d98-bb2f-0410-8247-b05b2b5feb2a",
    "date": "2010-12-17T08:02:44Z",
    "url": "https://github.com/neo4j/neo4j/commit/988c165fd6521312497640600c8a799a682e6a13",
    "details": {
      "sha": "d558120599b304ba70cea0bc1b1bc67168f8be66",
      "filename": "advanced/src/functionaltest/java/org/neo4j/server/rest/CreateNodeFunctionalTest.java",
      "status": "modified",
      "additions": 8,
      "deletions": 3,
      "changes": 11,
      "blob_url": "https://github.com/neo4j/neo4j/blob/988c165fd6521312497640600c8a799a682e6a13/advanced%2Fsrc%2Ffunctionaltest%2Fjava%2Forg%2Fneo4j%2Fserver%2Frest%2FCreateNodeFunctionalTest.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/988c165fd6521312497640600c8a799a682e6a13/advanced%2Fsrc%2Ffunctionaltest%2Fjava%2Forg%2Fneo4j%2Fserver%2Frest%2FCreateNodeFunctionalTest.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/advanced%2Fsrc%2Ffunctionaltest%2Fjava%2Forg%2Fneo4j%2Fserver%2Frest%2FCreateNodeFunctionalTest.java?ref=988c165fd6521312497640600c8a799a682e6a13",
      "patch": "@@ -110,8 +110,8 @@ public void should400IfEntityBodyProvidedWhenCreatingAnEmptyNode()\n     {\n         Client client = Client.create();\n         WebResource resource = client.resource( server.restApiUri() + \"node/\" );\n-        ClientResponse response = resource.accept( MediaType.APPLICATION_JSON ).entity( \"{\\\"foo\\\" : \\\"bar\\\"}\" ).post( ClientResponse.class );\n-        assertEquals( 400, response.getStatus() );\n+        ClientResponse response = resource.type( MediaType.APPLICATION_JSON_TYPE ).accept( MediaType.APPLICATION_JSON ).entity( \"{\\\"foo\\\" : \\\"bar\\\"}\" ).post( ClientResponse.class );\n+        assertEquals( 201, response.getStatus() );\n \n     }\n \n@@ -212,6 +212,11 @@ public void shouldRespondWith409WhenNodeCannotBeDeleted() throws Exception\n \n     private ClientResponse sendDeleteRequestToServer( long id ) throws Exception\n     {\n-        return Client.create().resource( new URI( server.restApiUri() + \"node/\" + id ) ).delete( ClientResponse.class );\n+        return Client.\n+                create().\n+                resource( new URI( server.restApiUri() + \"node/\" + id ) ).\n+                type( MediaType.APPLICATION_JSON_TYPE ).\n+                accept( MediaType.APPLICATION_JSON_TYPE ).\n+                delete( ClientResponse.class );\n     }\n }",
      "parent_sha": "12f6d7cf2de2ab882615e92f0e3c9cc63543e0d8"
    }
  },
  {
    "oid": "47a49b7a9529bd3c4720b123e84a3a8420e3b779",
    "message": "Update queue to do spin instead of yield, offload propagation of transaction id.",
    "date": "2022-01-04T12:48:57Z",
    "url": "https://github.com/neo4j/neo4j/commit/47a49b7a9529bd3c4720b123e84a3a8420e3b779",
    "details": {
      "sha": "e782bef5f17fad878fb5e454ff30bdd7a1c13cf4",
      "filename": "community/kernel/src/main/java/org/neo4j/kernel/impl/transaction/log/TransactionLogQueue.java",
      "status": "modified",
      "additions": 27,
      "deletions": 26,
      "changes": 53,
      "blob_url": "https://github.com/neo4j/neo4j/blob/47a49b7a9529bd3c4720b123e84a3a8420e3b779/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Ftransaction%2Flog%2FTransactionLogQueue.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/47a49b7a9529bd3c4720b123e84a3a8420e3b779/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Ftransaction%2Flog%2FTransactionLogQueue.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Ftransaction%2Flog%2FTransactionLogQueue.java?ref=47a49b7a9529bd3c4720b123e84a3a8420e3b779",
      "patch": "@@ -126,13 +126,14 @@ public synchronized void shutdown() throws ExecutionException, InterruptedExcept\n \n     static class TxQueueElement\n     {\n-        private static final long PARK_TIME = MILLISECONDS.toNanos( 10 );\n+        private static final long PARK_TIME = MILLISECONDS.toNanos( 100 );\n \n         private final TransactionToApply batch;\n         private final LogAppendEvent logAppendEvent;\n         private final Thread executor;\n-        private Thread[] threadsToNotify;\n         private Throwable throwable;\n+        private TxQueueElement[] elementsToNotify;\n+        private volatile long[] txIds;\n         private volatile long txId;\n \n         TxQueueElement( TransactionToApply batch, LogAppendEvent logAppendEvent )\n@@ -144,17 +145,21 @@ static class TxQueueElement\n \n         public long getCommittedTxId()\n         {\n-            while ( txId == 0 )\n+            while ( txId == 0 && txIds == null )\n             {\n-                LockSupport.parkNanos( this, PARK_TIME );\n+                LockSupport.parkNanos( PARK_TIME );\n             }\n-            var threads = this.threadsToNotify;\n-            if ( threads != null )\n+            var elements = this.elementsToNotify;\n+            if ( elements != null )\n             {\n-                for ( Thread thread : threads )\n+                long[] ids = txIds;\n+                for ( int i = 1; i < elements.length; i++ )\n                 {\n-                    LockSupport.unpark( thread );\n+                    TxQueueElement element = elements[i];\n+                    element.txId = ids[i];\n+                    LockSupport.unpark( element.executor );\n                 }\n+                txId = ids[0];\n             }\n             var exception = throwable;\n             if ( exception != null )\n@@ -168,6 +173,7 @@ public void fail( Throwable throwable )\n         {\n             this.throwable = throwable;\n             this.txId = FAILED_TX_MARKER;\n+            LockSupport.unpark( executor );\n         }\n     }\n \n@@ -197,7 +203,7 @@ private static class TransactionWriter implements Runnable\n             this.transactionMetadataCache = transactionMetadataCache;\n             this.logRotation = logRotation;\n             this.log = log;\n-            this.waitStrategy = new ParkYieldCombineWaitingStrategy();\n+            this.waitStrategy = new SpinParkCombineWaitingStrategy();\n         }\n \n         @Override\n@@ -257,6 +263,7 @@ private static class TxConsumer implements MessagePassingQueue.Consumer<TxQueueE\n             private final TxQueueElement[] txElements = new TransactionLogQueue.TxQueueElement[CONSUMER_MAX_BATCH];\n             private final long[] txIds = new long[CONSUMER_MAX_BATCH];\n             private int index;\n+            private TxQueueElement[] elements;\n \n             TxConsumer( Health databaseHealth, TransactionIdStore transactionIdStore, TransactionLogWriter transactionLogWriter, int checksum,\n                     TransactionMetadataCache transactionMetadataCache )\n@@ -278,9 +285,11 @@ private void processBatch() throws IOException\n             {\n                 databaseHealth.assertHealthy( IOException.class );\n                 int drainedElements = index;\n+                elements = new TxQueueElement[drainedElements];\n                 for ( int i = 0; i < drainedElements; i++ )\n                 {\n                     TxQueueElement txQueueElement = txElements[i];\n+                    elements[i] = txQueueElement;\n                     LogAppendEvent logAppendEvent = txQueueElement.logAppendEvent;\n                     long lastTransactionId = TransactionIdStore.BASE_TX_ID;\n                     try ( var appendEvent = logAppendEvent.beginAppendTransaction( drainedElements ) )\n@@ -344,18 +353,10 @@ private TransactionCommitment appendToLog( TransactionRepresentation transaction\n \n             public void complete()\n             {\n-                int lastIndex = index - 1;\n-                var threadGroup = new Thread[lastIndex];\n-                for ( int i = 0; i < lastIndex; i++ )\n-                {\n-                    TxQueueElement txElement = txElements[i];\n-                    threadGroup[i] = txElement.executor;\n-                    txElement.txId = txIds[i];\n-                }\n-                TxQueueElement lastElement = txElements[lastIndex];\n-                lastElement.threadsToNotify = threadGroup;\n-                lastElement.txId = txIds[lastIndex];\n-                LockSupport.unpark( lastElement.executor );\n+                TxQueueElement first = txElements[0];\n+                first.elementsToNotify = elements;\n+                first.txIds = txIds;\n+                LockSupport.unpark( first.executor );\n \n                 Arrays.fill( txElements, 0, index, null );\n                 index = 0;\n@@ -379,14 +380,14 @@ public void stop()\n     }\n \n     /**\n-     * Message wait strategy that will try to wait at first for number of times for new work by using Thread.yield, and fallback to parkNanos\n+     * Message wait strategy that will try to wait at first for number of times for new work by using Thread.onSpinWait, and fallback to parkNanos\n      * if new work did not arrive.\n      * This is a strategy that should be good on systems with lots of work but may cause some increased latency spikes on systems with relatively small\n      * number of incoming transactions.\n      */\n-    private static class ParkYieldCombineWaitingStrategy implements MessagePassingQueue.WaitStrategy\n+    private static class SpinParkCombineWaitingStrategy implements MessagePassingQueue.WaitStrategy\n     {\n-        private static final int YIELD_THRESHOLD = 1000;\n+        private static final int SPIN_THRESHOLD = Runtime.getRuntime().availableProcessors() < 2 ? 1 : 1000;\n         private static final int SHORT_PARK_THRESHOLD = 100_000;\n         private static final int LONG_PARK_COUNTER = SHORT_PARK_THRESHOLD + 1;\n         private static final int SHORT_PARK_TIME = 10;\n@@ -395,9 +396,9 @@ private static class ParkYieldCombineWaitingStrategy implements MessagePassingQu\n         @Override\n         public int idle( int idleCounter )\n         {\n-            if ( idleCounter < YIELD_THRESHOLD )\n+            if ( idleCounter < SPIN_THRESHOLD )\n             {\n-                Thread.yield();\n+                Thread.onSpinWait();\n             }\n             else if ( idleCounter < SHORT_PARK_THRESHOLD )\n             {",
      "parent_sha": "4624e2fd29309d942f886111b2d0bea95e0c69f6"
    }
  },
  {
    "oid": "48cc2305eb7d637a83e375ea317964c3a7d0bc05",
    "message": "fix mismatch in cluster runner",
    "date": "2017-05-17T09:05:44Z",
    "url": "https://github.com/neo4j/neo4j/commit/48cc2305eb7d637a83e375ea317964c3a7d0bc05",
    "details": {
      "sha": "13fb13a4c9a53a05412fe3071676ac9240895b2b",
      "filename": "enterprise/neo4j-harness-enterprise/src/main/java/org/neo4j/harness/CausalClusterInProcessRunner.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/neo4j/neo4j/blob/48cc2305eb7d637a83e375ea317964c3a7d0bc05/enterprise%2Fneo4j-harness-enterprise%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fharness%2FCausalClusterInProcessRunner.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/48cc2305eb7d637a83e375ea317964c3a7d0bc05/enterprise%2Fneo4j-harness-enterprise%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fharness%2FCausalClusterInProcessRunner.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/enterprise%2Fneo4j-harness-enterprise%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fharness%2FCausalClusterInProcessRunner.java?ref=48cc2305eb7d637a83e375ea317964c3a7d0bc05",
      "patch": "@@ -105,7 +105,7 @@ void boot() throws IOException, InterruptedException\n             List<Thread> coreThreads = new ArrayList<>();\n             List<Thread> replicaThreads = new ArrayList<>();\n \n-            for ( int coreId = 0; coreId < nReplicas; coreId++ )\n+            for ( int coreId = 0; coreId < nCores; coreId++ )\n             {\n                 int hazelcastPort = 55000 + coreId;\n                 int txPort = 56000 + coreId;\n@@ -149,7 +149,7 @@ void boot() throws IOException, InterruptedException\n                 coreThread.join();\n             }\n \n-            for ( int replicaId = 0; replicaId < nCores; replicaId++ )\n+            for ( int replicaId = 0; replicaId < nReplicas; replicaId++ )\n             {\n                 int txPort = 56500 + replicaId;\n                 int boltPort = 58500 + replicaId;",
      "parent_sha": "4b1a3d358bd3ca0a79876aa41409658a011544be"
    }
  },
  {
    "oid": "eea737d052486ac6f478bed5a115c38b5bdfb16f",
    "message": "Extra test to verify we do not need to post-eagerize",
    "date": "2018-08-03T13:39:41Z",
    "url": "https://github.com/neo4j/neo4j/commit/eea737d052486ac6f478bed5a115c38b5bdfb16f",
    "details": {
      "sha": "8c3fe6736b86f0343354d8f3b6203fa3c4fad1a0",
      "filename": "integrationtests/src/test/java/org/neo4j/procedure/EagerProcedureIT.java",
      "status": "modified",
      "additions": 48,
      "deletions": 1,
      "changes": 49,
      "blob_url": "https://github.com/neo4j/neo4j/blob/eea737d052486ac6f478bed5a115c38b5bdfb16f/integrationtests%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fprocedure%2FEagerProcedureIT.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/eea737d052486ac6f478bed5a115c38b5bdfb16f/integrationtests%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fprocedure%2FEagerProcedureIT.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/integrationtests%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fprocedure%2FEagerProcedureIT.java?ref=eea737d052486ac6f478bed5a115c38b5bdfb16f",
      "patch": "@@ -34,9 +34,11 @@\n \n import java.io.IOException;\n import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n \n import static org.hamcrest.MatcherAssert.assertThat;\n import static org.hamcrest.Matchers.containsString;\n+import static org.neo4j.procedure.Mode.READ;\n import static org.neo4j.procedure.Mode.WRITE;\n \n public class EagerProcedureIT\n@@ -79,6 +81,22 @@ public void shouldGetPropertyAccessFailureWhenStreamingToANonEagerDestructivePro\n         res.resultAsString();   // pull all results. The second row will cause the exception\n     }\n \n+    @Test\n+    public void shouldNotGetErrorBecauseOfNormalEagerizationWhenStreamingFromANormalReadProcedureToDestructiveCypher()\n+    {\n+        // When we have a simple graph (a)\n+        int count = 10;\n+        setUpTestData( count );\n+\n+        // Then we can run an normal read procedure and it will be eagerized by normal Cypher eagerization\n+        Result res = db.execute( \"MATCH (n) WHERE n.key = 'value' \" +\n+                \"CALL org.neo4j.procedure.findNeighboursNotEagerized(n) \" +\n+                \"YIELD relationship AS r, node as m \" +\n+                \"DELETE r, m RETURN true\" );\n+        assertThat( \"Should get one fewer rows than original nodes\", res.resultAsString(), containsString( (count - 1) + \" rows\" ) );\n+        assertThat( \"The plan description should contain the 'Eager' operation\", res.getExecutionPlanDescription().toString(), containsString( \"+Eager\" ) );\n+    }\n+\n     @Test\n     public void shouldGetEagerPlanForAnEagerProcedure()\n     {\n@@ -101,10 +119,15 @@ public void shouldNotGetEagerPlanForANonEagerProcedure()\n     }\n \n     private void setUpTestData()\n+    {\n+        setUpTestData( 2 );\n+    }\n+\n+    private void setUpTestData( int nodes )\n     {\n         try ( Transaction tx = db.beginTx() )\n         {\n-            createChainOfNodesWithLabelAndProperty( 2, \"FOLLOWS\", \"User\", \"key\", \"value\" );\n+            createChainOfNodesWithLabelAndProperty( nodes, \"FOLLOWS\", \"User\", \"key\", \"value\" );\n             tx.success();\n         }\n     }\n@@ -159,12 +182,36 @@ public Output( long value )\n         }\n     }\n \n+    public static class NeighbourOutput\n+    {\n+        public final Relationship relationship;\n+        public final Node node;\n+\n+        public NeighbourOutput( Relationship relationship, Node node )\n+        {\n+            this.relationship = relationship;\n+            this.node = node;\n+        }\n+    }\n+\n     @SuppressWarnings( \"unused\" )\n     public static class ClassWithProcedures\n     {\n         @Context\n         public GraphDatabaseService db;\n \n+        @Procedure( mode = READ )\n+        public Stream<NeighbourOutput> findNeighboursNotEagerized( @Name( \"node\" ) Node node )\n+        {\n+            return findNeighbours( node );\n+        }\n+\n+        private Stream<NeighbourOutput> findNeighbours( Node node )\n+        {\n+            return StreamSupport.stream( node.getRelationships(Direction.OUTGOING).spliterator(), false ).map(\n+                    (relationship -> new NeighbourOutput( relationship, relationship.getOtherNode( node ) )) );\n+        }\n+\n         @Procedure( mode = WRITE, eager = true )\n         public Stream<Output> deleteNeighboursEagerized( @Name( \"node\" ) Node node, @Name( \"relation\" ) String relation )\n         {",
      "parent_sha": "975b375f7298123f6250a2f81fddcc4e38dbf95d"
    }
  },
  {
    "oid": "f8653c143aacbd2e34adc9775f083baf5dad0182",
    "message": "Fix for getSingleRelationship in the wrapped graphdb.",
    "date": "2011-12-15T21:01:38Z",
    "url": "https://github.com/neo4j/neo4j/commit/f8653c143aacbd2e34adc9775f083baf5dad0182",
    "details": {
      "sha": "414a2feb7639d4e889aa6b689436bbd2b95815c3",
      "filename": "community/kernel/src/main/java/org/neo4j/tooling/wrap/WrappedNode.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/neo4j/neo4j/blob/f8653c143aacbd2e34adc9775f083baf5dad0182/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Ftooling%2Fwrap%2FWrappedNode.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/f8653c143aacbd2e34adc9775f083baf5dad0182/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Ftooling%2Fwrap%2FWrappedNode.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Ftooling%2Fwrap%2FWrappedNode.java?ref=f8653c143aacbd2e34adc9775f083baf5dad0182",
      "patch": "@@ -110,7 +110,9 @@ public boolean hasRelationship( RelationshipType type, Direction dir )\n     @Override\n     public Relationship getSingleRelationship( RelationshipType type, Direction dir )\n     {\n-        return graphdb.relationship( actual().getSingleRelationship( type, dir ), false );\n+        Relationship rel = actual().getSingleRelationship( type, dir );\n+        if ( rel == null ) return null;\n+        return graphdb.relationship( rel, false );\n     }\n \n     @Override",
      "parent_sha": "a6c5a2dd0802d13d9c4237492ce3da5ee19dd593"
    }
  },
  {
    "oid": "6ce573c4b016f308ee1e1c863c89b3a1ab107ada",
    "message": "Undoing mistake on previous commit",
    "date": "2011-10-17T09:15:13Z",
    "url": "https://github.com/neo4j/neo4j/commit/6ce573c4b016f308ee1e1c863c89b3a1ab107ada",
    "details": {
      "sha": "8d0cce322fa052ad4839d1d8e6b7f7f9218aa9e1",
      "filename": "community/kernel/src/main/java/org/neo4j/kernel/impl/nioneo/store/PropertyStore.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/neo4j/neo4j/blob/6ce573c4b016f308ee1e1c863c89b3a1ab107ada/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fnioneo%2Fstore%2FPropertyStore.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/6ce573c4b016f308ee1e1c863c89b3a1ab107ada/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fnioneo%2Fstore%2FPropertyStore.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fnioneo%2Fstore%2FPropertyStore.java?ref=6ce573c4b016f308ee1e1c863c89b3a1ab107ada",
      "patch": "@@ -435,10 +435,10 @@ private PropertyRecord getRecord( long id, PersistenceWindow window )\n     {\n         Buffer buffer = window.getOffsettedBuffer( id );\n         PropertyRecord toReturn = getRecordFromBuffer( id, buffer );\n-        // if ( !toReturn.inUse() )\n-        // {\n-        // throw new InvalidRecordException( \"Record[\" + id + \"] not in use\" );\n-        // }\n+        if ( !toReturn.inUse() )\n+        {\n+            throw new InvalidRecordException( \"Record[\" + id + \"] not in use\" );\n+        }\n         return toReturn;\n     }\n ",
      "parent_sha": "fa032f60b1eb004007cbdf83bed048a3b450654f"
    }
  },
  {
    "oid": "244887bd4febff2b94f7e9464d6de222d5f443ce",
    "message": "Checkstyle fixes.",
    "date": "2017-05-25T14:41:00Z",
    "url": "https://github.com/neo4j/neo4j/commit/244887bd4febff2b94f7e9464d6de222d5f443ce",
    "details": {
      "sha": "cab0215cfabcbc296d4654d4bf4ea8da79dfa223",
      "filename": "community/kernel/src/test/java/org/neo4j/kernel/impl/api/StatementOperationsTestHelper.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/neo4j/neo4j/blob/244887bd4febff2b94f7e9464d6de222d5f443ce/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fapi%2FStatementOperationsTestHelper.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/244887bd4febff2b94f7e9464d6de222d5f443ce/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fapi%2FStatementOperationsTestHelper.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fapi%2FStatementOperationsTestHelper.java?ref=244887bd4febff2b94f7e9464d6de222d5f443ce",
      "patch": "@@ -79,7 +79,8 @@ public static KernelStatement mockedState( final TransactionState txState )\n         try\n         {\n             IndexReader indexReader = mock( IndexReader.class );\n-            when( indexReader.query( Matchers.isA( IndexQuery.ExactPredicate.class ) ) ).thenReturn( PrimitiveLongCollections.emptyIterator() );\n+            when( indexReader.query( Matchers.isA( IndexQuery.ExactPredicate.class ) ) )\n+                    .thenReturn( PrimitiveLongCollections.emptyIterator() );\n             StorageStatement storageStatement = mock( StorageStatement.class );\n             when( storageStatement.getIndexReader( Matchers.any() ) ).thenReturn( indexReader );\n             when( state.storageStatement() ).thenReturn( storageStatement );",
      "parent_sha": "13e3d20860f871d1c13c10429f2d4d31d6180c8b"
    }
  },
  {
    "oid": "5fa296050a232e6377ba82888f888911c2a07ff7",
    "message": "Fix RecordStorageReaderTests.\n\nIndex backed constraints should have owned indexes when we try to commit them.",
    "date": "2019-10-07T08:12:04Z",
    "url": "https://github.com/neo4j/neo4j/commit/5fa296050a232e6377ba82888f888911c2a07ff7",
    "details": {
      "sha": "157f640a90b665c86386a1f00e4cb0f86b43cc78",
      "filename": "community/community-it/record-storage-engine-it/src/test/java/org/neo4j/internal/recordstorage/RecordStorageReaderTestBase.java",
      "status": "modified",
      "additions": 8,
      "deletions": 4,
      "changes": 12,
      "blob_url": "https://github.com/neo4j/neo4j/blob/5fa296050a232e6377ba82888f888911c2a07ff7/community%2Fcommunity-it%2Frecord-storage-engine-it%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Finternal%2Frecordstorage%2FRecordStorageReaderTestBase.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/5fa296050a232e6377ba82888f888911c2a07ff7/community%2Fcommunity-it%2Frecord-storage-engine-it%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Finternal%2Frecordstorage%2FRecordStorageReaderTestBase.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fcommunity-it%2Frecord-storage-engine-it%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Finternal%2Frecordstorage%2FRecordStorageReaderTestBase.java?ref=5fa296050a232e6377ba82888f888911c2a07ff7",
      "patch": "@@ -169,8 +169,10 @@ void createUniquenessConstraint( Label label, String propertyKey ) throws Except\n     {\n         IndexDescriptor index = createUniqueIndex( label, propertyKey );\n         TxState txState = new TxState();\n-        UniquenessConstraintDescriptor constraint =\n-                ConstraintDescriptorFactory.uniqueForLabel( getOrCreateLabelId( label ), getOrCreatePropertyKeyId( propertyKey ) ).withName( index.getName() );\n+        int labelId = getOrCreateLabelId( label );\n+        int propertyKeyId = getOrCreatePropertyKeyId( propertyKey );\n+        UniquenessConstraintDescriptor constraint = ConstraintDescriptorFactory.uniqueForLabel( labelId, propertyKeyId );\n+        constraint = constraint.withName( index.getName() ).withOwnedIndexId( index.getId() );\n         txState.constraintDoAdd( constraint );\n         apply( txState );\n     }\n@@ -179,8 +181,10 @@ void createNodeKeyConstraint( Label label, String propertyKey ) throws Exception\n     {\n         IndexDescriptor index = createUniqueIndex( label, propertyKey );\n         TxState txState = new TxState();\n-        NodeKeyConstraintDescriptor constraint =\n-                ConstraintDescriptorFactory.nodeKeyForLabel( getOrCreateLabelId( label ), getOrCreatePropertyKeyId( propertyKey ) ).withName( index.getName() );\n+        int labelId = getOrCreateLabelId( label );\n+        int propertyKeyId = getOrCreatePropertyKeyId( propertyKey );\n+        NodeKeyConstraintDescriptor constraint = ConstraintDescriptorFactory.nodeKeyForLabel( labelId, propertyKeyId );\n+        constraint = constraint.withName( index.getName() ).withOwnedIndexId( index.getId() );\n         txState.constraintDoAdd( constraint );\n         apply( txState );\n     }",
      "parent_sha": "872c314adc57edde969e078f6fc989d805e412d8"
    }
  },
  {
    "oid": "fb94301b3a225581d69c611c71e61cbfcbefdb65",
    "message": "Improved an exception message to use \"-a\" option\n\n\ngit-svn-id: https://svn.neo4j.org/components/neo/trunk@1926 0b971d98-bb2f-0410-8247-b05b2b5feb2a",
    "date": "2008-06-25T15:22:02Z",
    "url": "https://github.com/neo4j/neo4j/commit/fb94301b3a225581d69c611c71e61cbfcbefdb65",
    "details": {
      "sha": "c9c334cae8d924f33f1a8c90352fa4c9446021c6",
      "filename": "community/src/java/org/neo4j/impl/shell/apps/Cd.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/neo4j/neo4j/blob/fb94301b3a225581d69c611c71e61cbfcbefdb65/community%2Fsrc%2Fjava%2Forg%2Fneo4j%2Fimpl%2Fshell%2Fapps%2FCd.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/fb94301b3a225581d69c611c71e61cbfcbefdb65/community%2Fsrc%2Fjava%2Forg%2Fneo4j%2Fimpl%2Fshell%2Fapps%2FCd.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fsrc%2Fjava%2Forg%2Fneo4j%2Fimpl%2Fshell%2Fapps%2FCd.java?ref=fb94301b3a225581d69c611c71e61cbfcbefdb65",
      "patch": "@@ -92,7 +92,8 @@ else if ( arg.equals( \".\" ) )\n \t\t\t\tif ( !absolute && !this.nodeIsConnected( currentNode, newId ) )\n \t\t\t\t{\n \t\t\t\t\tthrow new ShellException( \"Node \" + newId +\n-\t\t\t\t\t\t\" isn't connected to the current node\" );\n+\t\t\t\t\t\t\" isn't connected to the current node, use -a to \" +\n+\t\t\t\t\t\t\"force it to go to that node anyway\" );\n \t\t\t\t}\n \t\t\t\tpaths.add( currentNode.getId() );\n \t\t\t}",
      "parent_sha": "2ee80f32dd209780312e2779715ee3a41399107e"
    }
  },
  {
    "oid": "88d162cba23756d859fadfb2555bb913977c8f62",
    "message": "Fix to distunguish between recovery and HA apply log\n\n\ngit-svn-id: https://svn.neo4j.org/components/kernel/branches/ha@5149 0b971d98-bb2f-0410-8247-b05b2b5feb2a",
    "date": "2010-08-13T14:29:04Z",
    "url": "https://github.com/neo4j/neo4j/commit/88d162cba23756d859fadfb2555bb913977c8f62",
    "details": {
      "sha": "5c76f34122a0dafa80a079a2a26ec71c8ac5d67a",
      "filename": "community/src/main/java/org/neo4j/kernel/impl/nioneo/store/NeoStore.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/neo4j/neo4j/blob/88d162cba23756d859fadfb2555bb913977c8f62/community%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fnioneo%2Fstore%2FNeoStore.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/88d162cba23756d859fadfb2555bb913977c8f62/community%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fnioneo%2Fstore%2FNeoStore.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fnioneo%2Fstore%2FNeoStore.java?ref=88d162cba23756d859fadfb2555bb913977c8f62",
      "patch": "@@ -51,6 +51,7 @@ public class NeoStore extends AbstractStore\n     private RelationshipStore relStore;\n     private RelationshipTypeStore relTypeStore;\n     private final LastCommittedTxIdSetter lastCommittedTxIdSetter;\n+    private boolean isStarted;\n     \n     private final int REL_GRAB_SIZE;\n \n@@ -241,7 +242,7 @@ public synchronized void setLastCommittedTx( long txId )\n         }\n         setRecord( 3, txId );\n         // TODO Why check null here? because I have no time to fix the tests\n-        if ( lastCommittedTxIdSetter != null && txId == getLastCommittedTx()+1 )\n+        if ( isStarted && lastCommittedTxIdSetter != null && txId == getLastCommittedTx()+1 )\n         {\n             lastCommittedTxIdSetter.setLastCommittedTxId( txId );\n         }\n@@ -341,9 +342,9 @@ public void makeStoreOk()\n         relStore.makeStoreOk();\n         nodeStore.makeStoreOk();\n         super.makeStoreOk();\n+        isStarted = true;\n     }\n     \n-    \n     public void rebuildIdGenerators()\n     {\n         relTypeStore.rebuildIdGenerators();",
      "parent_sha": "3cc84faddc9c07f633a2f53ce5c5c85640587b6f"
    }
  },
  {
    "oid": "0927a240ce7a5be721a962e1f26cbb4b088d6fbc",
    "message": "Uses abstractions instead of accessing SchemaStore directly in test",
    "date": "2018-06-19T07:37:24Z",
    "url": "https://github.com/neo4j/neo4j/commit/0927a240ce7a5be721a962e1f26cbb4b088d6fbc",
    "details": {
      "sha": "510bb225595681b302f1a9f11c9356300c05301e",
      "filename": "community/community-it/index-it/src/test/java/org/neo4j/kernel/impl/api/index/IndexingServiceIntegrationTest.java",
      "status": "modified",
      "additions": 27,
      "deletions": 40,
      "changes": 67,
      "blob_url": "https://github.com/neo4j/neo4j/blob/0927a240ce7a5be721a962e1f26cbb4b088d6fbc/community%2Fcommunity-it%2Findex-it%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fapi%2Findex%2FIndexingServiceIntegrationTest.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/0927a240ce7a5be721a962e1f26cbb4b088d6fbc/community%2Fcommunity-it%2Findex-it%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fapi%2Findex%2FIndexingServiceIntegrationTest.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fcommunity-it%2Findex-it%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fapi%2Findex%2FIndexingServiceIntegrationTest.java?ref=0927a240ce7a5be721a962e1f26cbb4b088d6fbc",
      "patch": "@@ -27,7 +27,6 @@\n import org.junit.runner.RunWith;\n import org.junit.runners.Parameterized;\n \n-import java.io.IOException;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.concurrent.TimeUnit;\n@@ -41,21 +40,19 @@\n import org.neo4j.graphdb.Transaction;\n import org.neo4j.graphdb.mockfs.EphemeralFileSystemAbstraction;\n import org.neo4j.internal.kernel.api.InternalIndexState;\n+import org.neo4j.internal.kernel.api.Kernel;\n import org.neo4j.io.pagecache.IOLimiter;\n import org.neo4j.kernel.api.KernelTransaction;\n import org.neo4j.kernel.api.exceptions.index.IndexNotFoundKernelException;\n import org.neo4j.kernel.api.impl.schema.LuceneIndexProviderFactory;\n import org.neo4j.kernel.api.impl.schema.NativeLuceneFusionIndexProviderFactory10;\n import org.neo4j.kernel.api.impl.schema.NativeLuceneFusionIndexProviderFactory20;\n import org.neo4j.kernel.api.index.IndexProvider;\n-import org.neo4j.kernel.api.schema.index.StoreIndexDescriptor;\n+import org.neo4j.kernel.api.schema.RelationTypeSchemaDescriptor;\n import org.neo4j.kernel.api.schema.index.TestIndexDescriptorFactory;\n import org.neo4j.kernel.extension.KernelExtensionFactory;\n import org.neo4j.kernel.impl.api.index.inmemory.InMemoryIndexProviderFactory;\n import org.neo4j.kernel.impl.core.ThreadToStatementContextBridge;\n-import org.neo4j.kernel.impl.storageengine.impl.recordstorage.RecordStorageEngine;\n-import org.neo4j.kernel.impl.store.NeoStores;\n-import org.neo4j.kernel.impl.store.SchemaStore;\n import org.neo4j.kernel.impl.store.UnderlyingStorageException;\n import org.neo4j.kernel.internal.GraphDatabaseAPI;\n import org.neo4j.storageengine.api.schema.PopulationProgress;\n@@ -64,9 +61,10 @@\n \n import static java.util.Arrays.asList;\n import static org.junit.Assert.assertEquals;\n+import static org.neo4j.internal.kernel.api.Transaction.Type.explicit;\n+import static org.neo4j.internal.kernel.api.security.LoginContext.AUTH_DISABLED;\n import static org.neo4j.kernel.api.schema.SchemaDescriptorFactory.forLabel;\n import static org.neo4j.kernel.api.schema.SchemaDescriptorFactory.forRelType;\n-import static org.neo4j.kernel.api.schema.index.IndexDescriptorFactory.forSchema;\n \n @RunWith( Parameterized.class )\n public class IndexingServiceIntegrationTest\n@@ -123,17 +121,19 @@ public void tearDown()\n     }\n \n     @Test\n-    public void testManualIndexPopulation() throws IOException, IndexNotFoundKernelException, InterruptedException\n+    public void testManualIndexPopulation() throws InterruptedException, IndexNotFoundKernelException\n     {\n-        IndexingService indexingService = getIndexingService( database );\n-        SchemaStore schemaStore = getSchemaStore( database );\n+        try ( Transaction tx = database.beginTx() )\n+        {\n+            database.schema().indexFor( Label.label( FOOD_LABEL ) ).on( PROPERTY_NAME ).create();\n+            tx.success();\n+        }\n \n-        int foodId = getLabelId( FOOD_LABEL );\n-        int propertyId = getPropertyKeyId( PROPERTY_NAME );\n+        int labelId = getLabelId( FOOD_LABEL );\n+        int propertyKeyId = getPropertyKeyId( PROPERTY_NAME );\n \n-        StoreIndexDescriptor rule = forSchema( forLabel( foodId, propertyId ), indexDescriptor ).withId( schemaStore.nextId() );\n-        indexingService.createIndexes( rule );\n-        IndexProxy indexProxy = indexingService.getIndexProxy( rule.getId() );\n+        IndexingService indexingService = getIndexingService( database );\n+        IndexProxy indexProxy = indexingService.getIndexProxy( forLabel( labelId, propertyKeyId ) );\n \n         waitIndexOnline( indexProxy );\n         assertEquals( InternalIndexState.ONLINE, indexProxy.getState() );\n@@ -142,17 +142,21 @@ public void testManualIndexPopulation() throws IOException, IndexNotFoundKernelE\n     }\n \n     @Test\n-    public void testManualRelationshipIndexPopulation() throws IOException, IndexNotFoundKernelException, InterruptedException\n+    public void testManualRelationshipIndexPopulation() throws Exception\n     {\n-        IndexingService indexingService = getIndexingService( database );\n-        SchemaStore schemaStore = getSchemaStore( database );\n-\n-        int foodId = getRelationshipTypeId( FOOD_LABEL );\n-        int propertyId = getPropertyKeyId( PROPERTY_NAME );\n+        RelationTypeSchemaDescriptor descriptor;\n+        try ( org.neo4j.internal.kernel.api.Transaction tx =\n+                ((GraphDatabaseAPI) database).getDependencyResolver().resolveDependency( Kernel.class ).beginTransaction( explicit, AUTH_DISABLED ) )\n+        {\n+            int foodId = tx.tokenWrite().relationshipTypeGetOrCreateForName( FOOD_LABEL );\n+            int propertyId = tx.tokenWrite().propertyKeyGetOrCreateForName( PROPERTY_NAME );\n+            descriptor = forRelType( foodId, propertyId );\n+            tx.schemaWrite().indexCreate( descriptor );\n+            tx.success();\n+        }\n \n-        StoreIndexDescriptor rule = forSchema( forRelType( foodId, propertyId ), indexDescriptor ).withId( schemaStore.nextId() );\n-        indexingService.createIndexes( rule );\n-        IndexProxy indexProxy = indexingService.getIndexProxy( rule.getId() );\n+        IndexingService indexingService = getIndexingService( database );\n+        IndexProxy indexProxy = indexingService.getIndexProxy( descriptor );\n \n         waitIndexOnline( indexProxy );\n         assertEquals( InternalIndexState.ONLINE, indexProxy.getState() );\n@@ -232,13 +236,6 @@ private void waitIndexOnline( IndexProxy indexProxy ) throws InterruptedExceptio\n         }\n     }\n \n-    private SchemaStore getSchemaStore( GraphDatabaseService database )\n-    {\n-        NeoStores neoStores = getDependencyResolver( database )\n-                .resolveDependency( RecordStorageEngine.class ).testAccessNeoStores();\n-        return neoStores.getSchemaStore();\n-    }\n-\n     private IndexingService getIndexingService( GraphDatabaseService database )\n     {\n         return getDependencyResolver(database).resolveDependency( IndexingService.class );\n@@ -286,14 +283,4 @@ private int getLabelId( String name )\n             return transaction.tokenRead().nodeLabel( name );\n         }\n     }\n-\n-    private int getRelationshipTypeId( String name )\n-    {\n-        try ( Transaction tx = database.beginTx() )\n-        {\n-            KernelTransaction transaction = ((GraphDatabaseAPI) database).getDependencyResolver().resolveDependency(\n-                    ThreadToStatementContextBridge.class ).getKernelTransactionBoundToThisThread( true );\n-            return transaction.tokenRead().relationshipType( name );\n-        }\n-    }\n }",
      "parent_sha": "7355d3f7fe8385814adb08aaa80857a7c15ed172"
    }
  },
  {
    "oid": "5e927208fb0172b3cd92bbd589dd228415f26657",
    "message": "Made EmbeddedNeo.getAllNodes() return a proper Iterable, instead of the current one-shot iterable, where the iterable and iterator were the same objects.\n\ngit-svn-id: https://svn.neo4j.org/components/neo/trunk@2808 0b971d98-bb2f-0410-8247-b05b2b5feb2a",
    "date": "2009-05-03T13:02:28Z",
    "url": "https://github.com/neo4j/neo4j/commit/5e927208fb0172b3cd92bbd589dd228415f26657",
    "details": {
      "sha": "a2dc7c17f3a5c4ea76e2af51aa0a2ed5fbc7ceb7",
      "filename": "enterprise/src/java/org/neo4j/api/core/EmbeddedNeo.java",
      "status": "modified",
      "additions": 8,
      "deletions": 9,
      "changes": 17,
      "blob_url": "https://github.com/neo4j/neo4j/blob/5e927208fb0172b3cd92bbd589dd228415f26657/enterprise%2Fsrc%2Fjava%2Forg%2Fneo4j%2Fapi%2Fcore%2FEmbeddedNeo.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/5e927208fb0172b3cd92bbd589dd228415f26657/enterprise%2Fsrc%2Fjava%2Forg%2Fneo4j%2Fapi%2Fcore%2FEmbeddedNeo.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/enterprise%2Fsrc%2Fjava%2Forg%2Fneo4j%2Fapi%2Fcore%2FEmbeddedNeo.java?ref=5e927208fb0172b3cd92bbd589dd228415f26657",
      "patch": "@@ -392,14 +392,18 @@ public String toString()\n     \n     public Iterable<Node> getAllNodes()\n     {\n-        long highId = (nodeManager.getHighestPossibleIdInUse( Node.class ) &\n-            0xFFFFFFFFL );\n-        return new AllNodesIterator( highId );\n+        return new Iterable<Node>() {\n+            public Iterator<Node> iterator() {\n+                long highId = (nodeManager.getHighestPossibleIdInUse(Node.class)\n+                        & 0xFFFFFFFFL);\n+                return new AllNodesIterator(highId);\n+            }\n+        };\n     }\n     \n     // TODO: temporary all nodes getter, fix this with better implementation\n     // (no NotFoundException to control flow)\n-    private class AllNodesIterator implements Iterator<Node>, Iterable<Node>\n+    private class AllNodesIterator implements Iterator<Node>\n     {\n         private final long highId;\n         private long currentNodeId = 0;\n@@ -441,10 +445,5 @@ public void remove()\n         {\n             throw new UnsupportedOperationException();\n         }\n-\n-        public Iterator<Node> iterator()\n-        {\n-            return this;\n-        }\n     }\n }\n\\ No newline at end of file",
      "parent_sha": "b57aceb0595f55ba841890183d2093af26c9bb20"
    }
  },
  {
    "oid": "5ed9d0c1cd79f98264bbd58194ab00e30d462755",
    "message": "validate passed relationships internal transaction",
    "date": "2020-09-11T09:09:56Z",
    "url": "https://github.com/neo4j/neo4j/commit/5ed9d0c1cd79f98264bbd58194ab00e30d462755",
    "details": {
      "sha": "9a4ee3711eafe03a23bd5ffc1f67ea1b1db137ab",
      "filename": "community/procedure/src/main/java/org/neo4j/procedure/impl/ProcedureCompilation.java",
      "status": "modified",
      "additions": 8,
      "deletions": 6,
      "changes": 14,
      "blob_url": "https://github.com/neo4j/neo4j/blob/5ed9d0c1cd79f98264bbd58194ab00e30d462755/community%2Fprocedure%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fprocedure%2Fimpl%2FProcedureCompilation.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/5ed9d0c1cd79f98264bbd58194ab00e30d462755/community%2Fprocedure%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fprocedure%2Fimpl%2FProcedureCompilation.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fprocedure%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fprocedure%2Fimpl%2FProcedureCompilation.java?ref=5ed9d0c1cd79f98264bbd58194ab00e30d462755",
      "patch": "@@ -980,15 +980,17 @@ else if ( type.equals( TEMPORAL_AMOUNT ) )\n         else if ( type.equals( NODE ) )\n         {\n             Expression internalTransaction = invoke( context, methodReference( Context.class, InternalTransaction.class, \"internalTransactionOrNull\" ) );\n-            Expression getNode = invoke( internalTransaction, methodReference( InternalTransaction.class, Entity.class, \"validateSameDB\", Entity.class ), expression );\n-            return nullCheck( expression,\n-                              invoke( methodReference( ValueUtils.class, NodeValue.class, \"fromNodeEntity\", Node.class ),\n-                                      getNode ) );\n+            Expression getNode = invoke( internalTransaction,\n+                                         methodReference( InternalTransaction.class, Entity.class, \"validateSameDB\", Entity.class ), expression );\n+            return nullCheck( expression, invoke( methodReference( ValueUtils.class, NodeValue.class, \"fromNodeEntity\", Node.class ), getNode ) );\n         }\n         else if ( type.equals( RELATIONSHIP ) )\n         {\n-            return nullCheck( expression, invoke( methodReference( ValueUtils.class, RelationshipValue.class, \"fromRelationshipEntity\",\n-                    Relationship.class ), expression ));\n+            Expression internalTransaction = invoke( context, methodReference( Context.class, InternalTransaction.class, \"internalTransactionOrNull\" ) );\n+            Expression getRelationship =\n+                    invoke( internalTransaction, methodReference( InternalTransaction.class, Entity.class, \"validateSameDB\", Entity.class ), expression );\n+            return nullCheck( expression, invoke(\n+                    methodReference( ValueUtils.class, RelationshipValue.class, \"fromRelationshipEntity\", Relationship.class ), getRelationship ) );\n         }\n         else if ( type.equals( PATH ) )\n         {",
      "parent_sha": "0e9d60e49650efa3bf89d7e595991a0acaa99b2e"
    }
  },
  {
    "oid": "1aedf3929bb01fbe4007fc341dba7da8e0705314",
    "message": "more formating",
    "date": "2011-10-10T16:15:39Z",
    "url": "https://github.com/neo4j/neo4j/commit/1aedf3929bb01fbe4007fc341dba7da8e0705314",
    "details": {
      "sha": "a84e858c6659cbeada9935ebd230835af43d5d9d",
      "filename": "community/cypher/src/test/java/org/neo4j/cypher/javacompat/IntroExamplesTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/neo4j/neo4j/blob/1aedf3929bb01fbe4007fc341dba7da8e0705314/community%2Fcypher%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fcypher%2Fjavacompat%2FIntroExamplesTest.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/1aedf3929bb01fbe4007fc341dba7da8e0705314/community%2Fcypher%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fcypher%2Fjavacompat%2FIntroExamplesTest.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fcypher%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fcypher%2Fjavacompat%2FIntroExamplesTest.java?ref=1aedf3929bb01fbe4007fc341dba7da8e0705314",
      "patch": "@@ -87,7 +87,7 @@ public void intro_examples() throws Exception\n                 + \") MATCH user-[:friend]->follower WHERE follower.name =~ /S.*/ RETURN user, follower.name \";\n         fw.append( \"\\n\" );\n         fw.append( createCypherSnippet( query ) );\n-        fw.append( \"\\nResulting in \\n\" );\n+        fw.append( \"\\nResulting in\\n\\n\" );\n         fw.append( createQueryResultSnippet( engine.execute(\n                 parser.parse( query ) ).toString() ) );\n         fw.close();",
      "parent_sha": "1d26a194f9d3ddeff128223f407e93ceb0485511"
    }
  },
  {
    "oid": "721e3cc02e9a6f368e1632c0658a4f3cfe6f92a5",
    "message": "Small cleanup in `RunnableBoltWorker`",
    "date": "2017-01-24T16:11:43Z",
    "url": "https://github.com/neo4j/neo4j/commit/721e3cc02e9a6f368e1632c0658a4f3cfe6f92a5",
    "details": {
      "sha": "cfed792a953c9d28cb9eddb5befa0d2b208522d7",
      "filename": "community/bolt/src/main/java/org/neo4j/bolt/v1/runtime/concurrent/RunnableBoltWorker.java",
      "status": "modified",
      "additions": 7,
      "deletions": 3,
      "changes": 10,
      "blob_url": "https://github.com/neo4j/neo4j/blob/721e3cc02e9a6f368e1632c0658a4f3cfe6f92a5/community%2Fbolt%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fbolt%2Fv1%2Fruntime%2Fconcurrent%2FRunnableBoltWorker.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/721e3cc02e9a6f368e1632c0658a4f3cfe6f92a5/community%2Fbolt%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fbolt%2Fv1%2Fruntime%2Fconcurrent%2FRunnableBoltWorker.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fbolt%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fbolt%2Fv1%2Fruntime%2Fconcurrent%2FRunnableBoltWorker.java?ref=721e3cc02e9a6f368e1632c0658a4f3cfe6f92a5",
      "patch": "@@ -20,7 +20,9 @@\n package org.neo4j.bolt.v1.runtime.concurrent;\n \n import java.util.ArrayList;\n+import java.util.List;\n import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.TimeUnit;\n \n import org.neo4j.bolt.v1.runtime.BoltConnectionAuthFatality;\n@@ -39,7 +41,7 @@ class RunnableBoltWorker implements Runnable, BoltWorker\n {\n     private static final int workQueueSize = Integer.getInteger( \"org.neo4j.bolt.workQueueSize\", 100 );\n \n-    private final ArrayBlockingQueue<Job> jobQueue = new ArrayBlockingQueue<>( workQueueSize );\n+    private final BlockingQueue<Job> jobQueue = new ArrayBlockingQueue<>( workQueueSize );\n     private final BoltStateMachine machine;\n     private final Log log;\n     private final Log userLog;\n@@ -58,6 +60,7 @@ class RunnableBoltWorker implements Runnable, BoltWorker\n      * possible.\n      * @param job an operation to be performed on the session\n      */\n+    @Override\n     public void enqueue( Job job )\n     {\n         try\n@@ -66,6 +69,7 @@ public void enqueue( Job job )\n         }\n         catch ( InterruptedException e )\n         {\n+            Thread.currentThread().interrupt();\n             throw new RuntimeException( \"Worker interrupted while queueing request, the session may have been \" +\n                     \"forcibly closed, or the database may be shutting down.\" );\n         }\n@@ -74,7 +78,7 @@ public void enqueue( Job job )\n     @Override\n     public void run()\n     {\n-        ArrayList<Job> batch = new ArrayList<>( workQueueSize );\n+        List<Job> batch = new ArrayList<>( workQueueSize );\n \n         try\n         {\n@@ -111,7 +115,7 @@ public void run()\n         }\n     }\n \n-    private void executeBatch( ArrayList<Job> batch ) throws BoltConnectionFatality\n+    private void executeBatch( List<Job> batch ) throws BoltConnectionFatality\n     {\n         for ( int i = 0; keepRunning && i < batch.size(); i++ )\n         {",
      "parent_sha": "3a91140c7e53a5da13d66e6f4b264fb618c0973a"
    }
  },
  {
    "oid": "aced0c23768f7170a48e30ee409d31481c449f52",
    "message": "Make closed flag volatile",
    "date": "2019-02-21T13:32:16Z",
    "url": "https://github.com/neo4j/neo4j/commit/aced0c23768f7170a48e30ee409d31481c449f52",
    "details": {
      "sha": "d1c71ac05791435c5d4afc7b2b1410daf1740f92",
      "filename": "community/kernel/src/main/java/org/neo4j/kernel/impl/index/schema/BlockBasedIndexPopulator.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/neo4j/neo4j/blob/aced0c23768f7170a48e30ee409d31481c449f52/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Findex%2Fschema%2FBlockBasedIndexPopulator.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/aced0c23768f7170a48e30ee409d31481c449f52/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Findex%2Fschema%2FBlockBasedIndexPopulator.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Findex%2Fschema%2FBlockBasedIndexPopulator.java?ref=aced0c23768f7170a48e30ee409d31481c449f52",
      "patch": "@@ -368,7 +368,7 @@ public IndexUpdater newPopulatingUpdater()\n \n         return new IndexUpdater()\n         {\n-            private boolean closed;\n+            private volatile boolean closed;\n \n             @Override\n             public void process( IndexEntryUpdate<?> update )",
      "parent_sha": "fba45b7fababf5116ec32a60d01c9f7c09741b26"
    }
  },
  {
    "oid": "42e6683e5ce628a246dd166cda4da5ca713e8043",
    "message": "Restore constraint creation behaviour for half applied constraints\n\nWhen an index already exists from a previous failed attempt at creating\na constraint we try to adopt that index when we try and recreate that\nconstraint. In that case we allow collision on name and schema.\nThis behaviour will be changed soon but for now we restore\nthat behaviour.",
    "date": "2019-10-03T13:01:17Z",
    "url": "https://github.com/neo4j/neo4j/commit/42e6683e5ce628a246dd166cda4da5ca713e8043",
    "details": {
      "sha": "13f1a77acae6b92dd720b28abe9cd55f6e0a09ee",
      "filename": "community/kernel/src/main/java/org/neo4j/kernel/impl/newapi/Operations.java",
      "status": "modified",
      "additions": 36,
      "deletions": 3,
      "changes": 39,
      "blob_url": "https://github.com/neo4j/neo4j/blob/42e6683e5ce628a246dd166cda4da5ca713e8043/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fnewapi%2FOperations.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/42e6683e5ce628a246dd166cda4da5ca713e8043/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fnewapi%2FOperations.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fnewapi%2FOperations.java?ref=42e6683e5ce628a246dd166cda4da5ca713e8043",
      "patch": "@@ -970,7 +970,7 @@ private void assertNoBlockingSchemaRulesExists( IndexPrototype prototype )\n         }\n \n         // Name conflict with other schema rule\n-        assertSchemaRuleWithNameDoesNotExist( name );\n+        assertSchemaRuleWithNameDoesNotExist( name, null );\n \n         // Already constrained\n         final Iterator<ConstraintDescriptor> constraintWithSameSchema = allStoreHolder.constraintsGetForSchema( prototype.schema() );\n@@ -1012,7 +1012,7 @@ private void assertNoBlockingSchemaRulesExists( ConstraintDescriptor constraint\n         }\n \n         // Name conflict with other schema rule\n-        assertSchemaRuleWithNameDoesNotExist( name );\n+        assertSchemaRuleWithNameDoesNotExist( name, constraint );\n \n         // Already constrained\n         for ( ConstraintDescriptor constraintWithSameSchema : constraintsWithSameSchema )\n@@ -1030,12 +1030,19 @@ private void assertNoBlockingSchemaRulesExists( ConstraintDescriptor constraint\n             IndexDescriptor indexWithSameSchema = allStoreHolder.index( constraint.schema() );\n             if ( indexWithSameSchema != IndexDescriptor.NO_INDEX )\n             {\n+                // todo remove this bit once we remove support for adopting half applied constraints\n+                if ( isIndexFromHalfAppliedConstraint( indexWithSameSchema, constraint ) )\n+                {\n+                    return;\n+                }\n+\n                 throw new AlreadyIndexedException( constraint.schema(), CONSTRAINT_CREATION );\n             }\n         }\n     }\n \n-    private void assertSchemaRuleWithNameDoesNotExist( String name ) throws IndexWithNameAlreadyExistsException, ConstraintWithNameAlreadyExistsException\n+    private void assertSchemaRuleWithNameDoesNotExist( String name, ConstraintDescriptor constraintDescriptor )\n+            throws IndexWithNameAlreadyExistsException, ConstraintWithNameAlreadyExistsException\n     {\n         // Check constraints first because some of them will also be backed by indexes\n         final ConstraintDescriptor constraintWithSameName = allStoreHolder.constraintGetForName( name );\n@@ -1046,10 +1053,36 @@ private void assertSchemaRuleWithNameDoesNotExist( String name ) throws IndexWit\n         final IndexDescriptor indexWithSameName = allStoreHolder.indexGetForName( name );\n         if ( indexWithSameName != IndexDescriptor.NO_INDEX )\n         {\n+            // todo remove this bit once we remove support for adopting half applied constraints\n+            if ( constraintDescriptor != null && isIndexFromHalfAppliedConstraint( indexWithSameName, constraintDescriptor ) )\n+            {\n+                // Simply return and be happy this will be removed in the future\n+                return;\n+            }\n             throw new IndexWithNameAlreadyExistsException( name );\n         }\n     }\n \n+    private boolean isIndexFromHalfAppliedConstraint( IndexDescriptor index, ConstraintDescriptor constraint )\n+    {\n+        // OK so we found an index that collide with constraint in some way.\n+        // This might be a left-over from a previously failed constraints creation.\n+        // Check if it matches the index that would back the constraint we are trying to create.\n+        // - existing index is a uniqueness index\n+        // - existing index name match that of constraint\n+        // - existing index schema match that of constraint\n+        // - existing index does not already have owning constraint\n+        return index.isUnique() &&\n+               index.getName().equals( constraint.getName() ) &&\n+               index.schema().equals( constraint.schema() ) &&\n+               !constraintIndexHasOwner( index );\n+    }\n+\n+    private boolean constraintIndexHasOwner( IndexDescriptor index )\n+    {\n+        return allStoreHolder.indexGetOwningUniquenessConstraintId( index ) != null;\n+    }\n+\n     @Override\n     public ConstraintDescriptor nodeKeyConstraintCreate( LabelSchemaDescriptor descriptor, String name ) throws KernelException\n     {",
      "parent_sha": "ceae4b9ff4afc63c906fb00c76e719c700e80f8c"
    }
  },
  {
    "oid": "5aeb9f97f5c4fac43da8e724cc229a2ee02b363d",
    "message": "http DELETE requires the proper mediatype to accept\n\ngit-svn-id: https://svn.neo4j.org/components/server/trunk@7811 0b971d98-bb2f-0410-8247-b05b2b5feb2a",
    "date": "2010-12-17T08:53:20Z",
    "url": "https://github.com/neo4j/neo4j/commit/5aeb9f97f5c4fac43da8e724cc229a2ee02b363d",
    "details": {
      "sha": "1f258e16a2788b47dc7ccd93ded23637309d83eb",
      "filename": "packaging/src/functionaltest/java/org/neo4j/server/rest/RemoveRelationshipFunctionalTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/neo4j/neo4j/blob/5aeb9f97f5c4fac43da8e724cc229a2ee02b363d/packaging%2Fsrc%2Ffunctionaltest%2Fjava%2Forg%2Fneo4j%2Fserver%2Frest%2FRemoveRelationshipFunctionalTest.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/5aeb9f97f5c4fac43da8e724cc229a2ee02b363d/packaging%2Fsrc%2Ffunctionaltest%2Fjava%2Forg%2Fneo4j%2Fserver%2Frest%2FRemoveRelationshipFunctionalTest.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/packaging%2Fsrc%2Ffunctionaltest%2Fjava%2Forg%2Fneo4j%2Fserver%2Frest%2FRemoveRelationshipFunctionalTest.java?ref=5aeb9f97f5c4fac43da8e724cc229a2ee02b363d",
      "patch": "@@ -36,6 +36,8 @@\n import com.sun.jersey.api.client.ClientResponse;\n import com.sun.jersey.api.client.WebResource;\n \n+import javax.ws.rs.core.MediaType;\n+\n public class RemoveRelationshipFunctionalTest {\n \n     private NeoServer server;\n@@ -76,8 +78,8 @@ public void shouldGet404WhenRemovingAnInvalidRelationship() throws Exception {\n \n     private ClientResponse sendDeleteRequest(URI requestUri) {\n         Client client = Client.create();\n-        WebResource resource = client.resource(requestUri);\n-        ClientResponse response = resource.delete(ClientResponse.class);\n+        WebResource.Builder resource = client.resource(requestUri).accept( MediaType.APPLICATION_JSON );\n+        ClientResponse response = resource.delete( ClientResponse.class );\n         return response;\n     }\n }",
      "parent_sha": "6127777287f89143ec988ec372bb0d4ab1934bc3"
    }
  },
  {
    "oid": "d41c80b7803142bf7838b3a4a0878a6d43f3dbd9",
    "message": "Cleanup InternalTreeLogicTest\n\n1. Don't rely on raw long values. Instead use the long\nvalue as a seed that indicate sorting order.\n\n2. Use special assert method for comparing keys and values.\n\nBoth of those those steps is to make it possible to make this\ntest generic on key and value later.\n\n3. Also add missing assertion on removed valued.",
    "date": "2018-01-16T11:08:18Z",
    "url": "https://github.com/neo4j/neo4j/commit/d41c80b7803142bf7838b3a4a0878a6d43f3dbd9",
    "details": {
      "sha": "2be30603b5ab80e2caebbc43c230dfa6bd39f48b",
      "filename": "community/index/src/test/java/org/neo4j/index/internal/gbptree/InternalTreeLogicTest.java",
      "status": "modified",
      "additions": 277,
      "deletions": 288,
      "changes": 565,
      "blob_url": "https://github.com/neo4j/neo4j/blob/d41c80b7803142bf7838b3a4a0878a6d43f3dbd9/community%2Findex%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Findex%2Finternal%2Fgbptree%2FInternalTreeLogicTest.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/d41c80b7803142bf7838b3a4a0878a6d43f3dbd9/community%2Findex%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Findex%2Finternal%2Fgbptree%2FInternalTreeLogicTest.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Findex%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Findex%2Finternal%2Fgbptree%2FInternalTreeLogicTest.java?ref=d41c80b7803142bf7838b3a4a0878a6d43f3dbd9",
      "patch": "@@ -71,10 +71,7 @@ public class InternalTreeLogicTest\n     private final PageAwareByteArrayCursor readCursor = cursor.duplicate();\n     private final int maxKeyCount = node.leafMaxKeyCount();\n \n-    private final MutableLong insertKey = new MutableLong();\n-    private final MutableLong insertValue = new MutableLong();\n-    private final MutableLong readKey = new MutableLong();\n-    private final MutableLong readValue = new MutableLong();\n+    private final MutableLong dontCare = layout.newValue();\n     private final StructurePropagation<MutableLong> structurePropagation = new StructurePropagation<>(\n             layout.newKey(), layout.newKey(), layout.newKey() );\n \n@@ -123,8 +120,8 @@ public void modifierMustInsertAtFirstPositionInEmptyLeaf() throws Exception\n     {\n         // given\n         initialize();\n-        long key = 1L;\n-        long value = 1L;\n+        MutableLong key = key( 1L );\n+        MutableLong value = value( 1L );\n         goTo( readCursor, rootId );\n         assertThat( keyCount(), is( 0 ) );\n \n@@ -135,8 +132,8 @@ public void modifierMustInsertAtFirstPositionInEmptyLeaf() throws Exception\n         // then\n         goTo( readCursor, rootId );\n         assertThat( keyCount(), is( 1 ) );\n-        assertThat( keyAt( 0, LEAF ), is( key ) );\n-        assertThat( valueAt( 0 ), is( key ) );\n+        assertEqualsKey( keyAt( 0, LEAF ), key );\n+        assertEqualValues( valueAt( 0 ), value );\n     }\n \n     @Test\n@@ -145,16 +142,18 @@ public void modifierMustSortCorrectlyOnInsertFirstInLeaf() throws Exception\n         // given\n         initialize();\n         generationManager.checkpoint();\n+\n         for ( int i = 0; i < maxKeyCount; i++ )\n         {\n             // when\n-            long key = maxKeyCount - i;\n-            insert( key, key );\n+            MutableLong key = key( maxKeyCount - i );\n+            MutableLong value = value( maxKeyCount - i );\n+            insert( key, value );\n \n             // then\n             readCursor.next( rootId );\n-            assertThat( keyAt( 0, LEAF ), is( key ) );\n-            assertThat( valueAt( 0 ), is( key ) );\n+            assertEqualsKey( keyAt( 0, LEAF ), key );\n+            assertEqualValues( valueAt( 0 ), value );\n         }\n     }\n \n@@ -167,12 +166,14 @@ public void modifierMustSortCorrectlyOnInsertLastInLeaf() throws Exception\n         for ( int i = 0; i < maxKeyCount; i++ )\n         {\n             // when\n-            insert( i, i );\n+            MutableLong key = key( i );\n+            MutableLong value = value( i );\n+            insert( key, value );\n \n             // then\n             readCursor.next( rootId );\n-            assertThat( keyAt( i, LEAF ), is( (long) i ) );\n-            assertThat( valueAt( i ), is( (long) i ) );\n+            assertEqualsKey( keyAt( i, LEAF ), key );\n+            assertEqualValues( valueAt( i ), value );\n         }\n     }\n \n@@ -185,12 +186,14 @@ public void modifierMustSortCorrectlyOnInsertInMiddleOfLeaf() throws Exception\n         for ( int i = 0; i < maxKeyCount; i++ )\n         {\n             // when\n-            long key = i % 2 == 0 ? i / 2 : maxKeyCount - i / 2;\n-            insert( key, key );\n+            long middleValue = i % 2 == 0 ? i / 2 : maxKeyCount - i / 2;\n+            MutableLong key = key( middleValue );\n+            MutableLong value = value( middleValue );\n+            insert( key, value );\n \n             // then\n             readCursor.next( rootId );\n-            assertThat( keyAt( (i + 1) / 2, LEAF ), is( key ) );\n+            assertEqualsKey( keyAt( (i + 1) / 2, LEAF ), key );\n         }\n     }\n \n@@ -201,14 +204,14 @@ public void modifierMustSplitWhenInsertingMiddleOfFullLeaf() throws Exception\n         initialize();\n         for ( int i = 0; i < maxKeyCount; i++ )\n         {\n-            long key = i % 2 == 0 ? i : maxKeyCount * 2 - i;\n-            insert( key, key );\n+            long middle = i % 2 == 0 ? i : maxKeyCount * 2 - i;\n+            insert( key( middle ), value( middle ) );\n         }\n \n         // when\n         generationManager.checkpoint();\n         long middle = maxKeyCount;\n-        insert( middle, middle );\n+        insert( key( middle ), value( middle ) );\n \n         // then\n         assertEquals( 1, numberOfRootSplits );\n@@ -219,17 +222,16 @@ public void modifierMustSplitWhenInsertingLastInFullLeaf() throws Exception\n     {\n         // given\n         initialize();\n-        long key = 0;\n-        while ( key < maxKeyCount )\n+        long keyValue;\n+        for ( keyValue = 0; keyValue < maxKeyCount; keyValue++ )\n         {\n-            insert( key, key );\n+            insert( key( keyValue ), value( keyValue ) );\n             assertFalse( structurePropagation.hasRightKeyInsert );\n-            key++;\n         }\n \n         // when\n         generationManager.checkpoint();\n-        insert( key, key );\n+        insert( key( keyValue ), value( keyValue ) );\n \n         // then\n         assertEquals( 1, numberOfRootSplits ); // Should cause a split\n@@ -242,14 +244,14 @@ public void modifierMustSplitWhenInsertingFirstInFullLeaf() throws Exception\n         initialize();\n         for ( int i = 0; i < maxKeyCount; i++ )\n         {\n-            long key = i + 1;\n-            insert( key, key );\n+            long keyValue = i + 1;\n+            insert( key( keyValue ), value( keyValue ) );\n             assertFalse( structurePropagation.hasRightKeyInsert );\n         }\n \n         // when\n         generationManager.checkpoint();\n-        insert( 0L, 0L );\n+        insert( key( 0L ), value( 0L ) );\n \n         // then\n         assertEquals( 1, numberOfRootSplits );\n@@ -264,14 +266,20 @@ public void modifierMustUpdatePointersInSiblingsToSplit() throws Exception\n         long i = 0;\n         while ( i < maxKeyCount )\n         {\n-            insert( someLargeNumber - i, i );\n+            MutableLong key = key( someLargeNumber - i );\n+            MutableLong value = value( i );\n+            insert( key, value );\n             i++;\n         }\n \n         // First split\n-        generationManager.checkpoint();\n-        insert( someLargeNumber - i, i );\n-        i++;\n+        {\n+            generationManager.checkpoint();\n+            MutableLong key = key( someLargeNumber - i );\n+            MutableLong value = value( i );\n+            insert( key, value );\n+            i++;\n+        }\n \n         // Assert child pointers and sibling pointers are intact after split in root\n         goTo( readCursor, rootId );\n@@ -282,7 +290,9 @@ public void modifierMustUpdatePointersInSiblingsToSplit() throws Exception\n         // Insert until we have another split in leftmost leaf\n         while ( keyCount( rootId ) == 1 )\n         {\n-            insert( someLargeNumber - i, i );\n+            MutableLong key = key( someLargeNumber - i );\n+            MutableLong value = value( i );\n+            insert( key, value );\n             i++;\n         }\n \n@@ -305,17 +315,21 @@ public void modifierMustRemoveFirstInEmptyLeaf() throws Exception\n     {\n         // given\n         initialize();\n-        long key = 1L;\n-        long value = 1L;\n+        long keyValue = 1L;\n+        long valueValue = 1L;\n+        MutableLong key = key( keyValue );\n+        MutableLong value = value( valueValue );\n         insert( key, value );\n \n         // when\n         generationManager.checkpoint();\n+        MutableLong readValue = layout.newValue();\n         remove( key, readValue );\n \n         // then\n         goTo( readCursor, rootId );\n         assertThat( TreeNode.keyCount( cursor ), is( 0 ) );\n+        assertEqualValues( value, readValue );\n     }\n \n     @Test\n@@ -325,19 +339,23 @@ public void modifierMustRemoveFirstInFullLeaf() throws Exception\n         initialize();\n         for ( int i = 0; i < maxKeyCount; i++ )\n         {\n-            insert( i, i );\n+            MutableLong key = key( i );\n+            MutableLong value = value( i );\n+            insert( key, value );\n         }\n \n         // when\n         generationManager.checkpoint();\n-        remove( 0, readValue );\n+        MutableLong readValue = layout.newValue();\n+        remove( key( 0 ), readValue );\n \n         // then\n+        assertEqualValues( value( 0 ), readValue );\n         goTo( readCursor, rootId );\n         assertThat( TreeNode.keyCount( readCursor ), is( maxKeyCount - 1 ) );\n         for ( int i = 0; i < maxKeyCount - 1; i++ )\n         {\n-            assertThat( keyAt( i, LEAF ), is( i + 1L ) );\n+            assertEqualsKey( keyAt( i, LEAF ), key( i + 1L ) );\n         }\n     }\n \n@@ -349,21 +367,23 @@ public void modifierMustRemoveInMiddleInFullLeaf() throws Exception\n         int middle = maxKeyCount / 2;\n         for ( int i = 0; i < maxKeyCount; i++ )\n         {\n-            insert( i, i );\n+            insert( key( i ), value( i ) );\n         }\n \n         // when\n         generationManager.checkpoint();\n-        remove( middle, readValue );\n+        MutableLong readValue = layout.newValue();\n+        remove( key( middle ), readValue );\n \n         // then\n+        assertEqualValues( value( middle ), readValue );\n         goTo( readCursor, rootId );\n         assertThat( keyCount(), is( maxKeyCount - 1 ) );\n-        assertThat( keyAt( middle, LEAF ), is( middle + 1L ) );\n+        assertEqualsKey( keyAt( middle, LEAF ), key( middle + 1L ) );\n         for ( int i = 0; i < maxKeyCount - 1; i++ )\n         {\n             long expected = i < middle ? i : i + 1L;\n-            assertThat( keyAt( i, LEAF ), is( expected ) );\n+            assertEqualsKey( keyAt( i, LEAF ), key( expected ) );\n         }\n     }\n \n@@ -373,20 +393,21 @@ public void modifierMustRemoveLastInFullLeaf() throws Exception\n         initialize();\n         for ( int i = 0; i < maxKeyCount; i++ )\n         {\n-            insert( i, i );\n+            insert( key( i ), value( i ) );\n         }\n \n         // when\n         generationManager.checkpoint();\n-        remove( maxKeyCount - 1, readValue );\n+        MutableLong readValue = layout.newValue();\n+        remove( key( maxKeyCount - 1 ), readValue );\n \n         // then\n+        assertEqualValues( value( maxKeyCount - 1 ), readValue );\n         goTo( readCursor, rootId );\n         assertThat( keyCount(), is( maxKeyCount - 1 ) );\n         for ( int i = 0; i < maxKeyCount - 1; i++ )\n         {\n-            Long actual = keyAt( i, LEAF );\n-            assertThat( actual, is( (long) i ) );\n+            assertEqualsKey( keyAt( i, LEAF ), key( i ) );\n         }\n     }\n \n@@ -396,18 +417,20 @@ public void modifierMustRemoveFromLeftChild() throws Exception\n         initialize();\n         for ( int i = 0; numberOfRootSplits == 0; i++ )\n         {\n-            insert( i, i );\n+            insert( key( i ), value( i ) );\n         }\n \n         // when\n         generationManager.checkpoint();\n         goTo( readCursor, structurePropagation.midChild );\n-        assertThat( keyAt( 0, LEAF ), is( 0L ) );\n-        remove( 0, readValue );\n+        assertEqualsKey( keyAt( 0, LEAF ), key( 0L ) );\n+        MutableLong readValue = layout.newValue();\n+        remove( key( 0 ), readValue );\n \n         // then\n+        assertEqualValues( value( 0 ), readValue );\n         goTo( readCursor, structurePropagation.midChild );\n-        assertThat( keyAt( 0, LEAF ), is( 1L ) );\n+        assertEqualsKey( keyAt( 0, LEAF ), key( 1L ) );\n     }\n \n     @Test\n@@ -416,34 +439,34 @@ public void modifierMustRemoveFromRightChildButNotFromInternalWithHitOnInternalS\n         initialize();\n         for ( int i = 0; numberOfRootSplits == 0; i++ )\n         {\n-            insert( i, i );\n+            insert( key( i ), value( i ) );\n         }\n \n         // when key to remove exists in internal\n-        Long keyToRemove = structurePropagation.rightKey.getValue();\n+        MutableLong keyToRemove = structurePropagation.rightKey;\n         goTo( readCursor, rootId );\n-        assertThat( keyAt( 0, INTERNAL ), is( keyToRemove ) );\n+        assertEqualsKey( keyAt( 0, INTERNAL ), keyToRemove );\n \n         // and as first key in right child\n         long rightChild = structurePropagation.rightChild;\n         goTo( readCursor, rightChild );\n         int keyCountInRightChild = keyCount();\n-        assertThat( keyAt( 0, LEAF ), is( keyToRemove ) );\n+        assertEqualsKey( keyAt( 0, LEAF ), keyToRemove );\n \n         // and we remove it\n         generationManager.checkpoint();\n-        remove( keyToRemove, readValue );\n+        remove( keyToRemove, dontCare );\n \n         // then we should still find it in internal\n         goTo( readCursor, rootId );\n         assertThat( keyCount(), is( 1 ) );\n-        assertThat( keyAt( 0, INTERNAL ), is( keyToRemove ) );\n+        assertEqualsKey( keyAt( 0, INTERNAL ), keyToRemove );\n \n         // but not in right leaf\n         rightChild = childAt( readCursor, 1, stableGeneration, unstableGeneration );\n         goTo( readCursor, rightChild );\n         assertThat( keyCount(), is( keyCountInRightChild - 1 ) );\n-        assertThat( keyAt( 0, LEAF ), is( keyToRemove + 1 ) );\n+        assertEqualsKey( keyAt( 0, LEAF ), key( getSeed( keyToRemove ) + 1 ) );\n     }\n \n     @Test\n@@ -453,20 +476,19 @@ public void modifierMustNotRemoveWhenKeyDoesNotExist() throws Exception\n         initialize();\n         for ( int i = 0; i < maxKeyCount; i++ )\n         {\n-            insert( i, i );\n+            insert( key( i ), value( i ) );\n         }\n \n         // when\n         generationManager.checkpoint();\n-        assertNull( remove( maxKeyCount, readValue ) );\n+        assertNull( remove( key( maxKeyCount ), dontCare ) );\n \n         // then\n         goTo( readCursor, rootId );\n         assertThat( keyCount(), is( maxKeyCount ) );\n         for ( int i = 0; i < maxKeyCount; i++ )\n         {\n-            Long actual = keyAt( i, LEAF );\n-            assertThat( actual, is( (long) i ) );\n+            assertEqualsKey( keyAt( i, LEAF ), key( i ) );\n         }\n     }\n \n@@ -477,36 +499,36 @@ public void modifierMustNotRemoveWhenKeyOnlyExistInInternal() throws Exception\n         initialize();\n         for ( int i = 0; numberOfRootSplits == 0; i++ )\n         {\n-            insert( i, i );\n+            insert( key( i ), value( i ) );\n         }\n \n         // when key to remove exists in internal\n-        Long keyToRemove = structurePropagation.rightKey.getValue();\n-        assertThat( keyAt( rootId, 0, INTERNAL ), is( keyToRemove ) );\n+        MutableLong keyToRemove = structurePropagation.rightKey;\n+        assertEqualsKey( keyAt( rootId, 0, INTERNAL ), keyToRemove );\n \n         // and as first key in right child\n         long currentRightChild = structurePropagation.rightChild;\n         goTo( readCursor, currentRightChild );\n         int keyCountInRightChild = keyCount();\n-        assertThat( keyAt( 0, LEAF ), is( keyToRemove ) );\n+        assertEqualsKey( keyAt( 0, LEAF ), keyToRemove );\n \n         // and we remove it\n         generationManager.checkpoint();\n-        remove( keyToRemove, readValue ); // Possibly create successor of right child\n+        remove( keyToRemove, dontCare ); // Possibly create successor of right child\n         goTo( readCursor, rootId );\n         currentRightChild = childAt( readCursor, 1, stableGeneration, unstableGeneration );\n \n         // then we should still find it in internal\n         assertThat( keyCount(), is( 1 ) );\n-        assertThat( keyAt( 0, INTERNAL ), is( keyToRemove ) );\n+        assertEqualsKey( keyAt( 0, INTERNAL ), keyToRemove );\n \n         // but not in right leaf\n         goTo( readCursor, currentRightChild );\n         assertThat( keyCount(), is( keyCountInRightChild - 1 ) );\n-        assertThat( keyAt( 0, LEAF ), is( keyToRemove + 1 ) );\n+        assertEqualsKey( keyAt( 0, LEAF ), key( getSeed( keyToRemove ) + 1 ) );\n \n         // and when we remove same key again, nothing should change\n-        assertNull( remove( keyToRemove, readValue ) );\n+        assertNull( remove( keyToRemove, dontCare ) );\n     }\n \n     /* REBALANCE */\n@@ -519,39 +541,43 @@ public void mustNotRebalanceFromRightToLeft() throws Exception\n         long key = 0;\n         while ( numberOfRootSplits == 0 )\n         {\n-            insert( key, key );\n+            insert( key( key ), value( key ) );\n             key++;\n         }\n \n         // ... enough keys in right child to share with left child if rebalance is needed\n-        insert( key, key );\n+        insert( key( key ), value( key ) );\n         key++;\n \n         // ... and the prim key diving key range for left child and right child\n         goTo( readCursor, rootId );\n-        long primKey = keyAt( 0, INTERNAL );\n+        MutableLong primKey = keyAt( 0, INTERNAL );\n+\n+        // ... and knowing key count of right child\n+        long rightChild = childAt( readCursor, 1, stableGeneration, unstableGeneration );\n+        goTo( readCursor, rightChild );\n+        int expectedKeyCount = TreeNode.keyCount( readCursor );\n \n         // when\n         // ... removing all keys from left child\n-        for ( long i = 0; i < primKey; i++ )\n+        for ( long i = 0; ; i++ )\n         {\n-            remove( i, readValue );\n+            MutableLong removeKey = key( i );\n+            if ( layout.compare( removeKey, primKey ) >= 0 )\n+            {\n+                break;\n+            }\n+            remove( removeKey, dontCare );\n         }\n \n         // then\n         // ... looking a right child\n-        long rightChild = childAt( readCursor, 1, stableGeneration, unstableGeneration );\n         goTo( readCursor, rightChild );\n \n         // ... no keys should have moved from right sibling\n-        int pos = 0;\n-        long expected = primKey;\n-        while ( expected < key )\n-        {\n-            assertThat( keyAt( pos, LEAF ), is( expected ) );\n-            pos++;\n-            expected++;\n-        }\n+        int actualKeyCount = TreeNode.keyCount( readCursor );\n+        assertEquals( \"actualKeyCount=\" + actualKeyCount + \", expectedKeyCount=\" + expectedKeyCount, expectedKeyCount, actualKeyCount );\n+        assertEqualsKey( keyAt( 0, LEAF ), primKey );\n     }\n \n     @Test\n@@ -564,24 +590,24 @@ public void mustPropagateAllStructureChanges() throws Exception\n         long key = 10;\n         while ( numberOfRootSplits == 0 )\n         {\n-            insert( key, key );\n+            insert( key( key ), value( key ) );\n             key++;\n         }\n         // ... enough keys in left child to share with right child if rebalance is needed\n         for ( long smallKey = 0; smallKey < 2; smallKey++ )\n         {\n-            insert( smallKey, smallKey );\n+            insert( key( smallKey ), value( smallKey ) );\n         }\n \n         // ... and the prim key dividing key range for left and right child\n         goTo( readCursor, rootId );\n-        long oldPrimKey = keyAt( 0, INTERNAL );\n+        MutableLong oldPrimKey = keyAt( 0, INTERNAL );\n \n         // ... and left and right child\n         long originalLeftChild = childAt( readCursor, 0, stableGeneration, unstableGeneration );\n         long originalRightChild = childAt( readCursor, 1, stableGeneration, unstableGeneration );\n         goTo( readCursor, originalRightChild );\n-        List<Long> keysInRightChild = allKeys( readCursor, LEAF );\n+        List<MutableLong> keysInRightChild = allKeys( readCursor, LEAF );\n \n         // when\n         // ... after checkpoint\n@@ -590,23 +616,25 @@ public void mustPropagateAllStructureChanges() throws Exception\n         // ... removing keys from right child until rebalance is triggered\n         int index = 0;\n         long rightChild;\n-        long leftmostInRightChild;\n+        MutableLong originalLeftmost = keysInRightChild.get( 0 );\n+        MutableLong leftmostInRightChild;\n         do\n         {\n-            remove( keysInRightChild.get( index ), readValue );\n+            remove( keysInRightChild.get( index ), dontCare );\n             index++;\n             goTo( readCursor, rootId );\n             rightChild = childAt( readCursor, 1, stableGeneration, unstableGeneration );\n             goTo( readCursor, rightChild );\n             leftmostInRightChild = keyAt( 0, LEAF );\n-        } while ( leftmostInRightChild >= keysInRightChild.get( 0 ) );\n+        }\n+        while ( layout.compare( leftmostInRightChild, originalLeftmost ) >= 0 );\n \n         // then\n         // ... primKey in root is updated\n         goTo( readCursor, rootId );\n-        Long primKey = keyAt( 0, INTERNAL );\n-        assertThat( primKey, is( leftmostInRightChild ) );\n-        assertThat( primKey, is( not( oldPrimKey ) ) );\n+        MutableLong primKey = keyAt( 0, INTERNAL );\n+        assertEqualsKey( primKey, leftmostInRightChild );\n+        assertNotEqualsKey( primKey, oldPrimKey );\n \n         // ... new versions of left and right child\n         long newLeftChild = childAt( readCursor, 0, stableGeneration, unstableGeneration );\n@@ -627,14 +655,15 @@ public void mustPropagateStructureOnMergeFromLeft() throws Exception\n         //      /        |         \\\n         //     v         v          v\n         //   left <--> middle <--> right\n-        List<Long> allKeys = new ArrayList<>();\n+        List<MutableLong> allKeys = new ArrayList<>();\n         initialize();\n         long targetLastId = id.lastId() + 3; // 2 splits and 1 new allocated root\n         long i = 0;\n         for ( ; id.lastId() < targetLastId; i++ )\n         {\n-            insert( i, i );\n-            allKeys.add( i );\n+            MutableLong key = key( i );\n+            insert( key, value( i ) );\n+            allKeys.add( key );\n         }\n         goTo( readCursor, rootId );\n         assertEquals( 2, keyCount() );\n@@ -645,8 +674,8 @@ public void mustPropagateStructureOnMergeFromLeft() throws Exception\n \n         // WHEN\n         generationManager.checkpoint();\n-        long middleKey = keyAt( 0, INTERNAL ) + 1; // Should be located in middle leaf\n-        remove( middleKey, insertValue );\n+        MutableLong middleKey = keyAt( 0, INTERNAL ); // Should be located in middle leaf\n+        remove( middleKey, dontCare );\n         allKeys.remove( middleKey );\n \n         // THEN\n@@ -674,8 +703,8 @@ public void mustPropagateStructureOnMergeFromLeft() throws Exception\n \n         // new left child contain keys from old left and old middle\n         goTo( readCursor, oldRightChild );\n-        Long firstKeyOfOldRightChild = keyAt( 0, LEAF );\n-        List<Long> expectedKeysInNewLeftChild = allKeys.subList( 0, allKeys.indexOf( firstKeyOfOldRightChild ) );\n+        MutableLong firstKeyOfOldRightChild = keyAt( 0, LEAF );\n+        List<MutableLong> expectedKeysInNewLeftChild = allKeys.subList( 0, allKeys.indexOf( firstKeyOfOldRightChild ) );\n         goTo( readCursor, newLeftChild );\n         assertNodeContainsExpectedKeys( expectedKeysInNewLeftChild, LEAF );\n \n@@ -693,26 +722,30 @@ public void mustPropagateStructureOnMergeToRight() throws Exception\n         //       /           |          \\\n         //      v            v           v\n         //   oldleft <-> oldmiddle <-> oldright\n-        List<Long> allKeys = new ArrayList<>();\n+        List<MutableLong> allKeys = new ArrayList<>();\n         initialize();\n         long targetLastId = id.lastId() + 3; // 2 splits and 1 new allocated root\n         long i = 0;\n         for ( ; id.lastId() < targetLastId; i++ )\n         {\n-            insert( i, i );\n-            allKeys.add( i );\n+            MutableLong key = key( i );\n+            insert( key, value( i ) );\n+            allKeys.add( key );\n         }\n         goTo( readCursor, rootId );\n         assertEquals( 2, keyCount() );\n         long oldLeftChild = childAt( readCursor, 0, stableGeneration, unstableGeneration );\n         long oldMiddleChild = childAt( readCursor, 1, stableGeneration, unstableGeneration );\n         long oldRightChild = childAt( readCursor, 2, stableGeneration, unstableGeneration );\n         assertSiblings( oldLeftChild, oldMiddleChild, oldRightChild );\n+        goTo( readCursor, oldLeftChild );\n+        MutableLong keyInLeftChild = keyAt( 0, LEAF );\n \n         // WHEN\n         generationManager.checkpoint();\n-        long keyInLeftChild = keyAt( 0, INTERNAL ) - 1; // Should be located in left leaf\n-        remove( keyInLeftChild, insertValue );\n+        // removing key in left child\n+        goTo( readCursor, rootId );\n+        remove( keyInLeftChild, dontCare );\n         allKeys.remove( keyInLeftChild );\n         // New structure\n         // NOTE: oldleft gets a successor (intermediate) before removing key and then another one once it is merged,\n@@ -750,8 +783,8 @@ public void mustPropagateStructureOnMergeToRight() throws Exception\n \n         // new left child contain keys from old left and old middle\n         goTo( readCursor, oldRightChild );\n-        Long firstKeyInOldRightChild = keyAt( 0, LEAF );\n-        List<Long> expectedKeysInNewLeftChild = allKeys.subList( 0, allKeys.indexOf( firstKeyInOldRightChild ) );\n+        MutableLong firstKeyInOldRightChild = keyAt( 0, LEAF );\n+        List<MutableLong> expectedKeysInNewLeftChild = allKeys.subList( 0, allKeys.indexOf( firstKeyInOldRightChild ) );\n         goTo( readCursor, newLeftChild );\n         assertNodeContainsExpectedKeys( expectedKeysInNewLeftChild, LEAF );\n \n@@ -775,42 +808,42 @@ public void mustPropagateStructureWhenMergingBetweenDifferentSubtrees() throws E\n         long i = 0;\n         while ( numberOfRootSplits < 2 )\n         {\n-            insert( i, i );\n+            insert( key( i ), value( i ) );\n             i++;\n         }\n \n         long oldLeft = rightmostLeafInSubtree( rootId, 0 );\n         long oldRight = leftmostLeafInSubtree( rootId, 1 );\n-        long oldSplitter = keyAt( 0, INTERNAL );\n-        long rightmostKeyInLeftSubtree = rightmostInternalKeyInSubtree( rootId, 0 );\n+        MutableLong oldSplitter = keyAt( 0, INTERNAL );\n+        MutableLong rightmostKeyInLeftSubtree = rightmostInternalKeyInSubtree( rootId, 0 );\n \n-        ArrayList<Long> allKeysInOldLeftAndOldRight = new ArrayList<>();\n+        ArrayList<MutableLong> allKeysInOldLeftAndOldRight = new ArrayList<>();\n         goTo( readCursor, oldLeft );\n         allKeys( readCursor, allKeysInOldLeftAndOldRight, LEAF );\n         goTo( readCursor, oldRight );\n         allKeys( readCursor, allKeysInOldLeftAndOldRight, LEAF );\n \n-        long keyInOldRight = keyAt( 0, LEAF );\n+        MutableLong keyInOldRight = keyAt( 0, LEAF );\n \n         // WHEN\n         generationManager.checkpoint();\n-        remove( keyInOldRight, readValue );\n+        remove( keyInOldRight, dontCare );\n         allKeysInOldLeftAndOldRight.remove( keyInOldRight );\n \n         // THEN\n         // oldSplitter in root should have been replaced by rightmostKeyInLeftSubtree\n         goTo( readCursor, rootId );\n-        Long newSplitter = keyAt( 0, INTERNAL );\n-        assertThat( newSplitter, is( not( oldSplitter ) ) );\n-        assertThat( newSplitter, is( rightmostKeyInLeftSubtree ) );\n+        MutableLong newSplitter = keyAt( 0, INTERNAL );\n+        assertNotEqualsKey( newSplitter, oldSplitter );\n+        assertEqualsKey( newSplitter, rightmostKeyInLeftSubtree );\n \n         // rightmostKeyInLeftSubtree should have been removed from successor version of leftParent\n-        long newRightmostInternalKeyInLeftSubtree = rightmostInternalKeyInSubtree( rootId, 0 );\n-        assertThat( newRightmostInternalKeyInLeftSubtree, is( not( rightmostKeyInLeftSubtree ) ) );\n+        MutableLong newRightmostInternalKeyInLeftSubtree = rightmostInternalKeyInSubtree( rootId, 0 );\n+        assertNotEqualsKey( newRightmostInternalKeyInLeftSubtree, rightmostKeyInLeftSubtree );\n \n         // newRight contain all\n         goToSuccessor( readCursor, oldRight );\n-        List<Long> allKeysInNewRight = allKeys( readCursor, LEAF );\n+        List<MutableLong> allKeysInNewRight = allKeys( readCursor, LEAF );\n         assertEquals( allKeysInOldLeftAndOldRight, allKeysInNewRight );\n     }\n \n@@ -819,13 +852,14 @@ public void mustLeaveSingleLeafAsRootWhenEverythingIsRemoved() throws Exception\n     {\n         // GIVEN\n         // a tree with some keys\n-        List<Long> allKeys = new ArrayList<>();\n+        List<MutableLong> allKeys = new ArrayList<>();\n         initialize();\n         long i = 0;\n         while ( numberOfRootSplits < 3 )\n         {\n-            insert( i, i );\n-            allKeys.add( i );\n+            MutableLong key = key( i );\n+            insert( key, value( i ) );\n+            allKeys.add( key );\n             i++;\n         }\n \n@@ -834,7 +868,7 @@ public void mustLeaveSingleLeafAsRootWhenEverythingIsRemoved() throws Exception\n         generationManager.checkpoint();\n         for ( int j = 0; j < allKeys.size() - 1; j++ )\n         {\n-            remove( allKeys.get( j ), readValue );\n+            remove( allKeys.get( j ), dontCare );\n         }\n \n         // THEN\n@@ -853,7 +887,7 @@ public void modifierMustProduceConsistentTreeWithRandomInserts() throws Exceptio\n         for ( int i = 0; i < numberOfEntries; i++ )\n         {\n             // when\n-            insert( random.nextLong(), random.nextLong() );\n+            insert( key( random.nextLong() ), value( random.nextLong() ) );\n             if ( i == numberOfEntries / 2 )\n             {\n                 generationManager.checkpoint();\n@@ -874,155 +908,68 @@ public void modifierMustOverwriteWithOverwriteMerger() throws Exception\n     {\n         // given\n         initialize();\n-        long key = random.nextLong();\n-        long firstValue = random.nextLong();\n+        MutableLong key = key( random.nextLong() );\n+        MutableLong firstValue = value( random.nextLong() );\n         insert( key, firstValue );\n \n         // when\n         generationManager.checkpoint();\n-        long secondValue = random.nextLong();\n+        MutableLong secondValue = value( random.nextLong() );\n         insert( key, secondValue, ValueMergers.overwrite() );\n \n         // then\n         goTo( readCursor, rootId );\n         assertThat( keyCount(), is( 1 ) );\n-        assertThat( valueAt( 0 ), is( secondValue ) );\n+        assertEqualValues( valueAt( 0 ), secondValue );\n     }\n \n     @Test\n     public void modifierMustKeepExistingWithKeepExistingMerger() throws Exception\n     {\n         // given\n         initialize();\n-        long key = random.nextLong();\n-        long firstValue = random.nextLong();\n+        MutableLong key = key( random.nextLong() );\n+        MutableLong firstValue = value( random.nextLong() );\n         insert( key, firstValue, ValueMergers.keepExisting() );\n         goTo( readCursor, rootId );\n         assertThat( keyCount(), is( 1 ) );\n-        Long actual = valueAt( 0 );\n-        assertThat( actual, is( firstValue ) );\n+        MutableLong actual = valueAt( 0 );\n+        assertEqualValues( actual, firstValue );\n \n         // when\n         generationManager.checkpoint();\n-        long secondValue = random.nextLong();\n+        MutableLong secondValue = value( random.nextLong() );\n         insert( key, secondValue, ValueMergers.keepExisting() );\n \n         // then\n         goTo( readCursor, rootId );\n         assertThat( keyCount(), is( 1 ) );\n         actual = valueAt( 0 );\n-        assertThat( actual, is( firstValue ) );\n+        assertEqualValues( actual, firstValue );\n     }\n \n     @Test\n-    public void shouldMergeValueInRootLeaf() throws Exception\n+    public void shouldMergeValue() throws Exception\n     {\n         // GIVEN\n         initialize();\n-        long key = 10;\n+        MutableLong key = key( 10 );\n         long baseValue = 100;\n-        insert( key, baseValue );\n-\n-        // WHEN\n-        generationManager.checkpoint();\n-        int toAdd = 5;\n-        insert( key, toAdd, ADDER );\n-\n-        // THEN\n-        goTo( readCursor, rootId );\n-        int searchResult = KeySearch.search( readCursor, node, LEAF, key( key ), new MutableLong(), keyCount() );\n-        assertTrue( KeySearch.isHit( searchResult ) );\n-        int pos = KeySearch.positionOf( searchResult );\n-        assertEquals( 0, pos );\n-        assertEquals( key, keyAt( pos, LEAF ).longValue() );\n-        assertEquals( baseValue + toAdd, valueAt( pos ).longValue() );\n-    }\n-\n-    @Test\n-    public void shouldMergeValueInLeafLeftOfParentKey() throws Exception\n-    {\n-        // GIVEN\n-        initialize();\n-        for ( int i = 0; numberOfRootSplits == 0; i++ )\n-        {\n-            insert( i, i );\n-        }\n-\n-        // WHEN\n-        generationManager.checkpoint();\n-        long key = 1;\n-        int toAdd = 5;\n-        insert( key, toAdd, ADDER );\n-\n-        // THEN\n-        goTo( readCursor, structurePropagation.midChild );\n-        int searchResult = KeySearch.search( readCursor, node, LEAF, key( key ), new MutableLong(), keyCount() );\n-        assertTrue( KeySearch.isHit( searchResult ) );\n-        int pos = KeySearch.positionOf( searchResult );\n-        assertEquals( 1, pos );\n-        assertEquals( key, keyAt( pos, LEAF ).longValue() );\n-        assertEquals( key + toAdd, valueAt( pos ).longValue() );\n-    }\n-\n-    @Test\n-    public void shouldMergeValueInLeafAtParentKey() throws Exception\n-    {\n-        // GIVEN\n-        initialize();\n-        for ( int i = 0; numberOfRootSplits == 0; i++ )\n-        {\n-            insert( i, i );\n-        }\n+        insert( key, value( baseValue ) );\n \n         // WHEN\n         generationManager.checkpoint();\n-        long key = structurePropagation.rightKey.longValue();\n-        int toAdd = 5;\n-        insert( key, toAdd, ADDER );\n+        long toAdd = 5;\n+        insert( key, value( toAdd ), ADDER );\n \n         // THEN\n         goTo( readCursor, rootId );\n-        long rightChild = childAt( readCursor, 1, stableGeneration, unstableGeneration );\n-        goTo( readCursor, rightChild );\n-        int searchResult = KeySearch.search( readCursor, node, LEAF, key( key ), new MutableLong(), keyCount() );\n+        int searchResult = KeySearch.search( readCursor, node, LEAF, key, layout.newKey(), keyCount() );\n         assertTrue( KeySearch.isHit( searchResult ) );\n         int pos = KeySearch.positionOf( searchResult );\n         assertEquals( 0, pos );\n-        assertEquals( key, keyAt( pos, LEAF ).longValue() );\n-        assertEquals( key + toAdd, valueAt( pos ).longValue() );\n-    }\n-\n-    @Test\n-    public void shouldMergeValueInLeafBetweenTwoParentKeys() throws Exception\n-    {\n-        // GIVEN\n-        initialize();\n-        long firstSplitPrimKey = -1;\n-        for ( int i = 0; numberOfRootSplits == 0 || keyCount( rootId ) < 1; i++ )\n-        {\n-            insert( i, i );\n-            if ( firstSplitPrimKey == -1 && numberOfRootSplits == 1 )\n-            {\n-                firstSplitPrimKey = structurePropagation.rightKey.longValue();\n-            }\n-        }\n-\n-        // WHEN\n-        generationManager.checkpoint();\n-        long key = firstSplitPrimKey + 1;\n-        int toAdd = 5;\n-        insert( key, toAdd, ADDER );\n-\n-        // THEN\n-        goTo( readCursor, rootId );\n-        long middle = childAt( readCursor, 1, stableGeneration, unstableGeneration );\n-        goTo( readCursor, middle );\n-        int searchResult = KeySearch.search( readCursor, node, LEAF, key( key ), new MutableLong(), keyCount() );\n-        assertTrue( KeySearch.isHit( searchResult ) );\n-        int pos = KeySearch.positionOf( searchResult );\n-        assertEquals( 1, pos );\n-        assertEquals( key, keyAt( pos, LEAF ).longValue() );\n-        assertEquals( key + toAdd, valueAt( pos ).longValue() );\n+        assertEquals( key, keyAt( pos, LEAF ) );\n+        assertEquals( value( baseValue + toAdd ), valueAt( pos ) );\n     }\n \n     /* CREATE NEW VERSION ON UPDATE */\n@@ -1038,7 +985,7 @@ public void shouldCreateNewVersionWhenInsertInStableRootAsLeaf() throws Exceptio\n \n         // WHEN root -[successor]-> successor of root\n         generationManager.checkpoint();\n-        insert( 1L, 1L );\n+        insert( key( 1L ), value( 1L ) );\n         long successor = cursor.getCurrentPageId();\n \n         // THEN\n@@ -1060,14 +1007,14 @@ public void shouldCreateNewVersionWhenRemoveInStableRootAsLeaf() throws Exceptio\n \n         // GIVEN root\n         initialize();\n-        long key = 1L;\n-        long value = 10L;\n+        MutableLong key = key( 1L );\n+        MutableLong value = value( 10L );\n         insert( key, value );\n         long oldGenerationId = cursor.getCurrentPageId();\n \n         // WHEN root -[successor]-> successor of root\n         generationManager.checkpoint();\n-        remove( key, readValue );\n+        remove( key, dontCare );\n         long successor = cursor.getCurrentPageId();\n \n         // THEN\n@@ -1097,7 +1044,7 @@ public void shouldCreateNewVersionWhenInsertInStableLeaf() throws Exception\n         long i = 0;\n         for ( ; id.lastId() < targetLastId; i++ )\n         {\n-            insert( i, i );\n+            insert( key( i ), value( i ) );\n         }\n         goTo( readCursor, rootId );\n         assertEquals( 2, keyCount() );\n@@ -1108,8 +1055,9 @@ public void shouldCreateNewVersionWhenInsertInStableLeaf() throws Exception\n \n         // WHEN\n         generationManager.checkpoint();\n-        long middleKey = i / 2; // Should be located in middle leaf\n-        long newValue = middleKey * 100;\n+        long middle = i / 2;\n+        MutableLong middleKey = key( middle ); // Should be located in middle leaf\n+        MutableLong newValue = value( middle * 100 );\n         insert( middleKey, newValue );\n \n         // THEN\n@@ -1149,7 +1097,7 @@ public void shouldCreateNewVersionWhenRemoveInStableLeaf() throws Exception\n         long i = 0;\n         for ( ; id.lastId() < targetLastId; i += 2 )\n         {\n-            insert( i, i );\n+            insert( key( i ), value( i ) );\n         }\n         goTo( readCursor, rootId );\n         assertEquals( 2, keyCount() );\n@@ -1160,16 +1108,18 @@ public void shouldCreateNewVersionWhenRemoveInStableLeaf() throws Exception\n \n         // add some more keys to middleChild to not have remove trigger a merge\n         goTo( readCursor, middleChild );\n-        Long firstKeyInMiddleChild = keyAt( 0, LEAF );\n-        insert( firstKeyInMiddleChild + 1, firstKeyInMiddleChild + 1 );\n+        MutableLong firstKeyInMiddleChild = keyAt( 0, LEAF );\n+        long seed = getSeed( firstKeyInMiddleChild );\n+        insert( key( seed + 1 ), value( seed + 1 ) );\n         goTo( readCursor, rootId );\n \n         assertSiblings( leftChild, middleChild, rightChild );\n \n         // WHEN\n         generationManager.checkpoint();\n-        long middleKey = i / 2; // Should be located in middle leaf\n-        remove( middleKey, insertValue );\n+        long middleKeySeed = i / 2; // Should be located in middle leaf\n+        MutableLong middleKey = key( middleKeySeed );\n+        remove( middleKey, dontCare );\n \n         // THEN\n         // root have new middle child\n@@ -1183,7 +1133,7 @@ public void shouldCreateNewVersionWhenRemoveInStableLeaf() throws Exception\n         assertEquals( newMiddleChild, successor( readCursor, stableGeneration, unstableGeneration ) );\n \n         // old middle child has seen no change\n-        assertKeyAssociatedWithValue( middleKey, middleKey );\n+        assertKeyAssociatedWithValue( middleKey, value( middleKeySeed ) );\n \n         // new middle child has seen change\n         goTo( readCursor, newMiddleChild );\n@@ -1210,7 +1160,7 @@ public void shouldCreateNewVersionWhenInsertInStableRootAsInternal() throws Exce\n                 maxKeyCount /*will split root leaf into two half left/right*/ + maxKeyCount / 2;\n         for ( ; i < countToProduceAboveImageAndFullRight; i++ )\n         {\n-            insert( i, i );\n+            insert( key( i ), value( i ) );\n         }\n         long oldRootId = rootId;\n         goTo( readCursor, rootId );\n@@ -1226,7 +1176,7 @@ public void shouldCreateNewVersionWhenInsertInStableRootAsInternal() throws Exce\n         //                 v       v                 v\n         //               left <-> right(successor) <--> farRight\n         generationManager.checkpoint();\n-        insert( i, i );\n+        insert( key( i ), value( i ) );\n         assertEquals( 1, numberOfRootSuccessors );\n         goTo( readCursor, rootId );\n         leftChild = childAt( readCursor, 0, stableGeneration, unstableGeneration );\n@@ -1251,8 +1201,8 @@ public void shouldCreateNewVersionWhenInsertInStableInternal() throws Exception\n         initialize();\n         for ( int i = 0; numberOfRootSplits < 2; i++ )\n         {\n-            long keyAndValue = i * maxKeyCount;\n-            insert( keyAndValue, keyAndValue );\n+            long seed = i * maxKeyCount;\n+            insert( key( seed ), value( seed ) );\n         }\n         long rootAfterInitialData = rootId;\n         goTo( readCursor, rootId );\n@@ -1265,14 +1215,15 @@ public void shouldCreateNewVersionWhenInsertInStableInternal() throws Exception\n         assertTrue( TreeNode.isInternal( readCursor ) );\n         long leftLeaf = childAt( readCursor, 0, stableGeneration, unstableGeneration );\n         goTo( readCursor, leftLeaf );\n-        long firstKeyInLeaf = keyAt( 0, LEAF );\n+        MutableLong firstKeyInLeaf = keyAt( 0, LEAF );\n+        long seedOfFirstKeyInLeaf = getSeed( firstKeyInLeaf );\n \n         // WHEN\n         generationManager.checkpoint();\n         long targetLastId = id.lastId() + 3; /*one for successor in leaf, one for split leaf, one for successor in internal*/\n         for ( int i = 0; id.lastId() < targetLastId; i++ )\n         {\n-            insert( firstKeyInLeaf + i, firstKeyInLeaf + i );\n+            insert( key( seedOfFirstKeyInLeaf + i ), value( seedOfFirstKeyInLeaf + i ) );\n             assertFalse( structurePropagation.hasRightKeyInsert ); // there should be no root split\n         }\n \n@@ -1302,7 +1253,7 @@ public void shouldOverwriteInheritedSuccessorOnSuccessor() throws Exception\n         initialize();\n         long originalNodeId = rootId;\n         generationManager.checkpoint();\n-        insert( 1L, 10L ); // TX1 will create successor\n+        insert( key( 1L ), value( 10L ) ); // TX1 will create successor\n         assertEquals( 1, numberOfRootSuccessors );\n \n         // WHEN\n@@ -1312,7 +1263,7 @@ public void shouldOverwriteInheritedSuccessorOnSuccessor() throws Exception\n         goTo( cursor, originalNodeId );\n         treeLogic.initialize( cursor );\n         // replay transaction TX1 will create a new successor\n-        insert( 1L, 10L );\n+        insert( key( 1L ), value( 10L ) );\n         assertEquals( 2, numberOfRootSuccessors );\n \n         // THEN\n@@ -1333,8 +1284,8 @@ public void mustThrowIfReachingNodeWithValidSuccessor() throws Exception\n         initialize();\n         for ( int i = 1; numberOfRootSplits < 1; i++ )\n         {\n-            long keyAndValue = i * maxKeyCount;\n-            insert( keyAndValue, keyAndValue );\n+            long seed = i * maxKeyCount;\n+            insert( key( seed ), value( seed ) );\n         }\n         generationManager.checkpoint();\n \n@@ -1347,7 +1298,7 @@ public void mustThrowIfReachingNodeWithValidSuccessor() throws Exception\n         // insert in leftmostChild\n         try\n         {\n-            insert( 0, 0 );\n+            insert( key( 0 ), value( 0 ) );\n             fail( \"Expected insert to throw because child targeted for insertion has a valid new successor.\" );\n         }\n         catch ( TreeInconsistencyException e )\n@@ -1363,12 +1314,12 @@ private void giveSuccessor( PageCursor cursor, long nodeId ) throws IOException\n         TreeNode.setSuccessor( cursor, 42, stableGeneration, unstableGeneration );\n     }\n \n-    private long rightmostInternalKeyInSubtree( long parentNodeId, int subtreePosition ) throws IOException\n+    private MutableLong rightmostInternalKeyInSubtree( long parentNodeId, int subtreePosition ) throws IOException\n     {\n         long current = readCursor.getCurrentPageId();\n         goToSubtree( parentNodeId, subtreePosition );\n         boolean found = false;\n-        long rightmostKeyInSubtree = -1;\n+        MutableLong rightmostKeyInSubtree = layout.newKey();\n         while ( TreeNode.isInternal( readCursor ) )\n         {\n             int keyCount = TreeNode.keyCount( readCursor );\n@@ -1429,25 +1380,33 @@ private long rightmostLeafInSubtree( long parentNodeId, int subtreePosition ) th\n         return rightmostChild;\n     }\n \n-    private void assertNodeContainsExpectedKeys( List<Long> expectedKeys, TreeNode.Type type )\n+    private void assertNodeContainsExpectedKeys( List<MutableLong> expectedKeys, TreeNode.Type type )\n     {\n-        List<Long> actualKeys = allKeys( readCursor, type );\n-        assertThat( actualKeys, is( expectedKeys ) );\n+        List<MutableLong> actualKeys = allKeys( readCursor, type );\n+        for ( MutableLong actualKey : actualKeys )\n+        {\n+            GBPTreeTestUtil.contains( expectedKeys, actualKey, layout );\n+        }\n+        for ( MutableLong expectedKey : expectedKeys )\n+        {\n+            GBPTreeTestUtil.contains( actualKeys, expectedKey, layout );\n+        }\n     }\n \n-    private List<Long> allKeys( PageCursor cursor, TreeNode.Type type )\n+    private List<MutableLong> allKeys( PageCursor cursor, TreeNode.Type type )\n     {\n-        List<Long> keys = new ArrayList<>();\n+        List<MutableLong> keys = new ArrayList<>();\n         return allKeys( cursor, keys, type );\n     }\n \n-    private List<Long> allKeys( PageCursor cursor, List<Long> keys, TreeNode.Type type )\n+    private List<MutableLong> allKeys( PageCursor cursor, List<MutableLong> keys, TreeNode.Type type )\n     {\n         int keyCount = TreeNode.keyCount( cursor );\n         for ( int i = 0; i < keyCount; i++ )\n         {\n-            node.keyAt( cursor, readKey, i, type );\n-            keys.add( readKey.longValue() );\n+            MutableLong into = layout.newKey();\n+            node.keyAt( cursor, into, i, type );\n+            keys.add( into );\n         }\n         return keys;\n     }\n@@ -1490,20 +1449,21 @@ private void assertSuccessorPointerNotCrashOrBroken()\n                 TreeNode.BYTE_POS_SUCCESSOR );\n     }\n \n-    private void assertKeyAssociatedWithValue( long key, long expectedValue )\n+    private void assertKeyAssociatedWithValue( MutableLong key, MutableLong expectedValue )\n     {\n-        insertKey.setValue( key );\n-        int search = KeySearch.search( readCursor, node, LEAF, insertKey, readKey, TreeNode.keyCount( readCursor ) );\n+        MutableLong readKey = layout.newKey();\n+        MutableLong readValue = layout.newValue();\n+        int search = KeySearch.search( readCursor, node, LEAF, key, readKey, TreeNode.keyCount( readCursor ) );\n         assertTrue( KeySearch.isHit( search ) );\n         int keyPos = KeySearch.positionOf( search );\n         node.valueAt( readCursor, readValue, keyPos );\n-        assertEquals( expectedValue, readValue.longValue() );\n+        assertEquals( expectedValue, readValue );\n     }\n \n-    private void assertKeyNotFound( long key, TreeNode.Type type )\n+    private void assertKeyNotFound( MutableLong key, TreeNode.Type type )\n     {\n-        insertKey.setValue( key );\n-        int search = KeySearch.search( readCursor, node, type, insertKey, readKey, TreeNode.keyCount( readCursor ) );\n+        MutableLong readKey = layout.newKey();\n+        int search = KeySearch.search( readCursor, node, type, key, readKey, TreeNode.keyCount( readCursor ) );\n         assertFalse( KeySearch.isHit( search ) );\n     }\n \n@@ -1535,9 +1495,23 @@ private void printTree() throws IOException\n         cursor.next( currentPageId );\n     }\n \n-    private static MutableLong key( long key )\n+    private MutableLong key( long seed )\n+    {\n+        MutableLong key = layout.newKey();\n+        key.setValue( seed );\n+        return key;\n+    }\n+\n+    private MutableLong value( long seed )\n+    {\n+        MutableLong value = layout.newValue();\n+        value.setValue( seed );\n+        return value;\n+    }\n+\n+    private long getSeed( MutableLong key )\n     {\n-        return new MutableLong( key );\n+        return key.getValue();\n     }\n \n     private void newRootFromSplit( StructurePropagation<MutableLong> split ) throws IOException\n@@ -1573,42 +1547,41 @@ private void assertSiblingOrderAndPointers( long... children ) throws IOExceptio\n         goTo( readCursor, currentPageId );\n     }\n \n-    private Long keyAt( long nodeId, int pos, TreeNode.Type type ) throws IOException\n+    private MutableLong keyAt( long nodeId, int pos, TreeNode.Type type ) throws IOException\n     {\n+        MutableLong readKey = layout.newKey();\n         long prevId = readCursor.getCurrentPageId();\n         try\n         {\n             readCursor.next( nodeId );\n-            return node.keyAt( readCursor, readKey, pos, type ).getValue();\n+            return node.keyAt( readCursor, readKey, pos, type );\n         }\n         finally\n         {\n             readCursor.next( prevId );\n         }\n     }\n \n-    private Long keyAt( int pos, TreeNode.Type type )\n+    private MutableLong keyAt( int pos, TreeNode.Type type )\n     {\n-        return node.keyAt( readCursor, readKey, pos, type ).getValue();\n+        return node.keyAt( readCursor, layout.newKey(), pos, type );\n     }\n \n-    private Long valueAt( int pos )\n+    private MutableLong valueAt( int pos )\n     {\n-        return node.valueAt( readCursor, readValue, pos ).getValue();\n+        return node.valueAt( readCursor, layout.newValue(), pos );\n     }\n \n-    private void insert( long key, long value ) throws IOException\n+    private void insert( MutableLong key, MutableLong value ) throws IOException\n     {\n         insert( key, value, overwrite() );\n     }\n \n-    private void insert( long key, long value, ValueMerger<MutableLong,MutableLong> valueMerger ) throws IOException\n+    private void insert( MutableLong key, MutableLong value, ValueMerger<MutableLong,MutableLong> valueMerger ) throws IOException\n     {\n         structurePropagation.hasRightKeyInsert = false;\n         structurePropagation.hasMidChildUpdate = false;\n-        insertKey.setValue( key );\n-        insertValue.setValue( value );\n-        treeLogic.insert( cursor, structurePropagation, insertKey, insertValue, valueMerger, stableGeneration,\n+        treeLogic.insert( cursor, structurePropagation, key, value, valueMerger, stableGeneration,\n                 unstableGeneration );\n         handleAfterChange();\n     }\n@@ -1628,11 +1601,9 @@ private void handleAfterChange() throws IOException\n         }\n     }\n \n-    private MutableLong remove( long key, MutableLong into ) throws IOException\n+    private MutableLong remove( MutableLong key, MutableLong into ) throws IOException\n     {\n-        insertKey.setValue( key );\n-        MutableLong result = treeLogic.remove( cursor, structurePropagation, insertKey, into, stableGeneration,\n-                unstableGeneration );\n+        MutableLong result = treeLogic.remove( cursor, structurePropagation, key, into, stableGeneration, unstableGeneration );\n         handleAfterChange();\n         return result;\n     }\n@@ -1726,4 +1697,22 @@ private long newestGeneration( PageCursor cursor, long stableGeneration, long un\n         goTo( cursor, current );\n         return successor;\n     }\n+\n+    private void assertNotEqualsKey( MutableLong key1, MutableLong key2 )\n+    {\n+        assertFalse( String.format( \"expected no not equal, key1=%s, key2=%s\", key1.toString(), key2.toString() ),\n+                layout.compare( key1, key2 ) == 0 );\n+    }\n+\n+    private void assertEqualsKey( MutableLong expected, MutableLong actual )\n+    {\n+        assertTrue( String.format( \"expected equal, expected=%s, actual=%s\", expected.toString(), actual.toString() ),\n+                layout.compare( expected, actual ) == 0 );\n+    }\n+\n+    private void assertEqualValues( MutableLong expected, MutableLong actual )\n+    {\n+        assertTrue( String.format( \"expected equal, expected=%s, actual=%s\", expected.toString(), actual.toString() ),\n+                layout.compare( expected, actual ) == 0 );\n+    }\n }",
      "parent_sha": "5b4b197b6ab289387d0e005a9109fe37472ab695"
    }
  },
  {
    "oid": "1041ef7fed7911ed3db00b16e1b20d4e63c28941",
    "message": "Removed unused imports",
    "date": "2011-02-07T15:06:18Z",
    "url": "https://github.com/neo4j/neo4j/commit/1041ef7fed7911ed3db00b16e1b20d4e63c28941",
    "details": {
      "sha": "a306f85f515fc1733fec175844718eb4a1653304",
      "filename": "packaging/server/src/main/java/org/neo4j/server/web/Jetty6WebServer.java",
      "status": "modified",
      "additions": 8,
      "deletions": 14,
      "changes": 22,
      "blob_url": "https://github.com/neo4j/neo4j/blob/1041ef7fed7911ed3db00b16e1b20d4e63c28941/packaging%2Fserver%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fserver%2Fweb%2FJetty6WebServer.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/1041ef7fed7911ed3db00b16e1b20d4e63c28941/packaging%2Fserver%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fserver%2Fweb%2FJetty6WebServer.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/packaging%2Fserver%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fserver%2Fweb%2FJetty6WebServer.java?ref=1041ef7fed7911ed3db00b16e1b20d4e63c28941",
      "patch": "@@ -19,8 +19,12 @@\n  */\n package org.neo4j.server.web;\n \n-import com.sun.jersey.api.core.ResourceConfig;\n-import com.sun.jersey.spi.container.servlet.ServletContainer;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.List;\n+\n import org.mortbay.jetty.Server;\n import org.mortbay.jetty.SessionManager;\n import org.mortbay.jetty.handler.MovedContextHandler;\n@@ -32,21 +36,11 @@\n import org.mortbay.resource.Resource;\n import org.mortbay.thread.QueuedThreadPool;\n import org.neo4j.server.NeoServer;\n-import org.neo4j.server.configuration.Configurator;\n import org.neo4j.server.logging.Logger;\n import org.neo4j.server.rest.web.AllowAjaxFilter;\n \n-import javax.servlet.Servlet;\n-import javax.servlet.ServletException;\n-import javax.servlet.http.HttpServlet;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import java.io.IOException;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.net.URL;\n-import java.util.HashMap;\n-import java.util.List;\n+import com.sun.jersey.api.core.ResourceConfig;\n+import com.sun.jersey.spi.container.servlet.ServletContainer;\n \n public class Jetty6WebServer implements WebServer\n {",
      "parent_sha": "32506e27f78c0094b876377a9fffece9d71caaaa"
    }
  },
  {
    "oid": "255eead2e1b8df8fbcf17d2ad4b3c7ce0cf12d14",
    "message": "neo-server.external was never implemented",
    "date": "2017-10-04T08:35:17Z",
    "url": "https://github.com/neo4j/neo4j/commit/255eead2e1b8df8fbcf17d2ad4b3c7ce0cf12d14",
    "details": {
      "sha": "3d913500dc491057f4acb20cbf7f5924d6e10874",
      "filename": "community/server/src/test/java/org/neo4j/test/server/SharedServerTestBase.java",
      "status": "modified",
      "additions": 15,
      "deletions": 23,
      "changes": 38,
      "blob_url": "https://github.com/neo4j/neo4j/blob/255eead2e1b8df8fbcf17d2ad4b3c7ce0cf12d14/community%2Fserver%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Ftest%2Fserver%2FSharedServerTestBase.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/255eead2e1b8df8fbcf17d2ad4b3c7ce0cf12d14/community%2Fserver%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Ftest%2Fserver%2FSharedServerTestBase.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fserver%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Ftest%2Fserver%2FSharedServerTestBase.java?ref=255eead2e1b8df8fbcf17d2ad4b3c7ce0cf12d14",
      "patch": "@@ -34,8 +34,6 @@\n \n public class SharedServerTestBase\n {\n-    private static boolean useExternal = Boolean.valueOf( System.getProperty( \"neo-server.external\", \"false\" ) );\n-\n     protected static NeoServer server()\n     {\n         return server;\n@@ -50,35 +48,29 @@ protected static NeoServer server()\n     public static void allocateServer() throws Throwable\n     {\n         System.setProperty( \"org.neo4j.useInsecureCertificateGeneration\", \"true\" );\n-        if ( !useExternal )\n+        suppressAll().call( (Callable<Void>) () ->\n         {\n-            suppressAll().call( (Callable<Void>) () ->\n-            {\n-                ServerHolder.setServerBuilderProperty( GraphDatabaseSettings.cypher_hints_error.name(), \"true\" );\n-                server = ServerHolder.allocate();\n-                ServerHelper.cleanTheDatabase( server );\n-                return null;\n-            } );\n-        }\n+            ServerHolder.setServerBuilderProperty( GraphDatabaseSettings.cypher_hints_error.name(), \"true\" );\n+            server = ServerHolder.allocate();\n+            ServerHelper.cleanTheDatabase( server );\n+            return null;\n+        } );\n     }\n \n     @AfterClass\n     public static void releaseServer() throws Exception\n     {\n-        if ( !useExternal )\n+        try\n         {\n-            try\n-            {\n-                suppressAll().call( (Callable<Void>) () ->\n-                {\n-                    ServerHolder.release( server );\n-                    return null;\n-                } );\n-            }\n-            finally\n+            suppressAll().call( (Callable<Void>) () ->\n             {\n-                server = null;\n-            }\n+                ServerHolder.release( server );\n+                return null;\n+            } );\n+        }\n+        finally\n+        {\n+            server = null;\n         }\n     }\n }",
      "parent_sha": "81330f5efbfffb27eb57d21f024b42ef93c14279"
    }
  },
  {
    "oid": "259b32fd4a349a4940fc7b115823b0382435a5ca",
    "message": "Fix formatting of the description of the mapped_memory_total_size configuration",
    "date": "2014-09-24T14:20:33Z",
    "url": "https://github.com/neo4j/neo4j/commit/259b32fd4a349a4940fc7b115823b0382435a5ca",
    "details": {
      "sha": "f96a6ece1f031c3680229380ac71b0075170206e",
      "filename": "community/kernel/src/main/java/org/neo4j/graphdb/factory/GraphDatabaseSettings.java",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/neo4j/neo4j/blob/259b32fd4a349a4940fc7b115823b0382435a5ca/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fgraphdb%2Ffactory%2FGraphDatabaseSettings.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/259b32fd4a349a4940fc7b115823b0382435a5ca/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fgraphdb%2Ffactory%2FGraphDatabaseSettings.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fgraphdb%2Ffactory%2FGraphDatabaseSettings.java?ref=259b32fd4a349a4940fc7b115823b0382435a5ca",
      "patch": "@@ -180,13 +180,13 @@ public abstract class GraphDatabaseSettings\n     @Description(\"Target size for pages of mapped memory.\")\n     public static final Setting<Long> mapped_memory_page_size = setting(\"mapped_memory_page_size\", BYTES, \"8192\" );\n \n-    @Description(\"The amount of memory to use for mapping the store files, either in bytes or\\n\" +\n-            \" as a percentage of available memory. This will be clipped at the amount of\\n\" +\n-            \" free memory observed when the database starts, and automatically be rounded\\n\" +\n-            \" down to the nearest whole page. For example, if \\\"500MB\\\" is configured, but\\n\" +\n-            \" only 450MB of memory is free when the database starts, then the database will\\n\" +\n-            \" map at most 450MB. If \\\"50%\\\" is configured, and the system has a capacity of\\n\" +\n-            \" 4GB, then at most 2GB of memory will be mapped, unless the database observes\\n\" +\n+    @Description(\"The amount of memory to use for mapping the store files, either in bytes or\" +\n+            \" as a percentage of available memory. This will be clipped at the amount of\" +\n+            \" free memory observed when the database starts, and automatically be rounded\" +\n+            \" down to the nearest whole page. For example, if \\\"500MB\\\" is configured, but\" +\n+            \" only 450MB of memory is free when the database starts, then the database will\" +\n+            \" map at most 450MB. If \\\"50%\\\" is configured, and the system has a capacity of\" +\n+            \" 4GB, then at most 2GB of memory will be mapped, unless the database observes\" +\n             \" that less than 2GB of memory is free when it starts.\")\n     public static final Setting<Long> mapped_memory_total_size = setting(\"mapped_memory_total_size\", directMemoryUsage(), \"50%\" );\n ",
      "parent_sha": "119241c4ac3b09c28c754e66c4a946362759695f"
    }
  },
  {
    "oid": "e4018b8af20fe75258deb77f7205308e423020d7",
    "message": "Serve up static content as war content.\n\nThis makes Jetty extract the content to a temporary directory, eliminating\nthe linear scan and synchronized regions that slow down loading of static\nfiles when serving up content from within a jar file.",
    "date": "2013-07-29T14:56:09Z",
    "url": "https://github.com/neo4j/neo4j/commit/e4018b8af20fe75258deb77f7205308e423020d7",
    "details": {
      "sha": "a659d7f16693775b3c25f11724436d8fe5de6793",
      "filename": "community/server/src/main/java/org/neo4j/server/web/Jetty6WebServer.java",
      "status": "modified",
      "additions": 13,
      "deletions": 15,
      "changes": 28,
      "blob_url": "https://github.com/neo4j/neo4j/blob/e4018b8af20fe75258deb77f7205308e423020d7/community%2Fserver%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fserver%2Fweb%2FJetty6WebServer.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/e4018b8af20fe75258deb77f7205308e423020d7/community%2Fserver%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fserver%2Fweb%2FJetty6WebServer.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fserver%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fserver%2Fweb%2FJetty6WebServer.java?ref=e4018b8af20fe75258deb77f7205308e423020d7",
      "patch": "@@ -33,12 +33,12 @@\n import java.util.Map;\n import java.util.SortedSet;\n import java.util.TreeSet;\n-\n import javax.servlet.Filter;\n import javax.servlet.ServletException;\n import javax.servlet.http.HttpServletRequest;\n import javax.servlet.http.HttpServletResponse;\n \n+import ch.qos.logback.access.jetty.RequestLogImpl;\n import org.mortbay.component.LifeCycle;\n import org.mortbay.jetty.Connector;\n import org.mortbay.jetty.Handler;\n@@ -52,8 +52,8 @@\n import org.mortbay.jetty.servlet.HashSessionManager;\n import org.mortbay.jetty.servlet.SessionHandler;\n import org.mortbay.jetty.webapp.WebAppContext;\n-import org.mortbay.resource.Resource;\n import org.mortbay.thread.QueuedThreadPool;\n+\n import org.neo4j.kernel.guard.Guard;\n import org.neo4j.server.database.InjectableProvider;\n import org.neo4j.server.guard.GuardingRequestFilter;\n@@ -62,8 +62,6 @@\n import org.neo4j.server.security.KeyStoreInformation;\n import org.neo4j.server.security.SslSocketConnectorFactory;\n \n-import ch.qos.logback.access.jetty.RequestLogImpl;\n-\n import static java.lang.String.format;\n \n public class Jetty6WebServer implements WebServer\n@@ -467,21 +465,21 @@ private void loadStaticContent( SessionManager sm, String mountPoint )\n         log.info( \"Mounting static content at [%s] from [%s]\", mountPoint, contentLocation );\n         try\n         {\n-            final WebAppContext staticContext = new WebAppContext( null, new SessionHandler( sm ), null, null );\n-            staticContext.setServer( getJetty() );\n-            staticContext.setContextPath( mountPoint );\n-            URL resourceLoc = getClass().getClassLoader()\n-                .getResource( contentLocation );\n+            URL resourceLoc = getClass().getClassLoader().getResource( contentLocation );\n             if ( resourceLoc != null )\n             {\n                 log.debug( \"Found [%s]\", resourceLoc );\n-                URL url = resourceLoc.toURI()\n-                    .toURL();\n-                final Resource resource = Resource.newResource( url );\n-                staticContext.setBaseResource( resource );\n-                log.debug( \"Mounting static content from [%s] at [%s]\", url, mountPoint );\n+                String location = resourceLoc.toExternalForm();\n+                if ( !location.endsWith( \"/\" ) )\n+                {\n+                    location += \"/\"; // We want the *content* of the directory, not the directory itself.\n+                }\n+                System.out.println( \"resourceLoc: \" + location );\n+                WebAppContext staticContext = new WebAppContext( jetty, location, mountPoint );\n+                staticContext.setSessionHandler( new SessionHandler( sm ) );\n+                log.debug( \"Mounting static content from [%s] at [%s]\", resourceLoc, mountPoint );\n \n-                addFiltersTo(staticContext);\n+                addFiltersTo( staticContext );\n \n                 jetty.addHandler( staticContext );\n             }",
      "parent_sha": "ead1b8772cf878e5324033dd4b2a75d311b40b55"
    }
  },
  {
    "oid": "22958b4771c5454133e8c346418f37972335fd45",
    "message": "Fix file descriptor leak in BackupProtocolServiceIT.",
    "date": "2018-01-10T14:18:04Z",
    "url": "https://github.com/neo4j/neo4j/commit/22958b4771c5454133e8c346418f37972335fd45",
    "details": {
      "sha": "c9d65730ca89fa54bb8334d3e851ea907a44710b",
      "filename": "enterprise/backup/src/test/java/org/neo4j/backup/impl/BackupProtocolServiceIT.java",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/neo4j/neo4j/blob/22958b4771c5454133e8c346418f37972335fd45/enterprise%2Fbackup%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fbackup%2Fimpl%2FBackupProtocolServiceIT.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/22958b4771c5454133e8c346418f37972335fd45/enterprise%2Fbackup%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fbackup%2Fimpl%2FBackupProtocolServiceIT.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/enterprise%2Fbackup%2Fsrc%2Ftest%2Fjava%2Forg%2Fneo4j%2Fbackup%2Fimpl%2FBackupProtocolServiceIT.java?ref=22958b4771c5454133e8c346418f37972335fd45",
      "patch": "@@ -38,6 +38,7 @@\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n+import java.util.stream.Stream;\n \n import org.neo4j.backup.IncrementalBackupNotPossibleException;\n import org.neo4j.backup.OnlineBackupExtensionFactory;\n@@ -415,7 +416,11 @@ public void shouldCopyStoreFiles() throws Throwable\n         db.shutdown();\n \n         // then\n-        File[] files = Files.list( backupDir ).map( Path::toFile ).toArray( File[]::new );\n+        File[] files;\n+        try ( Stream<Path> listing = Files.list( backupDir ) )\n+        {\n+            files = listing.map( Path::toFile ).toArray( File[]::new );\n+        }\n \n         assertTrue( files.length > 0 );\n ",
      "parent_sha": "5ca03a25516898d4123c665dc73108bef4081e27"
    }
  },
  {
    "oid": "d91c23ccfff4b9baa5244cd0e3ab8da84232226a",
    "message": "Satisfy missing dependency in StoreMigration",
    "date": "2017-04-11T15:00:23Z",
    "url": "https://github.com/neo4j/neo4j/commit/d91c23ccfff4b9baa5244cd0e3ab8da84232226a",
    "details": {
      "sha": "da8c3ea2924b5757743bd38479fb90d20512b900",
      "filename": "tools/src/main/java/org/neo4j/tools/migration/StoreMigration.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/neo4j/neo4j/blob/d91c23ccfff4b9baa5244cd0e3ab8da84232226a/tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Ftools%2Fmigration%2FStoreMigration.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/d91c23ccfff4b9baa5244cd0e3ab8da84232226a/tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Ftools%2Fmigration%2FStoreMigration.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/tools%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Ftools%2Fmigration%2FStoreMigration.java?ref=d91c23ccfff4b9baa5244cd0e3ab8da84232226a",
      "patch": "@@ -49,6 +49,7 @@\n import org.neo4j.kernel.impl.storemigration.participant.StoreMigrator;\n import org.neo4j.kernel.impl.util.Dependencies;\n import org.neo4j.kernel.lifecycle.LifeSupport;\n+import org.neo4j.kernel.monitoring.Monitors;\n import org.neo4j.kernel.spi.legacyindex.IndexImplementation;\n import org.neo4j.kernel.spi.legacyindex.IndexProviders;\n import org.neo4j.logging.FormattedLogProvider;\n@@ -110,7 +111,7 @@ public void run( final FileSystemAbstraction fs, final File storeDirectory, Conf\n         try ( PageCache pageCache = createPageCache( fs, config ) )\n         {\n             Dependencies deps = new Dependencies();\n-            deps.satisfyDependencies( fs, config, legacyIndexProvider, pageCache, logService );\n+            deps.satisfyDependencies( fs, config, legacyIndexProvider, pageCache, logService, new Monitors() );\n \n             KernelContext kernelContext = new SimpleKernelContext( storeDirectory, DatabaseInfo.UNKNOWN, deps );\n             KernelExtensions kernelExtensions = life.add( new KernelExtensions(",
      "parent_sha": "74e9852afc7cb13d70172de57ffeace48f2c5375"
    }
  },
  {
    "oid": "5c4111c23397462673c780b7591bbc55c66dab38",
    "message": "Don't free EmptyTraversalCursor\n\nThis fixes a bug where un-usable EmptyTraversalCursors end up in a cursor pool.",
    "date": "2021-02-15T12:42:28Z",
    "url": "https://github.com/neo4j/neo4j/commit/5c4111c23397462673c780b7591bbc55c66dab38",
    "details": {
      "sha": "b1e386d4ef0b7e6d95081a04a78f3ef89427555b",
      "filename": "community/kernel/src/main/java/org/neo4j/kernel/impl/newapi/Cursors.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/neo4j/neo4j/blob/5c4111c23397462673c780b7591bbc55c66dab38/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fnewapi%2FCursors.java",
      "raw_url": "https://github.com/neo4j/neo4j/raw/5c4111c23397462673c780b7591bbc55c66dab38/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fnewapi%2FCursors.java",
      "contents_url": "https://api.github.com/repos/neo4j/neo4j/contents/community%2Fkernel%2Fsrc%2Fmain%2Fjava%2Forg%2Fneo4j%2Fkernel%2Fimpl%2Fnewapi%2FCursors.java?ref=5c4111c23397462673c780b7591bbc55c66dab38",
      "patch": "@@ -42,7 +42,7 @@ public static RelationshipTraversalCursor emptyTraversalCursor( org.neo4j.intern\n         return new EmptyTraversalCursor( (Read) read );\n     }\n \n-    private static class EmptyTraversalCursor implements RelationshipTraversalCursor\n+    public static class EmptyTraversalCursor implements RelationshipTraversalCursor\n     {\n         private final Read read;\n ",
      "parent_sha": "1b278684e49492b948c84b2f98c032d3da1654cc"
    }
  }
]