[
  {
    "oid": "6f034cfaaf7256abba5073497e905c3779ceeec0",
    "message": "Cleanup\n\nSigned-off-by: Tom Erik St\u00f8wer <testower@gmail.com>",
    "date": "2021-04-09T10:52:29Z",
    "url": "https://github.com/redisson/redisson/commit/6f034cfaaf7256abba5073497e905c3779ceeec0",
    "details": {
      "sha": "189e93854bc76db29c6e968931b2a53850a6d54b",
      "filename": "redisson/src/main/java/org/redisson/jcache/JCache.java",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/redisson/redisson/blob/6f034cfaaf7256abba5073497e905c3779ceeec0/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fjcache%2FJCache.java",
      "raw_url": "https://github.com/redisson/redisson/raw/6f034cfaaf7256abba5073497e905c3779ceeec0/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fjcache%2FJCache.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fjcache%2FJCache.java?ref=6f034cfaaf7256abba5073497e905c3779ceeec0",
      "patch": "@@ -157,7 +157,9 @@ String getRemovedChannelName() {\n         return \"jcache_removed_channel:{\" + getRawName() + \"}\";\n     }\n \n-    String getOldValueListenerCounter() { return \"jcache_old_value_listeners:{\" + getName() + \"}\"; }\n+    String getOldValueListenerCounter() {\n+        return \"jcache_old_value_listeners:{\" + getRawName() + \"}\";\n+    }\n \n     long currentNanoTime() {\n         if (config.isStatisticsEnabled()) {\n@@ -2705,19 +2707,19 @@ private V getAndReplaceValueLocked(K key, V value) {\n     }\n \n     private void incrementOldValueListenerCounter(String counterName) {\n-        evalWrite(getName(), codec, RedisCommands.EVAL_INTEGER,\n+        evalWrite(getRawName(), codec, RedisCommands.EVAL_INTEGER,\n                 \"return redis.call('incr', KEYS[1]);\",\n                 Arrays.<Object>asList(counterName));\n     }\n \n     private void decrementOldValueListenerCounter(String counterName) {\n-        evalWrite(getName(), codec, RedisCommands.EVAL_INTEGER,\n+        evalWrite(getRawName(), codec, RedisCommands.EVAL_INTEGER,\n                 \"return redis.call('decr', KEYS[1]);\",\n                 Arrays.<Object>asList(counterName));\n     }\n \n     private Integer getOldValueListenerCount(String counterName) {\n-        return evalWrite(getName(), codec, RedisCommands.EVAL_INTEGER,\n+        return evalWrite(getRawName(), codec, RedisCommands.EVAL_INTEGER,\n                 \"return tonumber(redis.call('get', KEYS[1]));\",\n                 Arrays.<Object>asList(counterName));\n     }",
      "parent_sha": "2368033d19a93dd539fedb53409a4c51283bed39"
    }
  },
  {
    "oid": "19cf41299167b9a1de63ef9023747305d427713d",
    "message": "refactoring",
    "date": "2016-09-07T14:36:58Z",
    "url": "https://github.com/redisson/redisson/commit/19cf41299167b9a1de63ef9023747305d427713d",
    "details": {
      "sha": "d10bef7e69905d789389401f0714ec51417685bd",
      "filename": "redisson/src/main/java/org/redisson/RedissonMap.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/19cf41299167b9a1de63ef9023747305d427713d/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonMap.java",
      "raw_url": "https://github.com/redisson/redisson/raw/19cf41299167b9a1de63ef9023747305d427713d/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonMap.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonMap.java?ref=19cf41299167b9a1de63ef9023747305d427713d",
      "patch": "@@ -485,7 +485,7 @@ public void clear() {\n \n     }\n \n-    protected final Iterator<Map.Entry<K,V>> entryIterator() {\n+    protected Iterator<Map.Entry<K,V>> entryIterator() {\n         return new RedissonMapIterator<K, V, Map.Entry<K, V>>(RedissonMap.this);\n     }\n ",
      "parent_sha": "418bf5acce644200b8fbc1278269928559d875fe"
    }
  },
  {
    "oid": "2c5be69379ab920c003ce4327b7ab916e08dfc81",
    "message": "Fixed - RedisURI throws MalformedURLException for IPv6 hosts",
    "date": "2020-03-03T08:18:28Z",
    "url": "https://github.com/redisson/redisson/commit/2c5be69379ab920c003ce4327b7ab916e08dfc81",
    "details": {
      "sha": "881166070bffa19588738ff418ff0be153da3495",
      "filename": "redisson/src/main/java/org/redisson/misc/RedisURI.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/redisson/redisson/blob/2c5be69379ab920c003ce4327b7ab916e08dfc81/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fmisc%2FRedisURI.java",
      "raw_url": "https://github.com/redisson/redisson/raw/2c5be69379ab920c003ce4327b7ab916e08dfc81/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fmisc%2FRedisURI.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fmisc%2FRedisURI.java?ref=2c5be69379ab920c003ce4327b7ab916e08dfc81",
      "patch": "@@ -31,7 +31,9 @@ public class RedisURI {\n     private final int port;\n \n     public RedisURI(String scheme, String host, int port) {\n-        this(scheme + \"://\" + host + \":\" + port);\n+        this.ssl = scheme.equals(\"rediss\");\n+        this.host = host;\n+        this.port = port;\n     }\n \n     public RedisURI(String uri) {",
      "parent_sha": "09e094f4f8b5b9bebbf92872923dd31fc64f2dde"
    }
  },
  {
    "oid": "8e574ce872be91dfd6ed73e1d623533fc5051cc2",
    "message": "Fix Quarkus redisson config with sentinel config\n\nSimilar to https://github.com/redisson/redisson/issues/4076 config load\nfails for `sentinel-addresses`. This adds sentinel to the LIST_NODES so\nthat sentinel configuration also works.\n\nSigned-off-by: Benjamin N\u00f8rgaard <mail@blacksails.dev>",
    "date": "2024-12-11T11:46:59Z",
    "url": "https://github.com/redisson/redisson/commit/8e574ce872be91dfd6ed73e1d623533fc5051cc2",
    "details": {
      "sha": "4236f75c8db9d6e6e49efc644aaf46b443c96c9f",
      "filename": "redisson/src/main/java/org/redisson/config/PropertiesConvertor.java",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/redisson/redisson/blob/8e574ce872be91dfd6ed73e1d623533fc5051cc2/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconfig%2FPropertiesConvertor.java",
      "raw_url": "https://github.com/redisson/redisson/raw/8e574ce872be91dfd6ed73e1d623533fc5051cc2/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconfig%2FPropertiesConvertor.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconfig%2FPropertiesConvertor.java?ref=8e574ce872be91dfd6ed73e1d623533fc5051cc2",
      "patch": "@@ -81,7 +81,11 @@ private static String convertKey(String key, boolean caseSensitive) {\n     }\n \n     private static final Set<String> LIST_NODES = new HashSet<>(\n-                            Arrays.asList(\"node-addresses\", \"nodeaddresses\", \"slave-addresses\", \"slaveaddresses\", \"addresses\"));\n+            Arrays.asList(\n+                    \"node-addresses\", \"nodeaddresses\",\n+                    \"slave-addresses\", \"slaveaddresses\",\n+                    \"sentinel-addresses\", \"sentineladdresses\",\n+                    \"addresses\"));\n \n     private static final Set<String> CLASS_PROPERTIES = new HashSet<>(\n             Arrays.asList(\"codec\",",
      "parent_sha": "c30fc89fc218a11ae36690ce4e5860663d45454d"
    }
  },
  {
    "oid": "b5e28106b0d83b85e3a03ea810a83e4edb6a4496",
    "message": "compilation fixed",
    "date": "2015-12-11T15:20:58Z",
    "url": "https://github.com/redisson/redisson/commit/b5e28106b0d83b85e3a03ea810a83e4edb6a4496",
    "details": {
      "sha": "dfd4dd84c0c123e03fcbae772eb4ccfa90c8eef3",
      "filename": "src/main/java/org/redisson/EvictionScheduler.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/b5e28106b0d83b85e3a03ea810a83e4edb6a4496/src%2Fmain%2Fjava%2Forg%2Fredisson%2FEvictionScheduler.java",
      "raw_url": "https://github.com/redisson/redisson/raw/b5e28106b0d83b85e3a03ea810a83e4edb6a4496/src%2Fmain%2Fjava%2Forg%2Fredisson%2FEvictionScheduler.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/src%2Fmain%2Fjava%2Forg%2Fredisson%2FEvictionScheduler.java?ref=b5e28106b0d83b85e3a03ea810a83e4edb6a4496",
      "patch": "@@ -123,7 +123,7 @@ public void operationComplete(Future<Integer> future) throws Exception {\n     private final ConcurrentMap<String, RedissonCacheTask> tasks = PlatformDependent.newConcurrentHashMap();\n     private final CommandAsyncExecutor executor;\n \n-    private final Map<String, Long> lastExpiredTime = PlatformDependent.newConcurrentHashMap();\n+    private final ConcurrentMap<String, Long> lastExpiredTime = PlatformDependent.newConcurrentHashMap();\n     private final int expireTaskExecutionDelay = 1000;\n     private final int valuesAmountToClean = 100;\n ",
      "parent_sha": "ec53659eecb2a2b0e8ebfce57ac622e08baa327c"
    }
  },
  {
    "oid": "9433d11a7b3db7217409f5b8c4a133c5e9314d2d",
    "message": "refactoring",
    "date": "2024-06-07T07:45:44Z",
    "url": "https://github.com/redisson/redisson/commit/9433d11a7b3db7217409f5b8c4a133c5e9314d2d",
    "details": {
      "sha": "294794ef6f9ad6fe8678d8786e9a5ffd2a8a6a82",
      "filename": "redisson/src/test/java/org/redisson/RedissonRemoteServiceTest.java",
      "status": "modified",
      "additions": 8,
      "deletions": 9,
      "changes": 17,
      "blob_url": "https://github.com/redisson/redisson/blob/9433d11a7b3db7217409f5b8c4a133c5e9314d2d/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonRemoteServiceTest.java",
      "raw_url": "https://github.com/redisson/redisson/raw/9433d11a7b3db7217409f5b8c4a133c5e9314d2d/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonRemoteServiceTest.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonRemoteServiceTest.java?ref=9433d11a7b3db7217409f5b8c4a133c5e9314d2d",
      "patch": "@@ -378,12 +378,12 @@ public void testCancelAsync() throws InterruptedException {\n \n     @Test\n     public void testCancelReactive() throws InterruptedException {\n-        RedissonReactiveClient r1 = Redisson.create(createConfig()).reactive();\n+        RedissonReactiveClient r1 = createInstance().reactive();\n         AtomicInteger iterations = new AtomicInteger();\n         ExecutorService executor = Executors.newSingleThreadExecutor();\n         r1.getRemoteService().register(RemoteInterface.class, new RemoteImpl(iterations), 1, executor);\n         \n-        RedissonReactiveClient r2 = Redisson.create(createConfig()).reactive();\n+        RedissonReactiveClient r2 = createInstance().reactive();\n         RemoteInterfaceReactive ri = r2.getRemoteService().get(RemoteInterfaceReactive.class);\n         \n         Mono<Void> f = ri.cancelMethod();\n@@ -402,13 +402,12 @@ public void testCancelReactive() throws InterruptedException {\n     \n     @Test\n     public void testCancelRxJava() throws InterruptedException {\n-        RedissonRxClient r1 = Redisson.create(createConfig()).rxJava();\n+        RedissonRxClient r1 = createInstance().rxJava();\n         AtomicInteger iterations = new AtomicInteger();\n         ExecutorService executor = Executors.newSingleThreadExecutor();\n-        r1.getKeys().flushall();\n         r1.getRemoteService().register(RemoteInterface.class, new RemoteImpl(iterations), 1, executor);\n         \n-        RedissonRxClient r2 = Redisson.create(createConfig()).rxJava();\n+        RedissonRxClient r2 = createInstance().rxJava();\n         RemoteInterfaceRx ri = r2.getRemoteService().get(RemoteInterfaceRx.class);\n         \n         Completable f = ri.cancelMethod();\n@@ -463,10 +462,10 @@ public void testAsync() {\n \n     @Test\n     public void testReactive() {\n-        RedissonReactiveClient r1 = Redisson.create(createConfig()).reactive();\n+        RedissonReactiveClient r1 = createInstance().reactive();\n         r1.getRemoteService().register(RemoteInterface.class, new RemoteImpl());\n         \n-        RedissonClient r2 = Redisson.create(createConfig());\n+        RedissonClient r2 = createInstance();\n         RemoteInterfaceReactive ri = r2.getRemoteService().get(RemoteInterfaceReactive.class);\n         \n         Mono<Void> f = ri.voidMethod(\"someName\", 100L);\n@@ -480,10 +479,10 @@ public void testReactive() {\n \n     @Test\n     public void testRx() {\n-        RedissonRxClient r1 = Redisson.create(createConfig()).rxJava();\n+        RedissonRxClient r1 = createInstance().rxJava();\n         r1.getRemoteService().register(RemoteInterface.class, new RemoteImpl());\n         \n-        RedissonRxClient r2 = Redisson.create(createConfig()).rxJava();\n+        RedissonRxClient r2 = createInstance().rxJava();\n         RemoteInterfaceRx ri = r2.getRemoteService().get(RemoteInterfaceRx.class);\n         \n         Completable f = ri.voidMethod(\"someName\", 100L);",
      "parent_sha": "fb0bf29078f2d4aae18e6fa514200918841bcb04"
    }
  },
  {
    "oid": "010d780cabebe48d8fac8fc659a19e44c56e8121",
    "message": "RedisRunner.RedisProcess.stop no longer throws Exception",
    "date": "2017-04-20T22:13:12Z",
    "url": "https://github.com/redisson/redisson/commit/010d780cabebe48d8fac8fc659a19e44c56e8121",
    "details": {
      "sha": "6f9190f8d4d6f4c8fe45ec1adb36cb6b19090cd5",
      "filename": "redisson/src/test/java/org/redisson/RedisRunner.java",
      "status": "modified",
      "additions": 26,
      "deletions": 11,
      "changes": 37,
      "blob_url": "https://github.com/redisson/redisson/blob/010d780cabebe48d8fac8fc659a19e44c56e8121/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedisRunner.java",
      "raw_url": "https://github.com/redisson/redisson/raw/010d780cabebe48d8fac8fc659a19e44c56e8121/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedisRunner.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedisRunner.java?ref=010d780cabebe48d8fac8fc659a19e44c56e8121",
      "patch": "@@ -290,10 +290,7 @@ public RedisProcess runAndCheck() throws IOException, InterruptedException, Fail\n             throw new FailedToStartRedisException();\n         }\n         Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n-            try {\n-                rp.stop();\n-            } catch (InterruptedException ex) {\n-            }\n+            rp.stop();\n         }));\n         return rp;\n     }\n@@ -884,17 +881,36 @@ private RedisProcess(Process redisProcess, RedisRunner runner) {\n             this.runner = runner;\n         }\n \n-        public int stop() throws InterruptedException {\n+        public int stop() {\n             if (runner.isNosave() && !runner.isRandomDir()) {\n                 RedisClient c = createDefaultRedisClientInstance();\n                 RedisConnection connection = c.connect();\n-                connection.async(new RedisStrictCommand<Void>(\"SHUTDOWN\", \"NOSAVE\", new VoidReplayConvertor()))\n-                        .await(3, TimeUnit.SECONDS);\n+                try {\n+                    connection.async(new RedisStrictCommand<Void>(\"SHUTDOWN\", \"NOSAVE\", new VoidReplayConvertor()))\n+                            .await(3, TimeUnit.SECONDS);\n+                } catch (InterruptedException interruptedException) {\n+                    //shutdown via command failed, lets wait and kill it later.\n+                }\n                 c.shutdown();\n                 connection.closeAsync().syncUninterruptibly();\n             }\n-            redisProcess.destroy();\n-            int exitCode = redisProcess.isAlive() ? redisProcess.waitFor() : redisProcess.exitValue();\n+            Process p = redisProcess;\n+            p.destroy();\n+            boolean normalTermination = false;\n+            try {\n+                normalTermination = p.waitFor(5, TimeUnit.SECONDS);\n+            } catch (InterruptedException ex) {\n+                //OK lets hurry up by force kill;\n+            }\n+            if (!normalTermination) {\n+                p = p.destroyForcibly();\n+            }\n+            cleanup();\n+            int exitCode = p.exitValue();\n+            return exitCode == 1 && RedissonRuntimeEnvironment.isWindows ? 0 : exitCode;\n+        }\n+\n+        private void cleanup() {\n             if (runner.isSentinel()) {\n                 runner.deleteSentinelFile();\n             }\n@@ -904,9 +920,8 @@ public int stop() throws InterruptedException {\n             if (runner.isRandomDir()) {\n                 runner.deleteDBfileDir();\n             }\n-            return exitCode == 1 && RedissonRuntimeEnvironment.isWindows ? 0 : exitCode;\n         }\n-\n+        \n         public Process getRedisProcess() {\n             return redisProcess;\n         }",
      "parent_sha": "032c53fa421c21fe6dea0eebee482225c47bd1e9"
    }
  },
  {
    "oid": "6ce6076ba5fdd35cff17cff3d55a496f8258a9b6",
    "message": "redisson#2007: Unit test",
    "date": "2019-03-27T03:41:31Z",
    "url": "https://github.com/redisson/redisson/commit/6ce6076ba5fdd35cff17cff3d55a496f8258a9b6",
    "details": {
      "sha": "640087ce7765570787edc95f662acca7340cbe80",
      "filename": "redisson/src/test/java/org/redisson/RedissonTopicTest.java",
      "status": "modified",
      "additions": 83,
      "deletions": 2,
      "changes": 85,
      "blob_url": "https://github.com/redisson/redisson/blob/6ce6076ba5fdd35cff17cff3d55a496f8258a9b6/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonTopicTest.java",
      "raw_url": "https://github.com/redisson/redisson/raw/6ce6076ba5fdd35cff17cff3d55a496f8258a9b6/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonTopicTest.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonTopicTest.java?ref=6ce6076ba5fdd35cff17cff3d55a496f8258a9b6",
      "patch": "@@ -28,7 +28,7 @@\n import org.junit.BeforeClass;\n import org.junit.Test;\n import org.redisson.ClusterRunner.ClusterProcesses;\n-import org.redisson.RedisRunner.FailedToStartRedisException;\n+import org.redisson.RedisRunner.KEYSPACE_EVENTS_OPTIONS;\n import org.redisson.RedisRunner.RedisProcess;\n import org.redisson.api.RFuture;\n import org.redisson.api.RPatternTopic;\n@@ -38,9 +38,14 @@\n import org.redisson.api.listener.BaseStatusListener;\n import org.redisson.api.listener.MessageListener;\n import org.redisson.api.listener.PatternMessageListener;\n+import org.redisson.api.listener.PatternStatusListener;\n import org.redisson.api.listener.StatusListener;\n+import org.redisson.client.RedisClient;\n+import org.redisson.client.RedisClientConfig;\n+import org.redisson.client.RedisTimeoutException;\n import org.redisson.client.codec.LongCodec;\n import org.redisson.client.codec.StringCodec;\n+import org.redisson.client.protocol.RedisStrictCommand;\n import org.redisson.config.Config;\n import org.redisson.config.SubscriptionMode;\n import org.redisson.connection.balancer.RandomLoadBalancer;\n@@ -820,8 +825,9 @@ public void onMessage(CharSequence channel, Integer msg) {\n         slave2.stop();\n     }\n \n-    protected void sendCommands(RedissonClient redisson, String topicName) {\n+    protected Thread sendCommands(RedissonClient redisson, String topicName) {\n         Thread t = new Thread() {\n+            @Override\n             public void run() {\n                 List<RFuture<?>> futures = new ArrayList<RFuture<?>>();\n                 \n@@ -840,6 +846,7 @@ public void run() {\n             };\n         };\n         t.start();\n+        return t;\n     }\n     \n     @Test\n@@ -980,4 +987,78 @@ public void onMessage(CharSequence channel, Integer msg) {\n         process.shutdown();\n     }\n \n+    @Test\n+    public void testReattachPatternTopicListenersOnClusterFailover() throws Exception {\n+        final KEYSPACE_EVENTS_OPTIONS keyspaceEvents[] =\n+                {KEYSPACE_EVENTS_OPTIONS.K, KEYSPACE_EVENTS_OPTIONS.E, KEYSPACE_EVENTS_OPTIONS.A};\n+        final RedisRunner master = new RedisRunner().randomPort().randomDir().nosave()\n+                .notifyKeyspaceEvents(keyspaceEvents);\n+        final RedisRunner slave = new RedisRunner().randomPort().randomDir().nosave()\n+                .notifyKeyspaceEvents(keyspaceEvents);\n+\n+        final ClusterRunner clusterRunner = new ClusterRunner().addNode(master, slave);\n+        final ClusterProcesses process = clusterRunner.run();\n+\n+        final Config config = new Config();\n+        config.useClusterServers().addNodeAddress(\n+                process.getNodes().stream().findAny().get().getRedisServerAddressAndPort());\n+\n+        final RedissonClient redisson = Redisson.create(config);\n+\n+        final AtomicInteger subscriptions = new AtomicInteger();\n+        final AtomicInteger messagesReceived = new AtomicInteger();\n+\n+        final RPatternTopic topic =\n+                redisson.getPatternTopic(\"__keyspace*__:i*\", StringCodec.INSTANCE);\n+        topic.addListener(new PatternStatusListener() {\n+            @Override\n+            public void onPUnsubscribe(String pattern) {}\n+\n+            @Override\n+            public void onPSubscribe(String pattern) {\n+                subscriptions.incrementAndGet();\n+            }\n+        });\n+        topic.addListener(String.class,\n+                (pattern, channel, msg) -> messagesReceived.incrementAndGet());\n+        Assert.assertEquals(1, subscriptions.get());\n+\n+        sendCommands(redisson, \"dummy\").join();\n+        await().atMost(30, TimeUnit.SECONDS).until(() -> messagesReceived.get() == 100);\n+\n+        failover(process, master, slave);\n+\n+        redisson.getBucket(\"i100\").set(\"\");\n+        await().atMost(30, TimeUnit.SECONDS).until(() -> subscriptions.get() == 2);\n+        await().atMost(5, TimeUnit.SECONDS).until(() -> messagesReceived.get() == 101);\n+\n+        redisson.shutdown();\n+        process.shutdown();\n+    }\n+\n+    private void failover(ClusterProcesses processes, RedisRunner master, RedisRunner slave)\n+            throws InterruptedException {\n+        final RedisClient masterClient = connect(processes, master);\n+        try {\n+            masterClient.connect().sync(new RedisStrictCommand<Void>(\"DEBUG\", \"SEGFAULT\"));\n+        } catch (RedisTimeoutException e) {\n+            // node goes down, so this command times out waiting for the response\n+        }\n+        Thread.sleep(java.time.Duration.ofSeconds(15).toMillis());\n+\n+        final RedisClient slaveClient = connect(processes, slave);\n+        slaveClient.connect().sync(new RedisStrictCommand<Void>(\"CLUSTER\", \"FAILOVER\"), \"TAKEOVER\");\n+        Thread.sleep(java.time.Duration.ofSeconds(15).toMillis());\n+    }\n+\n+    private RedisClient connect(ClusterProcesses processes, RedisRunner runner) {\n+        return RedisClient.create(new RedisClientConfig()\n+                .setAddress(processes.getNodes().stream()\n+                        .filter(node -> node.getRedisServerPort() == runner.getPort())\n+                        .findFirst()\n+                        .map(RedisProcess::getRedisServerAddressAndPort)\n+                        .orElseThrow(() -> new IllegalArgumentException(\n+                                \"Failed to find node running at port: \" + runner.getPort()\n+                                        + \" in cluster processes\"))));\n+    }\n }",
      "parent_sha": "695842d620990db38b69691a7f9d3fc424e5c846"
    }
  },
  {
    "oid": "c748702911deb87c5bdff988aaded263810c7681",
    "message": "test fixed",
    "date": "2022-12-14T08:15:22Z",
    "url": "https://github.com/redisson/redisson/commit/c748702911deb87c5bdff988aaded263810c7681",
    "details": {
      "sha": "74be801b8a9f4f5de80b250809afea5f3d0c8cb4",
      "filename": "redisson/src/test/java/org/redisson/executor/RedissonScheduledExecutorServiceTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/c748702911deb87c5bdff988aaded263810c7681/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2Fexecutor%2FRedissonScheduledExecutorServiceTest.java",
      "raw_url": "https://github.com/redisson/redisson/raw/c748702911deb87c5bdff988aaded263810c7681/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2Fexecutor%2FRedissonScheduledExecutorServiceTest.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2Fexecutor%2FRedissonScheduledExecutorServiceTest.java?ref=c748702911deb87c5bdff988aaded263810c7681",
      "patch": "@@ -254,7 +254,7 @@ void finish(Invocation invocation, String requestId, boolean removeTask) {\n         assertThat(redisson.getAtomicLong(\"counter\").get()).isEqualTo(2);\n         \n         redisson.getKeys().delete(\"counter\");\n-        assertThat(redisson.getKeys().count()).isEqualTo(2);\n+        assertThat(redisson.getKeys().count()).isEqualTo(1);\n     }\n \n     @Test",
      "parent_sha": "c80ceebeb4871449e302bc3c7371d671493ac660"
    }
  },
  {
    "oid": "8809f4b85dc797716ba7f40ff1ee10039ffe8c59",
    "message": "Improvement - each AddressResolver created by SequentialDnsAddressResolverFactory should share common DnsCache and DnsCnameCache instances. #5222\n\nSigned-off-by: Sergey Kuznetsov <sergey.kuznetsov@infobip.com>",
    "date": "2023-08-02T19:22:15Z",
    "url": "https://github.com/redisson/redisson/commit/8809f4b85dc797716ba7f40ff1ee10039ffe8c59",
    "details": {
      "sha": "a31087cf66b052f00ff9ffb6eb56ab0ee613d3df",
      "filename": "redisson/src/main/java/org/redisson/connection/SequentialDnsAddressResolverFactory.java",
      "status": "modified",
      "additions": 8,
      "deletions": 3,
      "changes": 11,
      "blob_url": "https://github.com/redisson/redisson/blob/8809f4b85dc797716ba7f40ff1ee10039ffe8c59/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2FSequentialDnsAddressResolverFactory.java",
      "raw_url": "https://github.com/redisson/redisson/raw/8809f4b85dc797716ba7f40ff1ee10039ffe8c59/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2FSequentialDnsAddressResolverFactory.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2FSequentialDnsAddressResolverFactory.java?ref=8809f4b85dc797716ba7f40ff1ee10039ffe8c59",
      "patch": "@@ -21,8 +21,7 @@\n import io.netty.resolver.AddressResolverGroup;\n import io.netty.resolver.InetSocketAddressResolver;\n import io.netty.resolver.NameResolver;\n-import io.netty.resolver.dns.DnsAddressResolverGroup;\n-import io.netty.resolver.dns.DnsServerAddressStreamProvider;\n+import io.netty.resolver.dns.*;\n import io.netty.util.concurrent.EventExecutor;\n import io.netty.util.concurrent.Promise;\n import org.redisson.misc.AsyncSemaphore;\n@@ -91,7 +90,13 @@ public SequentialDnsAddressResolverFactory(int concurrencyLevel) {\n \n     @Override\n     public AddressResolverGroup<InetSocketAddress> create(Class<? extends DatagramChannel> channelType, DnsServerAddressStreamProvider nameServerProvider) {\n-        DnsAddressResolverGroup group = new DnsAddressResolverGroup(channelType, nameServerProvider) {\n+        DnsNameResolverBuilder dnsResolverBuilder = new DnsNameResolverBuilder();\n+        dnsResolverBuilder.channelType(channelType)\n+                        .nameServerProvider(nameServerProvider)\n+                        .resolveCache(new DefaultDnsCache(0, Integer.MAX_VALUE, 0))\n+                        .cnameCache(new DefaultDnsCnameCache(0, Integer.MAX_VALUE));\n+\n+        DnsAddressResolverGroup group = new DnsAddressResolverGroup(dnsResolverBuilder) {\n             @Override\n             protected AddressResolver<InetSocketAddress> newAddressResolver(EventLoop eventLoop, NameResolver<InetAddress> resolver) throws Exception {\n                 return new LimitedInetSocketAddressResolver(asyncSemaphore, eventLoop, resolver);",
      "parent_sha": "9d2316f6e779b23e3ed9e9f88be89296a1bca901"
    }
  },
  {
    "oid": "7eabd7d4ccd064e2aa781c64990ac337e3739442",
    "message": "Feature - ZStdCodec added #6270",
    "date": "2024-11-09T17:37:08Z",
    "url": "https://github.com/redisson/redisson/commit/7eabd7d4ccd064e2aa781c64990ac337e3739442",
    "details": {
      "sha": "96bed5fd56e7cf9d8a38701d72040391c81084d0",
      "filename": "redisson/src/main/java/org/redisson/codec/ZStdCodec.java",
      "status": "modified",
      "additions": 10,
      "deletions": 11,
      "changes": 21,
      "blob_url": "https://github.com/redisson/redisson/blob/7eabd7d4ccd064e2aa781c64990ac337e3739442/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcodec%2FZStdCodec.java",
      "raw_url": "https://github.com/redisson/redisson/raw/7eabd7d4ccd064e2aa781c64990ac337e3739442/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcodec%2FZStdCodec.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcodec%2FZStdCodec.java?ref=7eabd7d4ccd064e2aa781c64990ac337e3739442",
      "patch": "@@ -65,16 +65,16 @@ public ZStdCodec(ClassLoader classLoader, ZStdCodec codec) throws ReflectiveOper\n         @Override\n         public Object decode(ByteBuf buf, State state) throws IOException {\n             int size = buf.readInt();\n-            ZstdInputStream s = new ZstdInputStream(new ByteBufInputStream(buf));\n-            byte[] bytes = new byte[size];\n-            s.read(bytes);\n-            s.close();\n+            ByteBuf out = ByteBufAllocator.DEFAULT.buffer(size);\n \n-            ByteBuf in = Unpooled.wrappedBuffer(bytes);\n             try {\n-                return innerCodec.getValueDecoder().decode(in, state);\n+                ZstdInputStream in = new ZstdInputStream(new ByteBufInputStream(buf));\n+                out.writeBytes(in, size);\n+                in.close();\n+\n+                return innerCodec.getValueDecoder().decode(out, state);\n             } finally {\n-                in.release();\n+                out.release();\n             }\n         }\n     };\n@@ -88,12 +88,11 @@ public ByteBuf encode(Object in) throws IOException {\n             ByteBuf out = ByteBufAllocator.DEFAULT.buffer();\n             ZstdOutputStream o = new ZstdOutputStream(new ByteBufOutputStream(out));\n \n-            byte[] bytes = new byte[encoded.readableBytes()];\n-            encoded.readBytes(bytes);\n+            int size = encoded.readableBytes();\n+            out.writeInt(size);\n+            encoded.readBytes(o, size);\n             encoded.release();\n \n-            out.writeInt(bytes.length);\n-            o.write(bytes);\n             o.flush();\n             o.close();\n             return out;",
      "parent_sha": "e2e96fec6c3cfea10c67f0265dd3f408abeac048"
    }
  },
  {
    "oid": "9042258a7abf362e982c255d1216d6ec37d475f4",
    "message": "test fixed",
    "date": "2016-08-09T14:50:16Z",
    "url": "https://github.com/redisson/redisson/commit/9042258a7abf362e982c255d1216d6ec37d475f4",
    "details": {
      "sha": "470eb90978851a20c9893488332dfdae02350fba",
      "filename": "redisson/src/test/java/org/redisson/RedissonTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/redisson/redisson/blob/9042258a7abf362e982c255d1216d6ec37d475f4/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonTest.java",
      "raw_url": "https://github.com/redisson/redisson/raw/9042258a7abf362e982c255d1216d6ec37d475f4/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonTest.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonTest.java?ref=9042258a7abf362e982c255d1216d6ec37d475f4",
      "patch": "@@ -21,6 +21,7 @@\n import org.redisson.api.Node;\n import org.redisson.api.NodesGroup;\n import org.redisson.client.RedisConnectionException;\n+import org.redisson.client.RedisException;\n import org.redisson.client.RedisOutOfMemoryException;\n import org.redisson.client.WriteRedisConnectionException;\n import org.redisson.client.protocol.decoder.ListScanResult;\n@@ -104,7 +105,7 @@ public static class Dummy {\n         private String field;\n     }\n \n-    @Test(expected = WriteRedisConnectionException.class)\n+    @Test(expected = RedisException.class)\n     public void testSer() {\n         Config config = new Config();\n         config.useSingleServer().setAddress(\"127.0.0.1:6379\");",
      "parent_sha": "1f78f5e3c6843bfc0b816b743dcae11b39f9fd03"
    }
  },
  {
    "oid": "923949fce5421587d4ee38d710de4ac86030dfc1",
    "message": "remain only changed lines\n\nremain only changed lines\r\n\r\nSigned-off-by: AnJia <anjia0532@gmail.com>",
    "date": "2020-08-24T03:26:45Z",
    "url": "https://github.com/redisson/redisson/commit/923949fce5421587d4ee38d710de4ac86030dfc1",
    "details": {
      "sha": "285ffdc4038139bd760e4c2e251141d3a7086768",
      "filename": "redisson-spring-boot-starter/src/main/java/org/redisson/spring/starter/RedissonAutoConfiguration.java",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/redisson/redisson/blob/923949fce5421587d4ee38d710de4ac86030dfc1/redisson-spring-boot-starter%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fspring%2Fstarter%2FRedissonAutoConfiguration.java",
      "raw_url": "https://github.com/redisson/redisson/raw/923949fce5421587d4ee38d710de4ac86030dfc1/redisson-spring-boot-starter%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fspring%2Fstarter%2FRedissonAutoConfiguration.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson-spring-boot-starter%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fspring%2Fstarter%2FRedissonAutoConfiguration.java?ref=923949fce5421587d4ee38d710de4ac86030dfc1",
      "patch": "@@ -45,11 +45,11 @@\n import org.springframework.util.ReflectionUtils;\n \n /**\n- *\n+ * \n  * @author Nikita Koksharov\n  * @author Nikos Kakavas (https://github.com/nikakis)\n  * @author AnJia (https://anjia0532.github.io/)\n- *\n+ * \n  */\n @Configuration\n @ConditionalOnClass({Redisson.class, RedisOperations.class})\n@@ -65,13 +65,13 @@ public class RedissonAutoConfiguration {\n \n     @Autowired\n     private RedissonProperties redissonProperties;\n-\n+    \n     @Autowired\n     private RedisProperties redisProperties;\n-\n+    \n     @Autowired\n     private ApplicationContext ctx;\n-\n+    \n     @Bean\n     @ConditionalOnMissingBean(name = \"redisTemplate\")\n     public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {\n@@ -93,7 +93,7 @@ public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConne\n     public RedissonConnectionFactory redissonConnectionFactory(RedissonClient redisson) {\n         return new RedissonConnectionFactory(redisson);\n     }\n-\n+    \n     @Bean(destroyMethod = \"shutdown\")\n     @ConditionalOnMissingBean(RedissonClient.class)\n     public RedissonClient redisson() throws IOException {\n@@ -110,7 +110,7 @@ public RedissonClient redisson() throws IOException {\n         } else {\n             timeout = (Integer)timeoutValue;\n         }\n-\n+        \n         if (redissonProperties.getConfigBlock() != null) {\n             try {\n                 config = Config.fromYAML(redissonProperties.getConfigBlock());\n@@ -137,14 +137,14 @@ public RedissonClient redisson() throws IOException {\n         } else if (redisProperties.getSentinel() != null) {\n             Method nodesMethod = ReflectionUtils.findMethod(Sentinel.class, \"getNodes\");\n             Object nodesValue = ReflectionUtils.invokeMethod(nodesMethod, redisProperties.getSentinel());\n-\n+            \n             String[] nodes;\n             if (nodesValue instanceof String) {\n                 nodes = convert(Arrays.asList(((String)nodesValue).split(\",\")));\n             } else {\n                 nodes = convert((List<String>)nodesValue);\n             }\n-\n+            \n             config = new Config();\n             config.useSentinelServers()\n                 .setMasterName(redisProperties.getSentinel().getMaster())\n@@ -156,9 +156,9 @@ public RedissonClient redisson() throws IOException {\n             Object clusterObject = ReflectionUtils.invokeMethod(clusterMethod, redisProperties);\n             Method nodesMethod = ReflectionUtils.findMethod(clusterObject.getClass(), \"getNodes\");\n             List<String> nodesObject = (List) ReflectionUtils.invokeMethod(nodesMethod, clusterObject);\n-\n+            \n             String[] nodes = convert(nodesObject);\n-\n+            \n             config = new Config();\n             config.useClusterServers()\n                 .addNodeAddress(nodes)\n@@ -171,7 +171,7 @@ public RedissonClient redisson() throws IOException {\n             if (method != null && (Boolean)ReflectionUtils.invokeMethod(method, redisProperties)) {\n                 prefix = REDISS_PROTOCOL_PREFIX;\n             }\n-\n+            \n             config.useSingleServer()\n                 .setAddress(prefix + redisProperties.getHost() + \":\" + redisProperties.getPort())\n                 .setConnectTimeout(timeout)\n@@ -204,5 +204,5 @@ private InputStream getConfigStream() throws IOException {\n         return is;\n     }\n \n-\n+    \n }",
      "parent_sha": "40c80d75822c963c2305923a5162d18481373723"
    }
  },
  {
    "oid": "eb450752222d303285c00358c7fce4d22f1856cb",
    "message": "RAtomicLong NPE fixed. #104",
    "date": "2014-12-05T18:18:42Z",
    "url": "https://github.com/redisson/redisson/commit/eb450752222d303285c00358c7fce4d22f1856cb",
    "details": {
      "sha": "0260cec10e001ab8b974ebf7f8df861c0a05d7a8",
      "filename": "src/main/java/org/redisson/RedissonAtomicLong.java",
      "status": "modified",
      "additions": 32,
      "deletions": 24,
      "changes": 56,
      "blob_url": "https://github.com/redisson/redisson/blob/eb450752222d303285c00358c7fce4d22f1856cb/src%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonAtomicLong.java",
      "raw_url": "https://github.com/redisson/redisson/raw/eb450752222d303285c00358c7fce4d22f1856cb/src%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonAtomicLong.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/src%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonAtomicLong.java?ref=eb450752222d303285c00358c7fce4d22f1856cb",
      "patch": "@@ -35,17 +35,6 @@ public class RedissonAtomicLong extends RedissonExpirable implements RAtomicLong\n \n     protected RedissonAtomicLong(ConnectionManager connectionManager, String name) {\n         super(connectionManager, name);\n-\n-        init();\n-    }\n-\n-    private void init() {\n-        connectionManager.writeAsync(new ResultOperation<Boolean, Object>() {\n-            @Override\n-            protected Future<Boolean> execute(RedisAsyncConnection<Object, Object> async) {\n-                return async.setnx(getName(), 0);\n-            }\n-        });\n     }\n \n     @Override\n@@ -65,11 +54,22 @@ public boolean compareAndSet(final long expect, final long update) {\n             public Boolean execute(RedisConnection<Object, Object> conn) {\n                 while (true) {\n                     conn.watch(getName());\n-                    Long value = ((Number) conn.get(getName())).longValue();\n-                    if (value != expect) {\n+\n+                    Number n = (Number) conn.get(getName());\n+                    Long value = null;\n+                    if (n != null) {\n+                        value = n.longValue();\n+                    }\n+                    if (value == null) {\n+                        if (expect != 0) {\n+                            conn.unwatch();\n+                            return false;\n+                        }\n+                    } else if (value != expect) {\n                         conn.unwatch();\n                         return false;\n                     }\n+\n                     conn.multi();\n                     conn.set(getName(), update);\n                     if (conn.exec().size() == 1) {\n@@ -92,18 +92,13 @@ protected Future<Long> execute(RedisAsyncConnection<Object, Object> async) {\n \n     @Override\n     public long get() {\n-        Number res = connectionManager.read(new ResultOperation<Number, Number>() {\n-            @Override\n-            protected Future<Number> execute(RedisAsyncConnection<Object, Number> async) {\n-                return async.get(getName());\n-            }\n-        });\n-        return res.longValue();\n+        return addAndGet(0);\n     }\n \n     @Override\n     public long getAndAdd(long delta) {\n         while (true) {\n+            // TODO optimize\n             long current = get();\n             long next = current + delta;\n             if (compareAndSet(current, next))\n@@ -113,13 +108,26 @@ public long getAndAdd(long delta) {\n \n     @Override\n     public long getAndSet(final long newValue) {\n-        Number res = connectionManager.write(new ResultOperation<Number, Number>() {\n+        return connectionManager.write(new SyncOperation<Object, Long>() {\n             @Override\n-            protected Future<Number> execute(RedisAsyncConnection<Object, Number> async) {\n-                return async.getset(getName(), newValue);\n+            public Long execute(RedisConnection<Object, Object> conn) {\n+                while (true) {\n+                    conn.watch(getName());\n+\n+                    Number n = (Number) conn.get(getName());\n+                    Long value = 0L;\n+                    if (n != null) {\n+                        value = n.longValue();\n+                    }\n+\n+                    conn.multi();\n+                    conn.set(getName(), newValue);\n+                    if (conn.exec().size() == 1) {\n+                        return value;\n+                    }\n+                }\n             }\n         });\n-        return res.longValue();\n     }\n \n     @Override",
      "parent_sha": "949d90ceafe71de8c4fdc47d1e46fab9bca2caf5"
    }
  },
  {
    "oid": "3ab7930af3cb09678bb71315f63db0999fe129b4",
    "message": "refactoring",
    "date": "2020-10-12T06:37:34Z",
    "url": "https://github.com/redisson/redisson/commit/3ab7930af3cb09678bb71315f63db0999fe129b4",
    "details": {
      "sha": "a759c811ad76b5c5016b1bc60327f701b59de0cd",
      "filename": "redisson/src/main/java/org/redisson/config/Config.java",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/redisson/redisson/blob/3ab7930af3cb09678bb71315f63db0999fe129b4/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconfig%2FConfig.java",
      "raw_url": "https://github.com/redisson/redisson/raw/3ab7930af3cb09678bb71315f63db0999fe129b4/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconfig%2FConfig.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconfig%2FConfig.java?ref=3ab7930af3cb09678bb71315f63db0999fe129b4",
      "patch": "@@ -573,48 +573,48 @@ public AddressResolverGroupFactory getAddressResolverGroupFactory() {\n \n     @Deprecated\n     public static Config fromJSON(String content) throws IOException {\n-        log.error(\"Spring XML configuration is deprecated and will be removed in future!\");\n+        log.error(\"JSON configuration is deprecated and will be removed in future!\");\n         ConfigSupport support = new ConfigSupport();\n         return support.fromJSON(content, Config.class);\n     }\n \n     @Deprecated\n     public static Config fromJSON(InputStream inputStream) throws IOException {\n-        log.error(\"Spring XML configuration is deprecated and will be removed in future!\");\n+        log.error(\"JSON configuration is deprecated and will be removed in future!\");\n         ConfigSupport support = new ConfigSupport();\n         return support.fromJSON(inputStream, Config.class);\n     }\n \n     @Deprecated\n     public static Config fromJSON(File file, ClassLoader classLoader) throws IOException {\n-        log.error(\"Spring XML configuration is deprecated and will be removed in future!\");\n+        log.error(\"JSON configuration is deprecated and will be removed in future!\");\n         ConfigSupport support = new ConfigSupport();\n         return support.fromJSON(file, Config.class, classLoader);\n     }\n \n     @Deprecated\n     public static Config fromJSON(File file) throws IOException {\n-        log.error(\"Spring XML configuration is deprecated and will be removed in future!\");\n+        log.error(\"JSON configuration is deprecated and will be removed in future!\");\n         return fromJSON(file, null);\n     }\n \n     @Deprecated\n     public static Config fromJSON(URL url) throws IOException {\n-        log.error(\"Spring XML configuration is deprecated and will be removed in future!\");\n+        log.error(\"JSON configuration is deprecated and will be removed in future!\");\n         ConfigSupport support = new ConfigSupport();\n         return support.fromJSON(url, Config.class);\n     }\n \n     @Deprecated\n     public static Config fromJSON(Reader reader) throws IOException {\n-        log.error(\"Spring XML configuration is deprecated and will be removed in future!\");\n+        log.error(\"JSON configuration is deprecated and will be removed in future!\");\n         ConfigSupport support = new ConfigSupport();\n         return support.fromJSON(reader, Config.class);\n     }\n \n     @Deprecated\n     public String toJSON() throws IOException {\n-        log.error(\"Spring XML configuration is deprecated and will be removed in future!\");\n+        log.error(\"JSON configuration is deprecated and will be removed in future!\");\n         ConfigSupport support = new ConfigSupport();\n         return support.toJSON(this);\n     }",
      "parent_sha": "adf8990356c86d1aa066d1ad125eb05f0037037b"
    }
  },
  {
    "oid": "ca23bb99a2982910fca524924c56efc35c0ed904",
    "message": "fix GEORADIUSBYMEMBER STORE\n\nit was using the wrong codec for member parameter",
    "date": "2017-04-21T16:35:07Z",
    "url": "https://github.com/redisson/redisson/commit/ca23bb99a2982910fca524924c56efc35c0ed904",
    "details": {
      "sha": "9c5f3605d6130e469920c5880654cace2e48c1f7",
      "filename": "redisson/src/main/java/org/redisson/RedissonGeo.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/redisson/redisson/blob/ca23bb99a2982910fca524924c56efc35c0ed904/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonGeo.java",
      "raw_url": "https://github.com/redisson/redisson/raw/ca23bb99a2982910fca524924c56efc35c0ed904/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonGeo.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonGeo.java?ref=ca23bb99a2982910fca524924c56efc35c0ed904",
      "patch": "@@ -443,7 +443,7 @@ public int radiusStore(String fromKey, V member, double radius, GeoUnit geoUnit)\n \n \t@Override\n \tpublic RFuture<Integer> radiusStoreAsync(String fromKey, V member, double radius, GeoUnit geoUnit) {\n-        return commandExecutor.writeAsync(fromKey, LongCodec.INSTANCE, RedisCommands.GEORADIUSBYMEMBER_STORE_INT, fromKey, member, radius, geoUnit, \"STORE\", getName());\n+        return commandExecutor.writeAsync(fromKey, codec, RedisCommands.GEORADIUSBYMEMBER_STORE_INT, fromKey, member, radius, geoUnit, \"STORE\", getName());\n \t}\n \n \t@Override\n@@ -453,7 +453,7 @@ public int radiusStore(String fromKey, V member, double radius, GeoUnit geoUnit,\n \n \t@Override\n \tpublic RFuture<Integer> radiusStoreAsync(String fromKey, V member, double radius, GeoUnit geoUnit, int count) {\n-        return commandExecutor.writeAsync(fromKey, LongCodec.INSTANCE, RedisCommands.GEORADIUSBYMEMBER_STORE_INT, fromKey, member, radius, geoUnit, \"COUNT\", count, \"STORE\", getName());\n+        return commandExecutor.writeAsync(fromKey, codec, RedisCommands.GEORADIUSBYMEMBER_STORE_INT, fromKey, member, radius, geoUnit, \"COUNT\", count, \"STORE\", getName());\n \t}\n \n \t@Override\n@@ -463,7 +463,7 @@ public int radiusStore(String fromKey, V member, double radius, GeoUnit geoUnit,\n \n \t@Override\n \tpublic RFuture<Integer> radiusStoreAsync(String fromKey, V member, double radius, GeoUnit geoUnit, GeoOrder geoOrder, int count) {\n-        return commandExecutor.writeAsync(fromKey, LongCodec.INSTANCE, RedisCommands.GEORADIUSBYMEMBER_STORE_INT, fromKey, member, radius, geoUnit, geoOrder, \"COUNT\", count, \"STORE\", getName());\n+        return commandExecutor.writeAsync(fromKey, codec, RedisCommands.GEORADIUSBYMEMBER_STORE_INT, fromKey, member, radius, geoUnit, geoOrder, \"COUNT\", count, \"STORE\", getName());\n \t}\n \n }",
      "parent_sha": "7a9305684948771273562e8d0d128f420775d474"
    }
  },
  {
    "oid": "fb41f8fda11a81e631d292bcbd7d30941c09c268",
    "message": "test fixed",
    "date": "2016-09-26T09:41:57Z",
    "url": "https://github.com/redisson/redisson/commit/fb41f8fda11a81e631d292bcbd7d30941c09c268",
    "details": {
      "sha": "f5c6f2f01321f612c2a08468d6fb808ec187d78a",
      "filename": "redisson/src/test/java/org/redisson/RedissonSemaphoreTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/fb41f8fda11a81e631d292bcbd7d30941c09c268/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonSemaphoreTest.java",
      "raw_url": "https://github.com/redisson/redisson/raw/fb41f8fda11a81e631d292bcbd7d30941c09c268/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonSemaphoreTest.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonSemaphoreTest.java?ref=fb41f8fda11a81e631d292bcbd7d30941c09c268",
      "patch": "@@ -131,7 +131,7 @@ public void run() {\n         t.join(1);\n \n         long startTime = System.currentTimeMillis();\n-        assertThat(s.tryAcquire(4, 1, TimeUnit.SECONDS)).isTrue();\n+        assertThat(s.tryAcquire(4, 2, TimeUnit.SECONDS)).isTrue();\n         assertThat(System.currentTimeMillis() - startTime).isBetween(900L, 1020L);\n         assertThat(s.availablePermits()).isEqualTo(0);\n     }",
      "parent_sha": "dd706d69f68fcdd0b3823e90a1b3944a08cb4bf2"
    }
  },
  {
    "oid": "52e276288dbfaf3242f5e4623a2107a519330f82",
    "message": "Rename permitsIds to ids\n\nSigned-off-by: Sergey Kuznetsov <sergey.kuznetsov@infobip.com>",
    "date": "2023-08-22T20:00:14Z",
    "url": "https://github.com/redisson/redisson/commit/52e276288dbfaf3242f5e4623a2107a519330f82",
    "details": {
      "sha": "03bcbf0f3d92db9a93f2f37936df34ad422b4450",
      "filename": "redisson/src/main/java/org/redisson/RedissonPermitExpirableSemaphore.java",
      "status": "modified",
      "additions": 48,
      "deletions": 48,
      "changes": 96,
      "blob_url": "https://github.com/redisson/redisson/blob/52e276288dbfaf3242f5e4623a2107a519330f82/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonPermitExpirableSemaphore.java",
      "raw_url": "https://github.com/redisson/redisson/raw/52e276288dbfaf3242f5e4623a2107a519330f82/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonPermitExpirableSemaphore.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonPermitExpirableSemaphore.java?ref=52e276288dbfaf3242f5e4623a2107a519330f82",
      "patch": "@@ -81,9 +81,9 @@ public RFuture<String> acquireAsync(long leaseTime, TimeUnit timeUnit) {\n \n     @Override\n     public List<String> acquire(int permits, long ttl, TimeUnit timeUnit) throws InterruptedException {\n-        List<String> permitsIds = tryAcquire(permits, ttl, timeUnit);\n-        if (!permitsIds.isEmpty() && !hasOnlyNextTimeout(permitsIds)) {\n-            return permitsIds;\n+        List<String> ids = tryAcquire(permits, ttl, timeUnit);\n+        if (!ids.isEmpty() && !hasOnlyNextTimeout(ids)) {\n+            return ids;\n         }\n \n         CompletableFuture<RedissonLockEntry> future = subscribe();\n@@ -92,13 +92,13 @@ public List<String> acquire(int permits, long ttl, TimeUnit timeUnit) throws Int\n         try {\n             while (true) {\n                 Long nearestTimeout;\n-                permitsIds = tryAcquire(permits, ttl, timeUnit);\n-                if (permitsIds.isEmpty()) {\n+                ids = tryAcquire(permits, ttl, timeUnit);\n+                if (ids.isEmpty()) {\n                     nearestTimeout = null;\n-                } else if (hasOnlyNextTimeout(permitsIds)) {\n-                    nearestTimeout = Long.parseLong(permitsIds.get(0).substring(1)) - System.currentTimeMillis();\n+                } else if (hasOnlyNextTimeout(ids)) {\n+                    nearestTimeout = Long.parseLong(ids.get(0).substring(1)) - System.currentTimeMillis();\n                 } else {\n-                    return permitsIds;\n+                    return ids;\n                 }\n                 \n                 if (nearestTimeout != null) {\n@@ -129,9 +129,9 @@ public RFuture<List<String>> acquireAsync(int permits) {\n     public RFuture<List<String>> acquireAsync(int permits, long ttl, TimeUnit timeUnit) {\n         long timeoutDate = calcTimeout(ttl, timeUnit);\n         RFuture<List<String>> tryAcquireFuture = tryAcquireAsync(permits, timeoutDate);\n-        CompletionStage<List<String>> f = tryAcquireFuture.thenCompose(permitsIds -> {\n-            if (!permitsIds.isEmpty() && !hasOnlyNextTimeout(permitsIds)) {\n-                return CompletableFuture.completedFuture(permitsIds);\n+        CompletionStage<List<String>> f = tryAcquireFuture.thenCompose(ids -> {\n+            if (!ids.isEmpty() && !hasOnlyNextTimeout(ids)) {\n+                return CompletableFuture.completedFuture(ids);\n             }\n \n             CompletableFuture<RedissonLockEntry> subscribeFuture = subscribe();\n@@ -140,9 +140,9 @@ public RFuture<List<String>> acquireAsync(int permits, long ttl, TimeUnit timeUn\n         });\n         f.whenComplete((r, e) -> {\n             if (f.toCompletableFuture().isCancelled()) {\n-                tryAcquireFuture.whenComplete((permitsIds, ex) -> {\n-                    if (!permitsIds.isEmpty() && !hasOnlyNextTimeout(permitsIds)) {\n-                        releaseAsync(permitsIds);\n+                tryAcquireFuture.whenComplete((ids, ex) -> {\n+                    if (!ids.isEmpty() && !hasOnlyNextTimeout(ids)) {\n+                        releaseAsync(ids);\n                     }\n                 });\n             }\n@@ -165,22 +165,22 @@ private void tryAcquireAsync(AtomicLong time, int permits, RedissonLockEntry ent\n         long timeoutDate = calcTimeout(ttl, timeUnit);\n         long curr = System.currentTimeMillis();\n         RFuture<List<String>> tryAcquireFuture = tryAcquireAsync(permits, timeoutDate);\n-        tryAcquireFuture.whenComplete((permitsIds, e) -> {\n+        tryAcquireFuture.whenComplete((ids, e) -> {\n             if (e != null) {\n                 unsubscribe(entry);\n                 result.completeExceptionally(e);\n                 return;\n             }\n \n             Long nearestTimeout;\n-            if (permitsIds.isEmpty()) {\n+            if (ids.isEmpty()) {\n                 nearestTimeout = null;\n-            } else if (hasOnlyNextTimeout(permitsIds)) {\n-                nearestTimeout = Long.parseLong(permitsIds.get(0).substring(1)) - System.currentTimeMillis();\n+            } else if (hasOnlyNextTimeout(ids)) {\n+                nearestTimeout = Long.parseLong(ids.get(0).substring(1)) - System.currentTimeMillis();\n             } else {\n                 unsubscribe(entry);\n-                if (!result.complete(permitsIds)) {\n-                    releaseAsync(permitsIds);\n+                if (!result.complete(ids)) {\n+                    releaseAsync(ids);\n                 }\n                 return;\n             }\n@@ -266,15 +266,15 @@ private CompletableFuture<List<String>> acquireAsync(int permits, RedissonLockEn\n             if (e != null) {\n                 unsubscribe(entry);\n             }\n-        }).thenCompose(permitsIds -> {\n+        }).thenCompose(ids -> {\n             Long nearestTimeout;\n-            if (permitsIds.isEmpty()) {\n+            if (ids.isEmpty()) {\n                 nearestTimeout = null;\n-            } else if (hasOnlyNextTimeout(permitsIds)) {\n-                nearestTimeout = Long.parseLong(permitsIds.get(0).substring(1)) - System.currentTimeMillis();\n+            } else if (hasOnlyNextTimeout(ids)) {\n+                nearestTimeout = Long.parseLong(ids.get(0).substring(1)) - System.currentTimeMillis();\n             } else {\n                 unsubscribe(entry);\n-                return CompletableFuture.completedFuture(permitsIds);\n+                return CompletableFuture.completedFuture(ids);\n             }\n \n             if (entry.getLatch().tryAcquire(permits)) {\n@@ -342,15 +342,15 @@ public RFuture<String> tryAcquireAsync() {\n     @Override\n     public RFuture<List<String>> tryAcquireAsync(int permits) {\n         CompletableFuture<List<String>> future = tryAcquireAsync(permits, nonExpirableTimeout).toCompletableFuture()\n-                .thenApply(permitsIds -> {\n-                    if (hasOnlyNextTimeout(permitsIds)) {\n+                .thenApply(ids -> {\n+                    if (hasOnlyNextTimeout(ids)) {\n                         return null;\n                     }\n-                    return permitsIds;\n+                    return ids;\n                 });\n-        future.whenComplete((permitsIds, e) -> {\n-            if (future.isCancelled() && !permitsIds.isEmpty() && !hasOnlyNextTimeout(permitsIds)) {\n-                releaseAsync(permitsIds);\n+        future.whenComplete((ids, e) -> {\n+            if (future.isCancelled() && !ids.isEmpty() && !hasOnlyNextTimeout(ids)) {\n+                releaseAsync(ids);\n             }\n         });\n \n@@ -440,9 +440,9 @@ public List<String> tryAcquire(int permits, long waitTime, long ttl, TimeUnit un\n         long time = unit.toMillis(waitTime);\n         long current = System.currentTimeMillis();\n \n-        List<String> permitsIds = tryAcquire(permits, ttl, unit);\n-        if (!permitsIds.isEmpty() && !hasOnlyNextTimeout(permitsIds)) {\n-            return permitsIds;\n+        List<String> ids = tryAcquire(permits, ttl, unit);\n+        if (!ids.isEmpty() && !hasOnlyNextTimeout(ids)) {\n+            return ids;\n         }\n \n         time -= System.currentTimeMillis() - current;\n@@ -468,13 +468,13 @@ public List<String> tryAcquire(int permits, long waitTime, long ttl, TimeUnit un\n             while (true) {\n                 current = System.currentTimeMillis();\n                 Long nearestTimeout;\n-                permitsIds = tryAcquire(permits, ttl, unit);\n-                if (permitsIds.isEmpty()) {\n+                ids = tryAcquire(permits, ttl, unit);\n+                if (ids.isEmpty()) {\n                     nearestTimeout = null;\n-                } else if (hasOnlyNextTimeout(permitsIds)) {\n-                    nearestTimeout = Long.parseLong(permitsIds.get(0).substring(1)) - System.currentTimeMillis();\n+                } else if (hasOnlyNextTimeout(ids)) {\n+                    nearestTimeout = Long.parseLong(ids.get(0).substring(1)) - System.currentTimeMillis();\n                 } else {\n-                    return permitsIds;\n+                    return ids;\n                 }\n                 \n                 time -= System.currentTimeMillis() - current;\n@@ -509,15 +509,15 @@ public RFuture<List<String>> tryAcquireAsync(int permits, long waitTime, long tt\n         AtomicLong time = new AtomicLong(timeUnit.toMillis(waitTime));\n         long curr = System.currentTimeMillis();\n         long timeoutDate = calcTimeout(ttl, timeUnit);\n-        tryAcquireAsync(permits, timeoutDate).whenComplete((permitsIds, e) -> {\n+        tryAcquireAsync(permits, timeoutDate).whenComplete((ids, e) -> {\n             if (e != null) {\n                 result.completeExceptionally(e);\n                 return;\n             }\n \n-            if (!permitsIds.isEmpty() && !hasOnlyNextTimeout(permitsIds)) {\n-                if (!result.complete(permitsIds)) {\n-                    releaseAsync(permitsIds);\n+            if (!ids.isEmpty() && !hasOnlyNextTimeout(ids)) {\n+                if (!result.complete(ids)) {\n+                    releaseAsync(ids);\n                 }\n                 return;\n             }\n@@ -865,15 +865,15 @@ public boolean updateLeaseTime(String permitId, long leaseTime, TimeUnit unit) {\n         return get(updateLeaseTimeAsync(permitId, leaseTime, unit));\n     }\n \n-    private static boolean hasOnlyNextTimeout(List<String> list) {\n-        return list.size() == 1 && list.get(0).startsWith(\":\");\n+    private static boolean hasOnlyNextTimeout(List<String> ids) {\n+        return ids.size() == 1 && ids.get(0).startsWith(\":\");\n     }\n \n-    private static String getFirstOrNull(List<String> list) {\n-        if (list.isEmpty()) {\n+    private static String getFirstOrNull(List<String> ids) {\n+        if (ids.isEmpty()) {\n             return null;\n         }\n-        return list.get(0);\n+        return ids.get(0);\n     }\n     \n }",
      "parent_sha": "ecee2902492a88fe0c704c0219655cb77bd2da26"
    }
  },
  {
    "oid": "786cda02cdc3843ee75980e921d1b540756a5c29",
    "message": "refactoring",
    "date": "2018-12-25T09:42:34Z",
    "url": "https://github.com/redisson/redisson/commit/786cda02cdc3843ee75980e921d1b540756a5c29",
    "details": {
      "sha": "9476c189a73026603917573138258d83de756158",
      "filename": "redisson/src/main/java/org/redisson/client/handler/CommandDecoder.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/786cda02cdc3843ee75980e921d1b540756a5c29/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fhandler%2FCommandDecoder.java",
      "raw_url": "https://github.com/redisson/redisson/raw/786cda02cdc3843ee75980e921d1b540756a5c29/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fhandler%2FCommandDecoder.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fhandler%2FCommandDecoder.java?ref=786cda02cdc3843ee75980e921d1b540756a5c29",
      "patch": "@@ -332,7 +332,7 @@ protected void decode(ByteBuf in, CommandData<Object, Object> data, List<Object>\n             handleResult(data, parts, result, false, channel);\n         } else if (code == '*') {\n             long size = readLong(in);\n-            final List<Object> respParts = new ArrayList<Object>();\n+            final List<Object> respParts = new ArrayList<Object>(Math.max((int)size, 0));\n             \n             StateLevel lastLevel = null;\n             if (state().isMakeCheckpoint()) {",
      "parent_sha": "1768f4ff488aeda2c013e61d63485de9ebf9c72d"
    }
  },
  {
    "oid": "aabceeea7785de9475ba4a144c3e4b6938c2ff95",
    "message": "Fixed - Node hasn't been discovered yet error isn't resolved by a new attempt for RBatch and RLock objects #4822",
    "date": "2023-02-28T07:01:17Z",
    "url": "https://github.com/redisson/redisson/commit/aabceeea7785de9475ba4a144c3e4b6938c2ff95",
    "details": {
      "sha": "49e9737e514ba209d8f1ce77dc9fe480150b7dde",
      "filename": "redisson/src/main/java/org/redisson/command/CommandBatchService.java",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/redisson/redisson/blob/aabceeea7785de9475ba4a144c3e4b6938c2ff95/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcommand%2FCommandBatchService.java",
      "raw_url": "https://github.com/redisson/redisson/raw/aabceeea7785de9475ba4a144c3e4b6938c2ff95/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcommand%2FCommandBatchService.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcommand%2FCommandBatchService.java?ref=aabceeea7785de9475ba4a144c3e4b6938c2ff95",
      "patch": "@@ -478,7 +478,12 @@ public void run(Timeout timeout) throws Exception {\n                 AtomicInteger attempt = new AtomicInteger();\n                 CompletableFuture<Map<MasterSlaveEntry, Entry>> resolvedEntriesFuture = new CompletableFuture<>();\n                 resolveCommands(attempt, resolvedEntriesFuture);\n-                resolvedEntriesFuture.thenAccept(map -> {\n+                resolvedEntriesFuture.whenComplete((map, ee) -> {\n+                    if (ee != null) {\n+                        resultPromise.completeExceptionally(ee);\n+                        return;\n+                    }\n+\n                     List<CompletableFuture<Void>> futures = new ArrayList<>(map.size());\n                     for (Map.Entry<MasterSlaveEntry, Entry> entry : aggregatedCommands.entrySet()) {\n                         boolean isReadOnly = options.getExecutionMode() == ExecutionMode.REDIS_READ_ATOMIC;",
      "parent_sha": "63a8f98ec7fe5d96a3e882f6e34e99f7eb2ad149"
    }
  },
  {
    "oid": "db4fe1546a8fe595624562aa7768c1a1ccb083fb",
    "message": "Fixed - Repeated new connections with AWS Elasticache serverless #5589",
    "date": "2024-01-31T11:36:30Z",
    "url": "https://github.com/redisson/redisson/commit/db4fe1546a8fe595624562aa7768c1a1ccb083fb",
    "details": {
      "sha": "5e8020e2d845d473774ae580642c403cbf1edee9",
      "filename": "redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/db4fe1546a8fe595624562aa7768c1a1ccb083fb/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcluster%2FClusterConnectionManager.java",
      "raw_url": "https://github.com/redisson/redisson/raw/db4fe1546a8fe595624562aa7768c1a1ccb083fb/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcluster%2FClusterConnectionManager.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcluster%2FClusterConnectionManager.java?ref=db4fe1546a8fe595624562aa7768c1a1ccb083fb",
      "patch": "@@ -849,7 +849,7 @@ private CompletableFuture<Collection<ClusterPartition>> parsePartitions(List<Clu\n                 int index = 0;\n                 if (addresses.size() > 1) {\n                     addresses.sort(Comparator.comparing(RedisURI::getHost));\n-                    Random r = new Random(serviceManager.getId().hashCode());\n+                    SplittableRandom r = new SplittableRandom(serviceManager.getId().hashCode());\n                     index = r.nextInt(addresses.size());\n                 }\n                 RedisURI address = addresses.get(index);",
      "parent_sha": "935ca1a50ffc22231fa7a7c8d789b6e13e910878"
    }
  },
  {
    "oid": "2e4db010372e7b84ccde465af863456222c2ef54",
    "message": "Fixed - Slave node in cluster mode isn't shutdown properly if readMode = MASTER and subscribeMode = MASTER (regression since 3.27.2) #5752",
    "date": "2024-04-19T05:29:11Z",
    "url": "https://github.com/redisson/redisson/commit/2e4db010372e7b84ccde465af863456222c2ef54",
    "details": {
      "sha": "faaf70d5fbd1e4fd5d09adf5d31ae212b7af869f",
      "filename": "redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/redisson/redisson/blob/2e4db010372e7b84ccde465af863456222c2ef54/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcluster%2FClusterConnectionManager.java",
      "raw_url": "https://github.com/redisson/redisson/raw/2e4db010372e7b84ccde465af863456222c2ef54/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcluster%2FClusterConnectionManager.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcluster%2FClusterConnectionManager.java?ref=2e4db010372e7b84ccde465af863456222c2ef54",
      "patch": "@@ -534,7 +534,8 @@ private CompletableFuture<Void> upDownSlaves(MasterSlaveEntry entry, ClusterPart\n                 .filter(uri -> !currentPart.getFailedSlaveAddresses().contains(uri))\n                 .forEach(uri -> {\n                     currentPart.addFailedSlaveAddress(uri);\n-                    if (config.isSlaveNotUsed() || entry.slaveDown(uri, FreezeReason.MANAGER)) {\n+                    boolean slaveDown = entry.slaveDown(uri, FreezeReason.MANAGER);\n+                    if (config.isSlaveNotUsed() || slaveDown) {\n                         disconnectNode(uri);\n                         log.warn(\"slave: {} has down for slot ranges: {}\", uri, currentPart.getSlotRanges());\n                     }\n@@ -554,7 +555,8 @@ private CompletableFuture<Set<RedisURI>> addRemoveSlaves(MasterSlaveEntry entry,\n         for (RedisURI uri : removedSlaves) {\n             currentPart.removeSlaveAddress(uri);\n \n-            if (config.isSlaveNotUsed() || entry.slaveDown(uri, FreezeReason.MANAGER)) {\n+            boolean slaveDown = entry.slaveDown(uri, FreezeReason.MANAGER);\n+            if (config.isSlaveNotUsed() || slaveDown) {\n                 disconnectNode(uri);\n                 log.info(\"slave {} removed for master {} and slot ranges: {}\",\n                         currentPart.getMasterAddress(), uri, currentPart.getSlotRanges());",
      "parent_sha": "77919d08b4c3d9c2920fb236bf468b67e901e578"
    }
  },
  {
    "oid": "7cb556e0506813c050c2301231ef2d9a4e1628c4",
    "message": "refactoring",
    "date": "2023-03-27T13:28:19Z",
    "url": "https://github.com/redisson/redisson/commit/7cb556e0506813c050c2301231ef2d9a4e1628c4",
    "details": {
      "sha": "5996cdb64fe1bf63ea439722d90e6ab93cf9d793",
      "filename": "redisson/src/main/java/org/redisson/client/RedisConnection.java",
      "status": "modified",
      "additions": 9,
      "deletions": 7,
      "changes": 16,
      "blob_url": "https://github.com/redisson/redisson/blob/7cb556e0506813c050c2301231ef2d9a4e1628c4/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2FRedisConnection.java",
      "raw_url": "https://github.com/redisson/redisson/raw/7cb556e0506813c050c2301231ef2d9a4e1628c4/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2FRedisConnection.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2FRedisConnection.java?ref=7cb556e0506813c050c2301231ef2d9a4e1628c4",
      "patch": "@@ -46,14 +46,15 @@\n  */\n public class RedisConnection implements RedisCommands {\n \n+    public enum Status {OPEN, CLOSED, CLOSED_IDLE}\n+\n     private static final Logger LOG = LoggerFactory.getLogger(RedisConnection.class);\n     private static final AttributeKey<RedisConnection> CONNECTION = AttributeKey.valueOf(\"connection\");\n \n     final RedisClient redisClient;\n \n     private volatile CompletableFuture<Void> fastReconnect;\n-    private volatile boolean closed;\n-    private volatile boolean closedIdle;\n+    private volatile Status status = Status.OPEN;\n     volatile Channel channel;\n \n     private CompletableFuture<?> connectionPromise;\n@@ -280,7 +281,7 @@ public <T, R> CommandData<T, R> create(Codec encoder, RedisCommand<T> command, O\n     }\n \n     public boolean isClosed() {\n-        return closed;\n+        return status != Status.OPEN;\n     }\n \n     public boolean isFastReconnect() {\n@@ -323,16 +324,17 @@ public Channel getChannel() {\n     }\n \n     public ChannelFuture closeIdleAsync() {\n-        closedIdle = true;\n-        return closeAsync();\n+        status = Status.CLOSED_IDLE;\n+        close();\n+        return channel.closeFuture();\n     }\n \n     public boolean isClosedIdle() {\n-        return closedIdle;\n+        return status == Status.CLOSED_IDLE;\n     }\n \n     public ChannelFuture closeAsync() {\n-        closed = true;\n+        status = Status.CLOSED;\n         close();\n         return channel.closeFuture();\n     }",
      "parent_sha": "b23224d470fc696e4f7b4ab64de2da89ec516360"
    }
  },
  {
    "oid": "a8096c0a071adbba93bd9012b243a43ed47a4e6f",
    "message": "Update usages of getChannelName\n\nSigned-off-by: maddie-boisvert <maddie.boisvert@gmail.com>",
    "date": "2023-01-03T16:22:13Z",
    "url": "https://github.com/redisson/redisson/commit/a8096c0a071adbba93bd9012b243a43ed47a4e6f",
    "details": {
      "sha": "690d27f4cf1284f1f241e5f2dc9a8be7906c8d52",
      "filename": "redisson/src/main/java/org/redisson/RedissonPermitExpirableSemaphore.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/redisson/redisson/blob/a8096c0a071adbba93bd9012b243a43ed47a4e6f/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonPermitExpirableSemaphore.java",
      "raw_url": "https://github.com/redisson/redisson/raw/a8096c0a071adbba93bd9012b243a43ed47a4e6f/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonPermitExpirableSemaphore.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonPermitExpirableSemaphore.java?ref=a8096c0a071adbba93bd9012b243a43ed47a4e6f",
      "patch": "@@ -666,7 +666,7 @@ public RFuture<Integer> getPermitsAsync() {\n                     \"return tonumber(available) \" +\n                 \"end;\" +\n                 \"return tonumber(available) + acquired;\",\n-                Arrays.<Object>asList(getRawName(), timeoutName, getChannelName()), System.currentTimeMillis());\n+                Arrays.<Object>asList(getRawName(), timeoutName, channelName), System.currentTimeMillis());\n     }\n \n     @Override\n@@ -682,7 +682,7 @@ public RFuture<Integer> acquiredPermitsAsync() {\n                 \"end; \" +\n                 \"local acquired = redis.call('zcount', KEYS[2], 0, '+inf'); \" +\n                 \"return acquired == false and 0 or acquired;\",\n-                Arrays.<Object>asList(getRawName(), timeoutName, getChannelName()), System.currentTimeMillis());\n+                Arrays.<Object>asList(getRawName(), timeoutName, channelName), System.currentTimeMillis());\n     }\n \n     @Override\n@@ -711,7 +711,7 @@ public RFuture<Void> setPermitsAsync(int permits) {\n                 \"end;\" +\n                 \"redis.call('incrby', KEYS[1], tonumber(ARGV[1]) - maximum); \" +\n                 \"redis.call('publish', KEYS[2], ARGV[1]);\",\n-                Arrays.<Object>asList(getRawName(), getChannelName(), timeoutName), permits);\n+                Arrays.<Object>asList(getRawName(), channelName, timeoutName), permits);\n     }\n \n     @Override",
      "parent_sha": "61d1b8a85e7c7d0ddae1c5cfd094f69125abaf53"
    }
  },
  {
    "oid": "22c90d4555db71e05d67292f2dd646cc87cf6865",
    "message": "fixed a test bug",
    "date": "2016-09-14T20:53:04Z",
    "url": "https://github.com/redisson/redisson/commit/22c90d4555db71e05d67292f2dd646cc87cf6865",
    "details": {
      "sha": "d366c993e6642cae0403cfe04d1426b0f5dde5cf",
      "filename": "redisson/src/test/java/org/redisson/RedissonMapCacheReactiveTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/redisson/redisson/blob/22c90d4555db71e05d67292f2dd646cc87cf6865/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonMapCacheReactiveTest.java",
      "raw_url": "https://github.com/redisson/redisson/raw/22c90d4555db71e05d67292f2dd646cc87cf6865/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonMapCacheReactiveTest.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonMapCacheReactiveTest.java?ref=22c90d4555db71e05d67292f2dd646cc87cf6865",
      "patch": "@@ -373,9 +373,9 @@ public void testSize() {\n     @Test\n     public void testEmptyRemove() {\n         RMapCacheReactive<Integer, Integer> map = redisson.getMapCache(\"simple\");\n-        assertThat(sync(map.remove(1, 3))).isEqualTo(0);\n+        assertThat(sync(map.remove(1, 3))).isEqualTo(Boolean.FALSE);\n         sync(map.put(4, 5));\n-        assertThat(sync(map.remove(4, 5))).isEqualTo(1);\n+        assertThat(sync(map.remove(4, 5))).isEqualTo(Boolean.TRUE);\n     }\n \n     @Test",
      "parent_sha": "1ca644b54cfa9f13fb9f75c89c38448e3b3a1f6c"
    }
  },
  {
    "oid": "79971af00350f300954dde708a1e4d12b577f1df",
    "message": "refactoring",
    "date": "2021-12-14T10:44:58Z",
    "url": "https://github.com/redisson/redisson/commit/79971af00350f300954dde708a1e4d12b577f1df",
    "details": {
      "sha": "491c0bb2e5a9c1ee16b6c550e570ae9b34945a4f",
      "filename": "redisson/src/main/java/org/redisson/RedisNodes.java",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/redisson/redisson/blob/79971af00350f300954dde708a1e4d12b577f1df/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedisNodes.java",
      "raw_url": "https://github.com/redisson/redisson/raw/79971af00350f300954dde708a1e4d12b577f1df/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedisNodes.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedisNodes.java?ref=79971af00350f300954dde708a1e4d12b577f1df",
      "patch": "@@ -127,10 +127,8 @@ public boolean pingAll(long timeout, TimeUnit timeUnit) {\n                 if (c != null) {\n                     RFuture<String> r = c.async(timeUnit.toMillis(timeout), RedisCommands.PING);\n                     result.put(c, r);\n-                    latch.countDown();\n-                } else {\n-                    latch.countDown();\n                 }\n+                latch.countDown();\n             });\n         }\n ",
      "parent_sha": "877535e08604218db1a350b6d0e6c315611560d1"
    }
  },
  {
    "oid": "8610d60b0c1d9a3f1ed334871b51cdfe5da1a577",
    "message": "Fixed - Spring session ID change doesn't work in Redis cluster #1897",
    "date": "2019-02-01T14:12:17Z",
    "url": "https://github.com/redisson/redisson/commit/8610d60b0c1d9a3f1ed334871b51cdfe5da1a577",
    "details": {
      "sha": "933a6e206b1350de073f034098ad793cae05345b",
      "filename": "redisson/src/main/java/org/redisson/spring/session/RedissonSessionRepository.java",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/redisson/redisson/blob/8610d60b0c1d9a3f1ed334871b51cdfe5da1a577/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fspring%2Fsession%2FRedissonSessionRepository.java",
      "raw_url": "https://github.com/redisson/redisson/raw/8610d60b0c1d9a3f1ed334871b51cdfe5da1a577/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fspring%2Fsession%2FRedissonSessionRepository.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fspring%2Fsession%2FRedissonSessionRepository.java?ref=8610d60b0c1d9a3f1ed334871b51cdfe5da1a577",
      "patch": "@@ -216,7 +216,14 @@ public boolean isExpired() {\n         @Override\n         public String changeSessionId() {\n             String id = delegate.changeSessionId();\n-            map.rename(keyPrefix + id);\n+            if (redisson.getConfig().isClusterConfig()) {\n+                Map<String, Object> oldState = map.readAllMap();\n+                map.delete();\n+                map = redisson.getMap(keyPrefix + id, map.getCodec());\n+                map.putAll(oldState);\n+            } else {\n+                map.rename(keyPrefix + id);\n+            }\n             return id;\n         }\n ",
      "parent_sha": "584cb7c15182311abca7067d140169df47a33bb9"
    }
  },
  {
    "oid": "bae67d6191b75b22cc518c4ac83db4d468013c75",
    "message": "refactoring",
    "date": "2018-03-01T16:53:40Z",
    "url": "https://github.com/redisson/redisson/commit/bae67d6191b75b22cc518c4ac83db4d468013c75",
    "details": {
      "sha": "3a032dc697f494dd0e3452b141623326da5adf9d",
      "filename": "redisson/src/main/java/org/redisson/command/CommandAsyncService.java",
      "status": "modified",
      "additions": 8,
      "deletions": 6,
      "changes": 14,
      "blob_url": "https://github.com/redisson/redisson/blob/bae67d6191b75b22cc518c4ac83db4d468013c75/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcommand%2FCommandAsyncService.java",
      "raw_url": "https://github.com/redisson/redisson/raw/bae67d6191b75b22cc518c4ac83db4d468013c75/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcommand%2FCommandAsyncService.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcommand%2FCommandAsyncService.java?ref=bae67d6191b75b22cc518c4ac83db4d468013c75",
      "patch": "@@ -149,14 +149,10 @@ public void operationComplete(Future<V> future) throws Exception {\n             boolean interrupted = false;\n             while (!future.isDone()) {\n                 try {\n-                    MasterSlaveServersConfig config = connectionManager.getConfig();\n-                    int timeout = config.getTimeout() + config.getRetryInterval() * config.getRetryAttempts();\n-                    if (!l.await(timeout, TimeUnit.MILLISECONDS)) {\n-                        ((RPromise<V>)future).tryFailure(new RedisTimeoutException(\"Command timeout: (\" + timeout + \" ms)\"));\n-                        break;\n-                    }\n+                    l.await();\n                 } catch (InterruptedException e) {\n                     interrupted = true;\n+                    break;\n                 }\n             }\n \n@@ -529,6 +525,12 @@ public void run(Timeout t) throws Exception {\n                 }\n \n                 if (details.getConnectionFuture().cancel(false)) {\n+                    if (details.getException() == null) {\n+                        details.setException(new RedisTimeoutException(\"Unable to get connection! \"\n+                                    + \"Node source: \" + source\n+                                    + \", command: \" + command + \", command params: \" + LogHelper.toString(details.getParams()) \n+                                    + \" after \" + connectionManager.getConfig().getRetryAttempts() + \" retry attempts\"));\n+                    }\n                     connectionManager.getShutdownLatch().release();\n                 } else {\n                     if (details.getConnectionFuture().isSuccess()) {",
      "parent_sha": "bfe853989c2cbe5e1e1e01676812d7d2f8882ee4"
    }
  },
  {
    "oid": "30b1be87a3e519dcb1ab70676bcb74096a46285a",
    "message": "`Not all slots are covered` error should be more informative",
    "date": "2016-09-23T10:19:29Z",
    "url": "https://github.com/redisson/redisson/commit/30b1be87a3e519dcb1ab70676bcb74096a46285a",
    "details": {
      "sha": "02e32138732e3bde396901da635f5802520780e1",
      "filename": "redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/30b1be87a3e519dcb1ab70676bcb74096a46285a/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcluster%2FClusterConnectionManager.java",
      "raw_url": "https://github.com/redisson/redisson/raw/30b1be87a3e519dcb1ab70676bcb74096a46285a/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcluster%2FClusterConnectionManager.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcluster%2FClusterConnectionManager.java?ref=30b1be87a3e519dcb1ab70676bcb74096a46285a",
      "patch": "@@ -114,7 +114,7 @@ public ClusterConnectionManager(ClusterServersConfig cfg, Config config) {\n                     for (RFuture<Void> future : masterFuture.getNow()) {\n                         future.awaitUninterruptibly();\n                         if (!future.isSuccess()) {\n-                            continue;\n+                            lastException = masterFuture.cause();\n                         }\n                     }\n                 }",
      "parent_sha": "dd02c3f55ada9b361d19d7798fc09238e75e7aef"
    }
  },
  {
    "oid": "3169a1cda73aac97007016131b0b1c5155e9c15d",
    "message": "Fixed - ServiceManager.calcSHA() method should use UTF-8 encoding by default. #5531",
    "date": "2023-12-25T12:22:48Z",
    "url": "https://github.com/redisson/redisson/commit/3169a1cda73aac97007016131b0b1c5155e9c15d",
    "details": {
      "sha": "2695d80a9bc66224639470c3255c9b43625ea1c0",
      "filename": "redisson/src/main/java/org/redisson/connection/ServiceManager.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/redisson/redisson/blob/3169a1cda73aac97007016131b0b1c5155e9c15d/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2FServiceManager.java",
      "raw_url": "https://github.com/redisson/redisson/raw/3169a1cda73aac97007016131b0b1c5155e9c15d/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2FServiceManager.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2FServiceManager.java?ref=3169a1cda73aac97007016131b0b1c5155e9c15d",
      "patch": "@@ -67,6 +67,7 @@\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n import java.net.UnknownHostException;\n+import java.nio.charset.StandardCharsets;\n import java.security.MessageDigest;\n import java.util.*;\n import java.util.concurrent.*;\n@@ -453,7 +454,7 @@ public String calcSHA(String script) {\n         return SHA_CACHE.computeIfAbsent(script, k -> {\n             try {\n                 MessageDigest mdigest = MessageDigest.getInstance(\"SHA-1\");\n-                byte[] s = mdigest.digest(script.getBytes());\n+                byte[] s = mdigest.digest(script.getBytes(StandardCharsets.UTF_8));\n                 return ByteBufUtil.hexDump(s);\n             } catch (Exception e) {\n                 throw new IllegalStateException(e);",
      "parent_sha": "a0205f9389901f03444bfd51b482db68f6974118"
    }
  },
  {
    "oid": "7b35902d30ce3c488569026fa4b9a51c6cfb8aa9",
    "message": "LockValue is serializable now",
    "date": "2014-01-06T14:12:43Z",
    "url": "https://github.com/redisson/redisson/commit/7b35902d30ce3c488569026fa4b9a51c6cfb8aa9",
    "details": {
      "sha": "86fec82f50c4efa301947719339e9a2d8cd2bd34",
      "filename": "src/main/java/org/redisson/RedissonLock.java",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/redisson/redisson/blob/7b35902d30ce3c488569026fa4b9a51c6cfb8aa9/src%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonLock.java",
      "raw_url": "https://github.com/redisson/redisson/raw/7b35902d30ce3c488569026fa4b9a51c6cfb8aa9/src%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonLock.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/src%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonLock.java?ref=7b35902d30ce3c488569026fa4b9a51c6cfb8aa9",
      "patch": "@@ -15,6 +15,7 @@\n  */\n package org.redisson;\n \n+import java.io.Serializable;\n import java.util.UUID;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.Semaphore;\n@@ -35,7 +36,9 @@\n  */\n public class RedissonLock implements RLock {\n \n-    public static class LockValue {\n+    public static class LockValue implements Serializable {\n+\n+        private static final long serialVersionUID = -8895632286065689476L;\n \n         private UUID id;\n         private Long threadId;",
      "parent_sha": "eed1f22be8a880cd92b2e9412e015b7f0031e3ac"
    }
  },
  {
    "oid": "6f6f0ffde484974f9a960924be14ff050046a7ff",
    "message": "Script issue fixed in RScoredSortedSet.retainAll",
    "date": "2016-05-04T17:13:11Z",
    "url": "https://github.com/redisson/redisson/commit/6f6f0ffde484974f9a960924be14ff050046a7ff",
    "details": {
      "sha": "43edf86bdb5c6ee19eaa7a56128d66f8e54f2b2d",
      "filename": "src/main/java/org/redisson/RedissonScoredSortedSet.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/6f6f0ffde484974f9a960924be14ff050046a7ff/src%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonScoredSortedSet.java",
      "raw_url": "https://github.com/redisson/redisson/raw/6f6f0ffde484974f9a960924be14ff050046a7ff/src%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonScoredSortedSet.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/src%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonScoredSortedSet.java?ref=6f6f0ffde484974f9a960924be14ff050046a7ff",
      "patch": "@@ -353,7 +353,7 @@ public Future<Boolean> retainAllAsync(Collection<?> c) {\n         return commandExecutor.evalWriteAsync(getName(), codec, RedisCommands.EVAL_BOOLEAN,\n                 \"redis.call('zadd', KEYS[2], unpack(ARGV)); \"\n                  + \"local prevSize = redis.call('zcard', KEYS[1]); \"\n-                 + \"local size = redis.call('zinterstore', KEYS[1], #ARGV/2, KEYS[1], KEYS[2], 'aggregate', 'sum');\"\n+                 + \"local size = redis.call('zinterstore', KEYS[1], 2, KEYS[1], KEYS[2], 'aggregate', 'sum');\"\n                  + \"redis.call('del', KEYS[2]); \"\n                  + \"return size ~= prevSize and 1 or 0; \",\n              Arrays.<Object>asList(getName(), \"redisson_temp__{\" + getName() + \"}\"), params.toArray());",
      "parent_sha": "1d123af02b6f99d5ebd56ecd07d4b7180b38c44f"
    }
  },
  {
    "oid": "ac6581ed21d111d27dfbe41b1662d742df3d0c43",
    "message": "Fixed - RBatch throws NoSuchElementException. #2212",
    "date": "2019-08-03T07:37:06Z",
    "url": "https://github.com/redisson/redisson/commit/ac6581ed21d111d27dfbe41b1662d742df3d0c43",
    "details": {
      "sha": "d2e90f4a762db2dc17b6c919ac24b8576c18fe7c",
      "filename": "redisson/src/main/java/org/redisson/command/CommandBatchService.java",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/redisson/redisson/blob/ac6581ed21d111d27dfbe41b1662d742df3d0c43/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcommand%2FCommandBatchService.java",
      "raw_url": "https://github.com/redisson/redisson/raw/ac6581ed21d111d27dfbe41b1662d742df3d0c43/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcommand%2FCommandBatchService.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcommand%2FCommandBatchService.java?ref=ac6581ed21d111d27dfbe41b1662d742df3d0c43",
      "patch": "@@ -468,8 +468,14 @@ public void run() {\n                                     if (data.getCommand().getName().equals(RedisCommands.EXEC.getName())) {\n                                         break;\n                                     }\n+                                    \n                                     RPromise<Object> promise = (RPromise<Object>) data.getPromise();\n-                                    promise.trySuccess(resultIter.next());\n+                                    if (resultIter.hasNext()) {\n+                                        promise.trySuccess(resultIter.next());\n+                                    } else {\n+                                        // fix for https://github.com/redisson/redisson/issues/2212\n+                                        promise.trySuccess(null);\n+                                    }\n                                 }\n                             }\n                             ",
      "parent_sha": "06d155f2c85442d9ed41f649422f2b40e536d06a"
    }
  },
  {
    "oid": "b669a99b442b3873f62674677428fbb9c1a2091b",
    "message": "compilation fixed",
    "date": "2018-09-17T06:57:50Z",
    "url": "https://github.com/redisson/redisson/commit/b669a99b442b3873f62674677428fbb9c1a2091b",
    "details": {
      "sha": "2876637bd783d578e68c40452f6506eb7c963f35",
      "filename": "redisson/src/main/java/org/redisson/client/handler/PingConnectionHandler.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/b669a99b442b3873f62674677428fbb9c1a2091b/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fhandler%2FPingConnectionHandler.java",
      "raw_url": "https://github.com/redisson/redisson/raw/b669a99b442b3873f62674677428fbb9c1a2091b/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fhandler%2FPingConnectionHandler.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fhandler%2FPingConnectionHandler.java?ref=b669a99b442b3873f62674677428fbb9c1a2091b",
      "patch": "@@ -46,7 +46,7 @@ public PingConnectionHandler(RedisClientConfig config) {\n     }\n \n     @Override\n-    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+    public void channelActive(final ChannelHandlerContext ctx) throws Exception {\n         RedisConnection connection = RedisConnection.getFrom(ctx.channel());\n         connection.getConnectionPromise().addListener(new FutureListener<RedisConnection>() {\n             @Override",
      "parent_sha": "25d29acb1f7c74253edad7f8fb88d7eb7ead0907"
    }
  },
  {
    "oid": "f2ab62ed51d7d14cac27a6d09dfd3b8817c58b03",
    "message": "test fixed",
    "date": "2024-04-17T10:50:07Z",
    "url": "https://github.com/redisson/redisson/commit/f2ab62ed51d7d14cac27a6d09dfd3b8817c58b03",
    "details": {
      "sha": "e51d1e8be1f7604aedf72d11a7cc6b75edf7547e",
      "filename": "redisson/src/test/java/org/redisson/RedissonRemoteServiceTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/f2ab62ed51d7d14cac27a6d09dfd3b8817c58b03/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonRemoteServiceTest.java",
      "raw_url": "https://github.com/redisson/redisson/raw/f2ab62ed51d7d14cac27a6d09dfd3b8817c58b03/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonRemoteServiceTest.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonRemoteServiceTest.java?ref=f2ab62ed51d7d14cac27a6d09dfd3b8817c58b03",
      "patch": "@@ -341,7 +341,7 @@ public void testFreeWorkers() throws InterruptedException, ExecutionException {\n         RemoteInterfaceAsync ri = r2.getRemoteService().get(RemoteInterfaceAsync.class);\n         \n         RFuture<Void> f = ri.timeoutMethod();\n-        Thread.sleep(100);\n+        Thread.sleep(200);\n         assertThat(rs.getFreeWorkers(RemoteInterface.class)).isEqualTo(0);\n         f.get();\n         assertThat(rs.getFreeWorkers(RemoteInterface.class)).isEqualTo(1);",
      "parent_sha": "71c272ed2adb88da825e147a7908de3ffc036085"
    }
  },
  {
    "oid": "d13a3ae318f9385b3fa956fdfdf7ce8aff2e6266",
    "message": "refactoring",
    "date": "2024-02-13T07:42:21Z",
    "url": "https://github.com/redisson/redisson/commit/d13a3ae318f9385b3fa956fdfdf7ce8aff2e6266",
    "details": {
      "sha": "21a1267ccf57a93899ffc80574d36b3a52b6c185",
      "filename": "redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java",
      "status": "modified",
      "additions": 5,
      "deletions": 4,
      "changes": 9,
      "blob_url": "https://github.com/redisson/redisson/blob/d13a3ae318f9385b3fa956fdfdf7ce8aff2e6266/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcluster%2FClusterConnectionManager.java",
      "raw_url": "https://github.com/redisson/redisson/raw/d13a3ae318f9385b3fa956fdfdf7ce8aff2e6266/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcluster%2FClusterConnectionManager.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcluster%2FClusterConnectionManager.java?ref=d13a3ae318f9385b3fa956fdfdf7ce8aff2e6266",
      "patch": "@@ -67,12 +67,11 @@ public class ClusterConnectionManager extends MasterSlaveConnectionManager {\n \n     private ClusterServersConfig cfg;\n \n-    private final long seed;\n+    private final long seed = ThreadLocalRandom.current().nextLong();\n \n     public ClusterConnectionManager(ClusterServersConfig cfg, ServiceManager serviceManager) {\n         super(cfg, serviceManager);\n         this.serviceManager.setNatMapper(cfg.getNatMapper());\n-        this.seed = ThreadLocalRandom.current().nextLong();\n     }\n \n     @Override\n@@ -343,9 +342,11 @@ private CompletionStage<Void> addMasterEntry(ClusterPartition partition, Cluster\n                     CompletableFuture<Void> fs = entry.initSlaveBalancer(partition.getFailedSlaveAddresses(), r -> configEndpointHostName);\n                     return fs.thenAccept(r -> {\n                         if (!partition.getSlaveAddresses().isEmpty()) {\n-                            log.info(\"slaves: {} added for slot ranges: {}\", partition.getSlaveAddresses(), partition.getSlotRanges());\n+                            log.info(\"slaves: {} added for master: {} slot ranges: {}\",\n+                                    partition.getSlaveAddresses(), partition.getMasterAddress(), partition.getSlotRanges());\n                             if (!partition.getFailedSlaveAddresses().isEmpty()) {\n-                                log.warn(\"slaves: {} are down for slot ranges: {}\", partition.getFailedSlaveAddresses(), partition.getSlotRanges());\n+                                log.warn(\"slaves: {} down for master: {} slot ranges: {}\",\n+                                        partition.getFailedSlaveAddresses(), partition.getMasterAddress(), partition.getSlotRanges());\n                             }\n                         }\n ",
      "parent_sha": "ac1a7516ae82957a56c729c8112062849f2c38b2"
    }
  },
  {
    "oid": "d7d94fa36cacb1f417d6d4eb161fe2f770fdaf9b",
    "message": "SELECT command shouldn't be executed on Sentinel servers #924",
    "date": "2017-06-16T11:34:44Z",
    "url": "https://github.com/redisson/redisson/commit/d7d94fa36cacb1f417d6d4eb161fe2f770fdaf9b",
    "details": {
      "sha": "145c56a1fbc83c8ce3dee495e6e34b2b1e3e2241",
      "filename": "redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/d7d94fa36cacb1f417d6d4eb161fe2f770fdaf9b/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2FMasterSlaveConnectionManager.java",
      "raw_url": "https://github.com/redisson/redisson/raw/d7d94fa36cacb1f417d6d4eb161fe2f770fdaf9b/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2FMasterSlaveConnectionManager.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2FMasterSlaveConnectionManager.java?ref=d7d94fa36cacb1f417d6d4eb161fe2f770fdaf9b",
      "patch": "@@ -374,11 +374,11 @@ protected RedisClientConfig createRedisConfig(NodeType type, URI address, int ti\n               .setSslTruststorePassword(config.getSslTruststorePassword())\n               .setSslKeystore(config.getSslKeystore())\n               .setSslKeystorePassword(config.getSslKeystorePassword())\n-              .setDatabase(config.getDatabase())\n               .setClientName(config.getClientName())\n               .setKeepPubSubOrder(cfg.isKeepPubSubOrder());\n         \n         if (type != NodeType.SENTINEL) {\n+            redisConfig.setDatabase(config.getDatabase());\n             redisConfig.setPassword(config.getPassword());\n         }\n         ",
      "parent_sha": "3a5fdaa66ffaffbac7f203851e445239572ff82f"
    }
  },
  {
    "oid": "b4bdef9e21ea76d3e77af430f87c5fbe263fd1a3",
    "message": "refactoring",
    "date": "2024-09-17T08:27:36Z",
    "url": "https://github.com/redisson/redisson/commit/b4bdef9e21ea76d3e77af430f87c5fbe263fd1a3",
    "details": {
      "sha": "98224d2c45529e96b7f4993ae6b4888cd48456fb",
      "filename": "redisson/src/main/java/org/redisson/remote/BaseRemoteService.java",
      "status": "modified",
      "additions": 5,
      "deletions": 11,
      "changes": 16,
      "blob_url": "https://github.com/redisson/redisson/blob/b4bdef9e21ea76d3e77af430f87c5fbe263fd1a3/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fremote%2FBaseRemoteService.java",
      "raw_url": "https://github.com/redisson/redisson/raw/b4bdef9e21ea76d3e77af430f87c5fbe263fd1a3/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fremote%2FBaseRemoteService.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fremote%2FBaseRemoteService.java?ref=b4bdef9e21ea76d3e77af430f87c5fbe263fd1a3",
      "patch": "@@ -186,21 +186,15 @@ protected abstract CompletableFuture<Boolean> addAsync(String requestQueueName,\n     protected abstract CompletableFuture<Boolean> removeAsync(String requestQueueName, String taskId);\n \n     protected long[] getMethodSignature(Method method) {\n-        long[] result = methodSignaturesCache.get(method);\n-        if (result == null) {\n-            String str = Arrays.stream(method.getParameterTypes())\n+        return methodSignaturesCache.computeIfAbsent(method, m -> {\n+            String str = Arrays.stream(m.getParameterTypes())\n                                 .map(c -> c.getName())\n                                 .collect(Collectors.joining());\n             ByteBuf buf = Unpooled.copiedBuffer(str, CharsetUtil.UTF_8);\n-            result = Hash.hash128(buf);\n+            long[] result = Hash.hash128(buf);\n             buf.release();\n-            long[] oldResult = methodSignaturesCache.putIfAbsent(method, result);\n-            if (oldResult != null) {\n-                return oldResult;\n-            }\n-        }\n-        \n-        return result;\n+            return result;\n+        });\n     }\n \n     protected <V> RBlockingQueue<V> getBlockingQueue(String name, Codec codec) {",
      "parent_sha": "a7dba3ba1201b081e5c5ef176fc15692fb5fb060"
    }
  },
  {
    "oid": "af9208c3c9951b7743585b25a7f6a3fcd69c6fe8",
    "message": "Improvement - RedissonReliableTopic internal structure optimization #5027",
    "date": "2023-05-10T09:54:47Z",
    "url": "https://github.com/redisson/redisson/commit/af9208c3c9951b7743585b25a7f6a3fcd69c6fe8",
    "details": {
      "sha": "ecf250aa9f924c3c74fa7d5b61c0b168c27b3a75",
      "filename": "redisson/src/main/java/org/redisson/RedissonReliableTopic.java",
      "status": "modified",
      "additions": 43,
      "deletions": 60,
      "changes": 103,
      "blob_url": "https://github.com/redisson/redisson/blob/af9208c3c9951b7743585b25a7f6a3fcd69c6fe8/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonReliableTopic.java",
      "raw_url": "https://github.com/redisson/redisson/raw/af9208c3c9951b7743585b25a7f6a3fcd69c6fe8/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonReliableTopic.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonReliableTopic.java?ref=af9208c3c9951b7743585b25a7f6a3fcd69c6fe8",
      "patch": "@@ -77,18 +77,6 @@ public RedissonReliableTopic(CommandAsyncExecutor commandExecutor, String name)\n         super(commandExecutor, name);\n     }\n \n-    private String getSubscribersName() {\n-        return suffixName(getRawName(), \"subscribers\");\n-    }\n-\n-    private String getMapName() {\n-        return suffixName(getRawName(), \"map\");\n-    }\n-\n-    private String getCounter() {\n-        return suffixName(getRawName(), \"counter\");\n-    }\n-\n     private String getTimeout() {\n         return suffixName(getRawName(), \"timeout\");\n     }\n@@ -136,8 +124,10 @@ public int countListeners() {\n     public RFuture<Long> publishAsync(Object message) {\n         return commandExecutor.evalWriteAsync(getRawName(), StringCodec.INSTANCE, RedisCommands.EVAL_LONG,\n                 \"redis.call('xadd', KEYS[1], '*', 'm', ARGV[1]); \"\n-                        + \"return redis.call('zcard', KEYS[2]); \",\n-                Arrays.asList(getRawName(), getSubscribersName()), encode(message));\n+                    + \"local v = redis.call('xinfo', 'groups', KEYS[1]); \"\n+                    + \"return #v;\",\n+                Arrays.asList(getRawName()),\n+                encode(message));\n     }\n \n     @Override\n@@ -152,17 +142,13 @@ public <M> RFuture<String> addListenerAsync(Class<M> type, MessageListener<M> li\n         if (subscriberId.compareAndSet(null, id)) {\n             renewExpiration();\n \n-            StreamMessageId startId = StreamMessageId.ALL;\n-\n             RFuture<Void> addFuture = commandExecutor.evalWriteNoRetryAsync(getRawName(), StringCodec.INSTANCE, RedisCommands.EVAL_VOID,\n-                    \"local value = redis.call('incr', KEYS[3]); \"\n-                            + \"redis.call('zadd', KEYS[4], ARGV[3], ARGV[2]); \"\n-                            + \"redis.call('zadd', KEYS[1], value, ARGV[2]); \"\n-                            + \"redis.call('hset', KEYS[2], ARGV[2], ARGV[1]); \",\n-                    Arrays.asList(getSubscribersName(), getMapName(), getCounter(), getTimeout()),\n-                    startId, id, System.currentTimeMillis() + getServiceManager().getCfg().getReliableTopicWatchdogTimeout());\n+                              \"redis.call('zadd', KEYS[2], ARGV[3], ARGV[2]);\" +\n+                                    \"redis.call('xgroup', 'create', KEYS[1], ARGV[2], ARGV[1], 'MKSTREAM'); \",\n+                    Arrays.asList(getRawName(), getTimeout()),\n+            StreamMessageId.ALL, id, System.currentTimeMillis() + getServiceManager().getCfg().getReliableTopicWatchdogTimeout());\n             CompletionStage<String> f = addFuture.thenApply(r -> {\n-                poll(id, startId);\n+                poll(id);\n                 return id;\n             });\n \n@@ -172,9 +158,9 @@ public <M> RFuture<String> addListenerAsync(Class<M> type, MessageListener<M> li\n         return new CompletableFutureWrapper<>(id);\n     }\n \n-    private void poll(String id, StreamMessageId startId) {\n+    private void poll(String id) {\n         readFuture = commandExecutor.readAsync(getRawName(), new CompositeCodec(StringCodec.INSTANCE, codec),\n-                RedisCommands.XREAD_BLOCKING_SINGLE, \"BLOCK\", 0, \"STREAMS\", getRawName(), startId);\n+                RedisCommands.XREADGROUP_BLOCKING_SINGLE, \"GROUP\", id, \"consumer\", \"BLOCK\", 0, \"STREAMS\", getRawName(), \">\");\n         readFuture.whenComplete((res, ex) -> {\n             if (readFuture.isCancelled()) {\n                 return;\n@@ -187,11 +173,15 @@ private void poll(String id, StreamMessageId startId) {\n                 log.error(ex.getMessage(), ex);\n \n                 getServiceManager().newTimeout(task -> {\n-                    poll(id, startId);\n+                    poll(id);\n                 }, 1, TimeUnit.SECONDS);\n                 return;\n             }\n \n+            if (listeners.isEmpty()) {\n+                return;\n+            }\n+\n             getServiceManager().getExecutor().execute(() -> {\n                 res.values().forEach(entry -> {\n                     Object m = entry.get(\"m\");\n@@ -203,38 +193,30 @@ private void poll(String id, StreamMessageId startId) {\n                 });\n             });\n \n-            if (listeners.isEmpty()) {\n-                return;\n-            }\n-\n-            StreamMessageId lastId = res.keySet().stream().skip(res.size() - 1).findFirst().get();\n             long time = System.currentTimeMillis();\n             RFuture<Boolean> updateFuture = commandExecutor.evalWriteAsync(getRawName(), StringCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,\n-                        \"local r = redis.call('zscore', KEYS[2], ARGV[2]); \"\n-                            + \"if r ~= false then \"\n-                                + \"local value = redis.call('incr', KEYS[4]); \"\n-                                + \"redis.call('zadd', KEYS[2], value, ARGV[2]); \"\n-                                + \"redis.call('hset', KEYS[3], ARGV[2], ARGV[1]); \"\n-                            + \"end; \"\n-\n-                            + \"local expired = redis.call('zrangebyscore', KEYS[5], 0, tonumber(ARGV[3]) - 1); \"\n+                            \"local expired = redis.call('zrangebyscore', KEYS[2], 0, tonumber(ARGV[2]) - 1); \"\n                             + \"for i, v in ipairs(expired) do \"\n-                                + \"redis.call('hdel', KEYS[3], v); \"\n-                                + \"redis.call('zrem', KEYS[2], v); \"\n-                                + \"redis.call('zrem', KEYS[5], v); \"\n+                                + \"redis.call('xgroup', 'destroy', KEYS[1], v); \"\n                             + \"end; \"\n-\n-                            + \"local v = redis.call('zrange', KEYS[2], 0, 0); \"\n-                            + \"local score = redis.call('hget', KEYS[3], v[1]); \"\n+                            + \"local r = redis.call('zscore', KEYS[2], ARGV[1]); \"\n+\n+                            + \"local score = 92233720368547758;\"\n+                            + \"local groups = redis.call('xinfo', 'groups', KEYS[1]); \" +\n+                              \"for i, v in ipairs(groups) do \"\n+                                 + \"local id1, id2 = string.match(v[8], '(.*)%-(.*)'); \"\n+                                 + \"score = math.min(tonumber(id1), score); \"\n+                            + \"end; \" +\n+                              \"score = tostring(score) .. '-0';\"\n                             + \"local range = redis.call('xrange', KEYS[1], score, '+'); \"\n                             + \"if #range == 0 or (#range == 1 and range[1][1] == score) then \"\n                                 + \"redis.call('xtrim', KEYS[1], 'maxlen', 0); \"\n                             + \"else \"\n                                 + \"redis.call('xtrim', KEYS[1], 'maxlen', #range); \"\n                             + \"end;\"\n                             + \"return r ~= false; \",\n-                    Arrays.asList(getRawName(), getSubscribersName(), getMapName(), getCounter(), getTimeout()),\n-                    lastId, id, time);\n+                    Arrays.asList(getRawName(), getTimeout()),\n+                    id, time);\n             updateFuture.whenComplete((re, exc) -> {\n                 if (exc != null) {\n                     if (exc instanceof RedissonShutdownException) {\n@@ -248,36 +230,35 @@ private void poll(String id, StreamMessageId startId) {\n                     return;\n                 }\n \n-                poll(id, lastId);\n+                poll(id);\n             });\n \n         });\n     }\n \n     @Override\n     public RFuture<Boolean> deleteAsync() {\n-        return deleteAsync(getRawName(), getSubscribersName(), getMapName(), getCounter(), getTimeout());\n+        return deleteAsync(getRawName(), getTimeout());\n     }\n \n     @Override\n     public RFuture<Long> sizeInMemoryAsync() {\n-        return super.sizeInMemoryAsync(Arrays.asList(getRawName(), getSubscribersName(), getMapName(), getCounter(), getTimeout()));\n+        return super.sizeInMemoryAsync(Arrays.asList(getRawName(), getTimeout()));\n     }\n \n     @Override\n     public RFuture<Boolean> expireAsync(long timeToLive, TimeUnit timeUnit, String param, String... keys) {\n-        return super.expireAsync(timeToLive, timeUnit, param,\n-                                    getRawName(), getSubscribersName(), getMapName(), getCounter(), getTimeout());\n+        return super.expireAsync(timeToLive, timeUnit, param, getRawName(), getTimeout());\n     }\n \n     @Override\n     protected RFuture<Boolean> expireAtAsync(long timestamp, String param, String... keys) {\n-        return super.expireAtAsync(timestamp, param, getRawName(), getSubscribersName(), getMapName(), getCounter(), getTimeout());\n+        return super.expireAtAsync(timestamp, param, getRawName(), getTimeout());\n     }\n \n     @Override\n     public RFuture<Boolean> clearExpireAsync() {\n-        return clearExpireAsync(getRawName(), getSubscribersName(), getMapName(), getCounter(), getTimeout());\n+        return clearExpireAsync(getRawName(), getTimeout());\n     }\n \n     @Override\n@@ -296,10 +277,9 @@ private RFuture<Void> removeSubscriber() {\n \n         String id = subscriberId.getAndSet(null);\n         return commandExecutor.evalWriteAsync(getRawName(), StringCodec.INSTANCE, RedisCommands.EVAL_VOID,\n-                \"redis.call('zrem', KEYS[3], ARGV[1]); \"\n-                      + \"redis.call('zrem', KEYS[1], ARGV[1]); \"\n-                      + \"redis.call('hdel', KEYS[2], ARGV[1]); \",\n-                Arrays.asList(getSubscribersName(), getMapName(), getTimeout()),\n+                \"redis.call('xgroup', 'destroy', KEYS[1], ARGV[1]); \"\n+                      + \"redis.call('zrem', KEYS[2], ARGV[1]); \",\n+                Arrays.asList(getRawName(), getTimeout()),\n                 id);\n     }\n \n@@ -310,13 +290,16 @@ public int countSubscribers() {\n \n     @Override\n     public RFuture<Integer> countSubscribersAsync() {\n-        return commandExecutor.readAsync(getRawName(), StringCodec.INSTANCE, RedisCommands.ZCARD_INT, getSubscribersName());\n+        return commandExecutor.evalReadAsync(getRawName(), StringCodec.INSTANCE, RedisCommands.EVAL_INTEGER,\n+                        \"local v = redis.call('xinfo', 'groups', KEYS[1]); \" +\n+                              \"return #v;\",\n+                Arrays.asList(getRawName()));\n     }\n \n     private void renewExpiration() {\n         timeoutTask = getServiceManager().newTimeout(t -> {\n             RFuture<Boolean> future = commandExecutor.evalWriteAsync(getRawName(), StringCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,\n-                   \"if redis.call('zscore', KEYS[1], ARGV[2]) == false then \"\n+                  \"if redis.call('zscore', KEYS[1], ARGV[2]) == false then \"\n                          + \"return 0; \"\n                       + \"end; \"\n                       + \"redis.call('zadd', KEYS[1], ARGV[1], ARGV[2]); \"",
      "parent_sha": "3b839f83504e83467c612fe67a492c9d4ef78987"
    }
  },
  {
    "oid": "9d1ac28cf898fd43e855117faaf5e32ffaa74aed",
    "message": "Fixed - XREADGROUP and XCLAIM commands should be executed on Redis master. #2663",
    "date": "2020-03-30T06:28:24Z",
    "url": "https://github.com/redisson/redisson/commit/9d1ac28cf898fd43e855117faaf5e32ffaa74aed",
    "details": {
      "sha": "b0febdc0b98944411460ea8ab6592408008e83d1",
      "filename": "redisson/src/main/java/org/redisson/RedissonStream.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/redisson/redisson/blob/9d1ac28cf898fd43e855117faaf5e32ffaa74aed/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonStream.java",
      "raw_url": "https://github.com/redisson/redisson/raw/9d1ac28cf898fd43e855117faaf5e32ffaa74aed/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonStream.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonStream.java?ref=9d1ac28cf898fd43e855117faaf5e32ffaa74aed",
      "patch": "@@ -168,7 +168,7 @@ public RFuture<List<StreamMessageId>> fastClaimAsync(String groupName, String co\n         \n         params.add(\"JUSTID\");\n         \n-        return commandExecutor.readAsync(getName(), StringCodec.INSTANCE, RedisCommands.XCLAIM_IDS, params.toArray());\n+        return commandExecutor.writeAsync(getName(), StringCodec.INSTANCE, RedisCommands.XCLAIM_IDS, params.toArray());\n     }\n     \n     @Override\n@@ -184,7 +184,7 @@ public RFuture<Map<StreamMessageId, Map<K, V>>> claimAsync(String groupName, Str\n             params.add(id.toString());\n         }\n         \n-        return commandExecutor.readAsync(getName(), codec, RedisCommands.XCLAIM, params.toArray());\n+        return commandExecutor.writeAsync(getName(), codec, RedisCommands.XCLAIM, params.toArray());\n     }\n \n     @Override\n@@ -417,9 +417,9 @@ public RFuture<Map<String, Map<StreamMessageId, Map<K, V>>>> readGroupAsync(Stri\n         }\n \n         if (timeout > 0) {\n-            return commandExecutor.readAsync(getName(), codec, RedisCommands.XREADGROUP_BLOCKING, params.toArray());\n+            return commandExecutor.writeAsync(getName(), codec, RedisCommands.XREADGROUP_BLOCKING, params.toArray());\n         }\n-        return commandExecutor.readAsync(getName(), codec, RedisCommands.XREADGROUP, params.toArray());\n+        return commandExecutor.writeAsync(getName(), codec, RedisCommands.XREADGROUP, params.toArray());\n     }\n \n ",
      "parent_sha": "6cd9b28d9cf17a5d951b28b096634f2d7171fa3b"
    }
  },
  {
    "oid": "01305ecdd27e108d4a59efae85b81999583b721f",
    "message": "Fixed - channel write exception may lead to wrong commands order #4262",
    "date": "2022-06-14T06:40:24Z",
    "url": "https://github.com/redisson/redisson/commit/01305ecdd27e108d4a59efae85b81999583b721f",
    "details": {
      "sha": "549b0a6221cfca4a816e7041e8ff8529ed4b8a80",
      "filename": "redisson/src/main/java/org/redisson/client/handler/CommandsQueue.java",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/redisson/redisson/blob/01305ecdd27e108d4a59efae85b81999583b721f/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fhandler%2FCommandsQueue.java",
      "raw_url": "https://github.com/redisson/redisson/raw/01305ecdd27e108d4a59efae85b81999583b721f/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fhandler%2FCommandsQueue.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fhandler%2FCommandsQueue.java?ref=01305ecdd27e108d4a59efae85b81999583b721f",
      "patch": "@@ -79,7 +79,12 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n                 if (lock.compareAndSet(false, true)) {\n                     try {\n                         queue.add(holder);\n-                        ctx.writeAndFlush(data, holder.getChannelPromise());\n+                        try {\n+                            ctx.writeAndFlush(data, holder.getChannelPromise());\n+                        } catch (Exception e) {\n+                            queue.remove(holder);\n+                            throw e;\n+                        }\n                     } finally {\n                         lock.set(false);\n                     }",
      "parent_sha": "2d3eaba83b3ec8340ecf99ccad048bb550430d1d"
    }
  },
  {
    "oid": "da21348ff2d7769ca8404533f66b55860fb9f9c8",
    "message": "Compilation fixed",
    "date": "2016-07-14T17:52:54Z",
    "url": "https://github.com/redisson/redisson/commit/da21348ff2d7769ca8404533f66b55860fb9f9c8",
    "details": {
      "sha": "0d83bb236525c75a096cffb560f1b90b21c6d0aa",
      "filename": "src/main/java/org/redisson/connection/balancer/LoadBalancerManagerImpl.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/da21348ff2d7769ca8404533f66b55860fb9f9c8/src%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2Fbalancer%2FLoadBalancerManagerImpl.java",
      "raw_url": "https://github.com/redisson/redisson/raw/da21348ff2d7769ca8404533f66b55860fb9f9c8/src%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2Fbalancer%2FLoadBalancerManagerImpl.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/src%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2Fbalancer%2FLoadBalancerManagerImpl.java?ref=da21348ff2d7769ca8404533f66b55860fb9f9c8",
      "patch": "@@ -52,7 +52,7 @@ public LoadBalancerManagerImpl(MasterSlaveServersConfig config, ConnectionManage\n         pubSubConnectionPool = new PubSubConnectionPool(config, connectionManager, entry);\n     }\n \n-    public Future<Void> add(ClientConnectionsEntry entry) {\n+    public Future<Void> add(final ClientConnectionsEntry entry) {\n         final Promise<Void> result = connectionManager.newPromise();\n         FutureListener<Void> listener = new FutureListener<Void>() {\n             AtomicInteger counter = new AtomicInteger(2);",
      "parent_sha": "b3fed96b253d42f0fe735900622fda173831cf76"
    }
  },
  {
    "oid": "23c3a4e0ea2a19bacb28cd61c80b6363819c75db",
    "message": "Redis version updated",
    "date": "2018-11-14T12:45:07Z",
    "url": "https://github.com/redisson/redisson/commit/23c3a4e0ea2a19bacb28cd61c80b6363819c75db",
    "details": {
      "sha": "ac43085df102bab2ceda46d15e057b9a33e2ca68",
      "filename": "redisson/src/test/java/org/redisson/RedissonRuntimeEnvironment.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/23c3a4e0ea2a19bacb28cd61c80b6363819c75db/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonRuntimeEnvironment.java",
      "raw_url": "https://github.com/redisson/redisson/raw/23c3a4e0ea2a19bacb28cd61c80b6363819c75db/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonRuntimeEnvironment.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonRuntimeEnvironment.java?ref=23c3a4e0ea2a19bacb28cd61c80b6363819c75db",
      "patch": "@@ -9,7 +9,7 @@\n public class RedissonRuntimeEnvironment {\n \n     public static final boolean isTravis = \"true\".equalsIgnoreCase(System.getProperty(\"travisEnv\"));\n-    public static final String redisBinaryPath = System.getProperty(\"redisBinary\", \"C:\\\\Devel\\\\projects\\\\redis\\\\Redis-x64-3.2.100\\\\redis-server.exe\");\n+    public static final String redisBinaryPath = System.getProperty(\"redisBinary\", \"C:\\\\Devel\\\\projects\\\\redis\\\\redis-x64-4.0.2.2\\\\redis-server.exe\");\n     public static final String tempDir = System.getProperty(\"java.io.tmpdir\");\n     public static final String OS;\n     public static final boolean isWindows;",
      "parent_sha": "897c4f2b9faaa681f474b392f46619cc78cf6711"
    }
  },
  {
    "oid": "ec41ed0982b0ee699a558f5cc4b043db08277e9e",
    "message": "test fixed",
    "date": "2016-10-04T14:58:41Z",
    "url": "https://github.com/redisson/redisson/commit/ec41ed0982b0ee699a558f5cc4b043db08277e9e",
    "details": {
      "sha": "f4732b65651e6c8c929299f9ef318e86eb179aa3",
      "filename": "redisson/src/test/java/org/redisson/RedissonSetCacheTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/redisson/redisson/blob/ec41ed0982b0ee699a558f5cc4b043db08277e9e/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonSetCacheTest.java",
      "raw_url": "https://github.com/redisson/redisson/raw/ec41ed0982b0ee699a558f5cc4b043db08277e9e/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonSetCacheTest.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonSetCacheTest.java?ref=ec41ed0982b0ee699a558f5cc4b043db08277e9e",
      "patch": "@@ -151,9 +151,9 @@ public void testExpireOverwrite() throws InterruptedException, ExecutionExceptio\n         Thread.sleep(100);\n         assertThat(set.contains(\"123\")).isTrue();\n \n-        Thread.sleep(100);\n+        Thread.sleep(300);\n \n-        assertThat(set.contains(\"123\")).isFalse();\n+        assertThat(set.contains(\"123\")).isTrue();\n     }\n \n     @Test",
      "parent_sha": "e663767d0f3fabe65d13629317bb240eaa486e97"
    }
  },
  {
    "oid": "910ab5fdb7b50a9516242c324f2e3d881a41f486",
    "message": "Fixed - RMapCache.destroy throws NPE. #4230",
    "date": "2022-04-15T06:20:48Z",
    "url": "https://github.com/redisson/redisson/commit/910ab5fdb7b50a9516242c324f2e3d881a41f486",
    "details": {
      "sha": "340fd286f029069ec8c14b29e0f88b770dbdeffc",
      "filename": "redisson/src/main/java/org/redisson/eviction/EvictionScheduler.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/910ab5fdb7b50a9516242c324f2e3d881a41f486/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Feviction%2FEvictionScheduler.java",
      "raw_url": "https://github.com/redisson/redisson/raw/910ab5fdb7b50a9516242c324f2e3d881a41f486/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Feviction%2FEvictionScheduler.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Feviction%2FEvictionScheduler.java?ref=910ab5fdb7b50a9516242c324f2e3d881a41f486",
      "patch": "@@ -80,7 +80,7 @@ public void schedule(String name, String timeoutSetName, String maxIdleSetName,\n \n     public void remove(String name) {\n         EvictionTask task = tasks.remove(name);\n-        if (task != null) {\n+        if (task != null && task.getScheduledFuture() != null) {\n             task.getScheduledFuture().cancel(false);\n         }\n     }",
      "parent_sha": "59ff8e2245eeb4632560111f0c9dd56bc0425c01"
    }
  },
  {
    "oid": "ccccd4bd5e84a78cdfb94b17ecd536f0e37262b8",
    "message": "String.replaceFirsts compiles regex pattern on each call, it can be avoided just by getting index of `://`\n\nSigned-off-by: Sergey Kuznetsov <iksss.88@gmail.com>\nSigned-off-by: Sergey Kuznetsov <sergey.kuznetsov@infobip.com>",
    "date": "2023-08-02T19:22:15Z",
    "url": "https://github.com/redisson/redisson/commit/ccccd4bd5e84a78cdfb94b17ecd536f0e37262b8",
    "details": {
      "sha": "c00de85156944a2eaa12056a6918173472eb03c1",
      "filename": "redisson/src/main/java/org/redisson/misc/RedisURI.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/redisson/redisson/blob/ccccd4bd5e84a78cdfb94b17ecd536f0e37262b8/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fmisc%2FRedisURI.java",
      "raw_url": "https://github.com/redisson/redisson/raw/ccccd4bd5e84a78cdfb94b17ecd536f0e37262b8/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fmisc%2FRedisURI.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fmisc%2FRedisURI.java?ref=ccccd4bd5e84a78cdfb94b17ecd536f0e37262b8",
      "patch": "@@ -42,8 +42,7 @@ public RedisURI(String scheme, String host, int port) {\n     }\n \n     public RedisURI(String uri) {\n-        if (!uri.startsWith(\"redis://\")\n-                && !uri.startsWith(\"rediss://\")) {\n+        if (!uri.startsWith(\"redis://\") && !uri.startsWith(\"rediss://\")) {\n             throw new IllegalArgumentException(\"Redis url should start with redis:// or rediss:// (for SSL connection)\");\n         }\n \n@@ -73,8 +72,9 @@ public RedisURI(String uri) {\n     }\n \n     private String parseUrl(String uri) {\n-        String urlHost = uri.replaceFirst(\"redis://\", \"http://\").replaceFirst(\"rediss://\", \"http://\");\n-        String ipV6Host = uri.substring(uri.indexOf(\"://\")+3, uri.lastIndexOf(\":\"));\n+        int hostStartIndex = uri.indexOf(\"://\") + 3;\n+        String urlHost = \"http://\" + uri.substring(hostStartIndex);\n+        String ipV6Host = uri.substring(hostStartIndex, uri.lastIndexOf(\":\"));\n         if (ipV6Host.contains(\"@\")) {\n             ipV6Host = ipV6Host.split(\"@\")[1];\n         }",
      "parent_sha": "8809f4b85dc797716ba7f40ff1ee10039ffe8c59"
    }
  },
  {
    "oid": "7eb4c4fb4911cbc52a2c665f3c7b3eac0800941e",
    "message": "checkstyle error fixed",
    "date": "2020-09-23T17:31:14Z",
    "url": "https://github.com/redisson/redisson/commit/7eb4c4fb4911cbc52a2c665f3c7b3eac0800941e",
    "details": {
      "sha": "0c73b16e680927f96d09089b4797aca4c4cadcaa",
      "filename": "redisson/src/main/java/org/redisson/RedissonTopic.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/redisson/redisson/blob/7eb4c4fb4911cbc52a2c665f3c7b3eac0800941e/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonTopic.java",
      "raw_url": "https://github.com/redisson/redisson/raw/7eb4c4fb4911cbc52a2c665f3c7b3eac0800941e/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonTopic.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonTopic.java?ref=7eb4c4fb4911cbc52a2c665f3c7b3eac0800941e",
      "patch": "@@ -97,7 +97,7 @@ public int addListener(StatusListener listener) {\n \n     @Override\n     public <M> int addListener(Class<M> type, MessageListener<? extends M> listener) {\n-        RFuture<Integer> future = addListenerAsync(type, (MessageListener<M>)listener);\n+        RFuture<Integer> future = addListenerAsync(type, (MessageListener<M>) listener);\n         commandExecutor.syncSubscription(future);\n         return future.getNow();\n     }\n@@ -119,7 +119,7 @@ protected RFuture<Integer> addListenerAsync(RedisPubSubListener<?> pubSubListene\n         RPromise<Integer> result = new RedissonPromise<>();\n         result.onComplete((res, e) -> {\n             if (e != null) {\n-                ((RPromise<PubSubConnectionEntry>)future).tryFailure(e);\n+                ((RPromise<PubSubConnectionEntry>) future).tryFailure(e);\n             }\n         });\n         future.onComplete((res, e) -> {",
      "parent_sha": "c41f59b1077a423b46f946958231416658c729c4"
    }
  },
  {
    "oid": "760972b1c446085a861eaf9e84f87e1a3dd067cb",
    "message": "old methods deprecated",
    "date": "2023-05-11T05:56:28Z",
    "url": "https://github.com/redisson/redisson/commit/760972b1c446085a861eaf9e84f87e1a3dd067cb",
    "details": {
      "sha": "87bb323bd98c6ecf6c6b2baefab610a59c800260",
      "filename": "redisson/src/main/java/org/redisson/api/RStreamAsync.java",
      "status": "modified",
      "additions": 37,
      "deletions": 29,
      "changes": 66,
      "blob_url": "https://github.com/redisson/redisson/blob/760972b1c446085a861eaf9e84f87e1a3dd067cb/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fapi%2FRStreamAsync.java",
      "raw_url": "https://github.com/redisson/redisson/raw/760972b1c446085a861eaf9e84f87e1a3dd067cb/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fapi%2FRStreamAsync.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fapi%2FRStreamAsync.java?ref=760972b1c446085a861eaf9e84f87e1a3dd067cb",
      "patch": "@@ -331,43 +331,44 @@ public interface RStreamAsync<K, V> extends RExpirableAsync {\n     RFuture<Map<StreamMessageId, Map<K, V>>> readGroupAsync(String groupName, String consumerName, StreamReadGroupArgs args);\n \n     /**\n-     * Read stream data from <code>groupName</code> by <code>consumerName</code> and specified collection of Stream IDs.\n+     * * Use readGroup(String, String, StreamReadGroupArgs) method instead\n      * \n      * @param groupName - name of group\n      * @param consumerName - name of consumer\n      * @param ids - collection of Stream IDs\n      * @return stream data mapped by Stream ID\n      */\n+    @Deprecated\n     RFuture<Map<StreamMessageId, Map<K, V>>> readGroupAsync(String groupName, String consumerName, StreamMessageId... ids);\n     \n     /**\n-     * Read stream data from <code>groupName</code> by <code>consumerName</code> and specified collection of Stream IDs.\n+     * Use readGroup(String, String, StreamReadGroupArgs) method instead\n      * \n      * @param groupName - name of group\n      * @param consumerName - name of consumer\n      * @param count - stream data size limit\n      * @param ids - collection of Stream IDs\n      * @return stream data mapped by Stream ID\n      */\n+    @Deprecated\n     RFuture<Map<StreamMessageId, Map<K, V>>> readGroupAsync(String groupName, String consumerName, int count, StreamMessageId... ids);\n \n     /**\n-     * Read stream data from <code>groupName</code> by <code>consumerName</code> and specified collection of Stream IDs. \n-     * Wait for stream data availability for specified <code>timeout</code> interval.\n-     * \n+     * Use readGroup(String, String, StreamReadGroupArgs) method instead\n+     *\n      * @param groupName - name of group\n      * @param consumerName - name of consumer\n      * @param timeout - time interval to wait for stream data availability\n      * @param unit - time interval unit\n      * @param ids - collection of Stream IDs\n      * @return stream data mapped by Stream ID\n      */\n+    @Deprecated\n     RFuture<Map<StreamMessageId, Map<K, V>>> readGroupAsync(String groupName, String consumerName, long timeout, TimeUnit unit, StreamMessageId... ids);\n     \n     /**\n-     * Read stream data from <code>groupName</code> by <code>consumerName</code> and specified collection of Stream IDs. \n-     * Wait for stream data availability for specified <code>timeout</code> interval.\n-     * \n+     * Use readGroup(String, String, StreamReadGroupArgs) method instead\n+     *\n      * @param groupName - name of group\n      * @param consumerName - name of consumer\n      * @param count - stream data size limit\n@@ -376,21 +377,23 @@ public interface RStreamAsync<K, V> extends RExpirableAsync {\n      * @param ids - collection of Stream IDs\n      * @return stream data mapped by Stream ID\n      */\n+    @Deprecated\n     RFuture<Map<StreamMessageId, Map<K, V>>> readGroupAsync(String groupName, String consumerName, int count, long timeout, TimeUnit unit, StreamMessageId... ids);\n \n     /**\n-     * Read stream data from <code>groupName</code> by <code>consumerName</code>, starting by specified message ids for this and other streams.\n+     * Use readGroup(String, String, StreamMultiReadGroupArgs) method instead\n      * \n      * @param groupName - name of group\n      * @param consumerName - name of consumer\n      * @param id - starting message id for this stream\n      * @param nameToId - Stream Message ID mapped by stream name\n      * @return stream data mapped by key and Stream Message ID\n      */\n+    @Deprecated\n     RFuture<Map<String, Map<StreamMessageId, Map<K, V>>>> readGroupAsync(String groupName, String consumerName, StreamMessageId id, Map<String, StreamMessageId> nameToId);\n     \n     /**\n-     * Read stream data from <code>groupName</code> by <code>consumerName</code>, starting by specified message ids for this and other streams.\n+     * Use readGroup(String, String, StreamMultiReadGroupArgs) method instead\n      * \n      * @param groupName - name of group\n      * @param consumerName - name of consumer\n@@ -399,12 +402,12 @@ public interface RStreamAsync<K, V> extends RExpirableAsync {\n      * @param nameToId - Stream Message ID mapped by stream name\n      * @return stream data mapped by key and Stream Message ID\n      */\n+    @Deprecated\n     RFuture<Map<String, Map<StreamMessageId, Map<K, V>>>> readGroupAsync(String groupName, String consumerName, int count, StreamMessageId id, Map<String, StreamMessageId> nameToId);\n \n     /**\n-     * Read stream data from <code>groupName</code> by <code>consumerName</code>, starting by specified message ids for this and other streams.\n-     * Waits for the first stream data availability for specified <code>timeout</code> interval.\n-     * \n+     * Use readGroup(String, String, StreamMultiReadGroupArgs) method instead\n+     *\n      * @param groupName - name of group\n      * @param consumerName - name of consumer\n      * @param count - stream data size limit\n@@ -415,12 +418,12 @@ public interface RStreamAsync<K, V> extends RExpirableAsync {\n      * @param id2 - starting message id for second stream\n      * @return stream data mapped by key and Stream Message ID\n      */\n+    @Deprecated\n     RFuture<Map<String, Map<StreamMessageId, Map<K, V>>>> readGroupAsync(String groupName, String consumerName, int count, long timeout, TimeUnit unit, StreamMessageId id, String key2, StreamMessageId id2);\n \n     /**\n-     * Read stream data from <code>groupName</code> by <code>consumerName</code>, starting by specified message ids for this and other streams.\n-     * Waits for the first stream data availability for specified <code>timeout</code> interval.\n-     * \n+     * Use readGroup(String, String, StreamMultiReadGroupArgs) method instead\n+     *\n      * @param groupName - name of group\n      * @param consumerName - name of consumer\n      * @param count - stream data size limit\n@@ -433,13 +436,13 @@ public interface RStreamAsync<K, V> extends RExpirableAsync {\n      * @param id3 - starting message id for third stream\n      * @return stream data mapped by key and Stream Message ID\n      */\n+    @Deprecated\n     RFuture<Map<String, Map<StreamMessageId, Map<K, V>>>> readGroupAsync(String groupName, String consumerName, int count, long timeout, TimeUnit unit, StreamMessageId id,\n             String key2, StreamMessageId id2, String key3, StreamMessageId id3);\n     \n     /**\n-     * Read stream data from <code>groupName</code> by <code>consumerName</code>, starting by specified message ids for this and other streams.\n-     * Waits for the first stream data availability for specified <code>timeout</code> interval.\n-     * \n+     * Use readGroup(String, String, StreamMultiReadGroupArgs) method instead\n+     *\n      * @param groupName - name of group\n      * @param consumerName - name of consumer\n      * @param timeout - time interval to wait for stream data availability\n@@ -448,10 +451,11 @@ RFuture<Map<String, Map<StreamMessageId, Map<K, V>>>> readGroupAsync(String grou\n      * @param nameToId - Stream Message ID mapped by stream name\n      * @return stream data mapped by key and Stream Message ID\n      */\n+    @Deprecated\n     RFuture<Map<String, Map<StreamMessageId, Map<K, V>>>> readGroupAsync(String groupName, String consumerName, long timeout, TimeUnit unit, StreamMessageId id, Map<String, StreamMessageId> nameToId);\n     \n     /**\n-     * Read stream data from <code>groupName</code> by <code>consumerName</code>, starting by specified message ids for this and other streams.\n+     * Use readGroup(String, String, StreamMultiReadGroupArgs) method instead\n      * \n      * @param groupName - name of group\n      * @param consumerName - name of consumer\n@@ -460,10 +464,11 @@ RFuture<Map<String, Map<StreamMessageId, Map<K, V>>>> readGroupAsync(String grou\n      * @param id2 - starting message id for second stream\n      * @return stream data mapped by key and Stream Message ID\n      */\n+    @Deprecated\n     RFuture<Map<String, Map<StreamMessageId, Map<K, V>>>> readGroupAsync(String groupName, String consumerName, StreamMessageId id, String key2, StreamMessageId id2);\n \n     /**\n-     * Read stream data from <code>groupName</code> by <code>consumerName</code>, starting by specified message ids for this and other streams.\n+     * Use readGroup(String, String, StreamMultiReadGroupArgs) method instead\n      * \n      * @param groupName - name of group\n      * @param consumerName - name of consumer\n@@ -474,11 +479,12 @@ RFuture<Map<String, Map<StreamMessageId, Map<K, V>>>> readGroupAsync(String grou\n      * @param id3  - starting message id for third stream\n      * @return stream data mapped by key and Stream Message ID\n      */\n+    @Deprecated\n     RFuture<Map<String, Map<StreamMessageId, Map<K, V>>>> readGroupAsync(String groupName, String consumerName, StreamMessageId id, String key2, StreamMessageId id2, String key3,\n             StreamMessageId id3);\n \n     /**\n-     * Read stream data from <code>groupName</code> by <code>consumerName</code>, starting by specified message ids for this and other streams.\n+     * Use readGroup(String, String, StreamMultiReadGroupArgs) method instead\n      * \n      * @param groupName - name of group\n      * @param consumerName - name of consumer\n@@ -488,10 +494,11 @@ RFuture<Map<String, Map<StreamMessageId, Map<K, V>>>> readGroupAsync(String grou\n      * @param id2  - starting message id for second stream\n      * @return stream data mapped by key and Stream Message ID\n      */\n+    @Deprecated\n     RFuture<Map<String, Map<StreamMessageId, Map<K, V>>>> readGroupAsync(String groupName, String consumerName, int count, StreamMessageId id, String key2, StreamMessageId id2);\n \n     /**\n-     * Read stream data from <code>groupName</code> by <code>consumerName</code>, starting by specified message ids for this and other streams.\n+     * Use readGroup(String, String, StreamMultiReadGroupArgs) method instead\n      * \n      * @param groupName - name of group\n      * @param consumerName - name of consumer\n@@ -503,13 +510,13 @@ RFuture<Map<String, Map<StreamMessageId, Map<K, V>>>> readGroupAsync(String grou\n      * @param id3 - starting message id for third stream\n      * @return stream data mapped by key and Stream Message ID\n      */\n+    @Deprecated\n     RFuture<Map<String, Map<StreamMessageId, Map<K, V>>>> readGroupAsync(String groupName, String consumerName, int count, StreamMessageId id, String key2, StreamMessageId id2,\n             String key3, StreamMessageId id3);\n \n     /**\n-     * Read stream data from <code>groupName</code> by <code>consumerName</code>, starting by specified message ids for this and other streams.\n-     * Waits for the first stream data availability for specified <code>timeout</code> interval.\n-     * \n+     * Use readGroup(String, String, StreamMultiReadGroupArgs) method instead\n+     *\n      * @param groupName - name of group\n      * @param consumerName - name of consumer\n      * @param timeout - time interval to wait for stream data availability\n@@ -519,13 +526,13 @@ RFuture<Map<String, Map<StreamMessageId, Map<K, V>>>> readGroupAsync(String grou\n      * @param id2 - starting message id for second stream\n      * @return stream data mapped by key and Stream Message ID\n      */\n+    @Deprecated\n     RFuture<Map<String, Map<StreamMessageId, Map<K, V>>>> readGroupAsync(String groupName, String consumerName, long timeout, TimeUnit unit, StreamMessageId id,\n             String key2, StreamMessageId id2);\n \n     /**\n-     * Read stream data from <code>groupName</code> by <code>consumerName</code>, starting by specified message ids for this and other streams.\n-     * Waits for the first stream data availability for specified <code>timeout</code> interval.\n-     * \n+     * Use readGroup(String, String, StreamMultiReadGroupArgs) method instead\n+     *\n      * @param groupName - name of group\n      * @param consumerName - name of consumer\n      * @param timeout - time interval to wait for stream data availability\n@@ -537,6 +544,7 @@ RFuture<Map<String, Map<StreamMessageId, Map<K, V>>>> readGroupAsync(String grou\n      * @param id3 - starting message id for third stream\n      * @return stream data mapped by key and Stream Message ID\n      */\n+    @Deprecated\n     RFuture<Map<String, Map<StreamMessageId, Map<K, V>>>> readGroupAsync(String groupName, String consumerName, long timeout, TimeUnit unit, StreamMessageId id,\n             String key2, StreamMessageId id2, String key3, StreamMessageId id3);\n ",
      "parent_sha": "015a2fe4c396b0aa6fbed32b33475fbd493a639b"
    }
  },
  {
    "oid": "088006169e134ebc6c9541080853f7f25d27358e",
    "message": "fix: ClientConnectionsEntry reconnect error\n\nSigned-off-by: mika <mikawudi@qq.com>",
    "date": "2021-03-08T02:12:01Z",
    "url": "https://github.com/redisson/redisson/commit/088006169e134ebc6c9541080853f7f25d27358e",
    "details": {
      "sha": "08d69e0df7a0033ba14ed8c9f26941c27068ce15",
      "filename": "redisson/src/main/java/org/redisson/connection/balancer/LoadBalancerManager.java",
      "status": "modified",
      "additions": 28,
      "deletions": 3,
      "changes": 31,
      "blob_url": "https://github.com/redisson/redisson/blob/088006169e134ebc6c9541080853f7f25d27358e/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2Fbalancer%2FLoadBalancerManager.java",
      "raw_url": "https://github.com/redisson/redisson/raw/088006169e134ebc6c9541080853f7f25d27358e/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2Fbalancer%2FLoadBalancerManager.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2Fbalancer%2FLoadBalancerManager.java?ref=088006169e134ebc6c9541080853f7f25d27358e",
      "patch": "@@ -20,6 +20,7 @@\n import java.util.Collections;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.function.BiConsumer;\n \n import org.redisson.api.NodeType;\n@@ -148,9 +149,33 @@ protected void onSuccess(Void value) {\n                         }\n                     };\n                     listener.setCounter(2);\n-                    BiConsumer<Void, Throwable> initCallBack = (r, ex) -> {\n-                        if (ex == null) {\n-                            listener.decCounter();\n+                    BiConsumer<Void, Throwable> initCallBack = new BiConsumer<Void, Throwable>() {\n+                        private AtomicBoolean initConnError = new AtomicBoolean(false);\n+                        @Override\n+                        public void accept(Void r, Throwable ex) {\n+                            synchronized (this) {\n+                                if (ex == null) {\n+                                    listener.decCounter();\n+                                } else {\n+                                    if (!initConnError.compareAndSet(false, true)) {\n+                                        return;\n+                                    }\n+                                    for (RedisConnection connection : entry.getAllConnections()) {\n+                                        if (!connection.isClosed()) {\n+                                            connection.closeAsync();\n+                                        }\n+                                    }\n+                                    entry.getAllConnections().clear();\n+\n+                                    for (RedisConnection connection : entry.getAllSubscribeConnections()) {\n+                                        if (!connection.isClosed()) {\n+                                            connection.closeAsync();\n+                                        }\n+                                    }\n+                                    entry.getAllSubscribeConnections().clear();\n+                                    entry.setInitialized(false);\n+                                }\n+                            }\n                         }\n                     };\n                     entry.resetFirstFail();",
      "parent_sha": "e521df060e1afdff415d099c0d4ed940f24e1176"
    }
  },
  {
    "oid": "6a7e3c379cdd337c206ca0662e52882319b26f41",
    "message": "refactoring",
    "date": "2023-01-26T10:14:12Z",
    "url": "https://github.com/redisson/redisson/commit/6a7e3c379cdd337c206ca0662e52882319b26f41",
    "details": {
      "sha": "d0eb74c03592e42c46b2c562373a5bec031eec62",
      "filename": "redisson/src/main/java/org/redisson/command/RedisExecutor.java",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/redisson/redisson/blob/6a7e3c379cdd337c206ca0662e52882319b26f41/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcommand%2FRedisExecutor.java",
      "raw_url": "https://github.com/redisson/redisson/raw/6a7e3c379cdd337c206ca0662e52882319b26f41/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcommand%2FRedisExecutor.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcommand%2FRedisExecutor.java?ref=6a7e3c379cdd337c206ca0662e52882319b26f41",
      "patch": "@@ -424,7 +424,6 @@ private void handleBlockingOperations(CompletableFuture<R> attemptPromise, Redis\n             // handling cases when connection has been lost\n             scheduledFuture = connectionManager.newTimeout(timeout -> {\n                 if (attemptPromise.complete(null)) {\n-                    connection.clearCurrentCommand();\n                     connection.forceFastReconnectAsync();\n                 }\n             }, popTimeout + 3000, TimeUnit.MILLISECONDS);\n@@ -632,13 +631,13 @@ protected void releaseConnection(CompletableFuture<R> attemptPromise, Completabl\n             release(connection);\n         }\n \n-        if (log.isInfoEnabled()) {\n+        if (log.isDebugEnabled()) {\n             String connectionType = \" \";\n             if (connection instanceof RedisPubSubConnection) {\n                 connectionType = \" pubsub \";\n             }\n \n-            log.info(\"connection{}released for command {} and params {} from slot {} using connection {}\",\n+            log.debug(\"connection{}released for command {} and params {} from slot {} using connection {}\",\n                     connectionType, command, LogHelper.toString(params), source, connection);\n         }\n     }",
      "parent_sha": "53a0d448ce281a3e77fd7b1d111eb50698a6175f"
    }
  },
  {
    "oid": "167678894ffcfed19b12f1b0aec9667c46988e45",
    "message": "RedissonCountDownLatch race condition fixed",
    "date": "2014-11-19T09:10:28Z",
    "url": "https://github.com/redisson/redisson/commit/167678894ffcfed19b12f1b0aec9667c46988e45",
    "details": {
      "sha": "d61ffbfa808bac6f0a367758509885047f9f56fd",
      "filename": "src/main/java/org/redisson/RedissonCountDownLatch.java",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/redisson/redisson/blob/167678894ffcfed19b12f1b0aec9667c46988e45/src%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonCountDownLatch.java",
      "raw_url": "https://github.com/redisson/redisson/raw/167678894ffcfed19b12f1b0aec9667c46988e45/src%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonCountDownLatch.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/src%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonCountDownLatch.java?ref=167678894ffcfed19b12f1b0aec9667c46988e45",
      "patch": "@@ -100,7 +100,7 @@ public void message(String channel, Integer message) {\n \n         };\n \n-        synchronized (connectionManager) {\n+        synchronized (ENTRIES) {\n             connectionManager.subscribeOnce(listener, getChannelName());\n         }\n         return newPromise;\n@@ -117,9 +117,11 @@ private void unsubscribe() {\n             if (ENTRIES.replace(getEntryName(), entry, newEntry)) {\n                 if (newEntry.isFree()\n                         && ENTRIES.remove(getEntryName(), newEntry)) {\n-                    synchronized (connectionManager) {\n-                        Future future = connectionManager.unsubscribe(getChannelName());\n-                        future.awaitUninterruptibly();\n+                    synchronized (ENTRIES) {\n+                        // maybe added during subscription\n+                        if (!ENTRIES.containsKey(getEntryName())) {\n+                            connectionManager.unsubscribe(getChannelName());\n+                        }\n                     }\n                 }\n                 return;",
      "parent_sha": "b76209b260f9d01c9f1e13bcf0640f2dc85f516f"
    }
  },
  {
    "oid": "011be4160aeb5e23510e6715c16531ccaea07db9",
    "message": "value == 0 removed in drainPermitsAsync() and trySetPermitsAsync() methods of RSemaphore object.",
    "date": "2021-09-14T07:04:12Z",
    "url": "https://github.com/redisson/redisson/commit/011be4160aeb5e23510e6715c16531ccaea07db9",
    "details": {
      "sha": "a489e68795d0fad058f76e2d4fbefe52af6b879c",
      "filename": "redisson/src/main/java/org/redisson/RedissonSemaphore.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/redisson/redisson/blob/011be4160aeb5e23510e6715c16531ccaea07db9/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonSemaphore.java",
      "raw_url": "https://github.com/redisson/redisson/raw/011be4160aeb5e23510e6715c16531ccaea07db9/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonSemaphore.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonSemaphore.java?ref=011be4160aeb5e23510e6715c16531ccaea07db9",
      "patch": "@@ -471,7 +471,7 @@ public int drainPermits() {\n     public RFuture<Integer> drainPermitsAsync() {\n         return commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_INTEGER,\n                 \"local value = redis.call('get', KEYS[1]); \" +\n-                \"if (value == false or value == 0) then \" +\n+                \"if (value == false) then \" +\n                     \"return 0; \" +\n                 \"end; \" +\n                 \"redis.call('set', KEYS[1], 0); \" +\n@@ -498,7 +498,7 @@ public boolean trySetPermits(int permits) {\n     public RFuture<Boolean> trySetPermitsAsync(int permits) {\n         RFuture<Boolean> future = commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,\n                 \"local value = redis.call('get', KEYS[1]); \" +\n-                        \"if (value == false or value == 0) then \"\n+                        \"if (value == false) then \"\n                         + \"redis.call('set', KEYS[1], ARGV[1]); \"\n                         + \"redis.call('publish', KEYS[2], ARGV[1]); \"\n                         + \"return 1;\"",
      "parent_sha": "aed1c0dfee4fab19a076b314e7468ceb151db330"
    }
  },
  {
    "oid": "7fd29a2b49b650ec5004295b27992f036f39a5f5",
    "message": "`Not all slots are covered` error should be more informative",
    "date": "2016-09-22T10:37:47Z",
    "url": "https://github.com/redisson/redisson/commit/7fd29a2b49b650ec5004295b27992f036f39a5f5",
    "details": {
      "sha": "c292a153b2b78b72b70c1684409a80437628d5f7",
      "filename": "redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java",
      "status": "modified",
      "additions": 14,
      "deletions": 3,
      "changes": 17,
      "blob_url": "https://github.com/redisson/redisson/blob/7fd29a2b49b650ec5004295b27992f036f39a5f5/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcluster%2FClusterConnectionManager.java",
      "raw_url": "https://github.com/redisson/redisson/raw/7fd29a2b49b650ec5004295b27992f036f39a5f5/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcluster%2FClusterConnectionManager.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcluster%2FClusterConnectionManager.java?ref=7fd29a2b49b650ec5004295b27992f036f39a5f5",
      "patch": "@@ -76,7 +76,8 @@ public ClusterConnectionManager(ClusterServersConfig cfg, Config config) {\n         this.config = create(cfg);\n         init(this.config);\n \n-        Exception lastException = null;\n+        Throwable lastException = null;\n+        List<String> failedMasters = new ArrayList<String>();\n         for (URI addr : cfg.getNodeAddresses()) {\n             RFuture<RedisConnection> connectionFuture = connect(cfg, addr);\n             try {\n@@ -97,6 +98,7 @@ public ClusterConnectionManager(ClusterServersConfig cfg, Config config) {\n                 List<RFuture<Collection<RFuture<Void>>>> futures = new ArrayList<RFuture<Collection<RFuture<Void>>>>();\n                 for (ClusterPartition partition : partitions) {\n                     if (partition.isMasterFail()) {\n+                        failedMasters.add(partition.getMasterAddr().toString());\n                         continue;\n                     }\n                     RFuture<Collection<RFuture<Void>>> masterFuture = addMasterEntry(partition, cfg);\n@@ -106,6 +108,7 @@ public ClusterConnectionManager(ClusterServersConfig cfg, Config config) {\n                 for (RFuture<Collection<RFuture<Void>>> masterFuture : futures) {\n                     masterFuture.awaitUninterruptibly();\n                     if (!masterFuture.isSuccess()) {\n+                        lastException = masterFuture.cause();\n                         continue;\n                     }\n                     for (RFuture<Void> future : masterFuture.getNow()) {\n@@ -124,12 +127,20 @@ public ClusterConnectionManager(ClusterServersConfig cfg, Config config) {\n \n         if (lastPartitions.isEmpty()) {\n             stopThreads();\n-            throw new RedisConnectionException(\"Can't connect to servers!\", lastException);\n+            if (failedMasters.isEmpty()) {\n+                throw new RedisConnectionException(\"Can't connect to servers!\", lastException);\n+            } else {\n+                throw new RedisConnectionException(\"Can't connect to servers! Failed masters according to cluster status: \" + failedMasters, lastException);\n+            }\n         }\n \n         if (lastPartitions.size() != MAX_SLOT) {\n             stopThreads();\n-            throw new RedisConnectionException(\"Not all slots are covered! Only \" + lastPartitions.size() + \" slots are avaliable\", lastException);\n+            if (failedMasters.isEmpty()) {\n+                throw new RedisConnectionException(\"Not all slots are covered! Only \" + lastPartitions.size() + \" slots are avaliable\", lastException);\n+            } else {\n+                throw new RedisConnectionException(\"Not all slots are covered! Only \" + lastPartitions.size() + \" slots are avaliable. Failed masters according to cluster status: \" + failedMasters, lastException);\n+            }\n         }\n \n         scheduleClusterChangeCheck(cfg, null);",
      "parent_sha": "5091f3d30c8525c734d85b07f8a380176adfda73"
    }
  },
  {
    "oid": "258f1856bb298af538e20373008b7ad11e234fad",
    "message": "tests fixed",
    "date": "2025-01-03T14:42:08Z",
    "url": "https://github.com/redisson/redisson/commit/258f1856bb298af538e20373008b7ad11e234fad",
    "details": {
      "sha": "9d0fd45b2bb3867123bcb54cfd677612737b1e4e",
      "filename": "redisson/src/test/java/org/redisson/RedissonRemoteServiceTest.java",
      "status": "modified",
      "additions": 10,
      "deletions": 9,
      "changes": 19,
      "blob_url": "https://github.com/redisson/redisson/blob/258f1856bb298af538e20373008b7ad11e234fad/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonRemoteServiceTest.java",
      "raw_url": "https://github.com/redisson/redisson/raw/258f1856bb298af538e20373008b7ad11e234fad/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonRemoteServiceTest.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonRemoteServiceTest.java?ref=258f1856bb298af538e20373008b7ad11e234fad",
      "patch": "@@ -334,17 +334,18 @@ public void testPendingInvocations() throws InterruptedException, ExecutionExcep\n     public void testFreeWorkers() throws InterruptedException, ExecutionException {\n         RedissonClient r1 = createInstance();\n         ExecutorService executor = Executors.newSingleThreadExecutor();\n-        RRemoteService rs = r1.getRemoteService();\n+        RRemoteService rs = r1.getRemoteService(\"testFreeWorkers\");\n         rs.register(RemoteInterface.class, new RemoteImpl(), 1, executor);\n         assertThat(rs.getFreeWorkers(RemoteInterface.class)).isEqualTo(1);\n         \n         RedissonClient r2 = createInstance();\n-        RemoteInterfaceAsync ri = r2.getRemoteService().get(RemoteInterfaceAsync.class);\n+        RemoteInterfaceAsync ri = r2.getRemoteService(\"testFreeWorkers\").get(RemoteInterfaceAsync.class);\n         \n         RFuture<Void> f = ri.timeoutMethod();\n         Thread.sleep(200);\n         assertThat(rs.getFreeWorkers(RemoteInterface.class)).isEqualTo(0);\n         f.get();\n+        Thread.sleep(200);\n         assertThat(rs.getFreeWorkers(RemoteInterface.class)).isEqualTo(1);\n \n         r1.shutdown();\n@@ -359,10 +360,10 @@ public void testCancelAsync() throws InterruptedException {\n         RedissonClient r1 = createInstance();\n         AtomicInteger iterations = new AtomicInteger();\n         ExecutorService executor = Executors.newSingleThreadExecutor();\n-        r1.getRemoteService().register(RemoteInterface.class, new RemoteImpl(iterations), 1, executor);\n+        r1.getRemoteService(\"testCancelAsync\").register(RemoteInterface.class, new RemoteImpl(iterations), 1, executor);\n         \n         RedissonClient r2 = createInstance();\n-        RemoteInterfaceAsync ri = r2.getRemoteService().get(RemoteInterfaceAsync.class);\n+        RemoteInterfaceAsync ri = r2.getRemoteService(\"testCancelAsync\").get(RemoteInterfaceAsync.class);\n         \n         RFuture<Void> f = ri.cancelMethod();\n         Thread.sleep(500);\n@@ -657,7 +658,7 @@ public void testInvocationWithServiceName() {\n \n         RemoteInterface serviceRemoteInterface = client.getRemoteService(\"MyServiceNamespace\").get(RemoteInterface.class);\n         RemoteInterface otherServiceRemoteInterface = client.getRemoteService(\"MyOtherServiceNamespace\").get(RemoteInterface.class);\n-        RemoteInterface defaultServiceRemoteInterface = client.getRemoteService().get(RemoteInterface.class);\n+        RemoteInterface defaultServiceRemoteInterface = client.getRemoteService(\"MyOtherServiceNamespace2\").get(RemoteInterface.class);\n \n         assertThat(serviceRemoteInterface.resultMethod(21L)).isEqualTo(42L);\n \n@@ -693,9 +694,9 @@ public void testInvocationWithSerializationCodec() {\n         RedissonClient server = Redisson.create(createConfig().setCodec(new SerializationCodec()));\n         RedissonClient client = Redisson.create(createConfig().setCodec(new SerializationCodec()));\n         try {\n-            server.getRemoteService().register(RemoteInterface.class, new RemoteImpl());\n+            server.getRemoteService(\"testInvocationWithSerializationCodec\").register(RemoteInterface.class, new RemoteImpl());\n \n-            RemoteInterface service = client.getRemoteService().get(RemoteInterface.class);\n+            RemoteInterface service = client.getRemoteService(\"testInvocationWithSerializationCodec\").get(RemoteInterface.class);\n \n             try {\n                 assertThat(service.resultMethod(21L)).isEqualTo(42L);\n@@ -811,11 +812,11 @@ public void testAckWithoutResultInvocations() throws InterruptedException {\n         RedissonClient server = createInstance();\n         RedissonClient client = createInstance();\n         try {\n-            server.getRemoteService().register(RemoteInterface.class, new RemoteImpl());\n+            server.getRemoteService(\"testAckWithoutResultInvocations\").register(RemoteInterface.class, new RemoteImpl());\n \n             // fire and forget with an ack timeout of 1 sec\n             RemoteInvocationOptions options = RemoteInvocationOptions.defaults().expectAckWithin(1, TimeUnit.SECONDS).noResult();\n-            RemoteInterface service = client.getRemoteService().get(RemoteInterface.class, options);\n+            RemoteInterface service = client.getRemoteService(\"testAckWithoutResultInvocations\").get(RemoteInterface.class, options);\n \n             service.voidMethod(\"noResult\", 100L);\n ",
      "parent_sha": "0401642f152610235d974e45fb972f7b029a759e"
    }
  },
  {
    "oid": "adf8990356c86d1aa066d1ad125eb05f0037037b",
    "message": "Fixed - RTransaction should be executed in IN_MEMORY_ATOMIC mode #3119",
    "date": "2020-10-12T06:36:31Z",
    "url": "https://github.com/redisson/redisson/commit/adf8990356c86d1aa066d1ad125eb05f0037037b",
    "details": {
      "sha": "9a2314518f2e5505812267c8228ea0b6f3512983",
      "filename": "redisson/src/main/java/org/redisson/transaction/RedissonTransaction.java",
      "status": "modified",
      "additions": 12,
      "deletions": 7,
      "changes": 19,
      "blob_url": "https://github.com/redisson/redisson/blob/adf8990356c86d1aa066d1ad125eb05f0037037b/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Ftransaction%2FRedissonTransaction.java",
      "raw_url": "https://github.com/redisson/redisson/raw/adf8990356c86d1aa066d1ad125eb05f0037037b/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Ftransaction%2FRedissonTransaction.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Ftransaction%2FRedissonTransaction.java?ref=adf8990356c86d1aa066d1ad125eb05f0037037b",
      "patch": "@@ -304,7 +304,7 @@ private RFuture<BatchResult<?>> enableLocalCacheAsync(String requestId, Map<Hash\n             return RedissonPromise.newSucceededFuture(null);\n         }\n         \n-        RedissonBatch publishBatch = new RedissonBatch(null, commandExecutor.getConnectionManager(), BatchOptions.defaults());\n+        RedissonBatch publishBatch = createBatch();\n         for (Entry<HashKey, HashValue> entry : hashes.entrySet()) {\n             String name = RedissonObject.suffixName(entry.getKey().getName(), RedissonLocalCachedMap.TOPIC_SUFFIX);\n             RTopicAsync topic = publishBatch.getTopic(name, LocalCachedMessageCodec.INSTANCE);\n@@ -320,7 +320,7 @@ private void enableLocalCache(String requestId, Map<HashKey, HashValue> hashes)\n             return;\n         }\n         \n-        RedissonBatch publishBatch = new RedissonBatch(null, commandExecutor.getConnectionManager(), BatchOptions.defaults());\n+        RedissonBatch publishBatch = createBatch();\n         for (Entry<HashKey, HashValue> entry : hashes.entrySet()) {\n             String name = RedissonObject.suffixName(entry.getKey().getName(), RedissonLocalCachedMap.TOPIC_SUFFIX);\n             RTopicAsync topic = publishBatch.getTopic(name, LocalCachedMessageCodec.INSTANCE);\n@@ -341,7 +341,7 @@ private Map<HashKey, HashValue> disableLocalCache(String requestId, Set<String>\n         }\n         \n         Map<HashKey, HashValue> hashes = new HashMap<>(localCaches.size());\n-        RedissonBatch batch = new RedissonBatch(null, commandExecutor.getConnectionManager(), BatchOptions.defaults());\n+        RedissonBatch batch = createBatch();\n         for (TransactionalOperation transactionalOperation : operations) {\n             if (localCaches.contains(transactionalOperation.getName())) {\n                 MapOperation mapOperation = (MapOperation) transactionalOperation;\n@@ -387,7 +387,7 @@ public void onMessage(CharSequence channel, Object msg) {\n             });\n         }\n         \n-        RedissonBatch publishBatch = new RedissonBatch(null, commandExecutor.getConnectionManager(), BatchOptions.defaults());\n+        RedissonBatch publishBatch = createBatch();\n         for (Entry<HashKey, HashValue> entry : hashes.entrySet()) {\n             String disabledKeysName = RedissonObject.suffixName(entry.getKey().getName(), RedissonLocalCachedMap.DISABLED_KEYS_SUFFIX);\n             RMultimapCacheAsync<LocalCachedMapDisabledKey, String> multimap = publishBatch.getListMultimapCache(disabledKeysName, entry.getKey().getCodec());\n@@ -435,7 +435,7 @@ private RFuture<Map<HashKey, HashValue>> disableLocalCacheAsync(String requestId\n         \n         RPromise<Map<HashKey, HashValue>> result = new RedissonPromise<>();\n         Map<HashKey, HashValue> hashes = new HashMap<>(localCaches.size());\n-        RedissonBatch batch = new RedissonBatch(null, commandExecutor.getConnectionManager(), BatchOptions.defaults());\n+        RedissonBatch batch = createBatch();\n         for (TransactionalOperation transactionalOperation : operations) {\n             if (localCaches.contains(transactionalOperation.getName())) {\n                 MapOperation mapOperation = (MapOperation) transactionalOperation;\n@@ -491,7 +491,7 @@ public void onMessage(CharSequence channel, Object msg) {\n                 }\n                 \n                 subscriptionFuture.onComplete((r, ex) -> {\n-                        RedissonBatch publishBatch = new RedissonBatch(null, commandExecutor.getConnectionManager(), BatchOptions.defaults());\n+                        RedissonBatch publishBatch = createBatch();\n                         for (Entry<HashKey, HashValue> entry : hashes.entrySet()) {\n                             String disabledKeysName = RedissonObject.suffixName(entry.getKey().getName(), RedissonLocalCachedMap.DISABLED_KEYS_SUFFIX);\n                             RMultimapCacheAsync<LocalCachedMapDisabledKey, String> multimap = publishBatch.getListMultimapCache(disabledKeysName, entry.getKey().getCodec());\n@@ -538,7 +538,12 @@ public void run(Timeout timeout) throws Exception {\n         \n         return result;\n     }\n-    \n+\n+    private RedissonBatch createBatch() {\n+        return new RedissonBatch(null, commandExecutor.getConnectionManager(),\n+                                    BatchOptions.defaults().executionMode(BatchOptions.ExecutionMode.IN_MEMORY_ATOMIC));\n+    }\n+\n     protected static String generateId() {\n         byte[] id = new byte[16];\n         ThreadLocalRandom.current().nextBytes(id);",
      "parent_sha": "796335b7fc9ea79a06e1c51e835049928314efeb"
    }
  },
  {
    "oid": "d9f13f2519cd169f8f80356f395e33a7af244da8",
    "message": "Feature - Quarkus Cache implementation added #5943",
    "date": "2024-06-21T09:42:19Z",
    "url": "https://github.com/redisson/redisson/commit/d9f13f2519cd169f8f80356f395e33a7af244da8",
    "details": {
      "sha": "4012507eb6323ccc4f40d9048c3e1cbd4de4fca9",
      "filename": "redisson-quarkus/redisson-quarkus-30/cache/runtime/src/main/java/io/quarkus/cache/redisson/runtime/RedissonCacheImpl.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/redisson/redisson/blob/d9f13f2519cd169f8f80356f395e33a7af244da8/redisson-quarkus%2Fredisson-quarkus-30%2Fcache%2Fruntime%2Fsrc%2Fmain%2Fjava%2Fio%2Fquarkus%2Fcache%2Fredisson%2Fruntime%2FRedissonCacheImpl.java",
      "raw_url": "https://github.com/redisson/redisson/raw/d9f13f2519cd169f8f80356f395e33a7af244da8/redisson-quarkus%2Fredisson-quarkus-30%2Fcache%2Fruntime%2Fsrc%2Fmain%2Fjava%2Fio%2Fquarkus%2Fcache%2Fredisson%2Fruntime%2FRedissonCacheImpl.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson-quarkus%2Fredisson-quarkus-30%2Fcache%2Fruntime%2Fsrc%2Fmain%2Fjava%2Fio%2Fquarkus%2Fcache%2Fredisson%2Fruntime%2FRedissonCacheImpl.java?ref=d9f13f2519cd169f8f80356f395e33a7af244da8",
      "patch": "@@ -62,15 +62,15 @@ public RedissonCacheImpl(RedissonCacheInfo cacheInfo) {\n                 this.mapCacheNative = redisson.getMapCacheNative(cacheInfo.name);\n                 this.map = this.mapCacheNative;\n             } else {\n-                throw new IllegalArgumentException(\"\" + impl + \" implementation is available only in PRO version\");\n+                throw new IllegalArgumentException(\"\" + impl + \" implementation is available only in PRO version. Please contact sales@redisson.pro\");\n             }\n         } else {\n             if (impl == CacheImplementation.STANDARD) {\n                 this.map = redisson.getMap(cacheInfo.name);\n             } else if (impl == CacheImplementation.NATIVE) {\n                 this.map = redisson.getMapCacheNative(cacheInfo.name);\n             } else {\n-                throw new IllegalArgumentException(\"\" + impl + \" implementation is available only in PRO version\");\n+                throw new IllegalArgumentException(\"\" + impl + \" implementation is available only in PRO version. Please contact sales@redisson.pro\");\n             }\n         }\n     }",
      "parent_sha": "0fba7398d5d3d0a41e752fa1ce37ec490e5d5955"
    }
  },
  {
    "oid": "67f602f2a6278cb794696e1ded67209fde83db0e",
    "message": "Fixed - MarshallingCodec throws IllegalArgumentException: RIVER",
    "date": "2020-07-15T06:55:02Z",
    "url": "https://github.com/redisson/redisson/commit/67f602f2a6278cb794696e1ded67209fde83db0e",
    "details": {
      "sha": "b497cecaf7f7a4c661a4ee9fd5885af7673ab0c5",
      "filename": "redisson/src/main/java/org/redisson/codec/MarshallingCodec.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/redisson/redisson/blob/67f602f2a6278cb794696e1ded67209fde83db0e/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcodec%2FMarshallingCodec.java",
      "raw_url": "https://github.com/redisson/redisson/raw/67f602f2a6278cb794696e1ded67209fde83db0e/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcodec%2FMarshallingCodec.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcodec%2FMarshallingCodec.java?ref=67f602f2a6278cb794696e1ded67209fde83db0e",
      "patch": "@@ -16,6 +16,7 @@\n package org.redisson.codec;\n \n import java.io.IOException;\n+import java.util.Locale;\n \n import org.jboss.marshalling.ByteInput;\n import org.jboss.marshalling.ByteOutput;\n@@ -211,7 +212,7 @@ public MarshallingCodec(ClassLoader classLoader, MarshallingCodec codec) {\n     }\n     \n     public MarshallingCodec(Protocol protocol, MarshallingConfiguration configuration) {\n-        this.factory = Marshalling.getProvidedMarshallerFactory(protocol.toString().toLowerCase());\n+        this.factory = Marshalling.getProvidedMarshallerFactory(protocol.toString().toLowerCase(Locale.ENGLISH));\n         if (factory == null) {\n             throw new IllegalArgumentException(protocol.toString());\n         }",
      "parent_sha": "8f06210bba005d6c9150cf3496566bf451cdd0c8"
    }
  },
  {
    "oid": "58500ad134103c294122911f25806e3145be341b",
    "message": "RedissonSpringCacheManager constructor with Redisson instance only added",
    "date": "2016-12-23T10:01:23Z",
    "url": "https://github.com/redisson/redisson/commit/58500ad134103c294122911f25806e3145be341b",
    "details": {
      "sha": "1cfea6077f41190d9ec0008c486285e5861631f8",
      "filename": "redisson/src/main/java/org/redisson/spring/cache/RedissonSpringCacheManager.java",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/redisson/redisson/blob/58500ad134103c294122911f25806e3145be341b/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fspring%2Fcache%2FRedissonSpringCacheManager.java",
      "raw_url": "https://github.com/redisson/redisson/raw/58500ad134103c294122911f25806e3145be341b/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fspring%2Fcache%2FRedissonSpringCacheManager.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fspring%2Fcache%2FRedissonSpringCacheManager.java?ref=58500ad134103c294122911f25806e3145be341b",
      "patch": "@@ -52,7 +52,13 @@ public class RedissonSpringCacheManager implements CacheManager, ResourceLoaderA\n \n     private String configLocation;\n \n-    public RedissonSpringCacheManager() {\n+    /**\n+     * Creates CacheManager supplied by Redisson instance\n+     *\n+     * @param redisson object\n+     */\n+    public RedissonSpringCacheManager(RedissonClient redisson) {\n+        this(redisson, (String)null, null);\n     }\n \n     /**",
      "parent_sha": "539a0c9bdafcdab5dadb668ecadb20b792e3c650"
    }
  },
  {
    "oid": "94bf4cd30ef7be6d7c9670d1b06fde65292e3a6e",
    "message": "refactoring",
    "date": "2024-04-19T07:48:10Z",
    "url": "https://github.com/redisson/redisson/commit/94bf4cd30ef7be6d7c9670d1b06fde65292e3a6e",
    "details": {
      "sha": "4f068e995acc932043658d9cabaa794f88a86383",
      "filename": "redisson/src/main/java/org/redisson/client/protocol/decoder/ListObjectDecoder.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/94bf4cd30ef7be6d7c9670d1b06fde65292e3a6e/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fprotocol%2Fdecoder%2FListObjectDecoder.java",
      "raw_url": "https://github.com/redisson/redisson/raw/94bf4cd30ef7be6d7c9670d1b06fde65292e3a6e/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fprotocol%2Fdecoder%2FListObjectDecoder.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fprotocol%2Fdecoder%2FListObjectDecoder.java?ref=94bf4cd30ef7be6d7c9670d1b06fde65292e3a6e",
      "patch": "@@ -29,7 +29,7 @@\n  */\n public class ListObjectDecoder<T> implements MultiDecoder<T> {\n \n-    private int index;\n+    private final int index;\n     \n     public ListObjectDecoder(int index) {\n         super();",
      "parent_sha": "c5261ec077a6021fec27e1c7e9660cbac41f8828"
    }
  },
  {
    "oid": "f3e82cb561371318bfc337922294f23f90e454c4",
    "message": "Fixed - NPE handling",
    "date": "2024-02-08T07:15:31Z",
    "url": "https://github.com/redisson/redisson/commit/f3e82cb561371318bfc337922294f23f90e454c4",
    "details": {
      "sha": "fae19f420afd7ee3a47dd08ffba1843b2f0fe09d",
      "filename": "redisson/src/main/java/org/redisson/client/handler/CommandDecoder.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/redisson/redisson/blob/f3e82cb561371318bfc337922294f23f90e454c4/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fhandler%2FCommandDecoder.java",
      "raw_url": "https://github.com/redisson/redisson/raw/f3e82cb561371318bfc337922294f23f90e454c4/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fhandler%2FCommandDecoder.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fhandler%2FCommandDecoder.java?ref=f3e82cb561371318bfc337922294f23f90e454c4",
      "patch": "@@ -524,9 +524,10 @@ protected void completeResponse(CommandData<Object, Object> data, Object result)\n \n     protected MultiDecoder<Object> messageDecoder(CommandData<Object, Object> data, List<Object> parts) {\n         if (data == null) {\n-            if (parts.isEmpty()) {\n-                return null;\n+            if (!parts.isEmpty()) {\n+                log.error(\"No decoder found for decoding: {}\", parts);\n             }\n+            return null;\n         }\n         return data.getCommand().getReplayMultiDecoder();\n     }",
      "parent_sha": "45837b32090105a97b831923a49126f1c322f968"
    }
  },
  {
    "oid": "e8b046e9969916bb412982d6147e798d8d661b1f",
    "message": "checkstyle fixed",
    "date": "2022-10-14T09:15:39Z",
    "url": "https://github.com/redisson/redisson/commit/e8b046e9969916bb412982d6147e798d8d661b1f",
    "details": {
      "sha": "15f9a0f8a25945f98a9456eab5e9574e9a124a06",
      "filename": "redisson/src/main/java/org/redisson/RedissonObject.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/e8b046e9969916bb412982d6147e798d8d661b1f/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonObject.java",
      "raw_url": "https://github.com/redisson/redisson/raw/e8b046e9969916bb412982d6147e798d8d661b1f/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonObject.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonObject.java?ref=e8b046e9969916bb412982d6147e798d8d661b1f",
      "patch": "@@ -316,7 +316,7 @@ public ByteBuf encode(Object value) {\n     public void encode(Collection<?> params, Object value) {\n         try {\n             Object v = commandExecutor.encode(codec, value);\n-            ((Collection<Object>)params).add(v);\n+            ((Collection<Object>) params).add(v);\n         } catch (Exception e) {\n             params.forEach(v -> {\n                 ReferenceCountUtil.safeRelease(v);",
      "parent_sha": "a3ede6cb29ee29996e36cbcb35bfe85f48ae7ebd"
    }
  },
  {
    "oid": "3cf6f57ea439220bc1c7b901e09479bc2761e790",
    "message": "refactoring",
    "date": "2023-06-26T11:10:56Z",
    "url": "https://github.com/redisson/redisson/commit/3cf6f57ea439220bc1c7b901e09479bc2761e790",
    "details": {
      "sha": "1d08fe9d61b65660c214179fc50f803810c37986",
      "filename": "redisson/src/main/java/org/redisson/client/handler/CommandPubSubDecoder.java",
      "status": "modified",
      "additions": 26,
      "deletions": 27,
      "changes": 53,
      "blob_url": "https://github.com/redisson/redisson/blob/3cf6f57ea439220bc1c7b901e09479bc2761e790/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fhandler%2FCommandPubSubDecoder.java",
      "raw_url": "https://github.com/redisson/redisson/raw/3cf6f57ea439220bc1c7b901e09479bc2761e790/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fhandler%2FCommandPubSubDecoder.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fhandler%2FCommandPubSubDecoder.java?ref=3cf6f57ea439220bc1c7b901e09479bc2761e790",
      "patch": "@@ -111,38 +111,37 @@ protected void decodeCommand(Channel channel, ByteBuf in, QueueCommand data, int\n \n     @Override\n     protected void onError(Channel channel, String error) {\n-        if (error.contains(\"unknown command\")) {\n-            Set<String> cmds = new HashSet<>(RedisCommands.PUBSUB_COMMANDS);\n-            cmds.remove(RedisCommands.SUBSCRIBE.getName());\n-            cmds.remove(RedisCommands.UNSUBSCRIBE.getName());\n+        Set<String> cmds = new HashSet<>(RedisCommands.PUBSUB_COMMANDS);\n+        cmds.remove(RedisCommands.SUBSCRIBE.getName());\n+        cmds.remove(RedisCommands.UNSUBSCRIBE.getName());\n \n-            String cmd = null;\n-            for (String value : cmds) {\n-                if (error.contains(value)) {\n-                    cmd = value;\n-                    break;\n-                }\n+        String cmd = null;\n+        String e = error.toLowerCase();\n+        for (String value : cmds) {\n+            if (e.contains(value.toLowerCase())) {\n+                cmd = value;\n+                break;\n             }\n-            if (cmd == null) {\n-                if (error.contains(RedisCommands.UNSUBSCRIBE.getName())) {\n-                    cmd = RedisCommands.UNSUBSCRIBE.getName();\n-                } else if (error.contains(RedisCommands.SUBSCRIBE.getName())) {\n-                    cmd = RedisCommands.SUBSCRIBE.getName();\n-                }\n+        }\n+        if (cmd == null) {\n+            if (e.contains(RedisCommands.UNSUBSCRIBE.getName().toLowerCase())) {\n+                cmd = RedisCommands.UNSUBSCRIBE.getName();\n+            } else if (e.contains(RedisCommands.SUBSCRIBE.getName().toLowerCase())) {\n+                cmd = RedisCommands.SUBSCRIBE.getName();\n             }\n+        }\n \n-            if (cmd != null) {\n-                String c = cmd;\n-                commands.keySet().stream()\n-                        .filter(v -> v.getOperation().equalsIgnoreCase(c))\n-                        .forEach(v -> {\n-                            CommandData<Object, Object> dd = commands.get(v);\n-                            dd.getPromise().completeExceptionally(new RedisException(error));\n-                        });\n-            }\n-            return;\n+        if (cmd != null) {\n+            String c = cmd;\n+            commands.keySet().stream()\n+                    .filter(v -> v.getOperation().equalsIgnoreCase(c))\n+                    .forEach(v -> {\n+                        CommandData<Object, Object> dd = commands.get(v);\n+                        dd.getPromise().completeExceptionally(new RedisException(error));\n+                    });\n+        } else {\n+            super.onError(channel, error);\n         }\n-        super.onError(channel, error);\n     }\n \n     @Override",
      "parent_sha": "e774ae5d2164bc8d6e0efe64525a5305dbdb5209"
    }
  },
  {
    "oid": "09f733965ecccbdcc51eab1727beea1a4ff7400b",
    "message": "Fixed - connection leak in Topology Manager for Replicated Redis config. #3518",
    "date": "2021-03-30T05:18:43Z",
    "url": "https://github.com/redisson/redisson/commit/09f733965ecccbdcc51eab1727beea1a4ff7400b",
    "details": {
      "sha": "645ceddba9fe472091b2c1422a0589c1e642a055",
      "filename": "redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/redisson/redisson/blob/09f733965ecccbdcc51eab1727beea1a4ff7400b/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2FMasterSlaveConnectionManager.java",
      "raw_url": "https://github.com/redisson/redisson/raw/09f733965ecccbdcc51eab1727beea1a4ff7400b/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2FMasterSlaveConnectionManager.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2FMasterSlaveConnectionManager.java?ref=09f733965ecccbdcc51eab1727beea1a4ff7400b",
      "patch": "@@ -213,14 +213,15 @@ protected void closeNodeConnections() {\n     }\n     \n     protected void closeNodeConnection(RedisConnection conn) {\n-        if (nodeConnections.values().remove(conn)) {\n+        if (nodeConnections.values().removeAll(Arrays.asList(conn))) {\n             conn.closeAsync();\n         }\n     }\n \n     protected final void disconnectNode(RedisURI addr) {\n         RedisConnection conn = nodeConnections.remove(addr);\n         if (conn != null) {\n+            nodeConnections.values().removeAll(Arrays.asList(conn));\n             conn.closeAsync();\n         }\n     }\n@@ -233,8 +234,7 @@ protected final RFuture<RedisConnection> connectToNode(NodeType type, BaseConfig\n         RedisConnection conn = nodeConnections.get(addr);\n         if (conn != null) {\n             if (!conn.isActive()) {\n-                nodeConnections.remove(addr);\n-                conn.closeAsync();\n+                closeNodeConnection(conn);\n             } else {\n                 return RedissonPromise.newSucceededFuture(conn);\n             }\n@@ -251,13 +251,13 @@ protected final RFuture<RedisConnection> connectToNode(NodeType type, BaseConfig\n \n             if (connection.isActive()) {\n                 boolean isHostname = NetUtil.createByteArrayFromIpAddressString(addr.getHost()) == null;\n-                RedisURI address = addr;\n                 if (isHostname) {\n-                    address = new RedisURI(addr.getScheme()\n+                    RedisURI address = new RedisURI(addr.getScheme()\n                                  + \"://\" + connection.getRedisClient().getAddr().getAddress().getHostAddress()\n                                  + \":\" + connection.getRedisClient().getAddr().getPort());\n+                    nodeConnections.put(address, connection);\n                 }\n-                nodeConnections.put(address, connection);\n+                nodeConnections.put(addr, connection);\n                 result.trySuccess(connection);\n             } else {\n                 connection.closeAsync();",
      "parent_sha": "acbff29eab675ddc6fcfac4e4ae5dbb0f7c3ae45"
    }
  },
  {
    "oid": "238ce0790e0b77585a6608eecf36b7530e2b9a52",
    "message": "checkstyle fixed",
    "date": "2021-12-10T11:59:22Z",
    "url": "https://github.com/redisson/redisson/commit/238ce0790e0b77585a6608eecf36b7530e2b9a52",
    "details": {
      "sha": "e6efdbc03959a6d44120cc56ebb5e9ea5d307f14",
      "filename": "redisson/src/main/java/org/redisson/misc/TransferListener.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/238ce0790e0b77585a6608eecf36b7530e2b9a52/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fmisc%2FTransferListener.java",
      "raw_url": "https://github.com/redisson/redisson/raw/238ce0790e0b77585a6608eecf36b7530e2b9a52/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fmisc%2FTransferListener.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fmisc%2FTransferListener.java?ref=238ce0790e0b77585a6608eecf36b7530e2b9a52",
      "patch": "@@ -52,7 +52,7 @@ public void accept(Object t, Throwable u) {\n         if (value != null) {\n             promise.trySuccess(value);\n         } else {\n-            promise.trySuccess((T)t);\n+            promise.trySuccess((T) t);\n         }\n     }\n     ",
      "parent_sha": "b23c6649cb93cb93801f7cdbc87d7145e557065f"
    }
  },
  {
    "oid": "95cf6c92bc96e0c02a8de42078b01022c43e0345",
    "message": "Cluster state checking improvements",
    "date": "2018-09-26T12:37:07Z",
    "url": "https://github.com/redisson/redisson/commit/95cf6c92bc96e0c02a8de42078b01022c43e0345",
    "details": {
      "sha": "7c26ea6b681e9eec9a01cc6e8ee3596a9493910b",
      "filename": "redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/redisson/redisson/blob/95cf6c92bc96e0c02a8de42078b01022c43e0345/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcluster%2FClusterConnectionManager.java",
      "raw_url": "https://github.com/redisson/redisson/raw/95cf6c92bc96e0c02a8de42078b01022c43e0345/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcluster%2FClusterConnectionManager.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcluster%2FClusterConnectionManager.java?ref=95cf6c92bc96e0c02a8de42078b01022c43e0345",
      "patch": "@@ -363,21 +363,23 @@ public void operationComplete(Future<RedisConnection> future) throws Exception {\n                 }\n \n                 RedisConnection connection = future.getNow();\n-                updateClusterState(cfg, connection, iterator, uri);\n+                updateClusterState(cfg, connection, iterator, uri, lastException);\n             }\n         });\n     }\n \n-    private void updateClusterState(final ClusterServersConfig cfg, final RedisConnection connection, final Iterator<URI> iterator, final URI uri) {\n+    private void updateClusterState(final ClusterServersConfig cfg, final RedisConnection connection, \n+            final Iterator<URI> iterator, final URI uri, final AtomicReference<Throwable> lastException) {\n         RFuture<List<ClusterNodeInfo>> future = connection.async(clusterNodesCommand);\n         future.addListener(new FutureListener<List<ClusterNodeInfo>>() {\n             @Override\n             public void operationComplete(Future<List<ClusterNodeInfo>> future) throws Exception {\n                 if (!future.isSuccess()) {\n                     log.error(\"Can't execute CLUSTER_NODES with \" + connection.getRedisClient().getAddr(), future.cause());\n                     closeNodeConnection(connection);\n+                    lastException.set(future.cause());\n                     getShutdownLatch().release();\n-                    scheduleClusterChangeCheck(cfg, iterator);\n+                    checkClusterState(cfg, iterator, lastException);\n                     return;\n                 }\n ",
      "parent_sha": "0d7a134f9458e4ef52c7e3a1e904301e4f929686"
    }
  },
  {
    "oid": "b3c934b54849c77570b5c78191488497227e3aef",
    "message": "test fixed",
    "date": "2023-11-24T12:10:26Z",
    "url": "https://github.com/redisson/redisson/commit/b3c934b54849c77570b5c78191488497227e3aef",
    "details": {
      "sha": "ef344203cd55f3b49d97fdee11ad090f1e866f31",
      "filename": "redisson/src/test/java/org/redisson/RedisClientTest.java",
      "status": "modified",
      "additions": 15,
      "deletions": 26,
      "changes": 41,
      "blob_url": "https://github.com/redisson/redisson/blob/b3c934b54849c77570b5c78191488497227e3aef/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedisClientTest.java",
      "raw_url": "https://github.com/redisson/redisson/raw/b3c934b54849c77570b5c78191488497227e3aef/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedisClientTest.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedisClientTest.java?ref=b3c934b54849c77570b5c78191488497227e3aef",
      "patch": "@@ -8,6 +8,9 @@\n import org.redisson.client.protocol.CommandsData;\n import org.redisson.client.protocol.RedisCommands;\n import org.redisson.client.protocol.pubsub.PubSubType;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.junit.jupiter.Container;\n+import org.testcontainers.junit.jupiter.Testcontainers;\n \n import java.io.IOException;\n import java.util.ArrayList;\n@@ -18,39 +21,25 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n-public class RedisClientTest {\n+@Testcontainers\n+public class RedisClientTest  {\n \n-    private RedisClient redisClient;\n+    @Container\n+    private static final GenericContainer<?> REDIS =\n+            new GenericContainer<>(\"redis:7.2\")\n+                    .withExposedPorts(6379);\n+\n+    private static RedisClient redisClient;\n     \n     @BeforeAll\n-    public static void beforeClass() throws IOException, InterruptedException {\n-        if (!RedissonRuntimeEnvironment.isTravis) {\n-            RedisRunner.startDefaultRedisServerInstance();\n-        }\n-    }\n-\n-    @AfterAll\n-    public static void afterClass() throws IOException, InterruptedException {\n-        if (!RedissonRuntimeEnvironment.isTravis) {\n-            RedisRunner.shutDownDefaultRedisServerInstance();\n-        }\n-    }\n-\n-    @BeforeEach\n-    public void before() throws IOException, InterruptedException {\n-        if (RedissonRuntimeEnvironment.isTravis) {\n-            RedisRunner.startDefaultRedisServerInstance();\n-        }\n+    public static void beforeAll() {\n         RedisClientConfig config = new RedisClientConfig();\n-        config.setAddress(RedisRunner.getDefaultRedisServerBindAddressAndPort());\n+        config.setAddress(\"redis://127.0.0.1:\" + REDIS.getFirstMappedPort());\n         redisClient = RedisClient.create(config);\n     }\n \n-    @AfterEach\n-    public void after() throws InterruptedException {\n-        if (RedissonRuntimeEnvironment.isTravis) {\n-            RedisRunner.shutDownDefaultRedisServerInstance();\n-        }\n+    @AfterAll\n+    public static void afterAll() {\n         redisClient.shutdown();\n     }\n ",
      "parent_sha": "8964394e226f160291ed68cf8311805f5e4e99bb"
    }
  },
  {
    "oid": "5b580366bd683cc5eff14f6366e41902ea0b8035",
    "message": "refactoring",
    "date": "2023-11-29T10:56:55Z",
    "url": "https://github.com/redisson/redisson/commit/5b580366bd683cc5eff14f6366e41902ea0b8035",
    "details": {
      "sha": "298e1d61e4ffe216da73ecfbbaf4bef693c718cb",
      "filename": "redisson/src/test/java/org/redisson/LZ4CodecV2Test.java",
      "status": "modified",
      "additions": 3,
      "deletions": 7,
      "changes": 10,
      "blob_url": "https://github.com/redisson/redisson/blob/5b580366bd683cc5eff14f6366e41902ea0b8035/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FLZ4CodecV2Test.java",
      "raw_url": "https://github.com/redisson/redisson/raw/5b580366bd683cc5eff14f6366e41902ea0b8035/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FLZ4CodecV2Test.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FLZ4CodecV2Test.java?ref=5b580366bd683cc5eff14f6366e41902ea0b8035",
      "patch": "@@ -9,22 +9,18 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n-public class LZ4CodecV2Test extends BaseTest {\n+public class LZ4CodecV2Test extends RedisDockerTest {\n \n     @Test\n     public void test1() {\n-        Config config = new Config();\n+        Config config = createConfig();\n         config.setCodec(new LZ4Codec());\n-        config.useSingleServer()\n-                .setAddress(RedisRunner.getDefaultRedisServerBindAddressAndPort());\n         RedissonClient r = Redisson.create(config);\n         RBucket<String> s = r.getBucket(\"test1\");\n         s.set(\"12324\");\n \n-        Config config2 = new Config();\n+        Config config2 = createConfig();\n         config2.setCodec(new LZ4CodecV2());\n-        config2.useSingleServer()\n-                .setAddress(RedisRunner.getDefaultRedisServerBindAddressAndPort());\n         RedissonClient r2 = Redisson.create(config2);\n         RBucket<String> s2 = r2.getBucket(\"test1\");\n         assertThat(s2.get()).isEqualTo(\"12324\");",
      "parent_sha": "a969e5008ad67627940ca4d99ac834af0622f630"
    }
  },
  {
    "oid": "2906d574f52aee800e72318400cd2faf30bb5fdf",
    "message": "Fixed - redisson-tomcat-8 not compatible with Tomcat 8.5.2 #797",
    "date": "2017-03-15T09:08:44Z",
    "url": "https://github.com/redisson/redisson/commit/2906d574f52aee800e72318400cd2faf30bb5fdf",
    "details": {
      "sha": "80d18f91ed1694b08477d5049e9dfaec9ece93ae",
      "filename": "redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSessionManager.java",
      "status": "modified",
      "additions": 1,
      "deletions": 21,
      "changes": 22,
      "blob_url": "https://github.com/redisson/redisson/blob/2906d574f52aee800e72318400cd2faf30bb5fdf/redisson-tomcat%2Fredisson-tomcat-8%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Ftomcat%2FRedissonSessionManager.java",
      "raw_url": "https://github.com/redisson/redisson/raw/2906d574f52aee800e72318400cd2faf30bb5fdf/redisson-tomcat%2Fredisson-tomcat-8%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Ftomcat%2FRedissonSessionManager.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson-tomcat%2Fredisson-tomcat-8%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Ftomcat%2FRedissonSessionManager.java?ref=2906d574f52aee800e72318400cd2faf30bb5fdf",
      "patch": "@@ -18,14 +18,11 @@\n import java.io.File;\n import java.io.IOException;\n \n-import org.apache.catalina.Context;\n import org.apache.catalina.Lifecycle;\n import org.apache.catalina.LifecycleException;\n-import org.apache.catalina.LifecycleListener;\n import org.apache.catalina.LifecycleState;\n import org.apache.catalina.Session;\n import org.apache.catalina.session.ManagerBase;\n-import org.apache.catalina.util.LifecycleSupport;\n import org.apache.juli.logging.Log;\n import org.apache.juli.logging.LogFactory;\n import org.redisson.Redisson;\n@@ -43,8 +40,6 @@ public class RedissonSessionManager extends ManagerBase implements Lifecycle {\n \n     private final Log log = LogFactory.getLog(RedissonSessionManager.class);\n     \n-    protected LifecycleSupport lifecycle = new LifecycleSupport(this);\n-    \n     private RedissonClient redisson;\n     private String configPath;\n     \n@@ -74,29 +69,14 @@ public void load() throws ClassNotFoundException, IOException {\n     public void unload() throws IOException {\n     }\n \n-    @Override\n-    public void addLifecycleListener(LifecycleListener listener) {\n-        lifecycle.addLifecycleListener(listener);\n-    }\n-\n-    @Override\n-    public LifecycleListener[] findLifecycleListeners() {\n-        return lifecycle.findLifecycleListeners();\n-    }\n-\n-    @Override\n-    public void removeLifecycleListener(LifecycleListener listener) {\n-        lifecycle.removeLifecycleListener(listener);\n-    }\n-\n     @Override\n     public Session createSession(String sessionId) {\n         RedissonSession session = (RedissonSession) createEmptySession();\n         \n         session.setNew(true);\n         session.setValid(true);\n         session.setCreationTime(System.currentTimeMillis());\n-        session.setMaxInactiveInterval(((Context) getContainer()).getSessionTimeout() * 60);\n+        session.setMaxInactiveInterval(getContext().getSessionTimeout() * 60);\n \n         if (sessionId == null) {\n             sessionId = generateSessionId();",
      "parent_sha": "98e83507079292624133c7d8fd89a4e03bf0bf1f"
    }
  },
  {
    "oid": "e061d1c7d7d7ecdada20040fc6e87968fe4fb608",
    "message": "Redisson failed to start when one of sentinel servers is down. Fixed.",
    "date": "2016-01-30T10:44:28Z",
    "url": "https://github.com/redisson/redisson/commit/e061d1c7d7d7ecdada20040fc6e87968fe4fb608",
    "details": {
      "sha": "934e6c2f96efaf7302a9d10bac340a60ca84f6e7",
      "filename": "src/main/java/org/redisson/connection/SentinelConnectionManager.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/e061d1c7d7d7ecdada20040fc6e87968fe4fb608/src%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2FSentinelConnectionManager.java",
      "raw_url": "https://github.com/redisson/redisson/raw/e061d1c7d7d7ecdada20040fc6e87968fe4fb608/src%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2FSentinelConnectionManager.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/src%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2FSentinelConnectionManager.java?ref=e061d1c7d7d7ecdada20040fc6e87968fe4fb608",
      "patch": "@@ -127,7 +127,7 @@ public SentinelConnectionManager(SentinelServersConfig cfg, Config config) {\n         }\n \n         for (Future<RedisPubSubConnection> future : connectionFutures) {\n-            future.syncUninterruptibly();\n+            future.awaitUninterruptibly();\n         }\n     }\n ",
      "parent_sha": "c619e5634a59c022f61fb1d3e7654faccfc9ee52"
    }
  },
  {
    "oid": "3050949cfa174819f0f42272f0ed7b9135274bba",
    "message": "refactoring",
    "date": "2017-09-01T07:44:36Z",
    "url": "https://github.com/redisson/redisson/commit/3050949cfa174819f0f42272f0ed7b9135274bba",
    "details": {
      "sha": "01e0125e40ab8b64e5108dcb7e7d42c8ba98e675",
      "filename": "redisson/src/main/java/org/redisson/command/CommandAsyncService.java",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/redisson/redisson/blob/3050949cfa174819f0f42272f0ed7b9135274bba/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcommand%2FCommandAsyncService.java",
      "raw_url": "https://github.com/redisson/redisson/raw/3050949cfa174819f0f42272f0ed7b9135274bba/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcommand%2FCommandAsyncService.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcommand%2FCommandAsyncService.java?ref=3050949cfa174819f0f42272f0ed7b9135274bba",
      "patch": "@@ -548,7 +548,7 @@ public void run(Timeout t) throws Exception {\n \n                 if (details.getAttempt() == connectionManager.getConfig().getRetryAttempts()) {\n                     if (details.getException() == null) {\n-                        details.setException(new RedisTimeoutException(\"Command execution timeout for command: \" + command + \" with params: \" + LogHelper.toString(details.getParams())));\n+                        details.setException(new RedisTimeoutException(\"Unable to send command: \" + command + \" with params: \" + LogHelper.toString(details.getParams() + \" after \" + connectionManager.getConfig().getRetryAttempts() + \" retry attempts\")));\n                     }\n                     details.getAttemptPromise().tryFailure(details.getException());\n                     free(details);\n@@ -648,6 +648,10 @@ private <V, R> void checkWriteFuture(final AsyncDetails<V, R> details, final Red\n         if (!future.isSuccess()) {\n             details.setException(new WriteRedisConnectionException(\n                     \"Can't write command: \" + details.getCommand() + \", params: \" + LogHelper.toString(details.getParams()) + \" to channel: \" + future.channel(), future.cause()));\n+            if (details.getAttempt() == connectionManager.getConfig().getRetryAttempts()) {\n+                details.getAttemptPromise().tryFailure(details.getException());\n+                free(details);\n+            }\n             return;\n         }\n ",
      "parent_sha": "ee0ecce55c3d7c8038d7ff1f24d96ca036e62d90"
    }
  },
  {
    "oid": "5b40913b967f8fc959e7277d8f19b92b78ee9c99",
    "message": "refactoring",
    "date": "2019-01-29T14:16:13Z",
    "url": "https://github.com/redisson/redisson/commit/5b40913b967f8fc959e7277d8f19b92b78ee9c99",
    "details": {
      "sha": "6f5b304c9ac819f8663f914dbda2403f88f4e4fd",
      "filename": "redisson/src/main/java/org/redisson/command/CommandAsyncService.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/redisson/redisson/blob/5b40913b967f8fc959e7277d8f19b92b78ee9c99/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcommand%2FCommandAsyncService.java",
      "raw_url": "https://github.com/redisson/redisson/raw/5b40913b967f8fc959e7277d8f19b92b78ee9c99/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcommand%2FCommandAsyncService.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcommand%2FCommandAsyncService.java?ref=5b40913b967f8fc959e7277d8f19b92b78ee9c99",
      "patch": "@@ -938,8 +938,7 @@ private <V, R> void checkWriteFuture(final AsyncDetails<V, R> details, final boo\n         TimerTask timeoutTask = new TimerTask() {\n             @Override\n             public void run(Timeout timeout) throws Exception {\n-                if (!details.getAttemptPromise().isDone() \n-                        && details.getAttempt() < connectionManager.getConfig().getRetryAttempts()) {\n+                if (details.getAttempt() < connectionManager.getConfig().getRetryAttempts()) {\n                     if (!details.getAttemptPromise().cancel(false)) {\n                         return;\n                     }",
      "parent_sha": "76bd80eb081d21a56d0c871b5b4849024ed7f923"
    }
  },
  {
    "oid": "239d5b9c8a189b03fbd4dbe541b64b4ecbc538d6",
    "message": "Fixed - keepPubSubOrder setting isn't used #5123",
    "date": "2023-06-23T08:36:38Z",
    "url": "https://github.com/redisson/redisson/commit/239d5b9c8a189b03fbd4dbe541b64b4ecbc538d6",
    "details": {
      "sha": "f8c7342007ebc6cd27b0340835d31ff6f8dd8770",
      "filename": "redisson/src/main/java/org/redisson/client/handler/CommandPubSubDecoder.java",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/redisson/redisson/blob/239d5b9c8a189b03fbd4dbe541b64b4ecbc538d6/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fhandler%2FCommandPubSubDecoder.java",
      "raw_url": "https://github.com/redisson/redisson/raw/239d5b9c8a189b03fbd4dbe541b64b4ecbc538d6/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fhandler%2FCommandPubSubDecoder.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fhandler%2FCommandPubSubDecoder.java?ref=239d5b9c8a189b03fbd4dbe541b64b4ecbc538d6",
      "patch": "@@ -154,14 +154,13 @@ protected void decodeResult(CommandData<Object, Object> data, List<Object> parts\n                         channelName = ((PubSubPatternMessage) result).getPattern();\n                     }\n                     PubSubEntry entry = entries.remove(channelName);\n-                    if (config.isKeepAlive()) {\n+                    if (config.isKeepPubSubOrder()) {\n                         enqueueMessage(result, pubSubConnection, entry);\n                     }\n                 }\n             }\n-            \n-            \n-            if (config.isKeepAlive()) {\n+\n+            if (config.isKeepPubSubOrder()) {\n                 if (result instanceof PubSubPatternMessage) {\n                     channelName = ((PubSubPatternMessage) result).getPattern();\n                 }",
      "parent_sha": "33ac54cf8955f20f1016b03c8c7b5821b76a7c07"
    }
  },
  {
    "oid": "8b553c8e9b578011732d70a70bb6596edea5757a",
    "message": "fix ZPOPMIN\\ZPOPMAX to count members error\nSigned-off-by: chenxiabin <czchenxiabin@gmail.com>",
    "date": "2024-03-14T08:23:33Z",
    "url": "https://github.com/redisson/redisson/commit/8b553c8e9b578011732d70a70bb6596edea5757a",
    "details": {
      "sha": "cca4f1518be7c9ecbd175c5b1cff2214921c2539",
      "filename": "redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/redisson/redisson/blob/8b553c8e9b578011732d70a70bb6596edea5757a/redisson-spring-data%2Fredisson-spring-data-26%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fspring%2Fdata%2Fconnection%2FRedissonConnection.java",
      "raw_url": "https://github.com/redisson/redisson/raw/8b553c8e9b578011732d70a70bb6596edea5757a/redisson-spring-data%2Fredisson-spring-data-26%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fspring%2Fdata%2Fconnection%2FRedissonConnection.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson-spring-data%2Fredisson-spring-data-26%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fspring%2Fdata%2Fconnection%2FRedissonConnection.java?ref=8b553c8e9b578011732d70a70bb6596edea5757a",
      "patch": "@@ -2485,11 +2485,13 @@ public Tuple zPopMin(byte[] key) {\n         return write(key, ByteArrayCodec.INSTANCE, ZPOPMIN, (Object) key);\n     }\n \n+    private static final RedisCommand<Set<Tuple>> ZPOPMIN_FOR_SET = new RedisCommand<>(\"ZPOPMIN\", new ScoredSortedSetReplayDecoder());\n+\n     @Override\n     public Set<Tuple> zPopMin(byte[] key, long count) {\n         Assert.notNull(key, \"Key must not be null!\");\n \n-        return write(key, ByteArrayCodec.INSTANCE, ZPOPMIN, key, count);\n+        return write(key, ByteArrayCodec.INSTANCE, ZPOPMIN_FOR_SET, key, count);\n     }\n \n     private static final RedisCommand<Tuple> BZPOPMIN = new RedisCommand<>(\"BZPOPMIN\", new ScoredSortedSingleBlockingReplayDecoder());\n@@ -2511,11 +2513,13 @@ public Tuple zPopMax(byte[] key) {\n         return write(key, ByteArrayCodec.INSTANCE, ZPOPMAX, (Object) key);\n     }\n \n+    private static final RedisCommand<Set<Tuple>> ZPOPMAX_FOR_SET = new RedisCommand<>(\"ZPOPMAX\", new ScoredSortedSetReplayDecoder());\n+\t\n     @Override\n     public Set<Tuple> zPopMax(byte[] key, long count) {\n         Assert.notNull(key, \"Key must not be null!\");\n \n-        return write(key, ByteArrayCodec.INSTANCE, ZPOPMAX, key, count);\n+        return write(key, ByteArrayCodec.INSTANCE, ZPOPMAX_FOR_SET, key, count);\n     }\n \n     private static final RedisCommand<Tuple> BZPOPMAX = new RedisCommand<>(\"BZPOPMAX\", new ScoredSortedSingleBlockingReplayDecoder());",
      "parent_sha": "a4f0c9479dd5d4c60f701ccbe584910df9870146"
    }
  },
  {
    "oid": "4a1c7281cd2ed057e9f359dedb4a8fe0e1828ba7",
    "message": "ConnectionManger.shutdown completes within timeout\n\nMake sure that the total time of shutdown() does not exceed the\nprovided timeout.\n\nSigned-off-by: Dave Golombek\n\nFixes #5367\n\nSigned-off-by: David Golombek <dgolombek@mylookout.com>",
    "date": "2023-10-17T12:47:14Z",
    "url": "https://github.com/redisson/redisson/commit/4a1c7281cd2ed057e9f359dedb4a8fe0e1828ba7",
    "details": {
      "sha": "84541053a1f43bdb1ef94d57995aa2cad045b874",
      "filename": "redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java",
      "status": "modified",
      "additions": 10,
      "deletions": 3,
      "changes": 13,
      "blob_url": "https://github.com/redisson/redisson/blob/4a1c7281cd2ed057e9f359dedb4a8fe0e1828ba7/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2FMasterSlaveConnectionManager.java",
      "raw_url": "https://github.com/redisson/redisson/raw/4a1c7281cd2ed057e9f359dedb4a8fe0e1828ba7/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2FMasterSlaveConnectionManager.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fconnection%2FMasterSlaveConnectionManager.java?ref=4a1c7281cd2ed057e9f359dedb4a8fe0e1828ba7",
      "patch": "@@ -472,6 +472,7 @@ public void shutdown(long quietPeriod, long timeout, TimeUnit unit) {\n         if (dnsMonitor != null) {\n             dnsMonitor.stop();\n         }\n+        long timeoutInNanos = unit.toNanos(timeout);\n \n         serviceManager.getConnectionWatcher().stop();\n \n@@ -483,7 +484,9 @@ public void shutdown(long quietPeriod, long timeout, TimeUnit unit) {\n             CompletableFuture<Void> future = CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n \n             try {\n-                future.get(timeout, unit);\n+                long startTime = System.nanoTime();\n+                future.get(timeoutInNanos, TimeUnit.NANOSECONDS);\n+                timeoutInNanos -= (System.nanoTime() - startTime);\n             } catch (Exception e) {\n                 // skip\n             }\n@@ -495,7 +498,9 @@ public void shutdown(long quietPeriod, long timeout, TimeUnit unit) {\n         if (serviceManager.getCfg().getExecutor() == null) {\n             serviceManager.getExecutor().shutdown();\n             try {\n-                serviceManager.getExecutor().awaitTermination(timeout, unit);\n+                long startTime = System.nanoTime();\n+                serviceManager.getExecutor().awaitTermination(timeoutInNanos, TimeUnit.NANOSECONDS);\n+                timeoutInNanos -= (System.nanoTime() - startTime);\n             } catch (InterruptedException e) {\n                 Thread.currentThread().interrupt();\n             }\n@@ -505,7 +510,9 @@ public void shutdown(long quietPeriod, long timeout, TimeUnit unit) {\n         serviceManager.getShutdownLatch().awaitUninterruptibly();\n \n         if (serviceManager.getCfg().getEventLoopGroup() == null) {\n-            serviceManager.getGroup().shutdownGracefully(quietPeriod, timeout, unit).syncUninterruptibly();\n+            long startTime = System.nanoTime();\n+            serviceManager.getGroup().shutdownGracefully(quietPeriod, timeoutInNanos, TimeUnit.NANOSECONDS).syncUninterruptibly();\n+            timeoutInNanos -= (System.nanoTime() - startTime);\n         }\n \n         serviceManager.getTimer().stop();",
      "parent_sha": "b1456639a30c88221dd04e1f328e48aa1464f1d7"
    }
  },
  {
    "oid": "8669589d7e012b922f4673a8d56c81fd98686022",
    "message": "refactoring",
    "date": "2019-08-20T10:21:38Z",
    "url": "https://github.com/redisson/redisson/commit/8669589d7e012b922f4673a8d56c81fd98686022",
    "details": {
      "sha": "25864c65f157bcaa2a4e0e3d27961df3183497fa",
      "filename": "redisson/src/main/java/org/redisson/cache/ReferenceCacheMap.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/8669589d7e012b922f4673a8d56c81fd98686022/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcache%2FReferenceCacheMap.java",
      "raw_url": "https://github.com/redisson/redisson/raw/8669589d7e012b922f4673a8d56c81fd98686022/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcache%2FReferenceCacheMap.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcache%2FReferenceCacheMap.java?ref=8669589d7e012b922f4673a8d56c81fd98686022",
      "patch": "@@ -30,7 +30,7 @@ public class ReferenceCacheMap<K, V> extends AbstractCacheMap<K, V> {\n \n     private final ReferenceQueue<V> queue = new ReferenceQueue<V>();\n     \n-    private ReferenceCachedValue.Type type;\n+    private final ReferenceCachedValue.Type type;\n     \n     public static <K, V> ReferenceCacheMap<K, V> weak(long timeToLiveInMillis, long maxIdleInMillis) {\n         return new ReferenceCacheMap<K, V>(timeToLiveInMillis, maxIdleInMillis, Type.WEAK);",
      "parent_sha": "1a6ef7b9f9f9dd6257a540600c7d8bf7b50ba572"
    }
  },
  {
    "oid": "b77a4e4bc1294c1df4bc4c799d9846ecf2785c69",
    "message": "Fix primary update condition for cluster mode.\n\nSigned-off-by: Jerry Wu <jerrywzc213@gmail.com>",
    "date": "2021-08-03T23:42:33Z",
    "url": "https://github.com/redisson/redisson/commit/b77a4e4bc1294c1df4bc4c799d9846ecf2785c69",
    "details": {
      "sha": "5db18700784d204b36853a7fe73297bef884be5d",
      "filename": "redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/redisson/redisson/blob/b77a4e4bc1294c1df4bc4c799d9846ecf2785c69/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcluster%2FClusterConnectionManager.java",
      "raw_url": "https://github.com/redisson/redisson/raw/b77a4e4bc1294c1df4bc4c799d9846ecf2785c69/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcluster%2FClusterConnectionManager.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcluster%2FClusterConnectionManager.java?ref=b77a4e4bc1294c1df4bc4c799d9846ecf2785c69",
      "patch": "@@ -566,8 +566,8 @@ private RFuture<Void> checkMasterNodesChange(ClusterServersConfig cfg, Collectio\n                     continue;\n                 }\n                 masterFound = true;\n-                // current master marked as failed\n-                if (!newPart.isMasterFail() || newPart.getSlotsAmount() == 0) {\n+                // skip the new master if it is marked as failed or has no slots\n+                if (newPart.isMasterFail() || newPart.getSlotsAmount() == 0) {\n                     continue;\n                 }\n                 for (Integer slot : currentPart.getSlots()) {\n@@ -593,7 +593,7 @@ private RFuture<Void> checkMasterNodesChange(ClusterServersConfig cfg, Collectio\n                 break;\n             }\n \n-            if (!masterFound && newPart.getSlotsAmount() > 0) {\n+            if (!masterFound && !newPart.isMasterFail() && newPart.getSlotsAmount() > 0) {\n                 addedPartitions.put(newPart.getMasterAddress(), newPart);\n             }\n         }",
      "parent_sha": "7a0583b145a776cdc927bc10f3c26761258793d8"
    }
  },
  {
    "oid": "949bbe7f0110d00084ed67766ea4419477e24c34",
    "message": "compilation fixed",
    "date": "2018-01-24T06:48:05Z",
    "url": "https://github.com/redisson/redisson/commit/949bbe7f0110d00084ed67766ea4419477e24c34",
    "details": {
      "sha": "66cc94cb61ea4903537546a04b5a6836e8d9cbc7",
      "filename": "redisson/src/main/java/org/redisson/RedissonDoubleAdder.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/redisson/redisson/blob/949bbe7f0110d00084ed67766ea4419477e24c34/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonDoubleAdder.java",
      "raw_url": "https://github.com/redisson/redisson/raw/949bbe7f0110d00084ed67766ea4419477e24c34/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonDoubleAdder.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonDoubleAdder.java?ref=949bbe7f0110d00084ed67766ea4419477e24c34",
      "patch": "@@ -15,13 +15,12 @@\n  */\n package org.redisson;\n \n-import java.util.concurrent.atomic.DoubleAdder;\n-\n import org.redisson.api.RAtomicDouble;\n import org.redisson.api.RDoubleAdder;\n import org.redisson.api.RFuture;\n import org.redisson.api.RedissonClient;\n import org.redisson.command.CommandAsyncExecutor;\n+import org.redisson.misc.DoubleAdder;\n \n /**\n  * ",
      "parent_sha": "16ff4b1bbc0556ec4ed36c28d07166317d06bd42"
    }
  },
  {
    "oid": "a89f1a7f25549e7aa8e4154ff5230ac15dce6ddf",
    "message": "Improvement - JCache performance optimization. #1722",
    "date": "2018-11-13T21:06:51Z",
    "url": "https://github.com/redisson/redisson/commit/a89f1a7f25549e7aa8e4154ff5230ac15dce6ddf",
    "details": {
      "sha": "482a365c3434b157042b76d8e82dd93dc2a0d18a",
      "filename": "redisson/src/main/java/org/redisson/jcache/JCache.java",
      "status": "modified",
      "additions": 229,
      "deletions": 68,
      "changes": 297,
      "blob_url": "https://github.com/redisson/redisson/blob/a89f1a7f25549e7aa8e4154ff5230ac15dce6ddf/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fjcache%2FJCache.java",
      "raw_url": "https://github.com/redisson/redisson/raw/a89f1a7f25549e7aa8e4154ff5230ac15dce6ddf/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fjcache%2FJCache.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fjcache%2FJCache.java?ref=a89f1a7f25549e7aa8e4154ff5230ac15dce6ddf",
      "patch": "@@ -15,6 +15,9 @@\n  */\n package org.redisson.jcache;\n \n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n@@ -82,6 +85,8 @@\n  */\n public class JCache<K, V> extends RedissonObject implements Cache<K, V> {\n \n+    private final boolean v2 = System.getProperty(\"org.jsr107.tck.management.agentId\") == null;\n+    \n     private final JCacheManager cacheManager;\n     private final JCacheConfiguration<K, V> config;\n     private final ConcurrentMap<CacheEntryListenerConfiguration<K, V>, Map<Integer, String>> listeners = \n@@ -93,6 +98,13 @@ public class JCache<K, V> extends RedissonObject implements Cache<K, V> {\n     private boolean closed;\n     private boolean hasOwnRedisson;\n     \n+    private static final RLock DUMMY_LOCK = (RLock) Proxy.newProxyInstance(JCache.class.getClassLoader(), new Class[] {RLock.class}, new InvocationHandler() {\n+        @Override\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            return null;\n+        }\n+    });\n+    \n     public JCache(JCacheManager cacheManager, Redisson redisson, String name, JCacheConfiguration<K, V> config, boolean hasOwnRedisson) {\n         super(redisson.getConfig().getCodec(), redisson.getCommandExecutor(), name);\n         \n@@ -176,7 +188,12 @@ public V get(K key) {\n         long startTime = currentNanoTime();\n         RLock lock = getLockedLock(key);\n         try {\n-            V value = getValueLocked(key);\n+            V value;\n+            if (v2) {\n+                value = getValue(key);\n+            } else {\n+                value = getValueLocked(key);\n+            }\n             if (value == null) {\n                 cacheManager.getStatBean(this).addMisses(1);\n                 if (config.isReadThrough()) {\n@@ -253,6 +270,29 @@ V getValueLocked(K key) {\n     private V getValue(K key) {\n         Long accessTimeout = getAccessTimeout();\n         \n+        if (accessTimeout == -1) {\n+            V value = evalRead(getName(), codec, RedisCommands.EVAL_MAP_VALUE,\n+                    \"local value = redis.call('hget', KEYS[1], ARGV[3]); \"\n+                  + \"if value == false then \"\n+                      + \"return nil; \"\n+                  + \"end; \"\n+                      \n+                  + \"local expireDate = 92233720368547758; \"\n+                  + \"local expireDateScore = redis.call('zscore', KEYS[2], ARGV[3]); \"\n+                  + \"if expireDateScore ~= false then \"\n+                      + \"expireDate = tonumber(expireDateScore); \"\n+                  + \"end; \"\n+                  \n+                  + \"if expireDate <= tonumber(ARGV[2]) then \"\n+                      + \"return nil; \"\n+                  + \"end; \"\n+                  \n+                  + \"return value; \",\n+                 Arrays.<Object>asList(getName(), getTimeoutSetName(), getRemovedChannelName()), \n+                 accessTimeout, System.currentTimeMillis(), encodeMapKey(key));\n+            return value;\n+        }\n+        \n         V value = evalWrite(getName(), codec, RedisCommands.EVAL_MAP_VALUE,\n                 \"local value = redis.call('hget', KEYS[1], ARGV[3]); \"\n               + \"if value == false then \"\n@@ -301,7 +341,12 @@ private Long getAccessTimeout() {\n     V load(K key) {\n         RLock lock = getLockedLock(key);\n         try {\n-            V value = getValueLocked(key);\n+            V value;\n+            if (v2) {\n+                value = getValue(key);\n+            } else {\n+                value = getValueLocked(key);\n+            }\n             if (value == null) {\n                 value = loadValue(key);\n             }\n@@ -320,7 +365,11 @@ private V loadValue(K key) {\n         }\n         if (value != null) {\n             long startTime = currentNanoTime();\n-            putValueLocked(key, value);\n+            if (v2) {\n+                putValue(key, value);\n+            } else {\n+                putValueLocked(key, value);\n+            }\n             cacheManager.getStatBean(this).addGetTime(currentNanoTime() - startTime);\n         }\n         return value;\n@@ -518,14 +567,15 @@ private Long getCreationTimeout() {\n     \n     private boolean putIfAbsentValue(K key, Object value) {\n         Long creationTimeout = getCreationTimeout();\n+        if (creationTimeout == 0) {\n+            return false;\n+        }\n         \n         return evalWrite(getName(), codec, RedisCommands.EVAL_BOOLEAN,\n                 \"if redis.call('hexists', KEYS[1], ARGV[2]) == 1 then \"\n                   + \"return 0; \"\n               + \"else \"\n-                  + \"if ARGV[1] == '0' then \"\n-                      + \"return 0;\"                      \n-                  + \"elseif ARGV[1] ~= '-1' then \"\n+                  + \"if ARGV[1] ~= '-1' then \"\n                       + \"redis.call('hset', KEYS[1], ARGV[2], ARGV[3]); \"                                  \n                       + \"redis.call('zadd', KEYS[2], ARGV[1], ARGV[2]); \"\n                       + \"local msg = struct.pack('Lc0Lc0', string.len(ARGV[2]), ARGV[2], string.len(ARGV[3]), ARGV[3]); \"\n@@ -548,10 +598,11 @@ private boolean putIfAbsentValueLocked(K key, Object value) {\n         }\n         \n         Long creationTimeout = getCreationTimeout();\n+        if (creationTimeout == 0) {\n+            return false;\n+        }\n         return evalWrite(getName(), codec, RedisCommands.EVAL_BOOLEAN,\n-                    \"if ARGV[1] == '0' then \"\n-                      + \"return 0;\"                      \n-                  + \"elseif ARGV[1] ~= '-1' then \"\n+                    \"if ARGV[1] ~= '-1' then \"\n                       + \"redis.call('hset', KEYS[1], ARGV[2], ARGV[3]); \"                                  \n                       + \"redis.call('zadd', KEYS[2], ARGV[1], ARGV[2]); \"\n                       + \"local msg = struct.pack('Lc0Lc0', string.len(ARGV[2]), ARGV[2], string.len(ARGV[3]), ARGV[3]); \"\n@@ -590,15 +641,18 @@ public Map<K, V> getAll(Set<? extends K> keys) {\n         }\n \n         long startTime = currentNanoTime();\n-        boolean exists = false;\n-        for (K key : keys) {\n-            if (containsKey(key)) {\n-                exists = true;\n+        if (!config.isReadThrough()) {\n+            boolean exists = false;\n+            for (K key : keys) {\n+                if (containsKey(key)) {\n+                    exists = true;\n+                    break;\n+                }\n+            }\n+            if (!exists) {\n+                cacheManager.getStatBean(this).addGetTime(currentNanoTime() - startTime);\n+                return Collections.emptyMap();\n             }\n-        }\n-        if (!exists && !config.isReadThrough()) {\n-            cacheManager.getStatBean(this).addGetTime(currentNanoTime() - startTime);\n-            return Collections.emptyMap();\n         }\n         \n         \n@@ -608,43 +662,75 @@ public Map<K, V> getAll(Set<? extends K> keys) {\n         args.add(accessTimeout);\n         args.add(System.currentTimeMillis());\n         encode(args, keys);\n+        \n+        Map<K, V> res;\n+        if (accessTimeout == -1) {\n+            res = evalRead(getName(), codec, new RedisCommand<Map<Object, Object>>(\"EVAL\", new MapGetAllDecoder(new ArrayList<Object>(keys), 0, true), ValueType.MAP_VALUE),\n+                    \"local expireHead = redis.call('zrange', KEYS[2], 0, 0, 'withscores');\"\n+                  + \"local accessTimeout = ARGV[1]; \"\n+                  + \"local currentTime = tonumber(ARGV[2]); \"\n+                  + \"local hasExpire = #expireHead == 2 and tonumber(expireHead[2]) <= currentTime; \"\n+                  + \"local map = redis.call('hmget', KEYS[1], unpack(ARGV, 3, #ARGV)); \"\n+                  + \"local result = {};\"\n+                  + \"for i, value in ipairs(map) do \"\n+                      + \"if value ~= false then \"\n+                          + \"local key = ARGV[i+2]; \"\n+\n+                          + \"if hasExpire then \"\n+                              + \"local expireDate = 92233720368547758; \"\n+                              + \"local expireDateScore = redis.call('zscore', KEYS[2], key); \"\n+                              + \"if expireDateScore ~= false then \"\n+                                  + \"expireDate = tonumber(expireDateScore); \"\n+                              + \"end; \"\n+                              + \"if expireDate <= currentTime then \"\n+                                  + \"value = false; \"\n+                              + \"end; \"\n+                          + \"end; \"\n+                      + \"end; \"\n \n-        Map<K, V> res = evalWrite(getName(), codec, new RedisCommand<Map<Object, Object>>(\"EVAL\", new MapGetAllDecoder(new ArrayList<Object>(keys), 0, true), ValueType.MAP_VALUE),\n-                        \"local expireHead = redis.call('zrange', KEYS[2], 0, 0, 'withscores');\"\n-                      + \"local accessTimeout = ARGV[1]; \"\n-                      + \"local currentTime = tonumber(ARGV[2]); \"\n-                      + \"local hasExpire = #expireHead == 2 and tonumber(expireHead[2]) <= currentTime; \"\n-                      + \"local map = redis.call('hmget', KEYS[1], unpack(ARGV, 3, #ARGV)); \"\n-                      + \"local result = {};\"\n-                      + \"for i, value in ipairs(map) do \"\n-                          + \"if value ~= false then \"\n-                              + \"local key = ARGV[i+2]; \"\n-\n-                              + \"if hasExpire then \"\n-                                  + \"local expireDate = 92233720368547758; \"\n-                                  + \"local expireDateScore = redis.call('zscore', KEYS[2], key); \"\n-                                  + \"if expireDateScore ~= false then \"\n-                                      + \"expireDate = tonumber(expireDateScore); \"\n+                      + \"table.insert(result, value); \"\n+                  + \"end; \"\n+                  + \"return result;\",\n+            Arrays.<Object>asList(getName(), getTimeoutSetName(), getRemovedChannelName()), args.toArray());\n+        } else {\n+            res = evalWrite(getName(), codec, new RedisCommand<Map<Object, Object>>(\"EVAL\", new MapGetAllDecoder(new ArrayList<Object>(keys), 0, true), ValueType.MAP_VALUE),\n+                            \"local expireHead = redis.call('zrange', KEYS[2], 0, 0, 'withscores');\"\n+                          + \"local accessTimeout = ARGV[1]; \"\n+                          + \"local currentTime = tonumber(ARGV[2]); \"\n+                          + \"local hasExpire = #expireHead == 2 and tonumber(expireHead[2]) <= currentTime; \"\n+                          + \"local map = redis.call('hmget', KEYS[1], unpack(ARGV, 3, #ARGV)); \"\n+                          + \"local result = {};\"\n+                          + \"for i, value in ipairs(map) do \"\n+                              + \"if value ~= false then \"\n+                                  + \"local key = ARGV[i+2]; \"\n+\n+                                  + \"if hasExpire then \"\n+                                      + \"local expireDate = 92233720368547758; \"\n+                                      + \"local expireDateScore = redis.call('zscore', KEYS[2], key); \"\n+                                      + \"if expireDateScore ~= false then \"\n+                                          + \"expireDate = tonumber(expireDateScore); \"\n+                                      + \"end; \"\n+                                      + \"if expireDate <= currentTime then \"\n+                                          + \"value = false; \"\n+                                      + \"end; \"\n                                   + \"end; \"\n-                                  + \"if expireDate <= currentTime then \"\n-                                      + \"value = false; \"\n+                                      \n+                                  + \"if accessTimeout == '0' then \"\n+                                      + \"redis.call('hdel', KEYS[1], key); \"\n+                                      + \"redis.call('zrem', KEYS[2], key); \"\n+                                      + \"local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(value), value); \"\n+                                      + \"redis.call('publish', KEYS[3], {key, value}); \"\n+                                  + \"elseif accessTimeout ~= '-1' then \" \n+                                      + \"redis.call('zadd', KEYS[2], accessTimeout, key); \"\n                                   + \"end; \"\n                               + \"end; \"\n-                                  \n-                              + \"if accessTimeout == '0' then \"\n-                                  + \"redis.call('hdel', KEYS[1], key); \"\n-                                  + \"redis.call('zrem', KEYS[2], key); \"\n-                                  + \"local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(value), value); \"\n-                                  + \"redis.call('publish', KEYS[3], {key, value}); \"\n-                              + \"elseif accessTimeout ~= '-1' then \" \n-                                  + \"redis.call('zadd', KEYS[2], accessTimeout, key); \"\n-                              + \"end; \"\n+\n+                              + \"table.insert(result, value); \"\n                           + \"end; \"\n+                          + \"return result;\",\n+                    Arrays.<Object>asList(getName(), getTimeoutSetName(), getRemovedChannelName()), args.toArray());            \n+        }\n \n-                          + \"table.insert(result, value); \"\n-                      + \"end; \"\n-                      + \"return result;\",\n-                Arrays.<Object>asList(getName(), getTimeoutSetName(), getRemovedChannelName()), args.toArray());\n         \n         Map<K, V> result = new HashMap<K, V>();\n         for (Map.Entry<K, V> entry : res.entrySet()) {\n@@ -674,7 +760,7 @@ public boolean containsKey(K key) {\n             throw new NullPointerException();\n         }\n \n-        return evalWrite(getName(), codec, RedisCommands.EVAL_BOOLEAN,\n+        return evalRead(getName(), codec, RedisCommands.EVAL_BOOLEAN,\n                   \"if redis.call('hexists', KEYS[1], ARGV[2]) == 0 then \"\n                     + \"return 0;\"\n                 + \"end;\"\n@@ -729,7 +815,11 @@ public void run() {\n                                         throw new CacheLoaderException(ex);\n                                     }\n                                     if (value != null) {\n-                                        putValueLocked(key, value);\n+                                        if (v2) {\n+                                            putValue(key, value);\n+                                        } else {\n+                                            putValueLocked(key, value);\n+                                        }\n                                     }\n                                 }\n                             } finally {\n@@ -751,6 +841,10 @@ public void run() {\n     }\n     \n     private RLock getLockedLock(K key) {\n+        if (v2) {\n+            return DUMMY_LOCK;\n+        }\n+        \n         String lockName = getLockName(key);\n         RLock lock = redisson.getLock(lockName);\n         try {\n@@ -776,7 +870,12 @@ public void put(K key, V value) {\n         if (config.isWriteThrough()) {\n             RLock lock = getLockedLock(key);\n             try {\n-                List<Object> result = getAndPutValueLocked(key, value);\n+                List<Object> result;\n+                if (v2) {\n+                    result = getAndPutValue(key, value);\n+                } else {\n+                    result = getAndPutValueLocked(key, value);\n+                }\n                 if (result.isEmpty()) {\n                     cacheManager.getStatBean(this).addPuts(1);\n                     cacheManager.getStatBean(this).addPutTime(currentNanoTime() - startTime);\n@@ -821,7 +920,12 @@ public void put(K key, V value) {\n         } else {\n             RLock lock = getLockedLock(key);\n             try {\n-                boolean result = putValueLocked(key, value);\n+                boolean result;\n+                if (v2) {\n+                    result = putValue(key, value);\n+                } else {\n+                    result = putValueLocked(key, value);\n+                }\n                 if (result) {\n                     cacheManager.getStatBean(this).addPuts(1);\n                 }\n@@ -988,7 +1092,12 @@ public V getAndPut(K key, V value) {\n         if (config.isWriteThrough()) {\n             RLock lock = getLockedLock(key);\n             try {\n-                List<Object> result = getAndPutValueLocked(key, value);\n+                List<Object> result;\n+                if (v2) {\n+                    result = getAndPutValue(key, value);\n+                } else {\n+                    result = getAndPutValueLocked(key, value);\n+                }\n                 if (result.isEmpty()) {\n                     cacheManager.getStatBean(this).addPuts(1);\n                     cacheManager.getStatBean(this).addMisses(1);\n@@ -1037,7 +1146,12 @@ public V getAndPut(K key, V value) {\n         } else {\n             RLock lock = getLockedLock(key);\n             try {\n-                List<Object> result = getAndPutValueLocked(key, value);\n+                List<Object> result;\n+                if (v2) {\n+                    result = getAndPutValue(key, value);\n+                } else {\n+                    result = getAndPutValueLocked(key, value);\n+                }\n                 return getAndPutResult(startTime, result);\n             } finally {\n                 lock.unlock();\n@@ -1190,7 +1304,12 @@ public boolean putIfAbsent(K key, V value) {\n         if (config.isWriteThrough()) {\n             RLock lock = getLockedLock(key);\n             try {\n-                boolean result = putIfAbsentValueLocked(key, value);\n+                boolean result;\n+                if (v2) {\n+                    result = putIfAbsentValue(key, value);\n+                } else {\n+                    result = putIfAbsentValueLocked(key, value);\n+                }\n                 if (result) {\n                     cacheManager.getStatBean(this).addPuts(1);\n                     try {\n@@ -1211,7 +1330,12 @@ public boolean putIfAbsent(K key, V value) {\n         } else {\n             RLock lock = getLockedLock(key);\n             try {\n-                boolean result = putIfAbsentValueLocked(key, value);\n+                boolean result;\n+                if (v2) {\n+                    result = putIfAbsentValue(key, value);\n+                } else {\n+                    result = putIfAbsentValueLocked(key, value);\n+                }\n                 if (result) {\n                     cacheManager.getStatBean(this).addPuts(1);\n                 }\n@@ -1271,8 +1395,7 @@ public boolean remove(K key) {\n         if (config.isWriteThrough()) {\n             RLock lock = getLockedLock(key);\n             try {\n-                V oldValue = getValue(key);\n-                boolean result = removeValue(key);\n+                V oldValue = getAndRemoveValue(key);\n                 try {\n                     cacheWriter.delete(key);\n                 } catch (CacheWriterException e) {\n@@ -1286,11 +1409,11 @@ public boolean remove(K key) {\n                     }\n                     throw new CacheWriterException(e);\n                 }\n-                if (result) {\n+                if (oldValue != null) {\n                     cacheManager.getStatBean(this).addRemovals(1);\n                 }\n                 cacheManager.getStatBean(this).addRemoveTime(currentNanoTime() - startTime);\n-                return result;\n+                return oldValue != null;\n             } finally {\n                 lock.unlock();\n             }\n@@ -1412,7 +1535,11 @@ public boolean remove(K key, V value) {\n         if (config.isWriteThrough()) {\n             RLock lock = getLockedLock(key);\n             try {\n-                result = removeValueLocked(key, value);\n+                if (v2) {\n+                    result = removeValue(key, value);\n+                } else {\n+                    result = removeValueLocked(key, value);\n+                }\n                 if (result) {\n                     try {\n                         cacheWriter.delete(key);\n@@ -1438,7 +1565,11 @@ public boolean remove(K key, V value) {\n         } else {\n             RLock lock = getLockedLock(key);\n             try {\n-                result = removeValueLocked(key, value);\n+                if (v2) {\n+                    result = removeValue(key, value);\n+                } else {\n+                    result = removeValueLocked(key, value);\n+                }\n                 if (result) {\n                     cacheManager.getStatBean(this).addHits(1);\n                     cacheManager.getStatBean(this).addRemovals(1);\n@@ -1707,7 +1838,12 @@ public boolean replace(K key, V oldValue, V newValue) {\n         if (config.isWriteThrough()) {\n             RLock lock = getLockedLock(key);\n             try {\n-                long result = replaceValueLocked(key, oldValue, newValue);\n+                long result;\n+                if (v2) {\n+                    result = replaceValue(key, oldValue, newValue);\n+                } else {\n+                    result = replaceValueLocked(key, oldValue, newValue);\n+                }\n                 if (result == 1) {\n                     try {\n                         cacheWriter.write(new JCacheEntry<K, V>(key, newValue));\n@@ -1739,7 +1875,12 @@ public boolean replace(K key, V oldValue, V newValue) {\n         } else {\n             RLock lock = getLockedLock(key);\n             try {\n-                long result = replaceValueLocked(key, oldValue, newValue);\n+                long result;\n+                if (v2) {\n+                    result = replaceValue(key, oldValue, newValue);\n+                } else {\n+                    result = replaceValueLocked(key, oldValue, newValue);\n+                }\n                 if (result == 1) {\n                     cacheManager.getStatBean(this).addHits(1);\n                     cacheManager.getStatBean(this).addPuts(1);\n@@ -1950,7 +2091,12 @@ public boolean replace(K key, V value) {\n         if (config.isWriteThrough()) {\n             RLock lock = getLockedLock(key);\n             try {\n-                boolean result = replaceValueLocked(key, value);\n+                boolean result;\n+                if (v2) {\n+                    result = replaceValue(key, value);\n+                } else {\n+                    result = replaceValueLocked(key, value);\n+                }\n                 if (result) {\n                     cacheManager.getStatBean(this).addHits(1);\n                     cacheManager.getStatBean(this).addPuts(1);\n@@ -1974,7 +2120,12 @@ public boolean replace(K key, V value) {\n         } else {\n             RLock lock = getLockedLock(key);\n             try {\n-                boolean result = replaceValueLocked(key, value);\n+                boolean result;\n+                if (v2) {\n+                    result = replaceValue(key, value);\n+                } else {\n+                    result = replaceValueLocked(key, value);\n+                }\n                 if (result) {\n                     cacheManager.getStatBean(this).addHits(1);\n                     cacheManager.getStatBean(this).addPuts(1);\n@@ -2003,7 +2154,12 @@ public V getAndReplace(K key, V value) {\n         if (config.isWriteThrough()) {\n             RLock lock = getLockedLock(key);\n             try {\n-                V result = getAndReplaceValueLocked(key, value);\n+                V result;\n+                if (v2) {\n+                    result = getAndReplaceValue(key, value);\n+                } else {\n+                    result = getAndReplaceValueLocked(key, value);\n+                }\n                 if (result != null) {\n                     cacheManager.getStatBean(this).addHits(1);\n                     cacheManager.getStatBean(this).addPuts(1);\n@@ -2028,7 +2184,12 @@ public V getAndReplace(K key, V value) {\n         } else {\n             RLock lock = getLockedLock(key);\n             try {\n-                V result = getAndReplaceValueLocked(key, value);\n+                V result;\n+                if (v2) {\n+                    result = getAndReplaceValue(key, value);\n+                } else {\n+                    result = getAndReplaceValueLocked(key, value);\n+                }\n                 if (result != null) {\n                     cacheManager.getStatBean(this).addHits(1);\n                     cacheManager.getStatBean(this).addPuts(1);",
      "parent_sha": "182e377b9032fd61a061428ef079e19476e52a5c"
    }
  },
  {
    "oid": "bc176f30108ac7b96194dd6ebcf8faf9401de7f1",
    "message": "Improvement - read-only cached scripts should be executed on slaves (supported only by Redis 7.0+). #4040",
    "date": "2022-02-03T08:09:33Z",
    "url": "https://github.com/redisson/redisson/commit/bc176f30108ac7b96194dd6ebcf8faf9401de7f1",
    "details": {
      "sha": "c9b7fface7836265c26a9a40be50ea791c672ec3",
      "filename": "redisson/src/main/java/org/redisson/command/CommandAsyncService.java",
      "status": "modified",
      "additions": 18,
      "deletions": 12,
      "changes": 30,
      "blob_url": "https://github.com/redisson/redisson/blob/bc176f30108ac7b96194dd6ebcf8faf9401de7f1/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcommand%2FCommandAsyncService.java",
      "raw_url": "https://github.com/redisson/redisson/raw/bc176f30108ac7b96194dd6ebcf8faf9401de7f1/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcommand%2FCommandAsyncService.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fcommand%2FCommandAsyncService.java?ref=bc176f30108ac7b96194dd6ebcf8faf9401de7f1",
      "patch": "@@ -46,6 +46,7 @@\n import java.util.Map.Entry;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.AtomicReference;\n@@ -482,17 +483,24 @@ private Object[] copy(Object[] params) {\n         }\n         return result.toArray();\n     }\n+\n+    private AtomicBoolean evalShaROSupported = new AtomicBoolean(true);\n     \n     private <T, R> RFuture<R> evalAsync(NodeSource nodeSource, boolean readOnlyMode, Codec codec, RedisCommand<T> evalCommandType,\n                                         String script, List<Object> keys, boolean noRetry, Object... params) {\n         if (isEvalCacheActive() && evalCommandType.getName().equals(\"EVAL\")) {\n             CompletableFuture<R> mainPromise = new CompletableFuture<>();\n             \n             Object[] pps = copy(params);\n-            \n+\n             CompletableFuture<R> promise = new CompletableFuture<>();\n             String sha1 = calcSHA(script);\n-            RedisCommand cmd = new RedisCommand(evalCommandType, \"EVALSHA\");\n+            RedisCommand cmd;\n+            if (readOnlyMode && evalShaROSupported.get()) {\n+                cmd = new RedisCommand(evalCommandType, \"EVALSHA_RO\");\n+            } else {\n+                cmd = new RedisCommand(evalCommandType, \"EVALSHA\");\n+            }\n             List<Object> args = new ArrayList<Object>(2 + keys.size() + params.length);\n             args.add(sha1);\n             args.add(keys.size());\n@@ -506,7 +514,12 @@ private <T, R> RFuture<R> evalAsync(NodeSource nodeSource, boolean readOnlyMode,\n \n             promise.whenComplete((res, e) -> {\n                 if (e != null) {\n-                    if (e.getMessage().startsWith(\"NOSCRIPT\")) {\n+                    if (e.getMessage().startsWith(\"ERR unknown command\")) {\n+                        evalShaROSupported.set(false);\n+                        free(pps);\n+                        RFuture<R> future = evalAsync(nodeSource, readOnlyMode, codec, evalCommandType, script, keys, noRetry, params);\n+                        transfer(future.toCompletableFuture(), mainPromise);\n+                    } else if (e.getMessage().startsWith(\"NOSCRIPT\")) {\n                         RFuture<String> loadFuture = loadScript(executor.getRedisClient(), script);\n                         loadFuture.whenComplete((r, ex) -> {\n                             if (ex != null) {\n@@ -515,7 +528,6 @@ private <T, R> RFuture<R> evalAsync(NodeSource nodeSource, boolean readOnlyMode,\n                                 return;\n                             }\n \n-                            RedisCommand command = new RedisCommand(evalCommandType, \"EVALSHA\");\n                             List<Object> newargs = new ArrayList<Object>(2 + keys.size() + params.length);\n                             newargs.add(sha1);\n                             newargs.add(keys.size());\n@@ -527,14 +539,8 @@ private <T, R> RFuture<R> evalAsync(NodeSource nodeSource, boolean readOnlyMode,\n                                 ns = new NodeSource(nodeSource, executor.getRedisClient());\n                             }\n \n-                            RFuture<R> future = async(readOnlyMode, ns, codec, command, newargs.toArray(), false, noRetry);\n-                            future.whenComplete((re, ex\u0441) -> {\n-                                if (ex\u0441 != null) {\n-                                    mainPromise.completeExceptionally(ex\u0441);\n-                                } else {\n-                                    mainPromise.complete(re);\n-                                }\n-                            });\n+                            RFuture<R> future = async(readOnlyMode, ns, codec, cmd, newargs.toArray(), false, noRetry);\n+                            transfer(future.toCompletableFuture(), mainPromise);\n                         });\n                     } else {\n                         free(pps);",
      "parent_sha": "95b19f1695c6937a17f4a5fca58ab91e4cea5f19"
    }
  },
  {
    "oid": "02440366b3a4236edcb1724a9470aed80473c211",
    "message": "refactoring",
    "date": "2024-02-07T10:38:02Z",
    "url": "https://github.com/redisson/redisson/commit/02440366b3a4236edcb1724a9470aed80473c211",
    "details": {
      "sha": "c83052d82c5b2a48b81cc540be0cec7bb2232794",
      "filename": "redisson/src/main/java/org/redisson/pubsub/PublishSubscribeService.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/02440366b3a4236edcb1724a9470aed80473c211/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fpubsub%2FPublishSubscribeService.java",
      "raw_url": "https://github.com/redisson/redisson/raw/02440366b3a4236edcb1724a9470aed80473c211/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fpubsub%2FPublishSubscribeService.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fpubsub%2FPublishSubscribeService.java?ref=02440366b3a4236edcb1724a9470aed80473c211",
      "patch": "@@ -561,7 +561,7 @@ public void remove(MasterSlaveEntry entry) {\n         });\n     }\n \n-    public CompletableFuture<Codec> unsubscribe(ChannelName channelName, MasterSlaveEntry e, PubSubType topicType) {\n+    CompletableFuture<Codec> unsubscribe(ChannelName channelName, MasterSlaveEntry e, PubSubType topicType) {\n         if (connectionManager.getServiceManager().isShuttingDown()) {\n             return CompletableFuture.completedFuture(null);\n         }",
      "parent_sha": "1b8d4003b40c7605d0317c875dc6e66cc9948cc2"
    }
  },
  {
    "oid": "fc0f4afc25327a55d88a953eee6c2005c51b912a",
    "message": "WriteRedisConnectionException should extends RedisConnectionException",
    "date": "2018-05-12T14:09:45Z",
    "url": "https://github.com/redisson/redisson/commit/fc0f4afc25327a55d88a953eee6c2005c51b912a",
    "details": {
      "sha": "1c2faa34b94fac288652a5ad0cce96ce2078bd8f",
      "filename": "redisson/src/main/java/org/redisson/client/WriteRedisConnectionException.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/fc0f4afc25327a55d88a953eee6c2005c51b912a/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2FWriteRedisConnectionException.java",
      "raw_url": "https://github.com/redisson/redisson/raw/fc0f4afc25327a55d88a953eee6c2005c51b912a/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2FWriteRedisConnectionException.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2FWriteRedisConnectionException.java?ref=fc0f4afc25327a55d88a953eee6c2005c51b912a",
      "patch": "@@ -20,7 +20,7 @@\n  * @author Nikita Koksharov\n  *\n  */\n-public class WriteRedisConnectionException extends RedisException {\n+public class WriteRedisConnectionException extends RedisConnectionException {\n \n     private static final long serialVersionUID = -4756928186967834601L;\n ",
      "parent_sha": "dc6649301bce4006b2b63e06131a45d8db52e837"
    }
  },
  {
    "oid": "e1746b4b00061139273c0ae066bb483f5441433a",
    "message": "Connection pool error msg details added",
    "date": "2016-01-18T12:37:17Z",
    "url": "https://github.com/redisson/redisson/commit/e1746b4b00061139273c0ae066bb483f5441433a",
    "details": {
      "sha": "74d2987cc097cf91a2704d06038f1b6e2e2cfd1d",
      "filename": "src/main/java/org/redisson/misc/ConnectionPool.java",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/redisson/redisson/blob/e1746b4b00061139273c0ae066bb483f5441433a/src%2Fmain%2Fjava%2Forg%2Fredisson%2Fmisc%2FConnectionPool.java",
      "raw_url": "https://github.com/redisson/redisson/raw/e1746b4b00061139273c0ae066bb483f5441433a/src%2Fmain%2Fjava%2Forg%2Fredisson%2Fmisc%2FConnectionPool.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/src%2Fmain%2Fjava%2Forg%2Fredisson%2Fmisc%2FConnectionPool.java?ref=e1746b4b00061139273c0ae066bb483f5441433a",
      "patch": "@@ -65,7 +65,7 @@ public void operationComplete(Future<Void> future) throws Exception {\n     }\n \n     private void initConnections(final ClientConnectionsEntry entry, final Promise<Void> initPromise, boolean checkFreezed) {\n-        int minimumIdleSize = getMinimumIdleSize(entry);\n+        final int minimumIdleSize = getMinimumIdleSize(entry);\n \n         if (minimumIdleSize == 0 || (checkFreezed && entry.isFreezed())) {\n             initPromise.setSuccess(null);\n@@ -76,7 +76,7 @@ private void initConnections(final ClientConnectionsEntry entry, final Promise<V\n         for (int i = 0; i < minimumIdleSize; i++) {\n             if ((checkFreezed && entry.isFreezed()) || !tryAcquireConnection(entry)) {\n                 Throwable cause = new RedisConnectionException(\n-                        \"Can't init enough connections amount! \" + initializedConnections.get() + \" from \" + minimumIdleSize + \" was initialized. Server: \"\n+                        \"Can't init enough connections amount! Only \" + initializedConnections.get() + \" from \" + minimumIdleSize + \" were initialized. Server: \"\n                                             + entry.getClient().getAddr());\n                 initPromise.tryFailure(cause);\n                 return;\n@@ -92,7 +92,9 @@ public void operationComplete(Future<T> future) throws Exception {\n                     }\n                     releaseConnection(entry);\n                     if (!future.isSuccess()) {\n-                        Throwable cause = new RedisConnectionException(\"Can't init enough connections amount! from \" + entry.getClient().getAddr());\n+                        Throwable cause = new RedisConnectionException(\n+                                \"Can't init enough connections amount! Only \" + initializedConnections.get() + \" from \" + minimumIdleSize + \" were initialized. Server: \"\n+                                                    + entry.getClient().getAddr(), future.cause());\n                         initPromise.tryFailure(cause);\n                         return;\n                     }",
      "parent_sha": "ea0db454f3970ee43c4692a3cf8d2b22551bfc6c"
    }
  },
  {
    "oid": "6581423778e85e43676083dd3f9eb3b4fd1d8db2",
    "message": "Reduced strings cache size to 10000\n\nSigned-off-by: tomerarazy <tomerarazy@gmail.com>",
    "date": "2023-08-12T08:39:25Z",
    "url": "https://github.com/redisson/redisson/commit/6581423778e85e43676083dd3f9eb3b4fd1d8db2",
    "details": {
      "sha": "7d440998be2a1f48de84bcf62aa86940cd345805",
      "filename": "redisson/src/main/java/org/redisson/client/handler/CommandEncoder.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/6581423778e85e43676083dd3f9eb3b4fd1d8db2/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fhandler%2FCommandEncoder.java",
      "raw_url": "https://github.com/redisson/redisson/raw/6581423778e85e43676083dd3f9eb3b4fd1d8db2/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fhandler%2FCommandEncoder.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fhandler%2FCommandEncoder.java?ref=6581423778e85e43676083dd3f9eb3b4fd1d8db2",
      "patch": "@@ -63,7 +63,7 @@ public class CommandEncoder extends MessageToByteEncoder<CommandData<?, ?>> {\n     private static final char BYTES_PREFIX = '$';\n     private static final byte[] CRLF = \"\\r\\n\".getBytes();\n \n-    private static final Integer STRING_CACHE_SIZE = 100_000;\n+    private static final Integer STRING_CACHE_SIZE = 10_000;\n \n     private static final List<byte[]> LONG_TO_STRING_CACHE = LongStream.range(0, STRING_CACHE_SIZE)\n         .mapToObj(Long::toString)",
      "parent_sha": "d84d9f61f7e0bf785f83f2be278330c8476bd866"
    }
  },
  {
    "oid": "f27e931cde7fc969b6b05eca552305dc59003881",
    "message": "Fixed - result of RStream.read() method isn't sorted by key #3137",
    "date": "2020-10-19T08:48:56Z",
    "url": "https://github.com/redisson/redisson/commit/f27e931cde7fc969b6b05eca552305dc59003881",
    "details": {
      "sha": "091b2f7eacdc9488c1f1906caf2638a159dd2ff7",
      "filename": "redisson/src/main/java/org/redisson/client/protocol/decoder/StreamResultDecoder.java",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/redisson/redisson/blob/f27e931cde7fc969b6b05eca552305dc59003881/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fprotocol%2Fdecoder%2FStreamResultDecoder.java",
      "raw_url": "https://github.com/redisson/redisson/raw/f27e931cde7fc969b6b05eca552305dc59003881/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fprotocol%2Fdecoder%2FStreamResultDecoder.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fclient%2Fprotocol%2Fdecoder%2FStreamResultDecoder.java?ref=f27e931cde7fc969b6b05eca552305dc59003881",
      "patch": "@@ -15,14 +15,15 @@\n  */\n package org.redisson.client.protocol.decoder;\n \n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n import org.redisson.api.StreamMessageId;\n import org.redisson.client.handler.State;\n import org.redisson.client.protocol.Decoder;\n \n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n /**\n  * \n  * @author Nikita Koksharov\n@@ -45,7 +46,7 @@ public Object decode(List<Object> parts, State state) {\n             List<List<Object>> streamEntries = (List<List<Object>>) entries.get(1);\n             if (!streamEntries.isEmpty()) {\n                 String name = (String) entries.get(0);\n-                Map<StreamMessageId, Map<Object, Object>> ee = new HashMap<>();\n+                Map<StreamMessageId, Map<Object, Object>> ee = new LinkedHashMap<>();\n                 result.put(name, ee);\n                 \n                 for (List<Object> se : streamEntries) {",
      "parent_sha": "553553a711a039f6d0e191c72f2141529b7bb467"
    }
  },
  {
    "oid": "853a0c2803c16df30e2d398b81fe297ca67a6637",
    "message": "CommandBatchExecutorService timeout handling improvements",
    "date": "2015-11-20T11:38:03Z",
    "url": "https://github.com/redisson/redisson/commit/853a0c2803c16df30e2d398b81fe297ca67a6637",
    "details": {
      "sha": "e68e8511853e34d01128b18b98a8d579c97d5a70",
      "filename": "src/main/java/org/redisson/CommandBatchExecutorService.java",
      "status": "modified",
      "additions": 51,
      "deletions": 19,
      "changes": 70,
      "blob_url": "https://github.com/redisson/redisson/blob/853a0c2803c16df30e2d398b81fe297ca67a6637/src%2Fmain%2Fjava%2Forg%2Fredisson%2FCommandBatchExecutorService.java",
      "raw_url": "https://github.com/redisson/redisson/raw/853a0c2803c16df30e2d398b81fe297ca67a6637/src%2Fmain%2Fjava%2Forg%2Fredisson%2FCommandBatchExecutorService.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/src%2Fmain%2Fjava%2Forg%2Fredisson%2FCommandBatchExecutorService.java?ref=853a0c2803c16df30e2d398b81fe297ca67a6637",
      "patch": "@@ -32,9 +32,11 @@\n import org.redisson.client.RedisTimeoutException;\n import org.redisson.client.WriteRedisConnectionException;\n import org.redisson.client.codec.Codec;\n+import org.redisson.client.codec.StringCodec;\n import org.redisson.client.protocol.CommandData;\n import org.redisson.client.protocol.CommandsData;\n import org.redisson.client.protocol.RedisCommand;\n+import org.redisson.client.protocol.RedisCommands;\n import org.redisson.client.protocol.decoder.MultiDecoder;\n import org.redisson.connection.ConnectionManager;\n import org.redisson.connection.NodeSource;\n@@ -207,7 +209,10 @@ public void execute(final Entry entry, final NodeSource source, final Promise<Vo\n         }\n \n         final Promise<Void> attemptPromise = connectionManager.newPromise();\n-        final AtomicReference<RedisException> ex = new AtomicReference<RedisException>();\n+\n+        final AtomicReference<ChannelFuture> writeFutureRef = new AtomicReference<ChannelFuture>();\n+        final AtomicReference<RedisException> exceptionRef = new AtomicReference<RedisException>();\n+        final AtomicReference<Timeout> timeoutRef = new AtomicReference<Timeout>();\n \n         final Future<RedisConnection> connectionFuture;\n         if (entry.isReadOnlyMode()) {\n@@ -223,6 +228,17 @@ public void run(Timeout timeout) throws Exception {\n                     connectionManager.getShutdownLatch().release();\n                 }\n \n+                if ((writeFutureRef.get() == null || !writeFutureRef.get().isDone())\n+                        && connectionFuture.isSuccess()) {\n+                    Timeout newTimeout = connectionManager.newTimeout(this, connectionManager.getConfig().getRetryInterval(), TimeUnit.MILLISECONDS);\n+                    timeoutRef.set(newTimeout);\n+                    return;\n+                }\n+\n+                if (writeFutureRef.get() != null && writeFutureRef.get().isSuccess()) {\n+                    return;\n+                }\n+\n                 if (attemptPromise.isDone()) {\n                     return;\n                 }\n@@ -233,7 +249,7 @@ public void run(Timeout timeout) throws Exception {\n                 }\n \n                 if (attempt == connectionManager.getConfig().getRetryAttempts()) {\n-                    attemptPromise.tryFailure(ex.get());\n+                    attemptPromise.tryFailure(exceptionRef.get());\n                     return;\n                 }\n                 if (!attemptPromise.cancel(false)) {\n@@ -245,8 +261,7 @@ public void run(Timeout timeout) throws Exception {\n             }\n         };\n \n-        ex.set(new RedisTimeoutException(\"Batch command execution timeout\"));\n-        final AtomicReference<Timeout> timeoutRef = new AtomicReference<Timeout>();\n+        exceptionRef.set(new RedisTimeoutException(\"Batch command execution timeout\"));\n         Timeout timeout = connectionManager.newTimeout(retryTimerTask, connectionManager.getConfig().getTimeout(), TimeUnit.MILLISECONDS);\n         timeoutRef.set(timeout);\n \n@@ -256,35 +271,52 @@ public void operationComplete(Future<RedisConnection> connFuture) throws Excepti\n                 if (attemptPromise.isDone() || connFuture.isCancelled() || mainPromise.isCancelled()) {\n                     return;\n                 }\n+\n                 if (!connFuture.isSuccess()) {\n-                    ex.set(convertException(connFuture));\n-                    if (timeoutRef.get().cancel()) {\n-                        connectionManager.newTimeout(retryTimerTask, connectionManager.getConfig().getRetryInterval(), TimeUnit.MILLISECONDS);\n-                    }\n+                    exceptionRef.set(convertException(connFuture));\n                     return;\n                 }\n \n                 RedisConnection connection = connFuture.getNow();\n \n-                List<CommandData<?, ?>> list = new ArrayList<CommandData<?, ?>>(entry.getCommands().size());\n-                for (CommandEntry c : entry.getCommands()) {\n-                    list.add(c.getCommand());\n+\n+                if (source.getRedirect() == Redirect.ASK) {\n+                    List<CommandData<?, ?>> list = new ArrayList<CommandData<?, ?>>(entry.getCommands().size() + 1);\n+                    Promise<Void> promise = connectionManager.newPromise();\n+                    list.add(new CommandData<Void, Void>(promise, StringCodec.INSTANCE, RedisCommands.ASKING, new Object[] {}));\n+                    for (CommandEntry c : entry.getCommands()) {\n+                        list.add(c.getCommand());\n+                    }\n+                    ChannelFuture future = connection.send(new CommandsData(attemptPromise, list));\n+                    writeFutureRef.set(future);\n+                } else {\n+                    List<CommandData<?, ?>> list = new ArrayList<CommandData<?, ?>>(entry.getCommands().size());\n+                    for (CommandEntry c : entry.getCommands()) {\n+                        list.add(c.getCommand());\n+                    }\n+                    ChannelFuture future = connection.send(new CommandsData(attemptPromise, list));\n+                    writeFutureRef.set(future);\n                 }\n-                ChannelFuture writeFuture = connection.send(new CommandsData(attemptPromise, list));\n \n \n-                writeFuture.addListener(new ChannelFutureListener() {\n+                writeFutureRef.get().addListener(new ChannelFutureListener() {\n                     @Override\n                     public void operationComplete(ChannelFuture future) throws Exception {\n-                        if (attemptPromise.isDone() || future.isCancelled() || mainPromise.isCancelled()) {\n+                        if (attemptPromise.isDone() || mainPromise.isCancelled()) {\n                             return;\n                         }\n-\n                         if (!future.isSuccess()) {\n-                            ex.set(new WriteRedisConnectionException(\"Can't write commands batch to channel: \" + future.channel(), future.cause()));\n-                            if (timeoutRef.get().cancel()) {\n-                                connectionManager.newTimeout(retryTimerTask, connectionManager.getConfig().getRetryInterval(), TimeUnit.MILLISECONDS);\n-                            }\n+                            exceptionRef.set(new WriteRedisConnectionException(\"Can't write commands batch to channel: \" + future.channel(), future.cause()));\n+                        } else {\n+                            timeoutRef.get().cancel();\n+                            TimerTask timeoutTask = new TimerTask() {\n+                                @Override\n+                                public void run(Timeout timeout) throws Exception {\n+                                    attemptPromise.tryFailure(exceptionRef.get());\n+                                }\n+                            };\n+                            Timeout timeout = connectionManager.newTimeout(timeoutTask, connectionManager.getConfig().getTimeout(), TimeUnit.MILLISECONDS);\n+                            timeoutRef.set(timeout);\n                         }\n                     }\n                 });",
      "parent_sha": "4066886eddd81830a1c50c174b172427211c800a"
    }
  },
  {
    "oid": "7f37ae46709a6382bb7bca53915bba81e05b2bb0",
    "message": "refactoring",
    "date": "2020-01-17T07:06:32Z",
    "url": "https://github.com/redisson/redisson/commit/7f37ae46709a6382bb7bca53915bba81e05b2bb0",
    "details": {
      "sha": "819b5152c965a8297668128489e930e665999d83",
      "filename": "redisson/src/main/java/org/redisson/RedissonSemaphore.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/redisson/redisson/blob/7f37ae46709a6382bb7bca53915bba81e05b2bb0/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonSemaphore.java",
      "raw_url": "https://github.com/redisson/redisson/raw/7f37ae46709a6382bb7bca53915bba81e05b2bb0/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonSemaphore.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonSemaphore.java?ref=7f37ae46709a6382bb7bca53915bba81e05b2bb0",
      "patch": "@@ -461,8 +461,7 @@ public RFuture<Integer> drainPermitsAsync() {\n \n     @Override\n     public int availablePermits() {\n-        RFuture<Integer> future = commandExecutor.writeAsync(getName(), LongCodec.INSTANCE, RedisCommands.GET_INTEGER, getName());\n-        return get(future);\n+        return get(availablePermitsAsync());\n     }\n \n     @Override",
      "parent_sha": "8dd6da867a4e7c148be902ad45c5d9945e31374a"
    }
  },
  {
    "oid": "1449ec00e28002b10e8bc563a12f7746f978c571",
    "message": "Fixed - RRemoteService may cause CPU spike after Master failover",
    "date": "2024-02-27T07:56:11Z",
    "url": "https://github.com/redisson/redisson/commit/1449ec00e28002b10e8bc563a12f7746f978c571",
    "details": {
      "sha": "742f589ac6afcaec6e89cd503aba0620e09151e5",
      "filename": "redisson/src/main/java/org/redisson/RedissonRemoteService.java",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/redisson/redisson/blob/1449ec00e28002b10e8bc563a12f7746f978c571/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonRemoteService.java",
      "raw_url": "https://github.com/redisson/redisson/raw/1449ec00e28002b10e8bc563a12f7746f978c571/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonRemoteService.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonRemoteService.java?ref=1449ec00e28002b10e8bc563a12f7746f978c571",
      "patch": "@@ -247,7 +247,10 @@ private <T> void subscribe(Class<T> remoteInterface, RBlockingQueue<String> requ\n                     }\n                     log.error(\"Can't process the remote service request.\", e);\n                     // re-subscribe after a failed takeAsync\n-                    subscribe(remoteInterface, requestQueue, executor, bean);\n+                    commandExecutor.getServiceManager().newTimeout(task -> {\n+                        subscribe(remoteInterface, requestQueue, executor, bean);\n+                    }, commandExecutor.getServiceManager().getConfig().getRetryInterval(), TimeUnit.MILLISECONDS);\n+\n                     return;\n                 }\n ",
      "parent_sha": "844d342d0f41196a28fa7ee81106ccaa3e366353"
    }
  },
  {
    "oid": "1ef3bb82e3fb042463515ac60bcbc0aff76da11c",
    "message": "refactoring",
    "date": "2024-04-01T07:40:15Z",
    "url": "https://github.com/redisson/redisson/commit/1ef3bb82e3fb042463515ac60bcbc0aff76da11c",
    "details": {
      "sha": "7f71adae151bae94416e7b4e92621c78a04918ca",
      "filename": "redisson/src/main/java/org/redisson/Redisson.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/redisson/redisson/blob/1ef3bb82e3fb042463515ac60bcbc0aff76da11c/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedisson.java",
      "raw_url": "https://github.com/redisson/redisson/raw/1ef3bb82e3fb042463515ac60bcbc0aff76da11c/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedisson.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedisson.java?ref=1ef3bb82e3fb042463515ac60bcbc0aff76da11c",
      "patch": "@@ -15,17 +15,16 @@\n  */\n package org.redisson;\n \n-import org.redisson.api.*;\n import org.redisson.api.ExecutorOptions;\n import org.redisson.api.LocalCachedMapOptions;\n import org.redisson.api.MapCacheOptions;\n import org.redisson.api.MapOptions;\n+import org.redisson.api.*;\n import org.redisson.api.options.*;\n import org.redisson.api.redisnode.*;\n import org.redisson.client.codec.Codec;\n import org.redisson.codec.JsonCodec;\n import org.redisson.command.CommandAsyncExecutor;\n-import org.redisson.command.CommandAsyncService;\n import org.redisson.config.Config;\n import org.redisson.config.ConfigSupport;\n import org.redisson.connection.ConnectionManager;",
      "parent_sha": "962e38ce8cb14fa55bd5f02e5d194a2e9c4f0bfe"
    }
  },
  {
    "oid": "ead4eae3420dfbd1ba9dd90be8ba57a3ce585a62",
    "message": "Redisson node failover test added. #1622",
    "date": "2018-09-08T10:28:50Z",
    "url": "https://github.com/redisson/redisson/commit/ead4eae3420dfbd1ba9dd90be8ba57a3ce585a62",
    "details": {
      "sha": "0b1379f8007368bddcc958e89f6d747c105479c5",
      "filename": "redisson/src/test/java/org/redisson/executor/RedissonExecutorServiceTest.java",
      "status": "modified",
      "additions": 94,
      "deletions": 1,
      "changes": 95,
      "blob_url": "https://github.com/redisson/redisson/blob/ead4eae3420dfbd1ba9dd90be8ba57a3ce585a62/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2Fexecutor%2FRedissonExecutorServiceTest.java",
      "raw_url": "https://github.com/redisson/redisson/raw/ead4eae3420dfbd1ba9dd90be8ba57a3ce585a62/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2Fexecutor%2FRedissonExecutorServiceTest.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2Fexecutor%2FRedissonExecutorServiceTest.java?ref=ead4eae3420dfbd1ba9dd90be8ba57a3ce585a62",
      "patch": "@@ -21,13 +21,17 @@\n import org.junit.Before;\n import org.junit.Test;\n import org.redisson.BaseTest;\n+import org.redisson.RedisRunner;\n+import org.redisson.Redisson;\n import org.redisson.RedissonNode;\n import org.redisson.api.ExecutorOptions;\n import org.redisson.api.RExecutorBatchFuture;\n import org.redisson.api.RExecutorFuture;\n import org.redisson.api.RExecutorService;\n+import org.redisson.api.RedissonClient;\n import org.redisson.config.Config;\n import org.redisson.config.RedissonNodeConfig;\n+import org.redisson.connection.balancer.RandomLoadBalancer;\n \n import mockit.Invocation;\n import mockit.Mock;\n@@ -127,7 +131,96 @@ private void finish(Invocation invocation, String requestId) {\n     }\n     \n     @Test\n-    public void testTaskFailover() throws Exception {\n+    public void testFailoverInSentinel() throws Exception {\n+        RedisRunner.RedisProcess master = new RedisRunner()\n+                .nosave()\n+                .randomDir()\n+                .run();\n+        RedisRunner.RedisProcess slave1 = new RedisRunner()\n+                .port(6380)\n+                .nosave()\n+                .randomDir()\n+                .slaveof(\"127.0.0.1\", 6379)\n+                .run();\n+        RedisRunner.RedisProcess slave2 = new RedisRunner()\n+                .port(6381)\n+                .nosave()\n+                .randomDir()\n+                .slaveof(\"127.0.0.1\", 6379)\n+                .run();\n+        RedisRunner.RedisProcess sentinel1 = new RedisRunner()\n+                .nosave()\n+                .randomDir()\n+                .port(26379)\n+                .sentinel()\n+                .sentinelMonitor(\"myMaster\", \"127.0.0.1\", 6379, 2)\n+                .run();\n+        RedisRunner.RedisProcess sentinel2 = new RedisRunner()\n+                .nosave()\n+                .randomDir()\n+                .port(26380)\n+                .sentinel()\n+                .sentinelMonitor(\"myMaster\", \"127.0.0.1\", 6379, 2)\n+                .run();\n+        RedisRunner.RedisProcess sentinel3 = new RedisRunner()\n+                .nosave()\n+                .randomDir()\n+                .port(26381)\n+                .sentinel()\n+                .sentinelMonitor(\"myMaster\", \"127.0.0.1\", 6379, 2)\n+                .run();\n+        \n+        Thread.sleep(5000); \n+        \n+        Config config = new Config();\n+        config.useSentinelServers()\n+            .setLoadBalancer(new RandomLoadBalancer())\n+            .addSentinelAddress(sentinel3.getRedisServerAddressAndPort()).setMasterName(\"myMaster\");\n+        \n+        RedissonClient redisson = Redisson.create(config);\n+        \n+        RedissonNodeConfig nodeConfig = new RedissonNodeConfig(config);\n+        nodeConfig.setExecutorServiceWorkers(Collections.singletonMap(\"test2\", 1));\n+        node = RedissonNode.create(nodeConfig);\n+        node.start();\n+\n+        RExecutorService executor = redisson.getExecutorService(\"test2\", ExecutorOptions.defaults().taskRetryInterval(10, TimeUnit.SECONDS));\n+        for (int i = 0; i < 10; i++) {\n+            executor.submit(new DelayedTask(2000, \"counter\"));\n+        }\n+        Thread.sleep(2500);\n+        assertThat(redisson.getAtomicLong(\"counter\").get()).isEqualTo(1);\n+\n+        master.stop();\n+        System.out.println(\"master \" + master.getRedisServerAddressAndPort() + \" stopped!\");\n+        \n+        Thread.sleep(TimeUnit.SECONDS.toMillis(70));\n+        \n+        master = new RedisRunner()\n+                .port(master.getRedisServerPort())\n+                .nosave()\n+                .randomDir()\n+                .run();\n+\n+        System.out.println(\"master \" + master.getRedisServerAddressAndPort() + \" started!\");\n+        \n+        Thread.sleep(25000);\n+        \n+        assertThat(redisson.getAtomicLong(\"counter\").get()).isEqualTo(10);\n+        \n+        redisson.shutdown();\n+        node.shutdown();\n+        sentinel1.stop();\n+        sentinel2.stop();\n+        sentinel3.stop();\n+        master.stop();\n+        slave1.stop();\n+        slave2.stop();\n+    }\n+\n+    \n+    @Test\n+    public void testNodeFailover() throws Exception {\n         AtomicInteger counter = new AtomicInteger();\n         new MockUp<TasksRunnerService>() {\n             @Mock",
      "parent_sha": "52c33403a4434778910b66111ed72bedb67c54ff"
    }
  },
  {
    "oid": "b87634bcec6835afc7f0a72c1eae06a39a006863",
    "message": "refactoring",
    "date": "2022-01-28T09:20:09Z",
    "url": "https://github.com/redisson/redisson/commit/b87634bcec6835afc7f0a72c1eae06a39a006863",
    "details": {
      "sha": "544114920762cfa9df2c1d3a8d47953592d34988",
      "filename": "redisson/src/main/java/org/redisson/jcache/JCache.java",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/redisson/redisson/blob/b87634bcec6835afc7f0a72c1eae06a39a006863/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fjcache%2FJCache.java",
      "raw_url": "https://github.com/redisson/redisson/raw/b87634bcec6835afc7f0a72c1eae06a39a006863/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fjcache%2FJCache.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fjcache%2FJCache.java?ref=b87634bcec6835afc7f0a72c1eae06a39a006863",
      "patch": "@@ -520,22 +520,8 @@ private boolean putValueLocked(K key, Object value) {\n \n \n     RFuture<Long> putAllValues(Map<? extends K, ? extends V> map) {\n-        Long creationTimeout = getCreationTimeout();\n-        Long updateTimeout = getUpdateTimeout();\n-\n-        List<Object> params = new ArrayList<>();\n-        params.add(creationTimeout);\n-        params.add(updateTimeout);\n-        params.add(System.currentTimeMillis());\n         double syncId = ThreadLocalRandom.current().nextDouble();\n-        params.add(syncId);\n-\n-        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n-            params.add(encodeMapKey(entry.getKey()));\n-            params.add(encodeMapValue(entry.getValue()));\n-        }\n-\n-        RFuture<List<Object>> res = putAllOperation(commandExecutor, null, getRawName(), params);\n+        RFuture<List<Object>> res = putAllOperation(syncId, null, getRawName(), map);\n \n         RFuture<Long> result = handlePutAllResult(syncId, res);\n         return result;\n@@ -591,7 +577,21 @@ RFuture<Long> handlePutAllResult(double syncId, RFuture<List<Object>> res) {\n         return result;\n     }\n \n-    RFuture<List<Object>> putAllOperation(CommandAsyncExecutor commandExecutor, MasterSlaveEntry entry, String name, List<Object> params) {\n+    RFuture<List<Object>> putAllOperation(double syncId, MasterSlaveEntry msEntry, String name, Map<? extends K, ? extends V> map) {\n+        Long creationTimeout = getCreationTimeout();\n+        Long updateTimeout = getUpdateTimeout();\n+\n+        List<Object> params = new ArrayList<>();\n+        params.add(creationTimeout);\n+        params.add(updateTimeout);\n+        params.add(System.currentTimeMillis());\n+        params.add(syncId);\n+\n+        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+            params.add(encodeMapKey(entry.getKey()));\n+            params.add(encodeMapValue(entry.getValue()));\n+        }\n+\n         String script = \"local added = 0; \"\n             + \"local syncs = 0; \"\n             + \"for i = 5, #ARGV, 2 do \" +\n@@ -666,14 +666,14 @@ RFuture<List<Object>> putAllOperation(CommandAsyncExecutor commandExecutor, Mast\n           + \"end; \"\n           + \"return {added, syncs};\";\n \n-        if (entry == null) {\n+        if (msEntry == null) {\n             return commandExecutor.evalWriteAsync(name, codec, RedisCommands.EVAL_LIST, script,\n                     Arrays.asList(name, getTimeoutSetName(name), getCreatedChannelName(name), getRemovedChannelName(name), getUpdatedChannelName(name),\n                             getCreatedSyncChannelName(name), getRemovedSyncChannelName(name), getUpdatedSyncChannelName(name), getOldValueListenerCounter(name)),\n                     params.toArray());\n         }\n \n-        return commandExecutor.evalWriteAsync(entry, codec, RedisCommands.EVAL_LIST, script,\n+        return commandExecutor.evalWriteAsync(msEntry, codec, RedisCommands.EVAL_LIST, script,\n                     Arrays.asList(name, getTimeoutSetName(name), getCreatedChannelName(name), getRemovedChannelName(name), getUpdatedChannelName(name),\n                             getCreatedSyncChannelName(name), getRemovedSyncChannelName(name), getUpdatedSyncChannelName(name), getOldValueListenerCounter(name)),\n                     params.toArray());",
      "parent_sha": "31bf43b633a9734df5848e3f8c3ec0b017cda760"
    }
  },
  {
    "oid": "48619623cdfc726cd6630177fec68ea87d2a8c32",
    "message": "Fixed - CROSSLOT error thrown if RLiveObject got updated",
    "date": "2020-09-30T09:34:46Z",
    "url": "https://github.com/redisson/redisson/commit/48619623cdfc726cd6630177fec68ea87d2a8c32",
    "details": {
      "sha": "9c93e75b0a2b410ee4518dffd57483ed36430094",
      "filename": "redisson/src/main/java/org/redisson/liveobject/core/AccessorInterceptor.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/redisson/redisson/blob/48619623cdfc726cd6630177fec68ea87d2a8c32/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fliveobject%2Fcore%2FAccessorInterceptor.java",
      "raw_url": "https://github.com/redisson/redisson/raw/48619623cdfc726cd6630177fec68ea87d2a8c32/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fliveobject%2Fcore%2FAccessorInterceptor.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2Fliveobject%2Fcore%2FAccessorInterceptor.java?ref=48619623cdfc726cd6630177fec68ea87d2a8c32",
      "patch": "@@ -188,7 +188,8 @@ private void removeIndex(RMap<String, Object> liveMap, Object me, Field field) {\n             RScoredSortedSetAsync<Object> set = new RedissonScoredSortedSet<>(namingScheme.getCodec(), ce, indexName, null);\n             set.removeAsync(((RLiveObject) me).getLiveObjectId());\n         } else {\n-            if (ClassUtils.isAnnotationPresent(field.getType(), REntity.class)) {\n+            if (ClassUtils.isAnnotationPresent(field.getType(), REntity.class)\n+                    || connectionManager.isClusterMode()) {\n                 Object value = liveMap.remove(field.getName());\n                 RMultimapAsync<Object, Object> map = new RedissonSetMultimap<>(namingScheme.getCodec(), ce, indexName);\n                 map.removeAsync(((RLiveObject) value).getLiveObjectId(), ((RLiveObject) me).getLiveObjectId());",
      "parent_sha": "6c94b494e48c8fe4a55632093bc45d5e98ed8b9f"
    }
  },
  {
    "oid": "e8450f04340d0d3b4245f75a7dde0b9250f7203a",
    "message": "test added",
    "date": "2022-03-18T06:10:04Z",
    "url": "https://github.com/redisson/redisson/commit/e8450f04340d0d3b4245f75a7dde0b9250f7203a",
    "details": {
      "sha": "b5cace723970efe2f75f57c819726d8795737e65",
      "filename": "redisson/src/test/java/org/redisson/RedissonScriptTest.java",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/redisson/redisson/blob/e8450f04340d0d3b4245f75a7dde0b9250f7203a/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonScriptTest.java",
      "raw_url": "https://github.com/redisson/redisson/raw/e8450f04340d0d3b4245f75a7dde0b9250f7203a/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonScriptTest.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2FRedissonScriptTest.java?ref=e8450f04340d0d3b4245f75a7dde0b9250f7203a",
      "patch": "@@ -46,7 +46,14 @@ public void testMulti() {\n         assertThat(objs.get(1)).hasSize(15);\n         assertThat(objs.get(2)).hasSize(25);\n     }\n-    \n+\n+    @Test\n+    public void testString() {\n+        RScript script = redisson.getScript(StringCodec.INSTANCE);\n+        String res = script.eval(RScript.Mode.READ_ONLY, \"return 'hello'\", RScript.ReturnType.STATUS);\n+        assertThat(res).isEqualTo(\"hello\");\n+    }\n+\n     @Test\n     public void testEval() {\n         RScript script = redisson.getScript(StringCodec.INSTANCE);",
      "parent_sha": "afdd9ad9f64eb54559e754bb20d8df88c07964cb"
    }
  },
  {
    "oid": "e58405e2c20a0a1aa4f281a9419f9c97f9a7ecaf",
    "message": "Fixed - tryLockAsync and lockAsync methods of RedissonMultiLock object get hang #1939",
    "date": "2019-02-26T12:00:06Z",
    "url": "https://github.com/redisson/redisson/commit/e58405e2c20a0a1aa4f281a9419f9c97f9a7ecaf",
    "details": {
      "sha": "3ae8abaa249950c00b2a46b43b832b46036a869a",
      "filename": "redisson/src/main/java/org/redisson/RedissonMultiLock.java",
      "status": "modified",
      "additions": 148,
      "deletions": 136,
      "changes": 284,
      "blob_url": "https://github.com/redisson/redisson/blob/e58405e2c20a0a1aa4f281a9419f9c97f9a7ecaf/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonMultiLock.java",
      "raw_url": "https://github.com/redisson/redisson/raw/e58405e2c20a0a1aa4f281a9419f9c97f9a7ecaf/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonMultiLock.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonMultiLock.java?ref=e58405e2c20a0a1aa4f281a9419f9c97f9a7ecaf",
      "patch": "@@ -23,7 +23,6 @@\n import java.util.concurrent.ThreadLocalRandom;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.locks.Condition;\n import java.util.concurrent.locks.Lock;\n \n@@ -40,9 +39,154 @@\n  * @author Nikita Koksharov\n  *\n  */\n-@SuppressWarnings(\"ParameterNumber\")\n public class RedissonMultiLock implements Lock {\n \n+    class LockState {\n+        \n+        private final long newLeaseTime;\n+        private final long lockWaitTime;\n+        private final List<RLock> acquiredLocks;\n+        private final long waitTime;\n+        private final long threadId;\n+        private final long leaseTime;\n+        private final TimeUnit unit;\n+\n+        private long remainTime;\n+        private long time = System.currentTimeMillis();\n+        private int failedLocksLimit;\n+        \n+        LockState(long waitTime, long leaseTime, TimeUnit unit, long threadId) {\n+            this.waitTime = waitTime;\n+            this.leaseTime = leaseTime;\n+            this.unit = unit;\n+            this.threadId = threadId;\n+            \n+            if (leaseTime != -1) {\n+                newLeaseTime = unit.toMillis(waitTime)*2;\n+            } else {\n+                newLeaseTime = -1;\n+            }\n+            \n+            remainTime = -1;\n+            if (waitTime != -1) {\n+                remainTime = unit.toMillis(waitTime);\n+            }\n+            lockWaitTime = calcLockWaitTime(remainTime);\n+            \n+            failedLocksLimit = failedLocksLimit();\n+            acquiredLocks = new ArrayList<RLock>(locks.size());\n+        }\n+        \n+        void tryAcquireLockAsync(ListIterator<RLock> iterator, RPromise<Boolean> result) {\n+            if (!iterator.hasNext()) {\n+                checkLeaseTimeAsync(result);\n+                return;\n+            }\n+\n+            RLock lock = iterator.next();\n+            RPromise<Boolean> lockAcquiredFuture = new RedissonPromise<Boolean>();\n+            if (waitTime == -1 && leaseTime == -1) {\n+                lock.tryLockAsync(threadId)\n+                    .onComplete(new TransferListener<Boolean>(lockAcquiredFuture));\n+            } else {\n+                long awaitTime = Math.min(lockWaitTime, remainTime);\n+                lock.tryLockAsync(awaitTime, newLeaseTime, TimeUnit.MILLISECONDS, threadId)\n+                    .onComplete(new TransferListener<Boolean>(lockAcquiredFuture));\n+            }\n+            \n+            lockAcquiredFuture.onComplete((res, e) -> {\n+                boolean lockAcquired = false;\n+                if (res != null) {\n+                    lockAcquired = res;\n+                }\n+\n+                if (e instanceof RedisResponseTimeoutException) {\n+                    unlockInnerAsync(Arrays.asList(lock), threadId);\n+                }\n+                \n+                if (lockAcquired) {\n+                    acquiredLocks.add(lock);\n+                } else {\n+                    if (locks.size() - acquiredLocks.size() == failedLocksLimit()) {\n+                        checkLeaseTimeAsync(result);\n+                        return;\n+                    }\n+\n+                    if (failedLocksLimit == 0) {\n+                        unlockInnerAsync(acquiredLocks, threadId).onComplete((r, ex) -> {\n+                            if (ex != null) {\n+                                result.tryFailure(ex);\n+                                return;\n+                            }\n+                            \n+                            if (waitTime == -1 && leaseTime == -1) {\n+                                result.trySuccess(false);\n+                                return;\n+                            }\n+                            \n+                            failedLocksLimit = failedLocksLimit();\n+                            acquiredLocks.clear();\n+                            // reset iterator\n+                            while (iterator.hasPrevious()) {\n+                                iterator.previous();\n+                            }\n+                            \n+                            checkRemainTimeAsync(iterator, result);\n+                        });\n+                        return;\n+                    } else {\n+                        failedLocksLimit--;\n+                    }\n+                }\n+                \n+                checkRemainTimeAsync(iterator, result);\n+            });\n+        }\n+        \n+        private void checkLeaseTimeAsync(RPromise<Boolean> result) {\n+            if (leaseTime != -1) {\n+                AtomicInteger counter = new AtomicInteger(acquiredLocks.size());\n+                for (RLock rLock : acquiredLocks) {\n+                    RFuture<Boolean> future = rLock.expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);\n+                    future.onComplete((res, e) -> {\n+                        if (e != null) {\n+                            result.tryFailure(e);\n+                            return;\n+                        }\n+                        \n+                        if (counter.decrementAndGet() == 0) {\n+                            result.trySuccess(true);\n+                        }\n+                    });\n+                }\n+                return;\n+            }\n+            \n+            result.trySuccess(true);\n+        }\n+        \n+        private void checkRemainTimeAsync(ListIterator<RLock> iterator, RPromise<Boolean> result) {\n+            if (remainTime != -1) {\n+                remainTime += -(System.currentTimeMillis() - time);\n+                time = System.currentTimeMillis();\n+                if (remainTime <= 0) {\n+                    unlockInnerAsync(acquiredLocks, threadId).onComplete((res, e) -> {\n+                        if (e != null) {\n+                            result.tryFailure(e);\n+                            return;\n+                        }\n+                        \n+                        result.trySuccess(false);\n+                    });\n+                    return;\n+                }\n+            }\n+            \n+            tryAcquireLockAsync(iterator, result);\n+        }\n+        \n+    }\n+    \n     final List<RLock> locks = new ArrayList<RLock>();\n     \n     /**\n@@ -284,143 +428,11 @@ public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws Inte\n         return true;\n     }\n \n-    private void tryAcquireLockAsync(ListIterator<RLock> iterator, List<RLock> acquiredLocks, RPromise<Boolean> result, \n-            long lockWaitTime, long waitTime, long leaseTime, long newLeaseTime, \n-            AtomicLong remainTime, AtomicLong time, AtomicInteger failedLocksLimit, TimeUnit unit, long threadId) {\n-        if (!iterator.hasNext()) {\n-            checkLeaseTimeAsync(acquiredLocks, result, leaseTime, unit);\n-            return;\n-        }\n-\n-        RLock lock = iterator.next();\n-        RPromise<Boolean> lockAcquiredFuture = new RedissonPromise<Boolean>();\n-        if (waitTime == -1 && leaseTime == -1) {\n-            lock.tryLockAsync(threadId)\n-                .onComplete(new TransferListener<Boolean>(lockAcquiredFuture));\n-        } else {\n-            long awaitTime = Math.min(lockWaitTime, remainTime.get());\n-            lock.tryLockAsync(awaitTime, newLeaseTime, TimeUnit.MILLISECONDS, threadId)\n-                .onComplete(new TransferListener<Boolean>(lockAcquiredFuture));\n-        }\n-        \n-        lockAcquiredFuture.onComplete((res, e) -> {\n-            boolean lockAcquired = false;\n-            if (res != null) {\n-                lockAcquired = res;\n-            }\n-\n-            if (e instanceof RedisResponseTimeoutException) {\n-                unlockInnerAsync(Arrays.asList(lock), threadId);\n-            }\n-            \n-            if (lockAcquired) {\n-                acquiredLocks.add(lock);\n-            } else {\n-                if (locks.size() - acquiredLocks.size() == failedLocksLimit()) {\n-                    checkLeaseTimeAsync(acquiredLocks, result, leaseTime, unit);\n-                    return;\n-                }\n-\n-                if (failedLocksLimit.get() == 0) {\n-                    unlockInnerAsync(acquiredLocks, threadId).onComplete((r, ex) -> {\n-                        if (ex != null) {\n-                            result.tryFailure(ex);\n-                            return;\n-                        }\n-                        \n-                        if (waitTime == -1 && leaseTime == -1) {\n-                            result.trySuccess(false);\n-                            return;\n-                        }\n-                        \n-                        failedLocksLimit.set(failedLocksLimit());\n-                        acquiredLocks.clear();\n-                        // reset iterator\n-                        while (iterator.hasPrevious()) {\n-                            iterator.previous();\n-                        }\n-                        \n-                        checkRemainTimeAsync(iterator, acquiredLocks, result, \n-                                lockWaitTime, waitTime, leaseTime, newLeaseTime, \n-                                remainTime, time, failedLocksLimit, unit, threadId);\n-                    });\n-                    return;\n-                } else {\n-                    failedLocksLimit.decrementAndGet();\n-                }\n-            }\n-            \n-            checkRemainTimeAsync(iterator, acquiredLocks, result, \n-                    lockWaitTime, waitTime, leaseTime, newLeaseTime, \n-                    remainTime, time, failedLocksLimit, unit, threadId);\n-        });\n-    }\n \n-    private void checkLeaseTimeAsync(List<RLock> acquiredLocks, RPromise<Boolean> result, long leaseTime, TimeUnit unit) {\n-        if (leaseTime != -1) {\n-            AtomicInteger counter = new AtomicInteger(locks.size());\n-            for (RLock rLock : acquiredLocks) {\n-                RFuture<Boolean> future = rLock.expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);\n-                future.onComplete((res, e) -> {\n-                    if (e != null) {\n-                        result.tryFailure(e);\n-                        return;\n-                    }\n-                    \n-                    if (counter.decrementAndGet() == 0) {\n-                        result.trySuccess(true);\n-                    }\n-                });\n-            }\n-            return;\n-        }\n-        \n-        result.trySuccess(true);\n-    }\n-    \n-    protected void checkRemainTimeAsync(ListIterator<RLock> iterator, List<RLock> acquiredLocks, RPromise<Boolean> result, \n-            long lockWaitTime, long waitTime, long leaseTime, long newLeaseTime, \n-            AtomicLong remainTime, AtomicLong time, AtomicInteger failedLocksLimit, TimeUnit unit, long threadId) {\n-        if (remainTime.get() != -1) {\n-            remainTime.addAndGet(-(System.currentTimeMillis() - time.get()));\n-            time.set(System.currentTimeMillis());\n-            if (remainTime.get() <= 0) {\n-                unlockInnerAsync(acquiredLocks, threadId).onComplete((res, e) -> {\n-                    if (e != null) {\n-                        result.tryFailure(e);\n-                        return;\n-                    }\n-                    \n-                    result.trySuccess(false);\n-                });\n-                return;\n-            }\n-        }\n-        \n-        tryAcquireLockAsync(iterator, acquiredLocks, result, lockWaitTime, waitTime, \n-                leaseTime, newLeaseTime, remainTime, time, failedLocksLimit, unit, threadId);\n-    }\n-    \n     public RFuture<Boolean> tryLockAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId) {\n         RPromise<Boolean> result = new RedissonPromise<Boolean>();\n-        long newLeaseTime = -1;\n-        if (leaseTime != -1) {\n-            newLeaseTime = unit.toMillis(waitTime)*2;\n-        }\n-        \n-        AtomicLong time = new AtomicLong(System.currentTimeMillis());\n-        AtomicLong remainTime = new AtomicLong(-1);\n-        if (waitTime != -1) {\n-            remainTime.set(unit.toMillis(waitTime));\n-        }\n-        long lockWaitTime = calcLockWaitTime(remainTime.get());\n-        \n-        AtomicInteger failedLocksLimit = new AtomicInteger(failedLocksLimit());\n-        List<RLock> acquiredLocks = new ArrayList<RLock>(locks.size());\n-        tryAcquireLockAsync(locks.listIterator(), acquiredLocks, result, \n-                lockWaitTime, waitTime, leaseTime, newLeaseTime, \n-                remainTime, time, failedLocksLimit, unit, threadId);\n-        \n+        LockState state = new LockState(waitTime, leaseTime, unit, threadId);\n+        state.tryAcquireLockAsync(locks.listIterator(), result);\n         return result;\n     }\n     ",
      "parent_sha": "54a231716865326845aacc7f1547072aeb429b9e"
    }
  },
  {
    "oid": "7ea9130f422820e38cd8515e70057d364e6e4025",
    "message": "Fixed RBinaryStream doesn't work in Redis cluster environment #937",
    "date": "2017-06-23T13:17:21Z",
    "url": "https://github.com/redisson/redisson/commit/7ea9130f422820e38cd8515e70057d364e6e4025",
    "details": {
      "sha": "ecea38ea2da033405c87f41bd370a84c4daf5c24",
      "filename": "redisson/src/main/java/org/redisson/RedissonBinaryStream.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/7ea9130f422820e38cd8515e70057d364e6e4025/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonBinaryStream.java",
      "raw_url": "https://github.com/redisson/redisson/raw/7ea9130f422820e38cd8515e70057d364e6e4025/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonBinaryStream.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonBinaryStream.java?ref=7ea9130f422820e38cd8515e70057d364e6e4025",
      "patch": "@@ -282,7 +282,7 @@ public void operationComplete(Future<Void> future) throws Exception {\n     }\n     \n     private String getPartsName() {\n-        return getName() + \":parts\";\n+        return suffixName(getName(), \"parts\");\n     }\n     \n     @Override",
      "parent_sha": "4c80f29b2a6b93be05d152d45d757b220d5c4950"
    }
  },
  {
    "oid": "4663fcdba834b419a21d3cd4629b8bc4588e2935",
    "message": "refactoring",
    "date": "2023-06-06T10:43:53Z",
    "url": "https://github.com/redisson/redisson/commit/4663fcdba834b419a21d3cd4629b8bc4588e2935",
    "details": {
      "sha": "e1d68e55a9e712c2c777580ad5f85f77abf708b8",
      "filename": "redisson/src/main/java/org/redisson/RedissonScoredSortedSet.java",
      "status": "modified",
      "additions": 68,
      "deletions": 44,
      "changes": 112,
      "blob_url": "https://github.com/redisson/redisson/blob/4663fcdba834b419a21d3cd4629b8bc4588e2935/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonScoredSortedSet.java",
      "raw_url": "https://github.com/redisson/redisson/raw/4663fcdba834b419a21d3cd4629b8bc4588e2935/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonScoredSortedSet.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Fmain%2Fjava%2Forg%2Fredisson%2FRedissonScoredSortedSet.java?ref=4663fcdba834b419a21d3cd4629b8bc4588e2935",
      "patch": "@@ -122,14 +122,18 @@ public RFuture<V> pollLastAsync() {\n     }\n \n     private <T> RFuture<T> poll(int from, int to, RedisCommand<?> command) {\n-        return commandExecutor.evalWriteAsync(getRawName(), codec, command,\n+        return poll(getRawName(), from, to, command);\n+    }\n+\n+    protected <T> RFuture<T> poll(String name, int from, int to, RedisCommand<?> command) {\n+        return commandExecutor.evalWriteAsync(name, codec, command,\n                 \"local v = redis.call('zrange', KEYS[1], ARGV[1], ARGV[2]); \"\n                 + \"if #v > 0 then \"\n                     + \"redis.call('zremrangebyrank', KEYS[1], ARGV[1], ARGV[2]); \"\n                     + \"return v; \"\n                 + \"end \"\n                 + \"return v;\",\n-                Collections.<Object>singletonList(getRawName()), from, to);\n+                Collections.<Object>singletonList(name), from, to);\n     }\n \n     @Override\n@@ -180,14 +184,18 @@ public RFuture<List<ScoredEntry<V>>> pollLastEntriesAsync(int count) {\n     }\n \n     private <T> RFuture<T> pollEntry(int from, int to, RedisCommand<?> command) {\n-        return commandExecutor.evalWriteAsync(getRawName(), codec, command,\n+        return pollEntry(getRawName(), from, to, command);\n+    }\n+\n+    protected final <T> RFuture<T> pollEntry(String name, int from, int to, RedisCommand<?> command) {\n+        return commandExecutor.evalWriteAsync(name, codec, command,\n                 \"local v = redis.call('zrange', KEYS[1], ARGV[1], ARGV[2], 'withscores'); \"\n                     + \"if #v > 0 then \"\n                         + \"redis.call('zremrangebyrank', KEYS[1], ARGV[1], ARGV[2]); \"\n                         + \"return v; \"\n                     + \"end \"\n                     + \"return v;\",\n-                Collections.singletonList(getRawName()), from, to);\n+                Collections.singletonList(name), from, to);\n     }\n \n     @Override\n@@ -216,12 +224,12 @@ public RFuture<List<ScoredEntry<V>>> pollLastEntriesAsync(Duration duration, int\n     public V pollFirst(long timeout, TimeUnit unit) {\n         return get(pollFirstAsync(timeout, unit));\n     }\n-    \n+\n     @Override\n     public RFuture<V> pollFirstAsync(long timeout, TimeUnit unit) {\n         return commandExecutor.writeAsync(getRawName(), codec, RedisCommands.BZPOPMIN_VALUE, getRawName(), toSeconds(timeout, unit));\n     }\n-    \n+\n     @Override\n     public V pollFirstFromAny(long timeout, TimeUnit unit, String... queueNames) {\n         return get(pollFirstFromAnyAsync(timeout, unit, queueNames));\n@@ -386,7 +394,7 @@ public RFuture<Map<String, Map<V, Double>>> pollLastEntriesFromAnyAsync(Duration\n     public V pollLast(long timeout, TimeUnit unit) {\n         return get(pollLastAsync(timeout, unit));\n     }\n-    \n+\n     @Override\n     public RFuture<V> pollLastAsync(long timeout, TimeUnit unit) {\n         return commandExecutor.writeAsync(getRawName(), codec, RedisCommands.BZPOPMAX_VALUE, getRawName(), toSeconds(timeout, unit));\n@@ -456,10 +464,11 @@ public Integer addAndGetRank(double score, V object) {\n \n     @Override\n     public RFuture<Integer> addAndGetRankAsync(double score, V object) {\n-        return commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_INTEGER,\n+        String name = getRawName(object);\n+        return commandExecutor.evalWriteAsync(name, LongCodec.INSTANCE, RedisCommands.EVAL_INTEGER,\n                 \"redis.call('zadd', KEYS[1], ARGV[1], ARGV[2]);\" +\n                 \"return redis.call('zrank', KEYS[1], ARGV[2]); \",\n-                Collections.<Object>singletonList(getRawName()), new BigDecimal(score).toPlainString(), encode(object));\n+                Collections.<Object>singletonList(name), new BigDecimal(score).toPlainString(), encode(object));\n     }\n \n     @Override\n@@ -474,10 +483,11 @@ public List<Integer> addAndGetRevRank(Map<? extends V, Double> map) {\n \n     @Override\n     public RFuture<Integer> addAndGetRevRankAsync(double score, V object) {\n-        return commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_INTEGER,\n+        String name = getRawName(object);\n+        return commandExecutor.evalWriteAsync(name, LongCodec.INSTANCE, RedisCommands.EVAL_INTEGER,\n                 \"redis.call('zadd', KEYS[1], ARGV[1], ARGV[2]);\" +\n                 \"return redis.call('zrevrank', KEYS[1], ARGV[2]); \",\n-                Collections.<Object>singletonList(getRawName()), new BigDecimal(score).toPlainString(), encode(object));\n+                Collections.<Object>singletonList(name), new BigDecimal(score).toPlainString(), encode(object));\n     }\n \n     @Override\n@@ -522,7 +532,8 @@ public boolean addIfExists(double score, V object) {\n \n     @Override\n     public RFuture<Boolean> addIfExistsAsync(double score, V object) {\n-        return commandExecutor.writeAsync(getRawName(), codec, RedisCommands.ZADD_BOOL, getRawName(), \"XX\", \"CH\", BigDecimal.valueOf(score).toPlainString(), encode(object));\n+        String name = getRawName(object);\n+        return commandExecutor.writeAsync(name, codec, RedisCommands.ZADD_BOOL, name, \"XX\", \"CH\", BigDecimal.valueOf(score).toPlainString(), encode(object));\n     }\n \n     @Override\n@@ -537,14 +548,16 @@ public boolean addIfGreater(double score, V object) {\n \n     @Override\n     public RFuture<Boolean> addIfLessAsync(double score, V object) {\n-        return commandExecutor.writeAsync(getRawName(), codec, RedisCommands.ZADD_BOOL,\n-                getRawName(), \"LT\", \"CH\", BigDecimal.valueOf(score).toPlainString(), encode(object));\n+        String name = getRawName(object);\n+        return commandExecutor.writeAsync(name, codec, RedisCommands.ZADD_BOOL,\n+                name, \"LT\", \"CH\", BigDecimal.valueOf(score).toPlainString(), encode(object));\n     }\n \n     @Override\n     public RFuture<Boolean> addIfGreaterAsync(double score, V object) {\n-        return commandExecutor.writeAsync(getRawName(), codec, RedisCommands.ZADD_BOOL,\n-                getRawName(), \"GT\", \"CH\", BigDecimal.valueOf(score).toPlainString(), encode(object));\n+        String name = getRawName(object);\n+        return commandExecutor.writeAsync(name, codec, RedisCommands.ZADD_BOOL,\n+                name, \"GT\", \"CH\", BigDecimal.valueOf(score).toPlainString(), encode(object));\n     }\n \n     @Override\n@@ -596,7 +609,7 @@ public Double firstScore() {\n     public RFuture<Double> firstScoreAsync() {\n         return commandExecutor.readAsync(getRawName(), codec, RedisCommands.ZRANGE_SINGLE_SCORE, getRawName(), 0, 0, \"WITHSCORES\");\n     }\n-    \n+\n     @Override\n     public Double lastScore() {\n         return get(lastScoreAsync());\n@@ -610,7 +623,8 @@ public RFuture<Double> lastScoreAsync() {\n \n     @Override\n     public RFuture<Boolean> addAsync(double score, V object) {\n-        return commandExecutor.writeAsync(getRawName(), codec, RedisCommands.ZADD_BOOL, getRawName(), BigDecimal.valueOf(score).toPlainString(), encode(object));\n+        String name = getRawName(object);\n+        return commandExecutor.writeAsync(name, codec, RedisCommands.ZADD_BOOL, name, BigDecimal.valueOf(score).toPlainString(), encode(object));\n     }\n \n     @Override\n@@ -664,7 +678,7 @@ public RFuture<Integer> addAllIfExistAsync(Map<V, Double> objects) {\n         if (objects.isEmpty()) {\n             return new CompletableFutureWrapper<>(0);\n         }\n-        List<Object> params = new ArrayList<>(objects.size()*2+1);\n+        List<Object> params = new ArrayList<>(objects.size()*2+3);\n         params.add(getRawName());\n         params.add(\"XX\");\n         params.add(\"CH\");\n@@ -722,7 +736,8 @@ public RFuture<Integer> addAllIfLessAsync(Map<V, Double> objects) {\n \n     @Override\n     public RFuture<Boolean> tryAddAsync(double score, V object) {\n-        return commandExecutor.writeAsync(getRawName(), codec, RedisCommands.ZADD_BOOL, getRawName(), \"NX\", BigDecimal.valueOf(score).toPlainString(), encode(object));\n+        String name = getRawName(object);\n+        return commandExecutor.writeAsync(name, codec, RedisCommands.ZADD_BOOL, name, \"NX\", BigDecimal.valueOf(score).toPlainString(), encode(object));\n     }\n \n     @Override\n@@ -732,7 +747,8 @@ public boolean addIfAbsent(double score, V object) {\n \n     @Override\n     public RFuture<Boolean> addIfAbsentAsync(double score, V object) {\n-        return commandExecutor.writeAsync(getRawName(), codec, RedisCommands.ZADD_BOOL, getRawName(), \"NX\", BigDecimal.valueOf(score).toPlainString(), encode(object));\n+        String name = getRawName(object);\n+        return commandExecutor.writeAsync(name, codec, RedisCommands.ZADD_BOOL, name, \"NX\", BigDecimal.valueOf(score).toPlainString(), encode(object));\n     }\n \n     @Override\n@@ -786,7 +802,8 @@ public void clear() {\n \n     @Override\n     public RFuture<Boolean> removeAsync(Object object) {\n-        return commandExecutor.writeAsync(getRawName(), codec, RedisCommands.ZREM, getRawName(), encode(object));\n+        String name = getRawName(object);\n+        return commandExecutor.writeAsync(name, codec, RedisCommands.ZREM, name, encode(object));\n     }\n \n     @Override\n@@ -829,7 +846,8 @@ public boolean contains(Object object) {\n \n     @Override\n     public RFuture<Boolean> containsAsync(Object o) {\n-        return commandExecutor.readAsync(getRawName(), StringCodec.INSTANCE, RedisCommands.ZSCORE_CONTAINS, getRawName(), encode(o));\n+        String name = getRawName(o);\n+        return commandExecutor.readAsync(name, StringCodec.INSTANCE, RedisCommands.ZSCORE_CONTAINS, name, encode(o));\n     }\n \n     @Override\n@@ -844,7 +862,8 @@ public List<Double> getScore(List<V> keys) {\n \n     @Override\n     public RFuture<Double> getScoreAsync(V o) {\n-        return commandExecutor.readAsync(getRawName(), StringCodec.INSTANCE, RedisCommands.ZSCORE, getRawName(), encode(o));\n+        String name = getRawName(o);\n+        return commandExecutor.readAsync(name, StringCodec.INSTANCE, RedisCommands.ZSCORE, name, encode(o));\n     }\n \n     @Override\n@@ -865,7 +884,8 @@ public Integer rank(V o) {\n \n     @Override\n     public RFuture<Integer> rankAsync(V o) {\n-        return commandExecutor.readAsync(getRawName(), codec, RedisCommands.ZRANK_INT, getRawName(), encode(o));\n+        String name = getRawName(o);\n+        return commandExecutor.readAsync(name, codec, RedisCommands.ZRANK_INT, name, encode(o));\n     }\n \n     @Override\n@@ -875,14 +895,15 @@ public RankedEntry<V> rankEntry(V o) {\n \n     @Override\n     public RFuture<RankedEntry<V>> rankEntryAsync(V o) {\n-        return commandExecutor.readAsync(getRawName(), codec, RedisCommands.ZRANK_ENTRY, getRawName(), encode(o), \"WITHSCORE\");\n+        String name = getRawName(o);\n+        return commandExecutor.readAsync(name, codec, RedisCommands.ZRANK_ENTRY, name, encode(o), \"WITHSCORE\");\n     }\n \n     private ScanResult<Object> scanIterator(RedisClient client, long startPos, String pattern, int count) {\n         RFuture<ScanResult<Object>> f = scanIteratorAsync(client, startPos, pattern, count);\n         return get(f);\n     }\n-    \n+\n     public RFuture<ScanResult<Object>> scanIteratorAsync(RedisClient client, long startPos, String pattern, int count) {\n         if (pattern == null) {\n             RFuture<ScanResult<Object>> f = commandExecutor.readAsync(client, getRawName(), codec, RedisCommands.ZSCAN, getRawName(), startPos, \"COUNT\", count);\n@@ -896,12 +917,12 @@ public RFuture<ScanResult<Object>> scanIteratorAsync(RedisClient client, long st\n     public Iterator<V> iterator() {\n         return iterator(null, 10);\n     }\n-    \n+\n     @Override\n     public Iterator<V> iterator(String pattern) {\n         return iterator(pattern, 10);\n     }\n-    \n+\n     @Override\n     public Iterator<V> iterator(int count) {\n         return iterator(null, count);\n@@ -920,7 +941,7 @@ protected ScanResult<Object> iterator(RedisClient client, long nextIterPos) {\n             protected void remove(Object value) {\n                 RedissonScoredSortedSet.this.remove(value);\n             }\n-            \n+\n         };\n     }\n \n@@ -1062,7 +1083,7 @@ public RFuture<Boolean> containsAllAsync(Collection<?> c) {\n         if (c.isEmpty()) {\n             return new CompletableFutureWrapper<>(true);\n         }\n-        \n+\n         return commandExecutor.evalReadAsync(getRawName(), codec, RedisCommands.EVAL_BOOLEAN,\n                             \"for j = 1, #ARGV, 1 do \"\n                             + \"local expireDateScore = redis.call('zscore', KEYS[1], ARGV[j]) \"\n@@ -1079,7 +1100,7 @@ public RFuture<Boolean> removeAllAsync(Collection<?> c) {\n         if (c.isEmpty()) {\n             return new CompletableFutureWrapper<>(false);\n         }\n-        \n+\n         List<Object> params = new ArrayList<Object>(c.size()+1);\n         params.add(getRawName());\n         encode(params, c);\n@@ -1096,19 +1117,19 @@ public boolean removeAll(Collection<?> c) {\n     public boolean retainAll(Collection<?> c) {\n         return get(retainAllAsync(c));\n     }\n-    \n+\n     @Override\n     public RFuture<Boolean> retainAllAsync(Collection<?> c) {\n         if (c.isEmpty()) {\n             return deleteAsync();\n         }\n-        \n+\n         List<Object> params = new ArrayList<>(c.size() * 2);\n         for (Object object : c) {\n             params.add(0);\n             encode(params, object);\n         }\n-        \n+\n         return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_BOOLEAN,\n                 \"redis.call('zadd', KEYS[2], unpack(ARGV)); \"\n                  + \"local prevSize = redis.call('zcard', KEYS[1]); \"\n@@ -1125,34 +1146,37 @@ public Double addScore(V object, Number value) {\n \n     @Override\n     public RFuture<Double> addScoreAsync(V object, Number value) {\n-        return commandExecutor.writeAsync(getRawName(), DoubleCodec.INSTANCE, RedisCommands.ZINCRBY,\n-                                   getRawName(), new BigDecimal(value.toString()).toPlainString(), encode(object));\n+        String name = getRawName(object);\n+        return commandExecutor.writeAsync(name, DoubleCodec.INSTANCE, RedisCommands.ZINCRBY,\n+                                            name, new BigDecimal(value.toString()).toPlainString(), encode(object));\n     }\n-    \n+\n     @Override\n     public Integer addScoreAndGetRank(V object, Number value) {\n         return get(addScoreAndGetRankAsync(object, value));\n     }\n-    \n+\n     @Override\n     public RFuture<Integer> addScoreAndGetRankAsync(V object, Number value) {\n-        return commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_INTEGER,\n+        String name = getRawName(object);\n+        return commandExecutor.evalWriteAsync(name, LongCodec.INSTANCE, RedisCommands.EVAL_INTEGER,\n                 \"redis.call('zincrby', KEYS[1], ARGV[1], ARGV[2]); \"\n                +\"return redis.call('zrank', KEYS[1], ARGV[2]); \",\n-                Collections.singletonList(getRawName()), new BigDecimal(value.toString()).toPlainString(), encode(object));\n+                Collections.singletonList(name), new BigDecimal(value.toString()).toPlainString(), encode(object));\n     }\n \n     @Override\n     public Integer addScoreAndGetRevRank(V object, Number value) {\n         return get(addScoreAndGetRevRankAsync(object, value));\n     }\n-    \n+\n     @Override\n     public RFuture<Integer> addScoreAndGetRevRankAsync(V object, Number value) {\n-        return commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_INTEGER,\n+        String name = getRawName(object);\n+        return commandExecutor.evalWriteAsync(name, LongCodec.INSTANCE, RedisCommands.EVAL_INTEGER,\n                 \"redis.call('zincrby', KEYS[1], ARGV[1], ARGV[2]); \"\n                +\"return redis.call('zrevrank', KEYS[1], ARGV[2]); \",\n-                Collections.singletonList(getRawName()), new BigDecimal(value.toString()).toPlainString(), encode(object));\n+                Collections.singletonList(name), new BigDecimal(value.toString()).toPlainString(), encode(object));\n     }\n \n     @Override",
      "parent_sha": "cd4c603de5a9e45665582a033a03051af1933f7d"
    }
  },
  {
    "oid": "724375b3a4e6f44d498ef8001027d0ce8b796996",
    "message": "Enhancement on stopping redis instance\n\nRedis server started with nosave and randomdir options is stopped with\ndestroy instead of sending shutdown.",
    "date": "2016-04-01T12:30:56Z",
    "url": "https://github.com/redisson/redisson/commit/724375b3a4e6f44d498ef8001027d0ce8b796996",
    "details": {
      "sha": "b2a11d79b589f16b17927d52a9978089d5122907",
      "filename": "src/test/java/org/redisson/RedisRunner.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/724375b3a4e6f44d498ef8001027d0ce8b796996/src%2Ftest%2Fjava%2Forg%2Fredisson%2FRedisRunner.java",
      "raw_url": "https://github.com/redisson/redisson/raw/724375b3a4e6f44d498ef8001027d0ce8b796996/src%2Ftest%2Fjava%2Forg%2Fredisson%2FRedisRunner.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/src%2Ftest%2Fjava%2Forg%2Fredisson%2FRedisRunner.java?ref=724375b3a4e6f44d498ef8001027d0ce8b796996",
      "patch": "@@ -709,7 +709,7 @@ private RedisProcess(Process redisProcess, RedisRunner runner) {\n         }\n \n         public int stop() throws InterruptedException {\n-            if (runner.isNosave()) {\n+            if (runner.isNosave() && !runner.isRandomDir()) {\n                 ArrayList<String> b = runner.getBindAddr();\n                 RedisClient c = new RedisClient(b.size() > 0 ? b.get(0) : \"localhost\", runner.getPort());\n                 c.connect()",
      "parent_sha": "7671e59deae855d99c9abf1ef734450ad8ac6e51"
    }
  },
  {
    "oid": "a8ae0b892b8900659b5aa2217623c71a0b0c2199",
    "message": "Code cleanup",
    "date": "2015-11-25T08:08:41Z",
    "url": "https://github.com/redisson/redisson/commit/a8ae0b892b8900659b5aa2217623c71a0b0c2199",
    "details": {
      "sha": "b9e27a6b07aaaefe139938de60ee1f95a18f46cc",
      "filename": "src/main/java/org/redisson/misc/ConnectionPool.java",
      "status": "modified",
      "additions": 3,
      "deletions": 49,
      "changes": 52,
      "blob_url": "https://github.com/redisson/redisson/blob/a8ae0b892b8900659b5aa2217623c71a0b0c2199/src%2Fmain%2Fjava%2Forg%2Fredisson%2Fmisc%2FConnectionPool.java",
      "raw_url": "https://github.com/redisson/redisson/raw/a8ae0b892b8900659b5aa2217623c71a0b0c2199/src%2Fmain%2Fjava%2Forg%2Fredisson%2Fmisc%2FConnectionPool.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/src%2Fmain%2Fjava%2Forg%2Fredisson%2Fmisc%2FConnectionPool.java?ref=a8ae0b892b8900659b5aa2217623c71a0b0c2199",
      "patch": "@@ -15,22 +15,20 @@\n  */\n package org.redisson.misc;\n \n-import java.util.Deque;\n import java.util.List;\n import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.LinkedBlockingDeque;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n import org.redisson.MasterSlaveServersConfig;\n import org.redisson.client.RedisConnection;\n import org.redisson.client.RedisConnectionException;\n import org.redisson.client.protocol.RedisCommands;\n-import org.redisson.connection.ConnectionManager;\n-import org.redisson.connection.MasterSlaveEntry;\n import org.redisson.connection.ClientConnectionsEntry;\n import org.redisson.connection.ClientConnectionsEntry.FreezeReason;\n import org.redisson.connection.ClientConnectionsEntry.NodeType;\n+import org.redisson.connection.ConnectionManager;\n+import org.redisson.connection.MasterSlaveEntry;\n \n import io.netty.util.Timeout;\n import io.netty.util.TimerTask;\n@@ -42,8 +40,6 @@ public class ConnectionPool<T extends RedisConnection> {\n \n     protected final List<ClientConnectionsEntry> entries = new CopyOnWriteArrayList<ClientConnectionsEntry>();\n \n-    final Deque<Promise<T>> promises = new LinkedBlockingDeque<Promise<T>>();\n-\n     final ConnectionManager connectionManager;\n \n     final MasterSlaveServersConfig config;\n@@ -54,25 +50,13 @@ public ConnectionPool(MasterSlaveServersConfig config, ConnectionManager connect\n         this.config = config;\n         this.masterSlaveEntry = masterSlaveEntry;\n         this.connectionManager = connectionManager;\n-\n-//        Executors.newSingleThreadScheduledExecutor().scheduleWithFixedDelay(new Runnable() {\n-//\n-//            @Override\n-//            public void run() {\n-//                if (promises.size() > 0) {\n-//                    System.out.println(\"promises \" + promises.size());\n-//                }\n-//\n-//            }\n-//        }, 1, 1, TimeUnit.SECONDS);\n     }\n \n     public void add(final ClientConnectionsEntry entry) {\n         initConnections(entry, new Runnable() {\n             @Override\n             public void run() {\n                 entries.add(entry);\n-                handleQueue(entry, true);\n             }\n         }, true);\n     }\n@@ -129,11 +113,8 @@ public Future<T> get() {\n         }\n \n         RedisConnectionException exception = new RedisConnectionException(\n-                \"Can't aquire connection from pool\");\n+                \"Can't aquire connection from pool!\");\n         return connectionManager.newFailedFuture(exception);\n-//        Promise<T> promise = connectionManager.newPromise();\n-//        promises.add(promise);\n-//        return promise;\n     }\n \n     public Future<T> get(ClientConnectionsEntry entry) {\n@@ -289,13 +270,10 @@ public void operationComplete(Future<String> future) throws Exception {\n                                             @Override\n                                             public void run() {\n                                                 if (entry.getNodeType() == NodeType.SLAVE) {\n-                                                    handleQueue(entry, false);\n                                                     masterSlaveEntry.slaveUp(entry.getClient().getAddr().getHostName(), entry.getClient().getAddr().getPort(), FreezeReason.RECONNECT);\n                                                 } else {\n                                                     synchronized (entry) {\n                                                         if (entry.getFreezeReason() == FreezeReason.RECONNECT) {\n-                                                            handleQueue(entry, false);\n-\n                                                             entry.setFreezed(false);\n                                                             entry.setFreezeReason(null);\n                                                         }\n@@ -332,30 +310,6 @@ public void returnConnection(ClientConnectionsEntry entry, T connection) {\n \n     protected void releaseConnection(ClientConnectionsEntry entry) {\n         entry.releaseConnection();\n-\n-        handleQueue(entry, true);\n-    }\n-\n-    private void handleQueue(ClientConnectionsEntry entry, boolean checkFreezed) {\n-        while (true) {\n-            if (checkFreezed && entry.isFreezed()) {\n-                return;\n-            }\n-            Promise<T> promise = promises.poll();\n-            if (promise == null) {\n-                return;\n-            }\n-            if (promise.isCancelled()) {\n-                continue;\n-            }\n-\n-            if (!tryAcquireConnection(entry)) {\n-                promises.addFirst(promise);\n-            } else {\n-                connect(entry, promise);\n-            }\n-            return;\n-        }\n     }\n \n     protected void releaseConnection(ClientConnectionsEntry entry, T conn) {",
      "parent_sha": "2826623dfd1b35ef6f09d4375a03c9750c4ce4d4"
    }
  },
  {
    "oid": "70f8b7fb90bd8fbe9ac18203161d6d2c63dfe3ed",
    "message": "test fixed",
    "date": "2024-09-17T13:40:44Z",
    "url": "https://github.com/redisson/redisson/commit/70f8b7fb90bd8fbe9ac18203161d6d2c63dfe3ed",
    "details": {
      "sha": "0fe6ad3221f461c7e4eb2e427837f38884bbec63",
      "filename": "redisson/src/test/java/org/redisson/executor/RedissonExecutorServiceTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/70f8b7fb90bd8fbe9ac18203161d6d2c63dfe3ed/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2Fexecutor%2FRedissonExecutorServiceTest.java",
      "raw_url": "https://github.com/redisson/redisson/raw/70f8b7fb90bd8fbe9ac18203161d6d2c63dfe3ed/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2Fexecutor%2FRedissonExecutorServiceTest.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2Fexecutor%2FRedissonExecutorServiceTest.java?ref=70f8b7fb90bd8fbe9ac18203161d6d2c63dfe3ed",
      "patch": "@@ -226,7 +226,7 @@ void finish(Invocation invocation, String requestId, boolean removeTask) {\n \n         redisson.getKeys().delete(\"counter\");\n         f.get();\n-        assertThat(redisson.getKeys().count()).isEqualTo(1);\n+        assertThat(redisson.getKeys().count()).isEqualTo(3);\n     }\n     \n     @Test",
      "parent_sha": "6dabcf8687c560f33f9c61492bff87801be36fad"
    }
  },
  {
    "oid": "47c8af18b8371259814f184e309e85c3ae9703e0",
    "message": "test fixed",
    "date": "2021-10-26T07:24:16Z",
    "url": "https://github.com/redisson/redisson/commit/47c8af18b8371259814f184e309e85c3ae9703e0",
    "details": {
      "sha": "ab8de27d381171186303226fb8d1cfaee35b4d6e",
      "filename": "redisson-micronaut/redisson-micronaut-30/src/test/java/org/redisson/micronaut/RedissonSessionTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/redisson/redisson/blob/47c8af18b8371259814f184e309e85c3ae9703e0/redisson-micronaut%2Fredisson-micronaut-30%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2Fmicronaut%2FRedissonSessionTest.java",
      "raw_url": "https://github.com/redisson/redisson/raw/47c8af18b8371259814f184e309e85c3ae9703e0/redisson-micronaut%2Fredisson-micronaut-30%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2Fmicronaut%2FRedissonSessionTest.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson-micronaut%2Fredisson-micronaut-30%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2Fmicronaut%2FRedissonSessionTest.java?ref=47c8af18b8371259814f184e309e85c3ae9703e0",
      "patch": "@@ -179,7 +179,7 @@ public void testSessionCreate() throws ExecutionException, InterruptedException\n         Optional<RedissonSession> noSession = sessionStore.findSession(saved.getId()).get();\n         assertThat(noSession).isEmpty();\n \n-        Thread.sleep(10000);\n+        Thread.sleep(11000);\n \n         assertThat(rc.getKeys().count()).isZero();\n ",
      "parent_sha": "034f112e60e017a5baabf463b555d17adada50e7"
    }
  },
  {
    "oid": "baf1848dc59dc0676c04a91f7542472a4495b594",
    "message": "test fixed",
    "date": "2018-10-25T13:27:37Z",
    "url": "https://github.com/redisson/redisson/commit/baf1848dc59dc0676c04a91f7542472a4495b594",
    "details": {
      "sha": "17dd9b5be5bbc42d6d8b02d3b9b19bb777eddab7",
      "filename": "redisson/src/test/java/org/redisson/spring/cache/RedissonSpringCacheTest.java",
      "status": "modified",
      "additions": 24,
      "deletions": 11,
      "changes": 35,
      "blob_url": "https://github.com/redisson/redisson/blob/baf1848dc59dc0676c04a91f7542472a4495b594/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2Fspring%2Fcache%2FRedissonSpringCacheTest.java",
      "raw_url": "https://github.com/redisson/redisson/raw/baf1848dc59dc0676c04a91f7542472a4495b594/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2Fspring%2Fcache%2FRedissonSpringCacheTest.java",
      "contents_url": "https://api.github.com/repos/redisson/redisson/contents/redisson%2Fsrc%2Ftest%2Fjava%2Forg%2Fredisson%2Fspring%2Fcache%2FRedissonSpringCacheTest.java?ref=baf1848dc59dc0676c04a91f7542472a4495b594",
      "patch": "@@ -6,21 +6,24 @@\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n \n import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.Parameterized;\n import org.redisson.BaseTest;\n import org.redisson.RedisRunner;\n-import org.redisson.RedisRunner.RedisProcess;\n+import org.redisson.RedisRunner.FailedToStartRedisException;\n import org.redisson.api.RedissonClient;\n import org.springframework.cache.CacheManager;\n import org.springframework.cache.annotation.CacheEvict;\n import org.springframework.cache.annotation.CachePut;\n import org.springframework.cache.annotation.Cacheable;\n import org.springframework.cache.annotation.EnableCaching;\n-import org.springframework.context.ConfigurableApplicationContext;\n import org.springframework.context.annotation.AnnotationConfigApplicationContext;\n import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.ComponentScan;\n@@ -119,25 +122,35 @@ CacheManager cacheManager(RedissonClient redissonClient) throws IOException {\n \n     }\n \n-    private static RedisProcess p;\n+    private static Map<Class<?>, AnnotationConfigApplicationContext> contexts;\n \n     @Parameterized.Parameters(name = \"{index} - {0}\")\n-    public static Iterable<Object[]> data() throws IOException, InterruptedException {\n-        if (p == null) {\n-            p = RedisRunner.startDefaultRedisServerInstance();\n-        }\n-        return Arrays.asList(new Object[][]{\n-            {new AnnotationConfigApplicationContext(Application.class)},\n-            {new AnnotationConfigApplicationContext(JsonConfigApplication.class)}\n+    public static Iterable<Class<?>[]> data() throws IOException, InterruptedException {\n+        return Arrays.asList(new Class<?>[][]{\n+            {Application.class},\n+            {JsonConfigApplication.class}\n         });\n     }\n \n     @Parameterized.Parameter(0)\n+    public Class<?> contextClass;\n     public AnnotationConfigApplicationContext context;\n+    \n+    @Before\n+    public void dbefore() {\n+        context = contexts.get(contextClass);\n+    }\n+    \n+    @BeforeClass\n+    public static void before() throws FailedToStartRedisException, IOException, InterruptedException {\n+        RedisRunner.startDefaultRedisServerInstance();\n+        contexts = StreamSupport.stream(RedissonSpringCacheTest.data().spliterator(), false)\n+                          .collect(Collectors.toMap(e -> e[0], e -> new AnnotationConfigApplicationContext(e[0])));\n+    }\n \n     @AfterClass\n     public static void after() throws InterruptedException, IOException {\n-        RedissonSpringCacheTest.data().forEach(e -> ((ConfigurableApplicationContext) e[0]).close());\n+        contexts.values().forEach(e -> e.close());\n         RedisRunner.shutDownDefaultRedisServerInstance();\n     }\n ",
      "parent_sha": "b83812754a74ce9973fb347f2cdc3959eccfc15c"
    }
  }
]