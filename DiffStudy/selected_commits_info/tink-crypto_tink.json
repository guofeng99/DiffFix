[
  {
    "oid": "7c93a224b8fa6a3babfaf71c18c5610052dcbd61",
    "message": "Update KeysetHandle.getPrimaryKey so it returns a KeyHandle with the same key ID and KeyStatusType as the primary key in the keyset.\n\nPiperOrigin-RevId: 384301957",
    "date": "2021-07-12T20:15:45Z",
    "url": "https://github.com/tink-crypto/tink/commit/7c93a224b8fa6a3babfaf71c18c5610052dcbd61",
    "details": {
      "sha": "60921a1d7e33fce6940197f8cda5685150ea4143",
      "filename": "java_src/src/main/java/com/google/crypto/tink/KeysetHandle.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/tink-crypto/tink/blob/7c93a224b8fa6a3babfaf71c18c5610052dcbd61/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/7c93a224b8fa6a3babfaf71c18c5610052dcbd61/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java?ref=7c93a224b8fa6a3babfaf71c18c5610052dcbd61",
      "patch": "@@ -23,7 +23,6 @@\n import com.google.crypto.tink.proto.KeysetInfo;\n import com.google.crypto.tink.tinkkey.KeyAccess;\n import com.google.crypto.tink.tinkkey.KeyHandle;\n-import com.google.crypto.tink.tinkkey.SecretKeyAccess;\n import com.google.crypto.tink.tinkkey.internal.InternalKeyHandle;\n import com.google.crypto.tink.tinkkey.internal.ProtoKey;\n import com.google.protobuf.ByteString;\n@@ -380,9 +379,10 @@ public KeyHandle primaryKey() throws GeneralSecurityException {\n     int primaryKeyId = keyset.getPrimaryKeyId();\n     for (Keyset.Key key : keyset.getKeyList()) {\n       if (key.getKeyId() == primaryKeyId) {\n-        return KeyHandle.createFromKey(\n+        return new InternalKeyHandle(\n             new ProtoKey(key.getKeyData(), KeyTemplate.fromProto(key.getOutputPrefixType())),\n-            SecretKeyAccess.insecureSecretAccess());\n+            key.getStatus(),\n+            key.getKeyId());\n       }\n     }\n     throw new GeneralSecurityException(\"No primary key found in keyset.\");",
      "parent_sha": "99d379628add82a23b17788fa9d3381478f9bd1b"
    }
  },
  {
    "oid": "099300a2b2e814144fbc9c0b195913a7d7c08ba8",
    "message": "Rename generic type for JCE primitives.\n\nPiperOrigin-RevId: 482723479",
    "date": "2022-10-21T08:58:51Z",
    "url": "https://github.com/tink-crypto/tink/commit/099300a2b2e814144fbc9c0b195913a7d7c08ba8",
    "details": {
      "sha": "04c7737051b86c99f862a434f51795c302a8762c",
      "filename": "java_src/src/main/java/com/google/crypto/tink/subtle/EngineFactory.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/tink-crypto/tink/blob/099300a2b2e814144fbc9c0b195913a7d7c08ba8/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FEngineFactory.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/099300a2b2e814144fbc9c0b195913a7d7c08ba8/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FEngineFactory.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FEngineFactory.java?ref=099300a2b2e814144fbc9c0b195913a7d7c08ba8",
      "patch": "@@ -41,7 +41,7 @@\n  *\n  * @since 1.0.0\n  */\n-public final class EngineFactory<T_WRAPPER extends EngineWrapper<T_ENGINE>, T_ENGINE> {\n+public final class EngineFactory<T_WRAPPER extends EngineWrapper<JcePrimitiveT>, JcePrimitiveT> {\n   private static final Logger logger = Logger.getLogger(EngineFactory.class.getName());\n   private static final List<Provider> policy;\n   private static final boolean LET_FALLBACK;\n@@ -106,7 +106,7 @@ public EngineFactory(T_WRAPPER instanceBuilder) {\n     this.instanceBuilder = instanceBuilder;\n   }\n \n-  public T_ENGINE getInstance(String algorithm) throws GeneralSecurityException {\n+  public JcePrimitiveT getInstance(String algorithm) throws GeneralSecurityException {\n     Exception cause = null;\n     for (Provider provider : policy) {\n       try {",
      "parent_sha": "c68c0bbdc038742dd52517274fb88ee146b72811"
    }
  },
  {
    "oid": "724bfe24619cd4cfd0f1549207208c4366107e82",
    "message": "Add a KeysetManagerTest where we add a destroy a key.\n\nI had a bug somewhere else while developing, and this test was useful to find it. Additionally, we change the names to follow the naming convention.\n\nPiperOrigin-RevId: 217848436\nGitOrigin-RevId: 49c170d56298ac228f22509c74ce7215ef94bd1a",
    "date": "2018-10-19T21:58:28Z",
    "url": "https://github.com/tink-crypto/tink/commit/724bfe24619cd4cfd0f1549207208c4366107e82",
    "details": {
      "sha": "a1bce5f1681d9e65d567274da7c70b30017d4308",
      "filename": "java/src/test/java/com/google/crypto/tink/KeysetManagerTest.java",
      "status": "modified",
      "additions": 16,
      "deletions": 3,
      "changes": 19,
      "blob_url": "https://github.com/tink-crypto/tink/blob/724bfe24619cd4cfd0f1549207208c4366107e82/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetManagerTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/724bfe24619cd4cfd0f1549207208c4366107e82/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetManagerTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetManagerTest.java?ref=724bfe24619cd4cfd0f1549207208c4366107e82",
      "patch": "@@ -17,6 +17,7 @@\n package com.google.crypto.tink;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n \n import com.google.crypto.tink.config.TinkConfig;\n@@ -618,7 +619,7 @@ public void testAdd_existingKeySet_shouldAddNewKey() throws Exception {\n   }\n \n   @Test\n-  public void testAddFromTemplate_onePrimary() throws Exception {\n+  public void testAddNewKey_onePrimary() throws Exception {\n     KeysetManager keysetManager = KeysetManager.withEmptyKeyset();\n     int keyId = keysetManager.addNewKey(MacKeyTemplates.HMAC_SHA256_128BITTAG, true);\n     Keyset keyset = keysetManager.getKeysetHandle().getKeyset();\n@@ -628,7 +629,7 @@ public void testAddFromTemplate_onePrimary() throws Exception {\n   }\n \n   @Test\n-  public void testAddFromTemplate_onePrimaryAnotherPrimary() throws Exception {\n+  public void testAddNewKey_onePrimaryAnotherPrimary() throws Exception {\n     KeysetManager keysetManager = KeysetManager.withEmptyKeyset();\n     keysetManager.addNewKey(MacKeyTemplates.HMAC_SHA256_128BITTAG, true);\n     int primaryKeyId = keysetManager.addNewKey(MacKeyTemplates.HMAC_SHA256_128BITTAG, true);\n@@ -638,7 +639,7 @@ public void testAddFromTemplate_onePrimaryAnotherPrimary() throws Exception {\n   }\n \n   @Test\n-  public void testAddFromTemplate_primaryThenNonPrimary() throws Exception {\n+  public void testAddNewKey_primaryThenNonPrimary() throws Exception {\n     KeysetManager keysetManager = KeysetManager.withEmptyKeyset();\n     int primaryKeyId = keysetManager.addNewKey(MacKeyTemplates.HMAC_SHA256_128BITTAG, true);\n     keysetManager.addNewKey(MacKeyTemplates.HMAC_SHA256_128BITTAG, false);\n@@ -647,6 +648,18 @@ public void testAddFromTemplate_primaryThenNonPrimary() throws Exception {\n     assertThat(keyset.getPrimaryKeyId()).isEqualTo(primaryKeyId);\n   }\n \n+  @Test\n+  public void testAddNewKey_addThenDestroy() throws Exception {\n+    KeysetManager keysetManager = KeysetManager.withEmptyKeyset();\n+    keysetManager.addNewKey(MacKeyTemplates.HMAC_SHA256_128BITTAG, true);\n+    int secondaryKeyId = keysetManager.addNewKey(MacKeyTemplates.HMAC_SHA256_128BITTAG, false);\n+    keysetManager.destroy(secondaryKeyId);\n+    Keyset keyset = keysetManager.getKeysetHandle().getKeyset();\n+    assertThat(keyset.getKeyCount()).isEqualTo(2);\n+    // One of the two keys is destroyed and doesn't have keyData anymore.\n+    assertTrue(!keyset.getKey(0).hasKeyData() || !keyset.getKey(1).hasKeyData());\n+  }\n+\n \n   private void manipulateKeyset(KeysetManager manager) {\n     try {",
      "parent_sha": "73162f79f4b0ae0605218a7ba473a813c40662e1"
    }
  },
  {
    "oid": "d72a98696051b88e8ea4e00ed527e7547886cd3a",
    "message": "Mark some TestUtil functions as deprecated.\n\nPiperOrigin-RevId: 541601187",
    "date": "2023-06-19T11:36:58Z",
    "url": "https://github.com/tink-crypto/tink/commit/d72a98696051b88e8ea4e00ed527e7547886cd3a",
    "details": {
      "sha": "ca94dd7296645697508a35648ba07c5405e45b1b",
      "filename": "java_src/src/main/java/com/google/crypto/tink/testing/TestUtil.java",
      "status": "modified",
      "additions": 36,
      "deletions": 7,
      "changes": 43,
      "blob_url": "https://github.com/tink-crypto/tink/blob/d72a98696051b88e8ea4e00ed527e7547886cd3a/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Ftesting%2FTestUtil.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/d72a98696051b88e8ea4e00ed527e7547886cd3a/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Ftesting%2FTestUtil.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Ftesting%2FTestUtil.java?ref=d72a98696051b88e8ea4e00ed527e7547886cd3a",
      "patch": "@@ -229,7 +229,11 @@ public static HmacKey createHmacKey(byte[] keyValue, int tagSize) throws Excepti\n         .build();\n   }\n \n-  /** @return a {@code HkdfPrfKey}. */\n+  /**\n+   * @return a {@code HkdfPrfKey}.\n+   * @deprecated Do not use this function\n+   */\n+  @Deprecated\n   public static HkdfPrfKey createPrfKey(byte[] keyValue) throws Exception {\n     HkdfPrfParams params = HkdfPrfParams.newBuilder().setHash(HashType.SHA256).build();\n \n@@ -316,7 +320,11 @@ public static KeyData createAesGcmHkdfStreamingKeyData(\n         KeyData.KeyMaterialType.SYMMETRIC);\n   }\n \n-  /** @return a {@code KeyData} containing a {@code AesCtrHmacAeadKey}. */\n+  /**\n+   * @return a {@code KeyData} containing a {@code AesCtrHmacAeadKey}.\n+   * @deprecated Do not use this function\n+   */\n+  @Deprecated\n   public static KeyData createAesCtrHmacAeadKeyData(\n       byte[] aesCtrKeyValue, int ivSize, byte[] hmacKeyValue, int tagSize) throws Exception {\n     AesCtrKey aesCtrKey = createAesCtrKey(aesCtrKeyValue, ivSize);\n@@ -342,8 +350,13 @@ public static KeyData createAesGcmKeyData(byte[] keyValue) throws Exception {\n     return createKeyData(keyProto, AeadConfig.AES_GCM_TYPE_URL, KeyData.KeyMaterialType.SYMMETRIC);\n   }\n \n-  /** @return a {@code KeyData} containing a {@code AesEaxKey}. */\n-  public static KeyData createAesEaxKeyData(byte[] keyValue, int ivSizeInBytes) throws Exception {\n+  /**\n+   * @return a {@code KeyData} containing a {@code AesEaxKey}.\n+   * @deprecated DO not use this function.\n+   */\n+  @Deprecated\n+  public static KeyData createAesEaxKeyData(byte[] keyValue, int ivSizeInBytes)\n+      throws Exception {\n     AesEaxKey keyProto =\n         AesEaxKey.newBuilder()\n             .setKeyValue(ByteString.copyFrom(keyValue))\n@@ -528,7 +541,9 @@ public static EciesAeadHkdfPrivateKey generateEciesAeadHkdfPrivKey(\n   /**\n    * @return a {@code KeyData} containing a {@code EciesAeadHkdfPrivateKey} with the specified key\n    *     material and parameters.\n+   * @deprecated Do not use this function\n    */\n+  @Deprecated\n   public static EciesAeadHkdfPrivateKey createEciesAeadHkdfPrivKey(\n       EciesAeadHkdfPublicKey pubKey, byte[] privKeyValue) throws Exception {\n     final int version = 0;\n@@ -539,7 +554,11 @@ public static EciesAeadHkdfPrivateKey createEciesAeadHkdfPrivKey(\n         .build();\n   }\n \n-  /** @return a {@code EciesAeadHkdfPublicKey} with the specified key material and parameters. */\n+  /**\n+   * @return a {@code EciesAeadHkdfPublicKey} with the specified key material and parameters.\n+   * @deprecated Do not use this function.\n+   */\n+  @Deprecated\n   public static EciesAeadHkdfPublicKey createEciesAeadHkdfPubKey(\n       EllipticCurveType curve,\n       HashType hashType,\n@@ -694,7 +713,12 @@ public static void assertHmacKey(com.google.crypto.tink.KeyTemplate keyTemplate,\n     assertThat(hmacKey.getKeyValue().size()).isEqualTo(hmacKeyFormat.getKeySize());\n   }\n \n-  /** Asserts that {@code KeyInfo} is corresponding to a key from {@code keyTemplate}. */\n+  /**\n+   * Asserts that {@code KeyInfo} is corresponding to a key from {@code keyTemplate}.\n+   *\n+   * @deprecated Do not use this function.\n+   */\n+  @Deprecated\n   public static void assertKeyInfo(\n       com.google.crypto.tink.KeyTemplate keyTemplate, KeysetInfo.KeyInfo keyInfo) throws Exception {\n     assertThat(keyInfo.getKeyId()).isGreaterThan(0);\n@@ -738,7 +762,12 @@ public static void assertByteBufferContains(byte[] expected, ByteBuffer buffer)\n     assertByteBufferContains(\"\", expected, buffer);\n   }\n \n-  /** Verifies that the given entry has the specified contents. */\n+  /**\n+   * Verifies that the given entry has the specified contents.\n+   *\n+   * @deprecated Do not use this function.\n+   */\n+  @Deprecated\n   public static void verifyConfigEntry(\n       KeyTypeEntry entry,\n       String catalogueName,",
      "parent_sha": "74b3ac980089987595fa11d8b56bd674321f6278"
    }
  },
  {
    "oid": "287c60c91b768eedb61d6a7f93daab84cb8de9cf",
    "message": "Change a single factory call to a call to keysetHandle.getPrimitive().\n\nPiperOrigin-RevId: 231411049\nGitOrigin-RevId: f664956200f2603d064ace776208cf83873b642d",
    "date": "2019-02-02T02:57:11Z",
    "url": "https://github.com/tink-crypto/tink/commit/287c60c91b768eedb61d6a7f93daab84cb8de9cf",
    "details": {
      "sha": "46504390543caa8cca07d0cffb3858842f543821",
      "filename": "java/src/test/java/com/google/crypto/tink/daead/AesSivKeyManagerTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/tink-crypto/tink/blob/287c60c91b768eedb61d6a7f93daab84cb8de9cf/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fdaead%2FAesSivKeyManagerTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/287c60c91b768eedb61d6a7f93daab84cb8de9cf/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fdaead%2FAesSivKeyManagerTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fdaead%2FAesSivKeyManagerTest.java?ref=287c60c91b768eedb61d6a7f93daab84cb8de9cf",
      "patch": "@@ -67,7 +67,7 @@ public void setUp2() throws Exception {\n   public void testCiphertextSize() throws Exception {\n     for (KeyTemplate template : keyTemplates) {\n       KeysetHandle keysetHandle = KeysetHandle.generateNew(template);\n-      DeterministicAead daead = DeterministicAeadFactory.getPrimitive(keysetHandle);\n+      DeterministicAead daead = keysetHandle.getPrimitive(DeterministicAead.class);\n       byte[] plaintext = \"plaintext\".getBytes(\"UTF-8\");\n       byte[] associatedData = \"associatedData\".getBytes(\"UTF-8\");\n       byte[] ciphertext = daead.encryptDeterministically(plaintext, associatedData);",
      "parent_sha": "6677ba8af48c8954ecfa016f03f8653ffb4c464d"
    }
  },
  {
    "oid": "83f7a150d8f1b9edcd3fdbd729926b3b5b152512",
    "message": "Correct the import path in the SignaturePemKeysetReader documentation.\n\nPiperOrigin-RevId: 401845920",
    "date": "2021-10-08T20:41:44Z",
    "url": "https://github.com/tink-crypto/tink/commit/83f7a150d8f1b9edcd3fdbd729926b3b5b152512",
    "details": {
      "sha": "4082e72339afb7dced984255a790c9c6afe4a2a5",
      "filename": "java_src/src/main/java/com/google/crypto/tink/signature/SignaturePemKeysetReader.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/tink-crypto/tink/blob/83f7a150d8f1b9edcd3fdbd729926b3b5b152512/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsignature%2FSignaturePemKeysetReader.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/83f7a150d8f1b9edcd3fdbd729926b3b5b152512/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsignature%2FSignaturePemKeysetReader.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsignature%2FSignaturePemKeysetReader.java?ref=83f7a150d8f1b9edcd3fdbd729926b3b5b152512",
      "patch": "@@ -50,7 +50,7 @@\n  * <h3>Usage</h3>\n  *\n  * <pre>{@code\n- * import com.google.crypto.tink.subtle.PemKeyType;\n+ * import com.google.crypto.tink.PemKeyType;\n  *\n  * String pem = ...;\n  * PemKeyType type = ...;",
      "parent_sha": "a9b5325432a59123da58649e84983ab3be5a687a"
    }
  },
  {
    "oid": "a1af8fcfc44e12c1d503b8ddcf5ca000f3b23770",
    "message": "Fix a race condition in AndroidKeystoreKmsClient.\n\nThe getOrGenerateNewAeadKey function first checks if a key exists, and generates a new key if it does not. If two threads do this at the same time, there is a possibility for a race condition that both generate a key, and one of the keys will be overwritten.\n\nWithout this fix, the test added here may fail with one of these errors:\njava.security.UnrecoverableKeyException: Failed to obtain information about key\njava.security.InvalidKeyException: Keystore cannot load the key with ID\n\nPiperOrigin-RevId: 502316891",
    "date": "2023-01-16T08:57:05Z",
    "url": "https://github.com/tink-crypto/tink/commit/a1af8fcfc44e12c1d503b8ddcf5ca000f3b23770",
    "details": {
      "sha": "ce58c04fbde074f1cfd080d068e8c7b334a78bca",
      "filename": "java_src/src/main/java/com/google/crypto/tink/integration/android/AndroidKeystoreKmsClient.java",
      "status": "modified",
      "additions": 18,
      "deletions": 12,
      "changes": 30,
      "blob_url": "https://github.com/tink-crypto/tink/blob/a1af8fcfc44e12c1d503b8ddcf5ca000f3b23770/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeystoreKmsClient.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/a1af8fcfc44e12c1d503b8ddcf5ca000f3b23770/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeystoreKmsClient.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeystoreKmsClient.java?ref=a1af8fcfc44e12c1d503b8ddcf5ca000f3b23770",
      "patch": "@@ -45,6 +45,8 @@\n  * @since 1.0.0\n  */\n public final class AndroidKeystoreKmsClient implements KmsClient {\n+  private static final Object keyCreationLock = new Object();\n+\n   private static final String TAG = AndroidKeystoreKmsClient.class.getSimpleName();\n   private static final int WAIT_TIME_MILLISECONDS_BEFORE_RETRY = 20;\n \n@@ -209,35 +211,39 @@ synchronized boolean hasKey(String keyUri) throws GeneralSecurityException {\n   /**\n    * Generates a new key in Android Keystore, if it doesn't exist.\n    *\n-   * <p>At the moment it can generate only AES256-GCM keys.\n+   * <p>Generates AES256-GCM keys.\n    */\n   @RequiresApi(Build.VERSION_CODES.M)\n   public static Aead getOrGenerateNewAeadKey(String keyUri)\n       throws GeneralSecurityException, IOException {\n     AndroidKeystoreKmsClient client = new AndroidKeystoreKmsClient();\n-    if (!client.hasKey(keyUri)) {\n-      Log.i(TAG, String.format(\"key URI %s doesn't exist, generating a new one\", keyUri));\n-      generateNewAesGcmKeyWithoutExistenceCheck(keyUri);\n+    synchronized (keyCreationLock) {\n+      if (!client.hasKey(keyUri)) {\n+        Log.i(TAG, String.format(\"key URI %s doesn't exist, generating a new one\", keyUri));\n+        generateNewAesGcmKeyWithoutExistenceCheck(keyUri);\n+      }\n     }\n     return client.getAead(keyUri);\n   }\n \n   /**\n    * Generates a new key in Android Keystore.\n    *\n-   * <p>At the moment it can generate only AES256-GCM keys.\n+   * <p>Generates AES256-GCM keys.\n    */\n   @RequiresApi(Build.VERSION_CODES.M)\n   public static void generateNewAeadKey(String keyUri) throws GeneralSecurityException {\n     AndroidKeystoreKmsClient client = new AndroidKeystoreKmsClient();\n-    if (client.hasKey(keyUri)) {\n-      throw new IllegalArgumentException(\n-          String.format(\n-              \"cannot generate a new key %s because it already exists; please delete it with\"\n-                  + \" deleteKey() and try again\",\n-              keyUri));\n+    synchronized (keyCreationLock) {\n+      if (client.hasKey(keyUri)) {\n+        throw new IllegalArgumentException(\n+            String.format(\n+                \"cannot generate a new key %s because it already exists; please delete it with\"\n+                    + \" deleteKey() and try again\",\n+                keyUri));\n+      }\n+      generateNewAesGcmKeyWithoutExistenceCheck(keyUri);\n     }\n-    generateNewAesGcmKeyWithoutExistenceCheck(keyUri);\n   }\n \n   /**",
      "parent_sha": "dcb796d51c5167a1adb2878230d3cd0f3d382374"
    }
  },
  {
    "oid": "4eb63c6073b5b67a091ba773b7ca88e28cf18449",
    "message": "Deprecate KeysetHandle.createFromKey(KeyHandle, KeyAccess).\n\nPiperOrigin-RevId: 384825617",
    "date": "2021-07-15T01:05:17Z",
    "url": "https://github.com/tink-crypto/tink/commit/4eb63c6073b5b67a091ba773b7ca88e28cf18449",
    "details": {
      "sha": "daec8b69aa585f46c7dfc93c010aeeedb9d31e1f",
      "filename": "java_src/src/main/java/com/google/crypto/tink/KeysetHandle.java",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/tink-crypto/tink/blob/4eb63c6073b5b67a091ba773b7ca88e28cf18449/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/4eb63c6073b5b67a091ba773b7ca88e28cf18449/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java?ref=4eb63c6073b5b67a091ba773b7ca88e28cf18449",
      "patch": "@@ -112,7 +112,13 @@ public static final KeysetHandle generateNew(KeyTemplate keyTemplate)\n     return KeysetManager.withEmptyKeyset().rotate(keyTemplate.getProto()).getKeysetHandle();\n   }\n \n-  /** Creates a {@code KeysetHandle} that contains the single {@code KeyHandle} passed as input. */\n+  /**\n+   * Returns a {@code KeysetHandle} that contains the single {@code KeyHandle} passed as input.\n+   *\n+   * @deprecated Use {@code KeysetManager.withEmptyKeyset().add(keyHandle)\n+   *     .setPrimary(keyHandle.getId()).getKeysetHandle()} instead.\n+   */\n+  @Deprecated\n   public static final KeysetHandle createFromKey(KeyHandle keyHandle, KeyAccess access)\n       throws GeneralSecurityException {\n     KeysetManager km = KeysetManager.withEmptyKeyset().add(keyHandle);",
      "parent_sha": "204ce788f70c702848d8314a452f40d8d128c158"
    }
  },
  {
    "oid": "7c3e0caa624e1a65247dd4caf5b4ab71cd538bdb",
    "message": "Clarify the code to create a newKeyId.\n\nI found the previous code hard to understand, since I didn't know to where the \"continue\" statement jumps: there's a for and a while loop. I don't think there's a bug, but I think the new code is much easier to understand anyhow.\n\nPiperOrigin-RevId: 271337855",
    "date": "2019-09-26T13:37:23Z",
    "url": "https://github.com/tink-crypto/tink/commit/7c3e0caa624e1a65247dd4caf5b4ab71cd538bdb",
    "details": {
      "sha": "f925b4e5e5d077347dc0e8692a2c935ceab6a64e",
      "filename": "java/src/main/java/com/google/crypto/tink/KeysetManager.java",
      "status": "modified",
      "additions": 12,
      "deletions": 8,
      "changes": 20,
      "blob_url": "https://github.com/tink-crypto/tink/blob/7c3e0caa624e1a65247dd4caf5b4ab71cd538bdb/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetManager.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/7c3e0caa624e1a65247dd4caf5b4ab71cd538bdb/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetManager.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetManager.java?ref=7c3e0caa624e1a65247dd4caf5b4ab71cd538bdb",
      "patch": "@@ -242,17 +242,21 @@ private synchronized Keyset.Key newKey(KeyTemplate keyTemplate) throws GeneralSe\n         .build();\n   }\n \n+  @GuardedBy(\"this\")\n+  private synchronized boolean keyIdExists(int keyId) {\n+    for (Keyset.Key key : keysetBuilder.getKeyList()) {\n+      if (key.getKeyId() == keyId) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n   @GuardedBy(\"this\")\n   private synchronized int newKeyId() {\n     int keyId = randPositiveInt();\n-    while (true) {\n-      for (Keyset.Key key : keysetBuilder.getKeyList()) {\n-        if (key.getKeyId() == keyId) {\n-          keyId = randPositiveInt();\n-          continue;\n-        }\n-      }\n-      break;\n+    while (keyIdExists(keyId)) {\n+      keyId = randPositiveInt();\n     }\n     return keyId;\n   }",
      "parent_sha": "a283e7eae30d30613b7c0b5c2e24d747ccbc69df"
    }
  },
  {
    "oid": "d1b121c4c97c98838ff82a2195ac2c2430237ca9",
    "message": "Simplifying and clarifying the descriptions of SigUtil.validateRsaSsaPssParams() and SigUtil.toHashType(). The documentation now explicitly says that SHA384 is also a supported hash function.\n\nPiperOrigin-RevId: 367710923",
    "date": "2021-04-09T22:03:29Z",
    "url": "https://github.com/tink-crypto/tink/commit/d1b121c4c97c98838ff82a2195ac2c2430237ca9",
    "details": {
      "sha": "28e70bf80e35dedf6faa4736dd0a4fdc8828e2ea",
      "filename": "java_src/src/main/java/com/google/crypto/tink/signature/SigUtil.java",
      "status": "modified",
      "additions": 9,
      "deletions": 13,
      "changes": 22,
      "blob_url": "https://github.com/tink-crypto/tink/blob/d1b121c4c97c98838ff82a2195ac2c2430237ca9/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsignature%2FSigUtil.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/d1b121c4c97c98838ff82a2195ac2c2430237ca9/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsignature%2FSigUtil.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsignature%2FSigUtil.java?ref=d1b121c4c97c98838ff82a2195ac2c2430237ca9",
      "patch": "@@ -86,18 +86,10 @@ public static void validateRsaSsaPkcs1Params(RsaSsaPkcs1Params params)\n    * Validates RsaSsaPss's parameters.\n    *\n    * <ul>\n-   *   <li>As SHA1 is unsafe, we will only support SHA256 and SHA512 for digital signature.\n-   *   <li>The most common use case is that MGF1 hash is the same as signature hash. This is\n-   *       recommended by RFC https://tools.ietf.org/html/rfc8017#section-8.1. While using different\n-   *       hashes doesn't cause security vulnerabilities, there is also no good reason to support\n-   *       different hashes. Furthermore:\n-   *       <ul>\n-   *         <li>Golang does not support different hashes.\n-   *         <li>BoringSSL supports different hashes just because of historical reason. There is no\n-   *             real use case.\n-   *         <li>Conscrypt/BouncyCastle do not support different hashes.\n-   *       </ul>\n-   * </ul>\n+   *   <li>The MGF1 hash function must be the same as the signature hash function.\n+   *   <li>The hash function used must be either SHA256, SHA384, or SHA512.\n+   *   <li>The salt length must be non-zero.\n+   * <ul>\n    *\n    * @param params the RsaSsaPssParams protocol buffer.\n    * @throws GeneralSecurityException iff it's invalid.\n@@ -113,7 +105,11 @@ public static void validateRsaSsaPssParams(RsaSsaPssParams params)\n     }\n   }\n \n-  /** Converts protobuf enum {@code HashType} to raw Java enum {@code Enums.HashType}. */\n+  /**\n+   * Converts protobuf enum {@code HashType} to raw Java enum {@code Enums.HashType}.\n+   *\n+   * @throws GeneralSecurityException if the HashType is not SHA256, SHA384, or SHA512.\n+   */\n   public static Enums.HashType toHashType(HashType hash) throws GeneralSecurityException {\n     switch (hash) {\n       case SHA256:",
      "parent_sha": "3b9fc66b50adce22b2b3b1c2842ea7f0c48f5fb9"
    }
  },
  {
    "oid": "3ff7eae66f53c190321abd08aa5ddd718aea6189",
    "message": "Rename additional authenticated data to associated data.\n\nPiperOrigin-RevId: 446642190",
    "date": "2022-05-05T07:00:42Z",
    "url": "https://github.com/tink-crypto/tink/commit/3ff7eae66f53c190321abd08aa5ddd718aea6189",
    "details": {
      "sha": "db0624518e1a55cc8160958820ede9d4d2ff7a82",
      "filename": "java_src/src/main/java/com/google/crypto/tink/aead/subtle/AesGcmSiv.java",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/tink-crypto/tink/blob/3ff7eae66f53c190321abd08aa5ddd718aea6189/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Faead%2Fsubtle%2FAesGcmSiv.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/3ff7eae66f53c190321abd08aa5ddd718aea6189/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Faead%2Fsubtle%2FAesGcmSiv.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Faead%2Fsubtle%2FAesGcmSiv.java?ref=3ff7eae66f53c190321abd08aa5ddd718aea6189",
      "patch": "@@ -33,9 +33,9 @@\n /**\n  * This primitive implements AES-GCM-SIV (as defined in RFC 8452) using JCE.\n  *\n- * <p>This encryption mode is intended for authenticated encryption with additional authenticated\n- * data. A major security problem with AES-GCM is that reusing the same nonce twice leaks the\n- * authentication key. AES-GCM-SIV on the other hand has been designed to avoid this vulnerability.\n+ * <p>This encryption mode is intended for authenticated encryption with associated data. A major\n+ * security problem with AES-GCM is that reusing the same nonce twice leaks the authentication key.\n+ * AES-GCM-SIV on the other hand has been designed to avoid this vulnerability.\n  *\n  * <p>This encryption requires a JCE provider that supports the <code>AES/GCM-SIV/NoPadding</code>\n  * transformation such as <a href=\"https://conscrypt.org\">Conscrypt</a>. using JCE.\n@@ -65,11 +65,11 @@ public AesGcmSiv(final byte[] key) throws GeneralSecurityException {\n     keySpec = new SecretKeySpec(key, \"AES\");\n   }\n \n-  @Override\n   /**\n    * On Android KitKat (API level 19) this method does not support non null or non empty {@code\n    * associatedData}. It might not work at all in older versions.\n    */\n+  @Override\n   public byte[] encrypt(final byte[] plaintext, final byte[] associatedData)\n       throws GeneralSecurityException {\n     // Check that ciphertext is not longer than the max. size of a Java array.\n@@ -101,11 +101,11 @@ public byte[] encrypt(final byte[] plaintext, final byte[] associatedData)\n     return ciphertext;\n   }\n \n-  @Override\n   /**\n    * On Android KitKat (API level 19) this method does not support non null or non empty {@code\n    * associatedData}. It might not work at all in older versions.\n    */\n+  @Override\n   public byte[] decrypt(final byte[] ciphertext, final byte[] associatedData)\n       throws GeneralSecurityException {\n     if (ciphertext.length < IV_SIZE_IN_BYTES + TAG_SIZE_IN_BYTES) {",
      "parent_sha": "df05b957ba3c4018095bfb2156d263e2f7121473"
    }
  },
  {
    "oid": "1741ccad61a822cb18ade15da6bec306641b8ab7",
    "message": "Fix function definition comment.\n\nPiperOrigin-RevId: 574406898",
    "date": "2023-10-18T09:08:18Z",
    "url": "https://github.com/tink-crypto/tink/commit/1741ccad61a822cb18ade15da6bec306641b8ab7",
    "details": {
      "sha": "3aeb7c74f2074486a2eae1a4dc0f28eafb358336",
      "filename": "java_src/src/main/java/com/google/crypto/tink/TinkProtoParametersFormat.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/tink-crypto/tink/blob/1741ccad61a822cb18ade15da6bec306641b8ab7/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FTinkProtoParametersFormat.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/1741ccad61a822cb18ade15da6bec306641b8ab7/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FTinkProtoParametersFormat.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FTinkProtoParametersFormat.java?ref=1741ccad61a822cb18ade15da6bec306641b8ab7",
      "patch": "@@ -27,7 +27,7 @@\n /** Functions to parse and serialize Parameters in Tink's binary format based on Protobufs. */\n public final class TinkProtoParametersFormat {\n   /**\n-   * Serializes a parameters object into a byte[] according to Tink's binary format.\n+   * Serializes a Parameters object into a byte[] according to Tink's binary format.\n    */\n   public static byte[] serialize(Parameters parameters) throws GeneralSecurityException {\n     if (parameters instanceof LegacyProtoParameters) {\n@@ -40,7 +40,7 @@ public static byte[] serialize(Parameters parameters) throws GeneralSecurityExce\n   }\n \n   /**\n-   * Parses a byte[] into a parameters object into a byte[] according to Tink's binary format.\n+   * Parses a byte[] into a Parameters object according to Tink's binary format.\n    */\n   public static Parameters parse(byte[] serializedParameters) throws GeneralSecurityException {\n     KeyTemplate t;",
      "parent_sha": "8f5d7ad85625d935f5e3c5c608d2cfd570858d46"
    }
  },
  {
    "oid": "c11e586a75b0618c964f83a4241d7f41a9cab23f",
    "message": "Remove lambda expressions which are not supported in Java 7.\n\nWe'll revisit the decision to support Java 7 when we have more data\non how many users are still running this version.\n\nChange-Id: I2f17ebfb5d412add6ab168d56b7239259f8a17b4\nORIGINAL_AUTHOR=Thai Duong <thaidn@google.com>\nGitOrigin-RevId: 02715993144b4786e6527d4933094a24f15ededa",
    "date": "2017-07-11T03:31:45Z",
    "url": "https://github.com/tink-crypto/tink/commit/c11e586a75b0618c964f83a4241d7f41a9cab23f",
    "details": {
      "sha": "54a8936a709782d02ed5086c0627dc5636ac71a8",
      "filename": "java/src/test/java/com/google/crypto/tink/subtle/AesGcmHkdfStreamingTest.java",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/tink-crypto/tink/blob/c11e586a75b0618c964f83a4241d7f41a9cab23f/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FAesGcmHkdfStreamingTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/c11e586a75b0618c964f83a4241d7f41a9cab23f/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FAesGcmHkdfStreamingTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FAesGcmHkdfStreamingTest.java?ref=c11e586a75b0618c964f83a4241d7f41a9cab23f",
      "patch": "@@ -730,7 +730,11 @@ private ReadableByteChannel ciphertextChannel(\n     PipedOutputStream output = new PipedOutputStream();\n     PipedInputStream result = new PipedInputStream(output);\n     WritableByteChannel ciphertext = Channels.newChannel(output);\n-    new Thread(() -> encryptChannel(ags, plaintext, ciphertext, aad, chunkSize)).start();\n+    new Thread(new Runnable() {\n+      public void run() {\n+        encryptChannel(ags, plaintext, ciphertext, aad, chunkSize);\n+      }\n+    }).start();\n     return Channels.newChannel(result);\n   }\n ",
      "parent_sha": "6ccbf12a22e8817d7da5ec0b9912ee98522e911c"
    }
  },
  {
    "oid": "fee536b202af967e99e6a52bfa43089d1817c236",
    "message": "Deprecate JsonKeysetReader#withBytes.\n\nPiperOrigin-RevId: 563435512",
    "date": "2023-09-07T15:14:56Z",
    "url": "https://github.com/tink-crypto/tink/commit/fee536b202af967e99e6a52bfa43089d1817c236",
    "details": {
      "sha": "93e78e99301fd765ef936ff1dce57fef01078874",
      "filename": "java_src/src/main/java/com/google/crypto/tink/JsonKeysetReader.java",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/tink-crypto/tink/blob/fee536b202af967e99e6a52bfa43089d1817c236/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FJsonKeysetReader.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/fee536b202af967e99e6a52bfa43089d1817c236/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FJsonKeysetReader.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FJsonKeysetReader.java?ref=fee536b202af967e99e6a52bfa43089d1817c236",
      "patch": "@@ -89,7 +89,12 @@ public static JsonKeysetReader withString(String input) {\n     return new JsonKeysetReader(new ByteArrayInputStream(input.getBytes(UTF_8)));\n   }\n \n-  /** Static method to create a JsonKeysetReader from a byte array. */\n+  /**\n+   * Static method to create a JsonKeysetReader from a byte array.\n+   *\n+   * @deprecated Use TinkJsonProtoKeysetFormat.parseKeyset() instead.\n+   */\n+  @Deprecated\n   public static JsonKeysetReader withBytes(final byte[] bytes) {\n     return new JsonKeysetReader(new ByteArrayInputStream(bytes));\n   }",
      "parent_sha": "9fbbf93bcbdacda9c8a986900eb5e29fce350551"
    }
  },
  {
    "oid": "98a055ef480d7e78b9b199e384ed8ca9e8eb0fbe",
    "message": "Fix race condition in AndroidKeysetManager's build().\n\nThe build() function is synchronized, but unfortunately that does not help when there are more than one builder object, which is usually the case. This change now adds a global lock to the build function, to make sure that only one thread can be running the build() function.\n\nNote that this fix has already been added to \"EncryptedFile\" class in android in:\nhttps://android-review.googlesource.com/c/platform/frameworks/support/+/2257884\n\nPiperOrigin-RevId: 496589296",
    "date": "2022-12-20T08:41:44Z",
    "url": "https://github.com/tink-crypto/tink/commit/98a055ef480d7e78b9b199e384ed8ca9e8eb0fbe",
    "details": {
      "sha": "56a169b224af89a63e459c3fecfaf69b322bc0c1",
      "filename": "java_src/src/main/java/com/google/crypto/tink/integration/android/AndroidKeysetManager.java",
      "status": "modified",
      "additions": 13,
      "deletions": 8,
      "changes": 21,
      "blob_url": "https://github.com/tink-crypto/tink/blob/98a055ef480d7e78b9b199e384ed8ca9e8eb0fbe/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeysetManager.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/98a055ef480d7e78b9b199e384ed8ca9e8eb0fbe/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeysetManager.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeysetManager.java?ref=98a055ef480d7e78b9b199e384ed8ca9e8eb0fbe",
      "patch": "@@ -122,6 +122,8 @@\n  * @since 1.0.0\n  */\n public final class AndroidKeysetManager {\n+  private static final Object lock = new Object();\n+\n   private static final String TAG = AndroidKeysetManager.class.getSimpleName();\n   private final KeysetWriter writer;\n   private final Aead masterKey;\n@@ -242,12 +244,17 @@ Builder withKeyStore(KeyStore val) {\n      * @throws GeneralSecurityException If cannot read an existing keyset or generate a new one.\n      */\n     public synchronized AndroidKeysetManager build() throws GeneralSecurityException, IOException {\n-      if (masterKeyUri != null) {\n-        masterKey = readOrGenerateNewMasterKey();\n-      }\n-      this.keysetManager = readOrGenerateNewKeyset();\n+      // readOrGenerateNewMasterKey() and readOrGenerateNewKeyset() involve shared pref filesystem\n+      // operations. To control access to this global state in multi-threaded contexts we need to\n+      // ensure mutual exclusion of these functions.\n+      synchronized (lock) {\n+        if (masterKeyUri != null) {\n+          masterKey = readOrGenerateNewMasterKey();\n+        }\n+        this.keysetManager = readOrGenerateNewKeyset();\n \n-      return new AndroidKeysetManager(this);\n+        return new AndroidKeysetManager(this);\n+      }\n     }\n \n     @Nullable\n@@ -343,9 +350,7 @@ private KeysetManager read() throws GeneralSecurityException, IOException {\n     }\n   }\n \n-  /**\n-   * @return a {@link KeysetHandle} of the managed keyset\n-   */\n+  /** Returns a {@link KeysetHandle} of the managed keyset. */\n   public synchronized KeysetHandle getKeysetHandle() throws GeneralSecurityException {\n     return keysetManager.getKeysetHandle();\n   }",
      "parent_sha": "30dd1f28d30f57c22646b0fad698035b646d1d03"
    }
  },
  {
    "oid": "b5c6f5162bf2596ab79cfa5020c942ffc9c18bf9",
    "message": "Fixed bug found by test where the ciphertext was not the same for null and empty aad even though the decryption worked",
    "date": "2019-11-19T04:07:55Z",
    "url": "https://github.com/tink-crypto/tink/commit/b5c6f5162bf2596ab79cfa5020c942ffc9c18bf9",
    "details": {
      "sha": "148776049804f1d2958f58934adfc31a5bbd805c",
      "filename": "java/src/main/java/com/google/crypto/tink/subtle/AesSiv.java",
      "status": "modified",
      "additions": 6,
      "deletions": 3,
      "changes": 9,
      "blob_url": "https://github.com/tink-crypto/tink/blob/b5c6f5162bf2596ab79cfa5020c942ffc9c18bf9/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FAesSiv.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/b5c6f5162bf2596ab79cfa5020c942ffc9c18bf9/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FAesSiv.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FAesSiv.java?ref=b5c6f5162bf2596ab79cfa5020c942ffc9c18bf9",
      "patch": "@@ -76,10 +76,13 @@ private byte[] s2v(final byte[]... s) throws GeneralSecurityException {\n \n     byte[] result = cmacForS2V.computeMac(BLOCK_ZERO);\n     for (int i = 0; i < s.length - 1; i++) {\n-      byte[] currBlock = s[i];\n-      if (currBlock != null) {\n-        result = Bytes.xor(AesUtil.dbl(result), cmacForS2V.computeMac(currBlock));\n+      final byte[] currBlock;\n+      if (s[i] == null) {\n+        currBlock = new byte[0];\n+      } else {\n+        currBlock = s[i];\n       }\n+      result = Bytes.xor(AesUtil.dbl(result), cmacForS2V.computeMac(currBlock));\n     }\n     byte[] lastBlock = s[s.length - 1];\n     if (lastBlock.length >= 16) {",
      "parent_sha": "d79a5dd21587498e9c843faee284a0e18d7184c7"
    }
  },
  {
    "oid": "a14cdf3e36d2207b4849e28fff402f40cb69549a",
    "message": "Make \"equalsKeyset\" public.\n\nPiperOrigin-RevId: 547224118",
    "date": "2023-07-11T17:12:13Z",
    "url": "https://github.com/tink-crypto/tink/commit/a14cdf3e36d2207b4849e28fff402f40cb69549a",
    "details": {
      "sha": "24bc7f18da435d97a01ddf74ac9635d6277075dc",
      "filename": "java_src/src/main/java/com/google/crypto/tink/KeysetHandle.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/tink-crypto/tink/blob/a14cdf3e36d2207b4849e28fff402f40cb69549a/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/a14cdf3e36d2207b4849e28fff402f40cb69549a/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java?ref=a14cdf3e36d2207b4849e28fff402f40cb69549a",
      "patch": "@@ -1222,7 +1222,7 @@ private <B> B getFullPrimitiveOrNull(\n    * which are irrelevant to the function computed. Currently, keysets can also be invalid in which\n    * case this will return false.\n    */\n-  boolean equalsKeyset(KeysetHandle other) {\n+  public boolean equalsKeyset(KeysetHandle other) {\n     if (size() != other.size()) {\n       return false;\n     }",
      "parent_sha": "2c21a67ee63ccd45728eadd10dfce04ce550e1fd"
    }
  },
  {
    "oid": "34c8310876a0e990447542e40dd2daf29792df54",
    "message": "Fix the continuous test.\n\nPiperOrigin-RevId: 218668026\nGitOrigin-RevId: 879a56846bdb2ab7efb1cd56aa2f4ccf435329a4",
    "date": "2018-10-25T18:16:01Z",
    "url": "https://github.com/tink-crypto/tink/commit/34c8310876a0e990447542e40dd2daf29792df54",
    "details": {
      "sha": "7ab7f220fe5b650836ccfa60dc00a60702397a6b",
      "filename": "java/src/test/java/com/google/crypto/tink/subtle/X25519Test.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/tink-crypto/tink/blob/34c8310876a0e990447542e40dd2daf29792df54/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FX25519Test.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/34c8310876a0e990447542e40dd2daf29792df54/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FX25519Test.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FX25519Test.java?ref=34c8310876a0e990447542e40dd2daf29792df54",
      "patch": "@@ -143,6 +143,7 @@ public void testComputeSharedSecretWithWycheproofVectors() throws Exception {\n     for (int i = 0; i < testGroups.length(); i++) {\n       JSONObject group = testGroups.getJSONObject(i);\n       JSONArray tests = group.getJSONArray(\"tests\");\n+      String curve = group.getString(\"curve\");\n       for (int j = 0; j < tests.length(); j++) {\n         JSONObject testcase = tests.getJSONObject(j);\n         String tcId =\n@@ -152,7 +153,6 @@ public void testComputeSharedSecretWithWycheproofVectors() throws Exception {\n         String hexPubKey = testcase.getString(\"public\");\n         String hexPrivKey = testcase.getString(\"private\");\n         String expectedSharedSecret = testcase.getString(\"shared\");\n-        String curve = testcase.getString(\"curve\");\n         if (!curve.equals(\"curve25519\")) {\n           System.out.printf(\"Skipping %s, unknown curve name: %s\", tcId, curve);\n           cntSkippedTests++;",
      "parent_sha": "8e19ab5bc9a815bd4d791e2e33de0747b0e7bfa8"
    }
  },
  {
    "oid": "993866adfa43b3eb5bee9e1ae406a5aadca287c5",
    "message": "Use \"charAt\" instead of \"toCharArray\" because it is more efficient.\n\nPiperOrigin-RevId: 390998910",
    "date": "2021-08-16T09:26:52Z",
    "url": "https://github.com/tink-crypto/tink/commit/993866adfa43b3eb5bee9e1ae406a5aadca287c5",
    "details": {
      "sha": "ce54c65f48c7d91d16c729b1bb168aae5aeabdc3",
      "filename": "java_src/src/main/java/com/google/crypto/tink/jwt/JwtFormat.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/tink-crypto/tink/blob/993866adfa43b3eb5bee9e1ae406a5aadca287c5/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FJwtFormat.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/993866adfa43b3eb5bee9e1ae406a5aadca287c5/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FJwtFormat.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FJwtFormat.java?ref=993866adfa43b3eb5bee9e1ae406a5aadca287c5",
      "patch": "@@ -66,7 +66,8 @@ static void validateUtf8(byte[] data) throws JwtInvalidException {\n   }\n \n   static byte[] strictUrlSafeDecode(String encodedData) throws JwtInvalidException {\n-    for (char c : encodedData.toCharArray()) {\n+    for (int i = 0; i < encodedData.length(); i++) {\n+      char c = encodedData.charAt(i);\n       if (!isValidUrlsafeBase64Char(c)) {\n         throw new JwtInvalidException(\"invalid encoding\");\n       }\n@@ -226,7 +227,8 @@ static String createSignedCompact(String unsignedCompact, byte[] signature) {\n   }\n \n   static void validateASCII(String data) throws JwtInvalidException {\n-    for (char c : data.toCharArray()) {\n+    for (int i = 0; i < data.length(); i++) {\n+      char c = data.charAt(i);\n       if ((c & 0x80) > 0) {\n         throw new JwtInvalidException(\"Non ascii character\");\n       }",
      "parent_sha": "69d976c4e52e1d2f56dad4fe16a180109bf97601"
    }
  },
  {
    "oid": "592c2eb1847a24f3eec4540c2fbcf12a33232c48",
    "message": "Return a better error when a keyset gets decrypted with the wrong master key.\n\nWe also need to better handle when the master key is missing, but for that we first need to refactor the code a bit.\n\nPiperOrigin-RevId: 503393910",
    "date": "2023-01-20T10:39:16Z",
    "url": "https://github.com/tink-crypto/tink/commit/592c2eb1847a24f3eec4540c2fbcf12a33232c48",
    "details": {
      "sha": "4b730adf734325941f61d8cd1729b70b3d7da604",
      "filename": "java_src/src/main/java/com/google/crypto/tink/integration/android/AndroidKeysetManager.java",
      "status": "modified",
      "additions": 11,
      "deletions": 3,
      "changes": 14,
      "blob_url": "https://github.com/tink-crypto/tink/blob/592c2eb1847a24f3eec4540c2fbcf12a33232c48/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeysetManager.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/592c2eb1847a24f3eec4540c2fbcf12a33232c48/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeysetManager.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeysetManager.java?ref=592c2eb1847a24f3eec4540c2fbcf12a33232c48",
      "patch": "@@ -326,12 +326,13 @@ private KeysetManager readOrGenerateNewKeyset() throws GeneralSecurityException,\n       return manager;\n     }\n \n+    @SuppressWarnings(\"UnusedException\")\n     private KeysetManager read() throws GeneralSecurityException, IOException {\n       if (masterKey != null) {\n         try {\n           return KeysetManager.withKeysetHandle(KeysetHandle.read(reader, masterKey));\n         } catch (InvalidProtocolBufferException | GeneralSecurityException ex) {\n-          // Swallow the exception and attempt to read the keyset in cleartext.\n+          // Attempt to read the keyset in cleartext.\n           // This edge case may happen when either\n           //   - the keyset was generated on a pre M phone which is then upgraded to M or newer, or\n           //   - the keyset was generated with Keystore being disabled, then Keystore is enabled.\n@@ -340,9 +341,16 @@ private KeysetManager read() throws GeneralSecurityException, IOException {\n           // cleartext value that it controls. This does not introduce new security risks because to\n           // overwrite the encrypted keyset in private preferences of an app, said adversaries must\n           // have the same privilege as the app, thus they can call Android Keystore to read or\n-          // write\n-          // the encrypted keyset in the first place.\n+          // write the encrypted keyset in the first place.\n           Log.w(TAG, \"cannot decrypt keyset: \", ex);\n+          try {\n+            return KeysetManager.withKeysetHandle(CleartextKeysetHandle.read(reader));\n+          } catch (InvalidProtocolBufferException ex2) {\n+            // Raising a InvalidProtocolBufferException error here would be confusing, because\n+            // parsing probably failed because the keyset was encrypted but we were not able to\n+            // decrypt it. It is better to throw the error above.\n+            throw ex;\n+          }\n         }\n       }\n ",
      "parent_sha": "311ec9fe26d98ec5bb3e57fc421bc30c637876d6"
    }
  },
  {
    "oid": "420d2b88e97ac96fe6300c6327eff0a70c4f97cc",
    "message": "Run more repetitions in the RegistryMultithreadTest\n\nPiperOrigin-RevId: 452022160",
    "date": "2022-05-31T12:40:25Z",
    "url": "https://github.com/tink-crypto/tink/commit/420d2b88e97ac96fe6300c6327eff0a70c4f97cc",
    "details": {
      "sha": "1dd7a41420fa6d988e08b8853d104ebf450d16f2",
      "filename": "java_src/src/test/java/com/google/crypto/tink/RegistryMultithreadTest.java",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/tink-crypto/tink/blob/420d2b88e97ac96fe6300c6327eff0a70c4f97cc/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistryMultithreadTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/420d2b88e97ac96fe6300c6327eff0a70c4f97cc/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistryMultithreadTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistryMultithreadTest.java?ref=420d2b88e97ac96fe6300c6327eff0a70c4f97cc",
      "patch": "@@ -199,6 +199,8 @@ public Ed25519PublicKey getPublicKey(Ed25519PrivateKey privateKey) {\n     }\n   }\n \n+  private static final int REPETITIONS = 1000;\n+\n   @Test\n   public void registerAndGetKeyManager_works() throws Exception {\n     ExecutorService threadPool = Executors.newFixedThreadPool(4);\n@@ -213,8 +215,7 @@ public void registerAndGetKeyManager_works() throws Exception {\n         threadPool.submit(\n             () -> {\n               try {\n-\n-                for (int i = 0; i < 100; ++i) {\n+                for (int i = 0; i < REPETITIONS; ++i) {\n                   Registry.registerKeyManager(new TestKeyManager(\"KeyManager\" + i), false);\n                 }\n               } catch (GeneralSecurityException e) {\n@@ -225,7 +226,7 @@ public void registerAndGetKeyManager_works() throws Exception {\n         threadPool.submit(\n             () -> {\n               try {\n-                for (int i = 0; i < 100; ++i) {\n+                for (int i = 0; i < REPETITIONS; ++i) {\n                   Registry.registerKeyManager(new TestKeyTypeManager(\"KeyTypeManager\" + i), false);\n                 }\n               } catch (GeneralSecurityException e) {\n@@ -236,7 +237,7 @@ public void registerAndGetKeyManager_works() throws Exception {\n         threadPool.submit(\n             () -> {\n               try {\n-                for (int i = 0; i < 100; ++i) {\n+                for (int i = 0; i < REPETITIONS; ++i) {\n                   Registry.registerAsymmetricKeyManagers(\n                       new TestPrivateKeyTypeManager(\"Private\" + i),\n                       new TestPublicKeyTypeManager(\"Public\" + i),\n@@ -250,7 +251,7 @@ public void registerAndGetKeyManager_works() throws Exception {\n         threadPool.submit(\n             () -> {\n               try {\n-                for (int i = 0; i < 100; ++i) {\n+                for (int i = 0; i < REPETITIONS; ++i) {\n \n                   Registry.getKeyManager(\"KeyManagerStart\");\n                   Registry.getKeyManager(\"KeyTypeManagerStart\");",
      "parent_sha": "34b9120e6cda2e71b760803850f0ddc9181bafc1"
    }
  },
  {
    "oid": "abfb82003b04abc1970cd6d0a40caa5954bdfdaa",
    "message": "Rename some variables and functions in AndroidKeystoreAesGcm.\n\nThese names match what we use elsewhere.\n\nPiperOrigin-RevId: 504491331",
    "date": "2023-01-25T09:15:32Z",
    "url": "https://github.com/tink-crypto/tink/commit/abfb82003b04abc1970cd6d0a40caa5954bdfdaa",
    "details": {
      "sha": "f0453a3a35b3d0d7e67816607a7541f4ac6366be",
      "filename": "java_src/src/main/java/com/google/crypto/tink/integration/android/AndroidKeystoreAesGcm.java",
      "status": "modified",
      "additions": 14,
      "deletions": 13,
      "changes": 27,
      "blob_url": "https://github.com/tink-crypto/tink/blob/abfb82003b04abc1970cd6d0a40caa5954bdfdaa/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeystoreAesGcm.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/abfb82003b04abc1970cd6d0a40caa5954bdfdaa/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeystoreAesGcm.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeystoreAesGcm.java?ref=abfb82003b04abc1970cd6d0a40caa5954bdfdaa",
      "patch": "@@ -63,18 +63,18 @@ public AndroidKeystoreAesGcm(String keyId) throws GeneralSecurityException, IOEx\n   }\n \n   @Override\n-  public byte[] encrypt(final byte[] plaintext, final byte[] aad)\n+  public byte[] encrypt(final byte[] plaintext, final byte[] associatedData)\n       throws GeneralSecurityException {\n     try {\n-      return encryptInternal(plaintext, aad);\n+      return encryptInternal(plaintext, associatedData);\n     } catch (ProviderException | GeneralSecurityException ex) {\n       Log.w(TAG, \"encountered a potentially transient KeyStore error, will wait and retry\", ex);\n-      sleep();\n-      return encryptInternal(plaintext, aad);\n+      sleepRandomAmount();\n+      return encryptInternal(plaintext, associatedData);\n     }\n   }\n \n-  private byte[] encryptInternal(final byte[] plaintext, final byte[] aad)\n+  private byte[] encryptInternal(final byte[] plaintext, final byte[] associatedData)\n       throws GeneralSecurityException {\n     // Check that ciphertext is not longer than the max. size of a Java array.\n     if (plaintext.length > Integer.MAX_VALUE - IV_SIZE_IN_BYTES - TAG_SIZE_IN_BYTES) {\n@@ -83,7 +83,7 @@ private byte[] encryptInternal(final byte[] plaintext, final byte[] aad)\n     byte[] ciphertext = new byte[IV_SIZE_IN_BYTES + plaintext.length + TAG_SIZE_IN_BYTES];\n     Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");\n     cipher.init(Cipher.ENCRYPT_MODE, key);\n-    cipher.updateAAD(aad);\n+    cipher.updateAAD(associatedData);\n     int unusedWritten =\n         cipher.doFinal(plaintext, 0, plaintext.length, ciphertext, IV_SIZE_IN_BYTES);\n     // Copy the IV that is randomly generated by Android Keystore.\n@@ -92,32 +92,33 @@ private byte[] encryptInternal(final byte[] plaintext, final byte[] aad)\n   }\n \n   @Override\n-  public byte[] decrypt(final byte[] ciphertext, final byte[] aad) throws GeneralSecurityException {\n+  public byte[] decrypt(final byte[] ciphertext, final byte[] associatedData)\n+      throws GeneralSecurityException {\n     if (ciphertext.length < IV_SIZE_IN_BYTES + TAG_SIZE_IN_BYTES) {\n       throw new GeneralSecurityException(\"ciphertext too short\");\n     }\n     try {\n-      return decryptInternal(ciphertext, aad);\n+      return decryptInternal(ciphertext, associatedData);\n     } catch (AEADBadTagException ex) {\n       throw ex;\n     } catch (ProviderException | GeneralSecurityException ex) {\n       Log.w(TAG, \"encountered a potentially transient KeyStore error, will wait and retry\", ex);\n-      sleep();\n-      return decryptInternal(ciphertext, aad);\n+      sleepRandomAmount();\n+      return decryptInternal(ciphertext, associatedData);\n     }\n   }\n \n-  private byte[] decryptInternal(final byte[] ciphertext, final byte[] aad)\n+  private byte[] decryptInternal(final byte[] ciphertext, final byte[] associatedData)\n       throws GeneralSecurityException {\n     GCMParameterSpec params =\n         new GCMParameterSpec(8 * TAG_SIZE_IN_BYTES, ciphertext, 0, IV_SIZE_IN_BYTES);\n     Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");\n     cipher.init(Cipher.DECRYPT_MODE, key, params);\n-    cipher.updateAAD(aad);\n+    cipher.updateAAD(associatedData);\n     return cipher.doFinal(ciphertext, IV_SIZE_IN_BYTES, ciphertext.length - IV_SIZE_IN_BYTES);\n   }\n \n-  private static void sleep() {\n+  private static void sleepRandomAmount() {\n     int waitTimeMillis = (int) (Math.random() * MAX_WAIT_TIME_MILLISECONDS_BEFORE_RETRY);\n     try {\n       Thread.sleep(waitTimeMillis);",
      "parent_sha": "70f226b5793abfa382d365488a17d475a09bbf13"
    }
  },
  {
    "oid": "0ef18346e33f4048ab9178374e40595fab873a9d",
    "message": "Make generateNewAesGcmKeyWithoutExistenceCheck private.\n\nAnd remove it from tests.\n\nPiperOrigin-RevId: 612842627",
    "date": "2024-03-05T16:01:01Z",
    "url": "https://github.com/tink-crypto/tink/commit/0ef18346e33f4048ab9178374e40595fab873a9d",
    "details": {
      "sha": "b54c5b53b7bc3e6d03be0093c21fa9376788bf02",
      "filename": "java_src/src/main/java/com/google/crypto/tink/integration/android/AndroidKeystoreKmsClient.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/tink-crypto/tink/blob/0ef18346e33f4048ab9178374e40595fab873a9d/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeystoreKmsClient.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/0ef18346e33f4048ab9178374e40595fab873a9d/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeystoreKmsClient.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeystoreKmsClient.java?ref=0ef18346e33f4048ab9178374e40595fab873a9d",
      "patch": "@@ -245,7 +245,7 @@ public static void generateNewAeadKey(String keyUri) throws GeneralSecurityExcep\n    * <p>This function does not check if the key already exists, and will overwrite any existing key.\n    */\n   @RequiresApi(Build.VERSION_CODES.M)\n-  static void generateNewAesGcmKeyWithoutExistenceCheck(String keyUri)\n+  private static void generateNewAesGcmKeyWithoutExistenceCheck(String keyUri)\n       throws GeneralSecurityException {\n     String keyId = Validators.validateKmsKeyUriAndRemovePrefix(PREFIX, keyUri);\n     KeyGenerator keyGenerator =",
      "parent_sha": "17a4fdc37e971d9f8b516ed664986cd602bb4bb9"
    }
  },
  {
    "oid": "6f0c41bb83a8ffde90ea450dd3367f09cb768299",
    "message": "Clean up javadoc in Registry.java.\n\nPiperOrigin-RevId: 268279920",
    "date": "2019-09-10T19:16:13Z",
    "url": "https://github.com/tink-crypto/tink/commit/6f0c41bb83a8ffde90ea450dd3367f09cb768299",
    "details": {
      "sha": "a7feac1880269a305e8bc7882c94a943413a2552",
      "filename": "java/src/main/java/com/google/crypto/tink/Registry.java",
      "status": "modified",
      "additions": 20,
      "deletions": 19,
      "changes": 39,
      "blob_url": "https://github.com/tink-crypto/tink/blob/6f0c41bb83a8ffde90ea450dd3367f09cb768299/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistry.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/6f0c41bb83a8ffde90ea450dd3367f09cb768299/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistry.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistry.java?ref=6f0c41bb83a8ffde90ea450dd3367f09cb768299",
      "patch": "@@ -48,7 +48,7 @@\n  * and query the Registry for specific KeyManagers and PrimitiveWrappers. Registry is public though,\n  * to enable configurations with custom catalogues, primitives or KeyManagers.\n  *\n- * <p>To initialize the Registry with all key managers in Tink 1.0.0, one can do as follows:\n+ * <p>To initialize the Registry with all key managers:\n  *\n  * <pre>{@code\n  * TinkConfig.register();\n@@ -86,7 +86,7 @@ public final class Registry {\n       new ConcurrentHashMap<>();\n \n   /**\n-   * A container which either is constructed from an {@link KeyTypeManager} or from a {@link\n+   * A container which either is constructed from a {@link KeyTypeManager} or from a {@link\n    * KeyManager}.\n    */\n   private static interface KeyManagerContainer {\n@@ -265,8 +265,8 @@ static synchronized void reset() {\n    * throw exception if {@code catalogue} and the existing catalogue aren't instances of the same\n    * class, and do nothing if they are.\n    *\n-   * @throws GeneralSecurityException if there's an existing catalogue is not an instance of the\n-   *     same class as {@code catalogue}\n+   * @throws GeneralSecurityException if there's an existing catalogue and it is not an instance of\n+   *     the same class as {@code catalogue}\n    * @deprecated Catalogues are no longer supported.\n    */\n   @Deprecated\n@@ -294,7 +294,7 @@ public static synchronized void addCatalogue(String catalogueName, Catalogue<?>\n    * Tries to get a catalogue associated with {@code catalogueName}.\n    *\n    * @deprecated Catalogues are no longer supported.\n-   * @throws GeneralSecurityException if cannot find any catalogue\n+   * @throws GeneralSecurityException if no catalogue is found\n    */\n   @Deprecated\n   public static Catalogue<?> getCatalogue(String catalogueName)\n@@ -486,12 +486,12 @@ void registerAsymmetricKeyManagers(\n    * Tries to register {@code manager} for the given {@code typeUrl}. Users can generate new keys\n    * with this manager using the {@link Registry#newKey} methods.\n    *\n-   * <p>If there is an existing key manager, throw exception if {@code manager} and the existing\n-   * key manager aren't instances of the same class, and do nothing if they are.\n+   * <p>Does nothing if there's an existing key manager and it's an instance of the same class as\n+   * {@code manager}.\n    *\n-   * @throws GeneralSecurityException if there's an existing key manager is not an instance of the\n-   *     class of {@code manager}\n-   * @deprecated use {@link #registerKeyManager(KeyManager<P>)}\n+   * @throws GeneralSecurityException if there's an existing key manager and it is not an instance\n+   *     of the same class as {@code manager}\n+   * @deprecated use {@link #registerKeyManager(KeyManager) registerKeyManager(KeyManager&lt;P&gt;)}\n    */\n   @Deprecated\n   public static synchronized <P> void registerKeyManager(\n@@ -503,12 +503,13 @@ public static synchronized <P> void registerKeyManager(\n    * Tries to register {@code manager} for the given {@code typeUrl}. If {@code newKeyAllowed} is\n    * true, users can generate new keys with this manager using the {@link Registry#newKey} methods.\n    *\n-   * <p>If there is an existing key manager, throw exception if {@code manager} and the existing\n-   * key manager aren't instances of the same class, and do nothing if they are.\n+   * <p>Does nothing if there's an existing key manager and it's an instance of the same class as\n+   * {@code manager}.\n    *\n-   * @throws GeneralSecurityException if there's an existing key manager is not an instance of the\n-   *     class of {@code manager}\n-   * @deprecated use {@link #registerKeyManager(KeyManager<P>, boolean)}\n+   * @throws GeneralSecurityException if there's an existing key manager and it is not an instance\n+   *     of the same class as {@code manager}\n+   * @deprecated use {@link #registerKeyManager(KeyManager, boolean)\n+   *     registerKeyManager(KeyManager&lt;P&gt;, boolean)}\n    */\n   @Deprecated\n   public static synchronized <P> void registerKeyManager(\n@@ -527,14 +528,14 @@ public static synchronized <P> void registerKeyManager(\n   /**\n    * Tries to register {@code wrapper} as a new SetWrapper for primitive {@code P}.\n    *\n-   * <p>If no SetWrapper is registered for {@code P} registers the given one. If already is a\n+   * <p>If no SetWrapper is registered for {@code P}, registers the given one. If there already is a\n    * SetWrapper registered which is of the same class ass the passed in set wrapper, the call is\n    * silently ignored. If the new set wrapper is of a different type, the call fails with a {@code\n    * GeneralSecurityException}.\n    *\n-   * @throws GeneralSecurityException if there's an existing key manager is not an instance of the\n-   *     class of {@code manager}, or the registration tries to re-enable the generation of new\n-   *     keys.\n+   * @throws GeneralSecurityException if there's an existing key manager and it is not an instance\n+   *     of the class of {@code manager}, or the registration tries to re-enable the generation of\n+   *     new keys.\n    */\n   public static synchronized <P> void registerPrimitiveWrapper(final PrimitiveWrapper<P> wrapper)\n       throws GeneralSecurityException {",
      "parent_sha": "71a2aae6dcda00fc73b8dccab256f89839e803a0"
    }
  },
  {
    "oid": "89859790844186aa578bcea0323998d57f73290c",
    "message": "Changing Java EAX implementation to be as constant time as can be hoped for Java\n\nPiperOrigin-RevId: 359153691",
    "date": "2021-02-23T23:51:59Z",
    "url": "https://github.com/tink-crypto/tink/commit/89859790844186aa578bcea0323998d57f73290c",
    "details": {
      "sha": "572a9e1589a77e93f835f4d00fd011652c4c4f0b",
      "filename": "java_src/src/main/java/com/google/crypto/tink/subtle/AesEaxJce.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/tink-crypto/tink/blob/89859790844186aa578bcea0323998d57f73290c/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FAesEaxJce.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/89859790844186aa578bcea0323998d57f73290c/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FAesEaxJce.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FAesEaxJce.java?ref=89859790844186aa578bcea0323998d57f73290c",
      "patch": "@@ -121,7 +121,7 @@ private static byte[] multiplyByX(final byte[] block) {\n     }\n     // Shifts the least significant block by 1 bit and reduces the msb modulo the polynomial.\n     res[BLOCK_SIZE_IN_BYTES - 1] =\n-        (byte) ((block[BLOCK_SIZE_IN_BYTES - 1] << 1) ^ ((block[0] & 0x80) == 0 ? 0 : 0x87));\n+        (byte) ((block[BLOCK_SIZE_IN_BYTES - 1] << 1) ^ ((block[0] >> 7) & 0x87));\n     return res;\n   }\n ",
      "parent_sha": "f6b503f00f4ba3f29b6267a0ba1ae18232602a88"
    }
  },
  {
    "oid": "3be932cde3911dec3f15aa84de9aeeb7d002038f",
    "message": "Update AES-SIV javadoc to clarify key size.\n\nPiperOrigin-RevId: 230803410\nGitOrigin-RevId: b6eca09b078daba726e6d5cb41b8daeb8d7eded1",
    "date": "2019-01-25T21:17:03Z",
    "url": "https://github.com/tink-crypto/tink/commit/3be932cde3911dec3f15aa84de9aeeb7d002038f",
    "details": {
      "sha": "621883abc0b3c3a40b58cd9daa84ee83e8ba3918",
      "filename": "java/src/main/java/com/google/crypto/tink/subtle/AesSiv.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/tink-crypto/tink/blob/3be932cde3911dec3f15aa84de9aeeb7d002038f/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FAesSiv.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/3be932cde3911dec3f15aa84de9aeeb7d002038f/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FAesSiv.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FAesSiv.java?ref=3be932cde3911dec3f15aa84de9aeeb7d002038f",
      "patch": "@@ -29,8 +29,9 @@\n /**\n  * AES-SIV, as described in <a href=\"https://tools.ietf.org/html/rfc5297\">RFC 5297</a>.\n  *\n- * <p>To meet the security requirements of {@link DeterministicAead}, this cipher can only be used\n- * with 256-bit keys.\n+ * <p>Each AES-SIV key consists of two sub keys. To meet the security requirements of {@link\n+ * DeterministicAead}, each sub key must be 256 bits. The total size of ASE-SIV keys is then 512\n+ * bits.\n  *\n  * @since 1.1.0\n  */",
      "parent_sha": "621b573ea034f95e9ac7c50aca31d5e6c5250684"
    }
  },
  {
    "oid": "0150d869accc7680e2bffa51e80af37ff3b469ff",
    "message": "Deprecate JsonKeysetReader.withFile and JsonKeysetReader.withPath.\n\nPiperOrigin-RevId: 481913791",
    "date": "2022-10-18T14:22:47Z",
    "url": "https://github.com/tink-crypto/tink/commit/0150d869accc7680e2bffa51e80af37ff3b469ff",
    "details": {
      "sha": "85848946e06b6711410b326fec137550ed422a57",
      "filename": "java_src/src/main/java/com/google/crypto/tink/JsonKeysetReader.java",
      "status": "modified",
      "additions": 21,
      "deletions": 4,
      "changes": 25,
      "blob_url": "https://github.com/tink-crypto/tink/blob/0150d869accc7680e2bffa51e80af37ff3b469ff/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FJsonKeysetReader.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/0150d869accc7680e2bffa51e80af37ff3b469ff/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FJsonKeysetReader.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FJsonKeysetReader.java?ref=0150d869accc7680e2bffa51e80af37ff3b469ff",
      "patch": "@@ -67,7 +67,8 @@ private JsonKeysetReader(InputStream inputStream) {\n    * <p>Note: the input stream won't be read until {@link JsonKeysetReader#read} or {@link\n    * JsonKeysetReader#readEncrypted} is called.\n    */\n-  public static KeysetReader withInputStream(InputStream input) throws IOException {\n+  @SuppressWarnings(\"CheckedExceptionNotThrown\")\n+  public static JsonKeysetReader withInputStream(InputStream input) throws IOException {\n     return new JsonKeysetReader(input);\n   }\n \n@@ -100,8 +101,12 @@ public static JsonKeysetReader withBytes(final byte[] bytes) {\n    * <p>Note: the file won't be read until {@link JsonKeysetReader#read} or {@link\n    * JsonKeysetReader#readEncrypted} is called.\n    */\n+  @InlineMe(\n+      replacement = \"JsonKeysetReader.withInputStream(new FileInputStream(file))\",\n+      imports = {\"com.google.crypto.tink.JsonKeysetReader\", \"java.io.FileInputStream\"})\n+  @Deprecated\n   public static JsonKeysetReader withFile(File file) throws IOException {\n-    return new JsonKeysetReader(new FileInputStream(file));\n+    return withInputStream(new FileInputStream(file));\n   }\n \n   /**\n@@ -112,8 +117,16 @@ public static JsonKeysetReader withFile(File file) throws IOException {\n    *\n    * <p>This method only works on Android API level 26 or newer.\n    */\n+  @InlineMe(\n+      replacement = \"JsonKeysetReader.withInputStream(new FileInputStream(new File(path)))\",\n+      imports = {\n+        \"com.google.crypto.tink.JsonKeysetReader\",\n+        \"java.io.File\",\n+        \"java.io.FileInputStream\"\n+      })\n+  @Deprecated\n   public static JsonKeysetReader withPath(String path) throws IOException {\n-    return withFile(new File(path));\n+    return withInputStream(new FileInputStream(new File(path)));\n   }\n \n   /**\n@@ -124,9 +137,13 @@ public static JsonKeysetReader withPath(String path) throws IOException {\n    *\n    * <p>This method only works on Android API level 26 or newer.\n    */\n+  @InlineMe(\n+      replacement = \"JsonKeysetReader.withInputStream(new FileInputStream(path.toFile()))\",\n+      imports = {\"com.google.crypto.tink.JsonKeysetReader\", \"java.io.FileInputStream\"})\n   @RequiresApi(26) // https://developer.android.com/reference/java/nio/file/Path\n+  @Deprecated\n   public static JsonKeysetReader withPath(Path path) throws IOException {\n-    return withFile(path.toFile());\n+    return JsonKeysetReader.withInputStream(new FileInputStream(path.toFile()));\n   }\n \n   @CanIgnoreReturnValue",
      "parent_sha": "e4b2b379cf457fe6139cc6ba8e1aab792e0f2926"
    }
  },
  {
    "oid": "901b3c687a298805c9bfa20bc82e52426d2302f1",
    "message": "Use ByteArrayOutputStream.toString(string) instead of toString(charset).\n\nMaintains compatibility with JDK8 and fixes continuous testing failure.\n\nPiperOrigin-RevId: 422936591",
    "date": "2022-01-20T00:56:37Z",
    "url": "https://github.com/tink-crypto/tink/commit/901b3c687a298805c9bfa20bc82e52426d2302f1",
    "details": {
      "sha": "729ed9ea12e3c7b9cde91de7a30a776f7caea790",
      "filename": "testing/java_src/java/com/google/crypto/tink/testing/KeysetServiceImpl.java",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/tink-crypto/tink/blob/901b3c687a298805c9bfa20bc82e52426d2302f1/testing%2Fjava_src%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Ftesting%2FKeysetServiceImpl.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/901b3c687a298805c9bfa20bc82e52426d2302f1/testing%2Fjava_src%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Ftesting%2FKeysetServiceImpl.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/testing%2Fjava_src%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Ftesting%2FKeysetServiceImpl.java?ref=901b3c687a298805c9bfa20bc82e52426d2302f1",
      "patch": "@@ -16,8 +16,6 @@\n \n package com.google.crypto.tink.testing;\n \n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n import com.google.crypto.tink.Aead;\n import com.google.crypto.tink.BinaryKeysetReader;\n import com.google.crypto.tink.BinaryKeysetWriter;\n@@ -143,7 +141,7 @@ public void toJson(\n       JsonKeysetWriter.withOutputStream(jsonKeysetStream).write(keyset);\n       jsonKeysetStream.close();\n       response =\n-          KeysetToJsonResponse.newBuilder().setJsonKeyset(jsonKeysetStream.toString(UTF_8)).build();\n+          KeysetToJsonResponse.newBuilder().setJsonKeyset(jsonKeysetStream.toString(\"UTF-8\")).build();\n     } catch (GeneralSecurityException | InvalidProtocolBufferException e) {\n       response = KeysetToJsonResponse.newBuilder().setErr(e.toString()).build();\n     } catch (IOException e) {",
      "parent_sha": "f0b06825896547054f6f0b04cbfda6269f57662b"
    }
  },
  {
    "oid": "f886025b927df32c57df82a5871051ba30faffce",
    "message": "Make get and has methods in VerifiedJwt public.\n\nPiperOrigin-RevId: 356508594",
    "date": "2021-02-09T16:36:31Z",
    "url": "https://github.com/tink-crypto/tink/commit/f886025b927df32c57df82a5871051ba30faffce",
    "details": {
      "sha": "ba37be2c844cc8c96fef8fee029167bad9034111",
      "filename": "java_src/src/main/java/com/google/crypto/tink/jwt/VerifiedJwt.java",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/tink-crypto/tink/blob/f886025b927df32c57df82a5871051ba30faffce/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FVerifiedJwt.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/f886025b927df32c57df82a5871051ba30faffce/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FVerifiedJwt.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FVerifiedJwt.java?ref=f886025b927df32c57df82a5871051ba30faffce",
      "patch": "@@ -48,7 +48,7 @@ public String getIssuer() throws JwtInvalidException {\n   /**\n    * Returns true iff the {@code iss} claim is present.\n    */\n-  boolean hasIssuer() {\n+  public boolean hasIssuer() {\n     return this.rawJwt.hasIssuer();\n   }\n \n@@ -63,7 +63,7 @@ public String getSubject() throws JwtInvalidException {\n   /**\n    * Returns true iff the {@code sub} claim is present.\n    */\n-  boolean hasSubject() {\n+  public boolean hasSubject() {\n     return this.rawJwt.hasSubject();\n   }\n \n@@ -78,7 +78,7 @@ public List<String> getAudiences() throws JwtInvalidException {\n   /**\n    * Returns true iff the {@code aud} claim is present.\n    */\n-  boolean hasAudiences() {\n+  public boolean hasAudiences() {\n     return this.rawJwt.hasAudiences();\n   }\n \n@@ -93,7 +93,7 @@ public String getJwtId() throws JwtInvalidException {\n   /**\n    * Returns true iff the {@code jti} claim is present.\n    */\n-  boolean hasJwtId() {\n+  public boolean hasJwtId() {\n     return this.rawJwt.hasJwtId();\n   }\n \n@@ -113,7 +113,7 @@ public Instant getExpiration() throws JwtInvalidException  {\n   /**\n    * Returns true iff the {@code exp} claim is present.\n    */\n-  boolean hasExpiration() {\n+  public boolean hasExpiration() {\n     return this.rawJwt.hasExpiration();\n   }\n \n@@ -133,7 +133,7 @@ public Instant getNotBefore() throws JwtInvalidException {\n   /**\n    * Returns true iff the {@code nbf} claim is present.\n    */\n-  boolean hasNotBefore() {\n+  public boolean hasNotBefore() {\n     return this.rawJwt.hasNotBefore();\n   }\n \n@@ -152,59 +152,59 @@ public Instant getIssuedAt() throws JwtInvalidException {\n   /**\n    * Returns true iff the {@code iat} claim is present.\n    */\n-  boolean hasIssuedAt() {\n+  public boolean hasIssuedAt() {\n     return this.rawJwt.hasIssuedAt();\n   }\n \n   /**\n    * Returns the non-registered claim of name {@code name} and type Boolean. Throws a\n    * JwtInvalidException if no such claim is present or the claim has another type.\n    */\n-  Boolean getBooleanClaim(String name) throws JwtInvalidException {\n+  public Boolean getBooleanClaim(String name) throws JwtInvalidException {\n     return this.rawJwt.getBooleanClaim(name);\n   }\n \n   /**\n    * Returns the non-registered claim of name {@code name} and type Number. Throws a\n    * JwtInvalidException if no such claim is present or the claim has another type.\n    */\n-  Double getNumberClaim(String name) throws JwtInvalidException {\n+  public Double getNumberClaim(String name) throws JwtInvalidException {\n     return this.rawJwt.getNumberClaim(name);\n   }\n \n   /**\n    * Returns the non-registered claim of name {@code name} and type String. Throws a\n    * JwtInvalidException if no such claim is present or the claim has another type.\n    */\n-  String getStringClaim(String name) throws JwtInvalidException {\n+  public String getStringClaim(String name) throws JwtInvalidException {\n     return this.rawJwt.getStringClaim(name);\n   }\n \n   /** Returns true iff there is a non-registered claim of name {@code name} and type NULL. */\n-  boolean isNullClaim(String name) {\n+  public boolean isNullClaim(String name) {\n     return this.rawJwt.isNullClaim(name);\n   }\n \n   /**\n    * Returns the non-registered claim of name {@code name} and type JSON Object encoded in a string.\n    * Throws a JwtInvalidException if no such claim is present or the claim has another type.\n    */\n-  String getJsonObjectClaim(String name) throws JwtInvalidException {\n+  public String getJsonObjectClaim(String name) throws JwtInvalidException {\n     return this.rawJwt.getJsonObjectClaim(name);\n   }\n \n   /**\n    * Returns the non-registered claim of name {@code name} and type JSON Array encoded in a string.\n    * Throws a JwtInvalidException if no such claim is present or the claim has another type.\n    */\n-  String getJsonArrayClaim(String name) throws JwtInvalidException {\n+  public String getJsonArrayClaim(String name) throws JwtInvalidException {\n     return this.rawJwt.getJsonArrayClaim(name);\n   }\n \n   /**\n    * Returns true iff the non-registered claim of name {@code name} is present.\n    */\n-  boolean hasClaim(String name) {\n+  public boolean hasClaim(String name) {\n     return this.rawJwt.hasClaim(name);\n   }\n ",
      "parent_sha": "614c43741b96e827d9f6db194e404227ce0fa872"
    }
  },
  {
    "oid": "abe7962fa7d54fdcae14106f75e04d1f1d61e135",
    "message": "Fix typos in PrimitiveRegistryTest.\n\nPiperOrigin-RevId: 495022492",
    "date": "2022-12-13T16:02:09Z",
    "url": "https://github.com/tink-crypto/tink/commit/abe7962fa7d54fdcae14106f75e04d1f1d61e135",
    "details": {
      "sha": "2f8b444e89242f1e96af1bbbfdaee41ebf46ca8e",
      "filename": "java_src/src/test/java/com/google/crypto/tink/internal/PrimitiveRegistryTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/tink-crypto/tink/blob/abe7962fa7d54fdcae14106f75e04d1f1d61e135/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Finternal%2FPrimitiveRegistryTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/abe7962fa7d54fdcae14106f75e04d1f1d61e135/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Finternal%2FPrimitiveRegistryTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Finternal%2FPrimitiveRegistryTest.java?ref=abe7962fa7d54fdcae14106f75e04d1f1d61e135",
      "patch": "@@ -129,7 +129,7 @@ public void test_emptyRegistry_throws() throws Exception {\n   }\n \n   @Test\n-  public void test_registerSameSerializerTwice_works() throws Exception {\n+  public void test_registerSameConstructorTwice_works() throws Exception {\n     PrimitiveConstructor<TestKey1, TestPrimitiveA> testPrimitiveConstructor =\n         PrimitiveConstructor.create(\n             PrimitiveRegistryTest::getPrimitiveAKey1, TestKey1.class, TestPrimitiveA.class);\n@@ -140,7 +140,7 @@ public void test_registerSameSerializerTwice_works() throws Exception {\n   }\n \n   @Test\n-  public void test_registerDifferentSerializerWithSameKeyType_throws() throws Exception {\n+  public void test_registerDifferentConstructorWithSameKeyType_throws() throws Exception {\n     PrimitiveConstructor<TestKey1, TestPrimitiveA> testPrimitiveConstructor1 =\n         PrimitiveConstructor.create(\n             PrimitiveRegistryTest::getPrimitiveAKey1, TestKey1.class, TestPrimitiveA.class);\n@@ -155,7 +155,7 @@ public void test_registerDifferentSerializerWithSameKeyType_throws() throws Exce\n   }\n \n   @Test\n-  public void test_registerDifferentSerializerWithDifferentKeyType_works() throws Exception {\n+  public void test_registerDifferentConstructorWithDifferentKeyType_works() throws Exception {\n     PrimitiveConstructor<TestKey1, TestPrimitiveA> testPrimitiveConstructor1 =\n         PrimitiveConstructor.create(\n             PrimitiveRegistryTest::getPrimitiveAKey1, TestKey1.class, TestPrimitiveA.class);\n@@ -169,7 +169,7 @@ public void test_registerDifferentSerializerWithDifferentKeyType_works() throws\n   }\n \n   @Test\n-  public void test_registerDifferentSerializerWithDifferentPrimitiveType_works()\n+  public void test_registerDifferentConstructorWithDifferentPrimitiveType_works()\n       throws Exception {\n     PrimitiveConstructor<TestKey1, TestPrimitiveA> testPrimitiveConstructor1 =\n         PrimitiveConstructor.create(",
      "parent_sha": "829db35a474901124ad485499da1cd2b92b4d779"
    }
  },
  {
    "oid": "824a6d69386bc8ebeef201a8df813daa3b27cbb1",
    "message": "Split out parsePublicKeyFromProto from parsePublicKey.\n\nParsePublicKeyFromProto maps a the proto (plus the outputPrefixType, plus the IdRequirement) to a PublicKey.\n\nDoing it like this allows us to reuse this part when parsing private keys.\n\nPiperOrigin-RevId: 535144690",
    "date": "2023-05-25T07:37:25Z",
    "url": "https://github.com/tink-crypto/tink/commit/824a6d69386bc8ebeef201a8df813daa3b27cbb1",
    "details": {
      "sha": "9f0fc2c6c3adc89fdb8b65b5f58211723902937b",
      "filename": "java_src/src/main/java/com/google/crypto/tink/jwt/JwtEcdsaProtoSerialization.java",
      "status": "modified",
      "additions": 26,
      "deletions": 17,
      "changes": 43,
      "blob_url": "https://github.com/tink-crypto/tink/blob/824a6d69386bc8ebeef201a8df813daa3b27cbb1/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FJwtEcdsaProtoSerialization.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/824a6d69386bc8ebeef201a8df813daa3b27cbb1/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FJwtEcdsaProtoSerialization.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FJwtEcdsaProtoSerialization.java?ref=824a6d69386bc8ebeef201a8df813daa3b27cbb1",
      "patch": "@@ -232,38 +232,30 @@ private static ProtoKeySerialization serializePublicKey(\n         key.getIdRequirementOrNull());\n   }\n \n-  @SuppressWarnings(\"UnusedException\")\n-  private static JwtEcdsaPublicKey parsePublicKey(\n-      ProtoKeySerialization serialization, @Nullable SecretKeyAccess access)\n+  private static JwtEcdsaPublicKey parsePublicKeyFromProto(\n+      com.google.crypto.tink.proto.JwtEcdsaPublicKey protoKey,\n+      OutputPrefixType outputPrefixType,\n+      @Nullable Integer idRequirement)\n       throws GeneralSecurityException {\n-    if (!serialization.getTypeUrl().equals(PUBLIC_TYPE_URL)) {\n-      throw new IllegalArgumentException(\n-          \"Wrong type URL in call to EcdsaProtoSerialization.parsePublicKey: \"\n-              + serialization.getTypeUrl());\n-    }\n-    try {\n-      com.google.crypto.tink.proto.JwtEcdsaPublicKey protoKey =\n-          com.google.crypto.tink.proto.JwtEcdsaPublicKey.parseFrom(\n-              serialization.getValue(), ExtensionRegistryLite.getEmptyRegistry());\n       if (protoKey.getVersion() != 0) {\n         throw new GeneralSecurityException(\"Only version 0 keys are accepted\");\n       }\n+\n       JwtEcdsaParameters.Builder parametersBuilder = JwtEcdsaParameters.builder();\n       JwtEcdsaPublicKey.Builder keyBuilder = JwtEcdsaPublicKey.builder();\n \n-      if (serialization.getOutputPrefixType().equals(OutputPrefixType.TINK)) {\n+    if (outputPrefixType.equals(OutputPrefixType.TINK)) {\n         if (protoKey.hasCustomKid()) {\n           throw new GeneralSecurityException(\n               \"Keys serialized with OutputPrefixType TINK should not have a custom kid\");\n-        }\n-        @Nullable Integer idRequirement = serialization.getIdRequirementOrNull();\n+      }\n         if (idRequirement == null) {\n           throw new GeneralSecurityException(\n               \"Keys serialized with OutputPrefixType TINK need an ID Requirement\");\n         }\n         parametersBuilder.setKidStrategy(JwtEcdsaParameters.KidStrategy.BASE64_ENCODED_KEY_ID);\n         keyBuilder.setIdRequirement(idRequirement);\n-      } else if (serialization.getOutputPrefixType().equals(OutputPrefixType.RAW)) {\n+    } else if (outputPrefixType.equals(OutputPrefixType.RAW)) {\n         if (protoKey.hasCustomKid()) {\n           parametersBuilder.setKidStrategy(JwtEcdsaParameters.KidStrategy.CUSTOM);\n           keyBuilder.setCustomKid(protoKey.getCustomKid().getValue());\n@@ -277,7 +269,24 @@ private static JwtEcdsaPublicKey parsePublicKey(\n               BigIntegerEncoding.fromUnsignedBigEndianBytes(protoKey.getX().toByteArray()),\n               BigIntegerEncoding.fromUnsignedBigEndianBytes(protoKey.getY().toByteArray())));\n       return keyBuilder.setParameters(parametersBuilder.build()).build();\n-    } catch (InvalidProtocolBufferException | IllegalArgumentException e) {\n+  }\n+\n+  @SuppressWarnings(\"UnusedException\")\n+  private static JwtEcdsaPublicKey parsePublicKey(\n+      ProtoKeySerialization serialization, @Nullable SecretKeyAccess access)\n+      throws GeneralSecurityException {\n+    if (!serialization.getTypeUrl().equals(PUBLIC_TYPE_URL)) {\n+      throw new IllegalArgumentException(\n+          \"Wrong type URL in call to EcdsaProtoSerialization.parsePublicKey: \"\n+              + serialization.getTypeUrl());\n+    }\n+    try {\n+      com.google.crypto.tink.proto.JwtEcdsaPublicKey protoKey =\n+          com.google.crypto.tink.proto.JwtEcdsaPublicKey.parseFrom(\n+              serialization.getValue(), ExtensionRegistryLite.getEmptyRegistry());\n+      return parsePublicKeyFromProto(\n+          protoKey, serialization.getOutputPrefixType(), serialization.getIdRequirementOrNull());\n+    } catch (InvalidProtocolBufferException e) {\n       throw new GeneralSecurityException(\"Parsing EcdsaPublicKey failed\");\n     }\n   }",
      "parent_sha": "5f0694f75475b5aeb34dbe3e9066f406a3493129"
    }
  },
  {
    "oid": "c8f68878f213127097871ec6cbabbb0d8d3cdd57",
    "message": "Slightly simplify the logic to insert keymanagers in the registry.\n\nThis will be especially useful when we integrate internal private key managers.\n\nPiperOrigin-RevId: 254195643",
    "date": "2019-06-20T14:57:15Z",
    "url": "https://github.com/tink-crypto/tink/commit/c8f68878f213127097871ec6cbabbb0d8d3cdd57",
    "details": {
      "sha": "37b2554cec124edf0e37ba42e4905e2a5cdfb448",
      "filename": "java/src/main/java/com/google/crypto/tink/Registry.java",
      "status": "modified",
      "additions": 31,
      "deletions": 26,
      "changes": 57,
      "blob_url": "https://github.com/tink-crypto/tink/blob/c8f68878f213127097871ec6cbabbb0d8d3cdd57/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistry.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/c8f68878f213127097871ec6cbabbb0d8d3cdd57/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistry.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistry.java?ref=c8f68878f213127097871ec6cbabbb0d8d3cdd57",
      "patch": "@@ -292,6 +292,31 @@ public static synchronized <P> void registerKeyManager(final KeyManager<P> manag\n     registerKeyManager(manager, /* newKeyAllowed= */ true);\n   }\n \n+  /**\n+   * Throws a general security exception iff there is already a key manager registered for typeURL,\n+   * and at least one of the following is true:\n+   *   * The class implementing the existing key manager differs from the given one.\n+   *   * The value of newKeyAllowed currently registered is false, but the input parameter is true.\n+   */\n+  private static synchronized <P> void ensureKeyManagerInsertable(\n+      String typeUrl, Class<?> implementingClass, boolean newKeyAllowed)\n+      throws GeneralSecurityException {\n+    if (!keyManagerMap.containsKey(typeUrl)) {\n+      return;\n+    }\n+    KeyManagerContainer container = keyManagerMap.get(typeUrl);\n+    if (!container.getImplementingClass().equals(implementingClass)) {\n+        logger.warning(\"Attempted overwrite of a registered key manager for key type \" + typeUrl);\n+      throw new GeneralSecurityException(\n+          String.format(\n+              \"typeUrl (%s) is already registered with %s, cannot be re-registered with %s\",\n+              typeUrl, container.getImplementingClass().getName(), implementingClass.getName()));\n+    }\n+    if (newKeyAllowed && !newKeyAllowedMap.get(typeUrl)) {\n+      throw new GeneralSecurityException(\"New keys are already disallowed for key type \" + typeUrl);\n+    }\n+  }\n+\n   /**\n    * Tries to register {@code manager} for {@code manager.getKeyType()}. If {@code newKeyAllowed} is\n    * true, users can generate new keys with this manager using the {@link Registry#newKey} methods.\n@@ -310,20 +335,10 @@ public static synchronized <P> void registerKeyManager(\n       throw new IllegalArgumentException(\"key manager must be non-null.\");\n     }\n     String typeUrl = manager.getKeyType();\n-    if (keyManagerMap.containsKey(typeUrl)) {\n-      KeyManagerContainer container = keyManagerMap.get(typeUrl);\n-      boolean existingNewKeyAllowed = newKeyAllowedMap.get(typeUrl).booleanValue();\n-      if (!manager.getClass().equals(container.getImplementingClass())\n-          // Disallow changing newKeyAllowed from false to true.\n-          || (!existingNewKeyAllowed && newKeyAllowed)) {\n-        logger.warning(\"Attempted overwrite of a registered key manager for key type \" + typeUrl);\n-        throw new GeneralSecurityException(\n-            String.format(\n-                \"typeUrl (%s) is already registered with %s, cannot be re-registered with %s\",\n-                typeUrl, container.getImplementingClass().getName(), manager.getClass().getName()));\n-      }\n+    ensureKeyManagerInsertable(typeUrl, manager.getClass(), newKeyAllowed);\n+    if (!keyManagerMap.containsKey(typeUrl)) {\n+      keyManagerMap.put(typeUrl, createContainerFor(manager));\n     }\n-    keyManagerMap.put(typeUrl, createContainerFor(manager));\n     newKeyAllowedMap.put(typeUrl, Boolean.valueOf(newKeyAllowed));\n   }\n \n@@ -334,20 +349,10 @@ public static synchronized <KeyProtoT extends MessageLite> void registerKeyManag\n       throw new IllegalArgumentException(\"key manager must be non-null.\");\n     }\n     String typeUrl = manager.getKeyType();\n-    if (keyManagerMap.containsKey(typeUrl)) {\n-      KeyManagerContainer container = keyManagerMap.get(typeUrl);\n-      boolean existingNewKeyAllowed = newKeyAllowedMap.get(typeUrl).booleanValue();\n-      if (!manager.getClass().equals(container.getImplementingClass())\n-          // Disallow changing newKeyAllowed from false to true.\n-          || ((!existingNewKeyAllowed) && newKeyAllowed)) {\n-        logger.warning(\"Attempted overwrite of a registered key manager for key type \" + typeUrl);\n-        throw new GeneralSecurityException(\n-            String.format(\n-                \"typeUrl (%s) is already registered with %s, cannot be re-registered with %s\",\n-                typeUrl, container.getImplementingClass().getName(), manager.getClass().getName()));\n-      }\n+    ensureKeyManagerInsertable(typeUrl, manager.getClass(), newKeyAllowed);\n+    if (!keyManagerMap.containsKey(typeUrl)) {\n+      keyManagerMap.put(typeUrl, createContainerFor(manager));\n     }\n-    keyManagerMap.put(typeUrl, createContainerFor(manager));\n     newKeyAllowedMap.put(typeUrl, Boolean.valueOf(newKeyAllowed));\n   }\n ",
      "parent_sha": "0f7b10e20544ac48334f30ac6217825dbdddb8ab"
    }
  },
  {
    "oid": "e2a3755f462a0ddfef81782957b4dc2124f6cd6b",
    "message": "Internal Code Change\n\nPiperOrigin-RevId: 517063404",
    "date": "2023-03-16T09:37:40Z",
    "url": "https://github.com/tink-crypto/tink/commit/e2a3755f462a0ddfef81782957b4dc2124f6cd6b",
    "details": {
      "sha": "3f134f8da67031b5f56a4da99ef4fb73ddd20183",
      "filename": "java_src/src/main/java/com/google/crypto/tink/subtle/Bytes.java",
      "status": "modified",
      "additions": 2,
      "deletions": 4,
      "changes": 6,
      "blob_url": "https://github.com/tink-crypto/tink/blob/e2a3755f462a0ddfef81782957b4dc2124f6cd6b/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FBytes.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/e2a3755f462a0ddfef81782957b4dc2124f6cd6b/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FBytes.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FBytes.java?ref=e2a3755f462a0ddfef81782957b4dc2124f6cd6b",
      "patch": "@@ -78,10 +78,8 @@ public static final byte[] xor(\n   }\n \n   /**\n-   * Computes the xor of two byte buffers, specifying the length to xor, and\n-   * stores the result to {@code output}.\n-   *\n-   * @return a new byte[] of length len.\n+   * Computes the xor of two byte buffers, specifying the length to xor, and stores the result to\n+   * {@code output}.\n    */\n   public static final void xor(ByteBuffer output, ByteBuffer x, ByteBuffer y, int len) {\n     if (len < 0 || x.remaining() < len || y.remaining() < len || output.remaining() < len) {",
      "parent_sha": "1df735509bfa5f45244786163a4eed3872ce8ca7"
    }
  },
  {
    "oid": "c5408b17b5eb9b0618f343645aab1bce9243fc97",
    "message": "Fix the testGetKeyManager_legacy_wrongType_shouldThrowException for Java 11.\n\nThe message in the exception has changed. We make the matching less specific.\n\nPiperOrigin-RevId: 273477011",
    "date": "2019-10-08T09:26:05Z",
    "url": "https://github.com/tink-crypto/tink/commit/c5408b17b5eb9b0618f343645aab1bce9243fc97",
    "details": {
      "sha": "7b0ba43cc54dba4554c56e463d087251c55e89bb",
      "filename": "java/src/test/java/com/google/crypto/tink/RegistryTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/tink-crypto/tink/blob/c5408b17b5eb9b0618f343645aab1bce9243fc97/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistryTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/c5408b17b5eb9b0618f343645aab1bce9243fc97/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistryTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistryTest.java?ref=c5408b17b5eb9b0618f343645aab1bce9243fc97",
      "patch": "@@ -152,7 +152,8 @@ public void testGetKeyManager_legacy_wrongType_shouldThrowException() throws Exc\n       Aead unused = wrongType.getPrimitive(hmacKey);\n       fail(\"Expected ClassCastException\");\n     } catch (ClassCastException e) {\n-      assertExceptionContains(e, \"MacJce cannot be cast to com.google.crypto.tink.Aead\");\n+      assertExceptionContains(e, \"com.google.crypto.tink.Aead\");\n+      assertExceptionContains(e, \"com.google.crypto.tink.subtle.MacJce\");\n     }\n   }\n ",
      "parent_sha": "090075d031a55da56bf0551b2e1495d19e38c000"
    }
  },
  {
    "oid": "e57219410b906ac01b214ff3c5d1db14023b174e",
    "message": "Add comment to add full primitive methods.\n\nThe caller must ensure that the values added are consistent, PrimitiveSet can't ensure that.\n\nPiperOrigin-RevId: 607298495",
    "date": "2024-02-15T13:22:15Z",
    "url": "https://github.com/tink-crypto/tink/commit/e57219410b906ac01b214ff3c5d1db14023b174e",
    "details": {
      "sha": "d4b5a416078854fe33636dc787325f62ce7d7697",
      "filename": "java_src/src/main/java/com/google/crypto/tink/internal/PrimitiveSet.java",
      "status": "modified",
      "additions": 10,
      "deletions": 2,
      "changes": 12,
      "blob_url": "https://github.com/tink-crypto/tink/blob/e57219410b906ac01b214ff3c5d1db14023b174e/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Finternal%2FPrimitiveSet.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/e57219410b906ac01b214ff3c5d1db14023b174e/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Finternal%2FPrimitiveSet.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Finternal%2FPrimitiveSet.java?ref=e57219410b906ac01b214ff3c5d1db14023b174e",
      "patch": "@@ -310,15 +310,23 @@ private Builder<P> addEntry(\n       return this;\n     }\n \n+    /**\n+     * Adds a non-primary primitive.\n+     *\n+     * <p>The caller must make sure that the {@code fullPrimitive} is a full primitive constructed\n+     * from key, and that {@code protoKey} contains the same key as {@code fullPrimitive}.\n+     */\n     @CanIgnoreReturnValue\n     public Builder<P> addFullPrimitive(final P fullPrimitive, Key key, Keyset.Key protoKey)\n         throws GeneralSecurityException {\n       return addEntry(fullPrimitive, key, protoKey, false);\n     }\n \n     /**\n-     * Adds the primary primitive and full primitive. This or addPrimaryPrimitive should be called\n-     * exactly once per PrimitiveSet.\n+     * Adds the primary primitive. This should be called exactly once per PrimitiveSet.\n+     *\n+     * <p>The caller must make sure that the {@code fullPrimitive} is a full primitive constructed\n+     * from key, and that {@code protoKey} contains the same key as {@code fullPrimitive}.\n      */\n     @CanIgnoreReturnValue\n     public Builder<P> addPrimaryFullPrimitive(final P fullPrimitive, Key key, Keyset.Key protoKey)",
      "parent_sha": "b9970e0a45e45fb2bf36693f42e6c9f10d202b02"
    }
  },
  {
    "oid": "0a1dc8963ad0cb0ce153d24b5eb494fa43ecf147",
    "message": "Replace a parametrized test with Theory and use it internally with tink_android_test.\n\ntink_android_test is prefered than the previous way of collecting everything.\nParametrized tests do not work on android at the moment, so we use Theory which works, instead.\n\nPiperOrigin-RevId: 424816415",
    "date": "2022-01-28T10:04:38Z",
    "url": "https://github.com/tink-crypto/tink/commit/0a1dc8963ad0cb0ce153d24b5eb494fa43ecf147",
    "details": {
      "sha": "13f85f466e9f3659429d3b885eea9225a5a42f82",
      "filename": "java_src/src/test/java/com/google/crypto/tink/jwt/JwtHmacKeyManagerTest.java",
      "status": "modified",
      "additions": 13,
      "deletions": 21,
      "changes": 34,
      "blob_url": "https://github.com/tink-crypto/tink/blob/0a1dc8963ad0cb0ce153d24b5eb494fa43ecf147/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FJwtHmacKeyManagerTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/0a1dc8963ad0cb0ce153d24b5eb494fa43ecf147/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FJwtHmacKeyManagerTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FJwtHmacKeyManagerTest.java?ref=0a1dc8963ad0cb0ce153d24b5eb494fa43ecf147",
      "patch": "@@ -51,14 +51,15 @@\n import java.util.Set;\n import java.util.TreeSet;\n import javax.crypto.spec.SecretKeySpec;\n-import junitparams.JUnitParamsRunner;\n-import junitparams.Parameters;\n import org.junit.BeforeClass;\n import org.junit.Test;\n+import org.junit.experimental.theories.DataPoint;\n+import org.junit.experimental.theories.Theories;\n+import org.junit.experimental.theories.Theory;\n import org.junit.runner.RunWith;\n \n /** Unit tests for {@link JwtHmacKeyManager}. */\n-@RunWith(JUnitParamsRunner.class)\n+@RunWith(Theories.class)\n public class JwtHmacKeyManagerTest {\n   private final JwtHmacKeyManager manager = new JwtHmacKeyManager();\n   private final KeyTypeManager.KeyFactory<JwtHmacKeyFormat, JwtHmacKey> factory =\n@@ -69,14 +70,10 @@ public static void setUp() throws Exception {\n     JwtMacConfig.register();\n   }\n \n-  private static Object[] templates() {\n-    return new Object[] {\n-      \"JWT_HS256\",\n-      \"JWT_HS384\",\n-      \"JWT_HS512\",\n-      \"JWT_HS256_RAW\",\n-    };\n-  }\n+  @DataPoint public static final String JWT_HS256 = \"JWT_HS256\";\n+  @DataPoint public static final String JWT_HS384 = \"JWT_HS384\";\n+  @DataPoint public static final String JWT_HS512 = \"JWT_HS512\";\n+  @DataPoint public static final String JWT_HS256_RAW = \"JWT_HS256_RAW\";\n \n   @Test\n   public void validateKeyFormat_empty() throws Exception {\n@@ -226,8 +223,7 @@ public void testKeyTemplateAndManagerCompatibility() throws Exception {\n     testKeyTemplateCompatible(manager, KeyTemplates.get(\"JWT_HS512_RAW\"));\n   }\n \n-  @Test\n-  @Parameters(method = \"templates\")\n+  @Theory\n   public void createSignVerify_success(String templateNames) throws Exception {\n     KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(templateNames));\n     JwtMac primitive = handle.getPrimitive(JwtMac.class);\n@@ -238,8 +234,7 @@ public void createSignVerify_success(String templateNames) throws Exception {\n     assertThat(verifiedToken.getJwtId()).isEqualTo(\"jwtId\");\n   }\n \n-  @Test\n-  @Parameters(method = \"templates\")\n+  @Theory\n   public void createSignVerifyDifferentKey_throw(String templateNames) throws Exception {\n     KeyTemplate template = KeyTemplates.get(templateNames);\n     KeysetHandle handle = KeysetHandle.generateNew(template);\n@@ -255,8 +250,7 @@ public void createSignVerifyDifferentKey_throw(String templateNames) throws Exce\n         () -> otherPrimitive.verifyMacAndDecode(compact, validator));\n   }\n \n-  @Test\n-  @Parameters(method = \"templates\")\n+  @Theory\n   public void createSignVerify_modifiedHeader_throw(String templateNames) throws Exception {\n     KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(templateNames));\n     JwtMac mac = handle.getPrimitive(JwtMac.class);\n@@ -278,8 +272,7 @@ public void createSignVerify_modifiedHeader_throw(String templateNames) throws E\n     }\n   }\n \n-  @Test\n-  @Parameters(method = \"templates\")\n+  @Theory\n   public void createSignVerify_modifiedPayload_throw(String templateNames) throws Exception {\n     KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(templateNames));\n     JwtMac mac = handle.getPrimitive(JwtMac.class);\n@@ -301,8 +294,7 @@ public void createSignVerify_modifiedPayload_throw(String templateNames) throws\n     }\n   }\n \n-  @Test\n-  @Parameters(method = \"templates\")\n+  @Theory\n   public void verify_modifiedSignature_shouldThrow(String templateNames) throws Exception {\n     KeysetHandle handle = KeysetHandle.generateNew(KeyTemplates.get(templateNames));\n     JwtMac mac = handle.getPrimitive(JwtMac.class);",
      "parent_sha": "fc44f0498a1d294fb48e6a88350060e7f1e4e2be"
    }
  },
  {
    "oid": "e000dc9a6b7dbeddf0bd2e16733e6dd3565b06a5",
    "message": "Document that decrypt in the Aead interface throws a GeneralSecurityException if decryption fails.\n\nPiperOrigin-RevId: 586345172",
    "date": "2023-11-29T16:09:43Z",
    "url": "https://github.com/tink-crypto/tink/commit/e000dc9a6b7dbeddf0bd2e16733e6dd3565b06a5",
    "details": {
      "sha": "006e6e0086d8068d1c90b3cc12bf7591048023a2",
      "filename": "java_src/src/main/java/com/google/crypto/tink/Aead.java",
      "status": "modified",
      "additions": 9,
      "deletions": 7,
      "changes": 16,
      "blob_url": "https://github.com/tink-crypto/tink/blob/e000dc9a6b7dbeddf0bd2e16733e6dd3565b06a5/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FAead.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/e000dc9a6b7dbeddf0bd2e16733e6dd3565b06a5/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FAead.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FAead.java?ref=e000dc9a6b7dbeddf0bd2e16733e6dd3565b06a5",
      "patch": "@@ -49,15 +49,17 @@ byte[] encrypt(final byte[] plaintext, final byte[] associatedData)\n       throws GeneralSecurityException;\n \n   /**\n-   * Decrypts {@code ciphertext} with {@code associatedData} as associated authenticated data.\n-   * The decryption verifies the authenticity and integrity of the associated data, but there are\n-   * no guarantees wrt. secrecy of that data.\n+   * Decrypts {@code ciphertext} with {@code associatedData} as associated authenticated data. The\n+   * decryption verifies the authenticity and integrity of the associated data, but there are no\n+   * guarantees wrt. secrecy of that data.\n    *\n-   * @param ciphertext      the plaintext to be decrypted. It must be non-null.\n-   * @param associatedData  associated data to be authenticated.  For successful decryption\n-   *                        it must be the same as associatedData used during encryption.\n-   *                        Can be null, which is equivalent to an empty (zero-length) byte array.\n+   * @param ciphertext the plaintext to be decrypted. It must be non-null.\n+   * @param associatedData associated data to be authenticated. For successful decryption it must be\n+   *     the same as associatedData used during encryption. Can be null, which is equivalent to an\n+   *     empty (zero-length) byte array.\n    * @return resulting plaintext\n+   * @throws GeneralSecurityException if decryption fails. Decryption must fail if {@code\n+   *     ciphertext} is not correctly authenticated for the given {@code associatedData}.\n    */\n   byte[] decrypt(final byte[] ciphertext, final byte[] associatedData)\n       throws GeneralSecurityException;",
      "parent_sha": "083bdbbccc68195e6b3051074d62c5d018854cc1"
    }
  },
  {
    "oid": "363c762f1c1965b317ad1e9eec14a27798983020",
    "message": "  Suppress GuardedBy violations.\n\nPiperOrigin-RevId: 288531320",
    "date": "2020-01-07T19:03:10Z",
    "url": "https://github.com/tink-crypto/tink/commit/363c762f1c1965b317ad1e9eec14a27798983020",
    "details": {
      "sha": "ada8ca1c4db4bbd8ffb63d6c8518526d9d5f40f0",
      "filename": "java/src/test/java/com/google/crypto/tink/KeysetManagerTest.java",
      "status": "modified",
      "additions": 105,
      "deletions": 112,
      "changes": 217,
      "blob_url": "https://github.com/tink-crypto/tink/blob/363c762f1c1965b317ad1e9eec14a27798983020/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetManagerTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/363c762f1c1965b317ad1e9eec14a27798983020/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetManagerTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetManagerTest.java?ref=363c762f1c1965b317ad1e9eec14a27798983020",
      "patch": "@@ -76,59 +76,58 @@ public void testEnable_shouldEnableKey() throws Exception {\n     int keyId = 42;\n     KeysetHandle handle = KeysetHandle.fromKeyset(\n         TestUtil.createKeyset(createDisabledKey(keyId)));\n-    Keyset keyset = KeysetManager\n-        .withKeysetHandle(handle)\n-        .enable(keyId)\n-        .getKeysetHandle()\n-        .getKeyset();\n+    @SuppressWarnings(\"GuardedBy\")\n+    // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+    Keyset keyset =\n+        KeysetManager.withKeysetHandle(handle).enable(keyId).getKeysetHandle().getKeyset();\n \n     assertThat(keyset.getKeyCount()).isEqualTo(1);\n     assertThat(keyset.getKey(0).getKeyId()).isEqualTo(keyId);\n     assertThat(keyset.getKey(0).getStatus()).isEqualTo(KeyStatusType.ENABLED);\n   }\n \n+  @SuppressWarnings(\"GuardedBy\")\n   @Test\n   public void testEnable_unknownStatus_shouldThrowException() throws Exception {\n     int keyId = 42;\n     KeysetHandle handle = KeysetHandle.fromKeyset(\n         TestUtil.createKeyset(createUnknownStatusKey(keyId)));\n \n     try {\n-      KeysetManager\n-          .withKeysetHandle(handle)\n-          .enable(keyId);\n+      // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+      KeysetManager.withKeysetHandle(handle).enable(keyId);\n       fail(\"Expected GeneralSecurityException\");\n     } catch (GeneralSecurityException e) {\n       assertThat(e.toString()).contains(\"cannot enable\");\n     }\n   }\n \n+  @SuppressWarnings(\"GuardedBy\")\n   @Test\n   public void testEnable_keyDestroyed_shouldThrowException() throws Exception {\n     int keyId = 42;\n     KeysetHandle handle = KeysetHandle.fromKeyset(\n         TestUtil.createKeyset(createDestroyedKey(keyId)));\n \n     try {\n-      KeysetManager\n-          .withKeysetHandle(handle)\n-          .enable(keyId);\n+      // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+      KeysetManager.withKeysetHandle(handle).enable(keyId);\n       fail(\"Expected GeneralSecurityException\");\n     } catch (GeneralSecurityException e) {\n       assertThat(e.toString()).contains(\"cannot enable\");\n     }\n   }\n \n+  @SuppressWarnings(\"GuardedBy\")\n   @Test\n   public void testEnable_keyNotFound_shouldThrowException() throws Exception {\n     int keyId = 42;\n     KeysetHandle handle = KeysetHandle.fromKeyset(\n         TestUtil.createKeyset(createDisabledKey(keyId)));\n \n     try {\n-      KeysetManager\n-          .withKeysetHandle(handle)\n-          .enable(keyId + 1);\n+      // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+      KeysetManager.withKeysetHandle(handle).enable(keyId + 1);\n       fail(\"Expected GeneralSecurityException\");\n     } catch (GeneralSecurityException e) {\n       assertThat(e.toString()).contains(\"key not found\");\n@@ -143,16 +142,19 @@ public void testSetPrimary_shouldSetPrimary() throws Exception {\n         TestUtil.createKeyset(\n             createEnabledKey(primaryKeyId),\n             createEnabledKey(newPrimaryKeyId)));\n-    Keyset keyset = KeysetManager\n-        .withKeysetHandle(handle)\n-        .setPrimary(newPrimaryKeyId)\n-        .getKeysetHandle()\n-        .getKeyset();\n+    @SuppressWarnings(\"GuardedBy\")\n+    // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+    Keyset keyset =\n+        KeysetManager.withKeysetHandle(handle)\n+            .setPrimary(newPrimaryKeyId)\n+            .getKeysetHandle()\n+            .getKeyset();\n \n     assertThat(keyset.getKeyCount()).isEqualTo(2);\n     assertThat(keyset.getPrimaryKeyId()).isEqualTo(newPrimaryKeyId);\n   }\n \n+  @SuppressWarnings(\"GuardedBy\")\n   @Test\n   public void testSetPrimary_keyNotFound_shouldThrowException() throws Exception {\n     int primaryKeyId = 42;\n@@ -162,15 +164,15 @@ public void testSetPrimary_keyNotFound_shouldThrowException() throws Exception {\n             createEnabledKey(primaryKeyId),\n             createEnabledKey(newPrimaryKeyId)));\n     try {\n-      KeysetManager\n-          .withKeysetHandle(handle)\n-          .setPrimary(44);\n+      // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+      KeysetManager.withKeysetHandle(handle).setPrimary(44);\n       fail(\"Expected GeneralSecurityException\");\n     } catch (GeneralSecurityException e) {\n       assertThat(e.toString()).contains(\"key not found\");\n     }\n   }\n \n+  @SuppressWarnings(\"GuardedBy\")\n   @Test\n   public void testSetPrimary_keyDisabled_shouldThrowException() throws Exception {\n     int primaryKeyId = 42;\n@@ -180,15 +182,15 @@ public void testSetPrimary_keyDisabled_shouldThrowException() throws Exception {\n             createEnabledKey(primaryKeyId),\n             createDisabledKey(newPrimaryKeyId)));\n     try {\n-      KeysetManager\n-          .withKeysetHandle(handle)\n-          .setPrimary(newPrimaryKeyId);\n+      // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+      KeysetManager.withKeysetHandle(handle).setPrimary(newPrimaryKeyId);\n       fail(\"Expected GeneralSecurityException\");\n     } catch (GeneralSecurityException e) {\n       assertThat(e.toString()).contains(\"cannot set key as primary because it's not enabled\");\n     }\n   }\n \n+  @SuppressWarnings(\"GuardedBy\")\n   @Test\n   public void testSetPrimary_keyDestroyed_shouldThrowException() throws Exception {\n     int primaryKeyId = 42;\n@@ -198,15 +200,15 @@ public void testSetPrimary_keyDestroyed_shouldThrowException() throws Exception\n             createEnabledKey(primaryKeyId),\n             createDestroyedKey(newPrimaryKeyId)));\n     try {\n-      KeysetManager\n-          .withKeysetHandle(handle)\n-          .setPrimary(newPrimaryKeyId);\n+      // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+      KeysetManager.withKeysetHandle(handle).setPrimary(newPrimaryKeyId);\n       fail(\"Expected GeneralSecurityException\");\n     } catch (GeneralSecurityException e) {\n       assertThat(e.toString()).contains(\"cannot set key as primary because it's not enabled\");\n     }\n   }\n \n+  @SuppressWarnings(\"GuardedBy\")\n   @Test\n   public void testSetPrimary_keyUnknownStatus_shouldThrowException() throws Exception {\n     int primaryKeyId = 42;\n@@ -216,9 +218,8 @@ public void testSetPrimary_keyUnknownStatus_shouldThrowException() throws Except\n             createEnabledKey(primaryKeyId),\n             createUnknownStatusKey(newPrimaryKeyId)));\n     try {\n-      KeysetManager\n-          .withKeysetHandle(handle)\n-          .setPrimary(newPrimaryKeyId);\n+      // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+      KeysetManager.withKeysetHandle(handle).setPrimary(newPrimaryKeyId);\n       fail(\"Expected GeneralSecurityException\");\n     } catch (GeneralSecurityException e) {\n       assertThat(e.toString()).contains(\"cannot set key as primary because it's not enabled\");\n@@ -234,16 +235,19 @@ public void testPromote_shouldPromote() throws Exception {\n         TestUtil.createKeyset(\n             createEnabledKey(primaryKeyId),\n             createEnabledKey(newPrimaryKeyId)));\n-    Keyset keyset = KeysetManager\n-        .withKeysetHandle(handle)\n-        .promote(newPrimaryKeyId)\n-        .getKeysetHandle()\n-        .getKeyset();\n+    @SuppressWarnings(\"GuardedBy\")\n+    // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+    Keyset keyset =\n+        KeysetManager.withKeysetHandle(handle)\n+            .promote(newPrimaryKeyId)\n+            .getKeysetHandle()\n+            .getKeyset();\n \n     assertThat(keyset.getKeyCount()).isEqualTo(2);\n     assertThat(keyset.getPrimaryKeyId()).isEqualTo(newPrimaryKeyId);\n   }\n \n+  @SuppressWarnings(\"GuardedBy\")\n   @Test\n   public void testPromote_keyNotFound_shouldThrowException() throws Exception {\n     int primaryKeyId = 42;\n@@ -253,15 +257,15 @@ public void testPromote_keyNotFound_shouldThrowException() throws Exception {\n             createEnabledKey(primaryKeyId),\n             createEnabledKey(newPrimaryKeyId)));\n     try {\n-      KeysetManager\n-          .withKeysetHandle(handle)\n-          .promote(44);\n+      // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+      KeysetManager.withKeysetHandle(handle).promote(44);\n       fail(\"Expected GeneralSecurityException\");\n     } catch (GeneralSecurityException e) {\n       assertThat(e.toString()).contains(\"key not found\");\n     }\n   }\n \n+  @SuppressWarnings(\"GuardedBy\")\n   @Test\n   public void testPromote_keyDisabled_shouldThrowException() throws Exception {\n     int primaryKeyId = 42;\n@@ -271,15 +275,15 @@ public void testPromote_keyDisabled_shouldThrowException() throws Exception {\n             createEnabledKey(primaryKeyId),\n             createDisabledKey(newPrimaryKeyId)));\n     try {\n-      KeysetManager\n-          .withKeysetHandle(handle)\n-          .promote(newPrimaryKeyId);\n+      // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+      KeysetManager.withKeysetHandle(handle).promote(newPrimaryKeyId);\n       fail(\"Expected GeneralSecurityException\");\n     } catch (GeneralSecurityException e) {\n       assertThat(e.toString()).contains(\"cannot set key as primary because it's not enabled\");\n     }\n   }\n \n+  @SuppressWarnings(\"GuardedBy\")\n   @Test\n   public void testPromote_keyDestroyed_shouldThrowException() throws Exception {\n     int primaryKeyId = 42;\n@@ -289,15 +293,15 @@ public void testPromote_keyDestroyed_shouldThrowException() throws Exception {\n             createEnabledKey(primaryKeyId),\n             createDestroyedKey(newPrimaryKeyId)));\n     try {\n-      KeysetManager\n-          .withKeysetHandle(handle)\n-          .promote(newPrimaryKeyId);\n+      // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+      KeysetManager.withKeysetHandle(handle).promote(newPrimaryKeyId);\n       fail(\"Expected GeneralSecurityException\");\n     } catch (GeneralSecurityException e) {\n       assertThat(e.toString()).contains(\"cannot set key as primary because it's not enabled\");\n     }\n   }\n \n+  @SuppressWarnings(\"GuardedBy\")\n   @Test\n   public void testPromote_keyUnknownStatus_shouldThrowException() throws Exception {\n     int primaryKeyId = 42;\n@@ -307,9 +311,8 @@ public void testPromote_keyUnknownStatus_shouldThrowException() throws Exception\n             createEnabledKey(primaryKeyId),\n             createUnknownStatusKey(newPrimaryKeyId)));\n     try {\n-      KeysetManager\n-          .withKeysetHandle(handle)\n-          .promote(newPrimaryKeyId);\n+      // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+      KeysetManager.withKeysetHandle(handle).promote(newPrimaryKeyId);\n       fail(\"Expected GeneralSecurityException\");\n     } catch (GeneralSecurityException e) {\n       assertThat(e.toString()).contains(\"cannot set key as primary because it's not enabled\");\n@@ -324,11 +327,10 @@ public void testDisable_shouldDisableKey() throws Exception {\n         TestUtil.createKeyset(\n             createEnabledKey(primaryKeyId),\n             createEnabledKey(otherKeyId)));\n-    Keyset keyset = KeysetManager\n-        .withKeysetHandle(handle)\n-        .disable(otherKeyId)\n-        .getKeysetHandle()\n-        .getKeyset();\n+    @SuppressWarnings(\"GuardedBy\")\n+    // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+    Keyset keyset =\n+        KeysetManager.withKeysetHandle(handle).disable(otherKeyId).getKeysetHandle().getKeyset();\n \n     assertThat(keyset.getKeyCount()).isEqualTo(2);\n     assertThat(keyset.getKey(0).getKeyId()).isEqualTo(primaryKeyId);\n@@ -337,6 +339,7 @@ public void testDisable_shouldDisableKey() throws Exception {\n     assertThat(keyset.getKey(1).getStatus()).isEqualTo(KeyStatusType.DISABLED);\n   }\n \n+  @SuppressWarnings(\"GuardedBy\")\n   @Test\n   public void testDisable_keyIsPrimary_shouldThrowException() throws Exception {\n     int primaryKeyId = 42;\n@@ -346,17 +349,15 @@ public void testDisable_keyIsPrimary_shouldThrowException() throws Exception {\n             createEnabledKey(primaryKeyId),\n             createEnabledKey(otherKeyId)));\n     try {\n-      KeysetManager\n-          .withKeysetHandle(handle)\n-          .disable(primaryKeyId)\n-          .getKeysetHandle()\n-          .getKeyset();\n+      // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+      KeysetManager.withKeysetHandle(handle).disable(primaryKeyId).getKeysetHandle().getKeyset();\n       fail(\"Expected GeneralSecurityException\");\n     } catch (GeneralSecurityException e) {\n       assertThat(e.toString()).contains(\"cannot disable the primary key\");\n     }\n   }\n \n+  @SuppressWarnings(\"GuardedBy\")\n   @Test\n   public void testDisable_keyDestroyed_shouldThrowException() throws Exception {\n     int primaryKeyId = 42;\n@@ -366,27 +367,24 @@ public void testDisable_keyDestroyed_shouldThrowException() throws Exception {\n             createEnabledKey(primaryKeyId),\n             createDestroyedKey(otherKeyId)));\n     try {\n-      KeysetManager\n-          .withKeysetHandle(handle)\n-          .disable(otherKeyId)\n-          .getKeysetHandle()\n-          .getKeyset();\n+      // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+      KeysetManager.withKeysetHandle(handle).disable(otherKeyId).getKeysetHandle().getKeyset();\n       fail(\"Expected GeneralSecurityException\");\n     } catch (GeneralSecurityException e) {\n       assertThat(e.toString()).contains(\"cannot disable key\");\n     }\n   }\n \n+  @SuppressWarnings(\"GuardedBy\")\n   @Test\n   public void testDisable_keyNotFound_shouldThrowException() throws Exception {\n     int keyId = 42;\n     KeysetHandle handle = KeysetHandle.fromKeyset(\n         TestUtil.createKeyset(createDisabledKey(keyId)));\n \n     try {\n-      KeysetManager\n-          .withKeysetHandle(handle)\n-          .disable(keyId + 1);\n+      // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+      KeysetManager.withKeysetHandle(handle).disable(keyId + 1);\n       fail(\"Expected GeneralSecurityException\");\n     } catch (GeneralSecurityException e) {\n       assertThat(e.toString()).contains(\"key not found\");\n@@ -401,11 +399,10 @@ public void testDestroy_shouldDestroyKey() throws Exception {\n         TestUtil.createKeyset(\n             createEnabledKey(primaryKeyId),\n             createEnabledKey(otherKeyId)));\n-    Keyset keyset = KeysetManager\n-        .withKeysetHandle(handle)\n-        .destroy(otherKeyId)\n-        .getKeysetHandle()\n-        .getKeyset();\n+    @SuppressWarnings(\"GuardedBy\")\n+    // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+    Keyset keyset =\n+        KeysetManager.withKeysetHandle(handle).destroy(otherKeyId).getKeysetHandle().getKeyset();\n \n     assertThat(keyset.getKeyCount()).isEqualTo(2);\n     assertThat(keyset.getKey(0).getKeyId()).isEqualTo(primaryKeyId);\n@@ -415,6 +412,7 @@ public void testDestroy_shouldDestroyKey() throws Exception {\n     assertThat(keyset.getKey(1).hasKeyData()).isFalse();\n   }\n \n+  @SuppressWarnings(\"GuardedBy\")\n   @Test\n   public void testDestroy_keyIsPrimary_shouldThrowException() throws Exception {\n     int primaryKeyId = 42;\n@@ -424,17 +422,15 @@ public void testDestroy_keyIsPrimary_shouldThrowException() throws Exception {\n             createEnabledKey(primaryKeyId),\n             createEnabledKey(otherKeyId)));\n     try {\n-      KeysetManager\n-          .withKeysetHandle(handle)\n-          .destroy(primaryKeyId)\n-          .getKeysetHandle()\n-          .getKeyset();\n+      // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+      KeysetManager.withKeysetHandle(handle).destroy(primaryKeyId).getKeysetHandle().getKeyset();\n       fail(\"Expected GeneralSecurityException\");\n     } catch (GeneralSecurityException e) {\n       assertThat(e.toString()).contains(\"cannot destroy the primary key\");\n     }\n   }\n \n+  @SuppressWarnings(\"GuardedBy\")\n   @Test\n   public void testDestroy_keyUnknownStatus_shouldThrowException() throws Exception {\n     int primaryKeyId = 42;\n@@ -444,27 +440,24 @@ public void testDestroy_keyUnknownStatus_shouldThrowException() throws Exception\n             createEnabledKey(primaryKeyId),\n             createUnknownStatusKey(otherKeyId)));\n     try {\n-      KeysetManager\n-          .withKeysetHandle(handle)\n-          .destroy(otherKeyId)\n-          .getKeysetHandle()\n-          .getKeyset();\n+      // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+      KeysetManager.withKeysetHandle(handle).destroy(otherKeyId).getKeysetHandle().getKeyset();\n       fail(\"Expected GeneralSecurityException\");\n     } catch (GeneralSecurityException e) {\n       assertThat(e.toString()).contains(\"cannot destroy key\");\n     }\n   }\n \n+  @SuppressWarnings(\"GuardedBy\")\n   @Test\n   public void testDestroy_keyNotFound_shouldThrowException() throws Exception {\n     int keyId = 42;\n     KeysetHandle handle = KeysetHandle.fromKeyset(\n         TestUtil.createKeyset(createDisabledKey(keyId)));\n \n     try {\n-      KeysetManager\n-          .withKeysetHandle(handle)\n-          .destroy(keyId + 1);\n+      // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+      KeysetManager.withKeysetHandle(handle).destroy(keyId + 1);\n       fail(\"Expected GeneralSecurityException\");\n     } catch (GeneralSecurityException e) {\n       assertThat(e.toString()).contains(\"key not found\");\n@@ -479,17 +472,17 @@ public void testDelete_shouldDeleteKey() throws Exception {\n         TestUtil.createKeyset(\n             createEnabledKey(primaryKeyId),\n             createEnabledKey(otherKeyId)));\n-    Keyset keyset = KeysetManager\n-        .withKeysetHandle(handle)\n-        .delete(otherKeyId)\n-        .getKeysetHandle()\n-        .getKeyset();\n+    @SuppressWarnings(\"GuardedBy\")\n+    // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+    Keyset keyset =\n+        KeysetManager.withKeysetHandle(handle).delete(otherKeyId).getKeysetHandle().getKeyset();\n \n     assertThat(keyset.getKeyCount()).isEqualTo(1);\n     assertThat(keyset.getKey(0).getKeyId()).isEqualTo(primaryKeyId);\n     assertThat(keyset.getKey(0).getStatus()).isEqualTo(KeyStatusType.ENABLED);\n   }\n \n+  @SuppressWarnings(\"GuardedBy\")\n   @Test\n   public void testDelete_keyIsPrimary_shouldThrowException() throws Exception {\n     int primaryKeyId = 42;\n@@ -499,17 +492,15 @@ public void testDelete_keyIsPrimary_shouldThrowException() throws Exception {\n             createEnabledKey(primaryKeyId),\n             createEnabledKey(otherKeyId)));\n     try {\n-      KeysetManager\n-          .withKeysetHandle(handle)\n-          .delete(primaryKeyId)\n-          .getKeysetHandle()\n-          .getKeyset();\n+      // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+      KeysetManager.withKeysetHandle(handle).delete(primaryKeyId).getKeysetHandle().getKeyset();\n       fail(\"Expected GeneralSecurityException\");\n     } catch (GeneralSecurityException e) {\n       assertThat(e.toString()).contains(\"cannot delete the primary key\");\n     }\n   }\n \n+  @SuppressWarnings(\"GuardedBy\")\n   @Test\n   public void testDelete_keyNotFound_shouldThrowException() throws Exception {\n     int keyId1 = 42;\n@@ -520,9 +511,8 @@ public void testDelete_keyNotFound_shouldThrowException() throws Exception {\n             createEnabledKey(keyId2)));\n \n     try {\n-      KeysetManager\n-          .withKeysetHandle(handle)\n-          .delete(44);\n+      // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+      KeysetManager.withKeysetHandle(handle).delete(44);\n       fail(\"Expected GeneralSecurityException\");\n     } catch (GeneralSecurityException e) {\n       assertThat(e.toString()).contains(\"key not found\");\n@@ -534,6 +524,7 @@ public void testRotate_shouldAddNewKeyAndSetPrimaryKeyId() throws Exception {\n     // Create a keyset that contains a single HmacKey.\n     KeyTemplate template = MacKeyTemplates.HMAC_SHA256_128BITTAG;\n     @SuppressWarnings(\"GuardedBy\")\n+    // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n     // TODO(b/145386688): This access should be guarded by 'KeysetManager.withEmptyKeyset()', which\n     // is not currently held\n     Keyset keyset = KeysetManager.withEmptyKeyset().rotate(template).getKeysetHandle().getKeyset();\n@@ -561,16 +552,20 @@ public void testRotate_bogusKeyTemplate_shouldThrowException() throws Exception\n   @Test\n   public void testRotate_existingKeyset_shouldAddNewKeyAndSetPrimaryKeyId() throws Exception {\n     @SuppressWarnings(\"GuardedBy\")\n+    // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n     // TODO(b/145386688): This access should be guarded by 'KeysetManager.withEmptyKeyset()', which\n     // is not currently held\n     KeysetHandle existing =\n         KeysetManager.withEmptyKeyset()\n             .rotate(MacKeyTemplates.HMAC_SHA256_128BITTAG)\n             .getKeysetHandle();\n-    Keyset keyset = KeysetManager.withKeysetHandle(existing)\n-        .rotate(MacKeyTemplates.HMAC_SHA256_256BITTAG)\n-        .getKeysetHandle()\n-        .getKeyset();\n+    @SuppressWarnings(\"GuardedBy\")\n+    // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+    Keyset keyset =\n+        KeysetManager.withKeysetHandle(existing)\n+            .rotate(MacKeyTemplates.HMAC_SHA256_256BITTAG)\n+            .getKeysetHandle()\n+            .getKeyset();\n \n     assertThat(keyset.getKeyCount()).isEqualTo(2);\n     assertThat(keyset.getPrimaryKeyId()).isEqualTo(keyset.getKey(1).getKeyId());\n@@ -583,6 +578,7 @@ public void testAdd_shouldAddNewKey() throws Exception {\n     // Create a keyset that contains a single HmacKey.\n     KeyTemplate template = MacKeyTemplates.HMAC_SHA256_128BITTAG;\n     @SuppressWarnings(\"GuardedBy\")\n+    // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n     // TODO(b/145386688): This access should be guarded by 'KeysetManager.withEmptyKeyset()', which\n     // is not currently held\n     Keyset keyset = KeysetManager.withEmptyKeyset().add(template).getKeysetHandle().getKeyset();\n@@ -610,17 +606,21 @@ public void testAdd_bogusKeyTemplate_shouldThrowException() throws Exception {\n   @Test\n   public void testAdd_existingKeySet_shouldAddNewKey() throws Exception {\n     @SuppressWarnings(\"GuardedBy\")\n+    // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n     // TODO(b/145386688): This access should be guarded by 'KeysetManager.withEmptyKeyset()', which\n     // is not currently held\n     KeysetHandle existing =\n         KeysetManager.withEmptyKeyset()\n             .rotate(MacKeyTemplates.HMAC_SHA256_128BITTAG)\n             .getKeysetHandle();\n     int existingPrimaryKeyId = existing.getKeyset().getPrimaryKeyId();\n-    Keyset keyset = KeysetManager.withKeysetHandle(existing)\n-        .add(MacKeyTemplates.HMAC_SHA256_256BITTAG)\n-        .getKeysetHandle()\n-        .getKeyset();\n+    @SuppressWarnings(\"GuardedBy\")\n+    // TODO(b/145386688): This access should be guarded by 'this', which could not be resolved\n+    Keyset keyset =\n+        KeysetManager.withKeysetHandle(existing)\n+            .add(MacKeyTemplates.HMAC_SHA256_256BITTAG)\n+            .getKeysetHandle()\n+            .getKeyset();\n \n     assertThat(keyset.getKeyCount()).isEqualTo(2);\n     assertThat(keyset.getPrimaryKeyId()).isEqualTo(existingPrimaryKeyId);\n@@ -635,7 +635,6 @@ public void testAddNewKey_onePrimary() throws Exception {\n     // TODO(b/145386688): This access should be guarded by 'keysetManager', which is not currently\n     // held\n     int keyId = keysetManager.addNewKey(MacKeyTemplates.HMAC_SHA256_128BITTAG, true);\n-    @SuppressWarnings(\"GuardedBy\")\n     // TODO(b/145386688): This access should be guarded by 'keysetManager', which is not currently\n     // held\n     Keyset keyset = keysetManager.getKeysetHandle().getKeyset();\n@@ -651,11 +650,9 @@ public void testAddNewKey_onePrimaryAnotherPrimary() throws Exception {\n     // TODO(b/145386688): This access should be guarded by 'keysetManager', which is not currently\n     // held\n     keysetManager.addNewKey(MacKeyTemplates.HMAC_SHA256_128BITTAG, true);\n-    @SuppressWarnings(\"GuardedBy\")\n     // TODO(b/145386688): This access should be guarded by 'keysetManager', which is not currently\n     // held\n     int primaryKeyId = keysetManager.addNewKey(MacKeyTemplates.HMAC_SHA256_128BITTAG, true);\n-    @SuppressWarnings(\"GuardedBy\")\n     // TODO(b/145386688): This access should be guarded by 'keysetManager', which is not currently\n     // held\n     Keyset keyset = keysetManager.getKeysetHandle().getKeyset();\n@@ -667,14 +664,12 @@ public void testAddNewKey_onePrimaryAnotherPrimary() throws Exception {\n   @Test\n   public void testAddNewKey_primaryThenNonPrimary() throws Exception {\n     KeysetManager keysetManager = KeysetManager.withEmptyKeyset();\n-    @SuppressWarnings(\"GuardedBy\")\n     // TODO(b/145386688): This access should be guarded by 'keysetManager', which is not currently\n     // held\n     int primaryKeyId = keysetManager.addNewKey(MacKeyTemplates.HMAC_SHA256_128BITTAG, true);\n     // TODO(b/145386688): This access should be guarded by 'keysetManager', which is not currently\n     // held\n     keysetManager.addNewKey(MacKeyTemplates.HMAC_SHA256_128BITTAG, false);\n-    @SuppressWarnings(\"GuardedBy\")\n     // TODO(b/145386688): This access should be guarded by 'keysetManager', which is not currently\n     // held\n     Keyset keyset = keysetManager.getKeysetHandle().getKeyset();\n@@ -689,14 +684,12 @@ public void testAddNewKey_addThenDestroy() throws Exception {\n     // TODO(b/145386688): This access should be guarded by 'keysetManager', which is not currently\n     // held\n     keysetManager.addNewKey(MacKeyTemplates.HMAC_SHA256_128BITTAG, true);\n-    @SuppressWarnings(\"GuardedBy\")\n     // TODO(b/145386688): This access should be guarded by 'keysetManager', which is not currently\n     // held\n     int secondaryKeyId = keysetManager.addNewKey(MacKeyTemplates.HMAC_SHA256_128BITTAG, false);\n     // TODO(b/145386688): This access should be guarded by 'keysetManager', which is not currently\n     // held\n     keysetManager.destroy(secondaryKeyId);\n-    @SuppressWarnings(\"GuardedBy\")\n     // TODO(b/145386688): This access should be guarded by 'keysetManager', which is not currently\n     // held\n     Keyset keyset = keysetManager.getKeysetHandle().getKeyset();",
      "parent_sha": "9fb0041d201e1af060beebd07685891284f14cdc"
    }
  },
  {
    "oid": "eab544062e6b7a56f3b8d54fd62c32a5b21701e9",
    "message": "Remove deprecation of SharedPrefKeysetWriter, but add a comment that it is not recommended, which some instruction on what to do instead.\n\nPiperOrigin-RevId: 601054094",
    "date": "2024-01-24T10:20:52Z",
    "url": "https://github.com/tink-crypto/tink/commit/eab544062e6b7a56f3b8d54fd62c32a5b21701e9",
    "details": {
      "sha": "5dfc307e86c4efe8b2622bf5b704cf2882a0f961",
      "filename": "java_src/src/main/java/com/google/crypto/tink/integration/android/SharedPrefKeysetWriter.java",
      "status": "modified",
      "additions": 46,
      "deletions": 4,
      "changes": 50,
      "blob_url": "https://github.com/tink-crypto/tink/blob/eab544062e6b7a56f3b8d54fd62c32a5b21701e9/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FSharedPrefKeysetWriter.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/eab544062e6b7a56f3b8d54fd62c32a5b21701e9/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FSharedPrefKeysetWriter.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FSharedPrefKeysetWriter.java?ref=eab544062e6b7a56f3b8d54fd62c32a5b21701e9",
      "patch": "@@ -28,11 +28,53 @@\n /**\n  * A {@link KeysetWriter} that can write keysets to private shared preferences on Android.\n  *\n- * @since 1.0.0\n- * @deprecated We do not expect anyone to use this class. Please file an issue on\n- *     github.com/tink-crypto/tink-java/ if you need to replace this.\n+ * <p>We do not recommend new uses of this class. Instead, if you want to store a Tink keyset in\n+ * shared preferences, serialize the keyset using TinkProtoKeysetFormat, and write it hex-encoded\n+ * into your SharedPreferences manually.\n+ *\n+ * <p>For example, to write an encrypted keyset to the shared preferences, you can replace this:\n+ *\n+ * <pre>{@code\n+ * keysetHandle.write(\n+ *     new SharedPrefKeysetWriter(\n+ *         ApplicationProvider.getApplicationContext(), keysetName, null),\n+ *     keysetEncryptionAead);\n+ * }</pre>\n+ *\n+ * <p>with this:\n+ *\n+ * <pre>{@code\n+ * byte[] encryptedKeyset =\n+ *     TinkProtoKeysetFormat.serializeEncryptedKeyset(\n+ *         handle, keysetEncryptionAead, new byte[0]);\n+ * SharedPreferences.Editor editor =\n+ *     PreferenceManager.getDefaultSharedPreferences(\n+ *             ApplicationProvider.getApplicationContext().getApplicationContext())\n+ *         .edit();\n+ * boolean success = editor.putString(keysetName, Hex.encode(encryptedKeyset)).commit();\n+ * }</pre>\n+ *\n+ * <p>and to write an unencrypted keyset to the shared preferences, you can replace this:\n+ *\n+ * <pre>{@code\n+ * CleartextKeysetHandle.write(\n+ *     handle,\n+ *     new SharedPrefKeysetWriter(\n+ *         ApplicationProvider.getApplicationContext(), keysetName, null));\n+ * }</pre>\n+ *\n+ * <p>with this:\n+ *\n+ * <pre>{@code\n+ * byte[] serializedKeyset =\n+ *     TinkProtoKeysetFormat.serializeKeyset(handle, InsecureSecretKeyAccess.get());\n+ * SharedPreferences.Editor editor =\n+ *     PreferenceManager.getDefaultSharedPreferences(\n+ *         ApplicationProvider.getApplicationContext().getApplicationContext())\n+ *     .edit();\n+ * boolean success = editor.putString(keysetName, Hex.encode(serializedKeyset)).commit();\n+ * }</pre>\n  */\n-@Deprecated\n public final class SharedPrefKeysetWriter implements KeysetWriter {\n   private final SharedPreferences.Editor editor;\n   private final String keysetName;",
      "parent_sha": "4f3dc6901d74d7c470963d3fe5cb91103e73b344"
    }
  },
  {
    "oid": "2e1fd536478d9c952aa5a514c7689776a867b355",
    "message": "Add test with JWT payload with two identical claim names.\n\nAlso, fix the name of one of the tests.\n\nPiperOrigin-RevId: 474342738",
    "date": "2022-09-14T18:19:15Z",
    "url": "https://github.com/tink-crypto/tink/commit/2e1fd536478d9c952aa5a514c7689776a867b355",
    "details": {
      "sha": "40b7033beaa2d19473f3dd2c30adf9441aa6e8cd",
      "filename": "java_src/src/test/java/com/google/crypto/tink/jwt/RawJwtTest.java",
      "status": "modified",
      "additions": 10,
      "deletions": 1,
      "changes": 11,
      "blob_url": "https://github.com/tink-crypto/tink/blob/2e1fd536478d9c952aa5a514c7689776a867b355/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FRawJwtTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/2e1fd536478d9c952aa5a514c7689776a867b355/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FRawJwtTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FRawJwtTest.java?ref=2e1fd536478d9c952aa5a514c7689776a867b355",
      "patch": "@@ -600,7 +600,7 @@ public void fromInvalidJsonPayload_shouldThrow() throws Exception {\n   }\n \n   @Test\n-  public void fromJsonPayloadWithValidJsonEscapedCharacter_shouldThrow() throws Exception {\n+  public void fromJsonPayloadWithValidJsonEscapedCharacter_success() throws Exception {\n     RawJwt token = RawJwt.fromJsonPayload(Optional.empty(), \"{\\\"iss\\\":\\\"\\\\uD834\\\\uDD1E\\\"}\");\n     assertThat(token.hasIssuer()).isTrue();\n     assertThat(token.getIssuer()).isEqualTo(\"\\uD834\\uDD1E\");\n@@ -646,6 +646,15 @@ public void fromJsonPayloadWithComments_shouldThrow () throws Exception {\n     assertThrows(JwtInvalidException.class, () -> RawJwt.fromJsonPayload(Optional.empty(), input));\n   }\n \n+  @Test\n+  public void fromJsonPayloadWithTwoIdenticalClaimNames_firstIsIgnored() throws Exception {\n+    String input = \"{\\\"claim\\\": \\\"claim1\\\", \\\"claim\\\": \\\"claim2\\\"}\";\n+    RawJwt token = RawJwt.fromJsonPayload(Optional.empty(), input);\n+    assertThat(token.hasStringClaim(\"claim\")).isTrue();\n+    assertThat(token.getStringClaim(\"claim\")).isEqualTo(\"claim2\");\n+  }\n+\n+\n   @Test\n   public void fromJsonPayloadWithEscapedChars_success() throws Exception {\n     String input = \"{\\\"i\\\\u0073\\\\u0073\\\": \\\"\\\\u0061lice\\\"}\";",
      "parent_sha": "e4299327d1da17b76586de9581ac775e08578d6a"
    }
  },
  {
    "oid": "ce8d052451bb510d1e254396e2022187fd3c899a",
    "message": "Remove reader and writer from the builder instance.\n\nInstead, create it when needed from the parameters passed to the builder.\n\nAlso, add validation of keysetName.\n\nPiperOrigin-RevId: 503921979",
    "date": "2023-01-23T09:56:42Z",
    "url": "https://github.com/tink-crypto/tink/commit/ce8d052451bb510d1e254396e2022187fd3c899a",
    "details": {
      "sha": "5283e5cacf5f09cd4de49ca7051fec98425d5076",
      "filename": "java_src/src/main/java/com/google/crypto/tink/integration/android/AndroidKeysetManager.java",
      "status": "modified",
      "additions": 14,
      "deletions": 5,
      "changes": 19,
      "blob_url": "https://github.com/tink-crypto/tink/blob/ce8d052451bb510d1e254396e2022187fd3c899a/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeysetManager.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/ce8d052451bb510d1e254396e2022187fd3c899a/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeysetManager.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeysetManager.java?ref=ce8d052451bb510d1e254396e2022187fd3c899a",
      "patch": "@@ -132,7 +132,7 @@ public final class AndroidKeysetManager {\n   private KeysetManager keysetManager;\n \n   private AndroidKeysetManager(Builder builder) {\n-    writer = builder.writer;\n+    writer = new SharedPrefKeysetWriter(builder.context, builder.keysetName, builder.prefFileName);\n     masterKey = builder.masterKey;\n     keysetManager = builder.keysetManager;\n   }\n@@ -143,8 +143,10 @@ private AndroidKeysetManager(Builder builder) {\n    * <p>This class is thread-safe.\n    */\n   public static final class Builder {\n-    private KeysetReader reader = null;\n-    private KeysetWriter writer = null;\n+    private Context context = null;\n+    private String keysetName = null;\n+    private String prefFileName = null;\n+\n     private String masterKeyUri = null;\n     private Aead masterKey = null;\n     private boolean useKeystore = true;\n@@ -166,8 +168,10 @@ public Builder withSharedPref(Context context, String keysetName, String prefFil\n       if (keysetName == null) {\n         throw new IllegalArgumentException(\"need a keyset name\");\n       }\n-      reader = new SharedPrefKeysetReader(context, keysetName, prefFileName);\n-      writer = new SharedPrefKeysetWriter(context, keysetName, prefFileName);\n+      this.context = context;\n+      this.keysetName = keysetName;\n+      this.prefFileName = prefFileName;\n+\n       return this;\n     }\n \n@@ -244,6 +248,9 @@ Builder withKeyStore(KeyStore val) {\n      * @throws GeneralSecurityException If cannot read an existing keyset or generate a new one.\n      */\n     public synchronized AndroidKeysetManager build() throws GeneralSecurityException, IOException {\n+      if (keysetName == null) {\n+        throw new IllegalArgumentException(\"keysetName cannot be null\");\n+      }\n       // readOrGenerateNewMasterKey() and readOrGenerateNewKeyset() involve shared pref filesystem\n       // operations. To control access to this global state in multi-threaded contexts we need to\n       // ensure mutual exclusion of these functions.\n@@ -318,6 +325,7 @@ private KeysetManager readOrGenerateNewKeyset() throws GeneralSecurityException,\n       KeysetManager manager = KeysetManager.withEmptyKeyset().add(keyTemplate);\n       int keyId = manager.getKeysetHandle().getKeysetInfo().getKeyInfo(0).getKeyId();\n       manager = manager.setPrimary(keyId);\n+      KeysetWriter writer = new SharedPrefKeysetWriter(context, keysetName, prefFileName);\n       if (masterKey != null) {\n         manager.getKeysetHandle().write(writer, masterKey);\n       } else {\n@@ -328,6 +336,7 @@ private KeysetManager readOrGenerateNewKeyset() throws GeneralSecurityException,\n \n     @SuppressWarnings(\"UnusedException\")\n     private KeysetManager read() throws GeneralSecurityException, IOException {\n+      KeysetReader reader = new SharedPrefKeysetReader(context, keysetName, prefFileName);\n       if (masterKey != null) {\n         try {\n           return KeysetManager.withKeysetHandle(KeysetHandle.read(reader, masterKey));",
      "parent_sha": "8caaaca75a7317ddccc22723e50197040ffb2a92"
    }
  },
  {
    "oid": "5a2ab68b69771c6827cb16fe1093dbdb4ac57712",
    "message": "Fixing an invalid documentation link that was causing a 404 Not Found error\n\nPiperOrigin-RevId: 378875719",
    "date": "2021-06-11T15:21:46Z",
    "url": "https://github.com/tink-crypto/tink/commit/5a2ab68b69771c6827cb16fe1093dbdb4ac57712",
    "details": {
      "sha": "6778fd688fc9bf4f26839594304bfc794e0d9b02",
      "filename": "examples/java_src/gcs/GcsEnvelopeAeadExample.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/tink-crypto/tink/blob/5a2ab68b69771c6827cb16fe1093dbdb4ac57712/examples%2Fjava_src%2Fgcs%2FGcsEnvelopeAeadExample.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/5a2ab68b69771c6827cb16fe1093dbdb4ac57712/examples%2Fjava_src%2Fgcs%2FGcsEnvelopeAeadExample.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/examples%2Fjava_src%2Fgcs%2FGcsEnvelopeAeadExample.java?ref=5a2ab68b69771c6827cb16fe1093dbdb4ac57712",
      "patch": "@@ -124,7 +124,7 @@ public static void main(String[] args) throws Exception {\n       String gcsBlobPath = args[5];\n       // This will bind the encryption to the location of the GCS blob. That if, if you rename or\n       // move the blob to a different bucket, decryption will fail.\n-      // See https://developers.google.com/tink/AEAD#associated_data.\n+      // See https://developers.google.com/tink/aead#associated_data.\n       byte[] associatedData = gcsBlobPath.getBytes(UTF_8);\n       byte[] ciphertext = aead.encrypt(input, associatedData);\n ",
      "parent_sha": "fe09c05c55222702dd70d744fb9b96d955c6d501"
    }
  },
  {
    "oid": "3b2d647fa122a200117d79e19a231ef40ba12952",
    "message": "When comparing KeyManager instances, compare only the class names.\n\nWe used to compare the whole classes, which might not work when multiple versions of Tink are loaded with different class loaders.\n\nMake the same change w.r.t PrimitiveWrapper, etc.\n\nPiperOrigin-RevId: 367078887",
    "date": "2021-04-06T20:54:40Z",
    "url": "https://github.com/tink-crypto/tink/commit/3b2d647fa122a200117d79e19a231ef40ba12952",
    "details": {
      "sha": "93f253409ed68ec1a066d010811f7030d9c83b2e",
      "filename": "java_src/src/main/java/com/google/crypto/tink/Registry.java",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/tink-crypto/tink/blob/3b2d647fa122a200117d79e19a231ef40ba12952/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistry.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/3b2d647fa122a200117d79e19a231ef40ba12952/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistry.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistry.java?ref=3b2d647fa122a200117d79e19a231ef40ba12952",
      "patch": "@@ -295,16 +295,13 @@ private <KeyFormatProtoT extends MessageLite> MessageLite deriveKeyWithFactory(\n       @Override\n       public KeyData deriveKey(ByteString serializedKeyFormat, InputStream stream)\n           throws GeneralSecurityException {\n-        KeyTypeManager.KeyFactory<?, KeyProtoT> keyFactory;\n-        keyFactory = keyManager.keyFactory();\n+        KeyTypeManager.KeyFactory<?, KeyProtoT> keyFactory = keyManager.keyFactory();\n         MessageLite keyValue = deriveKeyWithFactory(serializedKeyFormat, stream, keyFactory);\n-        KeyData keyData =\n-            KeyData.newBuilder()\n-                .setTypeUrl(keyManager.getKeyType())\n-                .setValue(keyValue.toByteString())\n-                .setKeyMaterialType(keyManager.keyMaterialType())\n-                .build();\n-        return keyData;\n+        return KeyData.newBuilder()\n+            .setTypeUrl(keyManager.getKeyType())\n+            .setValue(keyValue.toByteString())\n+            .setKeyMaterialType(keyManager.keyMaterialType())\n+            .build();\n       }\n     };\n   }\n@@ -355,7 +352,7 @@ public static synchronized void addCatalogue(String catalogueName, Catalogue<?>\n     }\n     if (catalogueMap.containsKey(catalogueName.toLowerCase(Locale.US))) {\n       Catalogue<?> existing = catalogueMap.get(catalogueName.toLowerCase(Locale.US));\n-      if (!catalogue.getClass().equals(existing.getClass())) {\n+      if (!catalogue.getClass().getName().equals(existing.getClass().getName())) {\n         logger.warning(\n             \"Attempted overwrite of a catalogueName catalogue for name \" + catalogueName);\n         throw new GeneralSecurityException(\n@@ -526,7 +523,9 @@ void registerAsymmetricKeyManagers(\n       Class<?> existingPublicKeyManagerClass =\n           keyManagerMap.get(privateTypeUrl).publicKeyManagerClassOrNull();\n       if (existingPublicKeyManagerClass != null) {\n-        if (!existingPublicKeyManagerClass.equals(publicKeyTypeManager.getClass())) {\n+        if (!existingPublicKeyManagerClass\n+            .getName()\n+            .equals(publicKeyTypeManager.getClass().getName())) {\n           logger.warning(\n               \"Attempted overwrite of a registered key manager for key type \"\n                   + privateTypeUrl\n@@ -624,11 +623,12 @@ public static synchronized <B, P> void registerPrimitiveWrapper(\n       @SuppressWarnings(\"unchecked\") // We know that we only inserted objects of the correct type.\n       PrimitiveWrapper<?, P> existingWrapper =\n           (PrimitiveWrapper<?, P>) primitiveWrapperMap.get(classObject);\n-      if (!wrapper.getClass().equals(existingWrapper.getClass())) {\n-        logger.warning(\"Attempted overwrite of a registered SetWrapper for type \" + classObject);\n+      if (!wrapper.getClass().getName().equals(existingWrapper.getClass().getName())) {\n+        logger.warning(\n+            \"Attempted overwrite of a registered PrimitiveWrapper for type \" + classObject);\n         throw new GeneralSecurityException(\n             String.format(\n-                \"SetWrapper for primitive (%s) is already registered to be %s, \"\n+                \"PrimitiveWrapper for primitive (%s) is already registered to be %s, \"\n                     + \"cannot be re-registered with %s\",\n                 classObject.getName(),\n                 existingWrapper.getClass().getName(),",
      "parent_sha": "8682c85e46191604f74f80e11b275ddc3d269d8f"
    }
  },
  {
    "oid": "626f1f243881c849ed0cff694190a0d4e53bff68",
    "message": "Remove \"under consideration\" markers for \"NoSecretKeysetHandle\".\n\nPiperOrigin-RevId: 519710774",
    "date": "2023-03-27T14:06:21Z",
    "url": "https://github.com/tink-crypto/tink/commit/626f1f243881c849ed0cff694190a0d4e53bff68",
    "details": {
      "sha": "98e0a5c7adb3a62534972c92f23edf8c31d8bafe",
      "filename": "java_src/src/main/java/com/google/crypto/tink/NoSecretKeysetHandle.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/tink-crypto/tink/blob/626f1f243881c849ed0cff694190a0d4e53bff68/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FNoSecretKeysetHandle.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/626f1f243881c849ed0cff694190a0d4e53bff68/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FNoSecretKeysetHandle.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FNoSecretKeysetHandle.java?ref=626f1f243881c849ed0cff694190a0d4e53bff68",
      "patch": "@@ -29,15 +29,15 @@\n  * @since 1.0.0\n  * @deprecated use {@link KeysetHandle#readNoSecret} instead\n  */\n-@Deprecated /* Deprecation under consideration */\n+@Deprecated\n public final class NoSecretKeysetHandle {\n   /**\n    * @return a new keyset handle from {@code serialized} which is a serialized {@link Keyset}.\n    * @throws GeneralSecurityException\n    * @deprecated use {@link NoSecretKeysetHandle#read} instead\n    */\n   @SuppressWarnings(\"UnusedException\")\n-  @Deprecated /* Deprecation under consideration */\n+  @Deprecated\n   public static final KeysetHandle parseFrom(final byte[] serialized)\n       throws GeneralSecurityException {\n     try {",
      "parent_sha": "dc51abd101cbd45d16991c6e322dc34e32ecb6a3"
    }
  },
  {
    "oid": "51f733cc70556e5e745c150dbf2717a1cdd612c5",
    "message": "Make a test utility class final.\n\nPiperOrigin-RevId: 543723011",
    "date": "2023-06-27T13:16:21Z",
    "url": "https://github.com/tink-crypto/tink/commit/51f733cc70556e5e745c150dbf2717a1cdd612c5",
    "details": {
      "sha": "a25e4adb72f2ec9956f7cc04692ccd01ca03712c",
      "filename": "java_src/src/main/java/com/google/crypto/tink/mac/internal/AesCmacTestUtil.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/tink-crypto/tink/blob/51f733cc70556e5e745c150dbf2717a1cdd612c5/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fmac%2Finternal%2FAesCmacTestUtil.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/51f733cc70556e5e745c150dbf2717a1cdd612c5/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fmac%2Finternal%2FAesCmacTestUtil.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fmac%2Finternal%2FAesCmacTestUtil.java?ref=51f733cc70556e5e745c150dbf2717a1cdd612c5",
      "patch": "@@ -222,7 +222,7 @@ public static AesCmacParameters createAesCmacParameters(\n   /**\n    * Represents a single AesCmac test vector.\n    */\n-  public static class AesCmacTestVector {\n+  public static final class AesCmacTestVector {\n     public final AesCmacKey key;\n     public final byte[] message;\n     public final byte[] tag;",
      "parent_sha": "a76f5689c6b7a35948b518d7d4a38614e8485c9d"
    }
  },
  {
    "oid": "77d30855a674a7c2c06f2cc7245abd1eb618d199",
    "message": "Remove implementation of an internal test method.\n\nPiperOrigin-RevId: 281451742",
    "date": "2019-11-20T06:21:30Z",
    "url": "https://github.com/tink-crypto/tink/commit/77d30855a674a7c2c06f2cc7245abd1eb618d199",
    "details": {
      "sha": "e982951618adfc0e9cf5a25ca423699f35ff63a9",
      "filename": "java/src/main/java/com/google/crypto/tink/testing/TestUtil.java",
      "status": "modified",
      "additions": 1,
      "deletions": 11,
      "changes": 12,
      "blob_url": "https://github.com/tink-crypto/tink/blob/77d30855a674a7c2c06f2cc7245abd1eb618d199/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Ftesting%2FTestUtil.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/77d30855a674a7c2c06f2cc7245abd1eb618d199/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Ftesting%2FTestUtil.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Ftesting%2FTestUtil.java?ref=77d30855a674a7c2c06f2cc7245abd1eb618d199",
      "patch": "@@ -557,17 +557,7 @@ public static boolean isRemoteBuildExecution() {\n    * google.\n    */\n   public static boolean isTsan() {\n-    // Keep synchronized with google3/third_party/tink/copybara/java.bara.sky\n-    try {\n-      return (Boolean)\n-          Class.forName(\"com.google.devtools.java.sanitizers.Sanitizers\")\n-              .getMethod(\"runningWithTsan\")\n-              .invoke(null);\n-    } catch (Exception e) {\n-      // if anything goes wrong, we're not really sure and return false (which usually will imply\n-      // that the test runs, so we are safe).\n-      return false;\n-    }\n+    return false;\n   }\n \n   /** Returns whether we should skip a test with some AES key size. */",
      "parent_sha": "72383d6eb144a803bad541481f52ef238f5ae7f1"
    }
  },
  {
    "oid": "66c479462661c01f4d4f52a04b14c6e220c10cfe",
    "message": "Make the constructor of HmacPrfKeyManager package visible.\n\nThis was never intended to be public, and to the best of our knowledge nobody uses this.\n\nPiperOrigin-RevId: 592465420",
    "date": "2023-12-20T08:24:07Z",
    "url": "https://github.com/tink-crypto/tink/commit/66c479462661c01f4d4f52a04b14c6e220c10cfe",
    "details": {
      "sha": "275377aa1576eabfe77de0bf026ef34ce755fcb5",
      "filename": "java_src/src/main/java/com/google/crypto/tink/prf/HmacPrfKeyManager.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/tink-crypto/tink/blob/66c479462661c01f4d4f52a04b14c6e220c10cfe/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fprf%2FHmacPrfKeyManager.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/66c479462661c01f4d4f52a04b14c6e220c10cfe/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fprf%2FHmacPrfKeyManager.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fprf%2FHmacPrfKeyManager.java?ref=66c479462661c01f4d4f52a04b14c6e220c10cfe",
      "patch": "@@ -56,7 +56,7 @@\n  * PrfHmacJce}.\n  */\n public final class HmacPrfKeyManager extends KeyTypeManager<HmacPrfKey> {\n-  public HmacPrfKeyManager() {\n+  HmacPrfKeyManager() {\n     super(\n         HmacPrfKey.class,\n         new PrimitiveFactory<Prf, HmacPrfKey>(Prf.class) {",
      "parent_sha": "9caae4abd88c5b727a61c844635cea67744baf26"
    }
  },
  {
    "oid": "be4c41a11b577804851ca58935cce34e29ee47f8",
    "message": "Store the List<Key> objects in the KeysetHandle, as well as the primaryIndex.\n\nIt is better to store the Key objects instead of making them each time they are needed on the fly.\n\nSince currently a Key object may not exist (if parsing fails, or if the KeyStatus is invalid), the List can contain null objects.\n\nPiperOrigin-RevId: 499421429",
    "date": "2023-01-04T09:26:57Z",
    "url": "https://github.com/tink-crypto/tink/commit/be4c41a11b577804851ca58935cce34e29ee47f8",
    "details": {
      "sha": "a718c1f0289d2df67926cb2474dbd95546cdb42c",
      "filename": "java_src/src/main/java/com/google/crypto/tink/KeysetHandle.java",
      "status": "modified",
      "additions": 63,
      "deletions": 32,
      "changes": 95,
      "blob_url": "https://github.com/tink-crypto/tink/blob/be4c41a11b577804851ca58935cce34e29ee47f8/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/be4c41a11b577804851ca58935cce34e29ee47f8/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java?ref=be4c41a11b577804851ca58935cce34e29ee47f8",
      "patch": "@@ -391,7 +391,7 @@ public KeysetHandle build() throws GeneralSecurityException {\n         throw new GeneralSecurityException(\"No primary was set\");\n       }\n       keysetBuilder.setPrimaryKeyId(primaryId);\n-      return new KeysetHandle(keysetBuilder.build());\n+      return KeysetHandle.fromKeyset(keysetBuilder.build());\n     }\n   }\n \n@@ -487,6 +487,31 @@ private static Keyset.Key toKeysetKey(\n         .build();\n   }\n \n+  /**\n+   * Returns an immutable list of key objects for this keyset.\n+   *\n+   * <p>If a status is unparseable or parsing of a key fails, there will be \"null\" in the\n+   * corresponding entry.\n+   */\n+  private static List<Entry> getEntriesFromKeyset(Keyset keyset) {\n+    List<Entry> result = new ArrayList<>(keyset.getKeyCount());\n+    for (Keyset.Key protoKey : keyset.getKeyList()) {\n+      int id = protoKey.getKeyId();\n+      ProtoKeySerialization protoKeySerialization = toProtoKeySerialization(protoKey);\n+      try {\n+        Key key =\n+            MutableSerializationRegistry.globalInstance()\n+                .parseKeyWithLegacyFallback(protoKeySerialization, InsecureSecretKeyAccess.get());\n+        result.add(\n+            new KeysetHandle.Entry(\n+                key, parseStatus(protoKey.getStatus()), id, id == keyset.getPrimaryKeyId()));\n+      } catch (GeneralSecurityException e) {\n+        result.add(null);\n+      }\n+    }\n+    return Collections.unmodifiableList(result);\n+  }\n+\n   private static ProtoKeySerialization toProtoKeySerialization(Keyset.Key protoKey) {\n     int id = protoKey.getKeyId();\n     @Nullable\n@@ -505,21 +530,13 @@ private static ProtoKeySerialization toProtoKeySerialization(Keyset.Key protoKey\n   }\n \n   private KeysetHandle.Entry entryByIndex(int i) {\n-    Keyset.Key protoKey = keyset.getKey(i);\n-    int id = protoKey.getKeyId();\n-\n-    ProtoKeySerialization protoKeySerialization = toProtoKeySerialization(protoKey);\n-    try {\n-      Key key =\n-        MutableSerializationRegistry.globalInstance()\n-            .parseKeyWithLegacyFallback(protoKeySerialization, InsecureSecretKeyAccess.get());\n-      return new KeysetHandle.Entry(\n-          key, parseStatus(protoKey.getStatus()), id, id == keyset.getPrimaryKeyId());\n-    } catch (GeneralSecurityException e) {\n+    if (entries.get(i) == null) {\n       // This may happen if a keyset without status makes it here; or if a key has a parser\n       // registered but parsing fails. We should reject such keysets earlier instead.\n-      throw new IllegalStateException(\"Creating an entry failed\", e);\n+      throw new IllegalStateException(\n+          \"Keyset-Entry at position i has wrong status or key parsing failed\");\n     }\n+    return entries.get(i);\n   }\n \n   /**\n@@ -568,15 +585,24 @@ public static KeysetHandle.Builder.Entry generateEntryFromParameters(Parameters\n   }\n \n   private final Keyset keyset;\n+  /* Note: this should be List<@Nullable Entry>; but since we use the Nullable annotation from\n+   * javax.annotation it is not possible to do this.\n+   *\n+   * Contains all entries; but if either parsing the status or the key failed, contains null.\n+   */\n+  private final List<Entry> entries;\n   private final MonitoringAnnotations annotations;\n \n-  private KeysetHandle(Keyset keyset) {\n+  private KeysetHandle(Keyset keyset, List<Entry> entries) {\n     this.keyset = keyset;\n+    this.entries = entries;\n     this.annotations = MonitoringAnnotations.EMPTY;\n   }\n \n-  private KeysetHandle(Keyset keyset, MonitoringAnnotations annotations) {\n+  private KeysetHandle(\n+      Keyset keyset, List<Entry> entries, MonitoringAnnotations annotations) {\n     this.keyset = keyset;\n+    this.entries = entries;\n     this.annotations = annotations;\n   }\n \n@@ -586,7 +612,9 @@ private KeysetHandle(Keyset keyset, MonitoringAnnotations annotations) {\n    */\n   static final KeysetHandle fromKeyset(Keyset keyset) throws GeneralSecurityException {\n     assertEnoughKeyMaterial(keyset);\n-    return new KeysetHandle(keyset);\n+    List<Entry> entries = getEntriesFromKeyset(keyset);\n+\n+    return new KeysetHandle(keyset, entries);\n   }\n \n   /**\n@@ -596,7 +624,8 @@ static final KeysetHandle fromKeyset(Keyset keyset) throws GeneralSecurityExcept\n   static final KeysetHandle fromKeysetAndAnnotations(\n       Keyset keyset, MonitoringAnnotations annotations) throws GeneralSecurityException {\n     assertEnoughKeyMaterial(keyset);\n-    return new KeysetHandle(keyset, annotations);\n+    List<Entry> entries = getEntriesFromKeyset(keyset);\n+    return new KeysetHandle(keyset, entries, annotations);\n   }\n \n   /**\n@@ -771,7 +800,7 @@ public static final KeysetHandle readWithAssociatedData(\n       throws GeneralSecurityException, IOException {\n     EncryptedKeyset encryptedKeyset = reader.readEncrypted();\n     assertEnoughEncryptedKeyMaterial(encryptedKeyset);\n-    return new KeysetHandle(decrypt(encryptedKeyset, masterKey, associatedData));\n+    return KeysetHandle.fromKeyset(decrypt(encryptedKeyset, masterKey, associatedData));\n   }\n \n   /**\n@@ -913,7 +942,7 @@ public KeysetHandle getPublicKeysetHandle() throws GeneralSecurityException {\n       keysetBuilder.addKey(key.toBuilder().setKeyData(keyData).build());\n     }\n     keysetBuilder.setPrimaryKeyId(keyset.getPrimaryKeyId());\n-    return new KeysetHandle(keysetBuilder.build());\n+    return KeysetHandle.fromKeyset(keysetBuilder.build());\n   }\n \n   private static KeyData createPublicKeyData(KeyData privateKeyData)\n@@ -990,15 +1019,21 @@ private <B, P> P getPrimitiveWithKnownInputPrimitive(\n     Util.validateKeyset(keyset);\n     PrimitiveSet.Builder<B> builder = PrimitiveSet.newBuilder(inputPrimitiveClassObject);\n     builder.setAnnotations(annotations);\n-    for (Keyset.Key key : keyset.getKeyList()) {\n-      if (key.getStatus().equals(KeyStatusType.ENABLED)) {\n-        @Nullable B primitive = getLegacyPrimitiveOrNull(key, inputPrimitiveClassObject);\n-        @Nullable B fullPrimitive = getFullPrimitiveOrNull(key, inputPrimitiveClassObject);\n+    for (int i = 0; i < size(); ++i) {\n+      Keyset.Key protoKey = keyset.getKey(i);\n+      if (protoKey.getStatus().equals(KeyStatusType.ENABLED)) {\n+        @Nullable B primitive = getLegacyPrimitiveOrNull(protoKey, inputPrimitiveClassObject);\n+        @Nullable B fullPrimitive = null;\n+        // Entries.get(i) may be null (if the status is invalid in the proto, or parsing failed.\n+        if (entries.get(i) != null) {\n+          fullPrimitive =\n+              getFullPrimitiveOrNull(entries.get(i).getKey(), inputPrimitiveClassObject);\n+        }\n \n-        if (key.getKeyId() == keyset.getPrimaryKeyId()) {\n-          builder.addPrimaryFullPrimitiveAndOptionalPrimitive(fullPrimitive, primitive, key);\n+        if (protoKey.getKeyId() == keyset.getPrimaryKeyId()) {\n+          builder.addPrimaryFullPrimitiveAndOptionalPrimitive(fullPrimitive, primitive, protoKey);\n         } else {\n-          builder.addFullPrimitiveAndOptionalPrimitive(fullPrimitive, primitive, key);\n+          builder.addFullPrimitiveAndOptionalPrimitive(fullPrimitive, primitive, protoKey);\n         }\n       }\n     }\n@@ -1065,14 +1100,10 @@ private static <B> B getLegacyPrimitiveOrNull(Keyset.Key key, Class<B> inputPrim\n   }\n \n   @Nullable\n-  private static <B> B getFullPrimitiveOrNull(Keyset.Key key, Class<B> inputPrimitiveClassObject)\n+  private <B> B getFullPrimitiveOrNull(Key key, Class<B> inputPrimitiveClassObject)\n       throws GeneralSecurityException {\n-    ProtoKeySerialization protoKeySerialization = toProtoKeySerialization(key);\n-    Key keyObject =\n-        MutableSerializationRegistry.globalInstance()\n-            .parseKeyWithLegacyFallback(protoKeySerialization, InsecureSecretKeyAccess.get());\n     try {\n-      return Registry.getFullPrimitive(keyObject, inputPrimitiveClassObject);\n+      return Registry.getFullPrimitive(key, inputPrimitiveClassObject);\n     } catch (GeneralSecurityException e) {\n       // Ignoring because the key may not yet have a corresponding class.\n       // TODO(lizatretyakova): stop ignoring when all key classes are migrated from protos.",
      "parent_sha": "b54fa937af41f6d14c34148af1f15a4d4c32f386"
    }
  },
  {
    "oid": "7c5e1a4737903fdfbdeefde283daeb62eb5c3a3c",
    "message": "Add an additional GCP KMS integration test.\n\nThis tests that two keys in the same \"key ring\" on GCP cannot decrypt each other.\n\nI don't want to add the new test key URI to TestUtil, I think it's better to have them local in this test for now.\n\nPiperOrigin-RevId: 485611924",
    "date": "2022-11-02T16:14:29Z",
    "url": "https://github.com/tink-crypto/tink/commit/7c5e1a4737903fdfbdeefde283daeb62eb5c3a3c",
    "details": {
      "sha": "9d8d2da6d709bc20693949d4358d8a51386c3a03",
      "filename": "java_src/src/test/java/com/google/crypto/tink/integration/gcpkms/GcpKmsIntegrationTest.java",
      "status": "modified",
      "additions": 74,
      "deletions": 2,
      "changes": 76,
      "blob_url": "https://github.com/tink-crypto/tink/blob/7c5e1a4737903fdfbdeefde283daeb62eb5c3a3c/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fgcpkms%2FGcpKmsIntegrationTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/7c5e1a4737903fdfbdeefde283daeb62eb5c3a3c/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fgcpkms%2FGcpKmsIntegrationTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fgcpkms%2FGcpKmsIntegrationTest.java?ref=7c5e1a4737903fdfbdeefde283daeb62eb5c3a3c",
      "patch": "@@ -38,6 +38,21 @@\n /** Integration tests for Tink's GcpKmsClient with the real GCP Cloud KMS. */\n @RunWith(JUnit4.class)\n public class GcpKmsIntegrationTest {\n+\n+  // A valid GCP KMS AEAD key URI.\n+  // It is restricted to the service account in {@link\n+  // com.google.crypto.tink.testing.TestUtil#SERVICE_ACCOUNT_FILE}.\n+  private static final String GCP_KMS_TEST_KEY_URI =\n+      \"gcp-kms://projects/tink-test-infrastructure/locations/global/keyRings/\"\n+          + \"unit-and-integration-testing/cryptoKeys/aead-key\";\n+\n+  // Another valid GCP KMS AEAD key URI in the same key ring as {@link #GCP_KMS_TEST_KEY_URI}.\n+  // It is restricted to the service account in {@link\n+  // com.google.crypto.tink.testing.TestUtil#SERVICE_ACCOUNT_FILE}.\n+  private static final String GCP_KMS_TEST_KEY_URI_2 =\n+      \"gcp-kms://projects/tink-test-infrastructure/locations/global/keyRings/\"\n+          + \"unit-and-integration-testing/cryptoKeys/aead2-key\";\n+\n   @Before\n   public void setUp() throws Exception {\n     GcpKmsClient.register(Optional.empty(), Optional.of(TestUtil.SERVICE_ACCOUNT_FILE));\n@@ -48,7 +63,7 @@ public void setUp() throws Exception {\n   public void kmsAead_encryptDecrypt() throws Exception {\n     KeysetHandle keysetHandle =\n         KeysetHandle.generateNew(\n-            KmsAeadKeyManager.createKeyTemplate(TestUtil.GCP_KMS_TEST_KEY_URI));\n+            KmsAeadKeyManager.createKeyTemplate(GCP_KMS_TEST_KEY_URI));\n \n     Aead aead = keysetHandle.getPrimitive(Aead.class);\n \n@@ -67,11 +82,38 @@ public void kmsAead_encryptDecrypt() throws Exception {\n     assertThat(aead.decrypt(aead.encrypt(plaintext, empty), empty)).isEqualTo(plaintext);\n   }\n \n+  @Test\n+  public void kmsAeadDecryptWithDifferentKeyUri_fails() throws Exception {\n+    KeysetHandle keysetHandle =\n+        KeysetHandle.generateNew(\n+            KmsAeadKeyManager.createKeyTemplate(GCP_KMS_TEST_KEY_URI));\n+    Aead aead = keysetHandle.getPrimitive(Aead.class);\n+\n+    KeysetHandle keysetHandle2 =\n+        KeysetHandle.generateNew(\n+            KmsAeadKeyManager.createKeyTemplate(GCP_KMS_TEST_KEY_URI_2));\n+    Aead aead2 = keysetHandle2.getPrimitive(Aead.class);\n+\n+    byte[] plaintext = \"plaintext\".getBytes(UTF_8);\n+    byte[] associatedData = \"associatedData\".getBytes(UTF_8);\n+\n+    byte[] ciphertext = aead.encrypt(plaintext, associatedData);\n+    byte[] ciphertext2 = aead2.encrypt(plaintext, associatedData);\n+\n+    // Ciphertexts are valid.\n+    assertThat(aead.decrypt(ciphertext, associatedData)).isEqualTo(plaintext);\n+    assertThat(aead2.decrypt(ciphertext2, associatedData)).isEqualTo(plaintext);\n+\n+    // Ciphertexts cannot be decrypted using a different key URI.\n+    assertThrows(GeneralSecurityException.class, () -> aead.decrypt(ciphertext2, associatedData));\n+    assertThrows(GeneralSecurityException.class, () -> aead2.decrypt(ciphertext, associatedData));\n+  }\n+\n   @Test\n   public void kmsEnvelopeAead_encryptDecrypt() throws Exception {\n     KeyTemplate envelopeTemplate =\n         KmsEnvelopeAeadKeyManager.createKeyTemplate(\n-            TestUtil.GCP_KMS_TEST_KEY_URI, KeyTemplates.get(\"AES128_CTR_HMAC_SHA256\"));\n+            GCP_KMS_TEST_KEY_URI, KeyTemplates.get(\"AES128_CTR_HMAC_SHA256\"));\n     KeysetHandle keysetHandle = KeysetHandle.generateNew(envelopeTemplate);\n \n     Aead aead = keysetHandle.getPrimitive(Aead.class);\n@@ -90,4 +132,34 @@ public void kmsEnvelopeAead_encryptDecrypt() throws Exception {\n     assertThat(aead.decrypt(aead.encrypt(empty, associatedData), associatedData)).isEqualTo(empty);\n     assertThat(aead.decrypt(aead.encrypt(plaintext, empty), empty)).isEqualTo(plaintext);\n   }\n+\n+  @Test\n+  public void kmsEnvelopeAeadDecryptWithDifferentKeyUri_fails() throws Exception {\n+    KeysetHandle keysetHandle =\n+        KeysetHandle.generateNew(\n+            KmsEnvelopeAeadKeyManager.createKeyTemplate(\n+            GCP_KMS_TEST_KEY_URI, KeyTemplates.get(\"AES128_CTR_HMAC_SHA256\")));\n+    Aead aead = keysetHandle.getPrimitive(Aead.class);\n+\n+    KeysetHandle keysetHandle2 =\n+        KeysetHandle.generateNew(\n+            KmsEnvelopeAeadKeyManager.createKeyTemplate(\n+            GCP_KMS_TEST_KEY_URI_2, KeyTemplates.get(\"AES128_CTR_HMAC_SHA256\")));\n+    Aead aead2 = keysetHandle2.getPrimitive(Aead.class);\n+\n+    byte[] plaintext = \"plaintext\".getBytes(UTF_8);\n+    byte[] associatedData = \"associatedData\".getBytes(UTF_8);\n+\n+    byte[] ciphertext = aead.encrypt(plaintext, associatedData);\n+    byte[] ciphertext2 = aead2.encrypt(plaintext, associatedData);\n+\n+    // Ciphertexts are valid.\n+    assertThat(aead.decrypt(ciphertext, associatedData)).isEqualTo(plaintext);\n+    assertThat(aead2.decrypt(ciphertext2, associatedData)).isEqualTo(plaintext);\n+\n+    // Ciphertexts cannot be decrypted using a different key URI.\n+    assertThrows(GeneralSecurityException.class, () -> aead.decrypt(ciphertext2, associatedData));\n+    assertThrows(GeneralSecurityException.class, () -> aead2.decrypt(ciphertext, associatedData));\n+  }\n+\n }",
      "parent_sha": "4b71d5415aaf1a69949a8d3a2512089c7faddcd1"
    }
  },
  {
    "oid": "9e0b221f4940cbc8ee865f70e6b6a0e72704fcaf",
    "message": "Remove calls to the generated ExtensionRegistry.\n\nPiperOrigin-RevId: 275458866",
    "date": "2019-10-18T13:27:20Z",
    "url": "https://github.com/tink-crypto/tink/commit/9e0b221f4940cbc8ee865f70e6b6a0e72704fcaf",
    "details": {
      "sha": "384e8289e1821b2b0fdb39892541ca209fa3a4d6",
      "filename": "java/src/test/java/com/google/crypto/tink/signature/SignatureKeyTemplatesTest.java",
      "status": "modified",
      "additions": 11,
      "deletions": 27,
      "changes": 38,
      "blob_url": "https://github.com/tink-crypto/tink/blob/9e0b221f4940cbc8ee865f70e6b6a0e72704fcaf/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsignature%2FSignatureKeyTemplatesTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/9e0b221f4940cbc8ee865f70e6b6a0e72704fcaf/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsignature%2FSignatureKeyTemplatesTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsignature%2FSignatureKeyTemplatesTest.java?ref=9e0b221f4940cbc8ee865f70e6b6a0e72704fcaf",
      "patch": "@@ -27,7 +27,6 @@\n import com.google.crypto.tink.proto.OutputPrefixType;\n import com.google.crypto.tink.proto.RsaSsaPkcs1KeyFormat;\n import com.google.crypto.tink.proto.RsaSsaPssKeyFormat;\n-import com.google.protobuf.ExtensionRegistryLite;\n import java.math.BigInteger;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -41,8 +40,7 @@ public void testECDSA_P256() throws Exception {\n     KeyTemplate template = SignatureKeyTemplates.ECDSA_P256;\n     assertEquals(new EcdsaSignKeyManager().getKeyType(), template.getTypeUrl());\n     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());\n-    EcdsaKeyFormat format =\n-        EcdsaKeyFormat.parseFrom(template.getValue(), ExtensionRegistryLite.getGeneratedRegistry());\n+    EcdsaKeyFormat format = EcdsaKeyFormat.parseFrom(template.getValue());\n \n     assertTrue(format.hasParams());\n     assertEquals(HashType.SHA256, format.getParams().getHashType());\n@@ -55,8 +53,7 @@ public void testECDSA_P256_IEEE_P1363() throws Exception {\n     KeyTemplate template = SignatureKeyTemplates.ECDSA_P256_IEEE_P1363;\n     assertEquals(new EcdsaSignKeyManager().getKeyType(), template.getTypeUrl());\n     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());\n-    EcdsaKeyFormat format =\n-        EcdsaKeyFormat.parseFrom(template.getValue(), ExtensionRegistryLite.getGeneratedRegistry());\n+    EcdsaKeyFormat format = EcdsaKeyFormat.parseFrom(template.getValue());\n \n     assertTrue(format.hasParams());\n     assertEquals(HashType.SHA256, format.getParams().getHashType());\n@@ -69,8 +66,7 @@ public void testECDSA_P256_IEEE_P1363_WITHOUT_PREFIX() throws Exception {\n     KeyTemplate template = SignatureKeyTemplates.ECDSA_P256_IEEE_P1363_WITHOUT_PREFIX;\n     assertEquals(new EcdsaSignKeyManager().getKeyType(), template.getTypeUrl());\n     assertEquals(OutputPrefixType.RAW, template.getOutputPrefixType());\n-    EcdsaKeyFormat format =\n-        EcdsaKeyFormat.parseFrom(template.getValue(), ExtensionRegistryLite.getGeneratedRegistry());\n+    EcdsaKeyFormat format = EcdsaKeyFormat.parseFrom(template.getValue());\n \n     assertTrue(format.hasParams());\n     assertEquals(HashType.SHA256, format.getParams().getHashType());\n@@ -83,8 +79,7 @@ public void testECDSA_P384() throws Exception {\n     KeyTemplate template = SignatureKeyTemplates.ECDSA_P384;\n     assertEquals(new EcdsaSignKeyManager().getKeyType(), template.getTypeUrl());\n     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());\n-    EcdsaKeyFormat format =\n-        EcdsaKeyFormat.parseFrom(template.getValue(), ExtensionRegistryLite.getGeneratedRegistry());\n+    EcdsaKeyFormat format = EcdsaKeyFormat.parseFrom(template.getValue());\n \n     assertTrue(format.hasParams());\n     assertEquals(HashType.SHA512, format.getParams().getHashType());\n@@ -97,8 +92,7 @@ public void testECDSA_P384_IEEE_P1363() throws Exception {\n     KeyTemplate template = SignatureKeyTemplates.ECDSA_P384_IEEE_P1363;\n     assertEquals(new EcdsaSignKeyManager().getKeyType(), template.getTypeUrl());\n     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());\n-    EcdsaKeyFormat format =\n-        EcdsaKeyFormat.parseFrom(template.getValue(), ExtensionRegistryLite.getGeneratedRegistry());\n+    EcdsaKeyFormat format = EcdsaKeyFormat.parseFrom(template.getValue());\n \n     assertTrue(format.hasParams());\n     assertEquals(HashType.SHA512, format.getParams().getHashType());\n@@ -111,8 +105,7 @@ public void testECDSA_P521_IEEE_P1363() throws Exception {\n     KeyTemplate template = SignatureKeyTemplates.ECDSA_P521_IEEE_P1363;\n     assertEquals(new EcdsaSignKeyManager().getKeyType(), template.getTypeUrl());\n     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());\n-    EcdsaKeyFormat format =\n-        EcdsaKeyFormat.parseFrom(template.getValue(), ExtensionRegistryLite.getGeneratedRegistry());\n+    EcdsaKeyFormat format = EcdsaKeyFormat.parseFrom(template.getValue());\n \n     assertTrue(format.hasParams());\n     assertEquals(HashType.SHA512, format.getParams().getHashType());\n@@ -133,8 +126,7 @@ public void testCreateEcdsaKeyTemplate() throws Exception {\n     assertEquals(new EcdsaSignKeyManager().getKeyType(), template.getTypeUrl());\n     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());\n \n-    EcdsaKeyFormat format =\n-        EcdsaKeyFormat.parseFrom(template.getValue(), ExtensionRegistryLite.getGeneratedRegistry());\n+    EcdsaKeyFormat format = EcdsaKeyFormat.parseFrom(template.getValue());\n     assertEquals(hashType, format.getParams().getHashType());\n     assertEquals(curve, format.getParams().getCurve());\n     assertEquals(encoding, format.getParams().getEncoding());\n@@ -153,9 +145,7 @@ public void testRSA_SSA_PKCS1_3072_SHA256_F4() throws Exception {\n     KeyTemplate template = SignatureKeyTemplates.RSA_SSA_PKCS1_3072_SHA256_F4;\n     assertEquals(new RsaSsaPkcs1SignKeyManager().getKeyType(), template.getTypeUrl());\n     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());\n-    RsaSsaPkcs1KeyFormat format =\n-        RsaSsaPkcs1KeyFormat.parseFrom(\n-            template.getValue(), ExtensionRegistryLite.getGeneratedRegistry());\n+    RsaSsaPkcs1KeyFormat format = RsaSsaPkcs1KeyFormat.parseFrom(template.getValue());\n \n     assertTrue(format.hasParams());\n     assertEquals(HashType.SHA256, format.getParams().getHashType());\n@@ -169,9 +159,7 @@ public void testRSA_SSA_PKCS1_4096_SHA512_F4() throws Exception {\n     KeyTemplate template = SignatureKeyTemplates.RSA_SSA_PKCS1_4096_SHA512_F4;\n     assertEquals(new RsaSsaPkcs1SignKeyManager().getKeyType(), template.getTypeUrl());\n     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());\n-    RsaSsaPkcs1KeyFormat format =\n-        RsaSsaPkcs1KeyFormat.parseFrom(\n-            template.getValue(), ExtensionRegistryLite.getGeneratedRegistry());\n+    RsaSsaPkcs1KeyFormat format = RsaSsaPkcs1KeyFormat.parseFrom(template.getValue());\n \n     assertTrue(format.hasParams());\n     assertEquals(HashType.SHA512, format.getParams().getHashType());\n@@ -185,9 +173,7 @@ public void testRSA_SSA_PSS_3072_SHA256_SHA256_32_F4() throws Exception {\n     KeyTemplate template = SignatureKeyTemplates.RSA_SSA_PSS_3072_SHA256_SHA256_32_F4;\n     assertEquals(new RsaSsaPssSignKeyManager().getKeyType(), template.getTypeUrl());\n     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());\n-    RsaSsaPssKeyFormat format =\n-        RsaSsaPssKeyFormat.parseFrom(\n-            template.getValue(), ExtensionRegistryLite.getGeneratedRegistry());\n+    RsaSsaPssKeyFormat format = RsaSsaPssKeyFormat.parseFrom(template.getValue());\n \n     assertTrue(format.hasParams());\n     assertEquals(HashType.SHA256, format.getParams().getSigHash());\n@@ -203,9 +189,7 @@ public void testRSA_SSA_PSS_4096_SHA512_SHA512_64_F4() throws Exception {\n     KeyTemplate template = SignatureKeyTemplates.RSA_SSA_PSS_4096_SHA512_SHA512_64_F4;\n     assertEquals(new RsaSsaPssSignKeyManager().getKeyType(), template.getTypeUrl());\n     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());\n-    RsaSsaPssKeyFormat format =\n-        RsaSsaPssKeyFormat.parseFrom(\n-            template.getValue(), ExtensionRegistryLite.getGeneratedRegistry());\n+    RsaSsaPssKeyFormat format = RsaSsaPssKeyFormat.parseFrom(template.getValue());\n \n     assertTrue(format.hasParams());\n     assertEquals(HashType.SHA512, format.getParams().getSigHash());",
      "parent_sha": "9f579538dde5cbf14a0135f9a6ce9bb63188c2e0"
    }
  },
  {
    "oid": "3a670619c160949412751344e12d7917c1f6bbf5",
    "message": "Ensure that AndroidKeysetManager.Builder is thread-safe.\n\nPiperOrigin-RevId: 321045704",
    "date": "2020-07-13T22:25:45Z",
    "url": "https://github.com/tink-crypto/tink/commit/3a670619c160949412751344e12d7917c1f6bbf5",
    "details": {
      "sha": "85ad8931b181dbacb8a4d2def8939b5a2a636844",
      "filename": "java_src/src/main/java/com/google/crypto/tink/integration/android/AndroidKeysetManager.java",
      "status": "modified",
      "additions": 104,
      "deletions": 92,
      "changes": 196,
      "blob_url": "https://github.com/tink-crypto/tink/blob/3a670619c160949412751344e12d7917c1f6bbf5/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeysetManager.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/3a670619c160949412751344e12d7917c1f6bbf5/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeysetManager.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeysetManager.java?ref=3a670619c160949412751344e12d7917c1f6bbf5",
      "patch": "@@ -105,27 +105,29 @@\n  * generated. If the master key already exists but is unusable, a {@link KeyStoreException} is\n  * thrown.\n  *\n+ * <p>This class is thread-safe.\n+ *\n  * @since 1.0.0\n  */\n public final class AndroidKeysetManager {\n   private static final String TAG = AndroidKeysetManager.class.getSimpleName();\n-  private final KeysetReader reader;\n   private final KeysetWriter writer;\n   private final Aead masterKey;\n-  private final KeyTemplate keyTemplate;\n \n   @GuardedBy(\"this\")\n   private KeysetManager keysetManager;\n \n   private AndroidKeysetManager(Builder builder) throws GeneralSecurityException, IOException {\n-    reader = builder.reader;\n     writer = builder.writer;\n     masterKey = builder.masterKey;\n-    keyTemplate = builder.keyTemplate;\n-    keysetManager = readOrGenerateNewKeyset();\n+    keysetManager = builder.keysetManager;\n   }\n \n-  /** A builder for {@link AndroidKeysetManager}. */\n+  /**\n+   * A builder for {@link AndroidKeysetManager}.\n+   *\n+   * <p>This class is thread-safe.\n+   */\n   public static final class Builder {\n     private KeysetReader reader = null;\n     private KeysetWriter writer = null;\n@@ -135,6 +137,9 @@ public static final class Builder {\n     private KeyTemplate keyTemplate = null;\n     private KeyStore keyStore = null;\n \n+    @GuardedBy(\"this\")\n+    private KeysetManager keysetManager;\n+\n     public Builder() {}\n \n     /** Reads and writes the keyset from shared preferences. */\n@@ -218,12 +223,103 @@ Builder withKeyStore(KeyStore val) {\n      * @throws KeystoreException If a master key is found but unusable.\n      * @throws GeneralSecurityException If cannot read an existing keyset or generate a new one.\n      */\n-    public AndroidKeysetManager build() throws GeneralSecurityException, IOException {\n+    public synchronized AndroidKeysetManager build() throws GeneralSecurityException, IOException {\n       if (masterKeyUri != null) {\n-        masterKey = readOrGenerateNewMasterKey(masterKeyUri, keyStore);\n+        masterKey = readOrGenerateNewMasterKey();\n       }\n+      this.keysetManager = readOrGenerateNewKeyset();\n+\n       return new AndroidKeysetManager(this);\n     }\n+\n+    private Aead readOrGenerateNewMasterKey() throws GeneralSecurityException {\n+      if (!isAtLeastM()) {\n+        Log.w(TAG, \"Android Keystore requires at least Android M\");\n+        return null;\n+      }\n+\n+      AndroidKeystoreKmsClient client;\n+      if (keyStore != null) {\n+        client = new AndroidKeystoreKmsClient.Builder().setKeyStore(keyStore).build();\n+      } else {\n+        client = new AndroidKeystoreKmsClient();\n+      }\n+\n+      boolean existed = client.hasKey(masterKeyUri);\n+      if (!existed) {\n+        try {\n+          AndroidKeystoreKmsClient.generateNewAeadKey(masterKeyUri);\n+        } catch (GeneralSecurityException ex) {\n+          Log.w(TAG, \"cannot use Android Keystore, it'll be disabled\", ex);\n+          return null;\n+        }\n+      }\n+\n+      try {\n+        return client.getAead(masterKeyUri);\n+      } catch (GeneralSecurityException | ProviderException ex) {\n+        // Throw the exception if the key exists but is unusable. We can't recover by generating a\n+        // new\n+        // key because there might be existing encrypted data under the unusable key.\n+        // Users can provide a master key that is stored in StrongBox, which may throw a\n+        // ProviderException if there's any problem with it.\n+        if (existed) {\n+          throw new KeyStoreException(\n+              String.format(\"the master key %s exists but is unusable\", masterKeyUri), ex);\n+        }\n+        // Otherwise swallow the exception if the key doesn't exist yet. We can recover by disabling\n+        // Keystore.\n+        Log.w(TAG, \"cannot use Android Keystore, it'll be disabled\", ex);\n+      }\n+\n+      return null;\n+    }\n+\n+    private KeysetManager readOrGenerateNewKeyset() throws GeneralSecurityException, IOException {\n+      try {\n+        return read();\n+      } catch (FileNotFoundException ex) {\n+        // Not found, handle below.\n+        Log.w(TAG, \"keyset not found, will generate a new one\", ex);\n+      }\n+\n+      // Not found.\n+      if (keyTemplate != null) {\n+        KeysetManager manager = KeysetManager.withEmptyKeyset().add(keyTemplate);\n+        int keyId = manager.getKeysetHandle().getKeysetInfo().getKeyInfo(0).getKeyId();\n+        manager = manager.setPrimary(keyId);\n+        if (masterKey != null) {\n+          manager.getKeysetHandle().write(writer, masterKey);\n+        } else {\n+          CleartextKeysetHandle.write(manager.getKeysetHandle(), writer);\n+        }\n+        return manager;\n+      }\n+      throw new GeneralSecurityException(\"cannot read or generate keyset\");\n+    }\n+\n+    private KeysetManager read() throws GeneralSecurityException, IOException {\n+      if (masterKey != null) {\n+        try {\n+          return KeysetManager.withKeysetHandle(KeysetHandle.read(reader, masterKey));\n+        } catch (InvalidProtocolBufferException | GeneralSecurityException ex) {\n+          // Swallow the exception and attempt to read the keyset in cleartext.\n+          // This edge case may happen when either\n+          //   - the keyset was generated on a pre M phone which is then upgraded to M or newer, or\n+          //   - the keyset was generated with Keystore being disabled, then Keystore is enabled.\n+          // By ignoring the security failure here, an adversary with write access to private\n+          // preferences can replace an encrypted keyset (that it cannot read or write) with a\n+          // cleartext value that it controls. This does not introduce new security risks because to\n+          // overwrite the encrypted keyset in private preferences of an app, said adversaries must\n+          // have the same privilege as the app, thus they can call Android Keystore to read or\n+          // write\n+          // the encrypted keyset in the first place.\n+          Log.w(TAG, \"cannot decrypt keyset: \", ex);\n+        }\n+      }\n+\n+      return KeysetManager.withKeysetHandle(CleartextKeysetHandle.read(reader));\n+    }\n   }\n \n   /** @return a {@link KeysetHandle} of the managed keyset */\n@@ -351,47 +447,6 @@ public synchronized boolean isUsingKeystore() {\n     return shouldUseKeystore();\n   }\n \n-  private KeysetManager readOrGenerateNewKeyset() throws GeneralSecurityException, IOException {\n-    try {\n-      return read();\n-    } catch (FileNotFoundException ex) {\n-      // Not found, handle below.\n-      Log.w(TAG, \"keyset not found, will generate a new one\", ex);\n-    }\n-\n-    // Not found.\n-    if (keyTemplate != null) {\n-      KeysetManager manager = KeysetManager.withEmptyKeyset().add(keyTemplate);\n-      int keyId = manager.getKeysetHandle().getKeysetInfo().getKeyInfo(0).getKeyId();\n-      manager = manager.setPrimary(keyId);\n-      write(manager);\n-      return manager;\n-    }\n-    throw new GeneralSecurityException(\"cannot read or generate keyset\");\n-  }\n-\n-  private KeysetManager read() throws GeneralSecurityException, IOException {\n-    if (shouldUseKeystore()) {\n-      try {\n-        return KeysetManager.withKeysetHandle(KeysetHandle.read(reader, masterKey));\n-      } catch (InvalidProtocolBufferException | GeneralSecurityException ex) {\n-        // Swallow the exception and attempt to read the keyset in cleartext.\n-        // This edge case may happen when either\n-        //   - the keyset was generated on a pre M phone which is then upgraded to M or newer, or\n-        //   - the keyset was generated with Keystore being disabled, then Keystore is enabled.\n-        // By ignoring the security failure here, an adversary with write access to private\n-        // preferences can replace an encrypted keyset (that it cannot read or write) with a\n-        // cleartext value that it controls. This does not introduce new security risks because to\n-        // overwrite the encrypted keyset in private preferences of an app, said adversaries must\n-        // have the same privilege as the app, thus they can call Android Keystore to read or write\n-        // the encrypted keyset in the first place.\n-        Log.w(TAG, \"cannot decrypt keyset: \", ex);\n-      }\n-    }\n-\n-    return KeysetManager.withKeysetHandle(CleartextKeysetHandle.read(reader));\n-  }\n-\n   private void write(KeysetManager manager) throws GeneralSecurityException {\n     try {\n       if (shouldUseKeystore()) {\n@@ -426,47 +481,4 @@ private static KeyTemplate.OutputPrefixType fromProto(OutputPrefixType outputPre\n   private static boolean isAtLeastM() {\n     return Build.VERSION.SDK_INT >= Build.VERSION_CODES.M;\n   }\n-\n-  private static Aead readOrGenerateNewMasterKey(String keyId, KeyStore keyStore)\n-      throws GeneralSecurityException {\n-    if (!isAtLeastM()) {\n-      Log.w(TAG, \"Android Keystore requires at least Android M\");\n-      return null;\n-    }\n-\n-    AndroidKeystoreKmsClient client;\n-    if (keyStore != null) {\n-      client = new AndroidKeystoreKmsClient.Builder().setKeyStore(keyStore).build();\n-    } else {\n-      client = new AndroidKeystoreKmsClient();\n-    }\n-\n-    boolean existed = client.hasKey(keyId);\n-    if (!existed) {\n-      try {\n-        AndroidKeystoreKmsClient.generateNewAeadKey(keyId);\n-      } catch (GeneralSecurityException ex) {\n-        Log.w(TAG, \"cannot use Android Keystore, it'll be disabled\", ex);\n-        return null;\n-      }\n-    }\n-\n-    try {\n-      return client.getAead(keyId);\n-    } catch (GeneralSecurityException | ProviderException ex) {\n-      // Throw the exception if the key exists but is unusable. We can't recover by generating a new\n-      // key because there might be existing encrypted data under the unusable key.\n-      // Users can provide a master key that is stored in StrongBox, which may throw a\n-      // ProviderException if there's any problem with it.\n-      if (existed) {\n-        throw new KeyStoreException(\n-            String.format(\"the master key %s exists but is unusable\", keyId), ex);\n-      }\n-      // Otherwise swallow the exception if the key doesn't exist yet. We can recover by disabling\n-      // Keystore.\n-      Log.w(TAG, \"cannot use Android Keystore, it'll be disabled\", ex);\n-    }\n-\n-    return null;\n-  }\n }",
      "parent_sha": "f216cbf6551f03d9f163e671cefc968ac93b3a73"
    }
  },
  {
    "oid": "6d48f33eff45dd7cea40bef09bddd43da7df8253",
    "message": "Fixed AES-GCM HPKE AEAD unit test that calls seal() where open() should be\ncalled.\n\nPiperOrigin-RevId: 413411592",
    "date": "2021-12-01T15:34:38Z",
    "url": "https://github.com/tink-crypto/tink/commit/6d48f33eff45dd7cea40bef09bddd43da7df8253",
    "details": {
      "sha": "a85a575eb5da7db2e07ab755a82fe4d5126d739b",
      "filename": "java_src/src/test/java/com/google/crypto/tink/hybrid/internal/AesGcmHpkeAeadTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/tink-crypto/tink/blob/6d48f33eff45dd7cea40bef09bddd43da7df8253/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fhybrid%2Finternal%2FAesGcmHpkeAeadTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/6d48f33eff45dd7cea40bef09bddd43da7df8253/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fhybrid%2Finternal%2FAesGcmHpkeAeadTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fhybrid%2Finternal%2FAesGcmHpkeAeadTest.java?ref=6d48f33eff45dd7cea40bef09bddd43da7df8253",
      "patch": "@@ -148,7 +148,7 @@ public void open_wrongKeyLength() throws GeneralSecurityException {\n     assertThrows(\n         InvalidAlgorithmParameterException.class,\n         () ->\n-            aead.seal(\n-                setup.key, encryption.nonce, encryption.plaintext, encryption.associatedData));\n+            aead.open(\n+                setup.key, encryption.nonce, encryption.ciphertext, encryption.associatedData));\n   }\n }",
      "parent_sha": "6bf5483d8cff24b76d3cd835a7488867906eeee8"
    }
  },
  {
    "oid": "1f5aaf4386059fa052ea3ce394d4e0cb49b1236a",
    "message": "Fixed a typo.\n\nPiperOrigin-RevId: 192841538\nGitOrigin-RevId: fc764bfd75fad54812d2598b6edade53490e874a",
    "date": "2018-04-18T02:39:03Z",
    "url": "https://github.com/tink-crypto/tink/commit/1f5aaf4386059fa052ea3ce394d4e0cb49b1236a",
    "details": {
      "sha": "043dc49826dce638d874bb2062375ae3a33e1d3a",
      "filename": "apps/webpush/src/main/java/com/google/crypto/tink/apps/webpush/WebPushHybridDecrypt.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/tink-crypto/tink/blob/1f5aaf4386059fa052ea3ce394d4e0cb49b1236a/apps%2Fwebpush%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fapps%2Fwebpush%2FWebPushHybridDecrypt.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/1f5aaf4386059fa052ea3ce394d4e0cb49b1236a/apps%2Fwebpush%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fapps%2Fwebpush%2FWebPushHybridDecrypt.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/apps%2Fwebpush%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fapps%2Fwebpush%2FWebPushHybridDecrypt.java?ref=1f5aaf4386059fa052ea3ce394d4e0cb49b1236a",
      "patch": "@@ -176,8 +176,8 @@ public Builder withRecipientPrivateKey(ECPrivateKey val) throws GeneralSecurityE\n     /**\n      * Sets the private key of the recipient.\n      *\n-     * <p>The private key is in PKCS8 encoding. In Java, this is the return value of {@link\n-     * ECPrivateKey#getEncoded()}.\n+     * <p>The private key is the serialized bytes of the BigInteger returned by\n+     * {@link ECPrivateKey#getS()}.\n      */\n     public Builder withRecipientPrivateKey(final byte[] val) throws GeneralSecurityException {\n       recipientPrivateKey =",
      "parent_sha": "806bd79b9087262bb98c346659d20014d5e227d8"
    }
  },
  {
    "oid": "7a747493a6a295e01b765941df55424743a4f189",
    "message": "Exclude the mutation tests on android.\n\nPiperOrigin-RevId: 606899766",
    "date": "2024-02-14T09:48:10Z",
    "url": "https://github.com/tink-crypto/tink/commit/7a747493a6a295e01b765941df55424743a4f189",
    "details": {
      "sha": "dabc98817b4617dd5b5aeaaeeeaab05dd4412d5b",
      "filename": "java_src/src/test/java/com/google/crypto/tink/hybrid/EciesAeadHkdfHybridDecryptTest.java",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/tink-crypto/tink/blob/7a747493a6a295e01b765941df55424743a4f189/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fhybrid%2FEciesAeadHkdfHybridDecryptTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/7a747493a6a295e01b765941df55424743a4f189/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fhybrid%2FEciesAeadHkdfHybridDecryptTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fhybrid%2FEciesAeadHkdfHybridDecryptTest.java?ref=7a747493a6a295e01b765941df55424743a4f189",
      "patch": "@@ -218,8 +218,8 @@ private static void testEncryptDecrypt_mutatedCiphertext_throws(\n     for (BytesMutation mutation : TestUtil.generateMutations(ciphertext)) {\n       assertThrows(\n           GeneralSecurityException.class, () -> hybridDecrypt.decrypt(mutation.value, context));\n-      // The test takes too long in TSan, so we stop after the first case.\n-      if (TestUtil.isTsan()) {\n+      // The test takes too long in TSan and on Android, so we stop after the first case.\n+      if (TestUtil.isTsan() || TestUtil.isAndroid()) {\n         return;\n       }\n     }\n@@ -310,10 +310,10 @@ private static void testEncryptDecrypt_mutatedContext_throws(\n \n     byte[] ciphertext = hybridEncrypt.encrypt(plaintext, context);\n     for (BytesMutation mutation : TestUtil.generateMutations(context)) {\n-      // The test takes too long in TSan, so we stop after the first case.\n+      // The test takes too long in TSan and on Android, so we stop after the first case.\n       assertThrows(\n           GeneralSecurityException.class, () -> hybridDecrypt.decrypt(ciphertext, mutation.value));\n-      if (TestUtil.isTsan()) {\n+      if (TestUtil.isTsan() || TestUtil.isAndroid()) {\n         return;\n       }\n     }\n@@ -415,8 +415,8 @@ private static void testEncryptDecrypt_mutatedSalt_throws(\n         HybridDecrypt hybridDecrypt = EciesAeadHkdfHybridDecrypt.create(modifiedEciesPrivateKey);\n         assertThrows(\n             GeneralSecurityException.class, () -> hybridDecrypt.decrypt(ciphertext, context));\n-        // The test takes too long in TSan, so we stop after the first case.\n-        if (TestUtil.isTsan()) {\n+        // The test takes too long in TSan and on Android, so we stop after the first case.\n+        if (TestUtil.isTsan() || TestUtil.isAndroid()) {\n           return;\n         }\n       }",
      "parent_sha": "8b935c94d72755dc0cef6d6c4185be79f8471dda"
    }
  },
  {
    "oid": "f1fdf56d5cd8defb2878f0d3c8ec8f630ed4da5d",
    "message": "Suppress some warnings about ignored exceptions.\n\nPiperOrigin-RevId: 277917961",
    "date": "2019-11-01T13:45:44Z",
    "url": "https://github.com/tink-crypto/tink/commit/f1fdf56d5cd8defb2878f0d3c8ec8f630ed4da5d",
    "details": {
      "sha": "4443f9a73966d2507d0d7eeb2dcc08842ac68951",
      "filename": "java/src/main/java/com/google/crypto/tink/KeysetHandle.java",
      "status": "modified",
      "additions": 8,
      "deletions": 4,
      "changes": 12,
      "blob_url": "https://github.com/tink-crypto/tink/blob/f1fdf56d5cd8defb2878f0d3c8ec8f630ed4da5d/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/f1fdf56d5cd8defb2878f0d3c8ec8f630ed4da5d/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java?ref=f1fdf56d5cd8defb2878f0d3c8ec8f630ed4da5d",
      "patch": "@@ -109,7 +109,8 @@ public static final KeysetHandle readNoSecret(KeysetReader reader)\n       Keyset keyset = reader.read();\n       assertNoSecretKeyMaterial(keyset);\n       return KeysetHandle.fromKeyset(keyset);\n-    } catch (InvalidProtocolBufferException e) {\n+    } catch (@SuppressWarnings(\"UnusedException\") InvalidProtocolBufferException e) {\n+      // Do not propagate InvalidProtocolBufferException to guarantee no key material is leaked\n       throw new GeneralSecurityException(\"invalid keyset\");\n     }\n   }\n@@ -130,7 +131,8 @@ public static final KeysetHandle readNoSecret(final byte[] serialized)\n       Keyset keyset = Keyset.parseFrom(serialized, ExtensionRegistryLite.getEmptyRegistry());\n       assertNoSecretKeyMaterial(keyset);\n       return KeysetHandle.fromKeyset(keyset);\n-    } catch (InvalidProtocolBufferException e) {\n+    } catch (@SuppressWarnings(\"UnusedException\") InvalidProtocolBufferException e) {\n+      // Do not propagate InvalidProtocolBufferException to guarantee no key material is leaked\n       throw new GeneralSecurityException(\"invalid keyset\");\n     }\n   }\n@@ -171,7 +173,8 @@ private static EncryptedKeyset encrypt(Keyset keyset, Aead masterKey)\n       if (!keyset2.equals(keyset)) {\n         throw new GeneralSecurityException(\"cannot encrypt keyset\");\n       }\n-    } catch (InvalidProtocolBufferException e) {\n+    } catch (@SuppressWarnings(\"UnusedException\") InvalidProtocolBufferException e) {\n+      // Do not propagate InvalidProtocolBufferException to guarantee no key material is leaked\n       throw new GeneralSecurityException(\"invalid keyset, corrupted key material\");\n     }\n     return EncryptedKeyset.newBuilder()\n@@ -193,7 +196,8 @@ private static Keyset decrypt(EncryptedKeyset encryptedKeyset, Aead masterKey)\n       // check emptiness here too, in case the encrypted keys unwrapped to nothing?\n       assertEnoughKeyMaterial(keyset);\n       return keyset;\n-    } catch (InvalidProtocolBufferException e) {\n+    } catch (@SuppressWarnings(\"UnusedException\") InvalidProtocolBufferException e) {\n+      // Do not propagate InvalidProtocolBufferException to guarantee no key material is leaked\n       throw new GeneralSecurityException(\"invalid keyset, corrupted key material\");\n     }\n   }",
      "parent_sha": "ad6e398765a099d788bba14edaa81ac9948debfb"
    }
  },
  {
    "oid": "c02414af4c39322071b3bc35d19297ae08a41f60",
    "message": "Don't call Cipher.updateAAD when aad is empty or null.\n\nCipher.updateAAD doesn't work on Android KitKat, so this is a workaround for users that don't need aad.\n\nPiperOrigin-RevId: 190485577\nGitOrigin-RevId: 06bc667c953acb3f48d953939ac6c422c4b23d74",
    "date": "2018-03-26T23:44:31Z",
    "url": "https://github.com/tink-crypto/tink/commit/c02414af4c39322071b3bc35d19297ae08a41f60",
    "details": {
      "sha": "8cbd6fd1e3c29ef2a564f90dbee6759be0ba79be",
      "filename": "java/src/main/java/com/google/crypto/tink/subtle/AesGcmJce.java",
      "status": "modified",
      "additions": 12,
      "deletions": 8,
      "changes": 20,
      "blob_url": "https://github.com/tink-crypto/tink/blob/c02414af4c39322071b3bc35d19297ae08a41f60/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FAesGcmJce.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/c02414af4c39322071b3bc35d19297ae08a41f60/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FAesGcmJce.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FAesGcmJce.java?ref=c02414af4c39322071b3bc35d19297ae08a41f60",
      "patch": "@@ -41,6 +41,10 @@ private static Cipher instance() throws GeneralSecurityException {\n   }\n \n   @Override\n+  /**\n+   * On Android KitKat (API level 19) this method does not support non null or non empty {@code\n+   * associatedData}. It might not work at all in older versions.\n+   */\n   public byte[] encrypt(final byte[] plaintext, final byte[] associatedData)\n       throws GeneralSecurityException {\n     // Check that ciphertext is not longer than the max. size of a Java array.\n@@ -54,17 +58,19 @@ public byte[] encrypt(final byte[] plaintext, final byte[] associatedData)\n     Cipher cipher = instance();\n     GCMParameterSpec params = new GCMParameterSpec(8 * TAG_SIZE_IN_BYTES, iv);\n     cipher.init(Cipher.ENCRYPT_MODE, keySpec, params);\n-    byte[] aad = associatedData;\n-    if (aad == null) {\n-      aad = new byte[0];\n+    if (associatedData != null && associatedData.length != 0) {\n+      cipher.updateAAD(associatedData);\n     }\n-    cipher.updateAAD(aad);\n     int unusedWritten =\n         cipher.doFinal(plaintext, 0, plaintext.length, ciphertext, IV_SIZE_IN_BYTES);\n     return ciphertext;\n   }\n \n   @Override\n+  /**\n+   * On Android KitKat (API level 19) this method does not support non null or non empty {@code\n+   * associatedData}. It might not work at all in older versions.\n+   */\n   public byte[] decrypt(final byte[] ciphertext, final byte[] associatedData)\n       throws GeneralSecurityException {\n     if (ciphertext.length < IV_SIZE_IN_BYTES + TAG_SIZE_IN_BYTES) {\n@@ -74,11 +80,9 @@ public byte[] decrypt(final byte[] ciphertext, final byte[] associatedData)\n         new GCMParameterSpec(8 * TAG_SIZE_IN_BYTES, ciphertext, 0, IV_SIZE_IN_BYTES);\n     Cipher cipher = instance();\n     cipher.init(Cipher.DECRYPT_MODE, keySpec, params);\n-    byte[] aad = associatedData;\n-    if (aad == null) {\n-      aad = new byte[0];\n+    if (associatedData != null && associatedData.length != 0) {\n+      cipher.updateAAD(associatedData);\n     }\n-    cipher.updateAAD(aad);\n     return cipher.doFinal(ciphertext, IV_SIZE_IN_BYTES, ciphertext.length - IV_SIZE_IN_BYTES);\n   }\n };",
      "parent_sha": "223ed583f556929df650caf0aa6cb26adc2ca79c"
    }
  },
  {
    "oid": "55a8c680bd08f038fc95fcffa9a3c2d773bcff8b",
    "message": "Validate that ECIES private keys are not empty.\n\nNot sure what else that we can validate here.\n\nPiperOrigin-RevId: 242770198\nGitOrigin-RevId: d0155545bcb4dec10432cde581667cca0f0d691c",
    "date": "2019-05-02T07:34:30Z",
    "url": "https://github.com/tink-crypto/tink/commit/55a8c680bd08f038fc95fcffa9a3c2d773bcff8b",
    "details": {
      "sha": "0f6e8f75ee8e1fbc267eea8b634424eac895528c",
      "filename": "java/src/main/java/com/google/crypto/tink/hybrid/EciesAeadHkdfPrivateKeyManager.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/tink-crypto/tink/blob/55a8c680bd08f038fc95fcffa9a3c2d773bcff8b/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fhybrid%2FEciesAeadHkdfPrivateKeyManager.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/55a8c680bd08f038fc95fcffa9a3c2d773bcff8b/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fhybrid%2FEciesAeadHkdfPrivateKeyManager.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fhybrid%2FEciesAeadHkdfPrivateKeyManager.java?ref=55a8c680bd08f038fc95fcffa9a3c2d773bcff8b",
      "patch": "@@ -140,7 +140,9 @@ public int getVersion() {\n \n   @Override\n   protected void validateKey(EciesAeadHkdfPrivateKey keyProto) throws GeneralSecurityException {\n-    // TODO(b/74249437): add more checks.\n+    if (keyProto.getKeyValue().isEmpty()) {\n+      throw new GeneralSecurityException(\"invalid ECIES private key\");\n+    }\n     Validators.validateVersion(keyProto.getVersion(), VERSION);\n     HybridUtil.validate(keyProto.getPublicKey().getParams());\n   }",
      "parent_sha": "c2537c83b906219a3b1a7ad0f612e77a6e89bd54"
    }
  },
  {
    "oid": "56ef7854dced0688cc21aa12438e51c3cc230a55",
    "message": "Move creation of test cases into a function.\n\nI will want to make this dependent on whether we are on android, which is easier if it's in a function.\n\nPiperOrigin-RevId: 528761935",
    "date": "2023-05-02T13:16:12Z",
    "url": "https://github.com/tink-crypto/tink/commit/56ef7854dced0688cc21aa12438e51c3cc230a55",
    "details": {
      "sha": "f99c839ba4b52c64d2bf39340d644506b8976ccb",
      "filename": "java_src/src/test/java/com/google/crypto/tink/KeyTemplatesAsParametersTest.java",
      "status": "modified",
      "additions": 194,
      "deletions": 172,
      "changes": 366,
      "blob_url": "https://github.com/tink-crypto/tink/blob/56ef7854dced0688cc21aa12438e51c3cc230a55/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeyTemplatesAsParametersTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/56ef7854dced0688cc21aa12438e51c3cc230a55/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeyTemplatesAsParametersTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeyTemplatesAsParametersTest.java?ref=56ef7854dced0688cc21aa12438e51c3cc230a55",
      "patch": "@@ -34,7 +34,10 @@\n import com.google.crypto.tink.mac.PredefinedMacParameters;\n import com.google.crypto.tink.prf.PredefinedPrfParameters;\n import com.google.crypto.tink.streamingaead.PredefinedStreamingAeadParameters;\n+import java.security.GeneralSecurityException;\n+import java.util.ArrayList;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Set;\n import org.junit.BeforeClass;\n import org.junit.Test;\n@@ -75,178 +78,197 @@ public static void registerTink() throws Exception {\n     TinkConfig.register();\n   }\n \n+  private static final List<Pair> createTemplates() throws GeneralSecurityException {\n+    List<Pair> result = new ArrayList<>();\n+    // Aead\n+    result.add(new Pair(\"AES128_GCM\", PredefinedAeadParameters.AES128_GCM));\n+    result.add(new Pair(\"AES256_GCM\", PredefinedAeadParameters.AES256_GCM));\n+    result.add(\n+        new Pair(\n+            \"AES128_GCM_RAW\",\n+            AesGcmParameters.builder()\n+                .setIvSizeBytes(12)\n+                .setKeySizeBytes(16)\n+                .setTagSizeBytes(16)\n+                .setVariant(AesGcmParameters.Variant.NO_PREFIX)\n+                .build()));\n+    result.add(\n+        new Pair(\n+            \"AES256_GCM_RAW\",\n+            AesGcmParameters.builder()\n+                .setIvSizeBytes(12)\n+                .setKeySizeBytes(32)\n+                .setTagSizeBytes(16)\n+                .setVariant(AesGcmParameters.Variant.NO_PREFIX)\n+                .build()));\n+    result.add(new Pair(\"AES128_EAX\", PredefinedAeadParameters.AES128_EAX));\n+    result.add(new Pair(\"AES256_EAX\", PredefinedAeadParameters.AES256_EAX));\n+    result.add(\n+        new Pair(\n+            \"AES128_EAX_RAW\",\n+            AesEaxParameters.builder()\n+                .setIvSizeBytes(16)\n+                .setKeySizeBytes(16)\n+                .setTagSizeBytes(16)\n+                .setVariant(AesEaxParameters.Variant.NO_PREFIX)\n+                .build()));\n+    result.add(\n+        new Pair(\n+            \"AES256_EAX_RAW\",\n+            AesEaxParameters.builder()\n+                .setIvSizeBytes(16)\n+                .setKeySizeBytes(32)\n+                .setTagSizeBytes(16)\n+                .setVariant(AesEaxParameters.Variant.NO_PREFIX)\n+                .build()));\n+    result.add(new Pair(\"AES128_CTR_HMAC_SHA256\", PredefinedAeadParameters.AES128_CTR_HMAC_SHA256));\n+    result.add(new Pair(\"AES256_CTR_HMAC_SHA256\", PredefinedAeadParameters.AES256_CTR_HMAC_SHA256));\n+    result.add(\n+        new Pair(\n+            \"AES128_CTR_HMAC_SHA256_RAW\",\n+            AesCtrHmacAeadParameters.builder()\n+                .setAesKeySizeBytes(16)\n+                .setHmacKeySizeBytes(32)\n+                .setTagSizeBytes(16)\n+                .setIvSizeBytes(16)\n+                .setHashType(AesCtrHmacAeadParameters.HashType.SHA256)\n+                .setVariant(AesCtrHmacAeadParameters.Variant.NO_PREFIX)\n+                .build()));\n+    result.add(\n+        new Pair(\n+            \"AES256_CTR_HMAC_SHA256_RAW\",\n+            AesCtrHmacAeadParameters.builder()\n+                .setAesKeySizeBytes(32)\n+                .setHmacKeySizeBytes(32)\n+                .setTagSizeBytes(32)\n+                .setIvSizeBytes(16)\n+                .setHashType(AesCtrHmacAeadParameters.HashType.SHA256)\n+                .setVariant(AesCtrHmacAeadParameters.Variant.NO_PREFIX)\n+                .build()));\n+    result.add(new Pair(\"CHACHA20_POLY1305\", PredefinedAeadParameters.CHACHA20_POLY1305));\n+    result.add(\n+        new Pair(\n+            \"CHACHA20_POLY1305_RAW\",\n+            ChaCha20Poly1305Parameters.create(ChaCha20Poly1305Parameters.Variant.NO_PREFIX)));\n+    result.add(new Pair(\"XCHACHA20_POLY1305\", PredefinedAeadParameters.XCHACHA20_POLY1305));\n+    result.add(\n+        new Pair(\n+            \"XCHACHA20_POLY1305_RAW\",\n+            XChaCha20Poly1305Parameters.create(XChaCha20Poly1305Parameters.Variant.NO_PREFIX)));\n+    // Mac\n+    result.add(new Pair(\"HMAC_SHA256_128BITTAG\", PredefinedMacParameters.HMAC_SHA256_128BITTAG));\n+    result.add(\n+        new Pair(\n+            \"HMAC_SHA256_128BITTAG_RAW\",\n+            HmacParameters.builder()\n+                .setKeySizeBytes(32)\n+                .setTagSizeBytes(16)\n+                .setVariant(HmacParameters.Variant.NO_PREFIX)\n+                .setHashType(HmacParameters.HashType.SHA256)\n+                .build()));\n+    result.add(\n+        new Pair(\n+            \"HMAC_SHA256_256BITTAG_RAW\",\n+            HmacParameters.builder()\n+                .setKeySizeBytes(32)\n+                .setTagSizeBytes(32)\n+                .setVariant(HmacParameters.Variant.NO_PREFIX)\n+                .setHashType(HmacParameters.HashType.SHA256)\n+                .build()));\n+    result.add(\n+        new Pair(\n+            \"HMAC_SHA512_128BITTAG\",\n+            HmacParameters.builder()\n+                .setKeySizeBytes(64)\n+                .setTagSizeBytes(16)\n+                .setVariant(HmacParameters.Variant.TINK)\n+                .setHashType(HmacParameters.HashType.SHA512)\n+                .build()));\n+    result.add(\n+        new Pair(\n+            \"HMAC_SHA512_128BITTAG_RAW\",\n+            HmacParameters.builder()\n+                .setKeySizeBytes(64)\n+                .setTagSizeBytes(16)\n+                .setVariant(HmacParameters.Variant.NO_PREFIX)\n+                .setHashType(HmacParameters.HashType.SHA512)\n+                .build()));\n+    result.add(\n+        new Pair(\n+            \"HMAC_SHA512_256BITTAG_RAW\",\n+            HmacParameters.builder()\n+                .setKeySizeBytes(64)\n+                .setTagSizeBytes(32)\n+                .setVariant(HmacParameters.Variant.NO_PREFIX)\n+                .setHashType(HmacParameters.HashType.SHA512)\n+                .build()));\n+    result.add(\n+        new Pair(\n+            \"HMAC_SHA512_512BITTAG_RAW\",\n+            HmacParameters.builder()\n+                .setKeySizeBytes(64)\n+                .setTagSizeBytes(64)\n+                .setVariant(HmacParameters.Variant.NO_PREFIX)\n+                .setHashType(HmacParameters.HashType.SHA512)\n+                .build()));\n+    result.add(new Pair(\"HMAC_SHA256_256BITTAG\", PredefinedMacParameters.HMAC_SHA256_256BITTAG));\n+    result.add(new Pair(\"HMAC_SHA512_256BITTAG\", PredefinedMacParameters.HMAC_SHA512_256BITTAG));\n+    result.add(new Pair(\"HMAC_SHA512_512BITTAG\", PredefinedMacParameters.HMAC_SHA512_512BITTAG));\n+    result.add(new Pair(\"AES_CMAC\", PredefinedMacParameters.AES_CMAC));\n+    result.add(new Pair(\"AES256_CMAC\", PredefinedMacParameters.AES_CMAC));\n+    result.add(\n+        new Pair(\n+            \"AES256_CMAC_RAW\",\n+            AesCmacParameters.builder()\n+                .setKeySizeBytes(32)\n+                .setTagSizeBytes(16)\n+                .setVariant(AesCmacParameters.Variant.NO_PREFIX)\n+                .build()));\n+    // DeterministicAead\n+    result.add(new Pair(\"AES256_SIV\", PredefinedDeterministicAeadParameters.AES256_SIV));\n+    result.add(\n+        new Pair(\n+            \"AES256_SIV_RAW\",\n+            AesSivParameters.builder()\n+                .setKeySizeBytes(64)\n+                .setVariant(AesSivParameters.Variant.NO_PREFIX)\n+                .build()));\n+    // StreamingAead\n+    result.add(\n+        new Pair(\n+            \"AES128_CTR_HMAC_SHA256_4KB\",\n+            PredefinedStreamingAeadParameters.AES128_CTR_HMAC_SHA256_4KB));\n+    result.add(\n+        new Pair(\n+            \"AES128_CTR_HMAC_SHA256_1MB\",\n+            PredefinedStreamingAeadParameters.AES128_CTR_HMAC_SHA256_1MB));\n+    result.add(\n+        new Pair(\n+            \"AES256_CTR_HMAC_SHA256_4KB\",\n+            PredefinedStreamingAeadParameters.AES256_CTR_HMAC_SHA256_4KB));\n+    result.add(\n+        new Pair(\n+            \"AES256_CTR_HMAC_SHA256_1MB\",\n+            PredefinedStreamingAeadParameters.AES256_CTR_HMAC_SHA256_1MB));\n+    result.add(\n+        new Pair(\"AES128_GCM_HKDF_4KB\", PredefinedStreamingAeadParameters.AES128_GCM_HKDF_4KB));\n+    result.add(\n+        new Pair(\"AES128_GCM_HKDF_1MB\", PredefinedStreamingAeadParameters.AES128_GCM_HKDF_1MB));\n+    result.add(\n+        new Pair(\"AES256_GCM_HKDF_4KB\", PredefinedStreamingAeadParameters.AES256_GCM_HKDF_4KB));\n+    result.add(\n+        new Pair(\"AES256_GCM_HKDF_1MB\", PredefinedStreamingAeadParameters.AES256_GCM_HKDF_1MB));\n+    // Prf\n+    result.add(new Pair(\"HKDF_SHA256\", PredefinedPrfParameters.HKDF_SHA256));\n+    result.add(new Pair(\"HMAC_SHA256_PRF\", PredefinedPrfParameters.HMAC_SHA256_PRF));\n+    result.add(new Pair(\"HMAC_SHA512_PRF\", PredefinedPrfParameters.HMAC_SHA512_PRF));\n+    result.add(new Pair(\"AES256_CMAC_PRF\", PredefinedPrfParameters.AES_CMAC_PRF));\n+    result.add(new Pair(\"AES_CMAC_PRF\", PredefinedPrfParameters.AES_CMAC_PRF));\n+    return result;\n+  }\n+\n   @DataPoints(\"EquivalentPairs\")\n-  public static final Pair[] TEMPLATES =\n-      exceptionIsBug(\n-          () ->\n-              new Pair[] {\n-                // Aead\n-                new Pair(\"AES128_GCM\", PredefinedAeadParameters.AES128_GCM),\n-                new Pair(\"AES256_GCM\", PredefinedAeadParameters.AES256_GCM),\n-                new Pair(\n-                    \"AES128_GCM_RAW\",\n-                    AesGcmParameters.builder()\n-                        .setIvSizeBytes(12)\n-                        .setKeySizeBytes(16)\n-                        .setTagSizeBytes(16)\n-                        .setVariant(AesGcmParameters.Variant.NO_PREFIX)\n-                        .build()),\n-                new Pair(\n-                    \"AES256_GCM_RAW\",\n-                    AesGcmParameters.builder()\n-                        .setIvSizeBytes(12)\n-                        .setKeySizeBytes(32)\n-                        .setTagSizeBytes(16)\n-                        .setVariant(AesGcmParameters.Variant.NO_PREFIX)\n-                        .build()),\n-                new Pair(\"AES128_EAX\", PredefinedAeadParameters.AES128_EAX),\n-                new Pair(\"AES256_EAX\", PredefinedAeadParameters.AES256_EAX),\n-                new Pair(\n-                    \"AES128_EAX_RAW\",\n-                    AesEaxParameters.builder()\n-                        .setIvSizeBytes(16)\n-                        .setKeySizeBytes(16)\n-                        .setTagSizeBytes(16)\n-                        .setVariant(AesEaxParameters.Variant.NO_PREFIX)\n-                        .build()),\n-                new Pair(\n-                    \"AES256_EAX_RAW\",\n-                    AesEaxParameters.builder()\n-                        .setIvSizeBytes(16)\n-                        .setKeySizeBytes(32)\n-                        .setTagSizeBytes(16)\n-                        .setVariant(AesEaxParameters.Variant.NO_PREFIX)\n-                        .build()),\n-                new Pair(\"AES128_CTR_HMAC_SHA256\", PredefinedAeadParameters.AES128_CTR_HMAC_SHA256),\n-                new Pair(\"AES256_CTR_HMAC_SHA256\", PredefinedAeadParameters.AES256_CTR_HMAC_SHA256),\n-                new Pair(\n-                    \"AES128_CTR_HMAC_SHA256_RAW\",\n-                    AesCtrHmacAeadParameters.builder()\n-                        .setAesKeySizeBytes(16)\n-                        .setHmacKeySizeBytes(32)\n-                        .setTagSizeBytes(16)\n-                        .setIvSizeBytes(16)\n-                        .setHashType(AesCtrHmacAeadParameters.HashType.SHA256)\n-                        .setVariant(AesCtrHmacAeadParameters.Variant.NO_PREFIX)\n-                        .build()),\n-                new Pair(\n-                    \"AES256_CTR_HMAC_SHA256_RAW\",\n-                    AesCtrHmacAeadParameters.builder()\n-                        .setAesKeySizeBytes(32)\n-                        .setHmacKeySizeBytes(32)\n-                        .setTagSizeBytes(32)\n-                        .setIvSizeBytes(16)\n-                        .setHashType(AesCtrHmacAeadParameters.HashType.SHA256)\n-                        .setVariant(AesCtrHmacAeadParameters.Variant.NO_PREFIX)\n-                        .build()),\n-                new Pair(\"CHACHA20_POLY1305\", PredefinedAeadParameters.CHACHA20_POLY1305),\n-                new Pair(\n-                    \"CHACHA20_POLY1305_RAW\",\n-                    ChaCha20Poly1305Parameters.create(\n-                        ChaCha20Poly1305Parameters.Variant.NO_PREFIX)),\n-                new Pair(\"XCHACHA20_POLY1305\", PredefinedAeadParameters.XCHACHA20_POLY1305),\n-                new Pair(\n-                    \"XCHACHA20_POLY1305_RAW\",\n-                    XChaCha20Poly1305Parameters.create(\n-                        XChaCha20Poly1305Parameters.Variant.NO_PREFIX)),\n-                // Mac\n-                new Pair(\"HMAC_SHA256_128BITTAG\", PredefinedMacParameters.HMAC_SHA256_128BITTAG),\n-                new Pair(\n-                    \"HMAC_SHA256_128BITTAG_RAW\",\n-                    HmacParameters.builder()\n-                        .setKeySizeBytes(32)\n-                        .setTagSizeBytes(16)\n-                        .setVariant(HmacParameters.Variant.NO_PREFIX)\n-                        .setHashType(HmacParameters.HashType.SHA256)\n-                        .build()),\n-                new Pair(\n-                    \"HMAC_SHA256_256BITTAG_RAW\",\n-                    HmacParameters.builder()\n-                        .setKeySizeBytes(32)\n-                        .setTagSizeBytes(32)\n-                        .setVariant(HmacParameters.Variant.NO_PREFIX)\n-                        .setHashType(HmacParameters.HashType.SHA256)\n-                        .build()),\n-                new Pair(\n-                    \"HMAC_SHA512_128BITTAG\",\n-                    HmacParameters.builder()\n-                        .setKeySizeBytes(64)\n-                        .setTagSizeBytes(16)\n-                        .setVariant(HmacParameters.Variant.TINK)\n-                        .setHashType(HmacParameters.HashType.SHA512)\n-                        .build()),\n-                new Pair(\n-                    \"HMAC_SHA512_128BITTAG_RAW\",\n-                    HmacParameters.builder()\n-                        .setKeySizeBytes(64)\n-                        .setTagSizeBytes(16)\n-                        .setVariant(HmacParameters.Variant.NO_PREFIX)\n-                        .setHashType(HmacParameters.HashType.SHA512)\n-                        .build()),\n-                new Pair(\n-                    \"HMAC_SHA512_256BITTAG_RAW\",\n-                    HmacParameters.builder()\n-                        .setKeySizeBytes(64)\n-                        .setTagSizeBytes(32)\n-                        .setVariant(HmacParameters.Variant.NO_PREFIX)\n-                        .setHashType(HmacParameters.HashType.SHA512)\n-                        .build()),\n-                new Pair(\n-                    \"HMAC_SHA512_512BITTAG_RAW\",\n-                    HmacParameters.builder()\n-                        .setKeySizeBytes(64)\n-                        .setTagSizeBytes(64)\n-                        .setVariant(HmacParameters.Variant.NO_PREFIX)\n-                        .setHashType(HmacParameters.HashType.SHA512)\n-                        .build()),\n-                new Pair(\"HMAC_SHA256_256BITTAG\", PredefinedMacParameters.HMAC_SHA256_256BITTAG),\n-                new Pair(\"HMAC_SHA512_256BITTAG\", PredefinedMacParameters.HMAC_SHA512_256BITTAG),\n-                new Pair(\"HMAC_SHA512_512BITTAG\", PredefinedMacParameters.HMAC_SHA512_512BITTAG),\n-                new Pair(\"AES_CMAC\", PredefinedMacParameters.AES_CMAC),\n-                new Pair(\"AES256_CMAC\", PredefinedMacParameters.AES_CMAC),\n-                new Pair(\n-                    \"AES256_CMAC_RAW\",\n-                    AesCmacParameters.builder()\n-                        .setKeySizeBytes(32)\n-                        .setTagSizeBytes(16)\n-                        .setVariant(AesCmacParameters.Variant.NO_PREFIX)\n-                        .build()),\n-                // DeterministicAead\n-                new Pair(\"AES256_SIV\", PredefinedDeterministicAeadParameters.AES256_SIV),\n-                new Pair(\n-                    \"AES256_SIV_RAW\",\n-                    AesSivParameters.builder()\n-                        .setKeySizeBytes(64)\n-                        .setVariant(AesSivParameters.Variant.NO_PREFIX)\n-                        .build()),\n-                // StreamingAead\n-                new Pair(\n-                    \"AES128_CTR_HMAC_SHA256_4KB\",\n-                    PredefinedStreamingAeadParameters.AES128_CTR_HMAC_SHA256_4KB),\n-                new Pair(\n-                    \"AES128_CTR_HMAC_SHA256_1MB\",\n-                    PredefinedStreamingAeadParameters.AES128_CTR_HMAC_SHA256_1MB),\n-                new Pair(\n-                    \"AES256_CTR_HMAC_SHA256_4KB\",\n-                    PredefinedStreamingAeadParameters.AES256_CTR_HMAC_SHA256_4KB),\n-                new Pair(\n-                    \"AES256_CTR_HMAC_SHA256_1MB\",\n-                    PredefinedStreamingAeadParameters.AES256_CTR_HMAC_SHA256_1MB),\n-                new Pair(\n-                    \"AES128_GCM_HKDF_4KB\", PredefinedStreamingAeadParameters.AES128_GCM_HKDF_4KB),\n-                new Pair(\n-                    \"AES128_GCM_HKDF_1MB\", PredefinedStreamingAeadParameters.AES128_GCM_HKDF_1MB),\n-                new Pair(\n-                    \"AES256_GCM_HKDF_4KB\", PredefinedStreamingAeadParameters.AES256_GCM_HKDF_4KB),\n-                new Pair(\n-                    \"AES256_GCM_HKDF_1MB\", PredefinedStreamingAeadParameters.AES256_GCM_HKDF_1MB),\n-                // Prf\n-                new Pair(\"HKDF_SHA256\", PredefinedPrfParameters.HKDF_SHA256),\n-                new Pair(\"HMAC_SHA256_PRF\", PredefinedPrfParameters.HMAC_SHA256_PRF),\n-                new Pair(\"HMAC_SHA512_PRF\", PredefinedPrfParameters.HMAC_SHA512_PRF),\n-                new Pair(\"AES256_CMAC_PRF\", PredefinedPrfParameters.AES_CMAC_PRF),\n-                new Pair(\"AES_CMAC_PRF\", PredefinedPrfParameters.AES_CMAC_PRF),\n-              });\n+  public static final List<Pair> templates = exceptionIsBug(() -> createTemplates());\n \n   @Theory\n   public void testParametersEqualsKeyTemplate(@FromDataPoints(\"EquivalentPairs\") Pair p)\n@@ -256,7 +278,7 @@ public void testParametersEqualsKeyTemplate(@FromDataPoints(\"EquivalentPairs\") P\n \n   private static Set<String> getAllTestedNames() {\n     Set<String> result = new HashSet<>();\n-    for (Pair p : TEMPLATES) {\n+    for (Pair p : templates) {\n       result.add(p.templateName);\n     }\n     return result;",
      "parent_sha": "43851fbbc40a09a57c6836c79928690382dbe2cb"
    }
  },
  {
    "oid": "222092b77fefd760a87f202dab0e969a5c6f88c9",
    "message": "Merging #184.\n\nPiperOrigin-RevId: 234222213\nGitOrigin-RevId: 98c55286985603f061c16ac892b992a60b44ff9f",
    "date": "2019-02-18T20:35:44Z",
    "url": "https://github.com/tink-crypto/tink/commit/222092b77fefd760a87f202dab0e969a5c6f88c9",
    "details": {
      "sha": "31be1d67547aa9e4535a2f26b5462c9cfe6e2a66",
      "filename": "java/src/main/java/com/google/crypto/tink/integration/awskms/AwsKmsClient.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/tink-crypto/tink/blob/222092b77fefd760a87f202dab0e969a5c6f88c9/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fawskms%2FAwsKmsClient.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/222092b77fefd760a87f202dab0e969a5c6f88c9/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fawskms%2FAwsKmsClient.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fawskms%2FAwsKmsClient.java?ref=222092b77fefd760a87f202dab0e969a5c6f88c9",
      "patch": "@@ -109,7 +109,7 @@ public KmsClient withDefaultCredentials() throws GeneralSecurityException {\n   }\n \n   /** Loads AWS credentials from a provider. */\n-  private KmsClient withCredentialsProvider(AWSCredentialsProvider provider)\n+  public KmsClient withCredentialsProvider(AWSCredentialsProvider provider)\n       throws GeneralSecurityException {\n     try {\n       this.client = AWSKMSClientBuilder.standard().withCredentials(provider).build();",
      "parent_sha": "c1648621b34e7049ac086d0a525d54f82f33b7a4"
    }
  },
  {
    "oid": "0b80d23cb6f19dd339b5e8953065f7715083efec",
    "message": "Remove the functions assertEnoughKeyMaterial and assertEnoughEncryptedKeyMaterial from the public API.\n\nSince they are taking as input protos which aren't in the public API, I do not expect anyone to call those.\n\nPiperOrigin-RevId: 436181543",
    "date": "2022-03-21T12:48:59Z",
    "url": "https://github.com/tink-crypto/tink/commit/0b80d23cb6f19dd339b5e8953065f7715083efec",
    "details": {
      "sha": "6ab0163bde5b10baa788464e966460593da93b87",
      "filename": "java_src/src/main/java/com/google/crypto/tink/KeysetHandle.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/tink-crypto/tink/blob/0b80d23cb6f19dd339b5e8953065f7715083efec/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/0b80d23cb6f19dd339b5e8953065f7715083efec/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java?ref=0b80d23cb6f19dd339b5e8953065f7715083efec",
      "patch": "@@ -354,7 +354,7 @@ private static void assertNoSecretKeyMaterial(Keyset keyset) throws GeneralSecur\n    *\n    * @throws GeneralSecurityException\n    */\n-  public static void assertEnoughKeyMaterial(Keyset keyset) throws GeneralSecurityException {\n+  private static void assertEnoughKeyMaterial(Keyset keyset) throws GeneralSecurityException {\n     if (keyset == null || keyset.getKeyCount() <= 0) {\n       throw new GeneralSecurityException(\"empty keyset\");\n     }\n@@ -365,7 +365,7 @@ public static void assertEnoughKeyMaterial(Keyset keyset) throws GeneralSecurity\n    *\n    * @throws GeneralSecurityException\n    */\n-  public static void assertEnoughEncryptedKeyMaterial(EncryptedKeyset keyset)\n+  private static void assertEnoughEncryptedKeyMaterial(EncryptedKeyset keyset)\n       throws GeneralSecurityException {\n     if (keyset == null || keyset.getEncryptedKeyset().size() == 0) {\n       throw new GeneralSecurityException(\"empty keyset\");",
      "parent_sha": "217c9e654b0494bdfc3c453eabdce1bf600c61db"
    }
  },
  {
    "oid": "f6ac134063a81d66a196b474fe8f48274e427874",
    "message": "Use GoogleNetHttpTransport.newTrustedTransport() as the HTTP transport for GcpKmsClient.\n\nTo avoid changing the method signature of the existing\nGcpKmsClient::WithCredentials(GoogleCredential) factory method, this\nwill not apply to GcpKmsClient objects created with that method.\nPiperOrigin-RevId: 438111872",
    "date": "2022-03-29T20:37:56Z",
    "url": "https://github.com/tink-crypto/tink/commit/f6ac134063a81d66a196b474fe8f48274e427874",
    "details": {
      "sha": "9d02a502994da61660633f4da1909b30ec82ab5a",
      "filename": "java_src/src/main/java/com/google/crypto/tink/integration/gcpkms/GcpKmsClient.java",
      "status": "modified",
      "additions": 13,
      "deletions": 8,
      "changes": 21,
      "blob_url": "https://github.com/tink-crypto/tink/blob/f6ac134063a81d66a196b474fe8f48274e427874/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fgcpkms%2FGcpKmsClient.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/f6ac134063a81d66a196b474fe8f48274e427874/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fgcpkms%2FGcpKmsClient.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fgcpkms%2FGcpKmsClient.java?ref=f6ac134063a81d66a196b474fe8f48274e427874",
      "patch": "@@ -17,6 +17,7 @@\n package com.google.crypto.tink.integration.gcpkms;\n \n import com.google.api.client.googleapis.auth.oauth2.GoogleCredential;\n+import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;\n import com.google.api.client.http.javanet.NetHttpTransport;\n import com.google.api.client.json.jackson2.JacksonFactory;\n import com.google.api.services.cloudkms.v1.CloudKMS;\n@@ -121,17 +122,21 @@ public KmsClient withCredentials(GoogleCredential credential) {\n   }\n \n   /** Loads the provided credentials with {@code GoogleCredentials}. */\n-  public KmsClient withCredentials(GoogleCredentials credentials) {\n+  public KmsClient withCredentials(GoogleCredentials credentials) throws GeneralSecurityException {\n     if (credentials.createScopedRequired()) {\n       credentials = credentials.createScoped(CloudKMSScopes.all());\n     }\n-    this.client =\n-        new CloudKMS.Builder(\n-                new NetHttpTransport(),\n-                new JacksonFactory(),\n-                new HttpCredentialsAdapter(credentials))\n-            .setApplicationName(APPLICATION_NAME)\n-            .build();\n+    try {\n+      this.client =\n+          new CloudKMS.Builder(\n+                  GoogleNetHttpTransport.newTrustedTransport(),\n+                  new JacksonFactory(),\n+                  new HttpCredentialsAdapter(credentials))\n+              .setApplicationName(APPLICATION_NAME)\n+              .build();\n+    } catch (IOException e) {\n+      throw new GeneralSecurityException(\"cannot build GCP KMS client\", e);\n+    }\n     return this;\n   }\n ",
      "parent_sha": "df09d57b03679016a642b25d038fdffbf5be3c87"
    }
  },
  {
    "oid": "f32a3f97dd7a7f5a3d6aba2b9f1d9c239ea4a1e3",
    "message": "Fix Android Lint errors.\n\nPiperOrigin-RevId: 316755323",
    "date": "2020-06-16T21:13:40Z",
    "url": "https://github.com/tink-crypto/tink/commit/f32a3f97dd7a7f5a3d6aba2b9f1d9c239ea4a1e3",
    "details": {
      "sha": "3fe8921fdd726bc4b94c9e653edbd88c0fb776c2",
      "filename": "java_src/src/main/java/com/google/crypto/tink/subtle/Validators.java",
      "status": "modified",
      "additions": 8,
      "deletions": 6,
      "changes": 14,
      "blob_url": "https://github.com/tink-crypto/tink/blob/f32a3f97dd7a7f5a3d6aba2b9f1d9c239ea4a1e3/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FValidators.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/f32a3f97dd7a7f5a3d6aba2b9f1d9c239ea4a1e3/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FValidators.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FValidators.java?ref=f32a3f97dd7a7f5a3d6aba2b9f1d9c239ea4a1e3",
      "patch": "@@ -21,6 +21,7 @@\n import java.io.IOException;\n import java.security.GeneralSecurityException;\n import java.security.InvalidAlgorithmParameterException;\n+import java.util.Locale;\n import java.util.regex.Pattern;\n \n /**\n@@ -29,6 +30,8 @@\n  * @since 1.0.0\n  */\n public final class Validators {\n+  private Validators() {}\n+\n   private static final String TYPE_URL_PREFIX = \"type.googleapis.com/\";\n   /**\n    * To reach 128-bit security strength, RSA's modulus must be at least 3072-bit while 2048-bit RSA\n@@ -113,26 +116,25 @@ public static void validateRsaModulusSize(int modulusSize) throws GeneralSecurit\n    */\n   public static void validateNotExists(File f) throws IOException {\n     if (f.exists()) {\n-      throw new IOException(String.format(\"%s exists, please choose another file\\n\", f.toString()));\n+      throw new IOException(String.format(\"%s exists, please choose another file\\n\", f));\n     }\n   }\n \n   /** @throws IOException if {@code f} does not exists. */\n   public static void validateExists(File f) throws IOException {\n     if (!f.exists()) {\n       throw new IOException(\n-          String.format(\"Error: %s doesn't exist, please choose another file\\n\", f.toString()));\n+          String.format(\"Error: %s doesn't exist, please choose another file\\n\", f));\n     }\n   }\n \n   /**\n    * Validates that {@code kmsKeyUri} starts with {@code expectedPrefix}, and removes the prefix.\n    *\n-   * @throws IllegalArgumentException\n+   * @throws IllegalArgumentException if {@code kmsKeyUri} is invalid.\n    */\n-  public static String validateKmsKeyUriAndRemovePrefix(String expectedPrefix, String kmsKeyUri)\n-      throws IllegalArgumentException {\n-    if (!kmsKeyUri.toLowerCase().startsWith(expectedPrefix)) {\n+  public static String validateKmsKeyUriAndRemovePrefix(String expectedPrefix, String kmsKeyUri) {\n+    if (!kmsKeyUri.toLowerCase(Locale.US).startsWith(expectedPrefix)) {\n       throw new IllegalArgumentException(\n           String.format(\"key URI must start with %s\", expectedPrefix));\n     }",
      "parent_sha": "fd6ca490b3794c8c33cf987ffcc6227c18aca862"
    }
  },
  {
    "oid": "71a2aae6dcda00fc73b8dccab256f89839e803a0",
    "message": "Clean up javadoc in KmsEnvelopeAead.java.\n\nPiperOrigin-RevId: 268270925",
    "date": "2019-09-10T18:34:06Z",
    "url": "https://github.com/tink-crypto/tink/commit/71a2aae6dcda00fc73b8dccab256f89839e803a0",
    "details": {
      "sha": "fe281d1fd1d032c7f9c2779dcb2bcd3111702421",
      "filename": "java/src/main/java/com/google/crypto/tink/aead/KmsEnvelopeAead.java",
      "status": "modified",
      "additions": 15,
      "deletions": 8,
      "changes": 23,
      "blob_url": "https://github.com/tink-crypto/tink/blob/71a2aae6dcda00fc73b8dccab256f89839e803a0/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Faead%2FKmsEnvelopeAead.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/71a2aae6dcda00fc73b8dccab256f89839e803a0/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Faead%2FKmsEnvelopeAead.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Faead%2FKmsEnvelopeAead.java?ref=71a2aae6dcda00fc73b8dccab256f89839e803a0",
      "patch": "@@ -25,14 +25,21 @@\n \n /**\n  * This primitive implements <a href=\"https://cloud.google.com/kms/docs/data-encryption-keys\">\n- * envelope encryption</a>. In envelope encryption, user generates a data encryption key (DEK)\n- * locally, encrypts data with DEK, sends DEK to a KMS to be encrypted (with a key managed by KMS),\n- * and stores encrypted DEK with encrypted data; at a later point user can retrieve encrypted data\n- * and DEK, use Storky to decrypt DEK, and use decrypted DEK to decrypt the data.\n- * The ciphertext structure is as follows:\n- *   - Length of encrypted DEK: 4 bytes.\n- *   - Encrypted DEK: variable length that is equal to the value specified in the last 4 bytes.\n- *   - AEAD payload: variable length.\n+ * envelope encryption</a>.\n+ *\n+ * <p>In envelope encryption, a user generates a data encryption key (DEK) locally, encrypts data\n+ * with the DEK, sends the DEK to a KMS to be encrypted (with a key managed by KMS), and then stores\n+ * the encrypted DEK with the encrypted data. At a later point, a user can retrieve the encrypted\n+ * data and the encyrpted DEK, use the KMS to decrypt the DEK, and use the decrypted DEK to decrypt\n+ * the data.\n+ *\n+ * <p>The ciphertext structure is as follows:\n+ *\n+ * <ul>\n+ *   <li>Length of the encrypted DEK: 4 bytes.\n+ *   <li>Encrypted DEK: variable length that is equal to the value specified in the last 4 bytes.\n+ *   <li>AEAD payload: variable length.\n+ * </ul>\n  */\n public final class KmsEnvelopeAead implements Aead {\n   private static final byte[] EMPTY_AAD = new byte[0];",
      "parent_sha": "69d1139b98eb3a7cb065b35ef78909b3008281fa"
    }
  },
  {
    "oid": "8aca9292b3f41b8a3611a74645d0084b8725ed0a",
    "message": "Add test vectors from the EAX Documentation.\n\nPiperOrigin-RevId: 523627224",
    "date": "2023-04-12T07:54:55Z",
    "url": "https://github.com/tink-crypto/tink/commit/8aca9292b3f41b8a3611a74645d0084b8725ed0a",
    "details": {
      "sha": "7858c344563583313462fffb90c91b47a1160224",
      "filename": "java_src/src/test/java/com/google/crypto/tink/subtle/AesEaxJceTest.java",
      "status": "modified",
      "additions": 95,
      "deletions": 2,
      "changes": 97,
      "blob_url": "https://github.com/tink-crypto/tink/blob/8aca9292b3f41b8a3611a74645d0084b8725ed0a/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FAesEaxJceTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/8aca9292b3f41b8a3611a74645d0084b8725ed0a/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FAesEaxJceTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FAesEaxJceTest.java?ref=8aca9292b3f41b8a3611a74645d0084b8725ed0a",
      "patch": "@@ -34,11 +34,14 @@\n import org.junit.Assume;\n import org.junit.Before;\n import org.junit.Test;\n+import org.junit.experimental.theories.DataPoints;\n+import org.junit.experimental.theories.FromDataPoints;\n+import org.junit.experimental.theories.Theories;\n+import org.junit.experimental.theories.Theory;\n import org.junit.runner.RunWith;\n-import org.junit.runners.JUnit4;\n \n /** Unit tests for AesEax. */\n-@RunWith(JUnit4.class)\n+@RunWith(Theories.class)\n public class AesEaxJceTest {\n   private static final int KEY_SIZE = 16;\n   private static final int IV_SIZE = 16;\n@@ -301,4 +304,94 @@ public void testFailIfFipsModeUsed() throws Exception {\n     byte[] key = Random.randBytes(16);\n     assertThrows(GeneralSecurityException.class, () -> new AesEaxJce(key, IV_SIZE));\n   }\n+\n+  private static class TestVector {\n+    public TestVector(\n+        String hexMessage, String hexKey, String hexNonce, String hexAad, String hexCiphertext) {\n+      this.hexMessage = hexMessage;\n+      this.hexKey = hexKey;\n+      this.hexNonce = hexNonce;\n+      this.hexAad = hexAad;\n+      this.hexCiphertext = hexCiphertext;\n+    }\n+\n+    public final String hexMessage;\n+    public final String hexKey;\n+    public final String hexNonce;\n+    public final String hexAad;\n+    public final String hexCiphertext;\n+  }\n+\n+  @DataPoints(\"testVectors\")\n+  // Test vectors from \"The EAX Mode of Operation\", Appendix G.\n+  public static final TestVector[] TEST_VECTORS =\n+      new TestVector[] {\n+        new TestVector(\n+            \"\",\n+            \"233952dee4d5ed5f9b9c6d6ff80ff478\",\n+            \"62ec67f9c3a4a407fcb2a8c49031a8b3\",\n+            \"6bfb914fd07eae6b\",\n+            \"e037830e8389f27b025a2d6527e79d01\"),\n+        new TestVector(\n+            \"f7fb\",\n+            \"91945d3f4dcbee0bf45ef52255f095a4\",\n+            \"becaf043b0a23d843194ba972c66debd\",\n+            \"fa3bfd4806eb53fa\",\n+            \"19dd5c4c9331049d0bdab0277408f67967e5\"),\n+        new TestVector(\n+            \"481c9e39b1\",\n+            \"d07cf6cbb7f313bdde66b727afd3c5e8\",\n+            \"8408dfff3c1a2b1292dc199e46b7d617\",\n+            \"33cce2eabff5a79d\",\n+            \"632a9d131ad4c168a4225d8e1ff755939974a7bede\"),\n+        new TestVector(\n+            \"40d0c07da5e4\",\n+            \"35b6d0580005bbc12b0587124557d2c2\",\n+            \"fdb6b06676eedc5c61d74276e1f8e816\",\n+            \"aeb96eaebe2970e9\",\n+            \"071dfe16c675cb0677e536f73afe6a14b74ee49844dd\"),\n+        new TestVector(\n+            \"4de3b35c3fc039245bd1fb7d\",\n+            \"bd8e6e11475e60b268784c38c62feb22\",\n+            \"6eac5c93072d8e8513f750935e46da1b\",\n+            \"d4482d1ca78dce0f\",\n+            \"835bb4f15d743e350e728414abb8644fd6ccb86947c5e10590210a4f\"),\n+        new TestVector(\n+            \"8b0a79306c9ce7ed99dae4f87f8dd61636\",\n+            \"7c77d6e813bed5ac98baa417477a2e7d\",\n+            \"1a8c98dcd73d38393b2bf1569deefc19\",\n+            \"65d2017990d62528\",\n+            \"02083e3979da014812f59f11d52630da30137327d10649b0aa6e1c181db617d7f2\"),\n+        new TestVector(\n+            \"1bda122bce8a8dbaf1877d962b8592dd2d56\",\n+            \"5fff20cafab119ca2fc73549e20f5b0d\",\n+            \"dde59b97d722156d4d9aff2bc7559826\",\n+            \"54b9f04e6a09189a\",\n+            \"2ec47b2c4954a489afc7ba4897edcdae8cc33b60450599bd02c96382902aef7f832a\"),\n+        new TestVector(\n+            \"6cf36720872b8513f6eab1a8a44438d5ef11\",\n+            \"a4a4782bcffd3ec5e7ef6d8c34a56123\",\n+            \"b781fcf2f75fa5a8de97a9ca48e522ec\",\n+            \"899a175897561d7e\",\n+            \"0de18fd0fdd91e7af19f1d8ee8733938b1e8e7f6d2231618102fdb7fe55ff1991700\"),\n+        new TestVector(\n+            \"ca40d7446e545ffaed3bd12a740a659ffbbb3ceab7\",\n+            \"8395fcf1e95bebd697bd010bc766aac3\",\n+            \"22e7add93cfc6393c57ec0b3c17d6b44\",\n+            \"126735fcc320d25a\",\n+            \"cb8920f87a6c75cff39627b56e3ed197c552d295a7cfc46afc253b4652b1af3795b124ab6e\")\n+      };\n+\n+  @Theory\n+  public void testVector_decrypt_works(@FromDataPoints(\"testVectors\") TestVector vector)\n+      throws Exception {\n+    // We cannot use \"Assume\" here because Theories will complain that no input does any test.\n+    if (TinkFips.useOnlyFips()) {\n+      return;\n+    }\n+    byte[] fullCiphertext = Hex.decode(vector.hexNonce + vector.hexCiphertext);\n+    AesEaxJce eax = new AesEaxJce(Hex.decode(vector.hexKey), Hex.decode(vector.hexNonce).length);\n+    byte[] decryption = eax.decrypt(fullCiphertext, Hex.decode(vector.hexAad));\n+    assertThat(Hex.encode(decryption)).isEqualTo(vector.hexMessage);\n+  }\n }",
      "parent_sha": "89fee9d0c9a44b7e3b928d5859c8f4a44f7f75da"
    }
  },
  {
    "oid": "69125e65ff305f6172a12f093197e60d45c97bf8",
    "message": "Update the HmacKeyManager tests.\n\nPiperOrigin-RevId: 265860753",
    "date": "2019-08-28T08:40:30Z",
    "url": "https://github.com/tink-crypto/tink/commit/69125e65ff305f6172a12f093197e60d45c97bf8",
    "details": {
      "sha": "7656231e42c0c05fdb2a9e11504564791e27d229",
      "filename": "java/src/test/java/com/google/crypto/tink/mac/HmacKeyManagerTest.java",
      "status": "modified",
      "additions": 219,
      "deletions": 46,
      "changes": 265,
      "blob_url": "https://github.com/tink-crypto/tink/blob/69125e65ff305f6172a12f093197e60d45c97bf8/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fmac%2FHmacKeyManagerTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/69125e65ff305f6172a12f093197e60d45c97bf8/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fmac%2FHmacKeyManagerTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fmac%2FHmacKeyManagerTest.java?ref=69125e65ff305f6172a12f093197e60d45c97bf8",
      "patch": "@@ -16,22 +16,22 @@\n \n package com.google.crypto.tink.mac;\n \n-import static org.junit.Assert.assertEquals;\n+import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.fail;\n \n-import com.google.crypto.tink.KeyManager;\n-import com.google.crypto.tink.KeyManagerImpl;\n import com.google.crypto.tink.Mac;\n import com.google.crypto.tink.TestUtil;\n import com.google.crypto.tink.proto.HashType;\n import com.google.crypto.tink.proto.HmacKey;\n import com.google.crypto.tink.proto.HmacKeyFormat;\n import com.google.crypto.tink.proto.HmacParams;\n-import com.google.crypto.tink.proto.KeyTemplate;\n+import com.google.crypto.tink.subtle.MacJce;\n+import com.google.crypto.tink.subtle.Random;\n import com.google.protobuf.ByteString;\n import java.security.GeneralSecurityException;\n import java.util.Set;\n import java.util.TreeSet;\n+import javax.crypto.spec.SecretKeySpec;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n@@ -40,57 +40,230 @@\n @RunWith(JUnit4.class)\n public class HmacKeyManagerTest {\n   @Test\n-  public void testNewKeyMultipleTimes() throws Exception {\n-    KeyManager<Mac> keyManager = new KeyManagerImpl<>(new HmacKeyManager(), Mac.class);\n-    HmacKeyFormat hmacKeyFormat = HmacKeyFormat.newBuilder()\n-        .setParams(HmacParams.newBuilder().setHash(HashType.SHA256).setTagSize(16).build())\n-        .setKeySize(32)\n+  public void validateKeyFormat_empty() throws Exception {\n+    try {\n+      new HmacKeyManager().keyFactory().validateKeyFormat(HmacKeyFormat.getDefaultInstance());\n+      fail(\"At least the hash type needs to be set\");\n+    } catch (GeneralSecurityException e) {\n+      // expected.\n+    }\n+  }\n+\n+  private static HmacKeyFormat makeHmacKeyFormat(int keySize, int tagSize, HashType hashType) {\n+    HmacParams params = HmacParams.newBuilder()\n+        .setHash(hashType)\n+        .setTagSize(tagSize)\n         .build();\n-    ByteString serialized = ByteString.copyFrom(hmacKeyFormat.toByteArray());\n-    KeyTemplate keyTemplate =\n-        KeyTemplate.newBuilder()\n-            .setTypeUrl(new HmacKeyManager().getKeyType())\n-            .setValue(serialized)\n-            .build();\n-    // Calls newKey multiple times and make sure that we get different HmacKey each time.\n+    return HmacKeyFormat.newBuilder()\n+        .setParams(params)\n+        .setKeySize(keySize)\n+        .build();\n+  }\n+\n+  @Test\n+  public void validateKeyFormat_tagSizesSha1() throws Exception {\n+    HmacKeyManager manager = new HmacKeyManager();\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 10, HashType.SHA1));\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 11, HashType.SHA1));\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 12, HashType.SHA1));\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 13, HashType.SHA1));\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 14, HashType.SHA1));\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 15, HashType.SHA1));\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 16, HashType.SHA1));\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 17, HashType.SHA1));\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 18, HashType.SHA1));\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 19, HashType.SHA1));\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 20, HashType.SHA1));\n+    try {\n+      manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 21, HashType.SHA1));\n+      fail(\"SHA1 HMAC should not support tag size 21\");\n+    } catch (GeneralSecurityException e) {\n+      // expected\n+    }\n+  }\n+\n+  @Test\n+  public void validateKeyFormat_tagSizesSha256() throws Exception {\n+    HmacKeyManager manager = new HmacKeyManager();\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 10, HashType.SHA256));\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 11, HashType.SHA256));\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 12, HashType.SHA256));\n+\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 30, HashType.SHA256));\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 31, HashType.SHA256));\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 32, HashType.SHA256));\n+    try {\n+      manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 33, HashType.SHA256));\n+      fail(\"SHA256 HMAC should not support tag size 33\");\n+    } catch (GeneralSecurityException e) {\n+      // expected\n+    }\n+  }\n+\n+  @Test\n+  public void validateKeyFormat_tagSizesSha512() throws Exception {\n+    HmacKeyManager manager = new HmacKeyManager();\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 10, HashType.SHA512));\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 11, HashType.SHA512));\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 12, HashType.SHA512));\n+\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 62, HashType.SHA512));\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 63, HashType.SHA512));\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 64, HashType.SHA512));\n+    try {\n+      manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 65, HashType.SHA512));\n+      fail(\"SHA256 HMAC should not support tag size 65\");\n+    } catch (GeneralSecurityException e) {\n+      // expected\n+    }\n+  }\n+\n+  @Test\n+  public void validateKeyFormat_keySizes() throws Exception {\n+    HmacKeyManager manager = new HmacKeyManager();\n+    manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(16, 10, HashType.SHA256));\n+    try {\n+      manager.keyFactory().validateKeyFormat(makeHmacKeyFormat(15, 10, HashType.SHA256));\n+      fail();\n+    } catch (GeneralSecurityException e) {\n+      // expected\n+    }\n+  }\n+\n+  @Test\n+  public void createKey_valid() throws Exception {\n+    HmacKeyManager manager = new HmacKeyManager();\n+    manager.validateKey(manager.keyFactory().createKey(makeHmacKeyFormat(16, 10, HashType.SHA1)));\n+    manager.validateKey(manager.keyFactory().createKey(makeHmacKeyFormat(16, 20, HashType.SHA1)));\n+    manager.validateKey(manager.keyFactory().createKey(makeHmacKeyFormat(16, 10, HashType.SHA256)));\n+    manager.validateKey(manager.keyFactory().createKey(makeHmacKeyFormat(16, 32, HashType.SHA256)));\n+    manager.validateKey(manager.keyFactory().createKey(makeHmacKeyFormat(16, 10, HashType.SHA512)));\n+    manager.validateKey(manager.keyFactory().createKey(makeHmacKeyFormat(16, 64, HashType.SHA512)));\n+  }\n+\n+  @Test\n+  public void createKey_checkValues() throws Exception {\n+    HmacKeyFormat keyFormat = makeHmacKeyFormat(16, 10, HashType.SHA256);\n+    HmacKey key = new HmacKeyManager().keyFactory().createKey(keyFormat);\n+    assertThat(key.getKeyValue()).hasSize(keyFormat.getKeySize());\n+    assertThat(key.getParams().getTagSize()).isEqualTo(keyFormat.getParams().getTagSize());\n+  }\n+\n+  @Test\n+  public void createKey_multipleTimes() throws Exception {\n+    HmacKeyManager manager = new HmacKeyManager();\n+    HmacKeyFormat keyFormat = makeHmacKeyFormat(16, 10, HashType.SHA256);\n+    int numKeys = 100;\n     Set<String> keys = new TreeSet<String>();\n-    int numTests = 27;\n-    for (int i = 0; i < numTests / 3; i++) {\n-      HmacKey key = (HmacKey) keyManager.newKey(hmacKeyFormat);\n-      assertEquals(32, key.getKeyValue().toByteArray().length);\n-      keys.add(TestUtil.hexEncode(key.getKeyValue().toByteArray()));\n-\n-      key = (HmacKey) keyManager.newKey(serialized);\n-      assertEquals(32, key.getKeyValue().toByteArray().length);\n-      keys.add(TestUtil.hexEncode(key.getKeyValue().toByteArray()));\n-\n-      key = HmacKey.parseFrom(keyManager.newKeyData(keyTemplate.getValue()).getValue());\n-      assertEquals(32, key.getKeyValue().toByteArray().length);\n-      keys.add(TestUtil.hexEncode(key.getKeyValue().toByteArray()));\n+    for (int i = 0; i < numKeys; ++i) {\n+      keys.add(\n+          TestUtil.hexEncode(\n+              manager.keyFactory().createKey(keyFormat).getKeyValue().toByteArray()));\n     }\n-    assertEquals(numTests, keys.size());\n+    assertThat(keys).hasSize(numKeys);\n   }\n \n   @Test\n-  public void testNewKeyCorruptedFormat() throws Exception {\n-    KeyManager<Mac> keyManager = new KeyManagerImpl<>(new HmacKeyManager(), Mac.class);\n-    ByteString serialized = ByteString.copyFrom(new byte[128]);\n-    KeyTemplate keyTemplate =\n-        KeyTemplate.newBuilder()\n-            .setTypeUrl(new HmacKeyManager().getKeyType())\n-            .setValue(serialized)\n-            .build();\n+  public void validateKey_wrongVersion_throws() throws Exception {\n+    HmacKeyManager manager = new HmacKeyManager();\n+    HmacKey validKey = manager.keyFactory().createKey(makeHmacKeyFormat(16, 10, HashType.SHA1));\n+    try {\n+      manager.validateKey(HmacKey.newBuilder(validKey).setVersion(1).build());\n+      fail();\n+    } catch (GeneralSecurityException e) {\n+      // expected\n+    }\n+  }\n+\n+  @Test\n+  public void validateKey_notValid_throws() throws Exception {\n+    HmacKeyManager manager = new HmacKeyManager();\n+    HmacKey validKey = manager.keyFactory().createKey(makeHmacKeyFormat(16, 10, HashType.SHA1));\n+    try {\n+      manager.validateKey(\n+          HmacKey.newBuilder(validKey)\n+              .setKeyValue(ByteString.copyFrom(Random.randBytes(15)))\n+              .build());\n+      fail();\n+    } catch (GeneralSecurityException e) {\n+      // expected\n+    }\n     try {\n-      keyManager.newKey(serialized);\n-      fail(\"Corrupted format, should have thrown exception\");\n-    } catch (GeneralSecurityException expected) {\n-      // Expected\n+      manager\n+          .validateKey(\n+              HmacKey.newBuilder(validKey)\n+                  .setParams(HmacParams.newBuilder(validKey.getParams()).setTagSize(0).build())\n+                  .build());\n+      fail();\n+    } catch (GeneralSecurityException e) {\n+      // expected\n     }\n     try {\n-      keyManager.newKeyData(keyTemplate.getValue());\n-      fail(\"Corrupted format, should have thrown exception\");\n-    } catch (GeneralSecurityException expected) {\n-      // Expected\n+      manager\n+          .validateKey(\n+              HmacKey.newBuilder(validKey)\n+                  .setParams(HmacParams.newBuilder(validKey.getParams()).setTagSize(9).build())\n+                  .build());\n+      fail();\n+    } catch (GeneralSecurityException e) {\n+      // expected\n     }\n+    try {\n+      manager\n+          .validateKey(\n+              HmacKey.newBuilder(validKey)\n+                  .setParams(HmacParams.newBuilder(validKey.getParams()).setTagSize(21).build())\n+                  .build());\n+      fail();\n+    } catch (GeneralSecurityException e) {\n+      // expected\n+    }\n+    try {\n+      manager\n+          .validateKey(\n+              HmacKey.newBuilder(validKey)\n+                  .setParams(HmacParams.newBuilder(validKey.getParams()).setTagSize(32).build())\n+                  .build());\n+      fail();\n+    } catch (GeneralSecurityException e) {\n+      // expected\n+    }\n+  }\n+\n+\n+  @Test\n+  public void getPrimitive_worksForSha1() throws Exception {\n+    HmacKeyManager manager = new HmacKeyManager();\n+    HmacKey validKey = manager.keyFactory().createKey(makeHmacKeyFormat(16, 19, HashType.SHA1));\n+    Mac managerMac = manager.getPrimitive(validKey, Mac.class);\n+    Mac directMac =\n+        new MacJce(\n+            \"HMACSHA1\", new SecretKeySpec(validKey.getKeyValue().toByteArray(), \"HMAC\"), 19);\n+    byte[] message = Random.randBytes(50);\n+    managerMac.verifyMac(directMac.computeMac(message), message);\n+  }\n+\n+  @Test\n+  public void getPrimitive_worksForSha256() throws Exception {\n+    HmacKeyManager manager = new HmacKeyManager();\n+    HmacKey validKey = manager.keyFactory().createKey(makeHmacKeyFormat(16, 29, HashType.SHA256));\n+    Mac managerMac = manager.getPrimitive(validKey, Mac.class);\n+    Mac directMac =\n+        new MacJce(\n+            \"HMACSHA256\", new SecretKeySpec(validKey.getKeyValue().toByteArray(), \"HMAC\"), 29);\n+    byte[] message = Random.randBytes(50);\n+    managerMac.verifyMac(directMac.computeMac(message), message);\n+  }\n+\n+  @Test\n+  public void getPrimitive_worksForSha512() throws Exception {\n+    HmacKeyManager manager = new HmacKeyManager();\n+    HmacKey validKey = manager.keyFactory().createKey(makeHmacKeyFormat(16, 33, HashType.SHA512));\n+    Mac managerMac = manager.getPrimitive(validKey, Mac.class);\n+    Mac directMac =\n+        new MacJce(\n+            \"HMACSHA512\", new SecretKeySpec(validKey.getKeyValue().toByteArray(), \"HMAC\"), 33);\n+    byte[] message = Random.randBytes(50);\n+    managerMac.verifyMac(directMac.computeMac(message), message);\n   }\n }",
      "parent_sha": "e6791ff52e5ea0ca3f824cda06ff1e64279ae1c3"
    }
  },
  {
    "oid": "28c6858bd4a32dc2c49b51eab4d4ab9efa79cfc9",
    "message": "Remove package-private \"withKeystore\" method from AndroidKeysetManager.\n\nThis is not used anymore.\n\nPiperOrigin-RevId: 504486005",
    "date": "2023-01-25T08:41:29Z",
    "url": "https://github.com/tink-crypto/tink/commit/28c6858bd4a32dc2c49b51eab4d4ab9efa79cfc9",
    "details": {
      "sha": "6714dadd237af56e3207aa9aed27d5263215bb0a",
      "filename": "java_src/src/main/java/com/google/crypto/tink/integration/android/AndroidKeysetManager.java",
      "status": "modified",
      "additions": 1,
      "deletions": 15,
      "changes": 16,
      "blob_url": "https://github.com/tink-crypto/tink/blob/28c6858bd4a32dc2c49b51eab4d4ab9efa79cfc9/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeysetManager.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/28c6858bd4a32dc2c49b51eab4d4ab9efa79cfc9/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeysetManager.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeysetManager.java?ref=28c6858bd4a32dc2c49b51eab4d4ab9efa79cfc9",
      "patch": "@@ -38,7 +38,6 @@\n import java.io.CharConversionException;\n import java.io.IOException;\n import java.security.GeneralSecurityException;\n-import java.security.KeyStore;\n import java.security.KeyStoreException;\n import java.security.ProviderException;\n import javax.annotation.concurrent.GuardedBy;\n@@ -154,7 +153,6 @@ public static final class Builder {\n     private Aead masterKey = null;\n     private boolean useKeystore = true;\n     private KeyTemplate keyTemplate = null;\n-    private KeyStore keyStore = null;\n \n     @GuardedBy(\"this\")\n     private KeysetManager keysetManager;\n@@ -236,13 +234,6 @@ public Builder doNotUseKeystore() {\n       return this;\n     }\n \n-    /** This is for testing only */\n-    @CanIgnoreReturnValue\n-    Builder withKeyStore(KeyStore val) {\n-      this.keyStore = val;\n-      return this;\n-    }\n-\n     /** Returns the serialized keyset if it exist or null. */\n     @Nullable\n     @SuppressWarnings(\"UnusedException\")\n@@ -308,12 +299,7 @@ private Aead readOrGenerateNewMasterKey() throws GeneralSecurityException {\n         return null;\n       }\n \n-      AndroidKeystoreKmsClient client;\n-      if (keyStore != null) {\n-        client = new AndroidKeystoreKmsClient.Builder().setKeyStore(keyStore).build();\n-      } else {\n-        client = new AndroidKeystoreKmsClient();\n-      }\n+      AndroidKeystoreKmsClient client = new AndroidKeystoreKmsClient();\n \n       boolean generated;\n       try {",
      "parent_sha": "8a9f5d375404e84c7b1544ee51426dc75d110af8"
    }
  },
  {
    "oid": "6d622e75f6bea40cb3fd708f05b642a953e50e61",
    "message": "Mark PrimitiveRegistry.Builder.build() public (note that this is still a Tink internal API, however).\n\nPiperOrigin-RevId: 536413757",
    "date": "2023-05-30T15:53:08Z",
    "url": "https://github.com/tink-crypto/tink/commit/6d622e75f6bea40cb3fd708f05b642a953e50e61",
    "details": {
      "sha": "4be8c05cb6183a192ded086d087e8484c2ed6ead",
      "filename": "java_src/src/main/java/com/google/crypto/tink/internal/PrimitiveRegistry.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/tink-crypto/tink/blob/6d622e75f6bea40cb3fd708f05b642a953e50e61/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Finternal%2FPrimitiveRegistry.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/6d622e75f6bea40cb3fd708f05b642a953e50e61/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Finternal%2FPrimitiveRegistry.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Finternal%2FPrimitiveRegistry.java?ref=6d622e75f6bea40cb3fd708f05b642a953e50e61",
      "patch": "@@ -106,7 +106,7 @@ public <InputPrimitiveT, WrapperPrimitiveT> Builder registerPrimitiveWrapper(\n       return this;\n     }\n \n-    PrimitiveRegistry build() {\n+    public PrimitiveRegistry build() {\n       return new PrimitiveRegistry(this);\n     }\n   }",
      "parent_sha": "2d0a5c384184029e20ac1caffc19d16c681fdc05"
    }
  },
  {
    "oid": "6495d823d96860bedd177e712b73bae94da01d45",
    "message": "Java: Remove e.printStracktrace() in favor of a cause (#207)",
    "date": "2019-05-23T15:00:20Z",
    "url": "https://github.com/tink-crypto/tink/commit/6495d823d96860bedd177e712b73bae94da01d45",
    "details": {
      "sha": "a88b0a2afcdc1327251b5f9e096319dca92fffed",
      "filename": "java/src/main/java/com/google/crypto/tink/subtle/EngineFactory.java",
      "status": "modified",
      "additions": 9,
      "deletions": 14,
      "changes": 23,
      "blob_url": "https://github.com/tink-crypto/tink/blob/6495d823d96860bedd177e712b73bae94da01d45/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FEngineFactory.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/6495d823d96860bedd177e712b73bae94da01d45/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FEngineFactory.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FEngineFactory.java?ref=6495d823d96860bedd177e712b73bae94da01d45",
      "patch": "@@ -155,28 +155,23 @@ public EngineFactory(T_WRAPPER instanceBuilder, List<Provider> policy, boolean l\n   }\n \n   public T_ENGINE getInstance(String algorithm) throws GeneralSecurityException {\n-    for (Provider p : this.policy) {\n-      if (tryProvider(algorithm, p)) {\n-        return this.instanceBuilder.getInstance(algorithm, p);\n+    Exception cause = null;\n+    for (Provider provider : this.policy) {\n+      try {\n+        return this.instanceBuilder.getInstance(algorithm, provider);\n+      } catch (Exception e) {\n+        if (cause == null) {\n+          cause = e;\n+        }\n       }\n     }\n     if (letFallback) {\n       return this.instanceBuilder.getInstance(algorithm, null);\n     }\n-    throw new GeneralSecurityException(\"No good Provider found.\");\n+    throw new GeneralSecurityException(\"No good Provider found.\", cause);\n   }\n \n   private T_WRAPPER instanceBuilder;\n   private List<Provider> policy;\n   private boolean letFallback;\n-\n-  private boolean tryProvider(String algorithm, Provider provider) {\n-    try {\n-      this.instanceBuilder.getInstance(algorithm, provider);\n-      return true;\n-    } catch (Exception e) { // Don't care which one specifically.\n-      e.printStackTrace();\n-      return false;\n-    }\n-  }\n }",
      "parent_sha": "d0687dbff4f41e01fb6cb3c3e88dcf7baef4bfff"
    }
  },
  {
    "oid": "03a495b12077e74b92c207b09dc79110fb0cbff6",
    "message": "Deprecate the generateNew overload taking a proto KeyTemplate\n\nPiperOrigin-RevId: 565655358",
    "date": "2023-09-15T12:56:10Z",
    "url": "https://github.com/tink-crypto/tink/commit/03a495b12077e74b92c207b09dc79110fb0cbff6",
    "details": {
      "sha": "944fdda74769650e63bd7349bbfaf9ef3493c850",
      "filename": "java_src/src/main/java/com/google/crypto/tink/KeysetHandle.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/tink-crypto/tink/blob/03a495b12077e74b92c207b09dc79110fb0cbff6/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/03a495b12077e74b92c207b09dc79110fb0cbff6/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java?ref=03a495b12077e74b92c207b09dc79110fb0cbff6",
      "patch": "@@ -807,9 +807,11 @@ public static final KeysetHandle generateNew(Parameters parameters)\n    * <p>If this is not possible, please inline the function in your code.\n    *\n    * @throws GeneralSecurityException if the key template is invalid.\n+   * @deprecated Use the overload taking a Parameters object instead.\n    */\n-  public static final KeysetHandle generateNew(com.google.crypto.tink.proto.KeyTemplate keyTemplate)\n-      throws GeneralSecurityException {\n+  @Deprecated\n+  public static final KeysetHandle generateNew(\n+      com.google.crypto.tink.proto.KeyTemplate keyTemplate) throws GeneralSecurityException {\n     return generateNew(TinkProtoParametersFormat.parse(keyTemplate.toByteArray()));\n   }\n ",
      "parent_sha": "3194b6b6e62568c8a53ca81dd6fb97fe22d5938c"
    }
  },
  {
    "oid": "2fce9c363bb7fa64da0e799af069f7e04061a2c2",
    "message": "Add version to Cloud KMS's application name.\n\nPiperOrigin-RevId: 215486990\nGitOrigin-RevId: b8a61218646033cd7713c2bb5398c825f680ddc9",
    "date": "2018-10-03T01:43:54Z",
    "url": "https://github.com/tink-crypto/tink/commit/2fce9c363bb7fa64da0e799af069f7e04061a2c2",
    "details": {
      "sha": "fcf7f8144512b2c74be0273db094be10b4327690",
      "filename": "java/src/main/java/com/google/crypto/tink/integration/gcpkms/GcpKmsClient.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/tink-crypto/tink/blob/2fce9c363bb7fa64da0e799af069f7e04061a2c2/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fgcpkms%2FGcpKmsClient.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/2fce9c363bb7fa64da0e799af069f7e04061a2c2/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fgcpkms%2FGcpKmsClient.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fgcpkms%2FGcpKmsClient.java?ref=2fce9c363bb7fa64da0e799af069f7e04061a2c2",
      "patch": "@@ -24,6 +24,7 @@\n import com.google.auto.service.AutoService;\n import com.google.crypto.tink.Aead;\n import com.google.crypto.tink.KmsClient;\n+import com.google.crypto.tink.Version;\n import com.google.crypto.tink.subtle.Validators;\n import java.io.File;\n import java.io.FileInputStream;\n@@ -41,7 +42,7 @@ public final class GcpKmsClient implements KmsClient {\n   /** The prefix of all keys stored in Google Cloud KMS. */\n   public static final String PREFIX = \"gcp-kms://\";\n \n-  private static final String APPLICATION_NAME = \"Tink\";\n+  private static final String APPLICATION_NAME = \"Tink/\" + Version.TINK_VERSION;\n   private CloudKMS client;\n   private String keyUri;\n ",
      "parent_sha": "aa6c293167c615dc2e9baf7abaafd1f48e65d3d9"
    }
  },
  {
    "oid": "b00da20bcde0c2f9aabe4f9ae76254404c39f770",
    "message": "Deprecate KmsClients.getAutoLoaded.\n\nAlso, update documentation, this is not used anymore by Tinkey.\n\nPiperOrigin-RevId: 559095071",
    "date": "2023-08-22T13:37:23Z",
    "url": "https://github.com/tink-crypto/tink/commit/b00da20bcde0c2f9aabe4f9ae76254404c39f770",
    "details": {
      "sha": "43e25d36bb8770cb20066c2b7f101749189a179a",
      "filename": "java_src/src/main/java/com/google/crypto/tink/KmsClients.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/tink-crypto/tink/blob/b00da20bcde0c2f9aabe4f9ae76254404c39f770/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKmsClients.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/b00da20bcde0c2f9aabe4f9ae76254404c39f770/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKmsClients.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKmsClients.java?ref=b00da20bcde0c2f9aabe4f9ae76254404c39f770",
      "patch": "@@ -65,12 +65,12 @@ public static KmsClient get(String keyUri) throws GeneralSecurityException {\n    * <p><b>Warning</b> This method searches over the classpath for all implementations of {@link\n    * KmsClient}. An attacker that can insert a class in your classpath (e.g., someone controlling a\n    * library that you're using) could provide a fake {@link KmsClient} that steal your keys. For\n-   * this reason Tink does not use this method. It is used by <a\n-   * href=\"https://github.com/google/tink/tree/master/tools/tinkey\">Tinkey</a> which needs to talk\n-   * to custom, in-house key management systems.\n+   * this reason Tink does not use this method.\n    *\n+   * @deprecated Don't use this.\n    * @throws GeneralSecurityException if cannot found any KMS clients that support {@code keyUri}\n    */\n+  @Deprecated\n   public static synchronized KmsClient getAutoLoaded(String keyUri)\n       throws GeneralSecurityException {\n     if (autoClients == null) {",
      "parent_sha": "35a7a238b638962b561a3af3ceef6abc3f159461"
    }
  },
  {
    "oid": "fd72521feed71968618a95662dd0ed3e3b15f006",
    "message": "Removing deprecated method PublicKeyVerifyFactory.getPrimitive(KeySetHandle, KeyManager) in Java.\n\nPiperOrigin-RevId: 339524896",
    "date": "2020-10-28T20:21:10Z",
    "url": "https://github.com/tink-crypto/tink/commit/fd72521feed71968618a95662dd0ed3e3b15f006",
    "details": {
      "sha": "edc1aabaf5848038a535e5db1ae9aeb121ddb588",
      "filename": "java_src/src/main/java/com/google/crypto/tink/signature/PublicKeyVerifyFactory.java",
      "status": "modified",
      "additions": 1,
      "deletions": 16,
      "changes": 17,
      "blob_url": "https://github.com/tink-crypto/tink/blob/fd72521feed71968618a95662dd0ed3e3b15f006/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsignature%2FPublicKeyVerifyFactory.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/fd72521feed71968618a95662dd0ed3e3b15f006/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsignature%2FPublicKeyVerifyFactory.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsignature%2FPublicKeyVerifyFactory.java?ref=fd72521feed71968618a95662dd0ed3e3b15f006",
      "patch": "@@ -16,7 +16,6 @@\n \n package com.google.crypto.tink.signature;\n \n-import com.google.crypto.tink.KeyManager;\n import com.google.crypto.tink.KeysetHandle;\n import com.google.crypto.tink.PrimitiveSet;\n import com.google.crypto.tink.PublicKeyVerify;\n@@ -49,23 +48,9 @@ public final class PublicKeyVerifyFactory {\n   @Deprecated\n   public static PublicKeyVerify getPrimitive(KeysetHandle keysetHandle)\n       throws GeneralSecurityException {\n-    return getPrimitive(keysetHandle, /* keyManager= */ null);\n-  }\n-\n-  /**\n-   * @return a PublicKeyVerify primitive from a {@code keysetHandle} and a custom {@code\n-   *     keyManager}.\n-   * @throws GeneralSecurityException\n-   * @deprecated Use {@code keysetHandle.GetPrimitive(keyManager, PublicKeyVerify.class)} after\n-   *     registering the {@code PublicKeyVerifyWrapper} instead.\n-   */\n-  @Deprecated\n-  public static PublicKeyVerify getPrimitive(\n-      KeysetHandle keysetHandle, final KeyManager<PublicKeyVerify> keyManager)\n-      throws GeneralSecurityException {\n     Registry.registerPrimitiveWrapper(new PublicKeyVerifyWrapper());\n     final PrimitiveSet<PublicKeyVerify> primitives =\n-        Registry.getPrimitives(keysetHandle, keyManager, PublicKeyVerify.class);\n+        Registry.getPrimitives(keysetHandle, null, PublicKeyVerify.class);\n     return Registry.wrap(primitives);\n   }\n }",
      "parent_sha": "4ea28b362a00d621a5fa529e83c12b8c6c5dc4ea"
    }
  },
  {
    "oid": "a0a7f2b1ddb539b721e878a9dd390ea371d57584",
    "message": "Avoid the US_ASCII charset.\n\nPiperOrigin-RevId: 464024405",
    "date": "2022-07-29T08:31:03Z",
    "url": "https://github.com/tink-crypto/tink/commit/a0a7f2b1ddb539b721e878a9dd390ea371d57584",
    "details": {
      "sha": "7d7eddd29b77a700f141a1019884935fc2801dd8",
      "filename": "java_src/src/main/java/com/google/crypto/tink/mac/AesCmacProtoSerialization.java",
      "status": "modified",
      "additions": 13,
      "deletions": 2,
      "changes": 15,
      "blob_url": "https://github.com/tink-crypto/tink/blob/a0a7f2b1ddb539b721e878a9dd390ea371d57584/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fmac%2FAesCmacProtoSerialization.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/a0a7f2b1ddb539b721e878a9dd390ea371d57584/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fmac%2FAesCmacProtoSerialization.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fmac%2FAesCmacProtoSerialization.java?ref=a0a7f2b1ddb539b721e878a9dd390ea371d57584",
      "patch": "@@ -16,7 +16,6 @@\n \n package com.google.crypto.tink.mac;\n \n-import static java.nio.charset.StandardCharsets.US_ASCII;\n \n import com.google.crypto.tink.AccessesPartialKey;\n import com.google.crypto.tink.SecretKeyAccess;\n@@ -35,6 +34,7 @@\n import com.google.protobuf.ByteString;\n import com.google.protobuf.ExtensionRegistryLite;\n import com.google.protobuf.InvalidProtocolBufferException;\n+import java.io.UnsupportedEncodingException;\n import java.security.GeneralSecurityException;\n import javax.annotation.Nullable;\n \n@@ -45,7 +45,18 @@\n @SuppressWarnings(\"UnnecessarilyFullyQualified\") // Fully specifying proto types is more readable\n final class AesCmacProtoSerialization {\n   private static final String TYPE_URL = \"type.googleapis.com/google.crypto.tink.AesCmacKey\";\n-  private static final Bytes TYPE_URL_BYTES = Bytes.copyFrom(TYPE_URL.getBytes(US_ASCII));\n+\n+  // TODO(tholenst): move this to a Tink-internal utility function and avoid getBytes completely\n+  // (since it ignores non-ascii anyhow) and make errors into an InternalTinkError.\n+  private static final Bytes toBytesAscii(String s) {\n+    try {\n+      return Bytes.copyFrom(s.getBytes(\"ASCII\"));\n+    } catch (UnsupportedEncodingException e) {\n+      throw new IllegalArgumentException(e);\n+    }\n+  }\n+\n+  private static final Bytes TYPE_URL_BYTES = toBytesAscii(TYPE_URL);\n   private static final ParametersSerializer<AesCmacParameters, ProtoParametersSerialization>\n       PARAMETERS_SERIALIZER =\n           ParametersSerializer.create(",
      "parent_sha": "d4b7ac6fc2b923eb8bd5bd40a60d113f7ca6108e"
    }
  },
  {
    "oid": "58d505d550db4c56a5ada99b397c777b0fa2aa31",
    "message": "Fixing Maven error in rewardedads app.\n\nChange-Id: If6242c47f4072a74982de790dccc1765be599342\nORIGINAL_AUTHOR=Thai Duong <thaidn@google.com>\nGitOrigin-RevId: 2659dfdadce17c9c3457c50aad729ff266a4d5da",
    "date": "2018-02-14T22:46:24Z",
    "url": "https://github.com/tink-crypto/tink/commit/58d505d550db4c56a5ada99b397c777b0fa2aa31",
    "details": {
      "sha": "7d20130da8b75e638a7ba1239979e3ba0e517cb9",
      "filename": "apps/rewardedads/java/src/main/java/com/google/crypto/tink/apps/rewardedads/RewardedAdsVerifier.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/tink-crypto/tink/blob/58d505d550db4c56a5ada99b397c777b0fa2aa31/apps%2Frewardedads%2Fjava%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fapps%2Frewardedads%2FRewardedAdsVerifier.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/58d505d550db4c56a5ada99b397c777b0fa2aa31/apps%2Frewardedads%2Fjava%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fapps%2Frewardedads%2FRewardedAdsVerifier.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/apps%2Frewardedads%2Fjava%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fapps%2Frewardedads%2FRewardedAdsVerifier.java?ref=58d505d550db4c56a5ada99b397c777b0fa2aa31",
      "patch": "@@ -248,7 +248,7 @@ public Map<Integer, ECPublicKey> get() throws GeneralSecurityException {\n      * the private keys corresponding to the public keys added. Adding multiple keys is useful for\n      * handling key rotation.\n      */\n-    public Builder addVerifyingPublicKey(int keyId, final String val)\n+    public Builder addVerifyingPublicKey(final int keyId, final String val)\n         throws GeneralSecurityException {\n       this.verifyingPublicKeysProviders.add(\n           new VerifyingPublicKeysProvider() {\n@@ -270,7 +270,7 @@ public Map<Integer, ECPublicKey> get() throws GeneralSecurityException {\n      * this method if you can't use {@link #fetchVerifyingPublicKeysWith} and be aware you will need\n      * to handle Google key rotations yourself.\n      */\n-    public Builder addVerifyingPublicKey(int keyId, final ECPublicKey val)\n+    public Builder addVerifyingPublicKey(final int keyId, final ECPublicKey val)\n         throws GeneralSecurityException {\n       this.verifyingPublicKeysProviders.add(\n           new VerifyingPublicKeysProvider() {",
      "parent_sha": "7e7c41f9c7d073a5b34a3cb7936a728418634c95"
    }
  },
  {
    "oid": "08ac6454a8bab74d92e88ae4c4dc082a88bb8529",
    "message": "Fix documentation for getNistCurvePoint.\n\nPiperOrigin-RevId: 560014934",
    "date": "2023-08-25T08:24:30Z",
    "url": "https://github.com/tink-crypto/tink/commit/08ac6454a8bab74d92e88ae4c4dc082a88bb8529",
    "details": {
      "sha": "6fa94cfda112b79306b660bcec8af75aa663623a",
      "filename": "java_src/src/main/java/com/google/crypto/tink/hybrid/EciesPublicKey.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/tink-crypto/tink/blob/08ac6454a8bab74d92e88ae4c4dc082a88bb8529/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fhybrid%2FEciesPublicKey.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/08ac6454a8bab74d92e88ae4c4dc082a88bb8529/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fhybrid%2FEciesPublicKey.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fhybrid%2FEciesPublicKey.java?ref=08ac6454a8bab74d92e88ae4c4dc082a88bb8529",
      "patch": "@@ -158,9 +158,9 @@ public static EciesPublicKey createForNistCurve(\n   }\n \n   /**\n-   * Returns the underlying public point as byte array in case the curve is X25519.\n+   * Returns the underlying public point if the curve is a NIST curve.\n    *\n-   * <p>Returns null For NIST curves.\n+   * <p>Returns null if the curve used for this key is not a NIST curve.\n    */\n   @RestrictedApi(\n       explanation = \"Accessing parts of keys can produce unexpected incompatibilities, annotate the function with @AccessesPartialKey\",",
      "parent_sha": "b664c941d2aa2f2bf61d1905c8e7bb55572af9d7"
    }
  },
  {
    "oid": "69d976c4e52e1d2f56dad4fe16a180109bf97601",
    "message": "Simplify JwtFormat.validateHeader in Java.\n\nPiperOrigin-RevId: 390994865",
    "date": "2021-08-16T08:57:34Z",
    "url": "https://github.com/tink-crypto/tink/commit/69d976c4e52e1d2f56dad4fe16a180109bf97601",
    "details": {
      "sha": "e9b6e7b75571543daa19dc82319b69057b763724",
      "filename": "java_src/src/main/java/com/google/crypto/tink/jwt/JwtFormat.java",
      "status": "modified",
      "additions": 9,
      "deletions": 16,
      "changes": 25,
      "blob_url": "https://github.com/tink-crypto/tink/blob/69d976c4e52e1d2f56dad4fe16a180109bf97601/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FJwtFormat.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/69d976c4e52e1d2f56dad4fe16a180109bf97601/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FJwtFormat.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FJwtFormat.java?ref=69d976c4e52e1d2f56dad4fe16a180109bf97601",
      "patch": "@@ -115,23 +115,16 @@ static String createHeader(String algorithm, Optional<String> typeHeader, Option\n   static void validateHeader(String expectedAlgorithm, JsonObject parsedHeader)\n       throws InvalidAlgorithmParameterException, JwtInvalidException {\n     validateAlgorithm(expectedAlgorithm);\n-    if (!parsedHeader.has(JwtNames.HEADER_ALGORITHM)) {\n-      throw new JwtInvalidException(\"missing algorithm in header\");\n-    }\n-    for (String name : parsedHeader.keySet()) {\n-      if (name.equals(JwtNames.HEADER_ALGORITHM)) {\n-        String algorithm = getStringHeader(parsedHeader, JwtNames.HEADER_ALGORITHM);\n-        if (!algorithm.equals(expectedAlgorithm)) {\n-          throw new InvalidAlgorithmParameterException(\n-              String.format(\n-                  \"invalid algorithm; expected %s, got %s\", expectedAlgorithm, algorithm));\n-        }\n-      } else if (name.equals(JwtNames.HEADER_CRITICAL)) {\n-        throw new JwtInvalidException(\n-            \"all tokens with crit headers are rejected\");\n-      }\n-      // Ignore all other headers\n+    String algorithm = getStringHeader(parsedHeader, JwtNames.HEADER_ALGORITHM);\n+    if (!algorithm.equals(expectedAlgorithm)) {\n+      throw new InvalidAlgorithmParameterException(\n+          String.format(\n+              \"invalid algorithm; expected %s, got %s\", expectedAlgorithm, algorithm));\n+    }\n+    if (parsedHeader.has(JwtNames.HEADER_CRITICAL)) {\n+      throw new JwtInvalidException(\"all tokens with crit headers are rejected\");\n     }\n+    // Ignore all other headers\n   }\n \n   static Optional<String> getTypeHeader(JsonObject header) throws JwtInvalidException {",
      "parent_sha": "d582b5d0538a35bc81f0f0ef51998b3a481740d1"
    }
  },
  {
    "oid": "c437d71f2d13c92ce239b12c032afd7059bd1319",
    "message": "Add two faulty fake implementations:\n- one that sometimes may throw NullPointerException.\n- one that throws UnrecoverableKeyException for existing keys.\n\nBoth will be used to replace current keystore mocks.\n\nI also added the bug numbers for why these are tested.\n\nPiperOrigin-RevId: 501223837",
    "date": "2023-01-11T10:27:39Z",
    "url": "https://github.com/tink-crypto/tink/commit/c437d71f2d13c92ce239b12c032afd7059bd1319",
    "details": {
      "sha": "4349c27a8a3fb11ad73c7b1faec564e24f86c471",
      "filename": "java_src/src/main/java/com/google/crypto/tink/integration/android/internal/FakeAndroidKeystoreProvider.java",
      "status": "modified",
      "additions": 94,
      "deletions": 3,
      "changes": 97,
      "blob_url": "https://github.com/tink-crypto/tink/blob/c437d71f2d13c92ce239b12c032afd7059bd1319/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2Finternal%2FFakeAndroidKeystoreProvider.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/c437d71f2d13c92ce239b12c032afd7059bd1319/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2Finternal%2FFakeAndroidKeystoreProvider.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2Finternal%2FFakeAndroidKeystoreProvider.java?ref=c437d71f2d13c92ce239b12c032afd7059bd1319",
      "patch": "@@ -41,7 +41,7 @@\n import javax.crypto.spec.SecretKeySpec;\n \n /**\n- * A fake implementation of AndroidKeystore that provides all the function needed by Tink's android\n+ * Fake implementations of AndroidKeystore that provide all the function needed by Tink's android\n  * integration package.\n  */\n public final class FakeAndroidKeystoreProvider {\n@@ -221,8 +221,8 @@ private static class FakeProvider extends Provider {\n       FakeKeyStoreSpi.setKeysMapRef(keys);\n       FakeKeyGeneratorSpi.setKeysMapRef(keys);\n \n-      this.put(\"KeyStore.AndroidKeyStore\", FakeKeyStoreSpi.class.getName());\n-      this.put(\"KeyGenerator.AES\", FakeKeyGeneratorSpi.class.getName());\n+      put(\"KeyStore.AndroidKeyStore\", FakeKeyStoreSpi.class.getName());\n+      put(\"KeyGenerator.AES\", FakeKeyGeneratorSpi.class.getName());\n     }\n   }\n \n@@ -231,5 +231,96 @@ public static Provider newProvider() {\n     return new FakeProvider();\n   }\n \n+  /**\n+   * A fake KeyStoreSpi implementation that may raise a NullPointerException in engineContainsAlias.\n+   *\n+   * <p>This is added because of b/167402931.\n+   */\n+  public static class UnreliableFakeKeyStoreSpi\n+      extends FakeAndroidKeystoreProvider.FakeKeyStoreSpi {\n+\n+    public UnreliableFakeKeyStoreSpi() {}\n+\n+    public static int failuresInARow;\n+    public static int failuresLeft;\n+\n+    public static void setFailuresInARow(int failuresInARow) {\n+      UnreliableFakeKeyStoreSpi.failuresInARow = failuresInARow;\n+      failuresLeft = failuresInARow;\n+    }\n+\n+    @Override\n+    public boolean engineContainsAlias(String alias) {\n+      if (failuresLeft > 0) {\n+        failuresLeft = failuresLeft - 1;\n+        throw new NullPointerException(\"something went wrong\");\n+      }\n+      failuresLeft = failuresInARow;\n+      return keys.containsKey(alias);\n+    }\n+  }\n+\n+  @SuppressWarnings(\n+      \"deprecation\") // We need to use the old constructor to support older Java versions.\n+  private static class UnreliableFakeProvider extends Provider {\n+    UnreliableFakeProvider(int failuresInARow) {\n+      super(\"AndroidKeyStore\", 1.0, \"Fake AndroidKeyStore with a bad containsAlias implementation\");\n+\n+      HashMap<String, SecretKey> keys = new HashMap<>();\n+      FakeAndroidKeystoreProvider.FakeKeyStoreSpi.setKeysMapRef(keys);\n+      FakeAndroidKeystoreProvider.FakeKeyGeneratorSpi.setKeysMapRef(keys);\n+      UnreliableFakeKeyStoreSpi.setFailuresInARow(failuresInARow);\n+\n+      this.setProperty(\"KeyStore.AndroidKeyStore\", UnreliableFakeKeyStoreSpi.class.getName());\n+      this.setProperty(\n+          \"KeyGenerator.AES\", FakeAndroidKeystoreProvider.FakeKeyGeneratorSpi.class.getName());\n+    }\n+  }\n+\n+  /** Returns a new fake Provider for AndroidKeystore. */\n+  public static Provider newUnreliableProvider(int failuresInARow) {\n+    return new UnreliableFakeProvider(failuresInARow);\n+  }\n+\n+  /**\n+   * A partial fake implementation of KeyStoreSpi where engineGetKey always throws an exception.\n+   *\n+   * <p>This is added because of b/151893419.\n+   */\n+  public static class FakeKeyStoreSpiWithUnrecoverableKeys extends FakeKeyStoreSpi {\n+\n+    public FakeKeyStoreSpiWithUnrecoverableKeys() {}\n+\n+    @Override\n+    public Key engineGetKey(String keyId, char[] password)\n+        throws NoSuchAlgorithmException, UnrecoverableKeyException {\n+      Key key = super.engineGetKey(keyId, password);\n+      if (key == null) {\n+        return null;\n+      }\n+      throw new UnrecoverableKeyException(\"Failed to obtain information about key\");\n+    }\n+  }\n+\n+  @SuppressWarnings(\n+      \"deprecation\") // We need to use the old constructor to support older Java versions.\n+  private static class FakeProviderWithUnrecoverableKeys extends Provider {\n+    FakeProviderWithUnrecoverableKeys() {\n+      super(\"AndroidKeyStore\", 1.0, \"Fake AndroidKeyStore that returns null keys\");\n+\n+      HashMap<String, SecretKey> keys = new HashMap<>();\n+      FakeAndroidKeystoreProvider.FakeKeyStoreSpi.setKeysMapRef(keys);\n+      FakeAndroidKeystoreProvider.FakeKeyGeneratorSpi.setKeysMapRef(keys);\n+\n+      put(\"KeyStore.AndroidKeyStore\", FakeKeyStoreSpiWithUnrecoverableKeys.class.getName());\n+      put(\"KeyGenerator.AES\", FakeKeyGeneratorSpi.class.getName());\n+    }\n+  }\n+\n+  /** Returns a new fake Provider for AndroidKeystore. */\n+  public static Provider newProviderWithUnrecoverableKeys() {\n+    return new FakeProviderWithUnrecoverableKeys();\n+  }\n+\n   private FakeAndroidKeystoreProvider() {}\n }",
      "parent_sha": "34ce9c759ec11778338e0c77f25b9abb187686c7"
    }
  },
  {
    "oid": "07d4afb1cebdf01d67f5af13fd9cf63505a2c4f1",
    "message": "Refactor createKeysetKeyFromBuilderEntry.\n\n- Only call createKeysetKeyFromBuilderEntry when key is not null, and rename it.\n- Change order of parameters in createKeyFromParameters, and rename it.\n\nPiperOrigin-RevId: 610403944",
    "date": "2024-02-26T15:39:14Z",
    "url": "https://github.com/tink-crypto/tink/commit/07d4afb1cebdf01d67f5af13fd9cf63505a2c4f1",
    "details": {
      "sha": "f464cd17a285012fa9cdc6c34404e81466e63ce6",
      "filename": "java_src/src/main/java/com/google/crypto/tink/KeysetHandle.java",
      "status": "modified",
      "additions": 20,
      "deletions": 20,
      "changes": 40,
      "blob_url": "https://github.com/tink-crypto/tink/blob/07d4afb1cebdf01d67f5af13fd9cf63505a2c4f1/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/07d4afb1cebdf01d67f5af13fd9cf63505a2c4f1/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java?ref=07d4afb1cebdf01d67f5af13fd9cf63505a2c4f1",
      "patch": "@@ -312,9 +312,8 @@ private static int randomIdNotInSet(Set<Integer> ids) {\n       return id;\n     }\n \n-    private static Keyset.Key createKeyFromParameters(\n-        Parameters parameters, int id, KeyStatusType keyStatusType)\n-        throws GeneralSecurityException {\n+    private static Keyset.Key createNewKeysetKeyFromParameters(\n+        Parameters parameters, KeyStatus status, int id) throws GeneralSecurityException {\n       ProtoParametersSerialization serializedParameters;\n       if (parameters instanceof LegacyProtoParameters) {\n         serializedParameters = ((LegacyProtoParameters) parameters).getSerialization();\n@@ -326,7 +325,7 @@ private static Keyset.Key createKeyFromParameters(\n       KeyData keyData = Registry.newKeyData(serializedParameters.getKeyTemplate());\n       return Keyset.Key.newBuilder()\n           .setKeyId(id)\n-          .setStatus(keyStatusType)\n+          .setStatus(serializeStatus(status))\n           .setKeyData(keyData)\n           .setOutputPrefixType(serializedParameters.getKeyTemplate().getOutputPrefixType())\n           .build();\n@@ -347,22 +346,16 @@ private static int getNextIdFromBuilderEntry(\n       return id;\n     }\n \n-    private static Keyset.Key createKeysetKeyFromBuilderEntry(\n-        KeysetHandle.Builder.Entry builderEntry, int id) throws GeneralSecurityException {\n-      if (builderEntry.key == null) {\n-        return createKeyFromParameters(\n-            builderEntry.parameters, id, serializeStatus(builderEntry.getStatus()));\n-      } else {\n-        ProtoKeySerialization serializedKey =\n-            MutableSerializationRegistry.globalInstance()\n-                .serializeKey(\n-                    builderEntry.key, ProtoKeySerialization.class, InsecureSecretKeyAccess.get());\n-        @Nullable Integer idRequirement = serializedKey.getIdRequirementOrNull();\n-        if (idRequirement != null && idRequirement != id) {\n-          throw new GeneralSecurityException(\"Wrong ID set for key with ID requirement\");\n-        }\n-        return toKeysetKey(id, serializeStatus(builderEntry.getStatus()), serializedKey);\n+    private static Keyset.Key createKeysetKey(Key key, KeyStatus keyStatus, int id)\n+        throws GeneralSecurityException {\n+      ProtoKeySerialization serializedKey =\n+          MutableSerializationRegistry.globalInstance()\n+              .serializeKey(key, ProtoKeySerialization.class, InsecureSecretKeyAccess.get());\n+      @Nullable Integer idRequirement = serializedKey.getIdRequirementOrNull();\n+      if (idRequirement != null && idRequirement != id) {\n+        throw new GeneralSecurityException(\"Wrong ID set for key with ID requirement\");\n       }\n+      return toKeysetKey(id, serializeStatus(keyStatus), serializedKey);\n     }\n \n     /**\n@@ -409,7 +402,14 @@ public KeysetHandle build() throws GeneralSecurityException {\n         idsSoFar.add(id);\n \n         // Create proto key and add it to keysetBuilder.\n-        Keyset.Key keysetKey = createKeysetKeyFromBuilderEntry(builderEntry, id);\n+        Keyset.Key keysetKey;\n+        if (builderEntry.key != null) {\n+          keysetKey = createKeysetKey(builderEntry.key, builderEntry.keyStatus, id);\n+        } else {\n+          keysetKey =\n+              createNewKeysetKeyFromParameters(\n+                  builderEntry.parameters, builderEntry.getStatus(), id);\n+        }\n         keysetBuilder.addKey(keysetKey);\n         if (builderEntry.isPrimary) {\n           if (primaryId != null) {",
      "parent_sha": "507eee90c60d1f2a2dcc7d822e8d9736c55ac78b"
    }
  },
  {
    "oid": "00fd2aec3a6ec21c3fb39e420f9a0dd6072ffcd9",
    "message": "Remove \"deprecation under consideration marker for \"CleartextKeysetHandle#parseFrom\".\n\nPiperOrigin-RevId: 519653841",
    "date": "2023-03-27T08:51:57Z",
    "url": "https://github.com/tink-crypto/tink/commit/00fd2aec3a6ec21c3fb39e420f9a0dd6072ffcd9",
    "details": {
      "sha": "5afe499983cc378faacbc5072f2ced0378681e0f",
      "filename": "java_src/src/main/java/com/google/crypto/tink/CleartextKeysetHandle.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/tink-crypto/tink/blob/00fd2aec3a6ec21c3fb39e420f9a0dd6072ffcd9/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FCleartextKeysetHandle.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/00fd2aec3a6ec21c3fb39e420f9a0dd6072ffcd9/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FCleartextKeysetHandle.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FCleartextKeysetHandle.java?ref=00fd2aec3a6ec21c3fb39e420f9a0dd6072ffcd9",
      "patch": "@@ -39,10 +39,11 @@ public final class CleartextKeysetHandle {\n   /**\n    * @return a new {@link KeysetHandle} from {@code serialized} that is a serialized {@link Keyset}\n    * @throws GeneralSecurityException\n-   * @deprecated use {@link #read} instead\n+   * @deprecated Call {@code TinkProtoKeysetFormat.parseKeyset(serialized,\n+   *     InsecureSecretKeyAccess.get())} which has the same semantics.\n    */\n   @SuppressWarnings(\"UnusedException\")\n-  @Deprecated /* Deprecation under consideration */\n+  @Deprecated\n   public static final KeysetHandle parseFrom(final byte[] serialized)\n       throws GeneralSecurityException {\n     try {",
      "parent_sha": "e30f012ef152e42bab2d054fce71b70f822bc120"
    }
  },
  {
    "oid": "d5c0f23daf944898a49df4578224e76837908d12",
    "message": "Fix incorrect values in Javadoc for setTagSizeBytes().\n\nPiperOrigin-RevId: 586921891",
    "date": "2023-12-01T08:40:55Z",
    "url": "https://github.com/tink-crypto/tink/commit/d5c0f23daf944898a49df4578224e76837908d12",
    "details": {
      "sha": "6f4b69d916eae5395e6494ea01799f96cf8466a1",
      "filename": "java_src/src/main/java/com/google/crypto/tink/aead/AesGcmParameters.java",
      "status": "modified",
      "additions": 3,
      "deletions": 8,
      "changes": 11,
      "blob_url": "https://github.com/tink-crypto/tink/blob/d5c0f23daf944898a49df4578224e76837908d12/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Faead%2FAesGcmParameters.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/d5c0f23daf944898a49df4578224e76837908d12/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Faead%2FAesGcmParameters.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Faead%2FAesGcmParameters.java?ref=d5c0f23daf944898a49df4578224e76837908d12",
      "patch": "@@ -86,18 +86,13 @@ public Builder setIvSizeBytes(int ivSizeBytes) throws GeneralSecurityException {\n       this.ivSizeBytes = ivSizeBytes;\n       return this;\n     }\n-    /** Tag size must be one of the following five values: 128, 120, 112, 104 or 96 bytes */\n+    /** Tag size must be between 12 and 16 bytes. */\n     @CanIgnoreReturnValue\n     public Builder setTagSizeBytes(int tagSizeBytes) throws GeneralSecurityException {\n-      if (tagSizeBytes != 12\n-          && tagSizeBytes != 13\n-          && tagSizeBytes != 14\n-          && tagSizeBytes != 15\n-          && tagSizeBytes != 16) {\n+      if (tagSizeBytes < 12 || tagSizeBytes > 16) {\n         throw new GeneralSecurityException(\n             String.format(\n-                \"Invalid tag size in bytes %d; value must be one of the following: 12, 13, 14, 15\"\n-                    + \" or 16 bytes\",\n+                \"Invalid tag size in bytes %d; value must be between 12 and 16 bytes\",\n                 tagSizeBytes));\n       }\n       this.tagSizeBytes = tagSizeBytes;",
      "parent_sha": "a848cfdea1caf016bca9b5091636719aa19a201b"
    }
  },
  {
    "oid": "433a4a39f761ffbddf1d4e9a3ad9297cd444bcb9",
    "message": "Don't parse the proto key into a Key object if there builderEntry already has a key.\n\nAlso, do some renaming of helper functions.\n\nPiperOrigin-RevId: 610422190",
    "date": "2024-02-26T16:53:59Z",
    "url": "https://github.com/tink-crypto/tink/commit/433a4a39f761ffbddf1d4e9a3ad9297cd444bcb9",
    "details": {
      "sha": "b85a59084c0d9d8d24ad8873abf76a37e9e4054e",
      "filename": "java_src/src/main/java/com/google/crypto/tink/KeysetHandle.java",
      "status": "modified",
      "additions": 18,
      "deletions": 15,
      "changes": 33,
      "blob_url": "https://github.com/tink-crypto/tink/blob/433a4a39f761ffbddf1d4e9a3ad9297cd444bcb9/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/433a4a39f761ffbddf1d4e9a3ad9297cd444bcb9/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetHandle.java?ref=433a4a39f761ffbddf1d4e9a3ad9297cd444bcb9",
      "patch": "@@ -401,14 +401,28 @@ public KeysetHandle build() throws GeneralSecurityException {\n         }\n         idsSoFar.add(id);\n \n-        // Create proto key and add it to keysetBuilder.\n         Keyset.Key keysetKey;\n+        @Nullable KeysetHandle.Entry handleEntry;\n+\n         if (builderEntry.key != null) {\n+          handleEntry =\n+              new KeysetHandle.Entry(\n+                  builderEntry.key, builderEntry.keyStatus, id, builderEntry.isPrimary);\n           keysetKey = createKeysetKey(builderEntry.key, builderEntry.keyStatus, id);\n         } else {\n           keysetKey =\n-              createNewKeysetKeyFromParameters(\n-                  builderEntry.parameters, builderEntry.getStatus(), id);\n+              createNewKeysetKeyFromParameters(builderEntry.parameters, builderEntry.keyStatus, id);\n+          ProtoKeySerialization protoKeySerialization = toProtoKeySerialization(keysetKey);\n+          try {\n+            Key key =\n+                MutableSerializationRegistry.globalInstance()\n+                    .parseKeyWithLegacyFallback(\n+                        protoKeySerialization, InsecureSecretKeyAccess.get());\n+            handleEntry =\n+                new KeysetHandle.Entry(key, builderEntry.keyStatus, id, builderEntry.isPrimary);\n+          } catch (GeneralSecurityException e) {\n+            handleEntry = null;\n+          }\n         }\n         keysetBuilder.addKey(keysetKey);\n         if (builderEntry.isPrimary) {\n@@ -420,18 +434,7 @@ public KeysetHandle build() throws GeneralSecurityException {\n             throw new GeneralSecurityException(\"Primary key is not enabled\");\n           }\n         }\n-\n-        // Create KeysetHandle.Entry and add it to handleEntries.\n-        ProtoKeySerialization protoKeySerialization = toProtoKeySerialization(keysetKey);\n-        try {\n-          Key key =\n-              MutableSerializationRegistry.globalInstance()\n-                  .parseKeyWithLegacyFallback(protoKeySerialization, InsecureSecretKeyAccess.get());\n-          handleEntries.add(\n-              new KeysetHandle.Entry(key, builderEntry.keyStatus, id, builderEntry.isPrimary));\n-        } catch (GeneralSecurityException e) {\n-          handleEntries.add(null);\n-        }\n+        handleEntries.add(handleEntry);\n       }\n       if (primaryId == null) {\n         throw new GeneralSecurityException(\"No primary was set\");",
      "parent_sha": "b166f003fd0d8dbd1a1f71326b2243bed75b8e8b"
    }
  },
  {
    "oid": "633fe3e916bb709fe0dce608845c44a275baefbc",
    "message": "Rename KeyDeriverContainer to KeyDataDeriver.\n\nThe name \"Container\" is confusing, because it is normally used for collections of things.\n\nPiperOrigin-RevId: 544272609",
    "date": "2023-06-29T07:29:15Z",
    "url": "https://github.com/tink-crypto/tink/commit/633fe3e916bb709fe0dce608845c44a275baefbc",
    "details": {
      "sha": "96c856e639fd21175715704bdc901e34eb1bbd61",
      "filename": "java_src/src/main/java/com/google/crypto/tink/Registry.java",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/tink-crypto/tink/blob/633fe3e916bb709fe0dce608845c44a275baefbc/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistry.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/633fe3e916bb709fe0dce608845c44a275baefbc/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistry.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistry.java?ref=633fe3e916bb709fe0dce608845c44a275baefbc",
      "patch": "@@ -83,7 +83,7 @@ public final class Registry {\n   private static final AtomicReference<KeyManagerRegistry> keyManagerRegistry =\n       new AtomicReference<>(new KeyManagerRegistry());\n \n-  private static final ConcurrentMap<String, KeyDeriverContainer> keyDeriverMap =\n+  private static final ConcurrentMap<String, KeyDataDeriver> keyDeriverMap =\n       new ConcurrentHashMap<>(); // typeUrl -> deriver (created out of KeyTypeManager).\n \n   private static final ConcurrentMap<String, Boolean> newKeyAllowedMap =\n@@ -95,14 +95,14 @@ public final class Registry {\n   private static final ConcurrentMap<String, KeyTemplate> keyTemplateMap =\n       new ConcurrentHashMap<>(); // name -> KeyTemplate mapping\n \n-  private static interface KeyDeriverContainer {\n-    KeyData deriveKey(ByteString serializedKeyFormat, InputStream stream)\n+  private static interface KeyDataDeriver {\n+    KeyData deriveKeyData(ByteString serializedKeyFormat, InputStream stream)\n         throws GeneralSecurityException;\n   }\n \n-  private static <KeyProtoT extends MessageLite> KeyDeriverContainer createDeriverFor(\n+  private static <KeyProtoT extends MessageLite> KeyDataDeriver createDeriverFor(\n       final KeyTypeManager<KeyProtoT> keyManager) {\n-    return new KeyDeriverContainer() {\n+    return new KeyDataDeriver() {\n       private <KeyFormatProtoT extends MessageLite> MessageLite deriveKeyWithFactory(\n           ByteString serializedKeyFormat,\n           InputStream stream,\n@@ -119,7 +119,7 @@ private <KeyFormatProtoT extends MessageLite> MessageLite deriveKeyWithFactory(\n       }\n \n       @Override\n-      public KeyData deriveKey(ByteString serializedKeyFormat, InputStream stream)\n+      public KeyData deriveKeyData(ByteString serializedKeyFormat, InputStream stream)\n           throws GeneralSecurityException {\n         KeyTypeManager.KeyFactory<?, KeyProtoT> keyFactory = keyManager.keyFactory();\n         MessageLite keyValue = deriveKeyWithFactory(serializedKeyFormat, stream, keyFactory);\n@@ -604,8 +604,8 @@ static synchronized KeyData deriveKey(\n       throw new GeneralSecurityException(\n           \"No keymanager registered or key manager cannot derive keys for \" + typeUrl);\n     }\n-    KeyDeriverContainer deriver = keyDeriverMap.get(typeUrl);\n-    return deriver.deriveKey(keyTemplate.getValue(), randomStream);\n+    KeyDataDeriver deriver = keyDeriverMap.get(typeUrl);\n+    return deriver.deriveKeyData(keyTemplate.getValue(), randomStream);\n   }\n \n   /**",
      "parent_sha": "508a4c861b850c5da7fb94fd38508c225e1e32e7"
    }
  },
  {
    "oid": "2a229eb47b6bc167c1dfa79e4cbec2bf78842762",
    "message": "Add Java tests for Registry.newKeyData\n\nPiperOrigin-RevId: 333727490",
    "date": "2020-09-25T14:16:14Z",
    "url": "https://github.com/tink-crypto/tink/commit/2a229eb47b6bc167c1dfa79e4cbec2bf78842762",
    "details": {
      "sha": "d1c5a5a014642b56912391aadee82cebaaf3e25c",
      "filename": "java_src/src/test/java/com/google/crypto/tink/RegistryTest.java",
      "status": "modified",
      "additions": 51,
      "deletions": 3,
      "changes": 54,
      "blob_url": "https://github.com/tink-crypto/tink/blob/2a229eb47b6bc167c1dfa79e4cbec2bf78842762/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistryTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/2a229eb47b6bc167c1dfa79e4cbec2bf78842762/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistryTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistryTest.java?ref=2a229eb47b6bc167c1dfa79e4cbec2bf78842762",
      "patch": "@@ -93,8 +93,11 @@ public MessageLite newKey(MessageLite template) throws GeneralSecurityException\n     }\n \n     @Override\n-    public KeyData newKeyData(ByteString serialized) throws GeneralSecurityException {\n-      throw new GeneralSecurityException(\"Not Implemented\");\n+    public KeyData newKeyData(ByteString serializedKeyFormat) throws GeneralSecurityException {\n+      return KeyData.newBuilder()\n+            .setTypeUrl(typeUrl)\n+            .setValue(serializedKeyFormat)\n+            .build();\n     }\n \n     @Override\n@@ -784,6 +787,51 @@ public void testGetPrimitives_KeysetWithKeyForWrongPrimitive_shouldThrowExceptio\n     }\n   }\n \n+  @Test\n+  public void testNewKeyData_registeredTypeUrl_returnsCustomAeadKeyManagerNewKeyData()\n+      throws Exception {\n+    String typeUrl = \"testNewKeyDataTypeUrl\";\n+    CustomAeadKeyManager km = new CustomAeadKeyManager(typeUrl);\n+    ByteString keyformat = ByteString.copyFromUtf8(\"testNewKeyDataKeyFormat\");\n+    Registry.registerKeyManager(km);\n+    KeyTemplate template = KeyTemplate.newBuilder()\n+                           .setValue(keyformat)\n+                           .setTypeUrl(typeUrl)\n+                           .setOutputPrefixType(OutputPrefixType.TINK)\n+                           .build();\n+\n+    assertThat(Registry.newKeyData(template)).isEqualTo(km.newKeyData(keyformat));\n+  }\n+\n+  @Test\n+  public void testNewKeyData_registeredTypeUrlNewKeyAllowedFalse_throwsException()\n+      throws Exception {\n+    String typeUrl = \"testNewKeyDataTypeUrl\";\n+    CustomAeadKeyManager km = new CustomAeadKeyManager(typeUrl);\n+    ByteString keyformat = ByteString.copyFromUtf8(\"testNewKeyDataKeyFormat\");\n+    Registry.registerKeyManager(km, false);\n+    KeyTemplate template = KeyTemplate.newBuilder()\n+                           .setValue(keyformat)\n+                           .setTypeUrl(typeUrl)\n+                           .setOutputPrefixType(OutputPrefixType.TINK)\n+                           .build();\n+\n+    assertThrows(GeneralSecurityException.class, () -> Registry.newKeyData(template));\n+  }\n+\n+  @Test\n+  public void testNewKeyData_unregisteredTypeUrl_throwsException() throws Exception {\n+    String typeUrl = \"testNewKeyDataTypeUrl\";\n+    ByteString keyformat = ByteString.copyFromUtf8(\"testNewKeyDataKeyFormat\");\n+    KeyTemplate template = KeyTemplate.newBuilder()\n+                           .setValue(keyformat)\n+                           .setTypeUrl(typeUrl)\n+                           .setOutputPrefixType(OutputPrefixType.TINK)\n+                           .build();\n+\n+    assertThrows(GeneralSecurityException.class, () -> Registry.newKeyData(template));\n+  }\n+\n   /** Implementation of a KeyTypeManager for testing. */\n   private static class TestKeyTypeManager extends KeyTypeManager<AesGcmKey> {\n     public TestKeyTypeManager() {\n@@ -991,7 +1039,7 @@ public void testRegisterKeyTypeManager_BeforeKeyManager_throws() throws Exceptio\n   }\n \n   @Test\n-  public void parseKeyData_succeeds() throws Exception {\n+  public void testParseKeyData_succeeds() throws Exception {\n     Registry.reset();\n     Registry.registerKeyManager(new TestKeyTypeManager(), true);\n     AesGcmKey key =",
      "parent_sha": "2f8a3476e594e9e9827846e26133847709e0368e"
    }
  },
  {
    "oid": "20081067050b8556f8c9a118e1210746b9a6d13e",
    "message": "Remove erroneous character from AesCtrHmacAeadParameters comment.\n\nPiperOrigin-RevId: 529348106",
    "date": "2023-05-04T09:28:40Z",
    "url": "https://github.com/tink-crypto/tink/commit/20081067050b8556f8c9a118e1210746b9a6d13e",
    "details": {
      "sha": "24a7681f645a381ef59d6a1dc794876a2a4fa7ab",
      "filename": "java_src/src/main/java/com/google/crypto/tink/aead/AesCtrHmacAeadParameters.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/tink-crypto/tink/blob/20081067050b8556f8c9a118e1210746b9a6d13e/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Faead%2FAesCtrHmacAeadParameters.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/20081067050b8556f8c9a118e1210746b9a6d13e/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Faead%2FAesCtrHmacAeadParameters.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Faead%2FAesCtrHmacAeadParameters.java?ref=20081067050b8556f8c9a118e1210746b9a6d13e",
      "patch": "@@ -23,7 +23,7 @@\n import java.util.Objects;\n import javax.annotation.Nullable;\n \n-/** Describes the parameters of an {@link AesCtrHmacAead\u0192Key}. */\n+/** Describes the parameters of an {@link AesCtrHmacAeadKey}. */\n public final class AesCtrHmacAeadParameters extends AeadParameters {\n   private static final int PREFIX_SIZE_IN_BYTES = 5;\n   /**",
      "parent_sha": "227edac8bfec5a177323ee5bbd48fb46a978fc1e"
    }
  },
  {
    "oid": "2656c0f2a95e710913bf7930e7cbca943f4ad074",
    "message": "Add additional tests to check that EngineFactory uses the correct provider in FIPS mode.\n\nPiperOrigin-RevId: 363420098",
    "date": "2021-03-17T15:03:25Z",
    "url": "https://github.com/tink-crypto/tink/commit/2656c0f2a95e710913bf7930e7cbca943f4ad074",
    "details": {
      "sha": "d8e2d8c34f5f5158a1901f21f9183c83fc1083ef",
      "filename": "java_src/src/test/java/com/google/crypto/tink/subtle/EngineFactoryFipsTest.java",
      "status": "modified",
      "additions": 56,
      "deletions": 7,
      "changes": 63,
      "blob_url": "https://github.com/tink-crypto/tink/blob/2656c0f2a95e710913bf7930e7cbca943f4ad074/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FEngineFactoryFipsTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/2656c0f2a95e710913bf7930e7cbca943f4ad074/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FEngineFactoryFipsTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FEngineFactoryFipsTest.java?ref=2656c0f2a95e710913bf7930e7cbca943f4ad074",
      "patch": "@@ -20,7 +20,6 @@\n import java.security.GeneralSecurityException;\n import java.security.Provider;\n import java.security.Security;\n-import javax.crypto.Cipher;\n import org.conscrypt.Conscrypt;\n import org.junit.Assume;\n import org.junit.Before;\n@@ -36,21 +35,71 @@ public final class EngineFactoryFipsTest {\n   public void setUp() throws Exception {\n     // All tests here require that Tink is build in FIPS-mode.\n     Assume.assumeTrue(TinkFips.useOnlyFips());\n+\n+    // Register conscrypt\n+    Conscrypt.checkAvailability();\n   }\n \n   @Test\n-  public void testConscryptUsedAsProvider() throws Exception {\n-    Conscrypt.checkAvailability();\n+  public void testConscryptUsedAsProviderForCiphers() throws Exception {\n+    Provider p = Conscrypt.newProvider();\n+    Security.addProvider(p);\n+    String conscryptName = p.getName();\n+\n+    assertThat(EngineFactory.CIPHER.getInstance(\"AES/GCM/NoPadding\").getProvider().getName())\n+        .isEqualTo(conscryptName);\n+    assertThat(EngineFactory.CIPHER.getInstance(\"AES/CTR/NoPadding\").getProvider().getName())\n+        .isEqualTo(conscryptName);\n+  }\n+\n+  @Test\n+  public void testConscryptUsedAsProviderForMac() throws Exception {\n     Provider p = Conscrypt.newProvider();\n     Security.addProvider(p);\n-    Cipher c = EngineFactory.CIPHER.getInstance(\"AES/GCM/NoPadding\");\n-    assertThat(c.getProvider().getName()).isEqualTo(p.getName());\n+    String conscryptName = p.getName();\n+\n+    assertThat(EngineFactory.MAC.getInstance(\"HMACSHA1\").getProvider().getName())\n+        .isEqualTo(conscryptName);\n+    assertThat(EngineFactory.MAC.getInstance(\"HMACSHA224\").getProvider().getName())\n+        .isEqualTo(conscryptName);\n+    assertThat(EngineFactory.MAC.getInstance(\"HMACSHA256\").getProvider().getName())\n+        .isEqualTo(conscryptName);\n+    assertThat(EngineFactory.MAC.getInstance(\"HMACSHA384\").getProvider().getName())\n+        .isEqualTo(conscryptName);\n+    assertThat(EngineFactory.MAC.getInstance(\"HMACSHA512\").getProvider().getName())\n+        .isEqualTo(conscryptName);\n+  }\n+\n+  @Test\n+  public void testConscryptUsedAsProviderForSigner() throws Exception {\n+    Provider p = Conscrypt.newProvider();\n+    Security.addProvider(p);\n+    String conscryptName = p.getName();\n+\n+    assertThat(EngineFactory.SIGNATURE.getInstance(\"SHA256withRSA\").getProvider().getName())\n+        .isEqualTo(conscryptName);\n+    assertThat(EngineFactory.SIGNATURE.getInstance(\"SHA384withRSA\").getProvider().getName())\n+        .isEqualTo(conscryptName);\n+    assertThat(EngineFactory.SIGNATURE.getInstance(\"SHA512withRSA\").getProvider().getName())\n+        .isEqualTo(conscryptName);\n+    assertThat(EngineFactory.SIGNATURE.getInstance(\"SHA256withRSAandMGF1\").getProvider().getName())\n+        .isEqualTo(conscryptName);\n+    assertThat(EngineFactory.SIGNATURE.getInstance(\"SHA384withRSAandMGF1\").getProvider().getName())\n+        .isEqualTo(conscryptName);\n+    assertThat(EngineFactory.SIGNATURE.getInstance(\"SHA512withRSAandMGF1\").getProvider().getName())\n+        .isEqualTo(conscryptName);\n+    assertThat(EngineFactory.SIGNATURE.getInstance(\"SHA256withECDSA\").getProvider().getName())\n+        .isEqualTo(conscryptName);\n+    assertThat(EngineFactory.SIGNATURE.getInstance(\"SHA384withECDSA\").getProvider().getName())\n+        .isEqualTo(conscryptName);\n+    assertThat(EngineFactory.SIGNATURE.getInstance(\"SHA512withECDSA\").getProvider().getName())\n+        .isEqualTo(conscryptName);\n   }\n \n   @Test\n   public void testNoFallback() throws Exception {\n-    Conscrypt.checkAvailability();\n-    Security.addProvider(Conscrypt.newProvider());\n+    Provider p = Conscrypt.newProvider();\n+    Security.addProvider(p);\n \n     // Conscrypt does not provide \"AES\", so this must fail and not use another provider.\n     assertThrows(GeneralSecurityException.class, () -> EngineFactory.CIPHER.getInstance(\"AES\"));",
      "parent_sha": "6dac77376fde8b3bd1f1860fe75816f9e5192bce"
    }
  },
  {
    "oid": "99447e5bd48fc93d38b764b08d1baefd8f563d06",
    "message": "Inline \"setPayload\" in RawJwt.\n\nPiperOrigin-RevId: 358768899",
    "date": "2021-02-22T09:35:53Z",
    "url": "https://github.com/tink-crypto/tink/commit/99447e5bd48fc93d38b764b08d1baefd8f563d06",
    "details": {
      "sha": "1771bec41951a020743653687f0cf20d9c64363b",
      "filename": "java_src/src/main/java/com/google/crypto/tink/jwt/RawJwt.java",
      "status": "modified",
      "additions": 24,
      "deletions": 21,
      "changes": 45,
      "blob_url": "https://github.com/tink-crypto/tink/blob/99447e5bd48fc93d38b764b08d1baefd8f563d06/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FRawJwt.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/99447e5bd48fc93d38b764b08d1baefd8f563d06/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FRawJwt.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FRawJwt.java?ref=99447e5bd48fc93d38b764b08d1baefd8f563d06",
      "patch": "@@ -16,7 +16,6 @@\n \n import com.google.errorprone.annotations.Immutable;\n import com.google.gson.JsonArray;\n-import com.google.gson.JsonElement;\n import com.google.gson.JsonNull;\n import com.google.gson.JsonObject;\n import com.google.gson.JsonParseException;\n@@ -113,19 +112,14 @@ public Builder() {\n       payload = new JsonObject();\n     }\n \n-    private Builder setPayload(String name, JsonElement value) {\n-      payload.add(name, value);\n-      return this;\n-    }\n-\n-\n     /**\n      * Sets the issuer claim that identifies the principal that issued the JWT.\n      *\n      * <p>https://tools.ietf.org/html/rfc7519#section-4.1.1\n      */\n     public Builder setIssuer(String value) {\n-      return setPayload(JwtNames.CLAIM_ISSUER, new JsonPrimitive(value));\n+      payload.add(JwtNames.CLAIM_ISSUER, new JsonPrimitive(value));\n+      return this;\n     }\n \n     /**\n@@ -134,7 +128,8 @@ public Builder setIssuer(String value) {\n      * <p>https://tools.ietf.org/html/rfc7519#section-4.1.2\n      */\n     public Builder setSubject(String value) {\n-      return setPayload(JwtNames.CLAIM_SUBJECT, new JsonPrimitive(value));\n+      payload.add(JwtNames.CLAIM_SUBJECT, new JsonPrimitive(value));\n+      return this;\n     }\n \n     /**\n@@ -151,7 +146,8 @@ public Builder addAudience(String value) {\n         audiences = payload.get(JwtNames.CLAIM_AUDIENCE).getAsJsonArray();\n       }\n       audiences.add(value);\n-      return setPayload(JwtNames.CLAIM_AUDIENCE, audiences);\n+      payload.add(JwtNames.CLAIM_AUDIENCE, audiences);\n+      return this;\n     }\n \n     /**\n@@ -160,7 +156,8 @@ public Builder addAudience(String value) {\n      * <p>https://tools.ietf.org/html/rfc7519#section-4.1.7\n      */\n     public Builder setJwtId(String value) {\n-      return setPayload(JwtNames.CLAIM_JWT_ID, new JsonPrimitive(value));\n+      payload.add(JwtNames.CLAIM_JWT_ID, new JsonPrimitive(value));\n+      return this;\n     }\n \n     /**\n@@ -174,7 +171,8 @@ public Builder setJwtId(String value) {\n      * <p>https://tools.ietf.org/html/rfc7519#section-4.1.4\n      */\n     public Builder setExpiration(Instant value) {\n-      return setPayload(JwtNames.CLAIM_EXPIRATION, new JsonPrimitive(value.getEpochSecond()));\n+      payload.add(JwtNames.CLAIM_EXPIRATION, new JsonPrimitive(value.getEpochSecond()));\n+      return this;\n     }\n \n     /**\n@@ -188,7 +186,8 @@ public Builder setExpiration(Instant value) {\n      * <p>https://tools.ietf.org/html/rfc7519#section-4.1.5\n      */\n     public Builder setNotBefore(Instant value) {\n-      return setPayload(JwtNames.CLAIM_NOT_BEFORE, new JsonPrimitive(value.getEpochSecond()));\n+      payload.add(JwtNames.CLAIM_NOT_BEFORE, new JsonPrimitive(value.getEpochSecond()));\n+      return this;\n     }\n \n     /**\n@@ -201,25 +200,29 @@ public Builder setNotBefore(Instant value) {\n      * <p>https://tools.ietf.org/html/rfc7519#section-4.1.6\n      */\n     public Builder setIssuedAt(Instant value) {\n-      return setPayload(JwtNames.CLAIM_ISSUED_AT, new JsonPrimitive(value.getEpochSecond()));\n+      payload.add(JwtNames.CLAIM_ISSUED_AT, new JsonPrimitive(value.getEpochSecond()));\n+      return this;\n     }\n \n     /** Adds a custom claim of type {@code boolean} to the JWT. */\n     public Builder addBooleanClaim(String name, boolean value) {\n       JwtNames.validate(name);\n-      return setPayload(name, new JsonPrimitive(value));\n+      payload.add(name, new JsonPrimitive(value));\n+      return this;\n     }\n \n     /** Adds a custom claim of type {@code double} to the JWT. */\n     public Builder addNumberClaim(String name, double value) {\n       JwtNames.validate(name);\n-      return setPayload(name, new JsonPrimitive(value));\n+      payload.add(name, new JsonPrimitive(value));\n+      return this;\n     }\n \n     /** Adds a custom claim of type {@code String} to the JWT. */\n     public Builder addStringClaim(String name, String value) {\n       JwtNames.validate(name);\n-      return setPayload(name, new JsonPrimitive(value));\n+      payload.add(name, new JsonPrimitive(value));\n+      return this;\n     }\n \n     /** Adds a custom claim with value null. */\n@@ -234,23 +237,23 @@ public Builder addJsonObjectClaim(String name, String encodedJsonObject)\n         throws JwtInvalidException {\n       JwtNames.validate(name);\n       try {\n-        JsonObject jsonObject = JsonParser.parseString(encodedJsonObject).getAsJsonObject();\n-        return setPayload(name, jsonObject);\n+        payload.add(name, JsonParser.parseString(encodedJsonObject).getAsJsonObject());\n       } catch (JsonParseException | IllegalStateException ex) {\n         throw new JwtInvalidException(\"Invalid JSON Object: \" + ex.getMessage());\n       }\n+      return this;\n     }\n \n     /** Adds a custom claim encoded in a JSON {@code String} to the JWT. */\n     public Builder addJsonArrayClaim(String name, String encodedJsonArray)\n         throws JwtInvalidException {\n       JwtNames.validate(name);\n       try {\n-        JsonArray jsonArray = JsonParser.parseString(encodedJsonArray).getAsJsonArray();\n-        return setPayload(name, jsonArray);\n+        payload.add(name, JsonParser.parseString(encodedJsonArray).getAsJsonArray());\n       } catch (JsonParseException | IllegalStateException ex) {\n         throw new JwtInvalidException(\"Invalid JSON Array: \" + ex.getMessage());\n       }\n+      return this;\n     }\n \n     public RawJwt build() {",
      "parent_sha": "035a0a05af471317be2f5056fb3bedb71e27ddc0"
    }
  },
  {
    "oid": "43522de8f0348f8d87b4ed89f42f77d147d2524e",
    "message": "Make RawJwt.getJsonPayload() public.\n\nPiperOrigin-RevId: 531103273",
    "date": "2023-05-11T05:45:04Z",
    "url": "https://github.com/tink-crypto/tink/commit/43522de8f0348f8d87b4ed89f42f77d147d2524e",
    "details": {
      "sha": "9c2fe941c9414421e8a956c1a64c89529605b091",
      "filename": "java_src/src/main/java/com/google/crypto/tink/jwt/RawJwt.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/tink-crypto/tink/blob/43522de8f0348f8d87b4ed89f42f77d147d2524e/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FRawJwt.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/43522de8f0348f8d87b4ed89f42f77d147d2524e/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FRawJwt.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fjwt%2FRawJwt.java?ref=43522de8f0348f8d87b4ed89f42f77d147d2524e",
      "patch": "@@ -413,7 +413,7 @@ public RawJwt build() {\n     }\n   }\n \n-  String getJsonPayload() {\n+  public String getJsonPayload() {\n     return payload.toString();\n   }\n ",
      "parent_sha": "ad2d6d014fe1cdb0cbbb0cf065baf084bce3351a"
    }
  },
  {
    "oid": "6c520f4caa105d4ac95dd339a085dc816335b82f",
    "message": "Fix lint errors in StreamingAeadDecryptingStream.\n\nPiperOrigin-RevId: 329930364",
    "date": "2020-09-03T16:10:37Z",
    "url": "https://github.com/tink-crypto/tink/commit/6c520f4caa105d4ac95dd339a085dc816335b82f",
    "details": {
      "sha": "3599b7a97c164b09e9ea1fb8ca6d8c7ca982065d",
      "filename": "java_src/src/main/java/com/google/crypto/tink/subtle/StreamingAeadDecryptingStream.java",
      "status": "modified",
      "additions": 10,
      "deletions": 8,
      "changes": 18,
      "blob_url": "https://github.com/tink-crypto/tink/blob/6c520f4caa105d4ac95dd339a085dc816335b82f/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FStreamingAeadDecryptingStream.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/6c520f4caa105d4ac95dd339a085dc816335b82f/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FStreamingAeadDecryptingStream.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsubtle%2FStreamingAeadDecryptingStream.java?ref=6c520f4caa105d4ac95dd339a085dc816335b82f",
      "patch": "@@ -16,6 +16,8 @@\n \n package com.google.crypto.tink.subtle;\n \n+import static java.lang.Math.min;\n+\n import java.io.FilterInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n@@ -44,17 +46,17 @@ class StreamingAeadDecryptingStream extends FilterInputStream {\n    * necessary to read a segment plus one more byte to decrypt a segment, since the last segment of\n    * a ciphertext is encrypted differently.\n    */\n-  private ByteBuffer ciphertextSegment;\n+  private final ByteBuffer ciphertextSegment;\n \n   /**\n    * A buffer containing a plaintext segment. The bytes in the range plaintexSegment.position() ..\n    * plaintextSegment.limit() - 1 are plaintext that have been decrypted but not yet read out of\n    * AesGcmInputStream.\n    */\n-  private ByteBuffer plaintextSegment;\n+  private final ByteBuffer plaintextSegment;\n \n   /* Header information */\n-  private int headerLength;\n+  private final int headerLength;\n   private boolean headerRead;\n \n   /* Indicates whether the end of this InputStream has been reached. */\n@@ -67,7 +69,7 @@ class StreamingAeadDecryptingStream extends FilterInputStream {\n   private boolean decryptionErrorOccured;\n \n   /** The additional data that is authenticated with the ciphertext. */\n-  private byte[] aad;\n+  private final byte[] aad;\n \n   /** The number of the current segment of ciphertext buffered in ciphertexSegment. */\n   private int segmentNr;\n@@ -228,7 +230,7 @@ public synchronized int read(byte[] dst, int offset, int length) throws IOExcept\n         }\n         loadSegment();\n       }\n-      int sliceSize = java.lang.Math.min(plaintextSegment.remaining(), length - bytesRead);\n+      int sliceSize = min(plaintextSegment.remaining(), length - bytesRead);\n       plaintextSegment.get(dst, bytesRead + offset, sliceSize);\n       bytesRead += sliceSize;\n     }\n@@ -269,7 +271,7 @@ public boolean markSupported() {\n    * stream is non-blocking and not enough bytes are available or when the stream reaches the end of\n    * the stream.\n    *\n-   * @throws IOException when an exception occurs while reading from @code{in} or when the\n+   * @throws IOException when an exception occurs while reading from {@code in} or when the\n    *     ciphertext is corrupt. Currently all corrupt ciphertext will be detected. However this\n    *     behaviour may change.\n    */\n@@ -280,10 +282,10 @@ public long skip(long n) throws IOException {\n     if (n <= 0) {\n       return 0;\n     }\n-    int size = (int) Math.min(maxSkipBufferSize, remaining);\n+    int size = (int) min(maxSkipBufferSize, remaining);\n     byte[] skipBuffer = new byte[size];\n     while (remaining > 0) {\n-      int bytesRead = read(skipBuffer, 0, (int) Math.min(size, remaining));\n+      int bytesRead = read(skipBuffer, 0, (int) min(size, remaining));\n       if (bytesRead <= 0) {\n         break;\n       }",
      "parent_sha": "4fc49b955211a77bb9b816c08c90189710dba82b"
    }
  },
  {
    "oid": "ce18ae8f8813655483d6ff7ae468b0c814c6078b",
    "message": "Deprecate DeterministicAeadKeyTemplates.\n\nPiperOrigin-RevId: 537844226",
    "date": "2023-06-05T12:29:44Z",
    "url": "https://github.com/tink-crypto/tink/commit/ce18ae8f8813655483d6ff7ae468b0c814c6078b",
    "details": {
      "sha": "28f992b9abc5059ab2568bdc143edd71b40716a6",
      "filename": "java_src/src/main/java/com/google/crypto/tink/daead/DeterministicAeadKeyTemplates.java",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/tink-crypto/tink/blob/ce18ae8f8813655483d6ff7ae468b0c814c6078b/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fdaead%2FDeterministicAeadKeyTemplates.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/ce18ae8f8813655483d6ff7ae468b0c814c6078b/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fdaead%2FDeterministicAeadKeyTemplates.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fdaead%2FDeterministicAeadKeyTemplates.java?ref=ce18ae8f8813655483d6ff7ae468b0c814c6078b",
      "patch": "@@ -38,9 +38,8 @@\n  * <p>Instead, we recommend to use {@code KeysetHandle.generateEntryFromParametersName} or {@code\n  * KeysetHandle.generateEntryFromParameters}.\n  *\n- * One can use these templates\n- * to generate new {@code Keyset} with {@code KeysetHandle}. To generate a new keyset that contains\n- * a single {@code AesSivKey}, one can do:\n+ * <p>One can use these templates to generate new {@code Keyset} with {@code KeysetHandle}. To\n+ * generate a new keyset that contains a single {@code AesSivKey}, one can do:\n  *\n  * <pre>\n  *   Config.register(DeterministicAeadConfig.TINK_1_1_0);\n@@ -49,7 +48,9 @@\n  * </pre>\n  *\n  * @since 1.1.0\n+ * @deprecated Use {@link PredefinedDeterministicAeadParameters} instead.\n  */\n+@Deprecated\n public final class DeterministicAeadKeyTemplates {\n   /** A {@code KeyTemplate} that generates new instances of {@code AesSivKey} with a 64-byte key. */\n   public static final KeyTemplate AES256_SIV = createAesSivKeyTemplate(64);",
      "parent_sha": "4ef8b10bd2d725943e8306dc9f515989876fdec7"
    }
  },
  {
    "oid": "d23b9b2734aeecc9125e2e1db166af1c64383fac",
    "message": "Avoid more KeyTemplate in KeysetManagerTest.\n\nPiperOrigin-RevId: 542182909",
    "date": "2023-06-21T08:41:48Z",
    "url": "https://github.com/tink-crypto/tink/commit/d23b9b2734aeecc9125e2e1db166af1c64383fac",
    "details": {
      "sha": "6e795b683e3258ba1f260ae69a34c90cb1a79f67",
      "filename": "java_src/src/test/java/com/google/crypto/tink/KeysetManagerTest.java",
      "status": "modified",
      "additions": 17,
      "deletions": 42,
      "changes": 59,
      "blob_url": "https://github.com/tink-crypto/tink/blob/d23b9b2734aeecc9125e2e1db166af1c64383fac/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetManagerTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/d23b9b2734aeecc9125e2e1db166af1c64383fac/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetManagerTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FKeysetManagerTest.java?ref=d23b9b2734aeecc9125e2e1db166af1c64383fac",
      "patch": "@@ -25,8 +25,6 @@\n import com.google.crypto.tink.aead.AesGcmKeyManager;\n import com.google.crypto.tink.config.TinkConfig;\n import com.google.crypto.tink.mac.PredefinedMacParameters;\n-import com.google.crypto.tink.proto.AesGcmKey;\n-import com.google.crypto.tink.proto.AesGcmKeyFormat;\n import com.google.crypto.tink.proto.KeyStatusType;\n import com.google.crypto.tink.proto.Keyset;\n import com.google.crypto.tink.proto.Keyset.Key;\n@@ -818,20 +816,12 @@ public void addKeyHandleWithKeyAccess_newKeyset_shouldAddKey() throws Exception\n     keysetManager = keysetManager.add(keyHandle, keyAccess);\n \n     KeysetHandle keysetHandle = keysetManager.getKeysetHandle();\n-    Keyset keyset = keysetHandle.getKeyset();\n-    expect.that(keyset.getKeyCount()).isEqualTo(1);\n-    Keyset.Key key = keyset.getKey(0);\n-    expect.that(key.getStatus()).isEqualTo(KeyStatusType.ENABLED);\n-    expect.that(key.getOutputPrefixType()).isEqualTo(OutputPrefixType.TINK);\n-    expect.that(key.hasKeyData()).isTrue();\n-    expect.that(key.getKeyData().getTypeUrl()).isEqualTo(keyTemplate.getTypeUrl());\n-    AesGcmKeyFormat aesGcmKeyFormat =\n-        AesGcmKeyFormat.parseFrom(keyTemplate.getValue(), ExtensionRegistryLite.getEmptyRegistry());\n-    AesGcmKey aesGcmKey =\n-        AesGcmKey.parseFrom(key.getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());\n-    expect.that(aesGcmKey.getKeyValue().size()).isEqualTo(aesGcmKeyFormat.getKeySize());\n-    // No primary key because add doesn't automatically promote the new key to primary.\n-    assertThrows(GeneralSecurityException.class, () -> keysetHandle.getPrimitive(Aead.class));\n+    expect.that(keysetHandle.size()).isEqualTo(1);\n+    expect.that(keysetHandle.getAt(0).getStatus()).isEqualTo(KeyStatus.ENABLED);\n+    expect.that(keysetHandle.getAt(0).isPrimary()).isFalse();\n+    expect\n+        .that(keysetHandle.getAt(0).getKey().getParameters())\n+        .isEqualTo(keyTemplate.toParameters());\n   }\n \n   @Test\n@@ -848,32 +838,17 @@ public void addKeyHandleWithKeyAccess_existingKeyset_shouldAddKey() throws Excep\n     keysetManager = keysetManager.add(keyHandle, keyAccess);\n \n     KeysetHandle keysetHandle = keysetManager.getKeysetHandle();\n-    Keyset keyset = keysetHandle.getKeyset();\n-    expect.that(keyset.getKeyCount()).isEqualTo(2);\n-    Keyset.Key key1 = keyset.getKey(0);\n-    expect.that(key1.getStatus()).isEqualTo(KeyStatusType.ENABLED);\n-    expect.that(key1.getOutputPrefixType()).isEqualTo(OutputPrefixType.TINK);\n-    expect.that(key1.hasKeyData()).isTrue();\n-    expect.that(key1.getKeyData().getTypeUrl()).isEqualTo(keyTemplate1.getTypeUrl());\n-    AesGcmKeyFormat aesGcmKeyFormat1 =\n-        AesGcmKeyFormat.parseFrom(\n-            keyTemplate1.getValue(), ExtensionRegistryLite.getEmptyRegistry());\n-    AesGcmKey aesGcmKey1 =\n-        AesGcmKey.parseFrom(key1.getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());\n-    expect.that(aesGcmKey1.getKeyValue().size()).isEqualTo(aesGcmKeyFormat1.getKeySize());\n-    Keyset.Key key2 = keyset.getKey(1);\n-    expect.that(key2.getStatus()).isEqualTo(KeyStatusType.ENABLED);\n-    expect.that(key2.getOutputPrefixType()).isEqualTo(OutputPrefixType.TINK);\n-    expect.that(key2.hasKeyData()).isTrue();\n-    expect.that(key2.getKeyData().getTypeUrl()).isEqualTo(keyTemplate2.getTypeUrl());\n-    AesGcmKeyFormat aesGcmKeyFormat2 =\n-        AesGcmKeyFormat.parseFrom(\n-            keyTemplate2.getValue(), ExtensionRegistryLite.getEmptyRegistry());\n-    AesGcmKey aesGcmKey2 =\n-        AesGcmKey.parseFrom(key2.getKeyData().getValue(), ExtensionRegistryLite.getEmptyRegistry());\n-    expect.that(aesGcmKey2.getKeyValue().size()).isEqualTo(aesGcmKeyFormat2.getKeySize());\n-    // No primary key because add doesn't automatically promote the new key to primary.\n-    assertThrows(GeneralSecurityException.class, () -> keysetHandle.getPrimitive(Aead.class));\n+    assertThat(keysetHandle.size()).isEqualTo(2);\n+    expect.that(keysetHandle.getAt(0).getStatus()).isEqualTo(KeyStatus.ENABLED);\n+    expect.that(keysetHandle.getAt(0).isPrimary()).isFalse();\n+    expect\n+        .that(keysetHandle.getAt(0).getKey().getParameters())\n+        .isEqualTo(keyTemplate1.toParameters());\n+    expect.that(keysetHandle.getAt(1).getStatus()).isEqualTo(KeyStatus.ENABLED);\n+    expect.that(keysetHandle.getAt(1).isPrimary()).isFalse();\n+    expect\n+        .that(keysetHandle.getAt(1).getKey().getParameters())\n+        .isEqualTo(keyTemplate2.toParameters());\n   }\n \n   @Test",
      "parent_sha": "bee6d8a411c2448e99101d36e9c043d8cd5bf80e"
    }
  },
  {
    "oid": "4ea28b362a00d621a5fa529e83c12b8c6c5dc4ea",
    "message": "Removing deprecated method PublicKeySignFactory.getPrimitive(KeySetHandle, KeyManager) in Java.\n\nPiperOrigin-RevId: 339523745",
    "date": "2020-10-28T20:15:15Z",
    "url": "https://github.com/tink-crypto/tink/commit/4ea28b362a00d621a5fa529e83c12b8c6c5dc4ea",
    "details": {
      "sha": "bfb9709d7848c8feb1d1e15d632588360b680439",
      "filename": "java_src/src/main/java/com/google/crypto/tink/signature/PublicKeySignFactory.java",
      "status": "modified",
      "additions": 1,
      "deletions": 15,
      "changes": 16,
      "blob_url": "https://github.com/tink-crypto/tink/blob/4ea28b362a00d621a5fa529e83c12b8c6c5dc4ea/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsignature%2FPublicKeySignFactory.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/4ea28b362a00d621a5fa529e83c12b8c6c5dc4ea/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsignature%2FPublicKeySignFactory.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fsignature%2FPublicKeySignFactory.java?ref=4ea28b362a00d621a5fa529e83c12b8c6c5dc4ea",
      "patch": "@@ -16,7 +16,6 @@\n \n package com.google.crypto.tink.signature;\n \n-import com.google.crypto.tink.KeyManager;\n import com.google.crypto.tink.KeysetHandle;\n import com.google.crypto.tink.PrimitiveSet;\n import com.google.crypto.tink.PublicKeySign;\n@@ -49,22 +48,9 @@ public final class PublicKeySignFactory {\n   @Deprecated\n   public static PublicKeySign getPrimitive(KeysetHandle keysetHandle)\n       throws GeneralSecurityException {\n-    return getPrimitive(keysetHandle, /* keyManager= */ null);\n-  }\n-\n-  /**\n-   * @return a PublicKeySign primitive from a {@code keysetHandle} and a custom {@code keyManager}.\n-   * @throws GeneralSecurityException\n-   * @deprecated Use {@code keysetHandle.GetPrimitive(keyManager, PublicKeySign.class)} after\n-   *     registering the {@code PublicKeySignWrapper} instead.\n-   */\n-  @Deprecated\n-  public static PublicKeySign getPrimitive(\n-      KeysetHandle keysetHandle, final KeyManager<PublicKeySign> keyManager)\n-      throws GeneralSecurityException {\n     Registry.registerPrimitiveWrapper(new PublicKeySignWrapper());\n     final PrimitiveSet<PublicKeySign> primitives =\n-        Registry.getPrimitives(keysetHandle, keyManager, PublicKeySign.class);\n+        Registry.getPrimitives(keysetHandle, null, PublicKeySign.class);\n     return Registry.wrap(primitives);\n   }\n }",
      "parent_sha": "0f29488872412cd3f0162609c9df3ecd6189c6c1"
    }
  },
  {
    "oid": "d77ed2887eecb7e17cee2809861af06a0c055724",
    "message": "Remove \"Convenience method for...\".\n\nPiperOrigin-RevId: 549612275",
    "date": "2023-07-20T13:27:35Z",
    "url": "https://github.com/tink-crypto/tink/commit/d77ed2887eecb7e17cee2809861af06a0c055724",
    "details": {
      "sha": "e4917e4c7244c492c8f0dbe54407aac2abf78f47",
      "filename": "java_src/src/main/java/com/google/crypto/tink/Registry.java",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "blob_url": "https://github.com/tink-crypto/tink/blob/d77ed2887eecb7e17cee2809861af06a0c055724/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistry.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/d77ed2887eecb7e17cee2809861af06a0c055724/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistry.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistry.java?ref=d77ed2887eecb7e17cee2809861af06a0c055724",
      "patch": "@@ -524,7 +524,7 @@ public static KeyManager<?> getUntypedKeyManager(String typeUrl)\n   }\n \n   /**\n-   * Convenience method for generating a new {@link KeyData} for the specified {@code template}.\n+   * Generates a new {@link KeyData} for the specified {@code template}.\n    *\n    * <p>It looks up a {@link KeyManager} identified by {@code keyTemplate.type_url}, and calls\n    * {@link KeyManager#newKeyData}.\n@@ -544,8 +544,8 @@ public static synchronized KeyData newKeyData(\n     }\n   }\n \n-    /**\n-   * Convenience method for generating a new {@link KeyData} for the specified {@code template}.\n+  /**\n+   * Generates a new {@link KeyData} for the specified {@code template}.\n    *\n    * <p>It looks up a {@link KeyManager} identified by {@code keyTemplate.type_url}, and calls\n    * {@link KeyManager#newKeyData}.\n@@ -560,7 +560,7 @@ public static synchronized KeyData newKeyData(com.google.crypto.tink.KeyTemplate\n   }\n \n   /**\n-   * Convenience method for generating a new key for the specified {@code keyTemplate}.\n+   * Generates a new key for the specified {@code keyTemplate}.\n    *\n    * <p>It looks up a {@link KeyManager} identified by {@code keyTemplate.type_url}, and calls\n    * {@link KeyManager#newKey} with {@code keyTemplate} as the parameter.\n@@ -581,7 +581,7 @@ public static synchronized MessageLite newKey(\n   }\n \n   /**\n-   * Convenience method for generating a new key for the specified {@code format}.\n+   * Generates a new key for the specified {@code format}.\n    *\n    * <p>It looks up a {@link KeyManager} identified by {@code keyTemplate.type_url}, and calls\n    * {@link KeyManager#newKey} with {@code format} as the parameter.\n@@ -601,8 +601,8 @@ public static synchronized MessageLite newKey(String typeUrl, MessageLite format\n   }\n \n   /**\n-   * Method to derive a key, using the given {@code keyTemplate}, with the randomness as provided by\n-   * the second argument.\n+   * Derives a key, using the given {@code keyTemplate}, with the randomness as provided by the\n+   * second argument.\n    *\n    * <p>This method is on purpose not in the public interface. Calling it twice using different key\n    * templates and the same randomness can completely destroy any security in a system, so we\n@@ -623,8 +623,7 @@ static synchronized KeyData deriveKey(\n   }\n \n   /**\n-   * Convenience method for extracting the public key data from the private key given in {@code\n-   * serializedPrivateKey}.\n+   * Extracts the public key data from the private key given in {@code serializedPrivateKey}.\n    *\n    * <p>It looks up a {@link PrivateKeyManager} identified by {@code typeUrl}, and calls {@link\n    * PrivateKeyManager#getPublicKeyData} with {@code serializedPrivateKey} as the parameter.\n@@ -642,7 +641,7 @@ public static KeyData getPublicKeyData(String typeUrl, ByteString serializedPriv\n   }\n \n   /**\n-   * Convenience method for creating a new primitive for the key given in {@code proto}.\n+   * Creates a new primitive for the key given in {@code proto}.\n    *\n    * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link\n    * KeyManager#getPrimitive} with {@code key} as the parameter.\n@@ -659,7 +658,7 @@ public static <P> P getPrimitive(String typeUrl, MessageLite key)\n   }\n \n   /**\n-   * Convenience method for creating a new primitive for the key given in {@code key}.\n+   * Creates a new primitive for the key given in {@code key}.\n    *\n    * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link\n    * KeyManager#getPrimitive} with {@code key} as the parameter.\n@@ -675,7 +674,7 @@ public static <P> P getPrimitive(\n   }\n \n   /**\n-   * Convenience method for creating a new primitive for the key given in {@code proto}.\n+   * Creates a new primitive for the key given in {@code proto}.\n    *\n    * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link\n    * KeyManager#getPrimitive} with {@code serializedKey} as the parameter.\n@@ -692,7 +691,7 @@ public static <P> P getPrimitive(String typeUrl, ByteString serializedKey)\n   }\n \n   /**\n-   * Convenience method for creating a new primitive for the key given in {@code serializedKey}.\n+   * Creates a new primitive for the key given in {@code serializedKey}.\n    *\n    * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link\n    * KeyManager#getPrimitive} with {@code serialized} as the parameter.\n@@ -707,7 +706,7 @@ public static <P> P getPrimitive(\n   }\n \n   /**\n-   * Convenience method for creating a new primitive for the key given in {@code serializedKey}.\n+   * Creates a new primitive for the key given in {@code serializedKey}.\n    *\n    * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link\n    * KeyManager#getPrimitive} with {@code serialized} as the parameter.\n@@ -723,7 +722,7 @@ public static <P> P getPrimitive(String typeUrl, byte[] serializedKey)\n   }\n \n   /**\n-   * Convenience method for creating a new primitive for the key given in {@code serializedKey}.\n+   * Creates a new primitive for the key given in {@code serializedKey}.\n    *\n    * <p>It looks up a {@link KeyManager} identified by {@code type_url}, and calls {@link\n    * KeyManager#getPrimitive} with {@code serialized} as the parameter.\n@@ -736,7 +735,7 @@ public static <P> P getPrimitive(String typeUrl, byte[] serializedKey, Class<P>\n   }\n \n   /**\n-   * Convenience method for creating a new primitive for the key given in {@code keyData}.\n+   * Creates a new primitive for the key given in {@code keyData}.\n    *\n    * <p>It looks up a {@link KeyManager} identified by {@code keyData.type_url}, and calls {@link\n    * KeyManager#getPrimitive} with {@code keyData.value} as the parameter.\n@@ -751,7 +750,7 @@ public static <P> P getPrimitive(KeyData keyData) throws GeneralSecurityExceptio\n   }\n \n   /**\n-   * Convenience method for creating a new primitive for the key given in {@code keyData}.\n+   * Creates a new primitive for the key given in {@code keyData}.\n    *\n    * <p>It looks up a {@link KeyManager} identified by {@code keyData.type_url}, and calls {@link\n    * KeyManager#getPrimitive} with {@code keyData.value} as the parameter.\n@@ -799,6 +798,7 @@ public static synchronized List<String> keyTemplates() {\n   static synchronized Map<String, KeyTemplate> keyTemplateMap() {\n     return Collections.unmodifiableMap(keyTemplateMap);\n   }\n+\n   /**\n    * Returns the input primitive required when creating a {@code wrappedPrimitive}.\n    *",
      "parent_sha": "5649ede627ddc4067dc8502b7aca61e41cd0481a"
    }
  },
  {
    "oid": "61c39da63926272673c817e27c098903fc359d78",
    "message": "Migrate the ChaCha20Poly1305KeyManagerTest.\n\nPiperOrigin-RevId: 265041621",
    "date": "2019-08-23T13:20:45Z",
    "url": "https://github.com/tink-crypto/tink/commit/61c39da63926272673c817e27c098903fc359d78",
    "details": {
      "sha": "731c225b734aebc291188ebbaef270746fe9dcae",
      "filename": "java/src/test/java/com/google/crypto/tink/aead/ChaCha20Poly1305KeyManagerTest.java",
      "status": "modified",
      "additions": 96,
      "deletions": 38,
      "changes": 134,
      "blob_url": "https://github.com/tink-crypto/tink/blob/61c39da63926272673c817e27c098903fc359d78/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Faead%2FChaCha20Poly1305KeyManagerTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/61c39da63926272673c817e27c098903fc359d78/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Faead%2FChaCha20Poly1305KeyManagerTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Faead%2FChaCha20Poly1305KeyManagerTest.java?ref=61c39da63926272673c817e27c098903fc359d78",
      "patch": "@@ -16,69 +16,127 @@\n \n package com.google.crypto.tink.aead;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n \n import com.google.crypto.tink.Aead;\n-import com.google.crypto.tink.CryptoFormat;\n-import com.google.crypto.tink.KeyManager;\n-import com.google.crypto.tink.KeyManagerImpl;\n-import com.google.crypto.tink.KeysetHandle;\n import com.google.crypto.tink.TestUtil;\n import com.google.crypto.tink.proto.ChaCha20Poly1305Key;\n-import com.google.crypto.tink.proto.KeyData;\n-import com.google.crypto.tink.proto.KeyTemplate;\n+import com.google.crypto.tink.proto.ChaCha20Poly1305KeyFormat;\n+import com.google.crypto.tink.proto.KeyData.KeyMaterialType;\n+import com.google.crypto.tink.subtle.Random;\n+import com.google.protobuf.ByteString;\n import java.security.GeneralSecurityException;\n-import java.util.Set;\n import java.util.TreeSet;\n-import org.junit.BeforeClass;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n /** Test for ChaCha20Poly1305KeyManager. */\n @RunWith(JUnit4.class)\n public class ChaCha20Poly1305KeyManagerTest {\n-  @BeforeClass\n-  public static void setUp() throws GeneralSecurityException {\n-    AeadConfig.register();\n+  @Test\n+  public void basics() throws Exception {\n+    assertThat(new ChaCha20Poly1305KeyManager().getKeyType())\n+        .isEqualTo(\"type.googleapis.com/google.crypto.tink.ChaCha20Poly1305Key\");\n+    assertThat(new ChaCha20Poly1305KeyManager().getVersion()).isEqualTo(0);\n+    assertThat(new ChaCha20Poly1305KeyManager().keyMaterialType())\n+        .isEqualTo(KeyMaterialType.SYMMETRIC);\n+  }\n+\n+  @Test\n+  public void validateKeyFormat() throws Exception {\n+    new ChaCha20Poly1305KeyManager()\n+        .keyFactory()\n+        .validateKeyFormat(ChaCha20Poly1305KeyFormat.getDefaultInstance());\n+  }\n+\n+\n+  @Test\n+  public void validateKey_empty() throws Exception {\n+    try {\n+      new ChaCha20Poly1305KeyManager().validateKey(ChaCha20Poly1305Key.getDefaultInstance());\n+      fail();\n+    } catch (GeneralSecurityException e) {\n+      // expected\n+    }\n+  }\n+\n+  @Test\n+  public void validateKey_checkAllLengths() throws Exception {\n+    ChaCha20Poly1305KeyManager manager = new ChaCha20Poly1305KeyManager();\n+    for (int i = 0; i < 100; i++) {\n+      if (i == 32) {\n+        manager.validateKey(createChaCha20Poly1305Key(i));\n+      } else {\n+        try {\n+          manager.validateKey(createChaCha20Poly1305Key(i));\n+          fail();\n+        } catch (GeneralSecurityException e) {\n+          // expected\n+        }\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void validateKey_version() throws Exception {\n+    ChaCha20Poly1305KeyManager manager = new ChaCha20Poly1305KeyManager();\n+\n+    try {\n+      manager.validateKey(\n+          ChaCha20Poly1305Key.newBuilder(createChaCha20Poly1305Key(32)).setVersion(1).build());\n+      fail();\n+    } catch (GeneralSecurityException e) {\n+      // expected\n+    }\n+  }\n+\n+  @Test\n+  public void createKey_valid() throws Exception {\n+    ChaCha20Poly1305KeyManager manager = new ChaCha20Poly1305KeyManager();\n+    manager.validateKey(\n+        manager.keyFactory().createKey(ChaCha20Poly1305KeyFormat.getDefaultInstance()));\n   }\n \n   @Test\n-  public void testBasic() throws Exception {\n-    KeysetHandle keysetHandle = KeysetHandle.generateNew(AeadKeyTemplates.CHACHA20_POLY1305);\n-    TestUtil.runBasicAeadTests(keysetHandle.getPrimitive(Aead.class));\n+  public void createKey_values() throws Exception {\n+    ChaCha20Poly1305KeyManager manager = new ChaCha20Poly1305KeyManager();\n+    ChaCha20Poly1305Key key =\n+        manager.keyFactory().createKey(ChaCha20Poly1305KeyFormat.getDefaultInstance());\n+    assertThat(key.getVersion()).isEqualTo(0);\n+    assertThat(key.getKeyValue()).hasSize(32);\n+  }\n+\n+  @Test\n+  public void createKey_multipleCallsCreateDifferentKeys() throws Exception {\n+    TreeSet<String> keys = new TreeSet<>();\n+    ChaCha20Poly1305KeyManager.KeyFactory<ChaCha20Poly1305KeyFormat, ChaCha20Poly1305Key> factory =\n+        new ChaCha20Poly1305KeyManager().keyFactory();\n+    final int numKeys = 1000;\n+    for (int i = 0; i < numKeys; ++i) {\n+      keys.add(\n+          TestUtil.hexEncode(\n+              factory.createKey(ChaCha20Poly1305KeyFormat.getDefaultInstance()).toByteArray()));\n+    }\n+    assertThat(keys).hasSize(numKeys);\n   }\n \n   @Test\n   public void testCiphertextSize() throws Exception {\n-    KeysetHandle keysetHandle = KeysetHandle.generateNew(AeadKeyTemplates.CHACHA20_POLY1305);\n-    Aead aead = keysetHandle.getPrimitive(Aead.class);\n+    Aead aead =\n+        new ChaCha20Poly1305KeyManager().getPrimitive(createChaCha20Poly1305Key(32), Aead.class);\n     byte[] plaintext = \"plaintext\".getBytes(\"UTF-8\");\n     byte[] associatedData = \"associatedData\".getBytes(\"UTF-8\");\n     byte[] ciphertext = aead.encrypt(plaintext, associatedData);\n-    assertEquals(\n-        CryptoFormat.NON_RAW_PREFIX_SIZE + 12 /* IV_SIZE */ + plaintext.length + 16 /* TAG_SIZE */,\n-        ciphertext.length);\n+    assertEquals(12 /* IV_SIZE */ + plaintext.length + 16 /* TAG_SIZE */, ciphertext.length);\n   }\n \n-  @Test\n-  public void testNewKeyMultipleTimes() throws Exception {\n-    KeyTemplate keyTemplate = AeadKeyTemplates.CHACHA20_POLY1305;\n-    KeyManager<Aead> keyManager =\n-        new KeyManagerImpl<>(new ChaCha20Poly1305KeyManager(), Aead.class);\n-    Set<String> keys = new TreeSet<String>();\n-    // Calls newKey multiple times and make sure that they generate different keys.\n-    int numTests = 10;\n-    for (int i = 0; i < numTests; i++) {\n-      ChaCha20Poly1305Key key = (ChaCha20Poly1305Key) keyManager.newKey(keyTemplate.getValue());\n-      keys.add(TestUtil.hexEncode(key.getKeyValue().toByteArray()));\n-      assertEquals(32, key.getKeyValue().toByteArray().length);\n-\n-      KeyData keyData = keyManager.newKeyData(keyTemplate.getValue());\n-      key = ChaCha20Poly1305Key.parseFrom(keyData.getValue());\n-      keys.add(TestUtil.hexEncode(key.getKeyValue().toByteArray()));\n-      assertEquals(32, key.getKeyValue().toByteArray().length);\n-    }\n-    assertEquals(numTests * 2, keys.size());\n+  private ChaCha20Poly1305Key createChaCha20Poly1305Key(int keySize) {\n+    return ChaCha20Poly1305Key.newBuilder()\n+        .setVersion(0)\n+        .setKeyValue(ByteString.copyFrom(Random.randBytes(keySize)))\n+        .build();\n   }\n }",
      "parent_sha": "5ab15cd63f222545deab1b0f5567055757552160"
    }
  },
  {
    "oid": "77fa6ef28dbc11c40c37bc1764445d47096281e7",
    "message": "Merge \"Disable tests that require unlimited key strength, which is not supported yet in the JVM installed on Kokoro MacOS fleet.\"\n\nORIGINAL_AUTHOR=Thai Duong <thaidn@google.com>\nGitOrigin-RevId: 9bd9db1cd196b281a3396007b9f6258b61bcb5d8",
    "date": "2017-05-24T17:18:45Z",
    "url": "https://github.com/tink-crypto/tink/commit/77fa6ef28dbc11c40c37bc1764445d47096281e7",
    "details": {
      "sha": "63793370513b5b68f1e4281fd133d53fad2ca181",
      "filename": "java/src/test/java/com/google/cloud/crypto/tink/subtle/AesGcmJceTest.java",
      "status": "modified",
      "additions": 21,
      "deletions": 3,
      "changes": 24,
      "blob_url": "https://github.com/tink-crypto/tink/blob/77fa6ef28dbc11c40c37bc1764445d47096281e7/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Fcrypto%2Ftink%2Fsubtle%2FAesGcmJceTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/77fa6ef28dbc11c40c37bc1764445d47096281e7/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Fcrypto%2Ftink%2Fsubtle%2FAesGcmJceTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcloud%2Fcrypto%2Ftink%2Fsubtle%2FAesGcmJceTest.java?ref=77fa6ef28dbc11c40c37bc1764445d47096281e7",
      "patch": "@@ -25,6 +25,8 @@\n import java.util.Arrays;\n import java.util.HashSet;\n import javax.crypto.AEADBadTagException;\n+import javax.crypto.Cipher;\n+import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n@@ -37,7 +39,18 @@\n @RunWith(JUnit4.class)\n public class AesGcmJceTest {\n \n-  private static final int[] KEY_SIZES_IN_BYTES = new int[] {16, 24, 32};\n+  private int[] keySizeInBytes;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    if (Cipher.getMaxAllowedKeyLength(\"AES\") < 256) {\n+        System.out.println(\"Unlimited Strength Jurisdiction Policy Files are required\"\n+            + \" but not installed. Skip tests with keys larger than 128 bits.\");\n+      keySizeInBytes = new int[] {16};\n+    } else {\n+      keySizeInBytes = new int[] {16, 24, 32};\n+    }\n+  }\n \n   /** Test vectors */\n   public static class GcmTestVector {\n@@ -120,6 +133,11 @@ public GcmTestVector(\n    */\n   public void testRegression() throws Exception {\n     for (GcmTestVector test : GCM_TEST_VECTORS) {\n+      if (Cipher.getMaxAllowedKeyLength(\"AES\") < 256 && test.key.length > 16) {\n+          System.out.println(\"Unlimited Strength Jurisdiction Policy Files are required\"\n+              + \" but not installed. Skip tests with keys larger than 128 bits.\");\n+          continue;\n+      }\n       AesGcmJce gcm = new AesGcmJce(test.key);\n       byte[] pt = gcm.decrypt(test.ct, test.aad);\n       assertArrayEquals(test.pt, pt);\n@@ -129,7 +147,7 @@ public void testRegression() throws Exception {\n   @Test\n   public void testEncryptDecrypt() throws Exception {\n     byte[] aad = new byte[] {1, 2, 3};\n-    for (int keySize : KEY_SIZES_IN_BYTES) {\n+    for (int keySize : keySizeInBytes) {\n       byte[] key = Random.randBytes(keySize);\n       AesGcmJce gcm = new AesGcmJce(key);\n       for (int messageSize = 0; messageSize < 75; messageSize++) {\n@@ -150,7 +168,7 @@ public void testLongMessages() throws Exception {\n     while (dataSize <= (1 << 24)) {\n       byte[] plaintext = Random.randBytes(dataSize);\n       byte[] aad = Random.randBytes(dataSize / 3);\n-      for (int keySize : KEY_SIZES_IN_BYTES) {\n+      for (int keySize : keySizeInBytes) {\n         byte[] key = Random.randBytes(keySize);\n         AesGcmJce gcm = new AesGcmJce(key);\n         byte[] ciphertext = gcm.encrypt(plaintext, aad);",
      "parent_sha": "2d8c0a205d537b088b7fcefda536158094cd5290"
    }
  },
  {
    "oid": "97f52ad2cdc0edec00c84695041221d575385783",
    "message": "Rename masterKey to MasterAead and update some of the documentation.\n\nPiperOrigin-RevId: 504849650",
    "date": "2023-01-26T16:31:12Z",
    "url": "https://github.com/tink-crypto/tink/commit/97f52ad2cdc0edec00c84695041221d575385783",
    "details": {
      "sha": "92d60d731461b21e7c5c7d00d95e5ec305c42cd7",
      "filename": "java_src/src/main/java/com/google/crypto/tink/integration/android/AndroidKeysetManager.java",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/tink-crypto/tink/blob/97f52ad2cdc0edec00c84695041221d575385783/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeysetManager.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/97f52ad2cdc0edec00c84695041221d575385783/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeysetManager.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fandroid%2FAndroidKeysetManager.java?ref=97f52ad2cdc0edec00c84695041221d575385783",
      "patch": "@@ -58,7 +58,7 @@\n  * // later use.\n  * AndroidKeysetManager manager = AndroidKeysetManager.Builder()\n  *    .withSharedPref(getApplicationContext(), \"my_keyset_name\", \"my_pref_file_name\")\n- *    .withKeyTemplate(AesGcmHkfStreamingKeyManager.aes128GcmHkdf4KBTemplate())\n+ *    .withKeyTemplate(KeyTemplates.get(\"AES128_GCM_HKDF_4KB\"))\n  *    .build();\n  * StreamingAead streamingAead = manager.getKeysetHandle().getPrimitive(StreamingAead.class);\n  * }</pre>\n@@ -78,13 +78,13 @@\n  *       my_pref_file_name} shared preferences file.\n  * </ul>\n  *\n- * <h3>Key rotation</h3>\n+ * <h3>Adding a new key</h3>\n  *\n  * <p>The resulting manager supports all operations supported by {@link KeysetManager}. For example\n- * to rotate the keyset, you can do:\n+ * to add a key to the keyset, you can do:\n  *\n  * <pre>{@code\n- * manager.rotate(AesGcmHkfStreamingKeyManager.aes128GcmHkdf1MBTemplate());\n+ * manager.add(KeyTemplates.get(\"AES128_GCM_HKDF_4KB\"));\n  * }</pre>\n  *\n  * <p>All operations that manipulate the keyset would automatically persist the new keyset to\n@@ -128,14 +128,14 @@ public final class AndroidKeysetManager {\n \n   private static final String TAG = AndroidKeysetManager.class.getSimpleName();\n   private final KeysetWriter writer;\n-  private final Aead masterKey;\n+  private final Aead masterAead;\n \n   @GuardedBy(\"this\")\n   private KeysetManager keysetManager;\n \n   private AndroidKeysetManager(Builder builder) {\n     writer = new SharedPrefKeysetWriter(builder.context, builder.keysetName, builder.prefFileName);\n-    masterKey = builder.masterKey;\n+    masterAead = builder.masterAead;\n     keysetManager = builder.keysetManager;\n   }\n \n@@ -150,7 +150,7 @@ public static final class Builder {\n     private String prefFileName = null;\n \n     private String masterKeyUri = null;\n-    private Aead masterKey = null;\n+    private Aead masterAead = null;\n     private boolean useKeystore = true;\n     private KeyTemplate keyTemplate = null;\n \n@@ -287,7 +287,7 @@ public synchronized AndroidKeysetManager build() throws GeneralSecurityException\n         byte[] serializedKeyset = readKeysetFromPrefs(context, keysetName, prefFileName);\n         if (serializedKeyset == null) {\n           if (masterKeyUri != null) {\n-            masterKey = readOrGenerateNewMasterKey();\n+            masterAead = readOrGenerateNewMasterKey();\n           }\n           this.keysetManager = generateKeysetAndWriteToPrefs();\n         } else {\n@@ -349,8 +349,8 @@ private KeysetManager generateKeysetAndWriteToPrefs()\n       int keyId = manager.getKeysetHandle().getKeysetInfo().getKeyInfo(0).getKeyId();\n       manager = manager.setPrimary(keyId);\n       KeysetWriter writer = new SharedPrefKeysetWriter(context, keysetName, prefFileName);\n-      if (masterKey != null) {\n-        manager.getKeysetHandle().write(writer, masterKey);\n+      if (masterAead != null) {\n+        manager.getKeysetHandle().write(writer, masterAead);\n       } else {\n         CleartextKeysetHandle.write(manager.getKeysetHandle(), writer);\n       }\n@@ -360,11 +360,11 @@ private KeysetManager generateKeysetAndWriteToPrefs()\n     @SuppressWarnings(\"UnusedException\")\n     private KeysetManager readMasterkeyDecryptAndParseKeyset(byte[] serializedKeyset)\n         throws GeneralSecurityException, IOException {\n-      // We expect that the keyset is encrypted. Try to read masterKey.\n+      // We expect that the keyset is encrypted. Try to get masterAead.\n       try {\n-        masterKey = new AndroidKeystoreKmsClient().getAead(masterKeyUri);\n+        masterAead = new AndroidKeystoreKmsClient().getAead(masterKeyUri);\n       } catch (GeneralSecurityException | ProviderException keystoreException) {\n-        // Reading masterkey failed. Attempt to read the keyset in cleartext.\n+        // Getting masterAead failed. Attempt to read the keyset in cleartext.\n         try {\n           KeysetManager manager = readKeysetInCleartext(serializedKeyset);\n           Log.w(TAG, \"cannot use Android Keystore, it'll be disabled\", keystoreException);\n@@ -374,11 +374,11 @@ private KeysetManager readMasterkeyDecryptAndParseKeyset(byte[] serializedKeyset\n           throw keystoreException;\n         }\n       }\n-      // masterKey was read successfully.\n+      // Got masterAead successfully.\n       try {\n-        // Decrypt and parse the keyset using masterKey.\n+        // Decrypt and parse the keyset using masterAead.\n         return KeysetManager.withKeysetHandle(\n-            KeysetHandle.read(BinaryKeysetReader.withBytes(serializedKeyset), masterKey));\n+            KeysetHandle.read(BinaryKeysetReader.withBytes(serializedKeyset), masterAead));\n       } catch (IOException | GeneralSecurityException ex) {\n         // Attempt to read the keyset in cleartext.\n         // This edge case may happen when either\n@@ -538,7 +538,7 @@ public synchronized boolean isUsingKeystore() {\n   private void write(KeysetManager manager) throws GeneralSecurityException {\n     try {\n       if (shouldUseKeystore()) {\n-        manager.getKeysetHandle().write(writer, masterKey);\n+        manager.getKeysetHandle().write(writer, masterAead);\n       } else {\n         CleartextKeysetHandle.write(manager.getKeysetHandle(), writer);\n       }\n@@ -549,7 +549,7 @@ private void write(KeysetManager manager) throws GeneralSecurityException {\n \n   @ChecksSdkIntAtLeast(api = Build.VERSION_CODES.M)\n   private boolean shouldUseKeystore() {\n-    return masterKey != null && isAtLeastM();\n+    return masterAead != null && isAtLeastM();\n   }\n \n   private static KeyTemplate.OutputPrefixType fromProto(OutputPrefixType outputPrefixType) {",
      "parent_sha": "1ff148fcfd8921d041e75e7cbaf89f95e0ce5507"
    }
  },
  {
    "oid": "c07d1d2200456eb54c90e03ab0b864e2fd92a5fe",
    "message": "Removing a RegistryTest.java dependency on deprecated class AeadKeyTemplates.\n\nPiperOrigin-RevId: 340377365",
    "date": "2020-11-03T05:53:25Z",
    "url": "https://github.com/tink-crypto/tink/commit/c07d1d2200456eb54c90e03ab0b864e2fd92a5fe",
    "details": {
      "sha": "d02037e8d1416427c31d691522833ccd03fb5762",
      "filename": "java_src/src/test/java/com/google/crypto/tink/RegistryTest.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/tink-crypto/tink/blob/c07d1d2200456eb54c90e03ab0b864e2fd92a5fe/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistryTest.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/c07d1d2200456eb54c90e03ab0b864e2fd92a5fe/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistryTest.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FRegistryTest.java?ref=c07d1d2200456eb54c90e03ab0b864e2fd92a5fe",
      "patch": "@@ -403,9 +403,9 @@ public void testGetPrimitive_legacy_AesGcm_shouldWork() throws Exception {\n \n   @Test\n   public void testGetPrimitive_AesGcm_shouldWork() throws Exception {\n-    KeyTemplate template = AeadKeyTemplates.AES128_EAX;\n-    AesEaxKey aesEaxKey = (AesEaxKey) Registry.newKey(template);\n-    KeyData aesEaxKeyData = Registry.newKeyData(template);\n+    AesEaxKey aesEaxKey =\n+        (AesEaxKey) Registry.newKey(AesEaxKeyManager.aes128EaxTemplate().getProto());\n+    KeyData aesEaxKeyData = Registry.newKeyData(AesEaxKeyManager.aes128EaxTemplate().getProto());\n     Aead aead = Registry.getPrimitive(aesEaxKeyData, Aead.class);\n \n     assertThat(aesEaxKey.getKeyValue().size()).isEqualTo(16);",
      "parent_sha": "3ccb42046e3dd1515d10db6a53e81a74657f7fce"
    }
  },
  {
    "oid": "8c7ff3bc4e1298a752278adb8c42916feff38a89",
    "message": "java: Fix cross language aead test.\n\nPiperOrigin-RevId: 250595889",
    "date": "2019-05-30T00:02:29Z",
    "url": "https://github.com/tink-crypto/tink/commit/8c7ff3bc4e1298a752278adb8c42916feff38a89",
    "details": {
      "sha": "6d1bb17f50211830541d5a41b7c6ecf1a70bbb3c",
      "filename": "java/src/main/java/com/google/crypto/tink/integration/awskms/AwsKmsClient.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/tink-crypto/tink/blob/8c7ff3bc4e1298a752278adb8c42916feff38a89/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fawskms%2FAwsKmsClient.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/8c7ff3bc4e1298a752278adb8c42916feff38a89/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fawskms%2FAwsKmsClient.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fintegration%2Fawskms%2FAwsKmsClient.java?ref=8c7ff3bc4e1298a752278adb8c42916feff38a89",
      "patch": "@@ -117,7 +117,7 @@ public KmsClient withCredentialsProvider(AWSCredentialsProvider provider)\n       this.client =\n           AWSKMSClientBuilder.standard()\n               .withCredentials(provider)\n-              .withRegion(Regions.fromName(tokens[3]))\n+              .withRegion(Regions.fromName(tokens[4]))\n               .build();\n       return this;\n     } catch (AmazonServiceException e) {",
      "parent_sha": "0dc9f9f8447b34c0757ebae29ad8560349831650"
    }
  },
  {
    "oid": "0188b71daa0a0e9d51f9de3fad35cea6298dfde5",
    "message": "Remove deprecation under consideration markers in PrimitiveSet.\n\nPiperOrigin-RevId: 512561304",
    "date": "2023-02-27T09:48:11Z",
    "url": "https://github.com/tink-crypto/tink/commit/0188b71daa0a0e9d51f9de3fad35cea6298dfde5",
    "details": {
      "sha": "5009840ac05d8b20b27d2447e91b4d41d1e00457",
      "filename": "java_src/src/main/java/com/google/crypto/tink/PrimitiveSet.java",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/tink-crypto/tink/blob/0188b71daa0a0e9d51f9de3fad35cea6298dfde5/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FPrimitiveSet.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/0188b71daa0a0e9d51f9de3fad35cea6298dfde5/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FPrimitiveSet.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FPrimitiveSet.java?ref=0188b71daa0a0e9d51f9de3fad35cea6298dfde5",
      "patch": "@@ -276,7 +276,7 @@ public static <P> PrimitiveSet<P> newPrimitiveSet(Class<P> primitiveClass) {\n    * @throws IllegalStateException if object has been created by the {@link Builder}.\n    * @deprecated use {@link Builder.addPrimaryPrimitive} instead.\n    */\n-  @Deprecated /* Deprecation under consideration */\n+  @Deprecated\n   public void setPrimary(final Entry<P> primary) {\n     if (!isMutable) {\n       throw new IllegalStateException(\"setPrimary cannot be called on an immutable primitive set\");\n@@ -302,9 +302,10 @@ public void setPrimary(final Entry<P> primary) {\n    * @throws IllegalStateException if object has been created by the {@link Builder}.\n    * @deprecated use {@link Builder.addPrimitive} or {@link Builder.addPrimaryPrimitive} instead.\n    */\n-  @Deprecated /* Deprecation under consideration */\n   @CanIgnoreReturnValue\n-  public Entry<P> addPrimitive(final P primitive, Keyset.Key key) throws GeneralSecurityException {\n+  @Deprecated\n+  public Entry<P> addPrimitive(final P primitive, Keyset.Key key)\n+      throws GeneralSecurityException {\n     if (!isMutable) {\n       throw new IllegalStateException(\n           \"addPrimitive cannot be called on an immutable primitive set\");",
      "parent_sha": "582488f6de6c7a2de8b5e83443ba43630221a2db"
    }
  },
  {
    "oid": "f4408987d56d661d76b0abc05161ed92f5023d77",
    "message": "Fix comment that is not up to date.\n\nPiperOrigin-RevId: 341401501",
    "date": "2020-11-09T15:31:35Z",
    "url": "https://github.com/tink-crypto/tink/commit/f4408987d56d661d76b0abc05161ed92f5023d77",
    "details": {
      "sha": "3530c9333214daef9d84f85a22b0d200647d1a95",
      "filename": "java_src/src/main/java/com/google/crypto/tink/CryptoFormat.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/tink-crypto/tink/blob/f4408987d56d661d76b0abc05161ed92f5023d77/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FCryptoFormat.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/f4408987d56d661d76b0abc05161ed92f5023d77/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FCryptoFormat.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2FCryptoFormat.java?ref=f4408987d56d661d76b0abc05161ed92f5023d77",
      "patch": "@@ -27,7 +27,7 @@\n  */\n public final class CryptoFormat {\n \n-  /** Prefix size of Tink and Legacy key types. */\n+  /** Prefix size of Tink, Legacy and Crunchy output prefix types. */\n   public static final int NON_RAW_PREFIX_SIZE = 5;\n \n   /** Legacy or Crunchy prefix starts with \\x00 and followed by a 4-byte key id. */\n@@ -73,4 +73,6 @@ public static byte[] getOutputPrefix(Key key) throws GeneralSecurityException {\n         throw new GeneralSecurityException(\"unknown output prefix type\");\n     }\n   }\n+\n+  private CryptoFormat() {}\n }",
      "parent_sha": "fea13bf6d2055bd865401b1f11a9291a27ec7b27"
    }
  },
  {
    "oid": "2fc5d397125c11801b2ee309b18ad6f66e831c49",
    "message": "Removing deprecated method StreamingAeadFactory.getPrimitive(KeySetHandle, KeyManager) in Java.\n\nPiperOrigin-RevId: 339519091",
    "date": "2020-10-28T19:52:41Z",
    "url": "https://github.com/tink-crypto/tink/commit/2fc5d397125c11801b2ee309b18ad6f66e831c49",
    "details": {
      "sha": "e6391216b309f7a3c5995a31505911e2c91b58ff",
      "filename": "java_src/src/main/java/com/google/crypto/tink/streamingaead/StreamingAeadFactory.java",
      "status": "modified",
      "additions": 1,
      "deletions": 13,
      "changes": 14,
      "blob_url": "https://github.com/tink-crypto/tink/blob/2fc5d397125c11801b2ee309b18ad6f66e831c49/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fstreamingaead%2FStreamingAeadFactory.java",
      "raw_url": "https://github.com/tink-crypto/tink/raw/2fc5d397125c11801b2ee309b18ad6f66e831c49/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fstreamingaead%2FStreamingAeadFactory.java",
      "contents_url": "https://api.github.com/repos/tink-crypto/tink/contents/java_src%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgoogle%2Fcrypto%2Ftink%2Fstreamingaead%2FStreamingAeadFactory.java?ref=2fc5d397125c11801b2ee309b18ad6f66e831c49",
      "patch": "@@ -16,7 +16,6 @@\n \n package com.google.crypto.tink.streamingaead;\n \n-import com.google.crypto.tink.KeyManager;\n import com.google.crypto.tink.KeysetHandle;\n import com.google.crypto.tink.PrimitiveSet;\n import com.google.crypto.tink.Registry;\n@@ -46,20 +45,9 @@ public final class StreamingAeadFactory {\n    */\n   public static StreamingAead getPrimitive(KeysetHandle keysetHandle)\n       throws GeneralSecurityException {\n-    return getPrimitive(keysetHandle, /* keyManager= */ null);\n-  }\n-\n-  /**\n-   * @return a StreamingAead primitive from a {@code keysetHandle} and a custom {@code keyManager}.\n-   * @throws GeneralSecurityException\n-   */\n-  public static StreamingAead getPrimitive(\n-      KeysetHandle keysetHandle,\n-      final KeyManager<StreamingAead> keyManager)\n-      throws GeneralSecurityException {\n     Registry.registerPrimitiveWrapper(new StreamingAeadWrapper());\n     final PrimitiveSet<StreamingAead> primitives =\n-        Registry.getPrimitives(keysetHandle, keyManager, StreamingAead.class);\n+        Registry.getPrimitives(keysetHandle, null, StreamingAead.class);\n     return Registry.wrap(primitives);\n   }\n }",
      "parent_sha": "ca074ede47c2ed604e00d8fe10af433e05b6d48e"
    }
  }
]