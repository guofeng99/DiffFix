[
  {
    "oid": "9697e6cc36cec5f304a43933d3fa5a8cf6eb58aa",
    "message": "include superclass when referring to parent builder\n\nexample: \"ChildBuilder extends Parent.ParentBuilder\"",
    "date": "2018-04-14T18:01:01Z",
    "url": "https://github.com/projectlombok/lombok/commit/9697e6cc36cec5f304a43933d3fa5a8cf6eb58aa",
    "details": {
      "sha": "7f0858d2e0c4cd70014335461342591676281dda",
      "filename": "src/core/lombok/javac/handlers/HandleSuperBuilder.java",
      "status": "modified",
      "additions": 14,
      "deletions": 11,
      "changes": 25,
      "blob_url": "https://github.com/projectlombok/lombok/blob/9697e6cc36cec5f304a43933d3fa5a8cf6eb58aa/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FHandleSuperBuilder.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/9697e6cc36cec5f304a43933d3fa5a8cf6eb58aa/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FHandleSuperBuilder.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FHandleSuperBuilder.java?ref=9697e6cc36cec5f304a43933d3fa5a8cf6eb58aa",
      "patch": "@@ -163,18 +163,22 @@ private static class BuilderFieldData {\n \t\tString builderClassName = td.name.toString() + \"Builder\";\n \t\tString builderImplClassName = builderClassName + \"Impl\";\n \t\tJCTree extendsClause = Javac.getExtendsClause(td);\n-\t\tString superclassBuilderClassName = null;\n+\t\tJCExpression superclassBuilderClassExpression = null;\n \t\tif (extendsClause instanceof JCFieldAccess) {\n \t\t\t// The extends clause consists of a fully-qualified name. \n-\t\t\tsuperclassBuilderClassName = ((JCFieldAccess)extendsClause).getIdentifier() + \"Builder\";\n+\t\t\tName superclassClassName = ((JCFieldAccess)extendsClause).getIdentifier();\n+\t\t\tString superclassBuilderClassName = superclassClassName + \"Builder\";\n+\t\t\tsuperclassBuilderClassExpression = tdParent.getTreeMaker().Select((JCFieldAccess)extendsClause, \n+\t\t\t\t\ttdParent.toName(superclassBuilderClassName));\n \t\t} else if (extendsClause != null) {\n \t\t\t// A simple class name is used in the extends clause.\n-\t\t\tsuperclassBuilderClassName = extendsClause + \"Builder\";\n+\t\t\tString superclassBuilderClassName = extendsClause + \"Builder\";\n+\t\t\tsuperclassBuilderClassExpression = chainDots(tdParent, extendsClause.toString(), superclassBuilderClassName);\n \t\t}\n \t\t// If there is no superclass, superclassBuilderClassName is still == null at this point.\n \t\t// You can use it to check whether to inherit or not.\n \n-\t\tgenerateBuilderBasedConstructor(tdParent, builderFields, annotationNode, builderClassName, superclassBuilderClassName != null);\n+\t\tgenerateBuilderBasedConstructor(tdParent, builderFields, annotationNode, builderClassName, superclassBuilderClassExpression != null);\n \n \t\treturnType = namePlusTypeParamsToTypeReference(tdParent.getTreeMaker(), td.name, td.typarams);\n \t\ttypeParams = td.typarams;\n@@ -183,7 +187,7 @@ private static class BuilderFieldData {\n \t\t// Create the abstract builder class.\n \t\tJavacNode builderType = findInnerClass(tdParent, builderClassName);\n \t\tif (builderType == null) {\n-\t\t\tbuilderType = makeBuilderClass(annotationNode, tdParent, builderClassName, superclassBuilderClassName, typeParams, ast);\n+\t\t\tbuilderType = makeBuilderClass(annotationNode, tdParent, builderClassName, superclassBuilderClassExpression, typeParams, ast);\n \t\t} else {\n \t\t\tannotationNode.addError(\"@SuperBuilder does not support customized builders. Use @Builder instead.\");\n \t\t\treturn;\n@@ -218,8 +222,8 @@ private static class BuilderFieldData {\n \t\t}\n \n \t\t// Generate abstract self() and build() methods in the abstract builder.\n-\t\tinjectMethod(builderType, generateAbstractSelfMethod(tdParent, superclassBuilderClassName != null));\n-\t\tinjectMethod(builderType, generateAbstractBuildMethod(tdParent, buildMethodName, superclassBuilderClassName != null));\n+\t\tinjectMethod(builderType, generateAbstractSelfMethod(tdParent, superclassBuilderClassExpression != null));\n+\t\tinjectMethod(builderType, generateAbstractBuildMethod(tdParent, buildMethodName, superclassBuilderClassExpression != null));\n \n \t\t// Create the setter methods in the abstract builder.\n \t\tfor (BuilderFieldData bfd : builderFields) {\n@@ -535,7 +539,7 @@ public JavacNode findInnerClass(JavacNode parent, String name) {\n \t\treturn null;\n \t}\n \t\n-\tpublic JavacNode makeBuilderClass(JavacNode source, JavacNode tdParent, String builderClass, String parentBuilderClass, List<JCTypeParameter> typeParams, JCAnnotation ast) {\n+\tpublic JavacNode makeBuilderClass(JavacNode source, JavacNode tdParent, String builderClass, JCExpression superclassBuilderClassExpression, List<JCTypeParameter> typeParams, JCAnnotation ast) {\n \t\tJavacTreeMaker maker = tdParent.getTreeMaker();\n \t\tJCModifiers mods = maker.Modifiers(Flags.STATIC | Flags.ABSTRACT | Flags.PUBLIC);\n \n@@ -554,10 +558,9 @@ public JavacNode makeBuilderClass(JavacNode source, JavacNode tdParent, String b\n \t\tallTypeParams.add(maker.TypeParameter(tdParent.toName(\"B\"), List.<JCExpression>of(typeApply)));\n \n \t\tJCExpression extending = null;\n-\t\tif (parentBuilderClass != null) {\n+\t\tif (superclassBuilderClassExpression != null) {\n \t\t\t// If the annotated class extends another class, we want this builder to extend the builder of the superclass.\n-\t\t\t// FIXME: The extends clause should look like \"Parent.ParentBuilder\", not just \"ParentBuilder\" (risk of name clashes).\n-\t\t\textending = maker.TypeApply(maker.Ident(tdParent.toName(parentBuilderClass)), \n+\t\t\textending = maker.TypeApply(superclassBuilderClassExpression, \n \t\t\t\t\tList.<JCExpression>of(maker.Ident(tdParent.toName(\"C\")), maker.Ident(tdParent.toName(\"B\"))));\n \t\t\t// TODO: type params from annotated class\n \t\t}",
      "parent_sha": "9a3866ef52186bde47a698230ba9498df378768d"
    }
  },
  {
    "oid": "2611e6bf9830e4971dcae3abedfede59f3cc86a5",
    "message": "Revert \"[val] in ecj we were constructing a different type than for javac, when using \u2018val\u2019 on an intersection type.\"\n\nThis reverts commit 1730a991",
    "date": "2019-05-03T19:07:43Z",
    "url": "https://github.com/projectlombok/lombok/commit/2611e6bf9830e4971dcae3abedfede59f3cc86a5",
    "details": {
      "sha": "12f4ad3d450f275d80b05735e1a4b734ab538c0d",
      "filename": "src/eclipseAgent/lombok/eclipse/agent/PatchVal.java",
      "status": "modified",
      "additions": 5,
      "deletions": 9,
      "changes": 14,
      "blob_url": "https://github.com/projectlombok/lombok/blob/2611e6bf9830e4971dcae3abedfede59f3cc86a5/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchVal.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/2611e6bf9830e4971dcae3abedfede59f3cc86a5/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchVal.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchVal.java?ref=2611e6bf9830e4971dcae3abedfede59f3cc86a5",
      "patch": "@@ -263,15 +263,11 @@ public static boolean handleValForLocalDeclaration(LocalDeclaration local, Block\n \t\t\t\tresolved = null;\n \t\t\t}\n \t\t\tif (resolved != null) {\n-\t\t\t\tif (resolved.getClass().getSimpleName().startsWith(\"IntersectionTypeBinding\")) {\n-\t\t\t\t\t// We intentionally deconstruct these into simply 'Object', because picking an arbitrary type amongst the intersection feels worse.\n-\t\t\t\t} else {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\treplacement = makeType(resolved, local.type, false);\n-\t\t\t\t\t\tif (!decomponent) init.resolvedType = replacement.resolveType(scope);\n-\t\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\t\t// Some type thing failed.\n-\t\t\t\t\t}\n+\t\t\t\ttry {\n+\t\t\t\t\treplacement = makeType(resolved, local.type, false);\n+\t\t\t\t\tif (!decomponent) init.resolvedType = replacement.resolveType(scope);\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t// Some type thing failed.\n \t\t\t\t}\n \t\t\t}\n \t\t}",
      "parent_sha": "715c731fc24bf2915d2eaefefd964615e62c12ed"
    }
  },
  {
    "oid": "caaa578ea21108d171b53d94882e18819617014b",
    "message": "--help now no longer prints errors.",
    "date": "2009-11-27T15:12:25Z",
    "url": "https://github.com/projectlombok/lombok/commit/caaa578ea21108d171b53d94882e18819617014b",
    "details": {
      "sha": "f6a62befe82213af996de9d32e976375a6a5b2b1",
      "filename": "src/delombok/lombok/delombok/Delombok.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/projectlombok/lombok/blob/caaa578ea21108d171b53d94882e18819617014b/src%2Fdelombok%2Flombok%2Fdelombok%2FDelombok.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/caaa578ea21108d171b53d94882e18819617014b/src%2Fdelombok%2Flombok%2Fdelombok%2FDelombok.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fdelombok%2Flombok%2Fdelombok%2FDelombok.java?ref=caaa578ea21108d171b53d94882e18819617014b",
      "patch": "@@ -78,7 +78,7 @@ private static class CmdArgs {\n \t\t\n \t\t@Shorthand(\"d\")\n \t\t@Description(\"Directory to save delomboked files to\")\n-\t\t@Mandatory(onlyIfNot=\"print\")\n+\t\t@Mandatory(onlyIfNot={\"print\", \"help\"})\n \t\t@Parameterized\n \t\tprivate String target;\n \t\t\n@@ -103,9 +103,9 @@ public static void main(String[] rawArgs) {\n \t\t}\n \t\t\n \t\tif (args.help || args.input.isEmpty()) {\n-\t\t\tif (args.input.isEmpty()) System.err.println(\"ERROR: no files or directories to delombok specified.\");\n+\t\t\tif (!args.help) System.err.println(\"ERROR: no files or directories to delombok specified.\");\n \t\t\tSystem.err.println(reader.generateCommandLineHelp(\"delombok\"));\n-\t\t\tSystem.exit(args.input.isEmpty() ? 1 : 0);\n+\t\t\tSystem.exit(args.help ? 0 : 1);\n \t\t\treturn;\n \t\t}\n \t\t",
      "parent_sha": "2caddc3c2a4431aa5d2ffd4e4d1840dbd7c09a64"
    }
  },
  {
    "oid": "0e9b161b6f8781f77684844f9dee7a9173ff7de8",
    "message": "[trivial]",
    "date": "2024-10-17T22:11:37Z",
    "url": "https://github.com/projectlombok/lombok/commit/0e9b161b6f8781f77684844f9dee7a9173ff7de8",
    "details": {
      "sha": "1b005c57d1ed334190c6d03fc5411b4f36167a61",
      "filename": "src/eclipseAgent/lombok/launch/PatchFixesHider.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/projectlombok/lombok/blob/0e9b161b6f8781f77684844f9dee7a9173ff7de8/src%2FeclipseAgent%2Flombok%2Flaunch%2FPatchFixesHider.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/0e9b161b6f8781f77684844f9dee7a9173ff7de8/src%2FeclipseAgent%2Flombok%2Flaunch%2FPatchFixesHider.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2FeclipseAgent%2Flombok%2Flaunch%2FPatchFixesHider.java?ref=0e9b161b6f8781f77684844f9dee7a9173ff7de8",
      "patch": "@@ -896,7 +896,7 @@ public static boolean isEmpty(char[] array) {\n \t\t\treturn array.length == 0;\n \t\t}\n \t\t\n-\t\tpublic static Expression returnNullExpression(Object string) {\n+\t\tpublic static Expression returnNullExpression(Object arg0) {\n \t\t\treturn null;\n \t\t}\n \t\t",
      "parent_sha": "1ac535f644d62d2a8c3151fb8e8fef8e829b0123"
    }
  },
  {
    "oid": "794801c3c9dc4f62906ac5d493b5e60473a91c47",
    "message": "Removed the equalsPrime thing, because that's just needlessly putting implementation details in there. If switching primes is so important, hash the type name and turn that into a prime, or something.\n\nAlso added some javadoc.",
    "date": "2009-06-23T03:56:00Z",
    "url": "https://github.com/projectlombok/lombok/commit/794801c3c9dc4f62906ac5d493b5e60473a91c47",
    "details": {
      "sha": "f9b02b52e57c77d051ce39581dd8b7491619330f",
      "filename": "src/lombok/Data.java",
      "status": "modified",
      "additions": 11,
      "deletions": 1,
      "changes": 12,
      "blob_url": "https://github.com/projectlombok/lombok/blob/794801c3c9dc4f62906ac5d493b5e60473a91c47/src%2Flombok%2FData.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/794801c3c9dc4f62906ac5d493b5e60473a91c47/src%2Flombok%2FData.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Flombok%2FData.java?ref=794801c3c9dc4f62906ac5d493b5e60473a91c47",
      "patch": "@@ -8,6 +8,16 @@\n @Target(ElementType.TYPE)\n @Retention(RetentionPolicy.SOURCE)\n public @interface Data {\n+\t/**\n+\t * If you specify a static constructor name, then the generated constructor will be private, and\n+\t * instead a static factory method is created that other classes can use to create instances.\n+\t * We suggest the name: \"of\", like so:\n+\t * \n+\t * <pre>\n+\t *     public @Data(staticConstructor = \"of\") class Point { final int x, y; }\n+\t * </pre>\n+\t * \n+\t * Default: No static constructor, instead the normal constructor is public.\n+\t */\n \tString staticConstructor() default \"\";\n-\tint hashCodePrime() default 31;\n }",
      "parent_sha": "fdde039d2354d01481f22ebadf83f552d6cf9f50"
    }
  },
  {
    "oid": "7069c7e90377952ae7c9a7dfd6786205dfe7ec5f",
    "message": "[fixes #2810] Use MethodHandler instead of reflective defineClass",
    "date": "2021-04-11T18:03:39Z",
    "url": "https://github.com/projectlombok/lombok/commit/7069c7e90377952ae7c9a7dfd6786205dfe7ec5f",
    "details": {
      "sha": "402d6747068ff326eb3e63923307494cba4a5a89",
      "filename": "src/eclipseAgent/lombok/eclipse/agent/EclipseLoaderPatcherTransplants.java",
      "status": "modified",
      "additions": 30,
      "deletions": 1,
      "changes": 31,
      "blob_url": "https://github.com/projectlombok/lombok/blob/7069c7e90377952ae7c9a7dfd6786205dfe7ec5f/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FEclipseLoaderPatcherTransplants.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/7069c7e90377952ae7c9a7dfd6786205dfe7ec5f/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FEclipseLoaderPatcherTransplants.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FEclipseLoaderPatcherTransplants.java?ref=7069c7e90377952ae7c9a7dfd6786205dfe7ec5f",
      "patch": "@@ -77,6 +77,35 @@ public static Class overrideLoadResult(ClassLoader original, String name, boolea\n \t\t\t\t\t\t\t\t\tif (len == bytes.length) throw new IllegalStateException(\"lombok.launch.ShadowClassLoader too large.\");\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tin.close();\n+\t\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\t\t/* Since Java 16 reflective access to ClassLoader.defineClass is no longer permitted. The recommended solution \n+\t\t\t\t\t\t\t\t\t * is to use MethodHandles.lookup().defineClass which is useless here because it is limited to classes in the\n+\t\t\t\t\t\t\t\t\t * same package. Fortunately this code gets transplanted into a ClassLoader and we can call the parent method\n+\t\t\t\t\t\t\t\t\t * using a MethodHandle. To support old Java versions we use a reflective version of the code snippet below.\n+\t\t\t\t\t\t\t\t\t * \n+\t\t\t\t\t\t\t\t\t * Lookup lookup = MethodHandles.lookup();\n+\t\t\t\t\t\t\t\t\t * MethodType type = MethodType.methodType(Class.class, new Class[] {String.class, byte[].class, int.class, int.class});\n+\t\t\t\t\t\t\t\t\t * MethodHandle method = lookup.findVirtual(original.getClass(), \"defineClass\", type);\n+\t\t\t\t\t\t\t\t\t * shadowClassLoaderClass = (Class) method.invokeWithArguments(original, \"lombok.launch.ShadowClassLoader\", bytes, new Integer(0), new Integer(len)}) \n+\t\t\t\t\t\t\t\t\t */\n+\t\t\t\t\t\t\t\t\tClass methodHandles = Class.forName(\"java.lang.invoke.MethodHandles\");\n+\t\t\t\t\t\t\t\t\tClass methodHandle = Class.forName(\"java.lang.invoke.MethodHandle\");\n+\t\t\t\t\t\t\t\t\tClass methodType = Class.forName(\"java.lang.invoke.MethodType\");\n+\t\t\t\t\t\t\t\t\tClass methodHandlesLookup = Class.forName(\"java.lang.invoke.MethodHandles$Lookup\");\n+\t\t\t\t\t\t\t\t\tMethod lookupMethod = methodHandles.getDeclaredMethod(\"lookup\", null);\n+\t\t\t\t\t\t\t\t\tMethod methodTypeMethod = methodType.getDeclaredMethod(\"methodType\", new Class[] {Class.class, Class[].class});\n+\t\t\t\t\t\t\t\t\tMethod findVirtualMethod = methodHandlesLookup.getDeclaredMethod(\"findVirtual\", new Class[] {Class.class, String.class, methodType});\n+\t\t\t\t\t\t\t\t\tMethod invokeMethod = methodHandle.getDeclaredMethod(\"invokeWithArguments\", new Class[] {Object[].class});\n+\t\t\t\t\t\t\t\t\t\n+\t\t\t\t\t\t\t\t\tObject lookup = lookupMethod.invoke(null, null);\n+\t\t\t\t\t\t\t\t\tObject type = methodTypeMethod.invoke(null, new Object[] {Class.class, new Class[] {String.class, byte[].class, int.class, int.class}});\n+\t\t\t\t\t\t\t\t\tObject method = findVirtualMethod.invoke(lookup, new Object[] {original.getClass(), \"defineClass\", type});\n+\t\t\t\t\t\t\t\t\tshadowClassLoaderClass = (Class) invokeMethod.invoke(method, new Object[] {new Object[] {original, \"lombok.launch.ShadowClassLoader\", bytes, new Integer(0), new Integer(len)}});\n+\t\t\t\t\t\t\t\t} catch (ClassNotFoundException e) {\n+\t\t\t\t\t\t\t\t\t// Ignore, old Java\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tif (shadowClassLoaderClass == null)\n \t\t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\t\tClass[] paramTypes = new Class[4];\n \t\t\t\t\t\t\t\t\tparamTypes[0] = \"\".getClass();\n@@ -86,8 +115,8 @@ public static Class overrideLoadResult(ClassLoader original, String name, boolea\n \t\t\t\t\t\t\t\t\tMethod defineClassMethod = classLoaderClass.getDeclaredMethod(\"defineClass\", paramTypes);\n \t\t\t\t\t\t\t\t\tdefineClassMethod.setAccessible(true);\n \t\t\t\t\t\t\t\t\tshadowClassLoaderClass = (Class) defineClassMethod.invoke(original, new Object[] {\"lombok.launch.ShadowClassLoader\", bytes, new Integer(0), new Integer(len)});\n-\t\t\t\t\t\t\t\t\toriginal.getClass().getField(\"lombok$shadowLoaderClass\").set(null, shadowClassLoaderClass);\n \t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\toriginal.getClass().getField(\"lombok$shadowLoaderClass\").set(null, shadowClassLoaderClass);\n \t\t\t\t\t\t\t} finally {\n \t\t\t\t\t\t\t\tif (in != null) in.close();\n \t\t\t\t\t\t\t\tjf.close();",
      "parent_sha": "9e52cf0947db302375a910d5d32e39e41656d96e"
    }
  },
  {
    "oid": "1730a991b50439f91bba217bb49edc860915ee70",
    "message": "[val] in ecj we were constructing a different type than for javac, when using \u2018val\u2019 on an intersection type.",
    "date": "2019-04-24T11:52:49Z",
    "url": "https://github.com/projectlombok/lombok/commit/1730a991b50439f91bba217bb49edc860915ee70",
    "details": {
      "sha": "b32c99cd324cc4707d74c948d5c349ada1848e17",
      "filename": "src/eclipseAgent/lombok/eclipse/agent/PatchVal.java",
      "status": "modified",
      "additions": 9,
      "deletions": 5,
      "changes": 14,
      "blob_url": "https://github.com/projectlombok/lombok/blob/1730a991b50439f91bba217bb49edc860915ee70/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchVal.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/1730a991b50439f91bba217bb49edc860915ee70/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchVal.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchVal.java?ref=1730a991b50439f91bba217bb49edc860915ee70",
      "patch": "@@ -263,11 +263,15 @@ public static boolean handleValForLocalDeclaration(LocalDeclaration local, Block\n \t\t\t\tresolved = null;\n \t\t\t}\n \t\t\tif (resolved != null) {\n-\t\t\t\ttry {\n-\t\t\t\t\treplacement = makeType(resolved, local.type, false);\n-\t\t\t\t\tif (!decomponent) init.resolvedType = replacement.resolveType(scope);\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\t// Some type thing failed.\n+\t\t\t\tif (resolved.getClass().getSimpleName().startsWith(\"IntersectionTypeBinding\")) {\n+\t\t\t\t\t// We intentionally deconstruct these into simply 'Object', because picking an arbitrary type amongst the intersection feels worse.\n+\t\t\t\t} else {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\treplacement = makeType(resolved, local.type, false);\n+\t\t\t\t\t\tif (!decomponent) init.resolvedType = replacement.resolveType(scope);\n+\t\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t\t// Some type thing failed.\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}",
      "parent_sha": "ccaefff69fc021048ac6918948a0cae29e045b76"
    }
  },
  {
    "oid": "3127930afa4866ad5e1b45e700045ad656cd2d9e",
    "message": "Make it possible to copy from the release notes",
    "date": "2017-02-09T21:52:38Z",
    "url": "https://github.com/projectlombok/lombok/commit/3127930afa4866ad5e1b45e700045ad656cd2d9e",
    "details": {
      "sha": "5c0efcb4b6ce7770ff8473e15efe5742900d0570",
      "filename": "src/installer/lombok/installer/InstallerGUI.java",
      "status": "modified",
      "additions": 14,
      "deletions": 9,
      "changes": 23,
      "blob_url": "https://github.com/projectlombok/lombok/blob/3127930afa4866ad5e1b45e700045ad656cd2d9e/src%2Finstaller%2Flombok%2Finstaller%2FInstallerGUI.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/3127930afa4866ad5e1b45e700045ad656cd2d9e/src%2Finstaller%2Flombok%2Finstaller%2FInstallerGUI.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Finstaller%2Flombok%2Finstaller%2FInstallerGUI.java?ref=3127930afa4866ad5e1b45e700045ad656cd2d9e",
      "patch": "@@ -64,11 +64,12 @@\n import javax.swing.JOptionPane;\n import javax.swing.JPanel;\n import javax.swing.JScrollPane;\n+import javax.swing.JTextPane;\n import javax.swing.Scrollable;\n import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n import javax.swing.filechooser.FileFilter;\n-import javax.swing.plaf.basic.BasicHTML;\n-import javax.swing.text.View;\n+import javax.swing.text.html.HTMLDocument;\n \n import lombok.core.Version;\n import lombok.installer.OsUtils.OS;\n@@ -199,19 +200,23 @@ private Component buildSuccessArea() {\n \t\tconstraints.gridy++;\n \t\tconstraints.fill = GridBagConstraints.BOTH;\n \t\t\n-\t\tJLabel notes = new JLabel();\n+\t\tJTextPane notes = new JTextPane();\n+\t\tnotes.setContentType(\"text/html\");\n \t\tnotes.setText(readChangeLog());\n+\t\tnotes.setEditable(false);\n+\t\tnotes.setOpaque(false);\n+\t\tnotes.setBorder(null);\n+\t\tnotes.setSelectionStart(0);\n+\t\tnotes.setSelectionEnd(0);\n+\t\t\n+\t\tFont font = UIManager.getFont(\"Label.font\");\n+\t\tString bodyRule = \"body { font-family: \" + font.getFamily() + \"; font-size: \" + font.getSize() + \"pt; }\";\n+\t\t((HTMLDocument)notes.getDocument()).getStyleSheet().addRule(bodyRule);\n \t\t\n \t\tJScrollPane scroller = new JScrollPane(notes);\n \t\tcontainer.add(scroller, constraints);\n \t\tscroller.setPreferredSize(new Dimension(380, 240));\n \t\t\n-\t\tView view = (View) notes.getClientProperty(BasicHTML.propertyKey);\n-\t\tview.setSize(380, 0.0f);\n-\t\tfloat w = view.getPreferredSpan(View.X_AXIS);\n-\t\tfloat h = view.getPreferredSpan(View.Y_AXIS);\n-\t\tnotes.setSize((int) w, (int) h);\n-\t\t\n \t\tcontainer.setPreferredSize(new Dimension(462, 415));\n \t\treturn container;\n \t}",
      "parent_sha": "70f77f928ac7a6edf3ef91a41399c9a79561c871"
    }
  },
  {
    "oid": "0736f291747b1fc4d3ce3b7d9ccbaa129d15ed20",
    "message": "Skip PostCompiler for empty byte arrays",
    "date": "2020-08-27T20:57:07Z",
    "url": "https://github.com/projectlombok/lombok/commit/0736f291747b1fc4d3ce3b7d9ccbaa129d15ed20",
    "details": {
      "sha": "72f4b3a2391c20983ad29fde0cb1c76d67a3bbea",
      "filename": "src/core/lombok/core/PostCompiler.java",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/projectlombok/lombok/blob/0736f291747b1fc4d3ce3b7d9ccbaa129d15ed20/src%2Fcore%2Flombok%2Fcore%2FPostCompiler.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/0736f291747b1fc4d3ce3b7d9ccbaa129d15ed20/src%2Fcore%2Flombok%2Fcore%2FPostCompiler.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fcore%2FPostCompiler.java?ref=0736f291747b1fc4d3ce3b7d9ccbaa129d15ed20",
      "patch": "@@ -72,10 +72,12 @@ public static OutputStream wrapOutputStream(final OutputStream originalStream, f\n \t\t\t\t// no need to call super\n \t\t\t\tbyte[] original = toByteArray();\n \t\t\t\tbyte[] copy = null;\n-\t\t\t\ttry {\n-\t\t\t\t\tcopy = applyTransformations(original, fileName, diagnostics);\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tdiagnostics.addWarning(String.format(\"Error during the transformation of '%s'; no post-compilation has been applied\", fileName));\n+\t\t\t\tif (original.length > 0) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tcopy = applyTransformations(original, fileName, diagnostics);\n+\t\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t\tdiagnostics.addWarning(String.format(\"Error during the transformation of '%s'; no post-compilation has been applied\", fileName));\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\t\n \t\t\t\tif (copy == null) {",
      "parent_sha": "2ac4faf14cfb4e82b771f8691704efd3c36299ea"
    }
  },
  {
    "oid": "a9113718ae2adc2d837f9e5a1adf885a4b1aa844",
    "message": "Set generated on all created ASTNodes",
    "date": "2010-11-11T04:54:42Z",
    "url": "https://github.com/projectlombok/lombok/commit/a9113718ae2adc2d837f9e5a1adf885a4b1aa844",
    "details": {
      "sha": "8778b22b542757e02f846161c21475a68bb6c755",
      "filename": "src/core/lombok/eclipse/Eclipse.java",
      "status": "modified",
      "additions": 38,
      "deletions": 12,
      "changes": 50,
      "blob_url": "https://github.com/projectlombok/lombok/blob/a9113718ae2adc2d837f9e5a1adf885a4b1aa844/src%2Fcore%2Flombok%2Feclipse%2FEclipse.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/a9113718ae2adc2d837f9e5a1adf885a4b1aa844/src%2Fcore%2Flombok%2Feclipse%2FEclipse.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Feclipse%2FEclipse.java?ref=a9113718ae2adc2d837f9e5a1adf885a4b1aa844",
      "patch": "@@ -352,16 +352,24 @@ public static TypeReference makeType(TypeBinding binding, ASTNode pos, boolean a\n \t\t\n \t\tif (base != null) {\n \t\t\tif (dims > 0) {\n-\t\t\t\treturn new ArrayTypeReference(base, dims, pos(pos));\n+\t\t\t\tTypeReference result = new ArrayTypeReference(base, dims, pos(pos));\n+\t\t\t\tEclipse.setGeneratedBy(result, pos);\n+\t\t\t\treturn result;\n \t\t\t}\n-\t\t\treturn new SingleTypeReference(base, pos(pos));\n+\t\t\tTypeReference result = new SingleTypeReference(base, pos(pos));\n+\t\t\tEclipse.setGeneratedBy(result, pos);\n+\t\t\treturn result;\n \t\t}\n \t\t\n \t\tif (binding.isAnonymousType()) {\n \t\t\tReferenceBinding ref = (ReferenceBinding)binding;\n \t\t\tReferenceBinding[] supers = ref.superInterfaces();\n \t\t\tif (supers == null || supers.length == 0) supers = new ReferenceBinding[] {ref.superclass()};\n-\t\t\tif (supers[0] == null) return new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, poss(pos, 3));\n+\t\t\tif (supers[0] == null) {\n+\t\t\t\tTypeReference result = new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, poss(pos, 3));\n+\t\t\t\tEclipse.setGeneratedBy(result, pos);\n+\t\t\t\treturn result;\n+\t\t\t}\n \t\t\treturn makeType(supers[0], pos, false);\n \t\t}\n \t\t\n@@ -371,9 +379,12 @@ public static TypeReference makeType(TypeBinding binding, ASTNode pos, boolean a\n \t\t\n \t\tif (binding.isUnboundWildcard()) {\n \t\t\tif (!allowCompound) {\n-\t\t\t\treturn new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, poss(pos, 3));\n+\t\t\t\tTypeReference result = new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, poss(pos, 3));\n+\t\t\t\tEclipse.setGeneratedBy(result, pos);\n+\t\t\t\treturn result;\n \t\t\t} else {\n \t\t\t\tWildcard out = new Wildcard(Wildcard.UNBOUND);\n+\t\t\t\tEclipse.setGeneratedBy(out, pos);\n \t\t\t\tout.sourceStart = pos.sourceStart;\n \t\t\t\tout.sourceEnd = pos.sourceEnd;\n \t\t\t\treturn out;\n@@ -387,19 +398,23 @@ public static TypeReference makeType(TypeBinding binding, ASTNode pos, boolean a\n \t\t\t\t\treturn makeType(wildcard.bound, pos, false);\n \t\t\t\t} else {\n \t\t\t\t\tWildcard out = new Wildcard(Wildcard.EXTENDS);\n+\t\t\t\t\tEclipse.setGeneratedBy(out, pos);\n \t\t\t\t\tout.bound = makeType(wildcard.bound, pos, false);\n \t\t\t\t\tout.sourceStart = pos.sourceStart;\n \t\t\t\t\tout.sourceEnd = pos.sourceEnd;\n \t\t\t\t\treturn out;\n \t\t\t\t}\n \t\t\t} else if (allowCompound && wildcard.boundKind == Wildcard.SUPER) {\n \t\t\t\tWildcard out = new Wildcard(Wildcard.SUPER);\n+\t\t\t\tEclipse.setGeneratedBy(out, pos);\n \t\t\t\tout.bound = makeType(wildcard.bound, pos, false);\n \t\t\t\tout.sourceStart = pos.sourceStart;\n \t\t\t\tout.sourceEnd = pos.sourceEnd;\n \t\t\t\treturn out;\n \t\t\t} else {\n-\t\t\t\treturn new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, poss(pos, 3));\n+\t\t\t\tTypeReference result = new QualifiedTypeReference(TypeConstants.JAVA_LANG_OBJECT, poss(pos, 3));\n+\t\t\t\tEclipse.setGeneratedBy(result, pos);\n+\t\t\t\treturn result;\n \t\t\t}\n \t\t}\n \t\t\n@@ -433,23 +448,34 @@ public static TypeReference makeType(TypeBinding binding, ASTNode pos, boolean a\n \t\t\tif (parts.length > 1) {\n \t\t\t\tTypeReference[][] typeArguments = new TypeReference[parts.length][];\n \t\t\t\ttypeArguments[typeArguments.length - 1] = params;\n-\t\t\t\treturn new ParameterizedQualifiedTypeReference(parts, typeArguments, dims, poss(pos, parts.length));\n+\t\t\t\tTypeReference result = new ParameterizedQualifiedTypeReference(parts, typeArguments, dims, poss(pos, parts.length));\n+\t\t\t\tEclipse.setGeneratedBy(result, pos);\n+\t\t\t\treturn result;\n \t\t\t}\n-\t\t\treturn new ParameterizedSingleTypeReference(parts[0], params, dims, pos(pos));\n+\t\t\tTypeReference result = new ParameterizedSingleTypeReference(parts[0], params, dims, pos(pos));\n+\t\t\tEclipse.setGeneratedBy(result, pos);\n+\t\t\treturn result;\n \t\t}\n \t\t\n \t\tif (dims > 0) {\n \t\t\tif (parts.length > 1) {\n-\t\t\t\treturn new ArrayQualifiedTypeReference(parts, dims, poss(pos, parts.length));\n+\t\t\t\tTypeReference result = new ArrayQualifiedTypeReference(parts, dims, poss(pos, parts.length));\n+\t\t\t\tEclipse.setGeneratedBy(result, pos);\n+\t\t\t\treturn result;\n \t\t\t}\n-\t\t\treturn new ArrayTypeReference(parts[0], dims, pos(pos));\n+\t\t\tTypeReference result = new ArrayTypeReference(parts[0], dims, pos(pos));\n+\t\t\tEclipse.setGeneratedBy(result, pos);\n+\t\t\treturn result;\n \t\t}\n \t\t\n \t\tif (parts.length > 1) {\n-\t\t\treturn new QualifiedTypeReference(parts, poss(pos, parts.length));\n+\t\t\tTypeReference result = new QualifiedTypeReference(parts, poss(pos, parts.length));\n+\t\t\tEclipse.setGeneratedBy(result, pos);\n+\t\t\treturn result;\n \t\t}\n-\t\treturn new SingleTypeReference(parts[0], pos(pos));\n-\t\t\n+\t\tTypeReference result = new SingleTypeReference(parts[0], pos(pos));\n+\t\tEclipse.setGeneratedBy(result, pos);\n+\t\treturn result;\n \t}\n \t\n \tprivate static final Annotation[] EMPTY_ANNOTATION_ARRAY = new Annotation[0];",
      "parent_sha": "ddf54dcfaea71e50ae32b45785b8624b9137843b"
    }
  },
  {
    "oid": "2bacfa62a330e1274ee89c76fa22a36116f8fa3d",
    "message": "Should be a fix for issue #177: NoClassDefFoundErrors for JavacProcessingEnvironment would occur when using the m2eclipse plugin, for example when removing an entry from the build path.\n\nThe actual change is small but this took quite some searching. m2eclipse uses plexus, and plexus uses a custom classloader, which means lombok can't find the JavacProcessingEnvironment loaded by that classloader.\n\nWe fix it here by adding lombok to that custom classloader. Perhaps more die-hard m2eclipse users find a problem with this approach, but assuming these plexus compile runs are stand-alone, this should work great.\n\nfixed by Roel and Reinier.",
    "date": "2011-02-14T23:07:34Z",
    "url": "https://github.com/projectlombok/lombok/commit/2bacfa62a330e1274ee89c76fa22a36116f8fa3d",
    "details": {
      "sha": "ad7c58b98999eb1fb3c29be95ff51ff0860b9907",
      "filename": "src/core/lombok/core/AnnotationProcessor.java",
      "status": "modified",
      "additions": 27,
      "deletions": 3,
      "changes": 30,
      "blob_url": "https://github.com/projectlombok/lombok/blob/2bacfa62a330e1274ee89c76fa22a36116f8fa3d/src%2Fcore%2Flombok%2Fcore%2FAnnotationProcessor.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/2bacfa62a330e1274ee89c76fa22a36116f8fa3d/src%2Fcore%2Flombok%2Fcore%2FAnnotationProcessor.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fcore%2FAnnotationProcessor.java?ref=2bacfa62a330e1274ee89c76fa22a36116f8fa3d",
      "patch": "@@ -21,12 +21,17 @@\n  */\n package lombok.core;\n \n+import java.io.File;\n import java.io.PrintWriter;\n import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n+import java.util.WeakHashMap;\n \n import javax.annotation.processing.AbstractProcessor;\n import javax.annotation.processing.ProcessingEnvironment;\n@@ -39,6 +44,8 @@\n import javax.lang.model.element.TypeElement;\n import javax.tools.Diagnostic.Kind;\n \n+import lombok.patcher.inject.LiveInjector;\n+\n @SupportedAnnotationTypes(\"*\")\n @SupportedSourceVersion(SourceVersion.RELEASE_6)\n public class AnnotationProcessor extends AbstractProcessor {\n@@ -58,6 +65,8 @@ static abstract class ProcessorDescriptor {\n \tprivate final List<ProcessorDescriptor> active = new ArrayList<ProcessorDescriptor>();\n \tprivate final List<String> delayedWarnings = new ArrayList<String>();\n \t\n+\tprivate static final Map<ClassLoader, Boolean> lombokAlreadyAddedTo = new WeakHashMap<ClassLoader, Boolean>();\n+\t\n \tstatic class JavacDescriptor extends ProcessorDescriptor {\n \t\tprivate Processor processor;\n \t\t\n@@ -69,16 +78,31 @@ static class JavacDescriptor extends ProcessorDescriptor {\n \t\t\tif (!procEnv.getClass().getName().equals(\"com.sun.tools.javac.processing.JavacProcessingEnvironment\")) return false;\n \t\t\t\n \t\t\ttry {\n-\t\t\t\tprocessor = (Processor)Class.forName(\"lombok.javac.apt.Processor\").newInstance();\n+\t\t\t\tClassLoader toFix = procEnv.getClass().getClassLoader();\n+\t\t\t\tif (toFix.getClass().getCanonicalName().equals(\"org.codehaus.plexus.compiler.javac.IsolatedClassLoader\")) {\n+\t\t\t\t\tif (lombokAlreadyAddedTo.put(toFix, true) == null) {\n+\t\t\t\t\t\tMethod m = toFix.getClass().getDeclaredMethod(\"addURL\", URL.class);\n+\t\t\t\t\t\tURL selfUrl = new File(LiveInjector.findPathJar(AnnotationProcessor.class)).toURI().toURL();\n+\t\t\t\t\t\tm.invoke(toFix, selfUrl);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tprocessor = (Processor)Class.forName(\"lombok.javac.apt.Processor\", false, procEnv.getClass().getClassLoader()).newInstance();\n \t\t\t} catch (Exception e) {\n \t\t\t\tdelayedWarnings.add(\"You found a bug in lombok; lombok.javac.apt.Processor is not available. Lombok will not run during this compilation: \" + trace(e));\n \t\t\t\treturn false;\n \t\t\t} catch (NoClassDefFoundError e) {\n \t\t\t\tdelayedWarnings.add(\"Can't load javac processor due to (most likely) a class loader problem: \" + trace(e));\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\t\n-\t\t\tprocessor.init(procEnv);\n+\t\t\ttry {\n+\t\t\t\tprocessor.init(procEnv);\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tdelayedWarnings.add(\"lombok.javac.apt.Processor could not be initialized. Lombok will not run during this compilation: \" + trace(e));\n+\t\t\t\treturn false;\n+\t\t\t} catch (NoClassDefFoundError e) {\n+\t\t\t\tdelayedWarnings.add(\"Can't initialize javac processor due to (most likely) a class loader problem: \" + trace(e));\n+\t\t\t\treturn false;\n+\t\t\t}\n \t\t\treturn true;\n \t\t}\n \t\t",
      "parent_sha": "ed4068d84289390c74ca2e45149c9a22f96ce764"
    }
  },
  {
    "oid": "92bc41ae6dce8e16fd9da64c08ad085822fd33ed",
    "message": "[debugging] Improved the ecj AST printer",
    "date": "2018-09-03T23:54:16Z",
    "url": "https://github.com/projectlombok/lombok/commit/92bc41ae6dce8e16fd9da64c08ad085822fd33ed",
    "details": {
      "sha": "37bda5e3a87e422f25eb358b5ea3c8df26e35584",
      "filename": "src/core/lombok/eclipse/EclipseASTVisitor.java",
      "status": "modified",
      "additions": 22,
      "deletions": 1,
      "changes": 23,
      "blob_url": "https://github.com/projectlombok/lombok/blob/92bc41ae6dce8e16fd9da64c08ad085822fd33ed/src%2Fcore%2Flombok%2Feclipse%2FEclipseASTVisitor.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/92bc41ae6dce8e16fd9da64c08ad085822fd33ed/src%2Fcore%2Flombok%2Feclipse%2FEclipseASTVisitor.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Feclipse%2FEclipseASTVisitor.java?ref=92bc41ae6dce8e16fd9da64c08ad085822fd33ed",
      "patch": "@@ -34,9 +34,14 @@\n import org.eclipse.jdt.internal.compiler.ast.Block;\n import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\n import org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;\n+import org.eclipse.jdt.internal.compiler.ast.Expression;\n import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;\n import org.eclipse.jdt.internal.compiler.ast.Initializer;\n import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;\n+import org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation;\n+import org.eclipse.jdt.internal.compiler.ast.MemberValuePair;\n+import org.eclipse.jdt.internal.compiler.ast.NormalAnnotation;\n+import org.eclipse.jdt.internal.compiler.ast.SingleMemberAnnotation;\n import org.eclipse.jdt.internal.compiler.ast.Statement;\n import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\n import org.eclipse.jdt.internal.compiler.ast.TypeReference;\n@@ -351,7 +356,23 @@ public void visitMethod(EclipseNode node, AbstractMethodDeclaration method) {\n \t\t}\n \t\t\n \t\tpublic void visitAnnotationOnMethod(AbstractMethodDeclaration method, EclipseNode node, Annotation annotation) {\n-\t\t\tforcePrint(\"<ANNOTATION%s: %s%s />\", isGenerated(method) ? \" (GENERATED)\" : \"\", annotation, position(node));\n+\t\t\tforcePrint(\"<ANNOTATION%s: %s%s>\", isGenerated(method) ? \" (GENERATED)\" : \"\", annotation, position(node));\n+\t\t\tif (annotation instanceof MarkerAnnotation || disablePrinting != 0) {\n+\t\t\t\tforcePrint(\"<ANNOTATION%s: %s%s />\", isGenerated(method) ? \" (GENERATED)\" : \"\", annotation, position(node));\n+\t\t\t} else {\n+\t\t\t\tforcePrint(\"<ANNOTATION%s: %s%s>\", isGenerated(method) ? \" (GENERATED)\" : \"\", annotation, position(node));\n+\t\t\t\tindent++;\n+\t\t\t\tif (annotation instanceof SingleMemberAnnotation) {\n+\t\t\t\t\tExpression expr = ((SingleMemberAnnotation) annotation).memberValue;\n+\t\t\t\t\tprint(\"<SINGLE-MEMBER-VALUE %s /> %s\", expr.getClass(), expr);\n+\t\t\t\t}\n+\t\t\t\tif (annotation instanceof NormalAnnotation) {\n+\t\t\t\t\tfor (MemberValuePair mvp : ((NormalAnnotation) annotation).memberValuePairs) {\n+\t\t\t\t\t\tprint(\"<Member %s: %s /> %s\", new String(mvp.name), mvp.value.getClass(), mvp.value);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tindent--;\n+\t\t\t}\n \t\t}\n \t\t\n \t\tpublic void endVisitMethod(EclipseNode node, AbstractMethodDeclaration method) {",
      "parent_sha": "21df1c99391fb8e2678efa2ca11816bfcadd4725"
    }
  },
  {
    "oid": "7176ebc6c6a2fcaaa574f2d79aac4903c99055f3",
    "message": "errors generated during compilation by lombok weren\u2019t being conveyed in Javac9.",
    "date": "2017-12-04T23:00:08Z",
    "url": "https://github.com/projectlombok/lombok/commit/7176ebc6c6a2fcaaa574f2d79aac4903c99055f3",
    "details": {
      "sha": "af8124980457d13d8360c025f742deeb82e4b6ad",
      "filename": "src/core/lombok/javac/JavacAST.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/projectlombok/lombok/blob/7176ebc6c6a2fcaaa574f2d79aac4903c99055f3/src%2Fcore%2Flombok%2Fjavac%2FJavacAST.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/7176ebc6c6a2fcaaa574f2d79aac4903c99055f3/src%2Fcore%2Flombok%2Fjavac%2FJavacAST.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fjavac%2FJavacAST.java?ref=7176ebc6c6a2fcaaa574f2d79aac4903c99055f3",
      "patch": "@@ -561,7 +561,7 @@ private Jdk9Plus(Log log, Messager messager, Field errorCount, Field warningCoun\n \t\t\n \t\t@Override void error1(DiagnosticPosition pos, String message) {\n \t\t\ttry {\n-\t\t\t\tlogMethod.invoke(multiple, pos, \"proc.messager\", message);\n+\t\t\t\tlogMethod.invoke(log, multiple, pos, \"proc.messager\", new Object[] { message });\n \t\t\t} catch (Throwable t) {}\n \t\t}\n \t}",
      "parent_sha": "ab8e14736f8c3a7cb96ae7351d4bb1818131f2b2"
    }
  },
  {
    "oid": "4306f978fecb85ad49f5f147db6cf063305bf7b6",
    "message": "[SCL] update that should make it a little easier to add custom lombok handlers.",
    "date": "2018-06-18T22:09:48Z",
    "url": "https://github.com/projectlombok/lombok/commit/4306f978fecb85ad49f5f147db6cf063305bf7b6",
    "details": {
      "sha": "cd11720a099fee0070f7ea65946bbf06f4e6d05c",
      "filename": "src/launch/lombok/launch/ShadowClassLoader.java",
      "status": "modified",
      "additions": 8,
      "deletions": 19,
      "changes": 27,
      "blob_url": "https://github.com/projectlombok/lombok/blob/4306f978fecb85ad49f5f147db6cf063305bf7b6/src%2Flaunch%2Flombok%2Flaunch%2FShadowClassLoader.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/4306f978fecb85ad49f5f147db6cf063305bf7b6/src%2Flaunch%2Flombok%2Flaunch%2FShadowClassLoader.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Flaunch%2Flombok%2Flaunch%2FShadowClassLoader.java?ref=4306f978fecb85ad49f5f147db6cf063305bf7b6",
      "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2014-2016 The Project Lombok Authors.\n+ * Copyright (C) 2014-2018 The Project Lombok Authors.\n  * \n  * Permission is hereby granted, free of charge, to any person obtaining a copy\n  * of this software and associated documentation files (the \"Software\"), to deal\n@@ -33,7 +33,6 @@\n import java.net.URI;\n import java.net.URL;\n import java.net.URLDecoder;\n-import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Enumeration;\n@@ -73,6 +72,7 @@\n  * \n  * If no overrides are present, the load order is as follows:\n  * <li>First, if the resource is found in our own jar (trying \".SCL.<em>sclSuffix</em>\" first for any resource request ending in \".class\"), return that.\n+ * <li>Next, check any jar files other than our own, loading them via this classloader, if they have a file <code>META-INF/ShadowClassLoader</code> that contains a line of text with <em>sclSuffix</em>.\n  * <li>Next, ask the <code>parent</code> loader.\n  * </ul>\n  * \n@@ -117,9 +117,7 @@ class ShadowClassLoader extends ClassLoader {\n \t\t\tif (!pe.endsWith(\"/\")) pe = pe + \"/\";\n \t\t\tthis.parentExclusion.add(pe);\n \t\t}\n-\t\tif (highlanders != null) for (String hl : highlanders) {\n-\t\t\tthis.highlanders.add(hl);\n-\t\t}\n+\t\tif (highlanders != null) for (String hl : highlanders) this.highlanders.add(hl);\n \t\t\n \t\tif (selfBase != null) {\n \t\t\tSELF_BASE = selfBase;\n@@ -128,12 +126,7 @@ class ShadowClassLoader extends ClassLoader {\n \t\t\tString sclClassUrl = ShadowClassLoader.class.getResource(\"ShadowClassLoader.class\").toString();\n \t\t\tif (!sclClassUrl.endsWith(SELF_NAME)) throw new InternalError(\"ShadowLoader can't find itself.\");\n \t\t\tSELF_BASE_LENGTH = sclClassUrl.length() - SELF_NAME.length();\n-\t\t\tString decoded;\n-\t\t\ttry {\n-\t\t\t\tdecoded = URLDecoder.decode(sclClassUrl.substring(0, SELF_BASE_LENGTH), \"UTF-8\");\n-\t\t\t} catch (UnsupportedEncodingException e) {\n-\t\t\t\tthrow new InternalError(\"UTF-8 not available\");\n-\t\t\t}\n+\t\t\tString decoded = urlDecode(sclClassUrl.substring(0, SELF_BASE_LENGTH));\n \t\t\tSELF_BASE = decoded;\n \t\t}\n \t\t\n@@ -151,11 +144,11 @@ class ShadowClassLoader extends ClassLoader {\n \t\t\t}\n \t\t}\n \t}\n-\n+\t\n \tprivate final Map<String, Object> mapJarPathToTracker = new HashMap<String, Object>();\n \tprivate static final Map<Object, String> mapTrackerToJarPath = new WeakHashMap<Object, String>();\n \tprivate static final Map<Object, Set<String>> mapTrackerToJarContents = new WeakHashMap<Object, Set<String>>();\n-\n+\t\n \t/**\n \t * This cache ensures that any given jar file is only opened once in order to determine the full contents of it.\n \t * We use 'trackers' to make sure that the bulk of the memory taken up by this cache (the list of strings representing the content of a jar file)\n@@ -324,13 +317,9 @@ private static boolean sclFileContainsSuffix(InputStream in, String suffix) thro\n \t\n \tprivate static String urlDecode(String in) {\n \t\ttry {\n-\t\t\treturn URLDecoder.decode(in, Charset.defaultCharset().name());\n+\t\t\treturn URLDecoder.decode(in, \"UTF-8\");\n \t\t} catch (UnsupportedEncodingException e) {\n-\t\t\ttry {\n-\t\t\t\treturn URLDecoder.decode(in, \"UTF-8\");\n-\t\t\t} catch (UnsupportedEncodingException e1) {\n-\t\t\t\treturn in;\n-\t\t\t}\n+\t\t\tthrow new InternalError(\"UTF-8 not supported\");\n \t\t}\n \t}\n \t",
      "parent_sha": "eb09843cce285caecd25e1a459e95d8c28dda417"
    }
  },
  {
    "oid": "c972edb81e3d223c97175057cc56f5ac9d4e0143",
    "message": "[fixes #3000] Generate new type reference for val marker annotation",
    "date": "2021-12-12T01:39:33Z",
    "url": "https://github.com/projectlombok/lombok/commit/c972edb81e3d223c97175057cc56f5ac9d4e0143",
    "details": {
      "sha": "976a71f4a74c4da4294d351bfff827585b8fe445",
      "filename": "src/eclipseAgent/lombok/eclipse/agent/PatchVal.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/projectlombok/lombok/blob/c972edb81e3d223c97175057cc56f5ac9d4e0143/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchVal.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/c972edb81e3d223c97175057cc56f5ac9d4e0143/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchVal.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchVal.java?ref=c972edb81e3d223c97175057cc56f5ac9d4e0143",
      "patch": "@@ -359,7 +359,8 @@ private static Annotation[] addValAnnotation(Annotation[] originals, TypeReferen\n \t\t\tnewAnn = new Annotation[1];\n \t\t}\n \t\t\n-\t\tnewAnn[newAnn.length - 1] = new org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation(originalRef, originalRef.sourceStart);\n+\t\tTypeReference qualifiedTypeRef = generateQualifiedTypeRef(originalRef, originalRef.getTypeName());\n+\t\tnewAnn[newAnn.length - 1] = new org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation(qualifiedTypeRef, qualifiedTypeRef.sourceStart);\n \t\t\n \t\treturn newAnn;\n \t}",
      "parent_sha": "10fab5b77a04f5c89e4ad7fe6937055d36c4d1ee"
    }
  },
  {
    "oid": "786a6ffd234de977728250b6aa47a4be0b76a491",
    "message": "Consistent use of JavacResolution.typeToJCTree instead of TreeMaker.Types - fixes issue 341 where use of @Delegate with T-extends type parameters would prepend a dot to the fully qualified classname.",
    "date": "2012-02-27T20:48:31Z",
    "url": "https://github.com/projectlombok/lombok/commit/786a6ffd234de977728250b6aa47a4be0b76a491",
    "details": {
      "sha": "41e587f88c037d38e1cc1007b95295b6078cb86f",
      "filename": "src/core/lombok/javac/handlers/HandleDelegate.java",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/projectlombok/lombok/blob/786a6ffd234de977728250b6aa47a4be0b76a491/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FHandleDelegate.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/786a6ffd234de977728250b6aa47a4be0b76a491/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FHandleDelegate.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FHandleDelegate.java?ref=786a6ffd234de977728250b6aa47a4be0b76a491",
      "patch": "@@ -288,7 +288,13 @@ private JCMethodDecl createDelegateMethod(MethodSig sig, JavacNode annotation, N\n \t\t\n \t\tfor (TypeMirror param : sig.type.getTypeVariables()) {\n \t\t\tName name = ((TypeVar) param).tsym.name;\n-\t\t\ttypeParams.append(maker.TypeParameter(name, maker.Types(types.getBounds((TypeVar) param))));\n+\t\t\t\n+\t\t\tListBuffer<JCExpression> bounds = types.getBounds((TypeVar) param).isEmpty() ? null : new ListBuffer<JCExpression>();\n+\t\t\tfor (Type type : types.getBounds((TypeVar) param)) {\n+\t\t\t\tbounds.append(JavacResolution.typeToJCTree(type, annotation.getAst(), true));\n+\t\t\t}\n+\t\t\t\n+\t\t\ttypeParams.append(maker.TypeParameter(name, bounds.toList()));\n \t\t\ttypeArgs.append(maker.Ident(name));\n \t\t}\n \t\t",
      "parent_sha": "dbc46eefed2ecf37f248ec67faedf0d776332ed9"
    }
  },
  {
    "oid": "9470ca650ef6eb977047464041bff26fcafdeae3",
    "message": "ecj: revert changes to HandleBuilder (everything in HandleSuperBuilder)",
    "date": "2018-05-30T11:38:20Z",
    "url": "https://github.com/projectlombok/lombok/commit/9470ca650ef6eb977047464041bff26fcafdeae3",
    "details": {
      "sha": "d4cdc654543c9444e79c92376cbcbe5c37327163",
      "filename": "src/core/lombok/eclipse/handlers/HandleBuilder.java",
      "status": "modified",
      "additions": 48,
      "deletions": 196,
      "changes": 244,
      "blob_url": "https://github.com/projectlombok/lombok/blob/9470ca650ef6eb977047464041bff26fcafdeae3/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleBuilder.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/9470ca650ef6eb977047464041bff26fcafdeae3/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleBuilder.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleBuilder.java?ref=9470ca650ef6eb977047464041bff26fcafdeae3",
      "patch": "@@ -25,7 +25,6 @@\n import static lombok.core.handlers.HandlerUtil.*;\n import static lombok.eclipse.handlers.EclipseHandlerUtil.*;\n \n-import java.lang.reflect.Modifier;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n@@ -41,7 +40,6 @@\n import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\n import org.eclipse.jdt.internal.compiler.ast.ConditionalExpression;\n import org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;\n-import org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;\n import org.eclipse.jdt.internal.compiler.ast.Expression;\n import org.eclipse.jdt.internal.compiler.ast.FalseLiteral;\n import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;\n@@ -52,7 +50,6 @@\n import org.eclipse.jdt.internal.compiler.ast.OperatorIds;\n import org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;\n import org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;\n-import org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;\n import org.eclipse.jdt.internal.compiler.ast.QualifiedThisReference;\n import org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;\n import org.eclipse.jdt.internal.compiler.ast.ReturnStatement;\n@@ -84,7 +81,6 @@\n import lombok.eclipse.Eclipse;\n import lombok.eclipse.EclipseAnnotationHandler;\n import lombok.eclipse.EclipseNode;\n-import lombok.eclipse.handlers.EclipseHandlerUtil.MemberExistsResult;\n import lombok.eclipse.handlers.EclipseSingularsRecipes.EclipseSingularizer;\n import lombok.eclipse.handlers.EclipseSingularsRecipes.SingularData;\n import lombok.eclipse.handlers.HandleConstructor.SkipIfConstructorExists;\n@@ -106,7 +102,6 @@ private static final boolean toBoolean(Object expr, boolean defaultValue) {\n \t}\n \t\n \tprivate static class BuilderFieldData {\n-\t\tEclipseNode fieldNode;\n \t\tTypeReference type;\n \t\tchar[] rawName;\n \t\tchar[] name;\n@@ -160,10 +155,6 @@ private static final char[] prefixWith(char[] prefix, char[] name) {\n \t\tString builderMethodName = builderInstance.builderMethodName();\n \t\tString buildMethodName = builderInstance.buildMethodName();\n \t\tString builderClassName = builderInstance.builderClassName();\n-\t\t\n-\t\tboolean inherit = builderInstance.inherit();\n-\t\tboolean extensible = inherit || builderInstance.extensible(); // inherit implies extendable\n-\t\t\n \t\tString toBuilderMethodName = \"toBuilder\";\n \t\tboolean toBuilder = builderInstance.toBuilder();\n \t\tList<char[]> typeArgsForToBuilder = null;\n@@ -191,11 +182,9 @@ private static final char[] prefixWith(char[] prefix, char[] name) {\n \t\tboolean addCleaning = false;\n \t\tboolean isStatic = true;\n \t\t\n-\t\tTypeDeclaration td = null;\n-\t\t\n \t\tif (parent.get() instanceof TypeDeclaration) {\n \t\t\ttdParent = parent;\n-\t\t\ttd = (TypeDeclaration) tdParent.get();\n+\t\t\tTypeDeclaration td = (TypeDeclaration) tdParent.get();\n \t\t\t\n \t\t\tList<EclipseNode> allFields = new ArrayList<EclipseNode>();\n \t\t\tboolean valuePresent = (hasAnnotation(lombok.Value.class, parent) || hasAnnotation(\"lombok.experimental.Value\", parent));\n@@ -205,7 +194,6 @@ private static final char[] prefixWith(char[] prefix, char[] name) {\n \t\t\t\tboolean isFinal = ((fd.modifiers & ClassFileConstants.AccFinal) != 0) || (valuePresent && !hasAnnotation(NonFinal.class, fieldNode));\n \t\t\t\t\n \t\t\t\tBuilderFieldData bfd = new BuilderFieldData();\n-\t\t\t\tbfd.fieldNode = fieldNode;\n \t\t\t\tbfd.rawName = fieldNode.getName().toCharArray();\n \t\t\t\tbfd.name = removePrefixFromField(fieldNode);\n \t\t\t\tbfd.type = fd.type;\n@@ -239,51 +227,29 @@ private static final char[] prefixWith(char[] prefix, char[] name) {\n \t\t\t\tallFields.add(fieldNode);\n \t\t\t}\n \t\t\t\n-\t\t\tif (builderClassName.isEmpty()) builderClassName = new String(td.name) + \"Builder\";\n-\t\t\t\n-\t\t\tif (extensible) {\n-\t\t\t\tboolean callBuilderBasedSuperConstructor = td.superclass != null;\n-\t\t\t\tgenerateBuilderBasedConstructor(tdParent, builderFields, annotationNode, builderClassName, callBuilderBasedSuperConstructor);\n-\t\t\t} else {\n-\t\t\t\thandleConstructor.generateConstructor(tdParent, AccessLevel.PACKAGE, allFields, false, null, SkipIfConstructorExists.I_AM_BUILDER,\n-\t\t\t\t\tCollections.<Annotation>emptyList(), annotationNode);\n-\t\t\t}\n+\t\t\thandleConstructor.generateConstructor(tdParent, AccessLevel.PACKAGE, allFields, false, null, SkipIfConstructorExists.I_AM_BUILDER,\n+\t\t\t\tCollections.<Annotation>emptyList(), annotationNode);\n \t\t\t\n \t\t\treturnType = namePlusTypeParamsToTypeReference(td.name, td.typeParameters, p);\n \t\t\ttypeParams = td.typeParameters;\n \t\t\tthrownExceptions = null;\n \t\t\tnameOfStaticBuilderMethod = null;\n+\t\t\tif (builderClassName.isEmpty()) builderClassName = new String(td.name) + \"Builder\";\n \t\t} else if (parent.get() instanceof ConstructorDeclaration) {\n-\t\t\tif (inherit) {\n-\t\t\t\tannotationNode.addError(\"@Builder(inherit=true) is only supported for type builders.\");\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tif (extensible) {\n-\t\t\t\tannotationNode.addError(\"@Builder(extensible=true) is only supported for type builders.\");\n-\t\t\t\treturn;\n-\t\t\t}\n \t\t\tConstructorDeclaration cd = (ConstructorDeclaration) parent.get();\n \t\t\tif (cd.typeParameters != null && cd.typeParameters.length > 0) {\n \t\t\t\tannotationNode.addError(\"@Builder is not supported on constructors with constructor type parameters.\");\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t\n \t\t\ttdParent = parent.up();\n-\t\t\ttd = (TypeDeclaration) tdParent.get();\n+\t\t\tTypeDeclaration td = (TypeDeclaration) tdParent.get();\n \t\t\treturnType = namePlusTypeParamsToTypeReference(td.name, td.typeParameters, p);\n \t\t\ttypeParams = td.typeParameters;\n \t\t\tthrownExceptions = cd.thrownExceptions;\n \t\t\tnameOfStaticBuilderMethod = null;\n \t\t\tif (builderClassName.isEmpty()) builderClassName = new String(cd.selector) + \"Builder\";\n \t\t} else if (parent.get() instanceof MethodDeclaration) {\n-\t\t\tif (inherit) {\n-\t\t\t\tannotationNode.addError(\"@Builder(inherit=true) is only supported for type builders.\");\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tif (extensible) {\n-\t\t\t\tannotationNode.addError(\"@Builder(extendable=true) is only supported for type builders.\");\n-\t\t\t\treturn;\n-\t\t\t}\n \t\t\tMethodDeclaration md = (MethodDeclaration) parent.get();\n \t\t\ttdParent = parent.up();\n \t\t\tisStatic = md.isStatic();\n@@ -414,20 +380,7 @@ private static final char[] prefixWith(char[] prefix, char[] name) {\n \t\t\n \t\tEclipseNode builderType = findInnerClass(tdParent, builderClassName);\n \t\tif (builderType == null) {\n-\t\t\tString superclassBuilderClassName = null;\n-\t\t\tif (inherit) {\n-\t\t\t\tif (td.superclass == null) {\n-\t\t\t\t\tannotationNode.addError(\"@Builder(inherit = true) requires that your class has an 'extends' clause.\");\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\t\n-\t\t\t\tsuperclassBuilderClassName = builderInstance.superclassBuilderClassName();\n-\t\t\t\tif (superclassBuilderClassName == null || superclassBuilderClassName.isEmpty()) {\n-\t\t\t\t\tsuperclassBuilderClassName = new String(td.superclass.getLastToken()) + \"Builder\";\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t\n-\t\t\tbuilderType = makeBuilderClass(isStatic, tdParent, builderClassName, typeParams, ast, superclassBuilderClassName);\n+\t\t\tbuilderType = makeBuilderClass(isStatic, tdParent, builderClassName, typeParams, ast);\n \t\t} else {\n \t\t\tTypeDeclaration builderTypeDeclaration = (TypeDeclaration) builderType.get();\n \t\t\tif (isStatic && (builderTypeDeclaration.modifiers & ClassFileConstants.AccStatic) == 0) {\n@@ -491,7 +444,7 @@ private static final char[] prefixWith(char[] prefix, char[] name) {\n \t\t}\n \t\t\n \t\tif (methodExists(buildMethodName, builderType, -1) == MemberExistsResult.NOT_EXISTS) {\n-\t\t\tMethodDeclaration md = generateBuildMethod(tdParent, isStatic, buildMethodName, nameOfStaticBuilderMethod, returnType, builderFields, builderType, thrownExceptions, addCleaning, ast, extensible);\n+\t\t\tMethodDeclaration md = generateBuildMethod(tdParent, isStatic, buildMethodName, nameOfStaticBuilderMethod, returnType, builderFields, builderType, thrownExceptions, addCleaning, ast);\n \t\t\tif (md != null) injectMethod(builderType, md);\n \t\t}\n \t\t\n@@ -539,7 +492,8 @@ private MethodDeclaration generateToBuilderMethod(String methodName, String buil\n \t\tint pS = source.sourceStart, pE = source.sourceEnd;\n \t\tlong p = (long) pS << 32 | pE;\n \t\t\n-\t\tMethodDeclaration out = new MethodDeclaration(((CompilationUnitDeclaration) type.top().get()).compilationResult);\n+\t\tMethodDeclaration out = new MethodDeclaration(\n+\t\t\t\t((CompilationUnitDeclaration) type.top().get()).compilationResult);\n \t\tout.selector = methodName.toCharArray();\n \t\tout.modifiers = ClassFileConstants.AccPublic;\n \t\tout.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;\n@@ -577,92 +531,6 @@ private MethodDeclaration generateToBuilderMethod(String methodName, String buil\n \n \t}\n \t\n-\t/**\n-\t * Generates a constructor that has a builder as the only parameter.\n-\t * The values from the builder are used to initialize the fields of new instances.\n-\t *\n-\t * @param typeNode\n-\t *            the type (with the {@code @Builder} annotation) for which a\n-\t *            constructor should be generated.\n-\t * @param builderFields a list of fields in the builder which should be assigned to new instances.\n-\t * @param sourceNode the annotation (used for setting source code locations for the generated code).\n-\t * @param builderClassnameAsParameter\n-\t *            If {@code != null}, the only parameter of the constructor will\n-\t *            be a builder with this classname; the constructor will then\n-\t *            use the values within this builder to assign the fields of new\n-\t *            instances.\n-\t * @param callBuilderBasedSuperConstructor\n-\t *            If {@code true}, the constructor will explicitly call a super\n-\t *            constructor with the builder as argument. Requires\n-\t *            {@code builderClassAsParameter != null}.\n-\t */\n-\tprivate void generateBuilderBasedConstructor(EclipseNode typeNode, List<BuilderFieldData> builderFields, EclipseNode sourceNode,\n-\t\t\tString builderClassnameAsParameter, boolean callBuilderBasedSuperConstructor) {\n-\t\t\n-\t\tASTNode source = sourceNode.get();\n-\t\t\n-\t\tTypeDeclaration typeDeclaration = ((TypeDeclaration) typeNode.get());\n-\t\tlong p = (long) source.sourceStart << 32 | source.sourceEnd;\n-\t\t\n-\t\tConstructorDeclaration constructor = new ConstructorDeclaration(((CompilationUnitDeclaration) typeNode.top().get()).compilationResult);\n-\t\t\n-\t\tconstructor.modifiers = toEclipseModifier(AccessLevel.PROTECTED);\n-\t\tconstructor.selector = typeDeclaration.name;\n-\t\tif (callBuilderBasedSuperConstructor) {\n-\t\t\tconstructor.constructorCall = new ExplicitConstructorCall(ExplicitConstructorCall.Super);\n-\t\t\tconstructor.constructorCall.arguments = new Expression[] {new SingleNameReference(\"b\".toCharArray(), p)};\n-\t\t} else {\n-\t\t\tconstructor.constructorCall = new ExplicitConstructorCall(ExplicitConstructorCall.ImplicitSuper);\n-\t\t}\n-\t\tconstructor.constructorCall.sourceStart = source.sourceStart;\n-\t\tconstructor.constructorCall.sourceEnd = source.sourceEnd;\n-\t\tconstructor.thrownExceptions = null;\n-\t\tconstructor.typeParameters = null;\n-\t\tconstructor.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;\n-\t\tconstructor.bodyStart = constructor.declarationSourceStart = constructor.sourceStart = source.sourceStart;\n-\t\tconstructor.bodyEnd = constructor.declarationSourceEnd = constructor.sourceEnd = source.sourceEnd;\n-\t\tconstructor.arguments = null;\n-\t\t\n-\t\tList<Statement> statements = new ArrayList<Statement>();\n-\t\tList<Statement> nullChecks = new ArrayList<Statement>();\n-\t\t\n-\t\tfor (BuilderFieldData fieldNode : builderFields) {\n-\t\t\tchar[] fieldName = removePrefixFromField(fieldNode.fieldNode);\n-\t\t\tFieldReference thisX = new FieldReference(fieldNode.rawName, p);\n-\t\t\tint s = (int) (p >> 32);\n-\t\t\tint e = (int) p;\n-\t\t\tthisX.receiver = new ThisReference(s, e);\n-\t\t\t\n-\t\t\tExpression assignmentExpr;\n-\t\t\tif (fieldNode.singularData != null && fieldNode.singularData.getSingularizer() != null) {\n-\t\t\t\tfieldNode.singularData.getSingularizer().appendBuildCode(fieldNode.singularData, typeNode, statements, fieldNode.name, \"b\");\n-\t\t\t\tassignmentExpr = new SingleNameReference(fieldNode.name, p);\n-\t\t\t} else {\n-\t\t\t\tchar[][] variableInBuilder = new char[][] {\"b\".toCharArray(), fieldName};\n-\t\t\t\tlong[] positions = new long[] {p, p};\n-\t\t\t\tassignmentExpr = new QualifiedNameReference(variableInBuilder, positions, s, e);\n-\t\t\t}\n-\t\t\t\n-\t\t\tAssignment assignment = new Assignment(thisX, assignmentExpr, (int) p);\n-\t\t\tstatements.add(assignment);\n-\t\t\tAnnotation[] nonNulls = findAnnotations((FieldDeclaration)fieldNode.fieldNode.get(), NON_NULL_PATTERN);\n-\t\t\tif (nonNulls.length != 0) {\n-\t\t\t\tStatement nullCheck = generateNullCheck((FieldDeclaration)fieldNode.fieldNode.get(), sourceNode);\n-\t\t\t\tif (nullCheck != null) {\n-\t\t\t\t\tnullChecks.add(nullCheck);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t\n-\t\tnullChecks.addAll(statements);\n-\t\tconstructor.statements = nullChecks.isEmpty() ? null : nullChecks.toArray(new Statement[nullChecks.size()]);\n-\t\tconstructor.arguments = new Argument[] {new Argument(\"b\".toCharArray(), p, new SingleTypeReference(builderClassnameAsParameter.toCharArray(), p), Modifier.FINAL)};\n-\t\t\n-\t\tconstructor.traverse(new SetGeneratedByVisitor(source), typeDeclaration.scope);\n-\t\t\n-\t\tinjectMethod(typeNode, constructor);\n-\t}\n-\t\n \tprivate MethodDeclaration generateCleanMethod(List<BuilderFieldData> builderFields, EclipseNode builderType, ASTNode source) {\n \t\tList<Statement> statements = new ArrayList<Statement>();\n \t\t\n@@ -685,60 +553,51 @@ private MethodDeclaration generateCleanMethod(List<BuilderFieldData> builderFiel\n \t\treturn decl;\n \t}\n \t\n-\t/**\n-\t * @param useBuilderBasedConstructor\n-\t *            if true, the {@code build()} method will use a constructor\n-\t *            that takes the builder instance as parameter (instead of a\n-\t *            constructor with all relevant fields as parameters)\n-\t */\n-\tpublic MethodDeclaration generateBuildMethod(EclipseNode tdParent, boolean isStatic, String name, char[] staticName, TypeReference returnType, List<BuilderFieldData> builderFields, EclipseNode type, TypeReference[] thrownExceptions, boolean addCleaning, ASTNode source, boolean useBuilderBasedConstructor) {\n+\tpublic MethodDeclaration generateBuildMethod(EclipseNode tdParent, boolean isStatic, String name, char[] staticName, TypeReference returnType, List<BuilderFieldData> builderFields, EclipseNode type, TypeReference[] thrownExceptions, boolean addCleaning, ASTNode source) {\n \t\tMethodDeclaration out = new MethodDeclaration(((CompilationUnitDeclaration) type.top().get()).compilationResult);\n \t\tout.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;\n \t\tList<Statement> statements = new ArrayList<Statement>();\n-\t\tList<Expression> args = new ArrayList<Expression>();\n \t\t\n-\t\t// Extendable builders assign their values in the constructor, not in this build() method.\n-\t\tif (!useBuilderBasedConstructor) {\n-\t\t\tif (addCleaning) {\n-\t\t\t\tFieldReference thisUnclean = new FieldReference(CLEAN_FIELD_NAME, 0);\n-\t\t\t\tthisUnclean.receiver = new ThisReference(0, 0);\n-\t\t\t\tExpression notClean = new UnaryExpression(thisUnclean, OperatorIds.NOT);\n-\t\t\t\tMessageSend invokeClean = new MessageSend();\n-\t\t\t\tinvokeClean.selector = CLEAN_METHOD_NAME;\n-\t\t\t\tstatements.add(new IfStatement(notClean, invokeClean, 0, 0));\n-\t\t\t}\n-\t\t\t\n-\t\t\tfor (BuilderFieldData bfd : builderFields) {\n-\t\t\t\tif (bfd.singularData != null && bfd.singularData.getSingularizer() != null) {\n-\t\t\t\t\tbfd.singularData.getSingularizer().appendBuildCode(bfd.singularData, type, statements, bfd.name, \"this\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t\n-\t\t\tfor (BuilderFieldData bfd : builderFields) {\n-\t\t\t\tif (bfd.nameOfSetFlag != null) {\n-\t\t\t\t\tMessageSend inv = new MessageSend();\n-\t\t\t\t\tinv.sourceStart = source.sourceStart;\n-\t\t\t\t\tinv.sourceEnd = source.sourceEnd;\n-\t\t\t\t\tinv.receiver = new SingleNameReference(((TypeDeclaration) tdParent.get()).name, 0L);\n-\t\t\t\t\tinv.selector = bfd.nameOfDefaultProvider;\n-\t\t\t\t\tinv.typeArguments = typeParameterNames(((TypeDeclaration) type.get()).typeParameters);\n-\t\t\t\t\t\n-\t\t\t\t\targs.add(new ConditionalExpression(\n-\t\t\t\t\t\tnew SingleNameReference(bfd.nameOfSetFlag,  0L),\n-\t\t\t\t\t\tnew SingleNameReference(bfd.name, 0L),\n-\t\t\t\t\t\tinv));\n-\t\t\t\t} else {\n-\t\t\t\t\targs.add(new SingleNameReference(bfd.name, 0L));\n-\t\t\t\t}\n+\t\tif (addCleaning) {\n+\t\t\tFieldReference thisUnclean = new FieldReference(CLEAN_FIELD_NAME, 0);\n+\t\t\tthisUnclean.receiver = new ThisReference(0, 0);\n+\t\t\tExpression notClean = new UnaryExpression(thisUnclean, OperatorIds.NOT);\n+\t\t\tMessageSend invokeClean = new MessageSend();\n+\t\t\tinvokeClean.selector = CLEAN_METHOD_NAME;\n+\t\t\tstatements.add(new IfStatement(notClean, invokeClean, 0, 0));\n+\t\t}\n+\t\t\n+\t\tfor (BuilderFieldData bfd : builderFields) {\n+\t\t\tif (bfd.singularData != null && bfd.singularData.getSingularizer() != null) {\n+\t\t\t\tbfd.singularData.getSingularizer().appendBuildCode(bfd.singularData, type, statements, bfd.name);\n \t\t\t}\n-\t\t\t\n-\t\t\tif (addCleaning) {\n-\t\t\t\tFieldReference thisUnclean = new FieldReference(CLEAN_FIELD_NAME, 0);\n-\t\t\t\tthisUnclean.receiver = new ThisReference(0, 0);\n-\t\t\t\tstatements.add(new Assignment(thisUnclean, new TrueLiteral(0, 0), 0));\n+\t\t}\n+\t\t\n+\t\tList<Expression> args = new ArrayList<Expression>();\n+\t\tfor (BuilderFieldData bfd : builderFields) {\n+\t\t\tif (bfd.nameOfSetFlag != null) {\n+\t\t\t\tMessageSend inv = new MessageSend();\n+\t\t\t\tinv.sourceStart = source.sourceStart;\n+\t\t\t\tinv.sourceEnd = source.sourceEnd;\n+\t\t\t\tinv.receiver = new SingleNameReference(((TypeDeclaration) tdParent.get()).name, 0L);\n+\t\t\t\tinv.selector = bfd.nameOfDefaultProvider;\n+\t\t\t\tinv.typeArguments = typeParameterNames(((TypeDeclaration) type.get()).typeParameters);\n+\t\t\t\t\n+\t\t\t\targs.add(new ConditionalExpression(\n+\t\t\t\t\tnew SingleNameReference(bfd.nameOfSetFlag,  0L),\n+\t\t\t\t\tnew SingleNameReference(bfd.name, 0L),\n+\t\t\t\t\tinv));\n+\t\t\t} else {\n+\t\t\t\targs.add(new SingleNameReference(bfd.name, 0L));\n \t\t\t}\n \t\t}\n \t\t\n+\t\tif (addCleaning) {\n+\t\t\tFieldReference thisUnclean = new FieldReference(CLEAN_FIELD_NAME, 0);\n+\t\t\tthisUnclean.receiver = new ThisReference(0, 0);\n+\t\t\tstatements.add(new Assignment(thisUnclean, new TrueLiteral(0, 0), 0));\n+\t\t}\n+\t\t\n \t\tout.modifiers = ClassFileConstants.AccPublic;\n \t\tout.selector = name.toCharArray();\n \t\tout.thrownExceptions = copyTypes(thrownExceptions);\n@@ -748,13 +607,7 @@ public MethodDeclaration generateBuildMethod(EclipseNode tdParent, boolean isSta\n \t\tif (staticName == null) {\n \t\t\tAllocationExpression allocationStatement = new AllocationExpression();\n \t\t\tallocationStatement.type = copyType(out.returnType);\n-\t\t\tif (useBuilderBasedConstructor) {\n-\t\t\t\t// Use a constructor that only has this builder as parameter.\n-\t\t\t\tallocationStatement.arguments = new Expression[] {new ThisReference(0, 0)};\n-\t\t\t} else {\n-\t\t\t\t// Use a constructor with all the fields.\n-\t\t\t\tallocationStatement.arguments = args.isEmpty() ? null : args.toArray(new Expression[args.size()]);\n-\t\t\t}\n+\t\t\tallocationStatement.arguments = args.isEmpty() ? null : args.toArray(new Expression[args.size()]);\n \t\t\tstatements.add(new ReturnStatement(allocationStatement, 0, 0));\n \t\t} else {\n \t\t\tMessageSend invoke = new MessageSend();\n@@ -903,15 +756,14 @@ public EclipseNode findInnerClass(EclipseNode parent, String name) {\n \t\treturn null;\n \t}\n \t\n-\tpublic EclipseNode makeBuilderClass(boolean isStatic, EclipseNode tdParent, String builderClassName, TypeParameter[] typeParams, ASTNode source, String parentBuilderClassName) {\n+\tpublic EclipseNode makeBuilderClass(boolean isStatic, EclipseNode tdParent, String builderClassName, TypeParameter[] typeParams, ASTNode source) {\n \t\tTypeDeclaration parent = (TypeDeclaration) tdParent.get();\n \t\tTypeDeclaration builder = new TypeDeclaration(parent.compilationResult);\n \t\tbuilder.bits |= Eclipse.ECLIPSE_DO_NOT_TOUCH_FLAG;\n \t\tbuilder.modifiers |= ClassFileConstants.AccPublic;\n \t\tif (isStatic) builder.modifiers |= ClassFileConstants.AccStatic;\n \t\tbuilder.typeParameters = copyTypeParams(typeParams, source);\n \t\tbuilder.name = builderClassName.toCharArray();\n-\t\tif (parentBuilderClassName != null) builder.superclass = new SingleTypeReference(parentBuilderClassName.toCharArray(), 0);\n \t\tbuilder.traverse(new SetGeneratedByVisitor(source), (ClassScope) null);\n \t\treturn injectType(tdParent, builder);\n \t}",
      "parent_sha": "a74f4bdda04efcfea36f7b602fe2bdda2ef613fa"
    }
  },
  {
    "oid": "099e15aa3ee62b81dc074f77f7e07076cd0e8d8f",
    "message": "Upped version number, will release 0.8.1 immediately after this.",
    "date": "2009-07-26T08:02:44Z",
    "url": "https://github.com/projectlombok/lombok/commit/099e15aa3ee62b81dc074f77f7e07076cd0e8d8f",
    "details": {
      "sha": "964edc3732de5f7704aaea5c3eb54c7d286fc8ab",
      "filename": "src/lombok/core/Version.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/projectlombok/lombok/blob/099e15aa3ee62b81dc074f77f7e07076cd0e8d8f/src%2Flombok%2Fcore%2FVersion.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/099e15aa3ee62b81dc074f77f7e07076cd0e8d8f/src%2Flombok%2Fcore%2FVersion.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Flombok%2Fcore%2FVersion.java?ref=099e15aa3ee62b81dc074f77f7e07076cd0e8d8f",
      "patch": "@@ -25,7 +25,7 @@\n  * This class just holds lombok's current version.\n  */\n public class Version {\n-\tprivate static final String VERSION = \"0.8\";\n+\tprivate static final String VERSION = \"0.8.1\";\n \t\n \tprivate Version() {\n \t\t//Prevent instantiation",
      "parent_sha": "a73dd520412b907ee072e8fe8164483d949d9ddf"
    }
  },
  {
    "oid": "d5f1f79df67eb7cb0ccbbe2933302bcb39e272a1",
    "message": "Remove obsolete LombokProcessor.getModuleName",
    "date": "2023-02-20T19:50:17Z",
    "url": "https://github.com/projectlombok/lombok/commit/d5f1f79df67eb7cb0ccbbe2933302bcb39e272a1",
    "details": {
      "sha": "0467d7585b0bf8d822a5bc0522d040a96b7eb06c",
      "filename": "src/core/lombok/javac/apt/LombokProcessor.java",
      "status": "modified",
      "additions": 3,
      "deletions": 38,
      "changes": 41,
      "blob_url": "https://github.com/projectlombok/lombok/blob/d5f1f79df67eb7cb0ccbbe2933302bcb39e272a1/src%2Fcore%2Flombok%2Fjavac%2Fapt%2FLombokProcessor.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/d5f1f79df67eb7cb0ccbbe2933302bcb39e272a1/src%2Fcore%2Flombok%2Fjavac%2Fapt%2FLombokProcessor.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fjavac%2Fapt%2FLombokProcessor.java?ref=d5f1f79df67eb7cb0ccbbe2933302bcb39e272a1",
      "patch": "@@ -25,7 +25,6 @@\n import java.io.InputStream;\n import java.lang.reflect.Field;\n import java.lang.reflect.InvocationHandler;\n-import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.lang.reflect.Proxy;\n import java.net.URL;\n@@ -305,10 +304,7 @@ private void stopJavacProcessingEnvironmentFromClosingOurClassloader() {\n \t\t\n \t\t// Step 1: Take all CUs which aren't already in the map. Give them the first priority level.\n \t\t\n-\t\tString randomModuleName = null;\n-\t\t\n \t\tfor (Element element : roundEnv.getRootElements()) {\n-\t\t\tif (randomModuleName == null) randomModuleName = getModuleNameFor(element);\n \t\t\tJCCompilationUnit unit = toUnit(element);\n \t\t\tif (unit == null) continue;\n \t\t\tif (roots.containsKey(unit)) continue;\n@@ -353,15 +349,15 @@ private void stopJavacProcessingEnvironmentFromClosingOurClassloader() {\n \t\t\tnewLevels.retainAll(priorityLevelsRequiringResolutionReset);\n \t\t\tif (!newLevels.isEmpty()) {\n \t\t\t\t// Force a new round to reset resolution. The next round will cause this method (process) to be called again.\n-\t\t\t\tforceNewRound(randomModuleName, javacFiler);\n+\t\t\t\tforceNewRound(javacFiler);\n \t\t\t\treturn false;\n \t\t\t}\n \t\t\t// None of the new levels need resolution, so just keep going.\n \t\t}\n \t}\n \t\n \tprivate int dummyCount = 0;\n-\tprivate void forceNewRound(String randomModuleName, JavacFiler filer) {\n+\tprivate void forceNewRound(JavacFiler filer) {\n \t\tif (!filer.newFiles()) {\n \t\t\ttry {\n \t\t\t\tfiler.getGeneratedSourceNames().add(\"lombok.dummy.ForceNewRound\" + (dummyCount++));\n@@ -372,38 +368,7 @@ private void forceNewRound(String randomModuleName, JavacFiler filer) {\n \t\t\t}\n \t\t}\n \t}\n-\t\n-\tprivate String getModuleNameFor(Element element) {\n-\t\twhile (element != null) {\n-\t\t\tif (element.getKind().name().equals(\"MODULE\")) return getModuleName(element);\n-\t\t\tElement n = element.getEnclosingElement();\n-\t\t\tif (n == element) return null;\n-\t\t\telement = n;\n-\t\t}\n-\t\treturn null;\n-\t}\n-\t\n-\tprivate static Class<?> qualifiedNamableClass = null;\n-\tprivate static Method qualifiedNamableQualifiedNameMethod = null;\n-\t// QualifiedNameable isn't in java 6, so to remain compatible with java6, use reflection.\n-\tprivate static String getModuleName(Element element) {\n-\t\ttry {\n-\t\t\tif (qualifiedNamableClass == null) qualifiedNamableClass = Class.forName(\"javax.lang.model.element.QualifiedNamable\");\n-\t\t\tif (!qualifiedNamableClass.isInstance(element)) return null;\n-\t\t\tif (qualifiedNamableQualifiedNameMethod == null) qualifiedNamableQualifiedNameMethod = Permit.getMethod(qualifiedNamableClass, \"getQualifiedName\");\n-\t\t\tString name = Permit.invoke(qualifiedNamableQualifiedNameMethod, element).toString().trim();\n-\t\t\treturn name.isEmpty() ? null : name;\n-\t\t} catch (ClassNotFoundException e) {\n-\t\t\treturn null;\n-\t\t} catch (NoSuchMethodException e) {\n-\t\t\treturn null;\n-\t\t} catch (InvocationTargetException e) {\n-\t\t\treturn null;\n-\t\t} catch (IllegalAccessException e) {\n-\t\t\treturn null;\n-\t\t}\n-\t}\n-\t\n+\n \tprivate JCCompilationUnit toUnit(Element element) {\n \t\tTreePath path = null;\n \t\tif (trees != null) {",
      "parent_sha": "e5c324c615c1e304b2a9a64bc7f8608a67b0a74e"
    }
  },
  {
    "oid": "57578f46ec19abd1b28b2a22c65281cf4831af3d",
    "message": "add missing method to SetGeneratedByVisitor",
    "date": "2015-12-01T23:02:35Z",
    "url": "https://github.com/projectlombok/lombok/commit/57578f46ec19abd1b28b2a22c65281cf4831af3d",
    "details": {
      "sha": "b42761f4211948dd04005dbb7426c3b6307aaeec",
      "filename": "src/core/lombok/eclipse/handlers/SetGeneratedByVisitor.java",
      "status": "modified",
      "additions": 20,
      "deletions": 1,
      "changes": 21,
      "blob_url": "https://github.com/projectlombok/lombok/blob/57578f46ec19abd1b28b2a22c65281cf4831af3d/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FSetGeneratedByVisitor.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/57578f46ec19abd1b28b2a22c65281cf4831af3d/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FSetGeneratedByVisitor.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FSetGeneratedByVisitor.java?ref=57578f46ec19abd1b28b2a22c65281cf4831af3d",
      "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2011-2013 The Project Lombok Authors.\n+ * Copyright (C) 2011-2015 The Project Lombok Authors.\n  * \n  * Permission is hereby granted, free of charge, to any person obtaining a copy\n  * of this software and associated documentation files (the \"Software\"), to deal\n@@ -369,6 +369,11 @@ private void fixPositions(QualifiedTypeReference node) {\n \t\treturn super.visit(node, scope);\n \t}\n \t\n+\t@Override public boolean visit(ArrayInitializer node, ClassScope scope) {\n+\t\tfixPositions(setGeneratedBy(node, source));\n+\t\treturn super.visit(node, scope);\n+\t}\n+\t\n \t@Override public boolean visit(ArrayQualifiedTypeReference node, BlockScope scope) {\n \t\tfixPositions(setGeneratedBy(node, source));\n \t\treturn super.visit(node, scope);\n@@ -928,4 +933,18 @@ private void fixPositions(QualifiedTypeReference node) {\n \t\tfixPositions(setGeneratedBy(node, source));\n \t\treturn super.visit(node, scope);\n \t}\n+\n+// missing methods\n+//\tpublic boolean visit(MarkerAnnotation node, ClassScope scope){ return true;}\n+//\tpublic boolean visit(MemberValuePair node, ClassScope scope){ return true;}\n+//\tpublic boolean visit(NormalAnnotation node, ClassScope scope){ return true;}\n+//\tpublic boolean visit(SingleMemberAnnotation node, ClassScope scope){ return true;}\n+\t\n+// missing methods from later versions\n+//\tpublic boolean visit(UnionTypeReference node, BlockScope scope){ return true;}\n+//\tpublic boolean visit(UnionTypeReference node, ClassScope scope){ return true;}\n+//\tpublic boolean visit(LambdaExpression node, BlockScope scope){ return true;}\n+//\tpublic boolean visit(ReferenceExpression node, BlockScope scope){ return true;}\n+//\tpublic boolean visit(IntersectionCastTypeReference node, ClassScope scope){ return true;}\n+//\tpublic boolean visit(IntersectionCastTypeReference node, BlockScope scope){ return true;}\n }\n\\ No newline at end of file",
      "parent_sha": "ac319cca87020b779722351f37cc0a9c40b12872"
    }
  },
  {
    "oid": "cc36ab36d154ffab55bfa74e55a79a7b8b2fcd63",
    "message": "don't skip empty lines in the line number count for config files",
    "date": "2016-06-08T21:36:06Z",
    "url": "https://github.com/projectlombok/lombok/commit/cc36ab36d154ffab55bfa74e55a79a7b8b2fcd63",
    "details": {
      "sha": "29a6741b21fcb02bdb40a44a628dc298ed799c50",
      "filename": "src/core/lombok/core/configuration/ConfigurationParser.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/projectlombok/lombok/blob/cc36ab36d154ffab55bfa74e55a79a7b8b2fcd63/src%2Fcore%2Flombok%2Fcore%2Fconfiguration%2FConfigurationParser.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/cc36ab36d154ffab55bfa74e55a79a7b8b2fcd63/src%2Fcore%2Flombok%2Fcore%2Fconfiguration%2FConfigurationParser.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fcore%2Fconfiguration%2FConfigurationParser.java?ref=cc36ab36d154ffab55bfa74e55a79a7b8b2fcd63",
      "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2014 The Project Lombok Authors.\n+ * Copyright (C) 2014-2016 The Project Lombok Authors.\n  * \n  * Permission is hereby granted, free of charge, to any person obtaining a copy\n  * of this software and associated documentation files (the \"Software\"), to deal\n@@ -27,7 +27,7 @@\n \n public class ConfigurationParser {\n \tprivate static final Pattern LINE = Pattern.compile(\"(?:clear\\\\s+([^=]+))|(?:(\\\\S*?)\\\\s*([-+]?=)\\\\s*(.*?))\");\n-\tprivate static final Pattern NEWLINE_FINDER = Pattern.compile(\"^\\\\s*(.*?)\\\\s*$\", Pattern.MULTILINE);\n+\tprivate static final Pattern NEWLINE_FINDER = Pattern.compile(\"^[\\t ]*(.*?)[\\t ]*$\", Pattern.MULTILINE);\n \t\n \tprivate ConfigurationProblemReporter reporter;\n \t",
      "parent_sha": "ea219cd7ce76fa1140901050cce73e58f9ddb6d1"
    }
  },
  {
    "oid": "8ada852308f2823efb12af7795e21eb3ff08f598",
    "message": "Used reflection to call Apple native look to avoid errors in a non-mac\ndevelopment environment",
    "date": "2009-07-14T21:37:04Z",
    "url": "https://github.com/projectlombok/lombok/commit/8ada852308f2823efb12af7795e21eb3ff08f598",
    "details": {
      "sha": "b2c9055539a872bfef9bc92f9ee2630d3fa6b81f",
      "filename": "src/lombok/installer/AppleNativeLook.java",
      "status": "modified",
      "additions": 10,
      "deletions": 8,
      "changes": 18,
      "blob_url": "https://github.com/projectlombok/lombok/blob/8ada852308f2823efb12af7795e21eb3ff08f598/src%2Flombok%2Finstaller%2FAppleNativeLook.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/8ada852308f2823efb12af7795e21eb3ff08f598/src%2Flombok%2Finstaller%2FAppleNativeLook.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Flombok%2Finstaller%2FAppleNativeLook.java?ref=8ada852308f2823efb12af7795e21eb3ff08f598",
      "patch": "@@ -21,21 +21,23 @@\n  */\n package lombok.installer;\n \n-import java.io.IOException;\n+import java.awt.Image;\n+import java.awt.image.BufferedImage;\n \n import javax.imageio.ImageIO;\n \n-import com.apple.eawt.Application;\n-\n /**\n  * Mac OS X specific code to gussy up the GUI a little bit, mostly with a nice dock icon. Well, nicer than\n  * the standard icon, at any rate.\n  */\n class AppleNativeLook {\n-\tpublic static void go() throws IOException {\n-\t\tApplication app = Application.getApplication();\n-\t\tapp.removeAboutMenuItem();\n-\t\tapp.removePreferencesMenuItem();\n-\t\tapp.setDockIconImage(ImageIO.read(AppleNativeLook.class.getResource(\"lombokIcon.png\")));\n+\tpublic static void go() throws Exception {\n+\t\tClass<?> appClass = Class.forName(\"com.apple.eawt.Application\");\n+\t\tObject app = appClass.getMethod(\"getApplication\").invoke(null);\n+\t\tappClass.getMethod(\"removeAboutMenuItem\").invoke(app);\n+\t\tappClass.getMethod(\"removePreferencesMenuItem\").invoke(app);\n+\n+\t\tBufferedImage image = ImageIO.read(AppleNativeLook.class.getResource(\"lombokIcon.png\"));\n+\t\tappClass.getMethod(\"setDockIconImage\", Image.class).invoke(app, image);\n \t}\n }",
      "parent_sha": "f99fff3042a96ea509f2e1583fc182b3c4c9f5cd"
    }
  },
  {
    "oid": "614d490ea1477079ade277a95eb0cce123526842",
    "message": "Fix for NPEs in the eclipse log for\norg.eclipse.jdt.internal.compiler.lookup.MethodBinding.sourceMethod(MethodBinding.java:1108)",
    "date": "2012-10-23T09:19:35Z",
    "url": "https://github.com/projectlombok/lombok/commit/614d490ea1477079ade277a95eb0cce123526842",
    "details": {
      "sha": "6fdcfa63795eec2fcecb58feab7dc25202816a1e",
      "filename": "src/eclipseAgent/lombok/eclipse/agent/PatchDelegate.java",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/projectlombok/lombok/blob/614d490ea1477079ade277a95eb0cce123526842/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchDelegate.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/614d490ea1477079ade277a95eb0cce123526842/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchDelegate.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchDelegate.java?ref=614d490ea1477079ade277a95eb0cce123526842",
      "patch": "@@ -620,7 +620,12 @@ private static MethodDeclaration createDelegateMethod(char[] name, EclipseNode t\n \t\t\tmethod.arguments = new Argument[binding.parameters.length];\n \t\t\tcall.arguments = new Expression[method.arguments.length];\n \t\t\tfor (int i = 0; i < method.arguments.length; i++) {\n-\t\t\t\tAbstractMethodDeclaration sourceElem = pair.base.sourceMethod();\n+\t\t\t\tAbstractMethodDeclaration sourceElem;\n+\t\t\t\ttry {\n+\t\t\t\t\tsourceElem = pair.base.sourceMethod();\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tsourceElem = null;\n+\t\t\t\t}\n \t\t\t\tchar[] argName;\n \t\t\t\tif (sourceElem == null) argName = (\"arg\" + i).toCharArray();\n \t\t\t\telse {",
      "parent_sha": "10085d5f2a01cfefd9709b4745e58d8191a924d5"
    }
  },
  {
    "oid": "48ad2ba6c82cf1b4d852d174628c15ca5e634555",
    "message": "Minor correction to SneakyThrows javadoc",
    "date": "2024-06-25T21:44:01Z",
    "url": "https://github.com/projectlombok/lombok/commit/48ad2ba6c82cf1b4d852d174628c15ca5e634555",
    "details": {
      "sha": "41b8f5169eb811c10da891374c609a475ca57a55",
      "filename": "src/core/lombok/SneakyThrows.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/projectlombok/lombok/blob/48ad2ba6c82cf1b4d852d174628c15ca5e634555/src%2Fcore%2Flombok%2FSneakyThrows.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/48ad2ba6c82cf1b4d852d174628c15ca5e634555/src%2Fcore%2Flombok%2FSneakyThrows.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2FSneakyThrows.java?ref=48ad2ba6c82cf1b4d852d174628c15ca5e634555",
      "patch": "@@ -27,10 +27,10 @@\n import java.lang.annotation.Target;\n \n /**\n- * &#64;SneakyThrow will avoid javac's insistence that you either catch or throw onward any checked exceptions that\n+ * &#64;SneakyThrows will avoid javac's insistence that you either catch or throw onward any checked exceptions that\n  * statements in your method body declare they generate.\n  * <p>\n- * &#64;SneakyThrow does not silently swallow, wrap into RuntimeException, or otherwise modify any exceptions of the listed\n+ * &#64;SneakyThrows does not silently swallow, wrap into RuntimeException, or otherwise modify any exceptions of the listed\n  * checked exception types. The JVM does not check for the consistency of the checked exception system; javac does,\n  * and this annotation lets you opt out of its mechanism.\n  * <p>",
      "parent_sha": "30e19e4cdc872892214bc92d88291385a29ebafb"
    }
  },
  {
    "oid": "f84349965803816d46473b42d08ed0c0d288ce8a",
    "message": "Extract local variable paramName",
    "date": "2019-01-13T01:13:56Z",
    "url": "https://github.com/projectlombok/lombok/commit/f84349965803816d46473b42d08ed0c0d288ce8a",
    "details": {
      "sha": "79d5166ebabcef83b1088fd7b5dbe9d6d7f7bdb3",
      "filename": "src/core/lombok/javac/handlers/singulars/JavacJavaUtilListSetSingularizer.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/projectlombok/lombok/blob/f84349965803816d46473b42d08ed0c0d288ce8a/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2Fsingulars%2FJavacJavaUtilListSetSingularizer.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/f84349965803816d46473b42d08ed0c0d288ce8a/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2Fsingulars%2FJavacJavaUtilListSetSingularizer.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2Fsingulars%2FJavacJavaUtilListSetSingularizer.java?ref=f84349965803816d46473b42d08ed0c0d288ce8a",
      "patch": "@@ -111,11 +111,12 @@ protected void generateSingularMethod(boolean deprecate, JavacTreeMaker maker, J\n \t\tName name = data.getSingularName();\n \t\tlong paramFlags = JavacHandlerUtil.addFinalIfNeeded(Flags.PARAMETER, builderType.getContext());\n \t\tif (!fluent) name = builderType.toName(HandlerUtil.buildAccessorName(\"add\", name.toString()));\n+\t\tName paramName = data.getSingularName();\n \t\tJCExpression paramType = cloneParamType(0, maker, data.getTypeArgs(), builderType, source);\n \t\tList<JCAnnotation> typeUseAnns = getTypeUseAnnotations(paramType);\n \t\tparamType = removeTypeUseAnnotations(paramType);\n \t\tJCModifiers paramMods = typeUseAnns.isEmpty() ? maker.Modifiers(paramFlags) : maker.Modifiers(paramFlags, typeUseAnns);\n-\t\tJCVariableDecl param = maker.VarDef(paramMods, data.getSingularName(), paramType, null);\n+\t\tJCVariableDecl param = maker.VarDef(paramMods, paramName, paramType, null);\n \t\tfinishAndInjectMethod(maker, returnType, builderType, source, mods, body, name, List.of(param));\n \t}\n ",
      "parent_sha": "360c1d5a21273793ef5c96c21b979501bdebb5c3"
    }
  },
  {
    "oid": "9b211af8be36c67212999063134bc9dfc266f7b9",
    "message": "[jdk16] JCBindingPattern now has a field names var instead of separate fields",
    "date": "2021-03-19T02:08:10Z",
    "url": "https://github.com/projectlombok/lombok/commit/9b211af8be36c67212999063134bc9dfc266f7b9",
    "details": {
      "sha": "7531b0b12eb6d60ed2bbb3c442cd3075def54a72",
      "filename": "src/delombok/lombok/delombok/PrettyPrinter.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/projectlombok/lombok/blob/9b211af8be36c67212999063134bc9dfc266f7b9/src%2Fdelombok%2Flombok%2Fdelombok%2FPrettyPrinter.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/9b211af8be36c67212999063134bc9dfc266f7b9/src%2Fdelombok%2Flombok%2Fdelombok%2FPrettyPrinter.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fdelombok%2Flombok%2Fdelombok%2FPrettyPrinter.java?ref=9b211af8be36c67212999063134bc9dfc266f7b9",
      "patch": "@@ -1385,9 +1385,10 @@ void printYieldExpression(JCTree tree) {\n \t}\n \t\n \tvoid printBindingPattern(JCTree tree) {\n-\t\tprint((JCExpression) readObject(tree, \"vartype\", null));\n+\t\tJCTree var = readObject(tree, \"var\", tree);\n+\t\tprint((JCExpression) readObject(var, \"vartype\", null));\n \t\tprint(\" \");\n-\t\tprint((Name) readObject(tree, \"name\", null));\n+\t\tprint((Name) readObject(var, \"name\", null));\n \t}\n \t\n \t@Override public void visitTry(JCTry tree) {",
      "parent_sha": "2ed5077cae63cb193b4c7d1f8aa1ad3e9e6c2652"
    }
  },
  {
    "oid": "1eaa6da81602ddfd7d2d170974c064b8c0b117cf",
    "message": "Inline finishAndInjectSingularMethod into generateSingularMethod",
    "date": "2019-01-13T01:26:56Z",
    "url": "https://github.com/projectlombok/lombok/commit/1eaa6da81602ddfd7d2d170974c064b8c0b117cf",
    "details": {
      "sha": "db03c77a5e555d129ab1381b6e38e7e4821994be",
      "filename": "src/core/lombok/javac/handlers/JavacSingularsRecipes.java",
      "status": "modified",
      "additions": 7,
      "deletions": 11,
      "changes": 18,
      "blob_url": "https://github.com/projectlombok/lombok/blob/1eaa6da81602ddfd7d2d170974c064b8c0b117cf/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FJavacSingularsRecipes.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/1eaa6da81602ddfd7d2d170974c064b8c0b117cf/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FJavacSingularsRecipes.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FJavacSingularsRecipes.java?ref=1eaa6da81602ddfd7d2d170974c064b8c0b117cf",
      "patch": "@@ -267,7 +267,13 @@ protected void generateClearMethod(boolean deprecate, JavacTreeMaker maker, JCEx\n \t\tvoid generateSingularMethod(boolean deprecate, JavacTreeMaker maker, JCExpression returnType, JCStatement returnStatement, SingularData data, JavacNode builderType, JCTree source, boolean fluent) {\n \t\t\tListBuffer<JCStatement> statements = generateSingularMethodStatements(maker, data, builderType, source);\n \t\t\tList<JCVariableDecl> params = generateSingularMethodParameters(maker, data, builderType, source);\n-\t\t\tfinishAndInjectSingularMethod(maker, returnType, returnStatement, data, builderType, source, fluent, deprecate, statements, params, getAddMethodName());\n+\t\t\tJCModifiers mods = makeMods(maker, builderType, deprecate);\n+\t\t\tif (returnStatement != null) statements.append(returnStatement);\n+\t\t\tJCBlock body = maker.Block(0, statements.toList());\n+\t\t\tName name = data.getSingularName();\n+\t\t\tif (!fluent) name = builderType.toName(HandlerUtil.buildAccessorName(getAddMethodName(), name.toString()));\n+\n+\t\t\tfinishAndInjectMethod(maker, returnType, builderType, source, mods, body, name, params);\n \t\t}\n \n \t\tprotected JCVariableDecl generateSingularMethodParameter(int typeIndex, JavacTreeMaker maker, SingularData data, JavacNode builderType, JCTree source, Name name) {\n@@ -285,16 +291,6 @@ protected JCStatement generateSingularMethodAddStatement(JavacTreeMaker maker, J\n \t\t\treturn maker.Exec(invokeAdd);\n \t\t}\n \n-\t\tprotected void finishAndInjectSingularMethod(JavacTreeMaker maker, JCExpression returnType, JCStatement returnStatement, SingularData data, JavacNode builderType, JCTree source, boolean fluent, boolean deprecate, ListBuffer<JCStatement> statements, List<JCVariableDecl> params, String addMethodName) {\n-\t\t\tJCModifiers mods = makeMods(maker, builderType, deprecate);\n-\t\t\tif (returnStatement != null) statements.append(returnStatement);\n-\t\t\tJCBlock body = maker.Block(0, statements.toList());\n-\t\t\tName name = data.getSingularName();\n-\t\t\tif (!fluent) name = builderType.toName(HandlerUtil.buildAccessorName(addMethodName, name.toString()));\n-\n-\t\t\tfinishAndInjectMethod(maker, returnType, builderType, source, mods, body, name, params);\n-\t\t}\n-\n \t\tprotected abstract ListBuffer<JCStatement> generateSingularMethodStatements(JavacTreeMaker maker, SingularData data, JavacNode builderType, JCTree source);\n \n \t\tprotected abstract List<JCVariableDecl> generateSingularMethodParameters(JavacTreeMaker maker, SingularData data, JavacNode builderType, JCTree source);",
      "parent_sha": "452f1cb8eb11ab6335cc631e30c9ab21f9717140"
    }
  },
  {
    "oid": "233400eacba84ec33bfba5207481a6f5ec00aa65",
    "message": "Make tests run if no (eclipse-generated?) bin/ folder exists",
    "date": "2017-02-22T09:17:30Z",
    "url": "https://github.com/projectlombok/lombok/commit/233400eacba84ec33bfba5207481a6f5ec00aa65",
    "details": {
      "sha": "775e825c364f9c0ba996fa21756bd4917aaa6731",
      "filename": "test/core/src/lombok/RunTestsViaEcj.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/projectlombok/lombok/blob/233400eacba84ec33bfba5207481a6f5ec00aa65/test%2Fcore%2Fsrc%2Flombok%2FRunTestsViaEcj.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/233400eacba84ec33bfba5207481a6f5ec00aa65/test%2Fcore%2Fsrc%2Flombok%2FRunTestsViaEcj.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/test%2Fcore%2Fsrc%2Flombok%2FRunTestsViaEcj.java?ref=233400eacba84ec33bfba5207481a6f5ec00aa65",
      "patch": "@@ -137,7 +137,7 @@ private FileSystem createFileSystem(File file) {\n \t\t\t\ti.remove();\n \t\t\t}\n \t\t}\n-\t\tclasspath.add(\"bin\");\n+\t\tif (new File(\"bin\").exists()) classpath.add(\"bin\");\n \t\tclasspath.add(\"dist/lombok.jar\");\n \t\tclasspath.add(\"lib/test/commons-logging-commons-logging.jar\");\n \t\tclasspath.add(\"lib/test/org.slf4j-slf4j-api.jar\");",
      "parent_sha": "b7cede3c27e42351e72618c45fd5e960df0e0133"
    }
  },
  {
    "oid": "428023f548fce50a433bacadac1e68fdda4eda06",
    "message": "Fix Java12 tests",
    "date": "2023-03-22T09:22:34Z",
    "url": "https://github.com/projectlombok/lombok/commit/428023f548fce50a433bacadac1e68fdda4eda06",
    "details": {
      "sha": "f334ab08a13a36d051db8b5e05b7515548c500c7",
      "filename": "test/pretty/resource/after/Switch12.java",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/projectlombok/lombok/blob/428023f548fce50a433bacadac1e68fdda4eda06/test%2Fpretty%2Fresource%2Fafter%2FSwitch12.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/428023f548fce50a433bacadac1e68fdda4eda06/test%2Fpretty%2Fresource%2Fafter%2FSwitch12.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/test%2Fpretty%2Fresource%2Fafter%2FSwitch12.java?ref=428023f548fce50a433bacadac1e68fdda4eda06",
      "patch": "@@ -18,11 +18,11 @@ public void multiCase() {\n \n \tpublic int switchExpr() {\n \t\treturn switch (5) {\n-\t\tcase 1, 2 -> 0;\n-\t\tcase 3 -> {\n-\t\t\tbreak 10;\n-\t\t}\n-\t\tdefault -> 10;\n+\t\t\tcase 1, 2 -> 0;\n+\t\t\tcase 3 -> {\n+\t\t\t\tbreak 10;\n+\t\t\t}\n+\t\t\tdefault -> 10;\n \t\t} + 10;\n \t}\n }",
      "parent_sha": "193f808b69a07f7d5a658f111629c160ac422c79"
    }
  },
  {
    "oid": "7627d03afd8d10cbdefc93f0317f4d5f98cc6526",
    "message": "Issue 325: revert old behaviour of fixRetrieveRightBrace...",
    "date": "2012-01-16T21:34:12Z",
    "url": "https://github.com/projectlombok/lombok/commit/7627d03afd8d10cbdefc93f0317f4d5f98cc6526",
    "details": {
      "sha": "86f2b9cf5228ed80225685b225b90edeb389d158",
      "filename": "src/eclipseAgent/lombok/eclipse/agent/PatchFixes.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/projectlombok/lombok/blob/7627d03afd8d10cbdefc93f0317f4d5f98cc6526/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchFixes.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/7627d03afd8d10cbdefc93f0317f4d5f98cc6526/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchFixes.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchFixes.java?ref=7627d03afd8d10cbdefc93f0317f4d5f98cc6526",
      "patch": "@@ -237,7 +237,8 @@ public static int fixRetrieveEllipsisStartPosition(int original, int end) {\n \t}\n \t\n \tpublic static int fixRetrieveRightBraceOrSemiColonPosition(int original, int end) {\n-\t\treturn original == -1 ? end : original;\n+\t\treturn original;\n+\t\t// return original == -1 ? end : original;  // Need to fix: see issue 325.\n \t}\n \t\n \tpublic static final int ALREADY_PROCESSED_FLAG = 0x800000;  //Bit 24",
      "parent_sha": "06dceeb5419703b8bf87877eb6dcd448a148625a"
    }
  },
  {
    "oid": "4ab2bb7be0ec2ea3e0c61bd2c0e24bee46ff41a8",
    "message": "Turns out using instanceof checks to figure out if a LocalDeclaration is a method argument or not (by instanceof checking if it's an Argument) is faulty, as e.g. the argument to a catch block is also an Argument object. Rewritten the visitChild method to be based on a switch on the Node's getKind(), just like JavacAST. This even looks nicer.",
    "date": "2009-06-17T17:23:05Z",
    "url": "https://github.com/projectlombok/lombok/commit/4ab2bb7be0ec2ea3e0c61bd2c0e24bee46ff41a8",
    "details": {
      "sha": "e5489011b1f76b0f931e908429970a8aeab05073",
      "filename": "src/lombok/eclipse/EclipseAST.java",
      "status": "modified",
      "additions": 39,
      "deletions": 23,
      "changes": 62,
      "blob_url": "https://github.com/projectlombok/lombok/blob/4ab2bb7be0ec2ea3e0c61bd2c0e24bee46ff41a8/src%2Flombok%2Feclipse%2FEclipseAST.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/4ab2bb7be0ec2ea3e0c61bd2c0e24bee46ff41a8/src%2Flombok%2Feclipse%2FEclipseAST.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Flombok%2Feclipse%2FEclipseAST.java?ref=4ab2bb7be0ec2ea3e0c61bd2c0e24bee46ff41a8",
      "patch": "@@ -21,7 +21,6 @@\n import org.eclipse.jdt.internal.compiler.ast.ImportReference;\n import org.eclipse.jdt.internal.compiler.ast.Initializer;\n import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;\n-import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;\n import org.eclipse.jdt.internal.compiler.ast.Statement;\n import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\n import org.eclipse.jdt.internal.compiler.problem.ProblemSeverities;\n@@ -56,55 +55,72 @@ public void traverse(EclipseASTVisitor visitor) {\n \tprivate void traverseChildren(EclipseASTVisitor visitor, Node node) {\n \t\tfor ( Node child : node.down() ) {\n \t\t\tASTNode n = child.get();\n-\t\t\tif ( n instanceof TypeDeclaration ) {\n+\t\t\tswitch ( child.getKind() ) {\n+\t\t\tcase TYPE:\n \t\t\t\tvisitor.visitType(child, (TypeDeclaration)n);\n \t\t\t\ttraverseChildren(visitor, child);\n \t\t\t\tvisitor.endVisitType(child, (TypeDeclaration)n);\n-\t\t\t} else if ( n instanceof Initializer ) {\n-\t\t\t\tvisitor.visitInitializer(child, (Initializer)n);\n-\t\t\t\ttraverseChildren(visitor, child);\n-\t\t\t\tvisitor.endVisitInitializer(child, (Initializer)n);\n-\t\t\t} else if ( n instanceof FieldDeclaration ) {\n+\t\t\t\tbreak;\n+\t\t\tcase FIELD:\n \t\t\t\tvisitor.visitField(child, (FieldDeclaration)n);\n \t\t\t\ttraverseChildren(visitor, child);\n \t\t\t\tvisitor.endVisitField(child, (FieldDeclaration)n);\n-\t\t\t} else if ( n instanceof AbstractMethodDeclaration ) {\n+\t\t\t\tbreak;\n+\t\t\tcase INITIALIZER:\n+\t\t\t\tvisitor.visitInitializer(child, (Initializer)n);\n+\t\t\t\ttraverseChildren(visitor, child);\n+\t\t\t\tvisitor.endVisitInitializer(child, (Initializer)n);\n+\t\t\t\tbreak;\n+\t\t\tcase METHOD:\n \t\t\t\tif ( n instanceof Clinit ) continue;\n \t\t\t\tvisitor.visitMethod(child, (AbstractMethodDeclaration)n);\n \t\t\t\ttraverseChildren(visitor, child);\n \t\t\t\tvisitor.endVisitMethod(child, (AbstractMethodDeclaration)n);\n-\t\t\t} else if ( n instanceof Argument ) {\n-\t\t\t\tASTNode parent = child.up().get();\n-\t\t\t\tAbstractMethodDeclaration method = null;\n-\t\t\t\tif ( parent instanceof AbstractMethodDeclaration ) method = (AbstractMethodDeclaration)parent;\n-\t\t\t\telse System.out.println(\"Weird, this isn't a desc of method: \" + parent.getClass() + \": \" + parent);\n+\t\t\t\tbreak;\n+\t\t\tcase ARGUMENT:\n+\t\t\t\tAbstractMethodDeclaration method = (AbstractMethodDeclaration)child.up().get();\n \t\t\t\tvisitor.visitMethodArgument(child, (Argument)n, method);\n \t\t\t\ttraverseChildren(visitor, child);\n \t\t\t\tvisitor.endVisitMethodArgument(child, (Argument)n, method);\n-\t\t\t} else if ( n instanceof LocalDeclaration ) {\n+\t\t\t\tbreak;\n+\t\t\tcase LOCAL:\n \t\t\t\tvisitor.visitLocal(child, (LocalDeclaration)n);\n \t\t\t\ttraverseChildren(visitor, child);\n \t\t\t\tvisitor.endVisitLocal(child, (LocalDeclaration)n);\n-\t\t\t} else if ( n instanceof Annotation ) {\n+\t\t\t\tbreak;\n+\t\t\tcase ANNOTATION:\n \t\t\t\tNode parent = child.up();\n-\t\t\t\tif ( parent.get() instanceof TypeDeclaration )\n+\t\t\t\tswitch ( parent.getKind() ) {\n+\t\t\t\tcase TYPE:\n \t\t\t\t\tvisitor.visitAnnotationOnType((TypeDeclaration)parent.get(), child, (Annotation)n);\n-\t\t\t\telse if ( parent.get() instanceof AbstractMethodDeclaration )\n-\t\t\t\t\tvisitor.visitAnnotationOnMethod((AbstractMethodDeclaration)parent.get(), child, (Annotation)n);\n-\t\t\t\telse if ( parent.get() instanceof FieldDeclaration )\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase FIELD:\n \t\t\t\t\tvisitor.visitAnnotationOnField((FieldDeclaration)parent.get(), child, (Annotation)n);\n-\t\t\t\telse if ( parent.get() instanceof Argument )\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase METHOD:\n+\t\t\t\t\tvisitor.visitAnnotationOnMethod((AbstractMethodDeclaration)parent.get(), child, (Annotation)n);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase ARGUMENT:\n \t\t\t\t\tvisitor.visitAnnotationOnMethodArgument(\n \t\t\t\t\t\t\t(Argument)parent.get(),\n \t\t\t\t\t\t\t(AbstractMethodDeclaration)parent.directUp().get(),\n \t\t\t\t\t\t\tchild, (Annotation)n);\n-\t\t\t\telse if ( parent.get() instanceof LocalDeclaration )\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase LOCAL:\n \t\t\t\t\tvisitor.visitAnnotationOnLocal((LocalDeclaration)parent.get(), child, (Annotation)n);\n-\t\t\t} else if ( n instanceof Statement ) {\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault:\n+\t\t\t\t\tthrow new AssertionError(\"Annotion not expected as child of a \" + parent.getKind());\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase STATEMENT:\n \t\t\t\tvisitor.visitStatement(child, (Statement)n);\n \t\t\t\ttraverseChildren(visitor, child);\n \t\t\t\tvisitor.endVisitStatement(node, (Statement)n);\n-\t\t\t} else throw new AssertionError(\"Can't be reached\");\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new AssertionError(\"Unexpected kind during child traversal: \" + child.getKind());\n+\t\t\t}\n \t\t}\n \t}\n \t",
      "parent_sha": "024d8ffa9801f463fecadd16f42d51bbed46dea7"
    }
  },
  {
    "oid": "033356b6c6a20b929babd0e6a2ee39f280743684",
    "message": "[configuration] Add option 'stop-bubbling=true' to a lombok.config file to prevent the system from going up the directory tree to find more config files",
    "date": "2014-01-15T19:56:37Z",
    "url": "https://github.com/projectlombok/lombok/commit/033356b6c6a20b929babd0e6a2ee39f280743684",
    "details": {
      "sha": "440d7b685bb261391c33b8cbbc8addf216a63db8",
      "filename": "src/core/lombok/core/configuration/BubblingConfigurationResolver.java",
      "status": "modified",
      "additions": 8,
      "deletions": 4,
      "changes": 12,
      "blob_url": "https://github.com/projectlombok/lombok/blob/033356b6c6a20b929babd0e6a2ee39f280743684/src%2Fcore%2Flombok%2Fcore%2Fconfiguration%2FBubblingConfigurationResolver.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/033356b6c6a20b929babd0e6a2ee39f280743684/src%2Fcore%2Flombok%2Fcore%2Fconfiguration%2FBubblingConfigurationResolver.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fcore%2Fconfiguration%2FBubblingConfigurationResolver.java?ref=033356b6c6a20b929babd0e6a2ee39f280743684",
      "patch": "@@ -30,14 +30,16 @@\n \n public class BubblingConfigurationResolver implements ConfigurationResolver {\n \t\n-\tprivate final List<ConfigurationSource> sources;\n+\tprivate static final ConfigurationKey<Boolean> STOP_BUBBLING = new ConfigurationKey<Boolean>(\"stop-bubbling\") {};\n \t\n-\tpublic BubblingConfigurationResolver(List<ConfigurationSource> sources) {\n+\tprivate final Iterable<ConfigurationSource> sources;\n+\t\n+\tpublic BubblingConfigurationResolver(Iterable<ConfigurationSource> sources) {\n \t\tthis.sources = sources;\n \t}\n \t\n-\t@SuppressWarnings(\"unchecked\") \n-\t@Override \n+\t@SuppressWarnings(\"unchecked\")\n+\t@Override\n \tpublic <T> T resolve(ConfigurationKey<T> key) {\n \t\tboolean isList = key.getType().isList();\n \t\tList<ListModification> listModifications = null;\n@@ -57,6 +59,8 @@ public <T> T resolve(ConfigurationKey<T> key) {\n \t\t\t\t}\n \t\t\t\treturn result.getValue();\n \t\t\t}\n+\t\t\tResult<Boolean> stop = source.resolve(STOP_BUBBLING);\n+\t\t\tif (stop != null && Boolean.TRUE.equals(stop.getValue())) break;\n \t\t}\n \t\tif (!isList) {\n \t\t\treturn null;",
      "parent_sha": "96e1c9e02e4b58733c2b076dee1c3e1772bb6a41"
    }
  },
  {
    "oid": "2f210869f3ad6608cfa1aa8b8beb12c2f4bb9c35",
    "message": "Make fieldsOfASTClasses thread safe",
    "date": "2016-10-17T20:32:38Z",
    "url": "https://github.com/projectlombok/lombok/commit/2f210869f3ad6608cfa1aa8b8beb12c2f4bb9c35",
    "details": {
      "sha": "2d5e5352b1a018cc29de8d7d17a4c774ad0fb0ed",
      "filename": "src/core/lombok/core/AST.java",
      "status": "modified",
      "additions": 8,
      "deletions": 7,
      "changes": 15,
      "blob_url": "https://github.com/projectlombok/lombok/blob/2f210869f3ad6608cfa1aa8b8beb12c2f4bb9c35/src%2Fcore%2Flombok%2Fcore%2FAST.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/2f210869f3ad6608cfa1aa8b8beb12c2f4bb9c35/src%2Fcore%2Flombok%2Fcore%2FAST.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fcore%2FAST.java?ref=2f210869f3ad6608cfa1aa8b8beb12c2f4bb9c35",
      "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2009-2013 The Project Lombok Authors.\n+ * Copyright (C) 2009-2016 The Project Lombok Authors.\n  * \n  * Permission is hereby granted, free of charge, to any person obtaining a copy\n  * of this software and associated documentation files (the \"Software\"), to deal\n@@ -21,7 +21,7 @@\n  */\n package lombok.core;\n \n-import static lombok.Lombok.*;\n+import static lombok.Lombok.sneakyThrow;\n \n import java.lang.reflect.Array;\n import java.lang.reflect.Field;\n@@ -31,10 +31,11 @@\n import java.net.URI;\n import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.HashMap;\n import java.util.IdentityHashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n \n import lombok.core.configuration.ConfigurationKey;\n import lombok.core.debug.HistogramTracker;\n@@ -209,20 +210,20 @@ protected static class FieldAccess {\n \t\t}\n \t}\n \t\n-\tprivate static Map<Class<?>, Collection<FieldAccess>> fieldsOfASTClasses = new HashMap<Class<?>, Collection<FieldAccess>>();\n+\tprivate static final ConcurrentMap<Class<?>, Collection<FieldAccess>> fieldsOfASTClasses = new ConcurrentHashMap<Class<?>, Collection<FieldAccess>>();\n \t\n \t/** Returns FieldAccess objects for the stated class. Each field that contains objects of the kind returned by\n \t * {@link #getStatementTypes()}, either directly or inside of an array or java.util.collection (or array-of-arrays,\n-\t * or collection-of-collections, etcetera), is returned.\n+\t * or collection-of-collections, et cetera), is returned.\n \t */\n \tprotected Collection<FieldAccess> fieldsOf(Class<?> c) {\n \t\tCollection<FieldAccess> fields = fieldsOfASTClasses.get(c);\n \t\tif (fields != null) return fields;\n \t\t\n \t\tfields = new ArrayList<FieldAccess>();\n \t\tgetFields(c, fields);\n-\t\tfieldsOfASTClasses.put(c, fields);\n-\t\treturn fields;\n+\t\tfieldsOfASTClasses.putIfAbsent(c, fields);\n+\t\treturn fieldsOfASTClasses.get(c);\n \t}\n \t\n \tprivate void getFields(Class<?> c, Collection<FieldAccess> fields) {",
      "parent_sha": "0f0cb68eac20c6f02b77c1fade88cdad8b7d85a2"
    }
  },
  {
    "oid": "1853b71c05ea083b5e103611a617a4d4b7d1c074",
    "message": "[bugfix] builder.default with the old lombok.experimental.Builder annotation only worked in javac, not eclipse.",
    "date": "2018-02-06T23:49:41Z",
    "url": "https://github.com/projectlombok/lombok/commit/1853b71c05ea083b5e103611a617a4d4b7d1c074",
    "details": {
      "sha": "be2b986d58cca8ff830b1712e35215099acb512c",
      "filename": "src/core/lombok/eclipse/handlers/HandleBuilderDefault.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/projectlombok/lombok/blob/1853b71c05ea083b5e103611a617a4d4b7d1c074/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleBuilderDefault.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/1853b71c05ea083b5e103611a617a4d4b7d1c074/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleBuilderDefault.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleBuilderDefault.java?ref=1853b71c05ea083b5e103611a617a4d4b7d1c074",
      "patch": "@@ -39,7 +39,7 @@ public class HandleBuilderDefault extends EclipseAnnotationHandler<Builder.Defau\n \t\tEclipseNode annotatedField = annotationNode.up();\n \t\tif (annotatedField.getKind() != Kind.FIELD) return;\n \t\tEclipseNode classWithAnnotatedField = annotatedField.up();\n-\t\tif (!hasAnnotation(Builder.class, classWithAnnotatedField)) {\n+\t\tif (!hasAnnotation(Builder.class, classWithAnnotatedField) && !hasAnnotation(\"lombok.experimental.Builder\", classWithAnnotatedField)) {\n \t\t\tannotationNode.addWarning(\"@Builder.Default requires @Builder on the class for it to mean anything.\");\n \t\t}\n \t}",
      "parent_sha": "45967c522eca156bf0eeae14ebd9f466d23bd470"
    }
  },
  {
    "oid": "595a3041a01602d9a28aefe71bad021353900253",
    "message": "[fix] Fix intellij build with jdk10 (#1572)\n\nAdd a JavaFileManager class name to KNOWN_JAVA9_FILE_MANAGERS.",
    "date": "2018-03-21T07:43:12Z",
    "url": "https://github.com/projectlombok/lombok/commit/595a3041a01602d9a28aefe71bad021353900253",
    "details": {
      "sha": "f74c7d228e0ca4508c218856d5393c32b824a5a8",
      "filename": "src/core/lombok/javac/apt/LombokFileObjects.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/projectlombok/lombok/blob/595a3041a01602d9a28aefe71bad021353900253/src%2Fcore%2Flombok%2Fjavac%2Fapt%2FLombokFileObjects.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/595a3041a01602d9a28aefe71bad021353900253/src%2Fcore%2Flombok%2Fjavac%2Fapt%2FLombokFileObjects.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fjavac%2Fapt%2FLombokFileObjects.java?ref=595a3041a01602d9a28aefe71bad021353900253",
      "patch": "@@ -106,7 +106,8 @@ private LombokFileObjects() {}\n \t\t\"com.google.devtools.build.buildjar.javac.BlazeJavacMain$ClassloaderMaskingFileManager\",\n \t\t\"com.google.devtools.build.java.turbine.javac.JavacTurbineCompiler$ClassloaderMaskingFileManager\",\n \t\t\"org.netbeans.modules.java.source.parsing.ProxyFileManager\",\n-\t\t\"com.sun.tools.javac.api.ClientCodeWrapper$WrappedStandardJavaFileManager\"\n+\t\t\"com.sun.tools.javac.api.ClientCodeWrapper$WrappedStandardJavaFileManager\",\n+\t\t\"com.sun.tools.javac.main.DelegatingJavaFileManager$DelegatingSJFM\" // IntelliJ + JDK10\n \t);\n \t\n \tstatic Compiler getCompiler(JavaFileManager jfm) {",
      "parent_sha": "5a5d75a931e66b03212081e35bdfdc7b6be98783"
    }
  },
  {
    "oid": "c37c33be46961fd6ebc8bec24cee24f62d066f03",
    "message": "wildcards for the constructor parameter",
    "date": "2018-04-05T16:42:59Z",
    "url": "https://github.com/projectlombok/lombok/commit/c37c33be46961fd6ebc8bec24cee24f62d066f03",
    "details": {
      "sha": "2c292822d20f12134e35e73565b37cd2d4faf524",
      "filename": "src/core/lombok/javac/handlers/HandleSuperBuilder.java",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/projectlombok/lombok/blob/c37c33be46961fd6ebc8bec24cee24f62d066f03/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FHandleSuperBuilder.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/c37c33be46961fd6ebc8bec24cee24f62d066f03/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FHandleSuperBuilder.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FHandleSuperBuilder.java?ref=c37c33be46961fd6ebc8bec24cee24f62d066f03",
      "patch": "@@ -377,7 +377,13 @@ private void generateBuilderBasedConstructor(JavacNode typeNode, java.util.List<\n \t\tListBuffer<JCVariableDecl> params = new ListBuffer<JCVariableDecl>();\n \t\tlong flags = JavacHandlerUtil.addFinalIfNeeded(Flags.PARAMETER, typeNode.getContext());\n \t\tName builderClassname = typeNode.toName(builderClassName);\n-\t\tJCVariableDecl param = maker.VarDef(maker.Modifiers(flags), builderVariableName, maker.Ident(builderClassname), null);\n+\t\t// Now add the <?, ?>.\n+\t\tListBuffer<JCExpression> typeParams = new ListBuffer<JCExpression>();\n+\t\tJCWildcard wildcard = maker.Wildcard(maker.TypeBoundKind(BoundKind.UNBOUND), null);\n+\t\ttypeParams.add(wildcard);\n+\t\ttypeParams.add(wildcard);\n+\t\tJCTypeApply paramType = maker.TypeApply(maker.Ident(builderClassname), typeParams.toList());\n+\t\tJCVariableDecl param = maker.VarDef(maker.Modifiers(flags), builderVariableName, paramType, null);\n \t\tparams.append(param);\n \n \t\tif (callBuilderBasedSuperConstructor) {",
      "parent_sha": "d586cc6b4fc1afb0a9e59e73ac3db1f5c914e191"
    }
  },
  {
    "oid": "4a2e117e86479c07a23efc4b81615a9e266a95d1",
    "message": "[fixes #2756] Mark generated UtilityClass constructor as generated",
    "date": "2021-02-25T20:42:23Z",
    "url": "https://github.com/projectlombok/lombok/commit/4a2e117e86479c07a23efc4b81615a9e266a95d1",
    "details": {
      "sha": "5e7d2853e5b1ef0d40cef7304525b78e297245e1",
      "filename": "src/core/lombok/eclipse/handlers/HandleUtilityClass.java",
      "status": "modified",
      "additions": 4,
      "deletions": 15,
      "changes": 19,
      "blob_url": "https://github.com/projectlombok/lombok/blob/4a2e117e86479c07a23efc4b81615a9e266a95d1/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleUtilityClass.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/4a2e117e86479c07a23efc4b81615a9e266a95d1/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleUtilityClass.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleUtilityClass.java?ref=4a2e117e86479c07a23efc4b81615a9e266a95d1",
      "patch": "@@ -25,8 +25,6 @@\n import static lombok.eclipse.Eclipse.*;\n import static lombok.eclipse.handlers.EclipseHandlerUtil.*;\n \n-import java.util.Arrays;\n-\n import org.eclipse.jdt.internal.compiler.ast.ASTNode;\n import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;\n import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;\n@@ -158,37 +156,28 @@ private void createPrivateDefaultConstructor(EclipseNode typeNode, EclipseNode s\n \t\tASTNode source = sourceNode.get();\n \t\t\n \t\tTypeDeclaration typeDeclaration = ((TypeDeclaration) typeNode.get());\n-\t\tlong p = (long) source.sourceStart << 32 | source.sourceEnd;\n \t\t\n \t\tConstructorDeclaration constructor = new ConstructorDeclaration(((CompilationUnitDeclaration) typeNode.top().get()).compilationResult);\n \t\t\n \t\tconstructor.modifiers = ClassFileConstants.AccPrivate;\n \t\tconstructor.selector = typeDeclaration.name;\n \t\tconstructor.constructorCall = new ExplicitConstructorCall(ExplicitConstructorCall.ImplicitSuper);\n-\t\tconstructor.constructorCall.sourceStart = source.sourceStart;\n-\t\tconstructor.constructorCall.sourceEnd = source.sourceEnd;\n \t\tconstructor.thrownExceptions = null;\n \t\tconstructor.typeParameters = null;\n \t\tconstructor.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;\n-\t\tconstructor.bodyStart = constructor.declarationSourceStart = constructor.sourceStart = source.sourceStart;\n-\t\tconstructor.bodyEnd = constructor.declarationSourceEnd = constructor.sourceEnd = source.sourceEnd;\n \t\tconstructor.arguments = null;\n \t\t\n-\t\tAllocationExpression exception = new AllocationExpression();\n-\t\tsetGeneratedBy(exception, source);\n \t\tlong[] ps = new long[JAVA_LANG_UNSUPPORTED_OPERATION_EXCEPTION.length];\n-\t\tArrays.fill(ps, p);\n+\t\tAllocationExpression exception = new AllocationExpression();\n \t\texception.type = new QualifiedTypeReference(JAVA_LANG_UNSUPPORTED_OPERATION_EXCEPTION, ps);\n-\t\tsetGeneratedBy(exception.type, source);\n \t\texception.arguments = new Expression[] {\n-\t\t\t\tnew StringLiteral(UNSUPPORTED_MESSAGE, source.sourceStart, source.sourceEnd, 0)\n+\t\t\t\tnew StringLiteral(UNSUPPORTED_MESSAGE, 0, 0, 0)\n \t\t};\n-\t\tsetGeneratedBy(exception.arguments[0], source);\n-\t\tThrowStatement throwStatement = new ThrowStatement(exception, source.sourceStart, source.sourceEnd);\n-\t\tsetGeneratedBy(throwStatement, source);\n+\t\tThrowStatement throwStatement = new ThrowStatement(exception, 0, 0);\n \t\t\n \t\tconstructor.statements = new Statement[] {throwStatement};\n \t\t\n+\t\tconstructor.traverse(new SetGeneratedByVisitor(source), typeDeclaration.scope);\n \t\tinjectMethod(typeNode, constructor);\n \t}\n }",
      "parent_sha": "ed4ced1a3bc694f9a9903b5a15b2641236ff2f92"
    }
  },
  {
    "oid": "5e9e16a6b98da5a17f5efe785917bc1e92265fc8",
    "message": "Update to error messages of @Log annotations.",
    "date": "2012-02-14T15:39:02Z",
    "url": "https://github.com/projectlombok/lombok/commit/5e9e16a6b98da5a17f5efe785917bc1e92265fc8",
    "details": {
      "sha": "9038a0c93b1f95abb021ab57f4a7b7cdbbe89676",
      "filename": "src/core/lombok/eclipse/handlers/HandleLog.java",
      "status": "modified",
      "additions": 13,
      "deletions": 8,
      "changes": 21,
      "blob_url": "https://github.com/projectlombok/lombok/blob/5e9e16a6b98da5a17f5efe785917bc1e92265fc8/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleLog.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/5e9e16a6b98da5a17f5efe785917bc1e92265fc8/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleLog.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleLog.java?ref=5e9e16a6b98da5a17f5efe785917bc1e92265fc8",
      "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2010 The Project Lombok Authors.\n+ * Copyright (C) 2010-2012 The Project Lombok Authors.\n  * \n  * Permission is hereby granted, free of charge, to any person obtaining a copy\n  * of this software and associated documentation files (the \"Software\"), to deal\n@@ -60,7 +60,7 @@ public static void processAnnotation(LoggingFramework framework, AnnotationValue\n \t\t\t\t\t(ClassFileConstants.AccInterface | ClassFileConstants.AccAnnotation)) != 0;\n \t\t\t\n \t\t\tif (typeDecl == null || notAClass) {\n-\t\t\t\tannotationNode.addError(\"@Log is legal only on classes and enums.\");\n+\t\t\t\tannotationNode.addError(framework.getAnnotationAsString() + \" is legal only on classes and enums.\");\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t\n@@ -77,7 +77,6 @@ public static void processAnnotation(LoggingFramework framework, AnnotationValue\n \t\t\towner.rebuild();\n \t\t\tbreak;\n \t\tdefault:\n-\t\t\tannotationNode.addError(\"@Log is legal only on types.\");\n \t\t\tbreak;\n \t\t}\n \t}\n@@ -190,10 +189,10 @@ public static class HandleSlf4jLog extends EclipseAnnotationHandler<lombok.exter\n \t\n \tenum LoggingFramework {\n \t\t// private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(TargetType.class);\n-\t\tCOMMONS(\"org.apache.commons.logging.Log\", \"org.apache.commons.logging.LogFactory\", \"getLog\"),\n+\t\tCOMMONS(\"org.apache.commons.logging.Log\", \"org.apache.commons.logging.LogFactory\", \"getLog\", \"@CommonsLog\"),\n \t\t\n \t\t// private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(TargetType.class.getName());\n-\t\tJUL(\"java.util.logging.Logger\", \"java.util.logging.Logger\", \"getLogger\") {\n+\t\tJUL(\"java.util.logging.Logger\", \"java.util.logging.Logger\", \"getLogger\", \"@Log\") {\n \t\t\t@Override public Expression createFactoryParameter(ClassLiteralAccess type, Annotation source) {\n \t\t\t\tint pS = source.sourceStart, pE = source.sourceEnd;\n \t\t\t\tlong p = (long)pS << 32 | pE;\n@@ -213,21 +212,27 @@ enum LoggingFramework {\n \t\t},\n \t\t\n \t\t// private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(TargetType.class);\n-\t\tLOG4J(\"org.apache.log4j.Logger\", \"org.apache.log4j.Logger\", \"getLogger\"),\n+\t\tLOG4J(\"org.apache.log4j.Logger\", \"org.apache.log4j.Logger\", \"getLogger\", \"@Log4j\"),\n \n \t\t// private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(TargetType.class);\n-\t\tSLF4J(\"org.slf4j.Logger\", \"org.slf4j.LoggerFactory\", \"getLogger\"),\n+\t\tSLF4J(\"org.slf4j.Logger\", \"org.slf4j.LoggerFactory\", \"getLogger\", \"@Slf4j\"),\n \t\t\n \t\t;\n \t\t\n \t\tprivate final String loggerTypeName;\n \t\tprivate final String loggerFactoryTypeName;\n \t\tprivate final String loggerFactoryMethodName;\n+\t\tprivate final String annotationAsString;\n \n-\t\tLoggingFramework(String loggerTypeName, String loggerFactoryTypeName, String loggerFactoryMethodName) {\n+\t\tLoggingFramework(String loggerTypeName, String loggerFactoryTypeName, String loggerFactoryMethodName, String annotationAsString) {\n \t\t\tthis.loggerTypeName = loggerTypeName;\n \t\t\tthis.loggerFactoryTypeName = loggerFactoryTypeName;\n \t\t\tthis.loggerFactoryMethodName = loggerFactoryMethodName;\n+\t\t\tthis.annotationAsString = annotationAsString;\n+\t\t}\n+\t\t\n+\t\tfinal String getAnnotationAsString() {\n+\t\t\treturn annotationAsString;\n \t\t}\n \t\t\n \t\tfinal String getLoggerTypeName() {",
      "parent_sha": "29d2553deedcf5ac9b4c5fb1b40b20d0d5917682"
    }
  },
  {
    "oid": "dcc4f8f4ff8bb495a2ba92f5c01f143401465957",
    "message": "Removed double semicolon\n\nHi\r\n\r\nI have removed a typo error of 2 semicolons at the end of two lines\r\n\r\nciao\r\nmatteo",
    "date": "2022-01-25T00:59:26Z",
    "url": "https://github.com/projectlombok/lombok/commit/dcc4f8f4ff8bb495a2ba92f5c01f143401465957",
    "details": {
      "sha": "9a5e97e3073df6f077664e027a64108ddac50e1e",
      "filename": "src/core/lombok/core/configuration/ConfigurationFile.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/projectlombok/lombok/blob/dcc4f8f4ff8bb495a2ba92f5c01f143401465957/src%2Fcore%2Flombok%2Fcore%2Fconfiguration%2FConfigurationFile.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/dcc4f8f4ff8bb495a2ba92f5c01f143401465957/src%2Fcore%2Flombok%2Fcore%2Fconfiguration%2FConfigurationFile.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fcore%2Fconfiguration%2FConfigurationFile.java?ref=dcc4f8f4ff8bb495a2ba92f5c01f143401465957",
      "patch": "@@ -39,7 +39,7 @@\n public abstract class ConfigurationFile {\n \tprivate static final Pattern VARIABLE = Pattern.compile(\"\\\\<(.+?)\\\\>\");\n \tprivate static final String LOMBOK_CONFIG_FILENAME = \"lombok.config\";\n-\tprivate static final Map<String, String> ENV = new HashMap<String, String>(System.getenv());;\n+\tprivate static final Map<String, String> ENV = new HashMap<String, String>(System.getenv());\n \t\n \tprivate static final ThreadLocal<byte[]> buffers = new ThreadLocal<byte[]>() {\n \t\tprotected byte[] initialValue() {\n@@ -178,7 +178,7 @@ CharSequence contents() throws IOException {\n \t\t}\n \t\t\n \t\tprivate static String replaceEnvironmentVariables(String fileName) {\n-\t\t\tint start = 0;;\n+\t\t\tint start = 0;\n \t\t\tStringBuffer result = new StringBuffer();\n \t\t\tif (fileName.startsWith(\"~\")) {\n \t\t\t\tstart = 1;\n@@ -331,4 +331,4 @@ private CharSequenceConfigurationFile(String identifier, CharSequence contents,\n \t\t\treturn null;\n \t\t}\n \t}\n-}\n\\ No newline at end of file\n+}",
      "parent_sha": "f6ba4700996a80bb8c819ca2096041de7e8d647a"
    }
  },
  {
    "oid": "931a77855843e05f6a3da036e6c73f6c4656782b",
    "message": "fixed the second \"equals\" as well",
    "date": "2017-11-07T02:43:54Z",
    "url": "https://github.com/projectlombok/lombok/commit/931a77855843e05f6a3da036e6c73f6c4656782b",
    "details": {
      "sha": "0c43c40b16fa49e41c2d6da328cf1d4019f3505a",
      "filename": "src/core/lombok/ToString.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/projectlombok/lombok/blob/931a77855843e05f6a3da036e6c73f6c4656782b/src%2Fcore%2Flombok%2FToString.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/931a77855843e05f6a3da036e6c73f6c4656782b/src%2Fcore%2Flombok%2FToString.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2FToString.java?ref=931a77855843e05f6a3da036e6c73f6c4656782b",
      "patch": "@@ -64,7 +64,7 @@\n \t * Include the result of the superclass's implementation of {@code toString} in the output.\n \t * <strong>default: false</strong>\n \t * \n-\t * @return Whether to call the superclass's {@code toString} implementation as part of the generated equals algorithm.\n+\t * @return Whether to call the superclass's {@code toString} implementation as part of the generated toString algorithm.\n \t */\n \tboolean callSuper() default false;\n \t",
      "parent_sha": "98b0d91d091b554cb3ab9ed9f972d358c7cae01a"
    }
  },
  {
    "oid": "5bd3abdfe528344f0ae965b99332e20d7581680c",
    "message": "[TRIVIAL]",
    "date": "2009-12-01T23:05:28Z",
    "url": "https://github.com/projectlombok/lombok/commit/5bd3abdfe528344f0ae965b99332e20d7581680c",
    "details": {
      "sha": "4821851397cf197772381be2c76c76436df5a7d7",
      "filename": "src/core/lombok/javac/HandlerLibrary.java",
      "status": "modified",
      "additions": 19,
      "deletions": 30,
      "changes": 49,
      "blob_url": "https://github.com/projectlombok/lombok/blob/5bd3abdfe528344f0ae965b99332e20d7581680c/src%2Fcore%2Flombok%2Fjavac%2FHandlerLibrary.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/5bd3abdfe528344f0ae965b99332e20d7581680c/src%2Fcore%2Flombok%2Fjavac%2FHandlerLibrary.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fjavac%2FHandlerLibrary.java?ref=5bd3abdfe528344f0ae965b99332e20d7581680c",
      "patch": "@@ -21,14 +21,12 @@\n  */\n package lombok.javac;\n \n+import java.io.IOException;\n import java.lang.annotation.Annotation;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashMap;\n-import java.util.Iterator;\n import java.util.Map;\n-import java.util.ServiceConfigurationError;\n-import java.util.ServiceLoader;\n \n import javax.annotation.processing.Messager;\n import javax.tools.Diagnostic;\n@@ -85,46 +83,36 @@ public boolean handle(final JavacNode node) {\n \tpublic static HandlerLibrary load(Messager messager) {\n \t\tHandlerLibrary library = new HandlerLibrary(messager);\n \t\t\n-\t\tloadAnnotationHandlers(library);\n-\t\tloadVisitorHandlers(library);\n+\t\ttry {\n+\t\t\tloadAnnotationHandlers(library);\n+\t\t\tloadVisitorHandlers(library);\n+\t\t} catch (IOException e) {\n+\t\t\tSystem.err.println(\"Lombok isn't running due to misconfigured SPI files: \" + e);\n+\t\t}\n \t\t\n \t\treturn library;\n \t}\n \t\n \t/** Uses SPI Discovery to find implementations of {@link JavacAnnotationHandler}. */\n \t@SuppressWarnings(\"unchecked\")\n-\tprivate static void loadAnnotationHandlers(HandlerLibrary lib) {\n+\tprivate static void loadAnnotationHandlers(HandlerLibrary lib) throws IOException {\n \t\t//No, that seemingly superfluous reference to JavacAnnotationHandler's classloader is not in fact superfluous!\n-\t\tIterator<JavacAnnotationHandler> it = ServiceLoader.load(JavacAnnotationHandler.class,\n-\t\t\t\tJavacAnnotationHandler.class.getClassLoader()).iterator();\n-\t\twhile (it.hasNext()) {\n-\t\t\ttry {\n-\t\t\t\tJavacAnnotationHandler<?> handler = it.next();\n-\t\t\t\tClass<? extends Annotation> annotationClass =\n-\t\t\t\t\tSpiLoadUtil.findAnnotationClass(handler.getClass(), JavacAnnotationHandler.class);\n-\t\t\t\tAnnotationHandlerContainer<?> container = new AnnotationHandlerContainer(handler, annotationClass);\n-\t\t\t\tif (lib.annotationHandlers.put(container.annotationClass.getName(), container) != null) {\n-\t\t\t\t\tlib.javacWarning(\"Duplicate handlers for annotation type: \" + container.annotationClass.getName());\n-\t\t\t\t}\n-\t\t\t\tlib.typeLibrary.addType(container.annotationClass.getName());\n-\t\t\t} catch (ServiceConfigurationError e) {\n-\t\t\t\tlib.javacWarning(\"Can't load Lombok annotation handler for javac\", e);\n+\t\tfor (JavacAnnotationHandler handler : SpiLoadUtil.findServices(JavacAnnotationHandler.class, JavacAnnotationHandler.class.getClassLoader())) {\n+\t\t\tClass<? extends Annotation> annotationClass =\n+\t\t\t\tSpiLoadUtil.findAnnotationClass(handler.getClass(), JavacAnnotationHandler.class);\n+\t\t\tAnnotationHandlerContainer<?> container = new AnnotationHandlerContainer(handler, annotationClass);\n+\t\t\tif (lib.annotationHandlers.put(container.annotationClass.getName(), container) != null) {\n+\t\t\t\tlib.javacWarning(\"Duplicate handlers for annotation type: \" + container.annotationClass.getName());\n \t\t\t}\n+\t\t\tlib.typeLibrary.addType(container.annotationClass.getName());\n \t\t}\n \t}\n \t\n \t/** Uses SPI Discovery to find implementations of {@link JavacASTVisitor}. */\n-\tprivate static void loadVisitorHandlers(HandlerLibrary lib) {\n+\tprivate static void loadVisitorHandlers(HandlerLibrary lib) throws IOException {\n \t\t//No, that seemingly superfluous reference to JavacASTVisitor's classloader is not in fact superfluous!\n-\t\tIterator<JavacASTVisitor> it = ServiceLoader.load(JavacASTVisitor.class,\n-\t\t\t\tJavacASTVisitor.class.getClassLoader()).iterator();\n-\t\twhile (it.hasNext()) {\n-\t\t\ttry {\n-\t\t\t\tJavacASTVisitor handler = it.next();\n-\t\t\t\tlib.visitorHandlers.add(handler);\n-\t\t\t} catch (ServiceConfigurationError e) {\n-\t\t\t\tlib.javacWarning(\"Can't load Lombok visitor handler for javac\", e);\n-\t\t\t}\n+\t\tfor (JavacASTVisitor visitor : SpiLoadUtil.findServices(JavacASTVisitor.class, JavacASTVisitor.class.getClassLoader())) {\n+\t\t\tlib.visitorHandlers.add(visitor);\n \t\t}\n \t}\n \t\n@@ -177,6 +165,7 @@ public boolean handleAnnotation(JCCompilationUnit unit, JavacNode node, JCAnnota\n \t\t\tif (container == null) continue;\n \t\t\t\n \t\t\ttry {\n+\t\t\t\tSystem.out.println(\"Calling handle on: \"+ container.handler.getClass().getName());\n \t\t\t\thandled |= container.handle(node);\n \t\t\t} catch (AnnotationValueDecodeFail fail) {\n \t\t\t\tfail.owner.setError(fail.getMessage(), fail.idx);",
      "parent_sha": "8165f4628f75618f1cd105ad8901f273ada261e4"
    }
  },
  {
    "oid": "fa70b194aa7db62bdbc4cc759a606f97fe50fc92",
    "message": "[trivial] the pos array was one too large here, shouldn't have any effect other than save a smidge of memory.",
    "date": "2020-01-28T15:21:39Z",
    "url": "https://github.com/projectlombok/lombok/commit/fa70b194aa7db62bdbc4cc759a606f97fe50fc92",
    "details": {
      "sha": "aa48e00089dfddd98a685f769796f1d095030374",
      "filename": "src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/projectlombok/lombok/blob/fa70b194aa7db62bdbc4cc759a606f97fe50fc92/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FEclipseHandlerUtil.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/fa70b194aa7db62bdbc4cc759a606f97fe50fc92/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FEclipseHandlerUtil.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FEclipseHandlerUtil.java?ref=fa70b194aa7db62bdbc4cc759a606f97fe50fc92",
      "patch": "@@ -2018,7 +2018,7 @@ public static Statement generateNullCheck(TypeReference type, char[] variable, E\n \t\t\t\tutilityTypeName[i] = method.get(i).toCharArray();\n \t\t\t}\n \t\t\t\n-\t\t\tinvocation.receiver = new QualifiedNameReference(utilityTypeName, new long[method.size()], pS, pE);\n+\t\t\tinvocation.receiver = new QualifiedNameReference(utilityTypeName, new long[method.size() - 1], pS, pE);\n \t\t\tsetGeneratedBy(invocation.receiver, source);\n \t\t\tinvocation.selector = method.get(method.size() - 1).toCharArray();\n \t\t\tinvocation.arguments = new Expression[] {varName, message};",
      "parent_sha": "91a40b83125808d3684ce07c5cb4a2927d0b979c"
    }
  },
  {
    "oid": "2eabd8485df6fb01e05cf7bcf797d922b9d4e012",
    "message": "[delombok] [prettyprinter] add support for the compact record constructor",
    "date": "2021-03-23T03:58:20Z",
    "url": "https://github.com/projectlombok/lombok/commit/2eabd8485df6fb01e05cf7bcf797d922b9d4e012",
    "details": {
      "sha": "8ce38c334bb2381cd4d310fdb4a98dbb5edd8889",
      "filename": "src/delombok/lombok/delombok/PrettyPrinter.java",
      "status": "modified",
      "additions": 22,
      "deletions": 12,
      "changes": 34,
      "blob_url": "https://github.com/projectlombok/lombok/blob/2eabd8485df6fb01e05cf7bcf797d922b9d4e012/src%2Fdelombok%2Flombok%2Fdelombok%2FPrettyPrinter.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/2eabd8485df6fb01e05cf7bcf797d922b9d4e012/src%2Fdelombok%2Flombok%2Fdelombok%2FPrettyPrinter.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fdelombok%2Flombok%2Fdelombok%2FPrettyPrinter.java?ref=2eabd8485df6fb01e05cf7bcf797d922b9d4e012",
      "patch": "@@ -812,21 +812,31 @@ private void printTextBlock(String s) {\n \t\t\tprint(tree.name);\n \t\t}\n \t\t\n-\t\tboolean first = true;\n-\t\tprint(\"(\");\n-\t\t\n-\t\tJCVariableDecl recvparam = readObject(tree, \"recvparam\", null);\n-\t\tif (recvparam != null) {\n-\t\t\tprintVarDefInline(recvparam);\n-\t\t\tfirst = false;\n+\t\tboolean argsLessConstructor = false;\n+\t\tif (isConstructor && (tree.mods.flags & COMPACT_RECORD_CONSTRUCTOR) != 0) {\n+\t\t\targsLessConstructor = true;\n+\t\t\tfor (JCVariableDecl param : tree.params) {\n+\t\t\t\tif ((param.mods.flags & GENERATED_MEMBER) == 0) argsLessConstructor = false;\n+\t\t\t}\n \t\t}\n \t\t\n-\t\tfor (JCVariableDecl param : tree.params) {\n-\t\t\tif (!first) print(\", \");\n-\t\t\tfirst = false;\n-\t\t\tprintVarDefInline(param);\n+\t\tboolean first = true;\n+\t\tif (!argsLessConstructor) {\n+\t\t\tprint(\"(\");\n+\t\t\t\n+\t\t\tJCVariableDecl recvparam = readObject(tree, \"recvparam\", null);\n+\t\t\tif (recvparam != null) {\n+\t\t\t\tprintVarDefInline(recvparam);\n+\t\t\t\tfirst = false;\n+\t\t\t}\n+\t\t\t\n+\t\t\tfor (JCVariableDecl param : tree.params) {\n+\t\t\t\tif (!first) print(\", \");\n+\t\t\t\tfirst = false;\n+\t\t\t\tprintVarDefInline(param);\n+\t\t\t}\n+\t\t\tprint(\")\");\n \t\t}\n-\t\tprint(\")\");\n \t\t\n \t\tif (tree.thrown.nonEmpty()) {\n \t\t\tprint(\" throws \");",
      "parent_sha": "5e2a90836d0c332b75af15b8f42403cf799ec355"
    }
  },
  {
    "oid": "5a9dff08393e7767a7dbe5ca483764614aa1ac54",
    "message": "Added documentation to LombokApp.",
    "date": "2009-11-27T13:44:28Z",
    "url": "https://github.com/projectlombok/lombok/commit/5a9dff08393e7767a7dbe5ca483764614aa1ac54",
    "details": {
      "sha": "b88db46946e9bc3f37607a45f70108246780239c",
      "filename": "src/core/lombok/core/LombokApp.java",
      "status": "modified",
      "additions": 35,
      "deletions": 1,
      "changes": 36,
      "blob_url": "https://github.com/projectlombok/lombok/blob/5a9dff08393e7767a7dbe5ca483764614aa1ac54/src%2Fcore%2Flombok%2Fcore%2FLombokApp.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/5a9dff08393e7767a7dbe5ca483764614aa1ac54/src%2Fcore%2Flombok%2Fcore%2FLombokApp.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fcore%2FLombokApp.java?ref=5a9dff08393e7767a7dbe5ca483764614aa1ac54",
      "patch": "@@ -1,6 +1,40 @@\n+/*\n+ * Copyright \u00a9 2009 Reinier Zwitserloot and Roel Spilker.\n+ * \n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ * \n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ * \n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n package lombok.core;\n \n+/**\n+ * Implement this class, and add yourself as a provider for it, to become an app runnable by running lombok.jar as a jar.\n+ * \n+ * @see lombok.delombok.DelombokApp\n+ */\n public interface LombokApp {\n-\tpublic void runApp(String[] args);\n+\t/**\n+\t * @param args The arguments; analogous to what's passed to {@code public static void main(String[] args)} methods.\n+\t * @return The return value. Don't call {@code System.exit} yourself.\n+\t */\n+\tpublic int runApp(String[] args) throws Exception;\n+\t\n+\t/**\n+\t * @return Your app name. For example {@code delombok}.\n+\t */\n \tpublic String getAppName();\n }",
      "parent_sha": "3919e192f17dab936167215c9a163e8830a2b346"
    }
  },
  {
    "oid": "223a3fdb97ce67247b03a2537f53600fa6f2c383",
    "message": "Uae names.length instead of suffixes.size() as loop limits",
    "date": "2019-01-13T01:25:26Z",
    "url": "https://github.com/projectlombok/lombok/commit/223a3fdb97ce67247b03a2537f53600fa6f2c383",
    "details": {
      "sha": "d3db63ff7b58271b6f95ad4835a0dfcf6431fa8c",
      "filename": "src/core/lombok/javac/handlers/singulars/JavacGuavaSingularizer.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/projectlombok/lombok/blob/223a3fdb97ce67247b03a2537f53600fa6f2c383/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2Fsingulars%2FJavacGuavaSingularizer.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/223a3fdb97ce67247b03a2537f53600fa6f2c383/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2Fsingulars%2FJavacGuavaSingularizer.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2Fsingulars%2FJavacGuavaSingularizer.java?ref=223a3fdb97ce67247b03a2537f53600fa6f2c383",
      "patch": "@@ -84,17 +84,17 @@ protected JCStatement generateClearStatements(JavacTreeMaker maker, SingularData\n \tprotected void generateSingularMethod(boolean deprecate, JavacTreeMaker maker, JCExpression returnType, JCStatement returnStatement, SingularData data, JavacNode builderType, JCTree source, boolean fluent) {\n \t\tLombokImmutableList<String> suffixes = getArgumentSuffixes();\n \t\tName[] names = new Name[suffixes.size()];\n-\t\tfor (int i = 0; i < suffixes.size(); i++) {\n+\t\tfor (int i = 0; i < names.length; i++) {\n \t\t\tString s = suffixes.get(i);\n \t\t\tName n = data.getSingularName();\n \t\t\tnames[i] = s.isEmpty() ? n : builderType.toName(s);\n \t\t}\n-\t\t\n+\n \t\tListBuffer<JCStatement> statements = new ListBuffer<JCStatement>();\n \t\tstatements.append(createConstructBuilderVarIfNeeded(maker, data, builderType, source));\n \t\tJCExpression thisDotFieldDotAdd = chainDots(builderType, \"this\", data.getPluralName().toString(), getAddMethodName());\n \t\tListBuffer<JCExpression> invokeAddExprBuilder = new ListBuffer<JCExpression>();\n-\t\tfor (int i = 0; i < suffixes.size(); i++) {\n+\t\tfor (int i = 0; i < names.length; i++) {\n \t\t\tinvokeAddExprBuilder.append(maker.Ident(names[i]));\n \t\t}\n \t\tList<JCExpression> invokeAddExpr = invokeAddExprBuilder.toList();\n@@ -103,7 +103,7 @@ protected void generateSingularMethod(boolean deprecate, JavacTreeMaker maker, J\n \t\tstatements.append(st);\n \n \t\tListBuffer<JCVariableDecl> params = new ListBuffer<JCVariableDecl>();\n-\t\tfor (int i = 0; i < suffixes.size(); i++) {\n+\t\tfor (int i = 0; i < names.length; i++) {\n \t\t\tparams.append(generateSingularMethodParameter(i, maker, data, builderType, source, names[i]));\n \t\t}\n ",
      "parent_sha": "73a70e3332230170a11657610417f6d62a269643"
    }
  },
  {
    "oid": "db2326714f796b8e7100edc0388e54b2ba3e5139",
    "message": "Trivial",
    "date": "2009-06-17T18:09:01Z",
    "url": "https://github.com/projectlombok/lombok/commit/db2326714f796b8e7100edc0388e54b2ba3e5139",
    "details": {
      "sha": "99727553b0bc9d4daa34504473360fd3cd344de5",
      "filename": "src/lombok/javac/JavacAST.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/projectlombok/lombok/blob/db2326714f796b8e7100edc0388e54b2ba3e5139/src%2Flombok%2Fjavac%2FJavacAST.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/db2326714f796b8e7100edc0388e54b2ba3e5139/src%2Flombok%2Fjavac%2FJavacAST.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Flombok%2Fjavac%2FJavacAST.java?ref=db2326714f796b8e7100edc0388e54b2ba3e5139",
      "patch": "@@ -372,8 +372,7 @@ private void increaseErrorCount(Messager messager) {\n \t\t\tf.setAccessible(true);\n \t\t\tif ( f.getType() == int.class ) {\n \t\t\t\tint val = ((Number)f.get(messager)).intValue();\n-\t\t\t\tval++;\n-\t\t\t\tf.set(messager, val);\n+\t\t\t\tf.set(messager, val +1);\n \t\t\t}\n \t\t} catch ( Throwable t ) {\n \t\t\t//Very unfortunate, but in most cases it still works fine, so we'll silently swallow it.",
      "parent_sha": "d3ee75020ee2b28795d602f2a0daf018b5131c9a"
    }
  },
  {
    "oid": "26ebe6aaa8838c3bb6d7be4836216bcc4030f2b1",
    "message": "trivial",
    "date": "2016-06-27T22:35:04Z",
    "url": "https://github.com/projectlombok/lombok/commit/26ebe6aaa8838c3bb6d7be4836216bcc4030f2b1",
    "details": {
      "sha": "3a4e22c5a86ba8fcb3c1f3e631fdd456db090619",
      "filename": "src/eclipseAgent/lombok/eclipse/agent/PatchDelegate.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/projectlombok/lombok/blob/26ebe6aaa8838c3bb6d7be4836216bcc4030f2b1/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchDelegate.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/26ebe6aaa8838c3bb6d7be4836216bcc4030f2b1/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchDelegate.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchDelegate.java?ref=26ebe6aaa8838c3bb6d7be4836216bcc4030f2b1",
      "patch": "@@ -732,8 +732,8 @@ private static void addAllMethodBindings0(List<BindingTuple> list, TypeBinding b\n \t\tReferenceBinding rb = (ReferenceBinding) binding;\n \t\tMethodBinding[] availableMethods = rb.availableMethods();\n \t\tFieldBinding[] availableFields = rb.availableFields();\n-\t\tfailIfContainsAnnotation(binding, availableMethods); \n-\t\tfailIfContainsAnnotation(binding, availableFields); \n+\t\tfailIfContainsAnnotation(binding, availableMethods);\n+\t\tfailIfContainsAnnotation(binding, availableFields);\n \t\t\n \t\tMethodBinding[] parameterizedSigs = availableMethods;\n \t\tMethodBinding[] baseSigs = parameterizedSigs;",
      "parent_sha": "2a9820d8ec87e0e5e72eff19b56f1bee5f4e37e7"
    }
  },
  {
    "oid": "0fb3a680ac0334eb231b47ba1b4bac94a8a34ed1",
    "message": "[build] fix the website maker's all-versions tool",
    "date": "2021-04-01T22:47:30Z",
    "url": "https://github.com/projectlombok/lombok/commit/0fb3a680ac0334eb231b47ba1b4bac94a8a34ed1",
    "details": {
      "sha": "ea472a19b741188575340b523b1c07f450b80297",
      "filename": "src/support/lombok/website/WebsiteMaker.java",
      "status": "modified",
      "additions": 22,
      "deletions": 1,
      "changes": 23,
      "blob_url": "https://github.com/projectlombok/lombok/blob/0fb3a680ac0334eb231b47ba1b4bac94a8a34ed1/src%2Fsupport%2Flombok%2Fwebsite%2FWebsiteMaker.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/0fb3a680ac0334eb231b47ba1b4bac94a8a34ed1/src%2Fsupport%2Flombok%2Fwebsite%2FWebsiteMaker.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fsupport%2Flombok%2Fwebsite%2FWebsiteMaker.java?ref=0fb3a680ac0334eb231b47ba1b4bac94a8a34ed1",
      "patch": "@@ -1,3 +1,24 @@\n+/*\n+ * Copyright (C) 2021 The Project Lombok Authors.\n+ * \n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ * \n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ * \n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n package lombok.website;\n \n import java.io.BufferedReader;\n@@ -72,7 +93,7 @@ private static String getVersion0(String mName) {\n \tprivate static void printAllVersions(Domain domain) throws Exception {\n \t\tList<List<String>> versions = readAllVersions(domain);\n \t\tfor (List<String> v : versions) {\n-\t\t\tSystem.out.println(\" <a href=\\\"\" + v.get(0) + \"\\\">\" + v.get(1) + \"</a>\");\n+\t\t\tSystem.out.println(\" <a href=\\\"\" + v.get(1) + \"\\\">\" + v.get(0) + \"</a>\");\n \t\t}\n \t}\n \t",
      "parent_sha": "ff8af6164dfffa0827d12a342da35fc89d37c504"
    }
  },
  {
    "oid": "b4c3ab8f28427a30735bd77e1812d41170213582",
    "message": "Post beta release prep",
    "date": "2009-12-02T23:25:42Z",
    "url": "https://github.com/projectlombok/lombok/commit/b4c3ab8f28427a30735bd77e1812d41170213582",
    "details": {
      "sha": "379442187919d2faf12b5b7d2552fa975eb66cef",
      "filename": "src/core/lombok/core/Version.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/projectlombok/lombok/blob/b4c3ab8f28427a30735bd77e1812d41170213582/src%2Fcore%2Flombok%2Fcore%2FVersion.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/b4c3ab8f28427a30735bd77e1812d41170213582/src%2Fcore%2Flombok%2Fcore%2FVersion.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fcore%2FVersion.java?ref=b4c3ab8f28427a30735bd77e1812d41170213582",
      "patch": "@@ -26,7 +26,7 @@\n  */\n public class Version {\n \t// ** CAREFUL ** - this class must always compile with 0 dependencies (it must not refer to any other sources or libraries).\n-\tprivate static final String VERSION = \"0.9.2-BETA3\";\n+\tprivate static final String VERSION = \"0.9.2-HEAD\";\n \t\n \tprivate Version() {\n \t\t//Prevent instantiation",
      "parent_sha": "01d622d471d9b1809128dc9d5c834d33d4ff6866"
    }
  },
  {
    "oid": "3b504cf4d06c00f41f3e7bf472843568e618b83d",
    "message": "Preparing to release 0.10.0-RC2",
    "date": "2011-07-25T18:52:40Z",
    "url": "https://github.com/projectlombok/lombok/commit/3b504cf4d06c00f41f3e7bf472843568e618b83d",
    "details": {
      "sha": "335aa8bd5cc075a139ddf6437bb5886f86334085",
      "filename": "src/core/lombok/core/Version.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/projectlombok/lombok/blob/3b504cf4d06c00f41f3e7bf472843568e618b83d/src%2Fcore%2Flombok%2Fcore%2FVersion.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/3b504cf4d06c00f41f3e7bf472843568e618b83d/src%2Fcore%2Flombok%2Fcore%2FVersion.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fcore%2FVersion.java?ref=3b504cf4d06c00f41f3e7bf472843568e618b83d",
      "patch": "@@ -26,7 +26,7 @@\n  */\n public class Version {\n \t// ** CAREFUL ** - this class must always compile with 0 dependencies (it must not refer to any other sources or libraries).\n-\tprivate static final String VERSION = \"0.10.0-RC1\";\n+\tprivate static final String VERSION = \"0.10.0-RC2\";\n \tprivate static final String RELEASE_NAME = \"Burning Emu\";\n \t\n \tprivate Version() {",
      "parent_sha": "dfca0e4cbdf761bcb119dc2b5bd1598e455d6d09"
    }
  },
  {
    "oid": "cc3b8086d49f8e0e46383a73a0fd4e15bfa9fd99",
    "message": "[fixes #3728] Remove signature files eclipse plugin jars",
    "date": "2024-09-19T15:09:28Z",
    "url": "https://github.com/projectlombok/lombok/commit/cc3b8086d49f8e0e46383a73a0fd4e15bfa9fd99",
    "details": {
      "sha": "0aa9934dd41698711749bd2924373065a8ebcc69",
      "filename": "src/support/lombok/eclipse/dependencies/DownloadEclipseDependencies.java",
      "status": "modified",
      "additions": 18,
      "deletions": 5,
      "changes": 23,
      "blob_url": "https://github.com/projectlombok/lombok/blob/cc3b8086d49f8e0e46383a73a0fd4e15bfa9fd99/src%2Fsupport%2Flombok%2Feclipse%2Fdependencies%2FDownloadEclipseDependencies.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/cc3b8086d49f8e0e46383a73a0fd4e15bfa9fd99/src%2Fsupport%2Flombok%2Feclipse%2Fdependencies%2FDownloadEclipseDependencies.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fsupport%2Flombok%2Feclipse%2Fdependencies%2FDownloadEclipseDependencies.java?ref=cc3b8086d49f8e0e46383a73a0fd4e15bfa9fd99",
      "patch": "@@ -36,6 +36,9 @@\n import java.util.Arrays;\n import java.util.List;\n import java.util.Set;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipInputStream;\n+import java.util.zip.ZipOutputStream;\n \n /**\n  * Download eclipse bundles.\n@@ -87,12 +90,22 @@ private static void downloadFile(String filename, String repositoryUrl, String t\n \t\t\treturn;\n \t\t}\n \t\tSystem.out.print(\"Downloading '\" + filename + \"'... \");\n-\t\tInputStream in = null;\n-\t\tOutputStream out = null;\n+\t\tZipInputStream in = null;\n+\t\tZipOutputStream out = null;\n \t\ttry {\n-\t\t\tin = getStreamForUrl(repositoryUrl + filename);\n-\t\t\tout = new FileOutputStream(targetFile);\n-\t\t\tcopy(in, out);\n+\t\t\tin = new ZipInputStream(getStreamForUrl(repositoryUrl + filename));\n+\t\t\tout = new ZipOutputStream(new FileOutputStream(targetFile));\n+\t\t\t\n+\t\t\tZipEntry zipEntry;\n+\t\t\twhile ((zipEntry = in.getNextEntry()) != null) {\n+\t\t\t\tString name = zipEntry.getName();\n+\t\t\t\t\n+\t\t\t\t// Remove signature files\n+\t\t\t\tif (name.matches(\"META-INF/.*\\\\.(SF|RSA)\")) continue;\n+\t\t\t\t\n+\t\t\t\tout.putNextEntry(new ZipEntry(name));\n+\t\t\t\tcopy(in, out);\n+\t\t\t}\n \t\t\tSystem.out.println(\"[done]\");\n \t\t} catch (IOException e) {\n \t\t\tSystem.out.println(\"[error]\");",
      "parent_sha": "1ac3950a9e8d1c2da0ff0d6400386a9b345b23a2"
    }
  },
  {
    "oid": "bdcbd1bac40ddbfeda22a99285976e2a92fd59df",
    "message": "SpiLoadUtil's findAnnotationClass didn't work with extends Foo<T>, only with implements Foo<T>. Fixed this.",
    "date": "2011-06-20T19:05:06Z",
    "url": "https://github.com/projectlombok/lombok/commit/bdcbd1bac40ddbfeda22a99285976e2a92fd59df",
    "details": {
      "sha": "09a5970946ca7ea9720d871bc529bd8a11613cfb",
      "filename": "src/core/lombok/core/SpiLoadUtil.java",
      "status": "modified",
      "additions": 25,
      "deletions": 14,
      "changes": 39,
      "blob_url": "https://github.com/projectlombok/lombok/blob/bdcbd1bac40ddbfeda22a99285976e2a92fd59df/src%2Fcore%2Flombok%2Fcore%2FSpiLoadUtil.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/bdcbd1bac40ddbfeda22a99285976e2a92fd59df/src%2Fcore%2Flombok%2Fcore%2FSpiLoadUtil.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fcore%2FSpiLoadUtil.java?ref=bdcbd1bac40ddbfeda22a99285976e2a92fd59df",
      "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright \u00a9 2009 Reinier Zwitserloot and Roel Spilker.\n+ * Copyright \u00a9 2009-2011 Reinier Zwitserloot and Roel Spilker.\n  * \n  * Permission is hereby granted, free of charge, to any person obtaining a copy\n  * of this software and associated documentation files (the \"Software\"), to deal\n@@ -151,22 +151,16 @@ private static void readServicesFromUrl(Collection<String> list, URL url) throws\n \t * It returns an annotation type because it is used exclusively to figure out which annotations are\n \t * being handled by {@link lombok.eclipse.EclipseAnnotationHandler} and {@link lombok.javac.JavacAnnotationHandler}.\n \t */\n-\t@SuppressWarnings(\"unchecked\")\n \tpublic static Class<? extends Annotation> findAnnotationClass(Class<?> c, Class<?> base) {\n \t\tif (c == Object.class || c == null) return null;\n+\t\tClass<? extends Annotation> answer = null;\n+\t\t\n+\t\tanswer = findAnnotationHelper(base, c.getGenericSuperclass());\n+\t\tif (answer != null) return answer;\n+\t\t\n \t\tfor (Type iface : c.getGenericInterfaces()) {\n-\t\t\tif (iface instanceof ParameterizedType) {\n-\t\t\t\tParameterizedType p = (ParameterizedType)iface;\n-\t\t\t\tif (!base.equals(p.getRawType())) continue;\n-\t\t\t\tType target = p.getActualTypeArguments()[0];\n-\t\t\t\tif (target instanceof Class<?>) {\n-\t\t\t\t\tif (Annotation.class.isAssignableFrom((Class<?>) target)) {\n-\t\t\t\t\t\treturn (Class<? extends Annotation>) target;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\t\n-\t\t\t\tthrow new ClassCastException(\"Not an annotation type: \" + target);\n-\t\t\t}\n+\t\t\tanswer = findAnnotationHelper(base, iface);\n+\t\t\tif (answer != null) return answer;\n \t\t}\n \t\t\n \t\tClass<? extends Annotation> potential = findAnnotationClass(c.getSuperclass(), base);\n@@ -178,4 +172,21 @@ public static Class<? extends Annotation> findAnnotationClass(Class<?> c, Class<\n \t\t\n \t\treturn null;\n \t}\n+\t\n+\t@SuppressWarnings(\"unchecked\")\n+\tprivate static Class<? extends Annotation> findAnnotationHelper(Class<?> base, Type iface) {\n+\t\tif (iface instanceof ParameterizedType) {\n+\t\t\tParameterizedType p = (ParameterizedType)iface;\n+\t\t\tif (!base.equals(p.getRawType())) return null;\n+\t\t\tType target = p.getActualTypeArguments()[0];\n+\t\t\tif (target instanceof Class<?>) {\n+\t\t\t\tif (Annotation.class.isAssignableFrom((Class<?>) target)) {\n+\t\t\t\t\treturn (Class<? extends Annotation>) target;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t\n+\t\t\tthrow new ClassCastException(\"Not an annotation type: \" + target);\n+\t\t}\n+\t\treturn null;\n+\t}\n }",
      "parent_sha": "1c883cb13f1c1595c0aaefe1b3ff1fb9c734ed5b"
    }
  },
  {
    "oid": "930cc2410525f8605868fecc2373603ef3d1472b",
    "message": "[versioning] pre-release version bump 1.18.26",
    "date": "2023-01-19T21:58:23Z",
    "url": "https://github.com/projectlombok/lombok/commit/930cc2410525f8605868fecc2373603ef3d1472b",
    "details": {
      "sha": "2bcafe9e62eda96baf0cdc44d5326913bfa30883",
      "filename": "src/core/lombok/core/Version.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/projectlombok/lombok/blob/930cc2410525f8605868fecc2373603ef3d1472b/src%2Fcore%2Flombok%2Fcore%2FVersion.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/930cc2410525f8605868fecc2373603ef3d1472b/src%2Fcore%2Flombok%2Fcore%2FVersion.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fcore%2FVersion.java?ref=930cc2410525f8605868fecc2373603ef3d1472b",
      "patch": "@@ -30,9 +30,9 @@ public class Version {\n \t// ** CAREFUL ** - this class must always compile with 0 dependencies (it must not refer to any other sources or libraries).\n \t// Note: In 'X.Y.Z', if Z is odd, its a snapshot build built from the repository, so many different 0.10.3 versions can exist, for example.\n \t// Official builds always end in an even number. (Since 0.10.2).\n-\tprivate static final String VERSION = \"1.18.25\";\n-\tprivate static final String RELEASE_NAME = \"Edgy Guinea Pig\";\n-//\tprivate static final String RELEASE_NAME = \"Envious Ferret\";\n+\tprivate static final String VERSION = \"1.18.26\";\n+//\tprivate static final String RELEASE_NAME = \"Edgy Guinea Pig\";\n+\tprivate static final String RELEASE_NAME = \"Envious Ferret\";\n \t\n \t// Named version history:\n \t//   Angry Butterfly",
      "parent_sha": "86029538ee3f24c45adf3755b33005a4fe8cd608"
    }
  },
  {
    "oid": "64ff254b654dc0506025797b083826433ca6646d",
    "message": "Accept JCCatch as 'statement' (issue #281)",
    "date": "2011-10-07T19:32:48Z",
    "url": "https://github.com/projectlombok/lombok/commit/64ff254b654dc0506025797b083826433ca6646d",
    "details": {
      "sha": "ec7017a415c860dc61680b5a4c2572505d502851",
      "filename": "src/core/lombok/javac/JavacAST.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/projectlombok/lombok/blob/64ff254b654dc0506025797b083826433ca6646d/src%2Fcore%2Flombok%2Fjavac%2FJavacAST.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/64ff254b654dc0506025797b083826433ca6646d/src%2Fcore%2Flombok%2Fjavac%2FJavacAST.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fjavac%2FJavacAST.java?ref=64ff254b654dc0506025797b083826433ca6646d",
      "patch": "@@ -36,6 +36,7 @@\n import com.sun.tools.javac.model.JavacElements;\n import com.sun.tools.javac.model.JavacTypes;\n import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.JCCatch;\n import com.sun.tools.javac.tree.TreeMaker;\n import com.sun.tools.javac.tree.JCTree.JCAnnotation;\n import com.sun.tools.javac.tree.JCTree.JCBlock;\n@@ -275,9 +276,10 @@ private JavacNode drill(JCTree statement) {\n \t/** For javac, both JCExpression and JCStatement are considered as valid children types. */\n \t@Override\n \tprotected Collection<Class<? extends JCTree>> getStatementTypes() {\n-\t\tCollection<Class<? extends JCTree>> collection = new ArrayList<Class<? extends JCTree>>(2);\n+\t\tCollection<Class<? extends JCTree>> collection = new ArrayList<Class<? extends JCTree>>(3);\n \t\tcollection.add(JCStatement.class);\n \t\tcollection.add(JCExpression.class);\n+\t\tcollection.add(JCCatch.class);\n \t\treturn collection;\n \t}\n \t",
      "parent_sha": "fc72a48f17661bc6a42816b3ebba0319d2847747"
    }
  },
  {
    "oid": "3619f889f5088ccb08245c2c3d7bc6e4459337d5",
    "message": "To quote Reinier paraphrasing the compiler: \"If the loading doesn't work, I don't want it!\"",
    "date": "2013-08-05T20:07:45Z",
    "url": "https://github.com/projectlombok/lombok/commit/3619f889f5088ccb08245c2c3d7bc6e4459337d5",
    "details": {
      "sha": "c90b86117ff9234a60c9146dc12180809017bd1b",
      "filename": "src/utils/lombok/javac/Javac.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/projectlombok/lombok/blob/3619f889f5088ccb08245c2c3d7bc6e4459337d5/src%2Futils%2Flombok%2Fjavac%2FJavac.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/3619f889f5088ccb08245c2c3d7bc6e4459337d5/src%2Futils%2Flombok%2Fjavac%2FJavac.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Futils%2Flombok%2Fjavac%2FJavac.java?ref=3619f889f5088ccb08245c2c3d7bc6e4459337d5",
      "patch": "@@ -213,12 +213,12 @@ public static int getEndPosition(DiagnosticPosition pos, JCCompilationUnit top)\n \t\tClass<?> c = null;\n \t\ttry {\n \t\t\tc = Class.forName(\"com.sun.tools.javac.code.Type$JCVoidType\");\n-\t\t} catch (Exception ignore) {}\n+\t\t} catch (Throwable ignore) {}\n \t\tJC_VOID_TYPE = c;\n \t\tc = null;\n \t\ttry {\n \t\t\tc = Class.forName(\"com.sun.tools.javac.code.Type$JCNoType\");\n-\t\t} catch (Exception ignore) {}\n+\t\t} catch (Throwable ignore) {}\n \t\tJC_NO_TYPE = c;\n \t}\n \t",
      "parent_sha": "d0d2dd6f5d1b9bd33e9e127f8d66b3387f487271"
    }
  },
  {
    "oid": "8fb7c9c8a25646421b6ecf4693ff801652b55241",
    "message": "trivial",
    "date": "2012-01-02T19:33:42Z",
    "url": "https://github.com/projectlombok/lombok/commit/8fb7c9c8a25646421b6ecf4693ff801652b55241",
    "details": {
      "sha": "c1c1e988c1b1df31e2a0f70c236e5ea0d22e33bf",
      "filename": "src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/projectlombok/lombok/blob/8fb7c9c8a25646421b6ecf4693ff801652b55241/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FEclipsePatcher.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/8fb7c9c8a25646421b6ecf4693ff801652b55241/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FEclipsePatcher.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FEclipsePatcher.java?ref=8fb7c9c8a25646421b6ecf4693ff801652b55241",
      "patch": "@@ -78,8 +78,6 @@ private static void registerPatchScripts(Instrumentation instrumentation, boolea\n \t\t\tEquinoxClassLoader.registerScripts(sm);\n \t\t}\n \t\t\n-\t\tpatchAvoidReparsingGeneratedCode(sm);\n-\t\t\n \t\tif (!ecjOnly) {\n \t\t\tpatchCatchReparse(sm);\n \t\t\tpatchIdentifierEndReparse(sm);\n@@ -98,6 +96,7 @@ private static void registerPatchScripts(Instrumentation instrumentation, boolea\n \t\t\tpatchPostCompileHookEcj(sm);\n \t\t}\n \t\t\n+\t\tpatchAvoidReparsingGeneratedCode(sm);\n \t\tpatchLombokizeAST(sm);\n \t\tpatchEcjTransformers(sm, ecjOnly);\n \t\t\n@@ -153,7 +152,7 @@ private static void patchListRewriteHandleGeneratedMethods(ScriptManager sm) {\n \t}\n \n \tprivate static void patchSortMembersOperation(ScriptManager sm) {\n-\t\t/* Fixes \"sort members\" action with @Data @Log \n+\t\t/* Fixes \"sort members\" action with @Data @Log\n \t\t * I would have liked to patch sortMembers, but kept getting a VerifyError: Illegal type in constant pool\n \t\t * So now I just patch all calling methods\n \t\t */",
      "parent_sha": "ba680ad97a203b5d3d43e6219f7700af28542445"
    }
  },
  {
    "oid": "627e9dc8a7f381ace59f91c9ee4a023733d4717e",
    "message": "Updated the text to also mention rebuilding projects. Also fixed various size issues with swing\u2019s\u2026 peculiar layouting mechanism.",
    "date": "2017-02-13T20:48:40Z",
    "url": "https://github.com/projectlombok/lombok/commit/627e9dc8a7f381ace59f91c9ee4a023733d4717e",
    "details": {
      "sha": "b96fec9c511d84fd02a61b2782ec84a2ab9c3475",
      "filename": "src/installer/lombok/installer/InstallerGUI.java",
      "status": "modified",
      "additions": 16,
      "deletions": 12,
      "changes": 28,
      "blob_url": "https://github.com/projectlombok/lombok/blob/627e9dc8a7f381ace59f91c9ee4a023733d4717e/src%2Finstaller%2Flombok%2Finstaller%2FInstallerGUI.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/627e9dc8a7f381ace59f91c9ee4a023733d4717e/src%2Finstaller%2Flombok%2Finstaller%2FInstallerGUI.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Finstaller%2Flombok%2Finstaller%2FInstallerGUI.java?ref=627e9dc8a7f381ace59f91c9ee4a023733d4717e",
      "patch": "@@ -192,11 +192,15 @@ private Component buildSuccessArea() {\n \t\tGridBagConstraints constraints = new GridBagConstraints();\n \t\tconstraints.anchor = GridBagConstraints.WEST;\n \t\t\n-\t\tcontainer.add(new JLabel(SUCCESS_TITLE), constraints);\n+\t\tJLabel title;\n+\t\tcontainer.add(title = new JLabel(SUCCESS_TITLE), constraints);\n+\t\ttitle.setPreferredSize(new Dimension(INSTALLER_WINDOW_WIDTH - 82, 20));\n \t\t\n \t\tconstraints.gridy = 1;\n \t\tconstraints.insets = new Insets(8, 0, 0, 16);\n \t\tcontainer.add(successExplanation = new JLabel(SUCCESS_EXPLANATION), constraints);\n+\t\tsuccessExplanation.setPreferredSize(new Dimension(INSTALLER_WINDOW_WIDTH - 82, 175));\n+\t\tsuccessExplanation.setMinimumSize(new Dimension(INSTALLER_WINDOW_WIDTH - 82, 175));\n \t\t\n \t\tconstraints.gridy++;\n \t\tconstraints.fill = GridBagConstraints.BOTH;\n@@ -212,13 +216,13 @@ private Component buildSuccessArea() {\n \t\t\n \t\tFont font = UIManager.getFont(\"Label.font\");\n \t\tString bodyRule = \"body { font-family: \" + font.getFamily() + \"; font-size: \" + font.getSize() + \"pt; }\";\n-\t\t((HTMLDocument)notes.getDocument()).getStyleSheet().addRule(bodyRule);\n-\t\t\n+\t\t((HTMLDocument) notes.getDocument()).getStyleSheet().addRule(bodyRule);\n \t\tJScrollPane scroller = new JScrollPane(notes);\n \t\tcontainer.add(scroller, constraints);\n-\t\tscroller.setPreferredSize(new Dimension(INSTALLER_WINDOW_WIDTH - 82, 240));\n-\t\t\n+\t\tscroller.setPreferredSize(new Dimension(INSTALLER_WINDOW_WIDTH - 82, 200));\n+\t\tscroller.setMinimumSize(new Dimension(INSTALLER_WINDOW_WIDTH - 82, 200));\n \t\tcontainer.setPreferredSize(new Dimension(INSTALLER_WINDOW_WIDTH, 415));\n+\t\tcontainer.setMinimumSize(new Dimension(INSTALLER_WINDOW_WIDTH, 415));\n \t\treturn container;\n \t}\n \t\n@@ -372,11 +376,11 @@ private Component buildIdeArea() {\n \t\t\t\t\t\t\t\n \t\t\t\t\t\t\tif (locations.size() + problems.size() == 0) {\n \t\t\t\t\t\t\t\tJOptionPane.showMessageDialog(appWindow,\n-\t\t\t\t\t\t\t\t\t\t\"I can't find any IDEs on your computer.\\n\" +\n-\t\t\t\t\t\t\t\t\t\t\"If you have IDEs installed on this computer, please use the \" +\n-\t\t\t\t\t\t\t\t\t\t\"'Specify Location...' button to manually point out the \\n\" +\n-\t\t\t\t\t\t\t\t\t\t\"location of your IDE installation to me. Thanks!\",\n-\t\t\t\t\t\t\t\t\t\t\"Can't find IDE\", JOptionPane.INFORMATION_MESSAGE);\n+\t\t\t\t\t\t\t\t\t\"I can't find any IDEs on your computer.\\n\" +\n+\t\t\t\t\t\t\t\t\t\"If you have IDEs installed on this computer, please use the \" +\n+\t\t\t\t\t\t\t\t\t\"'Specify Location...' button to manually point out the \\n\" +\n+\t\t\t\t\t\t\t\t\t\"location of your IDE installation to me. Thanks!\",\n+\t\t\t\t\t\t\t\t\t\"Can't find IDE\", JOptionPane.INFORMATION_MESSAGE);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t});\n@@ -929,8 +933,8 @@ public void show() {\n \t\n \tprivate static final String SUCCESS_TITLE = \"<html><font size=\\\"+1\\\"><b><i>Install successful </i></b></font></html>\";\n \tprivate static final String SUCCESS_EXPLANATION = \"<html>Lombok has been installed on the selected IDE installations.<br>\" +\n-\t\t\t\"Don't forget to add <code>lombok.jar</code> to your projects, and <b>exit and start</b> your IDE!%%%</html>\";\n-\n+\t\t\t\"Don't forget to:<ul><li> add <code>lombok.jar</code> to your projects,<li><b>exit and start</b> your IDE,<li><b>rebuild</b> all projects!</ul>%%%</html>\";\n+\t\n \t\n \tprivate static class JHyperLink extends JButton {\n \t\tprivate static final long serialVersionUID = 1L;",
      "parent_sha": "ad4bd36274d2bfe8dcf74977d921a114739386b1"
    }
  },
  {
    "oid": "f2b25550457628650213a3bfcac6a28a30648e6c",
    "message": "Potential fix for #2412",
    "date": "2020-06-25T22:06:50Z",
    "url": "https://github.com/projectlombok/lombok/commit/f2b25550457628650213a3bfcac6a28a30648e6c",
    "details": {
      "sha": "d4a92408172969c096d5e0a1ac0e05961d28c7cc",
      "filename": "src/core/lombok/core/AnnotationProcessor.java",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/projectlombok/lombok/blob/f2b25550457628650213a3bfcac6a28a30648e6c/src%2Fcore%2Flombok%2Fcore%2FAnnotationProcessor.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/f2b25550457628650213a3bfcac6a28a30648e6c/src%2Fcore%2Flombok%2Fcore%2FAnnotationProcessor.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fcore%2FAnnotationProcessor.java?ref=f2b25550457628650213a3bfcac6a28a30648e6c",
      "patch": "@@ -83,7 +83,12 @@ private static ProcessingEnvironment tryRecursivelyObtainJavacProcessingEnvironm\n \t\t\n \t\tfor (Class<?> procEnvClass = procEnv.getClass(); procEnvClass != null; procEnvClass = procEnvClass.getSuperclass()) {\n \t\t\ttry {\n-\t\t\t\tField field = Permit.getField(procEnvClass, \"delegate\");\n+\t\t\t\tField field;\n+\t\t\t\ttry {\n+\t\t\t\t\tfield = Permit.getField(procEnvClass, \"delegate\");\n+\t\t\t\t} catch (NoSuchFieldException e) {\n+\t\t\t\t\tfield = Permit.getField(procEnvClass, \"processingEnv\");\n+\t\t\t\t}\n \t\t\t\tObject delegate = field.get(procEnv);\n \t\t\t\t\n \t\t\t\treturn tryRecursivelyObtainJavacProcessingEnvironment((ProcessingEnvironment) delegate);",
      "parent_sha": "625acfa2a4ce49863ea562dd676500b5bb7898fc"
    }
  },
  {
    "oid": "4735f99d2856068d18292532eace281b3efe809b",
    "message": "ecj: reordering of methods",
    "date": "2018-05-31T13:02:08Z",
    "url": "https://github.com/projectlombok/lombok/commit/4735f99d2856068d18292532eace281b3efe809b",
    "details": {
      "sha": "d452261a70721722a3b8a405e0af61780f24eb02",
      "filename": "src/core/lombok/eclipse/handlers/HandleSuperBuilder.java",
      "status": "modified",
      "additions": 174,
      "deletions": 173,
      "changes": 347,
      "blob_url": "https://github.com/projectlombok/lombok/blob/4735f99d2856068d18292532eace281b3efe809b/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleSuperBuilder.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/4735f99d2856068d18292532eace281b3efe809b/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleSuperBuilder.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleSuperBuilder.java?ref=4735f99d2856068d18292532eace281b3efe809b",
      "patch": "@@ -97,6 +97,8 @@ public class HandleSuperBuilder extends EclipseAnnotationHandler<SuperBuilder> {\n \tprivate static final char[] SET_PREFIX = {'$', 's', 'e', 't'};\n \tprivate static final String SELF_METHOD = \"self\";\n \n+\tprivate static final AbstractMethodDeclaration[] EMPTY_METHODS = {};\n+\n \tprivate static class BuilderFieldData {\n \t\tTypeReference type;\n \t\tchar[] rawName;\n@@ -264,7 +266,7 @@ public void handle(AnnotationValues<SuperBuilder> annotation, Annotation ast, Ec\n \t\t// Create the abstract builder class.\n \t\tEclipseNode builderType = findInnerClass(tdParent, builderClassName);\n \t\tif (builderType == null) {\n-\t\t\tbuilderType = makeBuilderAbstractClass(tdParent, builderClassName, superclassBuilderClass,\n+\t\t\tbuilderType = generateBuilderAbstractClass(tdParent, builderClassName, superclassBuilderClass,\n \t\t\t\t\ttypeParams, superclassTypeParams, ast, classGenericName, builderGenericName);\n \n \t\t} else {\n@@ -308,7 +310,7 @@ public void handle(AnnotationValues<SuperBuilder> annotation, Annotation ast, Ec\n \n \t\t// Create the setter methods in the abstract builder.\n \t\tfor (BuilderFieldData bfd : builderFields) {\n-\t\t\tmakeSetterMethodsForBuilder(builderType, bfd, annotationNode, builderGenericName);\n+\t\t\tgenerateSetterMethodsForBuilder(builderType, bfd, annotationNode, builderGenericName);\n \t\t}\n \n \t\t// Create the toString() method for the abstract builder.\n@@ -331,7 +333,7 @@ public void handle(AnnotationValues<SuperBuilder> annotation, Annotation ast, Ec\n \t\t// Create the builder implementation class.\n \t\tEclipseNode builderImplType = findInnerClass(tdParent, builderImplClassName);\n \t\tif (builderImplType == null) {\n-\t\t\tbuilderImplType = makeBuilderImplClass(tdParent, builderImplClassName, builderClassName, typeParams, ast);\n+\t\t\tbuilderImplType = generateBuilderImplClass(tdParent, builderImplClassName, builderClassName, typeParams, ast);\n \t\t} else {\n \t\t\tannotationNode.addError(\"@SuperBuilder does not support customized builders. Use @Builder instead.\");\n \t\t\treturn;\n@@ -356,31 +358,64 @@ public void handle(AnnotationValues<SuperBuilder> annotation, Annotation ast, Ec\n \t\t}\n \t}\n \n-\tprivate String generateNonclashingNameFor(String classGenericName, java.util.List<String> typeParamStrings) {\n-\t\tif (!typeParamStrings.contains(classGenericName)) {\n-\t\t\treturn classGenericName;\n-\t\t}\n-\t\tint counter = 2;\n-\t\twhile (typeParamStrings.contains(classGenericName + counter)) {\n-\t\t\tcounter++;\n-\t\t}\n-\t\treturn classGenericName + counter;\n+\tprivate EclipseNode generateBuilderAbstractClass(EclipseNode tdParent, String builderClass,\n+\t\t\tTypeReference superclassBuilderClass, TypeParameter[] typeParams,\n+\t\t\tTypeParameter[] superclassTypeParams, ASTNode source, String classGenericName, String builderGenericName) {\n+\t\n+\t\tTypeDeclaration parent = (TypeDeclaration) tdParent.get();\n+\t\tTypeDeclaration builder = new TypeDeclaration(parent.compilationResult);\n+\t\tbuilder.bits |= Eclipse.ECLIPSE_DO_NOT_TOUCH_FLAG;\n+\t\tbuilder.modifiers |= ClassFileConstants.AccPublic | ClassFileConstants.AccStatic | ClassFileConstants.AccAbstract;\n+\t\tbuilder.name = builderClass.toCharArray();\n+\t\n+\t\t// Keep any type params of the annotated class.\n+\t\tbuilder.typeParameters = Arrays.copyOf(copyTypeParams(typeParams, source), typeParams.length + 2);\n+\t\t// Add builder-specific type params required for inheritable builders.\n+\t\t// 1. The return type for the build() method, named \"C\", which extends the annotated class.\n+\t\tTypeParameter o = new TypeParameter();\n+\t\to.name = classGenericName.toCharArray();\n+\t\to.type = cloneSelfType(tdParent, source);\n+\t\tbuilder.typeParameters[builder.typeParameters.length - 2] = o;\n+\t\t// 2. The return type for all setter methods, named \"B\", which extends this builder class.\n+\t\to = new TypeParameter();\n+\t\to.name = builderGenericName.toCharArray();\n+\t\tTypeReference[] typerefs = appendBuilderTypeReferences(typeParams, classGenericName, builderGenericName);\n+\t\to.type = new ParameterizedSingleTypeReference(builderClass.toCharArray(), typerefs, 0, 0);\n+\t\tbuilder.typeParameters[builder.typeParameters.length - 1] = o;\n+\t\n+\t\tbuilder.superclass = copyType(superclassBuilderClass, source);\n+\t\n+\t\tbuilder.traverse(new SetGeneratedByVisitor(source), (ClassScope) null);\n+\t\treturn injectType(tdParent, builder);\n \t}\n \n-\tprivate TypeReference[] getTypeParametersFrom(TypeReference typeRef) {\n-\t\tTypeReference[][] typeArgss = null;\n-\t\tif (typeRef instanceof ParameterizedQualifiedTypeReference) {\n-\t\t\ttypeArgss = ((ParameterizedQualifiedTypeReference)typeRef).typeArguments;\n-\t\t} else if (typeRef instanceof ParameterizedSingleTypeReference) {\n-\t\t\ttypeArgss = new TypeReference[][] {((ParameterizedSingleTypeReference)typeRef).typeArguments};\n+\tprivate EclipseNode generateBuilderImplClass(EclipseNode tdParent, String builderImplClass, String builderAbstractClass, TypeParameter[] typeParams, ASTNode source) {\n+\t\tTypeDeclaration parent = (TypeDeclaration) tdParent.get();\n+\t\tTypeDeclaration builder = new TypeDeclaration(parent.compilationResult);\n+\t\tbuilder.bits |= Eclipse.ECLIPSE_DO_NOT_TOUCH_FLAG;\n+\t\tbuilder.modifiers |= ClassFileConstants.AccPrivate | ClassFileConstants.AccStatic | ClassFileConstants.AccFinal;\n+\t\tbuilder.name = builderImplClass.toCharArray();\n+\t\t// Add type params if there are any.\n+\t\tif (typeParams != null && typeParams.length > 0) {\n+\t\t\tbuilder.typeParameters = copyTypeParams(typeParams, source);\n \t\t}\n-\t\tTypeReference[] typeArgs = new TypeReference[0];\n-\t\tif (typeArgss != null && typeArgss.length > 0) {\n-\t\t\ttypeArgs = typeArgss[typeArgss.length - 1];\n+\t\tif (builderAbstractClass != null) {\n+\t\t\t// Extend the abstract builder.\n+\t\t\t// 1. Add any type params of the annotated class.\n+\t\t\tTypeReference[] typeArgs = new TypeReference[typeParams.length + 2];\n+\t\t\tfor (int i = 0; i < typeParams.length; i++) {\n+\t\t\t\ttypeArgs[i] = new SingleTypeReference(typeParams[i].name, 0);\n+\t\t\t}\n+\t\t\t// 2. The return type for the build() method (named \"C\" in the abstract builder), which is the annotated class.\n+\t\t\t// 3. The return type for all setter methods (named \"B\" in the abstract builder), which is this builder class.\n+\t\t\ttypeArgs[typeArgs.length - 2] = cloneSelfType(tdParent, source);\n+\t\t\ttypeArgs[typeArgs.length - 1] = createTypeReferenceWithTypeParameters(builderImplClass, typeParams);\n+\t\t\tbuilder.superclass = new ParameterizedSingleTypeReference(builderAbstractClass.toCharArray(), typeArgs, 0, 0);\n \t\t}\n-\t\treturn typeArgs;\n+\t\tbuilder.traverse(new SetGeneratedByVisitor(source), (ClassScope) null);\n+\t\treturn injectType(tdParent, builder);\n \t}\n-\t\n+\n \t/**\n \t * Generates a constructor that has a builder as the only parameter.\n \t * The values from the builder are used to initialize the fields of new instances.\n@@ -463,6 +498,30 @@ private void generateBuilderBasedConstructor(EclipseNode typeNode, TypeParameter\n \t\tinjectMethod(typeNode, constructor);\n \t}\n \n+\tprivate MethodDeclaration generateBuilderMethod(String builderMethodName, String builderClassName, String builderImplClassName, EclipseNode type, TypeParameter[] typeParams, ASTNode source) {\n+\t\tint pS = source.sourceStart, pE = source.sourceEnd;\n+\t\tlong p = (long) pS << 32 | pE;\n+\t\n+\t\tMethodDeclaration out = new MethodDeclaration(((CompilationUnitDeclaration) type.top().get()).compilationResult);\n+\t\tout.selector = builderMethodName.toCharArray();\n+\t\tout.modifiers = ClassFileConstants.AccPublic | ClassFileConstants.AccStatic;\n+\t\tout.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;\n+\t\n+\t\t// Add type params if there are any.\n+\t\tif (typeParams != null && typeParams.length > 0) {\n+\t\t\tout.typeParameters = copyTypeParams(typeParams, source);\n+\t\t}\n+\t\tTypeReference[] wildcards = new TypeReference[] {new Wildcard(Wildcard.UNBOUND), new Wildcard(Wildcard.UNBOUND) };\n+\t\tout.returnType = new ParameterizedSingleTypeReference(builderClassName.toCharArray(), mergeToTypeReferences(typeParams, wildcards), 0, p);\n+\t\t\n+\t\tAllocationExpression invoke = new AllocationExpression();\n+\t\tinvoke.type = namePlusTypeParamsToTypeReference(builderImplClassName.toCharArray(), typeParams, p);\n+\t\tout.statements = new Statement[] {new ReturnStatement(invoke, pS, pE)};\n+\t\n+\t\tout.traverse(new SetGeneratedByVisitor(source), ((TypeDeclaration) type.get()).scope);\n+\t\treturn out;\n+\t}\n+\n \tprivate MethodDeclaration generateAbstractSelfMethod(EclipseNode tdParent, boolean override, String builderGenericName) {\n \t\tMethodDeclaration out = new MethodDeclaration(((CompilationUnitDeclaration) tdParent.top().get()).compilationResult);\n \t\tout.selector = SELF_METHOD.toCharArray();\n@@ -502,40 +561,18 @@ private MethodDeclaration generateAbstractBuildMethod(EclipseNode tdParent, Stri\n \t\treturn out;\n \t}\n \n-\tprivate MethodDeclaration generateCleanMethod(List<BuilderFieldData> builderFields, EclipseNode builderType, ASTNode source) {\n-\t\tList<Statement> statements = new ArrayList<Statement>();\n-\n-\t\tfor (BuilderFieldData bfd : builderFields) {\n-\t\t\tif (bfd.singularData != null && bfd.singularData.getSingularizer() != null) {\n-\t\t\t\tbfd.singularData.getSingularizer().appendCleaningCode(bfd.singularData, builderType, statements);\n-\t\t\t}\n-\t\t}\n-\n-\t\tFieldReference thisUnclean = new FieldReference(CLEAN_FIELD_NAME, 0);\n-\t\tthisUnclean.receiver = new ThisReference(0, 0);\n-\t\tstatements.add(new Assignment(thisUnclean, new FalseLiteral(0, 0), 0));\n-\t\tMethodDeclaration decl = new MethodDeclaration(((CompilationUnitDeclaration) builderType.top().get()).compilationResult);\n-\t\tdecl.selector = CLEAN_METHOD_NAME;\n-\t\tdecl.modifiers = ClassFileConstants.AccPrivate;\n-\t\tdecl.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;\n-\t\tdecl.returnType = TypeReference.baseTypeReference(TypeIds.T_void, 0);\n-\t\tdecl.statements = statements.toArray(new Statement[0]);\n-\t\tdecl.traverse(new SetGeneratedByVisitor(source), (ClassScope) null);\n-\t\treturn decl;\n-\t}\n-\n \tprivate MethodDeclaration generateBuildMethod(EclipseNode tdParent, String name, TypeReference returnType, ASTNode source) {\n-\n+\t\n \t\tMethodDeclaration out = new MethodDeclaration(((CompilationUnitDeclaration) tdParent.top().get()).compilationResult);\n \t\tout.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;\n \t\tList<Statement> statements = new ArrayList<Statement>();\n-\n+\t\n \t\tout.modifiers = ClassFileConstants.AccPublic;\n \t\tout.selector = name.toCharArray();\n \t\tout.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;\n \t\tout.returnType = returnType;\n \t\tout.annotations = new Annotation[] {makeMarkerAnnotation(TypeConstants.JAVA_LANG_OVERRIDE, source)};\n-\n+\t\n \t\tAllocationExpression allocationStatement = new AllocationExpression();\n \t\tallocationStatement.type = copyType(out.returnType);\n \t\t// Use a constructor that only has this builder as parameter.\n@@ -546,28 +583,26 @@ private MethodDeclaration generateBuildMethod(EclipseNode tdParent, String name,\n \t\treturn out;\n \t}\n \n-\tprivate MethodDeclaration generateBuilderMethod(String builderMethodName, String builderClassName, String builderImplClassName, EclipseNode type, TypeParameter[] typeParams, ASTNode source) {\n-\t\tint pS = source.sourceStart, pE = source.sourceEnd;\n-\t\tlong p = (long) pS << 32 | pE;\n-\n-\t\tMethodDeclaration out = new MethodDeclaration(((CompilationUnitDeclaration) type.top().get()).compilationResult);\n-\t\tout.selector = builderMethodName.toCharArray();\n-\t\tout.modifiers = ClassFileConstants.AccPublic | ClassFileConstants.AccStatic;\n-\t\tout.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;\n+\tprivate MethodDeclaration generateCleanMethod(List<BuilderFieldData> builderFields, EclipseNode builderType, ASTNode source) {\n+\t\tList<Statement> statements = new ArrayList<Statement>();\n \n-\t\t// Add type params if there are any.\n-\t\tif (typeParams != null && typeParams.length > 0) {\n-\t\t\tout.typeParameters = copyTypeParams(typeParams, source);\n+\t\tfor (BuilderFieldData bfd : builderFields) {\n+\t\t\tif (bfd.singularData != null && bfd.singularData.getSingularizer() != null) {\n+\t\t\t\tbfd.singularData.getSingularizer().appendCleaningCode(bfd.singularData, builderType, statements);\n+\t\t\t}\n \t\t}\n-\t\tTypeReference[] wildcards = new TypeReference[] {new Wildcard(Wildcard.UNBOUND), new Wildcard(Wildcard.UNBOUND) };\n-\t\tout.returnType = new ParameterizedSingleTypeReference(builderClassName.toCharArray(), mergeToTypeReferences(typeParams, wildcards), 0, p);\n-\t\t\n-\t\tAllocationExpression invoke = new AllocationExpression();\n-\t\tinvoke.type = namePlusTypeParamsToTypeReference(builderImplClassName.toCharArray(), typeParams, p);\n-\t\tout.statements = new Statement[] {new ReturnStatement(invoke, pS, pE)};\n \n-\t\tout.traverse(new SetGeneratedByVisitor(source), ((TypeDeclaration) type.get()).scope);\n-\t\treturn out;\n+\t\tFieldReference thisUnclean = new FieldReference(CLEAN_FIELD_NAME, 0);\n+\t\tthisUnclean.receiver = new ThisReference(0, 0);\n+\t\tstatements.add(new Assignment(thisUnclean, new FalseLiteral(0, 0), 0));\n+\t\tMethodDeclaration decl = new MethodDeclaration(((CompilationUnitDeclaration) builderType.top().get()).compilationResult);\n+\t\tdecl.selector = CLEAN_METHOD_NAME;\n+\t\tdecl.modifiers = ClassFileConstants.AccPrivate;\n+\t\tdecl.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;\n+\t\tdecl.returnType = TypeReference.baseTypeReference(TypeIds.T_void, 0);\n+\t\tdecl.statements = statements.toArray(new Statement[0]);\n+\t\tdecl.traverse(new SetGeneratedByVisitor(source), (ClassScope) null);\n+\t\treturn decl;\n \t}\n \n \tprivate void generateBuilderFields(EclipseNode builderType, List<BuilderFieldData> builderFields, ASTNode source) {\n@@ -614,7 +649,7 @@ private void generateBuilderFields(EclipseNode builderType, List<BuilderFieldDat\n \t\t}\n \t}\n \n-\tprivate void makeSetterMethodsForBuilder(EclipseNode builderType, BuilderFieldData bfd, EclipseNode sourceNode, final String builderGenericName) {\n+\tprivate void generateSetterMethodsForBuilder(EclipseNode builderType, BuilderFieldData bfd, EclipseNode sourceNode, final String builderGenericName) {\n \t\tboolean deprecate = isFieldDeprecated(bfd.originalFieldNode);\n \n \t\t// TODO: Make these lambdas when switching to a source level >= 1.8.\n@@ -632,18 +667,17 @@ private void makeSetterMethodsForBuilder(EclipseNode builderType, BuilderFieldDa\n \t\t\t}\n \t\t};\n \t\tif (bfd.singularData == null || bfd.singularData.getSingularizer() == null) {\n-\t\t\tmakeSimpleSetterMethodForBuilder(builderType, deprecate, bfd.createdFields.get(0), bfd.nameOfSetFlag, returnType.get(), returnStatement.get(), sourceNode);\n+\t\t\tgenerateSimpleSetterMethodForBuilder(builderType, deprecate, bfd.createdFields.get(0), bfd.nameOfSetFlag, returnType.get(), returnStatement.get(), sourceNode);\n \t\t} else {\n \t\t\tbfd.singularData.getSingularizer().generateMethods(bfd.singularData, deprecate, builderType, true, returnType, returnStatement);\n \t\t}\n \t}\n \n-\tprivate static final AbstractMethodDeclaration[] EMPTY = {};\n-\tprivate void makeSimpleSetterMethodForBuilder(EclipseNode builderType, boolean deprecate, EclipseNode fieldNode, char[] nameOfSetFlag, TypeReference returnType, ReturnStatement returnStatement, EclipseNode sourceNode) {\n+\tprivate void generateSimpleSetterMethodForBuilder(EclipseNode builderType, boolean deprecate, EclipseNode fieldNode, char[] nameOfSetFlag, TypeReference returnType, ReturnStatement returnStatement, EclipseNode sourceNode) {\n \t\tTypeDeclaration td = (TypeDeclaration) builderType.get();\n \t\tAbstractMethodDeclaration[] existing = td.methods;\n \t\tif (existing == null) {\n-\t\t\texisting = EMPTY;\n+\t\t\texisting = EMPTY_METHODS;\n \t\t}\n \t\tint len = existing.length;\n \t\tFieldDeclaration fd = (FieldDeclaration) fieldNode.get();\n@@ -666,107 +700,6 @@ private void makeSimpleSetterMethodForBuilder(EclipseNode builderType, boolean d\n \t\tinjectMethod(builderType, setter);\n \t}\n \n-\tprivate EclipseNode findInnerClass(EclipseNode parent, String name) {\n-\t\tchar[] c = name.toCharArray();\n-\t\tfor (EclipseNode child : parent.down()) {\n-\t\t\tif (child.getKind() != Kind.TYPE) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tTypeDeclaration td = (TypeDeclaration) child.get();\n-\t\t\tif (Arrays.equals(td.name, c)) {\n-\t\t\t\treturn child;\n-\t\t\t}\n-\t\t}\n-\t\treturn null;\n-\t}\n-\t\n-\tprivate TypeReference[] appendBuilderTypeReferences(TypeParameter[] typeParams, String classGenericName, String builderGenericName) {\n-\t\tTypeReference[] typeReferencesToAppend = new TypeReference[2];\n-\t\ttypeReferencesToAppend[typeReferencesToAppend.length - 2] = new SingleTypeReference(classGenericName.toCharArray(), 0); \n-\t\ttypeReferencesToAppend[typeReferencesToAppend.length - 1] = new SingleTypeReference(builderGenericName.toCharArray(), 0);\n-\t\treturn mergeToTypeReferences(typeParams, typeReferencesToAppend);\n-\t}\n-\t\n-\tprivate TypeReference[] mergeToTypeReferences(TypeParameter[] typeParams, TypeReference[] typeReferencesToAppend) {\n-\t\tTypeReference[] typerefs = new TypeReference[typeParams.length + typeReferencesToAppend.length];\n-\t\tfor (int i = 0; i < typeParams.length; i++) {\n-\t\t\ttyperefs[i] = new SingleTypeReference(typeParams[i].name, 0);\n-\t\t}\n-\t\tfor (int i = 0; i < typeReferencesToAppend.length; i++) {\n-\t\t\ttyperefs[typeParams.length + i] = typeReferencesToAppend[i];\n-\t\t}\n-\t\treturn typerefs;\n-\t}\n-\n-\tprivate TypeReference[] mergeTypeReferences(TypeReference[] refs1, TypeReference[] refs2) {\n-\t\tTypeReference[] result = new TypeReference[refs1.length + refs2.length];\n-\t\tfor (int i = 0; i < refs1.length; i++) {\n-\t\t\tresult[i] = refs1[i];\n-\t\t}\n-\t\tfor (int i = 0; i < refs2.length; i++) {\n-\t\t\tresult[refs1.length + i] = refs2[i];\n-\t\t}\n-\t\treturn result;\n-\t}\n-\t\n-\tprivate EclipseNode makeBuilderAbstractClass(EclipseNode tdParent, String builderClass,\n-\t\t\tTypeReference superclassBuilderClass, TypeParameter[] typeParams,\n-\t\t\tTypeParameter[] superclassTypeParams, ASTNode source, String classGenericName, String builderGenericName) {\n-\n-\t\tTypeDeclaration parent = (TypeDeclaration) tdParent.get();\n-\t\tTypeDeclaration builder = new TypeDeclaration(parent.compilationResult);\n-\t\tbuilder.bits |= Eclipse.ECLIPSE_DO_NOT_TOUCH_FLAG;\n-\t\tbuilder.modifiers |= ClassFileConstants.AccPublic | ClassFileConstants.AccStatic | ClassFileConstants.AccAbstract;\n-\t\tbuilder.name = builderClass.toCharArray();\n-\n-\t\t// Keep any type params of the annotated class.\n-\t\tbuilder.typeParameters = Arrays.copyOf(copyTypeParams(typeParams, source), typeParams.length + 2);\n-\t\t// Add builder-specific type params required for inheritable builders.\n-\t\t// 1. The return type for the build() method, named \"C\", which extends the annotated class.\n-\t\tTypeParameter o = new TypeParameter();\n-\t\to.name = classGenericName.toCharArray();\n-\t\to.type = cloneSelfType(tdParent, source);\n-\t\tbuilder.typeParameters[builder.typeParameters.length - 2] = o;\n-\t\t// 2. The return type for all setter methods, named \"B\", which extends this builder class.\n-\t\to = new TypeParameter();\n-\t\to.name = builderGenericName.toCharArray();\n-\t\tTypeReference[] typerefs = appendBuilderTypeReferences(typeParams, classGenericName, builderGenericName);\n-\t\to.type = new ParameterizedSingleTypeReference(builderClass.toCharArray(), typerefs, 0, 0);\n-\t\tbuilder.typeParameters[builder.typeParameters.length - 1] = o;\n-\n-\t\tbuilder.superclass = copyType(superclassBuilderClass, source);\n-\n-\t\tbuilder.traverse(new SetGeneratedByVisitor(source), (ClassScope) null);\n-\t\treturn injectType(tdParent, builder);\n-\t}\n-\t\n-\tprivate EclipseNode makeBuilderImplClass(EclipseNode tdParent, String builderImplClass, String builderAbstractClass, TypeParameter[] typeParams, ASTNode source) {\n-\t\tTypeDeclaration parent = (TypeDeclaration) tdParent.get();\n-\t\tTypeDeclaration builder = new TypeDeclaration(parent.compilationResult);\n-\t\tbuilder.bits |= Eclipse.ECLIPSE_DO_NOT_TOUCH_FLAG;\n-\t\tbuilder.modifiers |= ClassFileConstants.AccPrivate | ClassFileConstants.AccStatic | ClassFileConstants.AccFinal;\n-\t\tbuilder.name = builderImplClass.toCharArray();\n-\t\t// Add type params if there are any.\n-\t\tif (typeParams != null && typeParams.length > 0) {\n-\t\t\tbuilder.typeParameters = copyTypeParams(typeParams, source);\n-\t\t}\n-\t\tif (builderAbstractClass != null) {\n-\t\t\t// Extend the abstract builder.\n-\t\t\t// 1. Add any type params of the annotated class.\n-\t\t\tTypeReference[] typeArgs = new TypeReference[typeParams.length + 2];\n-\t\t\tfor (int i = 0; i < typeParams.length; i++) {\n-\t\t\t\ttypeArgs[i] = new SingleTypeReference(typeParams[i].name, 0);\n-\t\t\t}\n-\t\t\t// 2. The return type for the build() method (named \"C\" in the abstract builder), which is the annotated class.\n-\t\t\t// 3. The return type for all setter methods (named \"B\" in the abstract builder), which is this builder class.\n-\t\t\ttypeArgs[typeArgs.length - 2] = cloneSelfType(tdParent, source);\n-\t\t\ttypeArgs[typeArgs.length - 1] = createTypeReferenceWithTypeParameters(builderImplClass, typeParams);\n-\t\t\tbuilder.superclass = new ParameterizedSingleTypeReference(builderAbstractClass.toCharArray(), typeArgs, 0, 0);\n-\t\t}\n-\t\tbuilder.traverse(new SetGeneratedByVisitor(source), (ClassScope) null);\n-\t\treturn injectType(tdParent, builder);\n-\t}\n-\n \tprivate void addObtainVia(BuilderFieldData bfd, EclipseNode node) {\n \t\tfor (EclipseNode child : node.down()) {\n \t\t\tif (!annotationTypeMatches(ObtainVia.class, child)) {\n@@ -844,6 +777,38 @@ private SingularData getSingularData(EclipseNode node, ASTNode source) {\n \t\treturn null;\n \t}\n \n+\tprivate String generateNonclashingNameFor(String classGenericName, java.util.List<String> typeParamStrings) {\n+\t\tif (!typeParamStrings.contains(classGenericName)) {\n+\t\t\treturn classGenericName;\n+\t\t}\n+\t\tint counter = 2;\n+\t\twhile (typeParamStrings.contains(classGenericName + counter)) {\n+\t\t\tcounter++;\n+\t\t}\n+\t\treturn classGenericName + counter;\n+\t}\n+\n+\tprivate TypeReference[] appendBuilderTypeReferences(TypeParameter[] typeParams, String classGenericName, String builderGenericName) {\n+\t\tTypeReference[] typeReferencesToAppend = new TypeReference[2];\n+\t\ttypeReferencesToAppend[typeReferencesToAppend.length - 2] = new SingleTypeReference(classGenericName.toCharArray(), 0); \n+\t\ttypeReferencesToAppend[typeReferencesToAppend.length - 1] = new SingleTypeReference(builderGenericName.toCharArray(), 0);\n+\t\treturn mergeToTypeReferences(typeParams, typeReferencesToAppend);\n+\t}\n+\n+\tprivate TypeReference[] getTypeParametersFrom(TypeReference typeRef) {\n+\t\tTypeReference[][] typeArgss = null;\n+\t\tif (typeRef instanceof ParameterizedQualifiedTypeReference) {\n+\t\t\ttypeArgss = ((ParameterizedQualifiedTypeReference)typeRef).typeArguments;\n+\t\t} else if (typeRef instanceof ParameterizedSingleTypeReference) {\n+\t\t\ttypeArgss = new TypeReference[][] {((ParameterizedSingleTypeReference)typeRef).typeArguments};\n+\t\t}\n+\t\tTypeReference[] typeArgs = new TypeReference[0];\n+\t\tif (typeArgss != null && typeArgss.length > 0) {\n+\t\t\ttypeArgs = typeArgss[typeArgss.length - 1];\n+\t\t}\n+\t\treturn typeArgs;\n+\t}\n+\n \tprivate static SingleTypeReference createTypeReferenceWithTypeParameters(String referenceName, TypeParameter[] typeParams) {\n \t\tif (typeParams.length > 0) {\n \t\t\tTypeReference[] typerefs = new TypeReference[typeParams.length];\n@@ -857,6 +822,42 @@ private static SingleTypeReference createTypeReferenceWithTypeParameters(String\n \n \t}\n \t\n+\tprivate TypeReference[] mergeToTypeReferences(TypeParameter[] typeParams, TypeReference[] typeReferencesToAppend) {\n+\t\tTypeReference[] typerefs = new TypeReference[typeParams.length + typeReferencesToAppend.length];\n+\t\tfor (int i = 0; i < typeParams.length; i++) {\n+\t\t\ttyperefs[i] = new SingleTypeReference(typeParams[i].name, 0);\n+\t\t}\n+\t\tfor (int i = 0; i < typeReferencesToAppend.length; i++) {\n+\t\t\ttyperefs[typeParams.length + i] = typeReferencesToAppend[i];\n+\t\t}\n+\t\treturn typerefs;\n+\t}\n+\n+\tprivate TypeReference[] mergeTypeReferences(TypeReference[] refs1, TypeReference[] refs2) {\n+\t\tTypeReference[] result = new TypeReference[refs1.length + refs2.length];\n+\t\tfor (int i = 0; i < refs1.length; i++) {\n+\t\t\tresult[i] = refs1[i];\n+\t\t}\n+\t\tfor (int i = 0; i < refs2.length; i++) {\n+\t\t\tresult[refs1.length + i] = refs2[i];\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprivate EclipseNode findInnerClass(EclipseNode parent, String name) {\n+\t\tchar[] c = name.toCharArray();\n+\t\tfor (EclipseNode child : parent.down()) {\n+\t\t\tif (child.getKind() != Kind.TYPE) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tTypeDeclaration td = (TypeDeclaration) child.get();\n+\t\t\tif (Arrays.equals(td.name, c)) {\n+\t\t\t\treturn child;\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n \tprivate static final char[] prefixWith(char[] prefix, char[] name) {\n \t\tchar[] out = new char[prefix.length + name.length];\n \t\tSystem.arraycopy(prefix, 0, out, 0, prefix.length);",
      "parent_sha": "664ed48460eba30b9cab7f9298ac563c4a23c993"
    }
  },
  {
    "oid": "094077da6eef53366574d313ec8d0956d885a2cf",
    "message": "Avoid looking up parent if bubbling stopped",
    "date": "2023-02-22T12:56:13Z",
    "url": "https://github.com/projectlombok/lombok/commit/094077da6eef53366574d313ec8d0956d885a2cf",
    "details": {
      "sha": "c55bc75e19c57c634601789fe1147b21de62dd6d",
      "filename": "src/core/lombok/core/configuration/BubblingConfigurationResolver.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/projectlombok/lombok/blob/094077da6eef53366574d313ec8d0956d885a2cf/src%2Fcore%2Flombok%2Fcore%2Fconfiguration%2FBubblingConfigurationResolver.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/094077da6eef53366574d313ec8d0956d885a2cf/src%2Fcore%2Flombok%2Fcore%2Fconfiguration%2FBubblingConfigurationResolver.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fcore%2Fconfiguration%2FBubblingConfigurationResolver.java?ref=094077da6eef53366574d313ec8d0956d885a2cf",
      "patch": "@@ -82,7 +82,7 @@ public <T> T resolve(ConfigurationKey<T> key) {\n \t\t\t\t\treturn (T) result.getValue();\n \t\t\t\t}\n \t\t\t}\n-\t\t\tcurrentLevel = currentLevel.parent();\n+\t\t\tcurrentLevel = stopBubbling ? null : currentLevel.parent();\n \t\t}\n \t\t\n \t\tif (!isList) return null;",
      "parent_sha": "e5c324c615c1e304b2a9a64bc7f8608a67b0a74e"
    }
  },
  {
    "oid": "7a575e1e5d1c78fa5be1deca7fc308bd9eb390dd",
    "message": "Copy all field annotations to the corresponding builder parameter.\nMaybe some filtering is necessary and should be added later.",
    "date": "2018-09-10T23:59:19Z",
    "url": "https://github.com/projectlombok/lombok/commit/7a575e1e5d1c78fa5be1deca7fc308bd9eb390dd",
    "details": {
      "sha": "335dee1a88386da2e76290308607303da45152b4",
      "filename": "src/core/lombok/javac/handlers/HandleBuilder.java",
      "status": "modified",
      "additions": 6,
      "deletions": 3,
      "changes": 9,
      "blob_url": "https://github.com/projectlombok/lombok/blob/7a575e1e5d1c78fa5be1deca7fc308bd9eb390dd/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FHandleBuilder.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/7a575e1e5d1c78fa5be1deca7fc308bd9eb390dd/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FHandleBuilder.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FHandleBuilder.java?ref=7a575e1e5d1c78fa5be1deca7fc308bd9eb390dd",
      "patch": "@@ -85,6 +85,7 @@ private static final boolean toBoolean(Object expr, boolean defaultValue) {\n \t}\n \t\n \tprivate static class BuilderFieldData {\n+\t\tList<JCAnnotation> annotations;\n \t\tJCExpression type;\n \t\tName rawName;\n \t\tName name;\n@@ -151,6 +152,7 @@ private static class BuilderFieldData {\n \t\t\t\tBuilderFieldData bfd = new BuilderFieldData();\n \t\t\t\tbfd.rawName = fd.name;\n \t\t\t\tbfd.name = removePrefixFromField(fieldNode);\n+\t\t\t\tbfd.annotations = fd.mods.annotations;\n \t\t\t\tbfd.type = fd.vartype;\n \t\t\t\tbfd.singularData = getSingularData(fieldNode);\n \t\t\t\tbfd.originalFieldNode = fieldNode;\n@@ -329,6 +331,7 @@ private static class BuilderFieldData {\n \t\t\t\tJCVariableDecl raw = (JCVariableDecl) param.get();\n \t\t\t\tbfd.name = raw.name;\n \t\t\t\tbfd.rawName = raw.name;\n+\t\t\t\tbfd.annotations = raw.mods.annotations;\n \t\t\t\tbfd.type = raw.vartype;\n \t\t\t\tbfd.singularData = getSingularData(param);\n \t\t\t\tbfd.originalFieldNode = param;\n@@ -678,13 +681,13 @@ public void generateBuilderFields(JavacNode builderType, java.util.List<BuilderF\n \tpublic void makeSetterMethodsForBuilder(JavacNode builderType, BuilderFieldData fieldNode, JavacNode source, boolean fluent, boolean chain) {\n \t\tboolean deprecate = isFieldDeprecated(fieldNode.originalFieldNode);\n \t\tif (fieldNode.singularData == null || fieldNode.singularData.getSingularizer() == null) {\n-\t\t\tmakeSimpleSetterMethodForBuilder(builderType, deprecate, fieldNode.createdFields.get(0), fieldNode.nameOfSetFlag, source, fluent, chain);\n+\t\t\tmakeSimpleSetterMethodForBuilder(builderType, deprecate, fieldNode.createdFields.get(0), fieldNode.nameOfSetFlag, source, fluent, chain, fieldNode.annotations);\n \t\t} else {\n \t\t\tfieldNode.singularData.getSingularizer().generateMethods(fieldNode.singularData, deprecate, builderType, source.get(), fluent, chain);\n \t\t}\n \t}\n \t\n-\tprivate void makeSimpleSetterMethodForBuilder(JavacNode builderType, boolean deprecate, JavacNode fieldNode, Name nameOfSetFlag, JavacNode source, boolean fluent, boolean chain) {\n+\tprivate void makeSimpleSetterMethodForBuilder(JavacNode builderType, boolean deprecate, JavacNode fieldNode, Name nameOfSetFlag, JavacNode source, boolean fluent, boolean chain, List<JCAnnotation> annosOnParam) {\n \t\tName fieldName = ((JCVariableDecl) fieldNode.get()).name;\n \t\t\n \t\tfor (JavacNode child : builderType.down()) {\n@@ -698,7 +701,7 @@ private void makeSimpleSetterMethodForBuilder(JavacNode builderType, boolean dep\n \t\t\n \t\tJavacTreeMaker maker = fieldNode.getTreeMaker();\n \t\t\n-\t\tJCMethodDecl newMethod = HandleSetter.createSetter(Flags.PUBLIC, deprecate, fieldNode, maker, setterName, nameOfSetFlag, chain, source, List.<JCAnnotation>nil(), List.<JCAnnotation>nil());\n+\t\tJCMethodDecl newMethod = HandleSetter.createSetter(Flags.PUBLIC, deprecate, fieldNode, maker, setterName, nameOfSetFlag, chain, source, List.<JCAnnotation>nil(), annosOnParam);\n \t\t\n \t\tinjectMethod(builderType, newMethod);\n \t}",
      "parent_sha": "2027ffc49f194da2892938e0cd5868cd286a06f6"
    }
  },
  {
    "oid": "05760d67ef4ccec8b702166371c7bdc9bdf77d95",
    "message": "[Closes #899] Typo in the LogManager name of log4j2 in the javadoc of the Log4j2 annotation.",
    "date": "2015-08-18T20:14:09Z",
    "url": "https://github.com/projectlombok/lombok/commit/05760d67ef4ccec8b702166371c7bdc9bdf77d95",
    "details": {
      "sha": "96d793f7f57f8a5380b239f46ca38b6ec86b1af3",
      "filename": "src/core/lombok/extern/log4j/Log4j2.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/projectlombok/lombok/blob/05760d67ef4ccec8b702166371c7bdc9bdf77d95/src%2Fcore%2Flombok%2Fextern%2Flog4j%2FLog4j2.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/05760d67ef4ccec8b702166371c7bdc9bdf77d95/src%2Fcore%2Flombok%2Fextern%2Flog4j%2FLog4j2.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fextern%2Flog4j%2FLog4j2.java?ref=05760d67ef4ccec8b702166371c7bdc9bdf77d95",
      "patch": "@@ -42,7 +42,7 @@\n  * \n  * <pre>\n  * public class LogExample {\n- *     private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.Logger.getLogger(LogExample.class);\n+ *     private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class);\n  * }\n  * </pre>\n  * ",
      "parent_sha": "a09f5842d9adebde7df13e0f29165fe61ce03e69"
    }
  },
  {
    "oid": "4ded143defebd49610e74443e2d6d813d57fd11b",
    "message": "Updated version name - should have done that after pushing 0.10.0-BETA2.",
    "date": "2010-11-22T22:52:35Z",
    "url": "https://github.com/projectlombok/lombok/commit/4ded143defebd49610e74443e2d6d813d57fd11b",
    "details": {
      "sha": "f1cb4437a5a75ec20ba32d274a4abfaad99f379a",
      "filename": "src/core/lombok/core/Version.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/projectlombok/lombok/blob/4ded143defebd49610e74443e2d6d813d57fd11b/src%2Fcore%2Flombok%2Fcore%2FVersion.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/4ded143defebd49610e74443e2d6d813d57fd11b/src%2Fcore%2Flombok%2Fcore%2FVersion.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fcore%2FVersion.java?ref=4ded143defebd49610e74443e2d6d813d57fd11b",
      "patch": "@@ -26,7 +26,7 @@\n  */\n public class Version {\n \t// ** CAREFUL ** - this class must always compile with 0 dependencies (it must not refer to any other sources or libraries).\n-\tprivate static final String VERSION = \"0.10.0-BETA2\";\n+\tprivate static final String VERSION = \"0.10.0-BETA2-HEAD\";\n \tprivate static final String RELEASE_NAME = \"Burning Emu\";\n \t\n \tprivate Version() {",
      "parent_sha": "d76c50e9d5250c86a8ecc89e98379386c6ce23c4"
    }
  },
  {
    "oid": "01d622d471d9b1809128dc9d5c834d33d4ff6866",
    "message": "Beta Release Prep",
    "date": "2009-12-02T23:22:06Z",
    "url": "https://github.com/projectlombok/lombok/commit/01d622d471d9b1809128dc9d5c834d33d4ff6866",
    "details": {
      "sha": "b5e7fbc9e60c4547fa5d8437a7e24e3f0a355ba5",
      "filename": "src/core/lombok/core/Version.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/projectlombok/lombok/blob/01d622d471d9b1809128dc9d5c834d33d4ff6866/src%2Fcore%2Flombok%2Fcore%2FVersion.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/01d622d471d9b1809128dc9d5c834d33d4ff6866/src%2Fcore%2Flombok%2Fcore%2FVersion.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fcore%2FVersion.java?ref=01d622d471d9b1809128dc9d5c834d33d4ff6866",
      "patch": "@@ -26,7 +26,7 @@\n  */\n public class Version {\n \t// ** CAREFUL ** - this class must always compile with 0 dependencies (it must not refer to any other sources or libraries).\n-\tprivate static final String VERSION = \"0.9.2-HEAD\";\n+\tprivate static final String VERSION = \"0.9.2-BETA3\";\n \t\n \tprivate Version() {\n \t\t//Prevent instantiation",
      "parent_sha": "881e1d0858327486bb2bad9782fac5f7cc4d8010"
    }
  },
  {
    "oid": "e131cf6b42add619b88fe60c2bff143b5276d55a",
    "message": "[refactor] Replace duplicate code with new method, add null check",
    "date": "2020-12-23T08:45:14Z",
    "url": "https://github.com/projectlombok/lombok/commit/e131cf6b42add619b88fe60c2bff143b5276d55a",
    "details": {
      "sha": "62c71f5b21d6f32e6346062d0c1c2a5c3607bb4e",
      "filename": "src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java",
      "status": "modified",
      "additions": 11,
      "deletions": 9,
      "changes": 20,
      "blob_url": "https://github.com/projectlombok/lombok/blob/e131cf6b42add619b88fe60c2bff143b5276d55a/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FEclipseHandlerUtil.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/e131cf6b42add619b88fe60c2bff143b5276d55a/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FEclipseHandlerUtil.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FEclipseHandlerUtil.java?ref=e131cf6b42add619b88fe60c2bff143b5276d55a",
      "patch": "@@ -292,9 +292,7 @@ public static Annotation copyAnnotation(Annotation annotation, ASTNode source) {\n \t\t\tMarkerAnnotation ann = new MarkerAnnotation(copyType(annotation.type, source), pS);\n \t\t\tsetGeneratedBy(ann, source);\n \t\t\tann.declarationSourceEnd = ann.sourceEnd = ann.statementEnd = pE;\n-\t\t\ttry {\n-\t\t\t\treflectSet(ANNOTATION__MEMBER_VALUE_PAIR_NAME, ann, reflect(ANNOTATION__MEMBER_VALUE_PAIR_NAME, annotation));\n-\t\t\t} catch (Exception ignore) { /* Various eclipse versions don't have it */ }\n+\t\t\tcopyMemberValuePairName(ann, annotation);\n \t\t\treturn ann;\n \t\t}\n \t\t\n@@ -303,9 +301,7 @@ public static Annotation copyAnnotation(Annotation annotation, ASTNode source) {\n \t\t\tsetGeneratedBy(ann, source);\n \t\t\tann.declarationSourceEnd = ann.sourceEnd = ann.statementEnd = pE;\n \t\t\tann.memberValue = copyAnnotationMemberValue(((SingleMemberAnnotation) annotation).memberValue);\n-\t\t\ttry {\n-\t\t\t\treflectSet(ANNOTATION__MEMBER_VALUE_PAIR_NAME, ann, reflect(ANNOTATION__MEMBER_VALUE_PAIR_NAME, annotation));\n-\t\t\t} catch (Exception ignore) { /* Various eclipse versions don't have it */ }\n+\t\t\tcopyMemberValuePairName(ann, annotation);\n \t\t\treturn ann;\n \t\t}\n \t\t\n@@ -321,15 +317,21 @@ public static Annotation copyAnnotation(Annotation annotation, ASTNode source) {\n \t\t\t\tfor (int i = 0; i < inPairs.length; i++) ann.memberValuePairs[i] =\n \t\t\t\t\t\tnew MemberValuePair(inPairs[i].name, inPairs[i].sourceStart, inPairs[i].sourceEnd, copyAnnotationMemberValue(inPairs[i].value));\n \t\t\t}\n-\t\t\ttry {\n-\t\t\t\treflectSet(ANNOTATION__MEMBER_VALUE_PAIR_NAME, ann, reflect(ANNOTATION__MEMBER_VALUE_PAIR_NAME, annotation));\n-\t\t\t} catch (Exception ignore) { /* Various eclipse versions don't have it */ }\n+\t\t\tcopyMemberValuePairName(ann, annotation);\n \t\t\treturn ann;\n \t\t}\n \t\t\n \t\treturn annotation;\n \t}\n \t\n+\tprivate static void copyMemberValuePairName(Annotation source, Annotation target) {\n+\t\tif (ANNOTATION__MEMBER_VALUE_PAIR_NAME == null) return;\n+\t\t\n+\t\ttry {\n+\t\t\treflectSet(ANNOTATION__MEMBER_VALUE_PAIR_NAME, source, reflect(ANNOTATION__MEMBER_VALUE_PAIR_NAME, target));\n+\t\t} catch (Exception ignore) { /* Various eclipse versions don't have it */ }\n+\t}\n+\t\n \tstatic class EclipseReflectiveMembers {\n \t\tpublic static final Field STRING_LITERAL__LINE_NUMBER;\n \t\tpublic static final Field ANNOTATION__MEMBER_VALUE_PAIR_NAME;",
      "parent_sha": "8ba5df7161f7a6ef24b67d783f3a4fd6c2359fee"
    }
  },
  {
    "oid": "d5f4bb8d9e51780f1ff0e80242ee0ba42fb54759",
    "message": "[javadoc]",
    "date": "2009-12-15T19:18:45Z",
    "url": "https://github.com/projectlombok/lombok/commit/d5f4bb8d9e51780f1ff0e80242ee0ba42fb54759",
    "details": {
      "sha": "35f0b59cba720613940ce286f853fe8830381a5f",
      "filename": "src/core/lombok/core/LombokApp.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/projectlombok/lombok/blob/d5f4bb8d9e51780f1ff0e80242ee0ba42fb54759/src%2Fcore%2Flombok%2Fcore%2FLombokApp.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/d5f4bb8d9e51780f1ff0e80242ee0ba42fb54759/src%2Fcore%2Flombok%2Fcore%2FLombokApp.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fcore%2FLombokApp.java?ref=d5f4bb8d9e51780f1ff0e80242ee0ba42fb54759",
      "patch": "@@ -26,7 +26,7 @@\n /**\n  * Implement this class, and add yourself as a provider for it, to become an app runnable by running lombok.jar as a jar.\n  * \n- * @see lombok.delombok.DelombokApp\n+ * @see lombok.core.Main.VersionApp\n  */\n public interface LombokApp {\n \t/**",
      "parent_sha": "fb189915506b964b40676348ea6dd81e4a7652ef"
    }
  },
  {
    "oid": "c025ef0695a3678463bfa1487372427b00e3e887",
    "message": "Try fix \"A save participant caused problems.\" \n\nThe bugfix was originally created by mateusz-matela",
    "date": "2018-01-07T18:34:03Z",
    "url": "https://github.com/projectlombok/lombok/commit/c025ef0695a3678463bfa1487372427b00e3e887",
    "details": {
      "sha": "d3477c1f535950b248aa0205ac99c6ab5d14b45d",
      "filename": "src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java",
      "status": "modified",
      "additions": 12,
      "deletions": 18,
      "changes": 30,
      "blob_url": "https://github.com/projectlombok/lombok/blob/c025ef0695a3678463bfa1487372427b00e3e887/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FEclipsePatcher.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/c025ef0695a3678463bfa1487372427b00e3e887/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FEclipsePatcher.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FEclipsePatcher.java?ref=c025ef0695a3678463bfa1487372427b00e3e887",
      "patch": "@@ -105,7 +105,7 @@ public String mapResourceName(int classFileFormatVersion, String resourceName) {\n \t\t\tpatchHideGeneratedNodes(sm);\n \t\t\tpatchPostCompileHookEclipse(sm);\n \t\t\tpatchFixSourceTypeConverter(sm);\n-\t\t\tpatchDisableLombokForCodeFormatterAndCleanup(sm);\n+\t\t\tpatchDisableLombokForCodeCleanup(sm);\n \t\t\tpatchListRewriteHandleGeneratedMethods(sm);\n \t\t\tpatchSyntaxAndOccurrencesHighlighting(sm);\n \t\t\tpatchSortMembersOperation(sm);\n@@ -214,14 +214,7 @@ private static void patchSyntaxAndOccurrencesHighlighting(ScriptManager sm) {\n \t\t\t\t.build());\n \t}\n \t\n-\tprivate static void patchDisableLombokForCodeFormatterAndCleanup(ScriptManager sm) {\n-\t\tsm.addScript(ScriptBuilder.setSymbolDuringMethodCall()\n-\t\t\t\t//.target(new MethodTarget(\"org.eclipse.jdt.internal.formatter.DefaultCodeFormatter\", \"formatCompilationUnit\"))\n-\t\t\t\t.target(new MethodTarget(\"org.eclipse.jdt.internal.formatter.DefaultCodeFormatter\", \"parseSourceCode\"))\n-\t\t\t\t.callToWrap(new Hook(\"org.eclipse.jdt.internal.core.util.CodeSnippetParsingUtil\", \"parseCompilationUnit\", \"org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration\", \"char[]\", \"java.util.Map\", \"boolean\"))\n-\t\t\t\t.symbol(\"lombok.disable\")\n-\t\t\t\t.build());\n-\t\t\n+\tprivate static void patchDisableLombokForCodeCleanup(ScriptManager sm) {\n \t\tsm.addScript(ScriptBuilder.exitEarly()\n \t\t\t.target(new MethodTarget(\"org.eclipse.jdt.internal.corext.fix.ControlStatementsFix$ControlStatementFinder\", \"visit\", \"boolean\", \"org.eclipse.jdt.core.dom.DoStatement\"))\n \t\t\t.target(new MethodTarget(\"org.eclipse.jdt.internal.corext.fix.ControlStatementsFix$ControlStatementFinder\", \"visit\", \"boolean\", \"org.eclipse.jdt.core.dom.EnhancedForStatement\"))\n@@ -340,18 +333,19 @@ private static void patchHideGeneratedNodes(ScriptManager sm) {\n \t}\n \t\n \tprivate static void patchFormatters(ScriptManager sm) {\n+\t    // before Eclipse Mars\n \t\tsm.addScript(ScriptBuilder.setSymbolDuringMethodCall()\n-\t\t\t\t.target(new MethodTarget(\"org.eclipse.jdt.internal.ui.text.java.JavaFormattingStrategy\", \"format\", \"void\"))\n-\t\t\t\t.callToWrap(new Hook(\"org.eclipse.jdt.internal.corext.util.CodeFormatterUtil\", \"reformat\", \"org.eclipse.text.edits.TextEdit\",\n-\t\t\t\t\t\t\"int\", \"java.lang.String\", \"int\", \"int\", \"int\", \"java.lang.String\", \"java.util.Map\"))\n-\t\t\t\t.symbol(\"lombok.disable\").build());\n+\t\t        .target(new MethodTarget(\"org.eclipse.jdt.internal.formatter.DefaultCodeFormatter\", \"formatCompilationUnit\"))\n+\t\t        .callToWrap(new Hook(\"org.eclipse.jdt.internal.core.util.CodeSnippetParsingUtil\", \"parseCompilationUnit\", \"org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration\", \"char[]\", \"java.util.Map\", \"boolean\"))\n+\t\t        .symbol(\"lombok.disable\")\n+\t\t        .build());\n \t\t\n+\t\t// Eclipse Mars and beyond\n \t\tsm.addScript(ScriptBuilder.setSymbolDuringMethodCall()\n-\t\t\t\t.target(new MethodTarget(\"org.eclipse.jdt.internal.corext.fix.CodeFormatFix\", \"createCleanUp\", \"org.eclipse.jdt.ui.cleanup.ICleanUpFix\",\n-\t\t\t\t\t\t\"org.eclipse.jdt.core.ICompilationUnit\", \"org.eclipse.jface.text.IRegion[]\", \"boolean\", \"boolean\", \"boolean\", \"boolean\"))\n-\t\t\t\t.callToWrap(new Hook(\"org.eclipse.jdt.internal.corext.util.CodeFormatterUtil\", \"reformat\", \"org.eclipse.text.edits.TextEdit\",\n-\t\t\t\t\t\t\"int\", \"java.lang.String\", \"int\", \"java.lang.String\", \"java.util.Map\"))\n-\t\t\t\t.symbol(\"lombok.disable\").build());\n+\t\t        .target(new MethodTarget(\"org.eclipse.jdt.internal.formatter.DefaultCodeFormatter\", \"parseSourceCode\"))\n+\t\t        .callToWrap(new Hook(\"org.eclipse.jdt.core.dom.ASTParser\", \"createAST\", \"org.eclipse.jdt.core.dom.ASTNode\", \"org.eclipse.core.runtime.IProgressMonitor\"))\n+\t\t        .symbol(\"lombok.disable\")\n+\t\t        .build());\n \t}\n \t\n \tprivate static void patchRefactorScripts(ScriptManager sm) {",
      "parent_sha": "98f08c245528ffd72c341d43ace131a4691927c0"
    }
  },
  {
    "oid": "0ef67926087ed2a6878e8b1c32f387b135c1d3df",
    "message": "For the strangest reason, compiling Getter with javac fails; it wants AccessLevel, but has AccessLevel. Yah, WTF. Turning AccessLevel into its FQN: lombok.AccessLevel fixes it. javac bug?",
    "date": "2009-06-12T06:35:43Z",
    "url": "https://github.com/projectlombok/lombok/commit/0ef67926087ed2a6878e8b1c32f387b135c1d3df",
    "details": {
      "sha": "d6a1054751bbb0d00906cf29a3700cc87008636a",
      "filename": "src/lombok/Getter.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/projectlombok/lombok/blob/0ef67926087ed2a6878e8b1c32f387b135c1d3df/src%2Flombok%2FGetter.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/0ef67926087ed2a6878e8b1c32f387b135c1d3df/src%2Flombok%2FGetter.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Flombok%2FGetter.java?ref=0ef67926087ed2a6878e8b1c32f387b135c1d3df",
      "patch": "@@ -8,5 +8,5 @@\n @Target(ElementType.FIELD)\n @Retention(RetentionPolicy.CLASS)\n public @interface Getter {\n-\tAccessLevel value() default AccessLevel.PUBLIC;\n+\tAccessLevel value() default lombok.AccessLevel.PUBLIC;\n }",
      "parent_sha": "d7434059c4492d9684f81b32c1f373b121c6a577"
    }
  },
  {
    "oid": "8b283e89e9e96cf21428ce0ecbdc0699a26d4213",
    "message": "[issue #278]: Assigned final fields and @AllArgsConstructor\n\nIn eclipse assigned final fields broke the @AllArgsConstructor. Now they are just skipped as intended.",
    "date": "2011-09-30T08:32:36Z",
    "url": "https://github.com/projectlombok/lombok/commit/8b283e89e9e96cf21428ce0ecbdc0699a26d4213",
    "details": {
      "sha": "6aca4cccf192f97450c2894e433868d0c6ebf220",
      "filename": "src/core/lombok/eclipse/handlers/HandleConstructor.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/projectlombok/lombok/blob/8b283e89e9e96cf21428ce0ecbdc0699a26d4213/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleConstructor.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/8b283e89e9e96cf21428ce0ecbdc0699a26d4213/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleConstructor.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleConstructor.java?ref=8b283e89e9e96cf21428ce0ecbdc0699a26d4213",
      "patch": "@@ -131,7 +131,7 @@ public static class HandleAllArgsConstructor extends EclipseAnnotationHandler<Al\n \t\t\t\tif (!EclipseHandlerUtil.filterField(fieldDecl)) continue;\n \t\t\t\t\n \t\t\t\t// Skip initialized final fields.\n-\t\t\t\tif (((fieldDecl.modifiers & ClassFileConstants.AccFinal) != 0) && fieldDecl.initialization != null) return;\n+\t\t\t\tif (((fieldDecl.modifiers & ClassFileConstants.AccFinal) != 0) && fieldDecl.initialization != null) continue;\n \t\t\t\t\n \t\t\t\tfields.add(child);\n \t\t\t}",
      "parent_sha": "40fe2506274b812598763ad9a37153b277ffa21d"
    }
  },
  {
    "oid": "ced7a8d5549af733bd0463daf533d08fe21a65ab",
    "message": "Added the state of the HasAllMethodBodies flag in the issue 164 analyser. Looks like eclipse sometimes sets this flag even though\nall method bodies are not in fact parsed yet, as a shortcut to try and force future eclipse parse runs to simply skip doing it\nas a timesaver. D'oh.",
    "date": "2011-08-01T09:21:24Z",
    "url": "https://github.com/projectlombok/lombok/commit/ced7a8d5549af733bd0463daf533d08fe21a65ab",
    "details": {
      "sha": "3982539e6875706ec9cc77b2f9450d036a387c01",
      "filename": "src/core/lombok/core/debug/DebugSnapshot.java",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/projectlombok/lombok/blob/ced7a8d5549af733bd0463daf533d08fe21a65ab/src%2Fcore%2Flombok%2Fcore%2Fdebug%2FDebugSnapshot.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/ced7a8d5549af733bd0463daf533d08fe21a65ab/src%2Fcore%2Flombok%2Fcore%2Fdebug%2FDebugSnapshot.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fcore%2Fdebug%2FDebugSnapshot.java?ref=ced7a8d5549af733bd0463daf533d08fe21a65ab",
      "patch": "@@ -5,12 +5,14 @@\n import java.util.List;\n import java.util.concurrent.atomic.AtomicLong;\n \n+import org.eclipse.jdt.internal.compiler.ast.ASTNode;\n import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\n \n public class DebugSnapshot implements Comparable<DebugSnapshot> {\n \tprivate static AtomicLong counter = new AtomicLong();\n \t\n \tprivate final long when, id = counter.getAndIncrement();\n+\tprivate final long bits;\n \tprivate final List<StackTraceElement> trace;\n \tprivate final String threadName;\n \tprivate final String message;\n@@ -19,6 +21,7 @@ public class DebugSnapshot implements Comparable<DebugSnapshot> {\n \t\n \tpublic DebugSnapshot(CompilationUnitDeclaration owner, int stackHiding, String message, Object... params) {\n \t\tthis.when = System.currentTimeMillis();\n+\t\tthis.bits = owner.bits;\n \t\tStackTraceElement[] stackTrace = new Throwable().getStackTrace();\n \t\tthis.trace = new ArrayList<StackTraceElement>(Math.max(0, stackTrace.length - stackHiding - 1));\n \t\tfor (int i = 1 + stackHiding; i < stackTrace.length; i++) trace.add(stackTrace[i]);\n@@ -42,7 +45,7 @@ private String ownerName() {\n \t\n \tpublic String shortToString() {\n \t\tStringBuilder out = new StringBuilder();\n-\t\tout.append(String.format(\"WHEN: %14d THREAD: %s AST: %s\", when, threadName, ownerName()));\n+\t\tout.append(String.format(\"WHEN: %14d THREAD: %s AST: %s HAMB: %b -- \", when, threadName, ownerName(), 0 != (bits & ASTNode.HasAllMethodBodies)));\n \t\tif (message != null) out.append(\" \").append(String.format(message, params));\n \t\treturn out.toString();\n \t}",
      "parent_sha": "6f8e8adf4c0c31aa17573da89938bc50894f0a52"
    }
  },
  {
    "oid": "bd03b512ba45bc0d6b99e118787b8b0f4b706d9e",
    "message": "Copy the indentation code instead of requiring dep on jdt internal\n\nSigned-off-by: Rob Stryker <rob@oxbeef.net>",
    "date": "2023-12-05T21:55:27Z",
    "url": "https://github.com/projectlombok/lombok/commit/bd03b512ba45bc0d6b99e118787b8b0f4b706d9e",
    "details": {
      "sha": "fb68b483e0d9a3d8be439ca18b1c9df24980fe49",
      "filename": "src/eclipseAgent/lombok/eclipse/agent/PatchJavadoc.java",
      "status": "modified",
      "additions": 12,
      "deletions": 4,
      "changes": 16,
      "blob_url": "https://github.com/projectlombok/lombok/blob/bd03b512ba45bc0d6b99e118787b8b0f4b706d9e/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchJavadoc.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/bd03b512ba45bc0d6b99e118787b8b0f4b706d9e/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchJavadoc.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchJavadoc.java?ref=bd03b512ba45bc0d6b99e118787b8b0f4b706d9e",
      "patch": "@@ -72,8 +72,7 @@ public static StringBuilder printMethod(AbstractMethodDeclaration methodDeclarat\n \t\t\tString rawJavadoc = docs.get(signature);\n \t\t\tif (rawJavadoc != null) {\n \t\t\t\tfor (String line : rawJavadoc.split(\"\\r?\\n\")) {\n-\t\t\t\t\t// TODO call this via reflection\n-\t\t\t\t\tASTNode.printIndent(tab, output).append(line).append(\"\\n\");\n+\t\t\t\t\tprintIndent(tab, output).append(line).append(\"\\n\");\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -89,15 +88,24 @@ public static StringBuffer printMethod(AbstractMethodDeclaration methodDeclarati\n \t\t\tString rawJavadoc = docs.get(signature);\n \t\t\tif (rawJavadoc != null) {\n \t\t\t\tfor (String line : rawJavadoc.split(\"\\r?\\n\")) {\n-\t\t\t\t\t// TODO call this via reflection\n-\t\t\t\t\tASTNode.printIndent(tab, output).append(line).append(\"\\n\");\n+\t\t\t\t\tprintIndent(tab, output).append(line).append(\"\\n\");\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t// TODO call this via reflection\n \t\treturn methodDeclaration.print(tab, output);\n \t}\n \t\n+\tprivate static StringBuilder printIndent(int indent, StringBuilder output) {\n+\t\tfor (int i = indent; i > 0; i--) output.append(\"  \"); //$NON-NLS-1$\n+\t\treturn output;\n+\t}\n+\n+\tprivate static StringBuffer printIndent(int indent, StringBuffer output) {\n+\t\tfor (int i = indent; i > 0; i--) output.append(\"  \"); //$NON-NLS-1$\n+\t\treturn output;\n+\t}\n+\n \tprivate static class Signature {\n \t\tstatic final String getSignature(SourceMethod sourceMethod) {\n \t\t\tStringBuilder sb = new StringBuilder();",
      "parent_sha": "75116df7f560c4e13c10c2f6685813113c73fd1b"
    }
  },
  {
    "oid": "b9714eae8ced8d22a319a471331be3a522ebccce",
    "message": "[BUGFIX] Pretty major bug - due to a typo, ALL values for annotation methods were set to the value of the last annotation method. e.g in:\n\n@Foo(bar=10), ALL methods in the Foo annotation were presumed to be listed, and set to 10. This was obviously causing problems. Fixed it.",
    "date": "2009-06-27T01:57:51Z",
    "url": "https://github.com/projectlombok/lombok/commit/b9714eae8ced8d22a319a471331be3a522ebccce",
    "details": {
      "sha": "549de3c0f44e5d44d93b29fc30daa7c63c359d78",
      "filename": "src/lombok/eclipse/Eclipse.java",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/projectlombok/lombok/blob/b9714eae8ced8d22a319a471331be3a522ebccce/src%2Flombok%2Feclipse%2FEclipse.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/b9714eae8ced8d22a319a471331be3a522ebccce/src%2Flombok%2Feclipse%2FEclipse.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Flombok%2Feclipse%2FEclipse.java?ref=b9714eae8ced8d22a319a471331be3a522ebccce",
      "patch": "@@ -199,7 +199,7 @@ public static boolean annotationTypeMatches(Class<? extends java.lang.annotation\n \t\n \tpublic static <A extends java.lang.annotation.Annotation> AnnotationValues<A>\n \t\t\tcreateAnnotation(Class<A> type, final Node annotationNode) {\n-\t\tAnnotation annotation = (Annotation) annotationNode.get();\n+\t\tfinal Annotation annotation = (Annotation) annotationNode.get();\n \t\tMap<String, AnnotationValue> values = new HashMap<String, AnnotationValue>();\n \t\t\n \t\tfinal MemberValuePair[] pairs = annotation.memberValuePairs();\n@@ -213,9 +213,8 @@ public static boolean annotationTypeMatches(Class<? extends java.lang.annotation\n \t\t\t\n \t\t\tif ( pairs != null ) for ( MemberValuePair pair : pairs ) {\n \t\t\t\tchar[] n = pair.name;\n-\t\t\t\tString mName = n == null ? \"value\" : new String(name);\n-\t\t\t\tif ( !mName.equals(name) ) continue;\n-\t\t\t\tfullExpression = pair.value;\n+\t\t\t\tString mName = n == null ? \"value\" : new String(pair.name);\n+\t\t\t\tif ( mName.equals(name) ) fullExpression = pair.value;\n \t\t\t}\n \t\t\t\n \t\t\tif ( fullExpression != null ) {\n@@ -237,7 +236,9 @@ public static boolean annotationTypeMatches(Class<? extends java.lang.annotation\n \t\t\t\t@Override public void setError(String message, int valueIdx) {\n \t\t\t\t\tExpression ex;\n \t\t\t\t\tif ( valueIdx == -1 ) ex = fullExpr;\n-\t\t\t\t\telse ex = exprs[valueIdx];\n+\t\t\t\t\telse ex = exprs != null ? exprs[valueIdx] : null;\n+\t\t\t\t\t\n+\t\t\t\t\tif ( ex == null ) ex = annotation;\n \t\t\t\t\t\n \t\t\t\t\tint sourceStart = ex.sourceStart;\n \t\t\t\t\tint sourceEnd = ex.sourceEnd;",
      "parent_sha": "c4611d669db5ef38ba59540dc850cb59a5168348"
    }
  },
  {
    "oid": "073f325d714e4f9a3c14d723a08d0055ad02f580",
    "message": "ExtensionMethod didn't work for primitive types in eclipse..\nthis has been fixed",
    "date": "2012-06-24T19:12:05Z",
    "url": "https://github.com/projectlombok/lombok/commit/073f325d714e4f9a3c14d723a08d0055ad02f580",
    "details": {
      "sha": "ebfb1a0536afa4a74b176153513fbc40073d469d",
      "filename": "src/eclipseAgent/lombok/eclipse/agent/PatchExtensionMethod.java",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/projectlombok/lombok/blob/073f325d714e4f9a3c14d723a08d0055ad02f580/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchExtensionMethod.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/073f325d714e4f9a3c14d723a08d0055ad02f580/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchExtensionMethod.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchExtensionMethod.java?ref=073f325d714e4f9a3c14d723a08d0055ad02f580",
      "patch": "@@ -198,8 +198,6 @@ public static TypeBinding resolveType(TypeBinding resolvedType, MessageSend meth\n \t\t\t}\n \t\t}\n \t\t\n-\t\tif (methodCall.binding == null) return resolvedType;\n-\t\t\n \t\tfor (Extension extension : extensions) {\n \t\t\tif (!extension.suppressBaseMethods && !(methodCall.binding instanceof ProblemMethodBinding)) continue;\n \t\t\tfor (MethodBinding extensionMethod : extension.extensionMethods) {\n@@ -212,8 +210,9 @@ public static TypeBinding resolveType(TypeBinding resolvedType, MessageSend meth\n \t\t\t\targuments.add(methodCall.receiver);\n \t\t\t\tif (methodCall.arguments != null) arguments.addAll(Arrays.asList(methodCall.arguments));\n \t\t\t\tList<TypeBinding> argumentTypes = new ArrayList<TypeBinding>();\n-\t\t\t\targumentTypes.add(methodCall.receiver.resolvedType);\n-\t\t\t\tif (methodCall.binding.parameters != null) argumentTypes.addAll(Arrays.asList(methodCall.binding.parameters));\n+\t\t\t\tfor (Expression argument : arguments) {\n+\t\t\t\t\targumentTypes.add(argument.resolvedType);\n+\t\t\t\t}\n \t\t\t\tMethodBinding fixedBinding = scope.getMethod(extensionMethod.declaringClass, methodCall.selector, argumentTypes.toArray(new TypeBinding[0]), methodCall);\n \t\t\t\tif (fixedBinding instanceof ProblemMethodBinding) {\n \t\t\t\t\tif (fixedBinding.declaringClass != null) {",
      "parent_sha": "8fb4f79757547378c7d8c29759d04037bdd47c7e"
    }
  },
  {
    "oid": "dd0fded2bfbd5c318913209e93d74a2bb06f3d14",
    "message": "some more work on why delombok isn't tracking changes due to val alone.",
    "date": "2010-11-29T19:44:16Z",
    "url": "https://github.com/projectlombok/lombok/commit/dd0fded2bfbd5c318913209e93d74a2bb06f3d14",
    "details": {
      "sha": "63dedc49564253a9f585ffbbaef7eb667f7dd373",
      "filename": "src/core/lombok/javac/handlers/HandleVal.java",
      "status": "modified",
      "additions": 5,
      "deletions": 2,
      "changes": 7,
      "blob_url": "https://github.com/projectlombok/lombok/blob/dd0fded2bfbd5c318913209e93d74a2bb06f3d14/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FHandleVal.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/dd0fded2bfbd5c318913209e93d74a2bb06f3d14/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FHandleVal.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FHandleVal.java?ref=dd0fded2bfbd5c318913209e93d74a2bb06f3d14",
      "patch": "@@ -68,6 +68,8 @@ public class HandleVal extends JavacASTAdapter {\n \t\t\treturn;\n \t\t}\n \t\t\n+\t\tJavacHandlerUtil.deleteImportFromCompilationUnit(localNode, \"lombok.val\");\n+\t\t\n \t\tlocal.mods.flags |= Flags.FINAL;\n \t\tlocal.vartype = JavacResolution.createJavaLangObject(localNode.getTreeMaker(), localNode.getAst());\n \t\t\n@@ -102,9 +104,10 @@ public class HandleVal extends JavacASTAdapter {\n \t\t\t\t\n \t\t\t\tif (replacement != null) {\n \t\t\t\t\tlocal.vartype = replacement;\n-\t\t\t\t\tlocalNode.getAst().setChanged();\n+\t\t\t\t} else {\n+\t\t\t\t\tlocal.vartype = JavacResolution.createJavaLangObject(localNode.getTreeMaker(), localNode.getAst());;\n \t\t\t\t}\n-\t\t\t\telse local.vartype = JavacResolution.createJavaLangObject(localNode.getTreeMaker(), localNode.getAst());;\n+\t\t\t\tlocalNode.getAst().setChanged();\n \t\t\t} catch (JavacResolution.TypeNotConvertibleException e) {\n \t\t\t\tlocalNode.addError(\"Cannot use 'val' here because initializer expression does not have a representable type: \" + e.getMessage());\n \t\t\t\tlocal.vartype = JavacResolution.createJavaLangObject(localNode.getTreeMaker(), localNode.getAst());;",
      "parent_sha": "a8e92af7b7bea0240825666520e74cc6550a4750"
    }
  },
  {
    "oid": "ec24fe37ddc7b8230b45f62c11bb4a047e9824e8",
    "message": "post release version increase.",
    "date": "2010-07-25T01:21:01Z",
    "url": "https://github.com/projectlombok/lombok/commit/ec24fe37ddc7b8230b45f62c11bb4a047e9824e8",
    "details": {
      "sha": "e2c005d964486f8091becc97d45e0e27c394ab5b",
      "filename": "src/core/lombok/core/Version.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/projectlombok/lombok/blob/ec24fe37ddc7b8230b45f62c11bb4a047e9824e8/src%2Fcore%2Flombok%2Fcore%2FVersion.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/ec24fe37ddc7b8230b45f62c11bb4a047e9824e8/src%2Fcore%2Flombok%2Fcore%2FVersion.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fcore%2FVersion.java?ref=ec24fe37ddc7b8230b45f62c11bb4a047e9824e8",
      "patch": "@@ -26,7 +26,7 @@\n  */\n public class Version {\n \t// ** CAREFUL ** - this class must always compile with 0 dependencies (it must not refer to any other sources or libraries).\n-\tprivate static final String VERSION = \"0.9.3\";\n+\tprivate static final String VERSION = \"0.9.4-EDGE\";\n \tprivate static final String RELEASE_NAME = \"burrowing whale\";\n \t\n \tprivate Version() {",
      "parent_sha": "27a6e0432d36830e5ee09bcbeeb329706c36dc28"
    }
  },
  {
    "oid": "0befce2072c811fe6cc4177d43c581f00bc2d578",
    "message": "Very slight change to the helptext of lombok the executable",
    "date": "2012-07-10T21:56:26Z",
    "url": "https://github.com/projectlombok/lombok/commit/0befce2072c811fe6cc4177d43c581f00bc2d578",
    "details": {
      "sha": "d62fe3e4ea3b913b74ec1529f2b947005222cf81",
      "filename": "src/core/lombok/core/Main.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/projectlombok/lombok/blob/0befce2072c811fe6cc4177d43c581f00bc2d578/src%2Fcore%2Flombok%2Fcore%2FMain.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/0befce2072c811fe6cc4177d43c581f00bc2d578/src%2Fcore%2Flombok%2Fcore%2FMain.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fcore%2FMain.java?ref=0befce2072c811fe6cc4177d43c581f00bc2d578",
      "patch": "@@ -141,7 +141,7 @@ public void printHelp(String message, PrintStream out) {\n \t\t\tout.println(message);\n \t\t\tout.println(\"------------------------------\");\n \t\t}\n-\t\tout.println(\"projectlombok.org v\" + Version.getVersion());\n+\t\tout.println(\"projectlombok.org \" + Version.getFullVersion());\n \t\tout.println(\"Copyright (C) 2009-2012 The Project Lombok Authors.\");\n \t\tout.println(\"Run 'lombok license' to see the lombok license agreement.\");\n \t\tout.println();",
      "parent_sha": "3166a83dbc625d4b467fc4b5b8cfa304c1c33eac"
    }
  },
  {
    "oid": "2ebb040c812191381d62aa7f7c9d3e81ac6c1971",
    "message": "HandleData for eclipse now seems to work 100%. Also updated toString to use deepToString, and added @Override in case people have warnings for missing @Override annotations on.",
    "date": "2009-06-23T21:33:12Z",
    "url": "https://github.com/projectlombok/lombok/commit/2ebb040c812191381d62aa7f7c9d3e81ac6c1971",
    "details": {
      "sha": "0b3dbffdecddc634f46f36eea84782576ebf29e7",
      "filename": "src/lombok/eclipse/handlers/HandleData.java",
      "status": "modified",
      "additions": 164,
      "deletions": 18,
      "changes": 182,
      "blob_url": "https://github.com/projectlombok/lombok/blob/2ebb040c812191381d62aa7f7c9d3e81ac6c1971/src%2Flombok%2Feclipse%2Fhandlers%2FHandleData.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/2ebb040c812191381d62aa7f7c9d3e81ac6c1971/src%2Flombok%2Feclipse%2Fhandlers%2FHandleData.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Flombok%2Feclipse%2Fhandlers%2FHandleData.java?ref=2ebb040c812191381d62aa7f7c9d3e81ac6c1971",
      "patch": "@@ -40,13 +40,16 @@\n import org.eclipse.jdt.internal.compiler.ast.IfStatement;\n import org.eclipse.jdt.internal.compiler.ast.IntLiteral;\n import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;\n+import org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation;\n import org.eclipse.jdt.internal.compiler.ast.MessageSend;\n import org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;\n+import org.eclipse.jdt.internal.compiler.ast.NameReference;\n import org.eclipse.jdt.internal.compiler.ast.NullLiteral;\n import org.eclipse.jdt.internal.compiler.ast.OperatorIds;\n import org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;\n import org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;\n import org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;\n+import org.eclipse.jdt.internal.compiler.ast.Reference;\n import org.eclipse.jdt.internal.compiler.ast.ReturnStatement;\n import org.eclipse.jdt.internal.compiler.ast.SingleNameReference;\n import org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;\n@@ -119,7 +122,11 @@ public class HandleData implements EclipseAnnotationHandler<Data> {\n \t\t\tinjectMethod(typeNode, equals);\n \t\t}\n \t\t\n-\t\t//TODO generate hashCode, equals.\n+\t\tif ( methodExists(\"hashCode\", typeNode) == MethodExistsResult.NOT_EXISTS ) {\n+\t\t\tMethodDeclaration hashCode = createHashCode(typeNode, nodesForEquality, ast);\n+\t\t\tinjectMethod(typeNode, hashCode);\n+\t\t}\n+\t\t\n \t\treturn false;\n \t}\n \t\n@@ -135,13 +142,27 @@ private MethodDeclaration createToString(Node type, Collection<Node> fields, AST\n \t\tboolean first = true;\n \t\tExpression current = new StringLiteral(prefix, 0, 0, 0);\n \t\tfor ( Node field : fields ) {\n-\t\t\tchar[] fName = ((FieldDeclaration)field.get()).name;\n-\t\t\tif ( fName == null ) continue;\n+\t\t\tFieldDeclaration f = (FieldDeclaration)field.get();\n+\t\t\tif ( f.name == null || f.type == null ) continue;\n \t\t\tif ( !first ) {\n \t\t\t\tcurrent = new BinaryExpression(current, new StringLiteral(infix, 0, 0, 0), PLUS);\n \t\t\t}\n \t\t\telse first = false;\n-\t\t\tcurrent = new BinaryExpression(current, new SingleNameReference(fName, p), PLUS);\n+\t\t\t\n+\t\t\tExpression ex;\n+\t\t\tif ( f.type.dimensions() > 0 ) {\n+\t\t\t\tMessageSend arrayToString = new MessageSend();\n+\t\t\t\tarrayToString.receiver = generateQualifiedNameRef(TypeConstants.JAVA, TypeConstants.UTIL, \"Arrays\".toCharArray());\n+\t\t\t\tarrayToString.arguments = new Expression[] { new SingleNameReference(f.name, p) };\n+\t\t\t\tif ( f.type.dimensions() > 1 || !BUILT_IN_TYPES.contains(new String(f.type.getLastToken())) ) {\n+\t\t\t\t\tarrayToString.selector = \"deepToString\".toCharArray();\n+\t\t\t\t} else {\n+\t\t\t\t\tarrayToString.selector = \"toString\".toCharArray();\n+\t\t\t\t}\n+\t\t\t\tex = arrayToString;\n+\t\t\t} else ex = new SingleNameReference(f.name, p);\n+\t\t\t\n+\t\t\tcurrent = new BinaryExpression(current, ex, PLUS);\n \t\t}\n \t\tcurrent = new BinaryExpression(current, new StringLiteral(suffix, 0, 0, 0), PLUS);\n \t\t\n@@ -150,7 +171,9 @@ private MethodDeclaration createToString(Node type, Collection<Node> fields, AST\n \t\tMethodDeclaration method = new MethodDeclaration(((CompilationUnitDeclaration) type.top().get()).compilationResult);\n \t\tmethod.modifiers = PKG.toModifier(AccessLevel.PUBLIC);\n \t\tmethod.returnType = new QualifiedTypeReference(TypeConstants.JAVA_LANG_STRING, new long[] {0, 0, 0});\n-\t\tmethod.annotations = null;\n+\t\tmethod.annotations = new Annotation[] {\n+\t\t\t\tnew MarkerAnnotation(new QualifiedTypeReference(TypeConstants.JAVA_LANG_OVERRIDE, new long[] { 0, 0, 0}), 0)\n+\t\t};\n \t\tmethod.arguments = null;\n \t\tmethod.selector = \"toString\".toCharArray();\n \t\tmethod.thrownExceptions = null;\n@@ -243,13 +266,14 @@ private MethodDeclaration createStaticConstructor(String name, Node type, Collec\n \t\t\t\"byte\", \"short\", \"int\", \"long\", \"char\", \"boolean\", \"double\", \"float\")));\n \t\n \tprivate MethodDeclaration createEquals(Node type, Collection<Node> fields, ASTNode pos) {\n-\t\tlong p = (long)pos.sourceStart << 32 | pos.sourceEnd;\n \t\tMethodDeclaration method = new MethodDeclaration(\n \t\t\t\t((CompilationUnitDeclaration) type.top().get()).compilationResult);\n \t\t\n \t\tmethod.modifiers = PKG.toModifier(AccessLevel.PUBLIC);\n \t\tmethod.returnType = TypeReference.baseTypeReference(TypeIds.T_boolean, 0);\n-\t\tmethod.annotations = null;\n+\t\tmethod.annotations = new Annotation[] {\n+\t\t\t\tnew MarkerAnnotation(new QualifiedTypeReference(TypeConstants.JAVA_LANG_OVERRIDE, new long[] { 0, 0, 0}), 0)\n+\t\t};\n \t\tmethod.selector = \"equals\".toCharArray();\n \t\tmethod.thrownExceptions = null;\n \t\tmethod.typeParameters = null;\n@@ -390,23 +414,145 @@ private IfStatement generateCompareFloatOrDouble(char[] otherN, char[] floatOrDo\n \t\treturn new IfStatement(ifFloatCompareIsNot0, returnFalse, 0, 0);\n \t}\n \t\n-\tprivate QualifiedNameReference generateQualifiedNameRef(char[]... varNames) {\n-\t\treturn new QualifiedNameReference(varNames, new long[varNames.length], 0, 0);\n+\tprivate Reference generateFieldReference(char[] fieldName) {\n+\t\tFieldReference thisX = new FieldReference((\"this.\" + new String(fieldName)).toCharArray(), 0);\n+\t\tthisX.receiver = new ThisReference(0, 0);\n+\t\tthisX.token = fieldName;\n+\t\treturn thisX;\n+\t}\n+\t\n+\tprivate NameReference generateQualifiedNameRef(char[]... varNames) {\n+\t\tif ( varNames.length > 1 )\n+\t\t\treturn new QualifiedNameReference(varNames, new long[varNames.length], 0, 0);\n+\t\telse return new SingleNameReference(varNames[0], 0);\n \t}\n \t\n \tprivate MethodDeclaration createHashCode(Node type, Collection<Node> fields, ASTNode pos) {\n-\t\t//booleans: conditionalexpression that bounces between 1231 and 1237.\n-\t\t//longs: (int) (lng ^ (lng >>> 32));\n-\t\t//doubles and floats: Double.doubleToLongBits, then as long.\n+\t\tMethodDeclaration method = new MethodDeclaration(\n+\t\t\t\t((CompilationUnitDeclaration) type.top().get()).compilationResult);\n+\t\t\n+\t\tmethod.modifiers = PKG.toModifier(AccessLevel.PUBLIC);\n+\t\tmethod.returnType = TypeReference.baseTypeReference(TypeIds.T_int, 0);\n+\t\tmethod.annotations = new Annotation[] {\n+\t\t\t\tnew MarkerAnnotation(new QualifiedTypeReference(TypeConstants.JAVA_LANG_OVERRIDE, new long[] { 0, 0, 0}), 0)\n+\t\t};\n+\t\tmethod.selector = \"hashCode\".toCharArray();\n+\t\tmethod.thrownExceptions = null;\n+\t\tmethod.typeParameters = null;\n+\t\tmethod.bits |= Eclipse.ECLIPSE_DO_NOT_TOUCH_FLAG;\n+\t\tmethod.bodyStart = method.declarationSourceStart = method.sourceStart = pos.sourceStart;\n+\t\tmethod.bodyEnd = method.declarationSourceEnd = method.sourceEnd = pos.sourceEnd;\n+\t\tmethod.arguments = null;\n+\t\t\n+\t\tList<Statement> statements = new ArrayList<Statement>();\n+\t\tList<Expression> intoResult = new ArrayList<Expression>();\n+\t\t\n+\t\tfinal char[] PRIME = \"PRIME\".toCharArray();\n+\t\tfinal char[] RESULT = \"result\".toCharArray();\n \t\t\n-\t\t//local final var PRIME = IntLiteral(primeNumber)\n-\t\t//local final var RESULT = IntLiteral(1)\n+\t\t/* final int PRIME = 31; */ {\n+\t\t\tLocalDeclaration primeDecl = new LocalDeclaration(PRIME, 0 ,0);\n+\t\t\tprimeDecl.modifiers = Modifier.FINAL;\n+\t\t\tprimeDecl.type = TypeReference.baseTypeReference(TypeIds.T_int, 0);\n+\t\t\tprimeDecl.initialization = new IntLiteral(\"31\".toCharArray(), 0, 0);\n+\t\t\tstatements.add(primeDecl);\n+\t\t}\n \t\t\n-\t\t//    Assignment(\"RESULT\", BinaryExpression(\"+\", BinaryExpression(\"*\", \"PRIME\", \"RESULT\"), \"name\")\n+\t\t/* int result = 1; */ {\n+\t\t\tLocalDeclaration resultDecl = new LocalDeclaration(RESULT, 0, 0);\n+\t\t\tresultDecl.initialization = new IntLiteral(\"1\".toCharArray(), 0, 0);\n+\t\t\tresultDecl.type = TypeReference.baseTypeReference(TypeIds.T_int, 0);\n+\t\t\tstatements.add(resultDecl);\n+\t\t}\n \t\t\n-\t\t//    add = ConditionalExpression(EqualExpression(\"name\", NullLiteral), IntLiteral(0), MessageSend(\"name\", \"hashCode()\"))\n-\t\t//    Assignment(\"RESULT\", BinaryExpression(\"+\", BinaryExpression(\"*\", \"PRIME\", \"RESULT\"), add);\n+\t\tint tempCounter = 0;\n+\t\tfor ( Node field : fields ) {\n+\t\t\tFieldDeclaration f = (FieldDeclaration) field.get();\n+\t\t\tchar[] token = f.type.getLastToken();\n+\t\t\tif ( f.type.dimensions() == 0 && token != null ) {\n+\t\t\t\tif ( Arrays.equals(TypeConstants.FLOAT, token) ) {\n+\t\t\t\t\t/* Float.floatToIntBits(fieldName) */\n+\t\t\t\t\tMessageSend floatToIntBits = new MessageSend();\n+\t\t\t\t\tfloatToIntBits.receiver = generateQualifiedNameRef(TypeConstants.JAVA_LANG_FLOAT);\n+\t\t\t\t\tfloatToIntBits.selector = \"floatToIntBits\".toCharArray();\n+\t\t\t\t\tfloatToIntBits.arguments = new Expression[] { generateFieldReference(f.name) };\n+\t\t\t\t\tintoResult.add(floatToIntBits);\n+\t\t\t\t} else if ( Arrays.equals(TypeConstants.DOUBLE, token) ) {\n+\t\t\t\t\t/* longToIntForHashCode(Double.doubleToLongBits(fieldName)) */\n+\t\t\t\t\tMessageSend doubleToLongBits = new MessageSend();\n+\t\t\t\t\tdoubleToLongBits.receiver = generateQualifiedNameRef(TypeConstants.JAVA_LANG_DOUBLE);\n+\t\t\t\t\tdoubleToLongBits.selector = \"doubleToLongBits\".toCharArray();\n+\t\t\t\t\tdoubleToLongBits.arguments = new Expression[] { generateFieldReference(f.name) };\n+\t\t\t\t\tfinal char[] tempName = (\"temp\" + ++tempCounter).toCharArray();\n+\t\t\t\t\tLocalDeclaration tempVar = new LocalDeclaration(tempName, 0, 0);\n+\t\t\t\t\ttempVar.initialization = doubleToLongBits;\n+\t\t\t\t\ttempVar.type = TypeReference.baseTypeReference(TypeIds.T_long, 0);\n+\t\t\t\t\ttempVar.modifiers = Modifier.FINAL;\n+\t\t\t\t\tstatements.add(tempVar);\n+\t\t\t\t\tintoResult.add(longToIntForHashCode(\n+\t\t\t\t\t\t\tnew SingleNameReference(tempName, 0), new SingleNameReference(tempName, 0)));\n+\t\t\t\t} else if ( Arrays.equals(TypeConstants.BOOLEAN, token) ) {\n+\t\t\t\t\t/* booleanField ? 1231 : 1237 */\n+\t\t\t\t\tintoResult.add(new ConditionalExpression(\n+\t\t\t\t\t\t\tgenerateFieldReference(f.name),\n+\t\t\t\t\t\t\tnew IntLiteral(\"1231\".toCharArray(), 0, 0),\n+\t\t\t\t\t\t\tnew IntLiteral(\"1237\".toCharArray(), 0 ,0)));\n+\t\t\t\t} else if ( Arrays.equals(TypeConstants.LONG, token) ) {\n+\t\t\t\t\tintoResult.add(longToIntForHashCode(generateFieldReference(f.name), generateFieldReference(f.name)));\n+\t\t\t\t} else if ( BUILT_IN_TYPES.contains(new String(token)) ) {\n+\t\t\t\t\tintoResult.add(generateFieldReference(f.name));\n+\t\t\t\t} else /* objects */ {\n+\t\t\t\t\t/* this.fieldName == null ? 0 : this.fieldName.hashCode() */\n+\t\t\t\t\tMessageSend hashCodeCall = new MessageSend();\n+\t\t\t\t\thashCodeCall.receiver = generateFieldReference(f.name);\n+\t\t\t\t\thashCodeCall.selector = \"hashCode\".toCharArray();\n+\t\t\t\t\tEqualExpression objIsNull = new EqualExpression(\n+\t\t\t\t\t\t\tgenerateFieldReference(f.name),\n+\t\t\t\t\t\t\tnew NullLiteral(0, 0),\n+\t\t\t\t\t\t\tOperatorIds.EQUAL_EQUAL);\n+\t\t\t\t\tConditionalExpression nullOrHashCode = new ConditionalExpression(\n+\t\t\t\t\t\t\tobjIsNull,\n+\t\t\t\t\t\t\tnew IntLiteral(\"0\".toCharArray(), 0, 0),\n+\t\t\t\t\t\t\thashCodeCall);\n+\t\t\t\t\tintoResult.add(nullOrHashCode);\n+\t\t\t\t}\n+\t\t\t} else if ( f.type.dimensions() > 0 && token != null ) {\n+\t\t\t\t/* Arrays.deepHashCode(array)  //just hashCode for simple arrays */\n+\t\t\t\tMessageSend arraysHashCodeCall = new MessageSend();\n+\t\t\t\tarraysHashCodeCall.receiver = generateQualifiedNameRef(TypeConstants.JAVA, TypeConstants.UTIL, \"Arrays\".toCharArray());\n+\t\t\t\tif ( f.type.dimensions() > 1 || !BUILT_IN_TYPES.contains(new String(token)) ) {\n+\t\t\t\t\tarraysHashCodeCall.selector = \"deepHashCode\".toCharArray();\n+\t\t\t\t} else {\n+\t\t\t\t\tarraysHashCodeCall.selector = \"hashCode\".toCharArray();\n+\t\t\t\t}\n+\t\t\t\tarraysHashCodeCall.arguments = new Expression[] { generateFieldReference(f.name) };\n+\t\t\t\tintoResult.add(arraysHashCodeCall);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\t/* fold each intoResult entry into:\n+\t\t   result = result * PRIME + (item); */ {\n+\t\t\tfor ( Expression ex : intoResult ) {\n+\t\t\t\tBinaryExpression multiplyByPrime = new BinaryExpression(new SingleNameReference(RESULT, 0),\n+\t\t\t\t\t\tnew SingleNameReference(PRIME, 0), OperatorIds.MULTIPLY);\n+\t\t\t\tBinaryExpression addItem = new BinaryExpression(multiplyByPrime, ex, OperatorIds.PLUS);\n+\t\t\t\tstatements.add(new Assignment(new SingleNameReference(RESULT, 0), addItem, 0));\n+\t\t\t}\n+\t\t}\n \t\t\n-\t\treturn null;\n+\t\t/* return result; */ {\n+\t\t\tstatements.add(new ReturnStatement(new SingleNameReference(RESULT, 0), 0, 0));\n+\t\t}\n+\t\tmethod.statements = statements.toArray(new Statement[statements.size()]);\n+\t\treturn method;\n+\t}\n+\t\n+\t/** Give 2 clones! */\n+\tprivate Expression longToIntForHashCode(Reference ref1, Reference ref2) {\n+\t\tBinaryExpression higherBits = new BinaryExpression(\n+\t\t\t\tref1, new IntLiteral(\"32\".toCharArray(), 0, 0),\n+\t\t\t\tOperatorIds.UNSIGNED_RIGHT_SHIFT);\n+\t\tBinaryExpression xorParts = new BinaryExpression(ref2, higherBits, OperatorIds.XOR);\n+\t\treturn new CastExpression(xorParts, TypeReference.baseTypeReference(TypeIds.T_int, 0));\n \t}\n }",
      "parent_sha": "6210df32d073d0cd07682271e03fa0634de2adfa"
    }
  },
  {
    "oid": "8ba6d4b0ea661fd6c701fed56212ecc9c4acabb2",
    "message": "Add more characters not to escape on Windows. Fixes #2435",
    "date": "2020-05-14T19:28:19Z",
    "url": "https://github.com/projectlombok/lombok/commit/8ba6d4b0ea661fd6c701fed56212ecc9c4acabb2",
    "details": {
      "sha": "6b9a94c67ddf4934fb77d638d72617353167bc06",
      "filename": "src/installer/lombok/installer/IdeLocation.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/projectlombok/lombok/blob/8ba6d4b0ea661fd6c701fed56212ecc9c4acabb2/src%2Finstaller%2Flombok%2Finstaller%2FIdeLocation.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/8ba6d4b0ea661fd6c701fed56212ecc9c4acabb2/src%2Finstaller%2Flombok%2Finstaller%2FIdeLocation.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Finstaller%2Flombok%2Finstaller%2FIdeLocation.java?ref=8ba6d4b0ea661fd6c701fed56212ecc9c4acabb2",
      "patch": "@@ -66,7 +66,7 @@ public static String canonical(File p) {\n \t}\n \t\n \tprivate static final String LEGAL_PATH_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-_/\";\n-\tprivate static final String LEGAL_PATH_CHARS_WINDOWS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-_/:\\\\ \";\n+\tprivate static final String LEGAL_PATH_CHARS_WINDOWS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.,/;'[]{}!@#$^&()-_+= :\\\\\";\n \tpublic static String escapePath(String path) {\n \t\tStringBuilder out = new StringBuilder();\n \t\tString legalChars = OsUtils.getOS() == OsUtils.OS.UNIX ? LEGAL_PATH_CHARS : LEGAL_PATH_CHARS_WINDOWS; ",
      "parent_sha": "d54b360af9bdd66885badb80007d6839ea9d48f8"
    }
  },
  {
    "oid": "063011105913f09228812980717de96e42b6c0c1",
    "message": "Javadoc fixes.",
    "date": "2009-11-02T00:07:43Z",
    "url": "https://github.com/projectlombok/lombok/commit/063011105913f09228812980717de96e42b6c0c1",
    "details": {
      "sha": "34d8b8491c5f5f00092d1c62e5fc71f7e7534f67",
      "filename": "src/lombok/javac/handlers/JavacHandlerUtil.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/projectlombok/lombok/blob/063011105913f09228812980717de96e42b6c0c1/src%2Flombok%2Fjavac%2Fhandlers%2FJavacHandlerUtil.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/063011105913f09228812980717de96e42b6c0c1/src%2Flombok%2Fjavac%2Fhandlers%2FJavacHandlerUtil.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Flombok%2Fjavac%2Fhandlers%2FJavacHandlerUtil.java?ref=063011105913f09228812980717de96e42b6c0c1",
      "patch": "@@ -59,7 +59,7 @@ public static boolean isPrimitive(JCExpression ref) {\n \t\n \t/**\n \t * Translates the given field into all possible getter names.\n-\t * Convenient wrapper around {@link TransformationsUtil#toAllGetterNames(String, boolean)}.\n+\t * Convenient wrapper around {@link TransformationsUtil#toAllGetterNames(CharSequence, boolean)}.\n \t */\n \tpublic static java.util.List<String> toAllGetterNames(JCVariableDecl field) {\n \t\tCharSequence fieldName = field.name;\n@@ -72,7 +72,7 @@ public static java.util.List<String> toAllGetterNames(JCVariableDecl field) {\n \t/**\n \t * @return the likely getter name for the stated field. (e.g. private boolean foo; to isFoo).\n \t * \n-\t * Convenient wrapper around {@link TransformationsUtil#toGetterName(String, boolean)}.\n+\t * Convenient wrapper around {@link TransformationsUtil#toGetterName(CharSequence, boolean)}.\n \t */\n \tpublic static String toGetterName(JCVariableDecl field) {\n \t\tCharSequence fieldName = field.name;\n@@ -85,7 +85,7 @@ public static String toGetterName(JCVariableDecl field) {\n \t/**\n \t * @return the likely setter name for the stated field. (e.g. private boolean foo; to setFoo).\n \t * \n-\t * Convenient wrapper around {@link TransformationsUtil.toSetterName(String)}.\n+\t * Convenient wrapper around {@link TransformationsUtil#toSetterName(CharSequence)}.\n \t */\n \tpublic static String toSetterName(JCVariableDecl field) {\n \t\tCharSequence fieldName = field.name;",
      "parent_sha": "1b006eca42fe622888d0372abcff5557b7838579"
    }
  },
  {
    "oid": "a7e3d5070eb0116e5b80e4f8a96d176a2127fc19",
    "message": "fixed code style of DanskerDave's contribution, and one trivial speed improvement on some bit wrangling.",
    "date": "2015-05-26T20:43:52Z",
    "url": "https://github.com/projectlombok/lombok/commit/a7e3d5070eb0116e5b80e4f8a96d176a2127fc19",
    "details": {
      "sha": "37c479eefa6658465e0429e11b81c9e3df50fbea",
      "filename": "src/launch/lombok/launch/ShadowClassLoader.java",
      "status": "modified",
      "additions": 46,
      "deletions": 61,
      "changes": 107,
      "blob_url": "https://github.com/projectlombok/lombok/blob/a7e3d5070eb0116e5b80e4f8a96d176a2127fc19/src%2Flaunch%2Flombok%2Flaunch%2FShadowClassLoader.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/a7e3d5070eb0116e5b80e4f8a96d176a2127fc19/src%2Flaunch%2Flombok%2Flaunch%2FShadowClassLoader.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Flaunch%2Flombok%2Flaunch%2FShadowClassLoader.java?ref=a7e3d5070eb0116e5b80e4f8a96d176a2127fc19",
      "patch": "@@ -145,8 +145,8 @@ class ShadowClassLoader extends ClassLoader {\n \t\t}\n \t}\n \n-\tprivate        final Map<String,     Object > mapJarPathToTracker     = new HashMap    <String,     Object >();\n-\tprivate static final Map<Object,     String > mapTrackerToJarPath     = new WeakHashMap<Object,     String >();\n+\tprivate final Map<String, Object> mapJarPathToTracker = new HashMap<String, Object>();\n+\tprivate static final Map<Object, String> mapTrackerToJarPath = new WeakHashMap<Object, String>();\n \tprivate static final Map<Object, Set<String>> mapTrackerToJarContents = new WeakHashMap<Object, Set<String>>();\n \n \t/**\n@@ -159,107 +159,88 @@ private Set<String> getOrMakeJarListing(final String absolutePathToJar) {\n \t\t\t/*\n \t\t\t * 1) Check our private instance JarPath-to-Tracker Mappings:\n \t\t\t */\n-\t\t\tfinal Object ourTracker = mapJarPathToTracker.get(absolutePathToJar);\n+\t\t\tObject ourTracker = mapJarPathToTracker.get(absolutePathToJar);\n \t\t\tif (ourTracker != null) {\n \t\t\t\t/*\n \t\t\t\t * Yes, we are already tracking this Jar. Just return its contents...\n \t\t\t\t */\n \t\t\t\treturn mapTrackerToJarContents.get(ourTracker);\n \t\t\t}\n-\n+\t\t\t\n \t\t\t/*\n \t\t\t * 2) Not tracked by us as yet. Check statically whether others have tracked this JarPath:\n \t\t\t */\n-\t\t\tfor (final Entry<Object, String> entry : mapTrackerToJarPath.entrySet()) {\n+\t\t\tfor (Entry<Object, String> entry : mapTrackerToJarPath.entrySet()) {\n \t\t\t\tif (entry.getValue().equals(absolutePathToJar)) {\n \t\t\t\t\t/*\n-\t\t\t\t\t * Yes, 3rd party is tracking this Jar. We must track too, then return its contents...\n+\t\t\t\t\t * Yes, 3rd party is tracking this jar. We must track too, then return its contents.\n \t\t\t\t\t */\n-\t\t\t\t\tfinal  Object otherTracker = entry.getKey();\n-\t\t\t\t\t/**/   mapJarPathToTracker    .put(absolutePathToJar, otherTracker);\n-\t\t\t\t\treturn mapTrackerToJarContents.get(                   otherTracker);\n+\t\t\t\t\tObject otherTracker = entry.getKey();\n+\t\t\t\t\tmapJarPathToTracker.put(absolutePathToJar, otherTracker);\n+\t\t\t\t\treturn mapTrackerToJarContents.get(otherTracker);\n \t\t\t\t}\n \t\t\t}\n-\n+\t\t\t\n \t\t\t/*\n \t\t\t * 3) Not tracked by anyone so far. Build, publish, track & return Jar contents...\n \t\t\t */\n-\t\t\tfinal Object      newTracker = new Object();\n-\t\t\tfinal Set<String> jarMembers = getJarMemberSet(absolutePathToJar);\n-\n+\t\t\tObject newTracker = new Object();\n+\t\t\tSet<String> jarMembers = getJarMemberSet(absolutePathToJar);\n+\t\t\t\n \t\t\tmapTrackerToJarContents.put(newTracker, jarMembers);\n-\t\t\tmapTrackerToJarPath    .put(newTracker, absolutePathToJar);\n-\t\t\tmapJarPathToTracker    .put(absolutePathToJar, newTracker);\n-\n-\t\t\treturn            jarMembers;\n+\t\t\tmapTrackerToJarPath.put(newTracker, absolutePathToJar);\n+\t\t\tmapJarPathToTracker.put(absolutePathToJar, newTracker);\n+\t\t\t\n+\t\t\treturn jarMembers;\n \t\t}\n \t}\n-\n+\t\n \t/**\n-\t * Return a\n-\t * {@link Set}\n-\t * of members in the Jar identified by\n-\t * {@code absolutePathToJar}.\n+\t * Return a {@link Set} of members in the Jar identified by {@code absolutePathToJar}.\n \t * \n-\t * @param  absolutePathToJar\n+\t * @param absolutePathToJar Cache key\n \t * @return a Set with the Jar member-names\n \t */\n-\tprivate   Set<String> getJarMemberSet(final String absolutePathToJar) {\n+\tprivate Set<String> getJarMemberSet(String absolutePathToJar) {\n \t\t/*\n \t\t * Note:\n-\t\t * Our implementation returns a HashSet. A HashSet wraps an array of \"Buckets\".\n-\t\t * Each key is mapped on to a Bucket using the keys hash.\n-\t\t * Each Bucket, in turn, contains a linked list of entries for that hash value.\n-\t\t * Buckets with no entries mapped to them (an undesirable situation) are null.\n-\t\t * (HashSet rounds the desired capacity up to the nearest power of 2 !!)\n-\t\t * \n-\t\t * 1) we do NOT want the capacity of the HashSet to exceed the number of Jar members!\n-\t\t * 2) to save space, we want to keep the number of null Buckets to a minimum.\n-\t\t * 3) to save CPU, we don't want the number of entries per Bucket to get too large.\n-\t\t * 4) loadFactor should be just large enough so that the HashSet will never be re-hashed.\n-\t\t * \n-\t\t * The values of initialCapacity & loadFactor used below satisfy the stated requirements.\n-\t\t * At uniform distribution, the number of entries/Bucket would NEVER exceed 2**shiftBits\n-\t\t * & (with the exception of tiny Jars) would ALWAYS be greater than 2**(shiftBits - 1).\n-\t\t * \n-\t\t * e.g. a value of 3 for shiftBits generates between 5 & 8 entries/Bucket.\n-\t\t * (the above discussion assumes uniform distribution. Using hash-keys this will vary slightly)\n+\t\t * Our implementation returns a HashSet. initialCapacity and loadFactor are carefully tweaked for speed and RAM optimization purposes.\n \t\t * \n \t\t * Benchmark:\n \t\t * The HashSet implementation is about 10% slower to build (only happens once) than the ArrayList.\n \t\t * The HashSet with shiftBits = 1 was about 33 times(!) faster than the ArrayList for retrievals.\n \t\t */\n \t\ttry {\n-\t\t\tfinal int     shiftBits = 1;  //  (fast, but big)  0 <= shiftBits <= 5, say  (slower & compact)\n-\t\t\tfinal JarFile jar       = new JarFile(absolutePathToJar);\n+\t\t\tint shiftBits = 1;  //  (fast, but big)  0 <= shiftBits <= 5, say  (slower & compact)\n+\t\t\tJarFile jar = new JarFile(absolutePathToJar);\n+\t\t\t\n \t\t\t/*\n \t\t\t * Find the first power of 2 >= JarSize (as calculated in HashSet constructor)\n \t\t\t */\n-\t        int      jarSizePower2 =   1;\n-\t        while   (jarSizePower2 <   jar.size()) {\n-\t        \t/**/ jarSizePower2 <<= 1;\n-\t        }\n-\t\t\tfinal Set<String> jarMembers = new HashSet<String>(jarSizePower2 >> shiftBits,  1 << shiftBits);\n+\t\t\tint jarSizePower2 = Integer.highestOneBit(jar.size());\n+\t\t\tif (jarSizePower2 != jar.size()) jarSizePower2 <<= 1;\n+\t\t\tif (jarSizePower2 == 0) jarSizePower2 = 1;\n+\t\t\t\n+\t\t\tSet<String> jarMembers = new HashSet<String>(jarSizePower2 >> shiftBits,  1 << shiftBits);\n \t\t\ttry {\n-\t\t\t\tfinal Enumeration<JarEntry> entries = jar.entries();\n+\t\t\t\tEnumeration<JarEntry> entries = jar.entries();\n \t\t\t\twhile (entries.hasMoreElements()) {\n-\t\t\t\t\tfinal JarEntry jarEntry = entries.nextElement();\n-\t\t\t\t\tif (jarEntry.isDirectory()) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n+\t\t\t\t\tJarEntry jarEntry = entries.nextElement();\n+\t\t\t\t\tif (jarEntry.isDirectory()) continue;\n \t\t\t\t\tjarMembers.add(jarEntry.getName());\n \t\t\t\t}\n-\t\t\t} catch (final Exception ignore) {\n+\t\t\t} catch (Exception ignore) {\n+\t\t\t\t// ignored; if the jar can't be read, treating it as if the jar contains no classes is just what we want.\n \t\t\t} finally {\n \t\t\t\tjar.close();\n \t\t\t}\n \t\t\treturn jarMembers;\n \t\t}\n-\t\tcatch (final Exception newJarFileException) {\n+\t\tcatch (Exception newJarFileException) {\n \t\t\treturn Collections.emptySet();\n \t\t}\n \t}\n-\n+\t\n \t/**\n \t * Looks up {@code altName} in {@code location}, and if that isn't found, looks up {@code name}; {@code altName} can be null in which case it is skipped.\n \t */\n@@ -288,21 +269,25 @@ private URL getResourceFromLocation(String name, String altName, File location)\n \t\t\t\tabsoluteFile = location.getAbsoluteFile();\n \t\t\t}\n \t\t}\n-\t\tfinal Set<String> jarContents = getOrMakeJarListing(absoluteFile.getAbsolutePath());\n-\n-\t\tfinal String      absoluteUri = absoluteFile.toURI().toString();\n+\t\tSet<String> jarContents = getOrMakeJarListing(absoluteFile.getAbsolutePath());\n+\t\t\n+\t\tString absoluteUri = absoluteFile.toURI().toString();\n \t\t\n \t\ttry {\n \t\t\tif (jarContents.contains(altName)) {\n \t\t\t\treturn new URI(\"jar:\" + absoluteUri + \"!/\" + altName).toURL();\n \t\t\t}\n-\t\t} catch (Exception e) {}\n+\t\t} catch (Exception ignore) {\n+\t\t\t// intentional fallthrough\n+\t\t}\n \t\t\n \t\ttry {\n \t\t\tif (jarContents.contains(name)) {\n \t\t\t\treturn new URI(\"jar:\" + absoluteUri + \"!/\" + name).toURL();\n \t\t\t}\n-\t\t} catch(Exception e) {}\n+\t\t} catch(Exception ignore) {\n+\t\t\t// intentional fallthrough\n+\t\t}\n \t\t\n \t\treturn null;\n \t}",
      "parent_sha": "c8eddeab55086d545137a2ccfa5aff6353fc62ee"
    }
  },
  {
    "oid": "98f08c245528ffd72c341d43ace131a4691927c0",
    "message": "revert initial fix-trial",
    "date": "2018-01-07T18:34:02Z",
    "url": "https://github.com/projectlombok/lombok/commit/98f08c245528ffd72c341d43ace131a4691927c0",
    "details": {
      "sha": "64838e3a156c7863fde0394bc1c6df53d53afb3f",
      "filename": "src/eclipseAgent/lombok/eclipse/agent/EclipsePatcher.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/projectlombok/lombok/blob/98f08c245528ffd72c341d43ace131a4691927c0/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FEclipsePatcher.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/98f08c245528ffd72c341d43ace131a4691927c0/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FEclipsePatcher.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FEclipsePatcher.java?ref=98f08c245528ffd72c341d43ace131a4691927c0",
      "patch": "@@ -216,8 +216,8 @@ private static void patchSyntaxAndOccurrencesHighlighting(ScriptManager sm) {\n \t\n \tprivate static void patchDisableLombokForCodeFormatterAndCleanup(ScriptManager sm) {\n \t\tsm.addScript(ScriptBuilder.setSymbolDuringMethodCall()\n-\t\t\t\t.target(new MethodTarget(\"org.eclipse.jdt.internal.formatter.DefaultCodeFormatter\", \"formatCompilationUnit\"))\n-\t\t\t\t//.target(new MethodTarget(\"org.eclipse.jdt.internal.formatter.DefaultCodeFormatter\", \"parseSourceCode\"))\n+\t\t\t\t//.target(new MethodTarget(\"org.eclipse.jdt.internal.formatter.DefaultCodeFormatter\", \"formatCompilationUnit\"))\n+\t\t\t\t.target(new MethodTarget(\"org.eclipse.jdt.internal.formatter.DefaultCodeFormatter\", \"parseSourceCode\"))\n \t\t\t\t.callToWrap(new Hook(\"org.eclipse.jdt.internal.core.util.CodeSnippetParsingUtil\", \"parseCompilationUnit\", \"org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration\", \"char[]\", \"java.util.Map\", \"boolean\"))\n \t\t\t\t.symbol(\"lombok.disable\")\n \t\t\t\t.build());",
      "parent_sha": "f8a6ba556ca21eb83bda6117d25b860398505714"
    }
  },
  {
    "oid": "89586dd793c61f047afda3e34a92487815cc04e3",
    "message": "Bugfix: Annotations on types were being ignored if the type had no members in it, in javac only.",
    "date": "2010-07-17T04:56:37Z",
    "url": "https://github.com/projectlombok/lombok/commit/89586dd793c61f047afda3e34a92487815cc04e3",
    "details": {
      "sha": "1a4703865d8e9def77b114266e6c2b6c803f955e",
      "filename": "src/core/lombok/javac/JavacAST.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/projectlombok/lombok/blob/89586dd793c61f047afda3e34a92487815cc04e3/src%2Fcore%2Flombok%2Fjavac%2FJavacAST.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/89586dd793c61f047afda3e34a92487815cc04e3/src%2Fcore%2Flombok%2Fjavac%2FJavacAST.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fjavac%2FJavacAST.java?ref=89586dd793c61f047afda3e34a92487815cc04e3",
      "patch": "@@ -176,8 +176,8 @@ private JavacNode buildType(JCClassDecl type) {\n \t\tif (setAndGetAsHandled(type)) return null;\n \t\tList<JavacNode> childNodes = new ArrayList<JavacNode>();\n \t\t\n+\t\tfor (JCAnnotation annotation : type.mods.annotations) addIfNotNull(childNodes, buildAnnotation(annotation));\n \t\tfor (JCTree def : type.defs) {\n-\t\t\tfor (JCAnnotation annotation : type.mods.annotations) addIfNotNull(childNodes, buildAnnotation(annotation));\n \t\t\t/* A def can be:\n \t\t\t *   JCClassDecl for inner types\n \t\t\t *   JCMethodDecl for constructors and methods",
      "parent_sha": "32a23d77866093c5ba97eefdd5482868cf505de5"
    }
  },
  {
    "oid": "87f628fe2339f010734bf59f73bc334fd15133be",
    "message": "[wip][#682][#683] Research on alternate ways to find the content of lombok.config given a CompilationUnitDeclaration (in eclipse).",
    "date": "2014-06-03T22:26:00Z",
    "url": "https://github.com/projectlombok/lombok/commit/87f628fe2339f010734bf59f73bc334fd15133be",
    "details": {
      "sha": "74c60950e5fc6fcb743b25fe62e3e5da9caf151b",
      "filename": "src/core/lombok/eclipse/EclipseAST.java",
      "status": "modified",
      "additions": 52,
      "deletions": 2,
      "changes": 54,
      "blob_url": "https://github.com/projectlombok/lombok/blob/87f628fe2339f010734bf59f73bc334fd15133be/src%2Fcore%2Flombok%2Feclipse%2FEclipseAST.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/87f628fe2339f010734bf59f73bc334fd15133be/src%2Fcore%2Flombok%2Feclipse%2FEclipseAST.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Feclipse%2FEclipseAST.java?ref=87f628fe2339f010734bf59f73bc334fd15133be",
      "patch": "@@ -22,6 +22,7 @@\n package lombok.eclipse;\n \n import java.io.File;\n+import java.io.InputStream;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.net.URI;\n@@ -49,6 +50,9 @@\n import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;\n import org.eclipse.jdt.internal.compiler.ast.Statement;\n import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.core.Openable;\n+import org.eclipse.jdt.internal.core.builder.SourceFile;\n \n /**\n  * Wraps around Eclipse's internal AST view to add useful features as well as the ability to visit parents from children,\n@@ -72,16 +76,29 @@ public EclipseAST(CompilationUnitDeclaration ast) {\n \tpublic URI getAbsoluteFileLocation() {\n \t\tString fileName = getFileName();\n \t\t\n+\t\t\n+\t\t// state of the research in this:\n+\t\t// * We need an abstraction of a 'directory level'. This abstraction needs 'read()' which returns a string (content of lombok.config) and 'getParent()'.\n+\t\t// * sometimes, cud.compilationResult.compilationUnit is an 'openable', you can chase this down to end up with a path, you can jigger this into being the sibling 'lombok.config', and then use:\n+\t\t// \t\t\t\tInputStream in = ResourcesPlugin.getWorkspace().getRoot().getFile(ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(x)).getFullPath()).getContents(true);\n+\t\t// to read out this data. Our theory is that this will work even with very crazy virtual filesystems such as sourcecontrol://jazz/blabla.\n+\t\t// * With jazz and other creative file backed systems, is there even a 'project root' concept? Surely there won't be a 'workspace root' concept so how do we abstract the idea that, from jazz://whatever/projectroot, the parent is c:\\myWorkspace?\n+\t\t// * Check the .getAlternateAbsolutePath() impl which has the research done so far.\n+\t\t// * VIRTUAL FILES: Sometimes virtual files are created; their location tends to be /FileName.java which cannot be resolved. Optimally speaking we should find the 'source' of the virtual code and use IT for determining lombok.config, but that may not be feasible. If not, can we get at project or at least workspace?\n+\t\t// * Either way there are sufficiently many WTF situations, that in case of error, as painful as this is, we should just carry on and not apply lombok.config, though at least if we don't recognize the scenario we should write a log file imploring the user to send us a bunch of feedback on the situation.\n+\t\t// Relevant issues: Comment 2 on #683, all of #682\n \t\tif (!skipEclipseWorkspaceBasedFileResolver) {\n+\t\t\tif (Boolean.TRUE) throw new IllegalArgumentException(\"Here's the alt strat result: \" + getAlternativeAbsolutePath());\n \t\t\ttry {\n \t\t\t\t/*if (fileName.startsWith(\"/\") && fileName.indexOf('/', 1) > -1) */\n \t\t\t\ttry {\n \t\t\t\t\treturn EclipseWorkspaceBasedFileResolver.resolve(fileName);\n \t\t\t\t} catch (IllegalArgumentException e) {\n \t\t\t\t\tString msg = e.getMessage();\n \t\t\t\t\tif (msg != null && msg.startsWith(\"Path must include project and resource name\")) {\n-\t\t\t\t\t\t// go with the fallthrough, but log that this happened.\n-\t\t\t\t\t\taddProblem(new ParseProblem(true, \"Path resolution for lombok.config failed. Path: \" + fileName + \" -- falling back to: \" + new File(fileName).getAbsoluteFile(), 0, 1));\n+\t\t\t\t\t\t// We shouldn't throw an exception at all, but we can't reproduce this so we need help from our users to figure this out.\n+\t\t\t\t\t\t// Let's bother them with an error that slows their eclipse down to a crawl and makes it unusable.\n+\t\t\t\t\t\tthrow new IllegalArgumentException(\"Path resolution for lombok.config failed. Path: \" + fileName + \" -- package of this class: \" + this.getPackageDeclaration());\n \t\t\t\t\t} else throw e;\n \t\t\t\t}\n \t\t\t} catch (NoClassDefFoundError e) {\n@@ -94,6 +111,39 @@ public URI getAbsoluteFileLocation() {\n \t\treturn new File(fileName).getAbsoluteFile().toURI();\n \t}\n \t\n+\tprivate String getAlternativeAbsolutePath() {\n+\t\ttry {\n+\t\t\tICompilationUnit cu = this.compilationUnitDeclaration.compilationResult.compilationUnit;\n+\t\t\t\n+\t\t\tif (cu instanceof Openable) {\n+\t\t\t\tString x = ((Openable) cu).getResource().getFullPath().makeAbsolute().toString();\n+\t\t\t\tint lastLoc = x.lastIndexOf('/');\n+\t\t\t\tx = x.substring(0, lastLoc + 1) + \"lombok.config\";\n+\t\t\t\tURI lombokConfigLoc = ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(x)).getLocationURI();\n+\t\t\t\tInputStream in = ResourcesPlugin.getWorkspace().getRoot().getFile(ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(x)).getFullPath()).getContents(true);\n+\t\t\t\tbyte[] b = new byte[100000];\n+\t\t\t\tint p = 0;\n+\t\t\t\twhile (true) {\n+\t\t\t\t\tint r = in.read(b, p, b.length - p);\n+\t\t\t\t\tif (r == -1) break;\n+\t\t\t\t\tp += r;\n+\t\t\t\t}\n+\t\t\t\tin.close();\n+\t\t\t\treturn \"(Contents of lombok.config: \" + new String(b, 0, p, \"UTF-8\");\n+\n+//\t\t\t\treturn \"(alt strategy result C: '\" + ((Openable) cu).getResource().getFullPath().makeAbsolute().toString() + \"'): resolved: \" + EclipseWorkspaceBasedFileResolver.resolve(((Openable) cu).getResource().getFullPath().makeAbsolute().toString());\n+\t\t\t}\n+\t\t\tif (cu instanceof SourceFile) {\n+\t\t\t\tString cuFileName = new String(((SourceFile) cu).getFileName());\n+\t\t\t\tString cuIFilePath = ((SourceFile) cu).resource.getFullPath().toString();\n+\t\t\t\treturn \"(alt strategy result A: \\\"\" + cuFileName + \"\\\" B: \\\"\" + cuIFilePath + \"\\\")\";\n+\t\t\t}\n+\t\t\treturn \"(alt strategy failed: cu isn't a SourceFile or Openable but a \" + cu.getClass() + \")\";\n+\t\t} catch (Exception e) {\n+\t\t\treturn \"(alt strategy failed: \" + e + \")\";\n+\t\t}\n+\t}\n+\t\n \tprivate static class EclipseWorkspaceBasedFileResolver {\n \t\tpublic static URI resolve(String path) {\n \t\t\treturn ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(path)).getLocationURI();",
      "parent_sha": "b37a95a6a4fa70da38f990b14a0f9517dd5ed0bc"
    }
  },
  {
    "oid": "c03ebf25350ca036126808c4328d90a826af070f",
    "message": "[trivial] Classed up the place with some javadoc.",
    "date": "2014-10-28T22:53:15Z",
    "url": "https://github.com/projectlombok/lombok/commit/c03ebf25350ca036126808c4328d90a826af070f",
    "details": {
      "sha": "79809b2f5fb7f46dec9f0603136b5d879d4d8aed",
      "filename": "src/launch/lombok/launch/ShadowClassLoader.java",
      "status": "modified",
      "additions": 42,
      "deletions": 15,
      "changes": 57,
      "blob_url": "https://github.com/projectlombok/lombok/blob/c03ebf25350ca036126808c4328d90a826af070f/src%2Flaunch%2Flombok%2Flaunch%2FShadowClassLoader.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/c03ebf25350ca036126808c4328d90a826af070f/src%2Flaunch%2Flombok%2Flaunch%2FShadowClassLoader.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Flaunch%2Flombok%2Flaunch%2FShadowClassLoader.java?ref=c03ebf25350ca036126808c4328d90a826af070f",
      "patch": "@@ -41,21 +41,39 @@\n /**\n  * The shadow classloader serves to completely hide almost all classes in a given jar file by using a different file ending.\n  * \n- *  Classes loaded by the shadowloader use \".SCL.<em>sclSuffix</em>\" instead of \".class\".\n- *  \n- *  In addition, the shadowloader will pick up an alternate (priority) classpath, using normal class files, from the system property {@code shadow.classpath}.\n- *  \n- *  This classloader accomplishes a number of things:<ul>\n- *  <li>Avoid contaminating the namespace of any project using lombok. Autocompleters in IDEs will NOT suggest anything other than actual public API.\n- *  <li>Like jarjar, allows folding in dependencies such as ASM without foisting these dependencies on projects that use lombok. shadowloader obviates the need for jarjar.\n- *  <li>Allows an agent (which MUST be in jar form) to still load everything except this loader infrastructure from class files generated by the IDE, which should\n- *  considerably help debugging, as you can now rely on the IDE's built-in auto-recompile features instead of having to run a full build everytime, and it should help\n- *  with hot code replace and the like.\n- *  </ul>\n- *  \n- *  Implementation note: {@code lombok.patcher} <em>relies</em> on this class having no dependencies on any other class except the JVM boot class, notably\n- *  including any other classes in this package, <strong>including</strong> inner classes of this very class. So, don't write closures, anonymous inner class literals,\n- *  enums, or anything else that could cause the compilation of this file to produce more than 1 class file.\n+ * The shadow classloader also serves to link in a project as it is being developed (a 'bin' dir from an IDE for example).\n+ * <p>\n+ * Classes loaded by the shadowloader use \".SCL.<em>sclSuffix</em>\" in addition to \".class\". In other words, most of the class files in a given jar end in this suffix, which\n+ * serves to hide them from any tool that isn't aware of the suffix (such as IDEs generating auto-complete dialogs, and javac's classpath in general). Only shadowloader can actually\n+ * load these classes.\n+ * <p>\n+ * The shadowloader will pick up an alternate (priority) classpath, using normal class files, from the system property \"<code>shadow.override.<em>sclSuffix</em></code>\".\n+ * This shadow classpath looks just like a normal java classpath; the path separator is applied (semi-colon on windows, colon elsewhere), and entries can consist of directories,\n+ * jar files, or directories ending in \"/*\" to pick up all jars inside it.\n+ * <p>\n+ * Load order is as follows if at least one override is present:\n+ * <li>First, if the resource is found in one of the paths stated in the shadow classpath, find that.\n+ * <li>Next, ask the <code>parent</code> loader, which is passed during construction of the ShadowClassLoader.\n+ * <li>Notably, this jar's contents are always skipped! (The idea of the shadow classpath is that this jar only functions as a launcher, not as a source of your actual application).\n+ * </ul>\n+ * \n+ * If no overrides are present, the load order is as follows:\n+ * <li>First, if the resource is found in our own jar (trying \".SCL.<em>sclSuffix</em>\" first for any resource request ending in \".class\"), return that.\n+ * <li>Next, ask the <code>parent</code> loader.\n+ * </ul>\n+ * \n+ * Use ShadowClassLoader to accomplish the following things:<ul>\n+ * <li>Avoid contaminating the namespace of any project using an SCL-based jar. Autocompleters in IDEs will NOT suggest anything other than actual public API.\n+ * <li>Like jarjar, allows folding in dependencies such as ASM without foisting these dependencies on projects that use this jar. shadowloader obviates the need for jarjar.\n+ * <li>Allows an agent (which MUST be in jar form) to still load everything except this loader infrastructure from class files generated by the IDE, which should\n+ * considerably help debugging, as you can now rely on the IDE's built-in auto-recompile features instead of having to run a full build everytime, and it should help\n+ * with hot code replace and the like (this is what the {@code shadow.override} feature is for).\n+ * </ul>\n+ * \n+ * Implementation note: {@code lombok.eclipse.agent.EclipseLoaderPatcher} <em>relies</em> on this class having no dependencies on any other class except the JVM boot class, notably\n+ * including any other classes in this package, <strong>including</strong> inner classes. So, don't write closures, anonymous inner class literals,\n+ * enums, or anything else that could cause the compilation of this file to produce more than 1 class file. In general, actually passing load control to this loader is a bit tricky\n+ * so ensure that this class has zero dependencies on anything except java core classes.\n  */\n class ShadowClassLoader extends ClassLoader {\n \tprivate static final String SELF_NAME = \"lombok/launch/ShadowClassLoader.class\";\n@@ -67,6 +85,9 @@ class ShadowClassLoader extends ClassLoader {\n \tprivate final String sclSuffix;\n \tprivate final List<String> parentExclusion = new ArrayList<String>();\n \t\n+\t/**\n+\t * Calls the {@link ShadowClassLoader(ClassLoader, String, String, String[]) constructor with no exclusions and the source of this class as base.\n+\t */\n \tShadowClassLoader(ClassLoader source, String sclSuffix) {\n \t\tthis(source, sclSuffix, null);\n \t}\n@@ -169,6 +190,9 @@ private List<String> retrieveFromCache(String absolutePathToJar) {\n \t\t}\n \t}\n \t\n+\t/**\n+\t * Looks up {@code altName} in {@code location}, and if that isn't found, looks up {@code name}; {@code altName} can be null in which case it is skipped.\n+\t */\n \tprivate URL getResourceFromLocation(String name, String altName, File location) {\n \t\tif (location.isDirectory()) {\n \t\t\ttry {\n@@ -211,6 +235,9 @@ private URL getResourceFromLocation(String name, String altName, File location)\n \t\treturn null;\n \t}\n \t\n+\t/**\n+\t * Checks if the stated item is located inside the same classpath root as the jar that hosts ShadowClassLoader.class. {@code item} and {@code name} refer to the same thing.\n+\t */\n \tprivate boolean inOwnBase(URL item, String name) {\n \t\tif (item == null) return false;\n \t\tString itemString = item.toString();",
      "parent_sha": "0c63bb3aa79ab29b679129f8a1a3cf01c79274d8"
    }
  },
  {
    "oid": "e94bf546f3bdb37dbc442804d3819c83bd4f69c5",
    "message": "Fixing javac's PrettyPrinter's screwup on enum members with bodies or parameters.\n\nNote that JDK7 fixed this themselves though they kept the silly comments.",
    "date": "2010-01-07T22:47:46Z",
    "url": "https://github.com/projectlombok/lombok/commit/e94bf546f3bdb37dbc442804d3819c83bd4f69c5",
    "details": {
      "sha": "a7c79f46ef8fa9420d64b3e6035536b00d70664b",
      "filename": "src/delombok/lombok/delombok/PrettyCommentsPrinter.java",
      "status": "modified",
      "additions": 17,
      "deletions": 7,
      "changes": 24,
      "blob_url": "https://github.com/projectlombok/lombok/blob/e94bf546f3bdb37dbc442804d3819c83bd4f69c5/src%2Fdelombok%2Flombok%2Fdelombok%2FPrettyCommentsPrinter.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/e94bf546f3bdb37dbc442804d3819c83bd4f69c5/src%2Fdelombok%2Flombok%2Fdelombok%2FPrettyCommentsPrinter.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fdelombok%2Flombok%2Fdelombok%2FPrettyCommentsPrinter.java?ref=e94bf546f3bdb37dbc442804d3819c83bd4f69c5",
      "patch": "@@ -521,6 +521,22 @@ public void printEnumBody(List<JCTree> stats) throws IOException {\n         print(\"}\");\n     }\n \n+    public void printEnumMember(JCVariableDecl tree) throws IOException {\n+        print(tree.name);\n+        if (tree.init instanceof JCNewClass) {\n+            JCNewClass constructor = (JCNewClass) tree.init;\n+            if (constructor.args != null && constructor.args.nonEmpty()) {\n+                print(\"(\");\n+                printExprs(constructor.args);\n+                print(\")\");\n+            }\n+            if (constructor.def != null && constructor.def.defs != null) {\n+                print(\" \");\n+                printBlock(constructor.def.defs, constructor.def);\n+            }\n+        }\n+    }\n+\n     /** Is the given tree an enumerator definition? */\n     boolean isEnumerator(JCTree t) {\n         return getTag(t) == JCTree.VARDEF && (((JCVariableDecl) t).mods.flags & ENUM) != 0;\n@@ -693,13 +709,7 @@ public void visitVarDef(JCVariableDecl tree) {\n             }\n             printDocComment(tree);\n             if ((tree.mods.flags & ENUM) != 0) {\n-                print(\"/*public static final*/ \");\n-                print(tree.name);\n-                if (tree.init != null) {\n-                    print(\" /* = \");\n-                    printExpr(tree.init);\n-                    print(\" */\");\n-                }\n+                printEnumMember(tree);\n             } else {\n                 printExpr(tree.mods);\n                 if ((tree.mods.flags & VARARGS) != 0) {",
      "parent_sha": "24be0f86adba532b0a002e6594c4d150e6cb84ab"
    }
  },
  {
    "oid": "460c70890cea12e0224d8b978b36bfc89b3b0e1e",
    "message": "let @SuperBuilder's toString() call super.toString()",
    "date": "2018-04-16T18:21:02Z",
    "url": "https://github.com/projectlombok/lombok/commit/460c70890cea12e0224d8b978b36bfc89b3b0e1e",
    "details": {
      "sha": "bd0f3b709dbef12c9cd1c35478fe7021507c220d",
      "filename": "src/core/lombok/javac/handlers/HandleSuperBuilder.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/projectlombok/lombok/blob/460c70890cea12e0224d8b978b36bfc89b3b0e1e/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FHandleSuperBuilder.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/460c70890cea12e0224d8b978b36bfc89b3b0e1e/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FHandleSuperBuilder.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FHandleSuperBuilder.java?ref=460c70890cea12e0224d8b978b36bfc89b3b0e1e",
      "patch": "@@ -181,7 +181,7 @@ public void handle(AnnotationValues<SuperBuilder> annotation, JCAnnotation ast,\n \t\t\tString superclassBuilderClassName = extendsClause.toString() + \"Builder\";\n \t\t\tsuperclassBuilderClassExpression = chainDots(tdParent, extendsClause.toString(), superclassBuilderClassName);\n \t\t}\n-\t\t// If there is no superclass, superclassBuilderClassName is still == null at this point.\n+\t\t// If there is no superclass, superclassBuilderClassExpression is still == null at this point.\n \t\t// You can use it to check whether to inherit or not.\n \n \t\treturnType = namePlusTypeParamsToTypeReference(tdParent.getTreeMaker(), td.name, td.typarams);\n@@ -257,8 +257,8 @@ public void handle(AnnotationValues<SuperBuilder> annotation, JCAnnotation ast,\n \t\t\tfor (BuilderFieldData bfd : builderFields) {\n \t\t\t\tfieldNodes.addAll(bfd.createdFields);\n \t\t\t}\n-\t\t\t// TODO: toString() should also call super.toString(), so that it also shows fields from the superclass.\n-\t\t\tJCMethodDecl md = HandleToString.createToString(builderType, fieldNodes, true, false, FieldAccess.ALWAYS_FIELD, ast);\n+\t\t\t// Let toString() call super.toString() if there is a superclass, so that it also shows fields from the superclass' builder.\n+\t\t\tJCMethodDecl md = HandleToString.createToString(builderType, fieldNodes, true, superclassBuilderClassExpression != null, FieldAccess.ALWAYS_FIELD, ast);\n \t\t\tif (md != null) injectMethod(builderType, md);\n \t\t}\n \t\t",
      "parent_sha": "054a966bad3037a758af50d5801461c8995fffa9"
    }
  },
  {
    "oid": "b719e47e2d47be40141634bd9db1b47b0bf75192",
    "message": "prep for this class working better for ecj.",
    "date": "2009-12-23T02:35:35Z",
    "url": "https://github.com/projectlombok/lombok/commit/b719e47e2d47be40141634bd9db1b47b0bf75192",
    "details": {
      "sha": "dff11442da4d7c3dc5e87e0d962728e7ec69a313",
      "filename": "src/core/lombok/eclipse/TransformEclipseAST.java",
      "status": "modified",
      "additions": 11,
      "deletions": 5,
      "changes": 16,
      "blob_url": "https://github.com/projectlombok/lombok/blob/b719e47e2d47be40141634bd9db1b47b0bf75192/src%2Fcore%2Flombok%2Feclipse%2FTransformEclipseAST.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/b719e47e2d47be40141634bd9db1b47b0bf75192/src%2Fcore%2Flombok%2Feclipse%2FTransformEclipseAST.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Feclipse%2FTransformEclipseAST.java?ref=b719e47e2d47be40141634bd9db1b47b0bf75192",
      "patch": "@@ -57,10 +57,10 @@ public class TransformEclipseAST {\n \t\n \tstatic {\n \t\tField f = null;\n-\t\tHandlerLibrary l = null;\n+\t\tHandlerLibrary h = null;\n+\t\t\n \t\ttry {\n-\t\t\tl = HandlerLibrary.load();\n-\t\t\tf = CompilationUnitDeclaration.class.getDeclaredField(\"$lombokAST\");\n+\t\t\th = HandlerLibrary.load();\n \t\t} catch (Throwable t) {\n \t\t\ttry {\n \t\t\t\tEclipse.error(null, \"Problem initializing lombok\", t);\n@@ -70,8 +70,14 @@ public class TransformEclipseAST {\n \t\t\t}\n \t\t\tdisableLombok = true;\n \t\t}\n+\t\ttry {\n+\t\t\tf = CompilationUnitDeclaration.class.getDeclaredField(\"$lombokAST\");\n+\t\t} catch (Throwable t) {\n+\t\t\t//I guess we're in an ecj environment; we'll just not cache stuff then.\n+\t\t}\n+\t\t\n \t\tastCacheField = f;\n-\t\thandlers = l;\n+\t\thandlers = h;\n \t}\n \t\n \tpublic static void transform_swapped(CompilationUnitDeclaration ast, Parser parser) {\n@@ -86,7 +92,7 @@ public static void transform_swapped(CompilationUnitDeclaration ast, Parser pars\n \t * Eclipse's parsers often operate in diet mode, which means many parts of the AST have been left blank.\n \t * Be ready to deal with just about anything being null, such as the Statement[] arrays of the Method AST nodes.\n \t * \n-\t * @param parser The Eclipse parser object that generated the AST.\n+\t * @param parser The Eclipse parser object that generated the AST. Not actually used; mostly there to satisfy parameter rules for lombok.patcher scripts.\n \t * @param ast The AST node belonging to the compilation unit (java speak for a single source file).\n \t */\n \tpublic static void transform(Parser parser, CompilationUnitDeclaration ast) {",
      "parent_sha": "f9264b78e47262cd285e9c219954a5c5120cb25e"
    }
  },
  {
    "oid": "dfbd843e5ac95dcd10cfb0c3d403d588b4123394",
    "message": "[#2612] VarSymbol.adr is a bit field",
    "date": "2020-10-29T21:57:46Z",
    "url": "https://github.com/projectlombok/lombok/commit/dfbd843e5ac95dcd10cfb0c3d403d588b4123394",
    "details": {
      "sha": "5e64d8ef99c60e0ef6dc5ef2c6c71ce2fd0a44d8",
      "filename": "src/core/lombok/javac/handlers/JavacHandlerUtil.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/projectlombok/lombok/blob/dfbd843e5ac95dcd10cfb0c3d403d588b4123394/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FJavacHandlerUtil.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/dfbd843e5ac95dcd10cfb0c3d403d588b4123394/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FJavacHandlerUtil.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FJavacHandlerUtil.java?ref=dfbd843e5ac95dcd10cfb0c3d403d588b4123394",
      "patch": "@@ -1241,7 +1241,7 @@ public static void injectMethod(JavacNode typeNode, JCMethodDecl method, List<Ty\n \t\t\t\tif (param.sym == null) {\n \t\t\t\t\tType paramType = paramTypes == null ? param.getType().type : paramTypes.get(i);\n \t\t\t\t\tVarSymbol varSymbol = new VarSymbol(param.mods.flags, param.name, paramType, symtab.noSymbol);\n-\t\t\t\t\tvarSymbol.adr = i;\n+\t\t\t\t\tvarSymbol.adr = 1 << i;\n \t\t\t\t\tList<JCAnnotation> annotations = param.getModifiers().getAnnotations();\n \t\t\t\t\tif (annotations != null && !annotations.isEmpty()) {\n \t\t\t\t\t\tListBuffer<Attribute.Compound> newAnnotations = new ListBuffer<Attribute.Compound>();",
      "parent_sha": "f04ee37f6bd57564f3529030ac1a5233428894ea"
    }
  },
  {
    "oid": "cb4c8ca4a1392844cd01b573e53b7926c1374872",
    "message": "Fixed the problem where the eclipse editor AST just loses track of things when using @SneakyThrows (syntax colouring goes away, first character in the file is italic).",
    "date": "2009-09-01T19:09:27Z",
    "url": "https://github.com/projectlombok/lombok/commit/cb4c8ca4a1392844cd01b573e53b7926c1374872",
    "details": {
      "sha": "e01cbcdec107c3613b09bbcbe089d323dede7cc6",
      "filename": "src/lombok/eclipse/handlers/HandleSneakyThrows.java",
      "status": "modified",
      "additions": 20,
      "deletions": 8,
      "changes": 28,
      "blob_url": "https://github.com/projectlombok/lombok/blob/cb4c8ca4a1392844cd01b573e53b7926c1374872/src%2Flombok%2Feclipse%2Fhandlers%2FHandleSneakyThrows.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/cb4c8ca4a1392844cd01b573e53b7926c1374872/src%2Flombok%2Feclipse%2Fhandlers%2FHandleSneakyThrows.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Flombok%2Feclipse%2Fhandlers%2FHandleSneakyThrows.java?ref=cb4c8ca4a1392844cd01b573e53b7926c1374872",
      "patch": "@@ -154,19 +154,24 @@ private boolean handleMethod(Node annotation, AbstractMethodDeclaration method,\n \t\t\n \t\treturn true;\n \t}\n-\n+\t\n \tprivate Statement buildTryCatchBlock(Statement[] contents, DeclaredException exception) {\n+\t\tlong p = exception.getPos();\n+\t\tint pS = (int)(p >> 32), pE = (int)p;\n+\t\t\n \t\tTryStatement tryStatement = new TryStatement();\n \t\ttryStatement.tryBlock = new Block(0);\n+\t\ttryStatement.tryBlock.sourceStart = pS;\n+\t\ttryStatement.tryBlock.sourceEnd = pE;\n \t\ttryStatement.tryBlock.statements = contents;\n \t\tTypeReference typeReference;\n \t\tif ( exception.exceptionName.indexOf('.') == -1 ) {\n-\t\t\ttypeReference = new SingleTypeReference(exception.exceptionName.toCharArray(), exception.getPos());\n+\t\t\ttypeReference = new SingleTypeReference(exception.exceptionName.toCharArray(), p);\n \t\t} else {\n \t\t\tString[] x = exception.exceptionName.split(\"\\\\.\");\n \t\t\tchar[][] elems = new char[x.length][];\n \t\t\tlong[] poss = new long[x.length];\n-\t\t\tint start = (int)(exception.getPos() >> 32);\n+\t\t\tint start = pS;\n \t\t\tfor ( int i = 0 ; i < x.length ; i++ ) {\n \t\t\t\telems[i] = x[i].trim().toCharArray();\n \t\t\t\tint end = start + x[i].length();\n@@ -176,19 +181,26 @@ private Statement buildTryCatchBlock(Statement[] contents, DeclaredException exc\n \t\t\ttypeReference = new QualifiedTypeReference(elems, poss);\n \t\t}\n \t\t\n-\t\tArgument catchArg = new Argument(\"$ex\".toCharArray(), exception.getPos(), typeReference, 0);\n+\t\tArgument catchArg = new Argument(\"$ex\".toCharArray(), p, typeReference, 0);\n+\t\tcatchArg.declarationSourceEnd = catchArg.declarationEnd = catchArg.sourceEnd = pE;\n+\t\tcatchArg.declarationSourceStart = catchArg.modifiersSourceStart = catchArg.sourceStart = pS;\n \t\t\n \t\ttryStatement.catchArguments = new Argument[] { catchArg };\n \t\t\n \t\tMessageSend sneakyThrowStatement = new MessageSend();\n-\t\tsneakyThrowStatement.receiver = new QualifiedNameReference(new char[][] { \"lombok\".toCharArray(), \"Lombok\".toCharArray() }, new long[] { 0, 0 }, 0, 0);\n+\t\tsneakyThrowStatement.receiver = new QualifiedNameReference(new char[][] { \"lombok\".toCharArray(), \"Lombok\".toCharArray() }, new long[] { p, p }, pS, pE);\n \t\tsneakyThrowStatement.selector = \"sneakyThrow\".toCharArray();\n-\t\tsneakyThrowStatement.arguments = new Expression[] { new SingleNameReference(\"$ex\".toCharArray(), 0) };\n-\t\tStatement rethrowStatement = new ThrowStatement(sneakyThrowStatement, 0, 0);\n+\t\tsneakyThrowStatement.arguments = new Expression[] { new SingleNameReference(\"$ex\".toCharArray(), p) };\n+\t\tsneakyThrowStatement.sourceStart = pS;\n+\t\tsneakyThrowStatement.sourceEnd = sneakyThrowStatement.statementEnd = pE;\n+\t\tStatement rethrowStatement = new ThrowStatement(sneakyThrowStatement, pS, pE);\n \t\tBlock block = new Block(0);\n+\t\tblock.sourceStart = pS;\n+\t\tblock.sourceEnd = pE;\n \t\tblock.statements = new Statement[] { rethrowStatement };\n-\t\tblock.sourceStart = block.sourceEnd = -2;\n \t\ttryStatement.catchBlocks = new Block[] { block };\n+\t\ttryStatement.sourceStart = pS;\n+\t\ttryStatement.sourceEnd = pE;\n \t\treturn tryStatement;\n \t}\n }",
      "parent_sha": "b069df74842976439112fd6a3d771ea8b30b31b4"
    }
  },
  {
    "oid": "36c75b2d68551df3f297e8dcf10a8909307c854a",
    "message": "no custom builders allowed, so there cannot be a toString() method",
    "date": "2018-05-30T20:49:34Z",
    "url": "https://github.com/projectlombok/lombok/commit/36c75b2d68551df3f297e8dcf10a8909307c854a",
    "details": {
      "sha": "116de47b42a97bc2f1ee6aa4f6e951a1d9e06b14",
      "filename": "src/core/lombok/javac/handlers/HandleSuperBuilder.java",
      "status": "modified",
      "additions": 13,
      "deletions": 14,
      "changes": 27,
      "blob_url": "https://github.com/projectlombok/lombok/blob/36c75b2d68551df3f297e8dcf10a8909307c854a/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FHandleSuperBuilder.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/36c75b2d68551df3f297e8dcf10a8909307c854a/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FHandleSuperBuilder.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fjavac%2Fhandlers%2FHandleSuperBuilder.java?ref=36c75b2d68551df3f297e8dcf10a8909307c854a",
      "patch": "@@ -262,18 +262,17 @@ public void handle(AnnotationValues<SuperBuilder> annotation, JCAnnotation ast,\n \t\t}\n \n \t\t// Create the toString() method for the abstract builder.\n-\t\tif (methodExists(\"toString\", builderType, 0) == MemberExistsResult.NOT_EXISTS) {\n-\t\t\tjava.util.List<JavacNode> fieldNodes = new ArrayList<JavacNode>();\n-\t\t\tfor (BuilderFieldData bfd : builderFields) {\n-\t\t\t\tfieldNodes.addAll(bfd.createdFields);\n-\t\t\t}\n-\t\t\t// Let toString() call super.toString() if there is a superclass, so that it also shows fields from the superclass' builder.\n-\t\t\tJCMethodDecl md = HandleToString.createToString(builderType, fieldNodes, true, superclassBuilderClassExpression != null, FieldAccess.ALWAYS_FIELD, ast);\n-\t\t\tif (md != null) {\n-\t\t\t\tinjectMethod(builderType, md);\n-\t\t\t}\n+\t\tjava.util.List<JavacNode> fieldNodes = new ArrayList<JavacNode>();\n+\t\tfor (BuilderFieldData bfd : builderFields) {\n+\t\t\tfieldNodes.addAll(bfd.createdFields);\n+\t\t}\n+\t\t// Let toString() call super.toString() if there is a superclass, so that it also shows fields from the superclass' builder.\n+\t\tJCMethodDecl toStringMethod = HandleToString.createToString(builderType, fieldNodes, true, superclassBuilderClassExpression != null, FieldAccess.ALWAYS_FIELD, ast);\n+\t\tif (toStringMethod != null) {\n+\t\t\tinjectMethod(builderType, toStringMethod);\n \t\t}\n \n+\t\t// If clean methods are requested, add them now.\n \t\tif (addCleaning) {\n \t\t\tinjectMethod(builderType, generateCleanMethod(builderFields, builderType, ast));\n \t\t}\n@@ -304,10 +303,10 @@ public void handle(AnnotationValues<SuperBuilder> annotation, JCAnnotation ast,\n \t\t// Add the builder() method to the annotated class.\n \t\t// Allow users to specify their own builder() methods, e.g., to provide default values.\n \t\tif (methodExists(builderMethodName, tdParent, -1) == MemberExistsResult.NOT_EXISTS) {\n-\t\t\tJCMethodDecl md = generateBuilderMethod(builderMethodName, builderClassName, builderImplClassName, annotationNode, tdParent, typeParams);\n-\t\t\trecursiveSetGeneratedBy(md, ast, annotationNode.getContext());\n-\t\t\tif (md != null) {\n-\t\t\t\tinjectMethod(tdParent, md);\n+\t\t\tJCMethodDecl builderMethod = generateBuilderMethod(builderMethodName, builderClassName, builderImplClassName, annotationNode, tdParent, typeParams);\n+\t\t\trecursiveSetGeneratedBy(builderMethod, ast, annotationNode.getContext());\n+\t\t\tif (builderMethod != null) {\n+\t\t\t\tinjectMethod(tdParent, builderMethod);\n \t\t\t}\n \t\t}\n ",
      "parent_sha": "4c5a7cddab109391d7494be2a0fc575b466dfa43"
    }
  },
  {
    "oid": "9ecfe2302f3cd1d654196e072cce0b334f21ffd9",
    "message": "Fix version parsing for jdk10.",
    "date": "2018-02-06T23:19:24Z",
    "url": "https://github.com/projectlombok/lombok/commit/9ecfe2302f3cd1d654196e072cce0b334f21ffd9",
    "details": {
      "sha": "2adc52658fbb5d2af15bc0d346766348fb56d9fa",
      "filename": "src/utils/lombok/javac/Javac.java",
      "status": "modified",
      "additions": 14,
      "deletions": 11,
      "changes": 25,
      "blob_url": "https://github.com/projectlombok/lombok/blob/9ecfe2302f3cd1d654196e072cce0b334f21ffd9/src%2Futils%2Flombok%2Fjavac%2FJavac.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/9ecfe2302f3cd1d654196e072cce0b334f21ffd9/src%2Futils%2Flombok%2Fjavac%2FJavac.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Futils%2Flombok%2Fjavac%2FJavac.java?ref=9ecfe2302f3cd1d654196e072cce0b334f21ffd9",
      "patch": "@@ -63,8 +63,8 @@ private Javac() {\n \t/** Matches any of the 8 primitive names, such as {@code boolean}. */\n \tprivate static final Pattern PRIMITIVE_TYPE_NAME_PATTERN = Pattern.compile(\"^(boolean|byte|short|int|long|float|double|char)$\");\n \t\n-\tprivate static final Pattern VERSION_PARSER = Pattern.compile(\"^(\\\\d{1,6})\\\\.(\\\\d{1,6}).*$\");\n-\tprivate static final Pattern SOURCE_PARSER = Pattern.compile(\"^JDK(\\\\d{1,6})_(\\\\d{1,6}).*$\");\n+\tprivate static final Pattern VERSION_PARSER = Pattern.compile(\"^(\\\\d{1,6})\\\\.?(\\\\d{1,6})?.*$\");\n+\tprivate static final Pattern SOURCE_PARSER = Pattern.compile(\"^JDK(\\\\d{1,6})_?(\\\\d{1,6})?.*$\");\n \t\n \tprivate static final AtomicInteger compilerVersion = new AtomicInteger(-1);\n \t\n@@ -79,11 +79,11 @@ public static int getJavaCompilerVersion() {\n \t\t\tMatcher m = VERSION_PARSER.matcher(JavaCompiler.version());\n \t\t\tif (m.matches()) {\n \t\t\t\tint major = Integer.parseInt(m.group(1));\n-\t\t\t\tint minor = Integer.parseInt(m.group(2));\n \t\t\t\tif (major == 1) {\n-\t\t\t\t\tcompilerVersion.set(minor);\n-\t\t\t\t\treturn minor;\n+\t\t\t\t\tint minor = Integer.parseInt(m.group(2));\n+\t\t\t\t\treturn setVersion(minor);\n \t\t\t\t}\n+\t\t\t\tif (major >= 9) return setVersion(major);\n \t\t\t}\n \t\t}\n \t\t\n@@ -92,16 +92,19 @@ public static int getJavaCompilerVersion() {\n \t\t\tMatcher m = SOURCE_PARSER.matcher(name);\n \t\t\tif (m.matches()) {\n \t\t\t\tint major = Integer.parseInt(m.group(1));\n-\t\t\t\tint minor = Integer.parseInt(m.group(2));\n \t\t\t\tif (major == 1) {\n-\t\t\t\t\tcompilerVersion.set(minor);\n-\t\t\t\t\treturn minor;\n+\t\t\t\t\tint minor = Integer.parseInt(m.group(2));\n+\t\t\t\t\treturn setVersion(minor);\n \t\t\t\t}\n+\t\t\t\tif (major >= 9) return setVersion(major);\n \t\t\t}\n \t\t}\n-\t\t\n-\t\tcompilerVersion.set(6);\n-\t\treturn 6;\n+\t\treturn setVersion(6);\n+\t}\n+\t\n+\tprivate static int setVersion(int version) {\n+\t\tcompilerVersion.set(version);\n+\t\treturn version;\n \t}\n \t\n \tprivate static final Class<?> DOCCOMMENTTABLE_CLASS;",
      "parent_sha": "2f1069e48c4641928ab3151a13a52b49062a29af"
    }
  },
  {
    "oid": "edbfdfe8c52c17a38bf2b526d14a4f622c5402f7",
    "message": "Issue 2552 - generate class initializer body only after field member injection",
    "date": "2020-08-27T21:52:32Z",
    "url": "https://github.com/projectlombok/lombok/commit/edbfdfe8c52c17a38bf2b526d14a4f622c5402f7",
    "details": {
      "sha": "cee3912c284cc0eafe1887542dd3d53ac2d57a92",
      "filename": "src/core/lombok/eclipse/handlers/HandleFieldNameConstants.java",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/projectlombok/lombok/blob/edbfdfe8c52c17a38bf2b526d14a4f622c5402f7/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleFieldNameConstants.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/edbfdfe8c52c17a38bf2b526d14a4f622c5402f7/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleFieldNameConstants.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleFieldNameConstants.java?ref=edbfdfe8c52c17a38bf2b526d14a4f622c5402f7",
      "patch": "@@ -171,10 +171,10 @@ private void createInnerTypeFieldNameConstants(EclipseNode typeNode, EclipseNode\n \t\t\tinjectMethod(fieldsType, constructor);\n \t\t}\n \t\t\n+\t\tClinit cli = null;\n \t\tif (genClinit) {\n-\t\t\tClinit cli = new Clinit(parent.compilationResult);\n+\t\t\tcli = new Clinit(parent.compilationResult);\n \t\t\tinjectMethod(fieldsType, cli);\n-\t\t\tcli.traverse(generatedByVisitor, ((TypeDeclaration) fieldsType.get()).scope);\n \t\t}\n \t\t\n \t\tfor (EclipseNode fieldNode : fields) {\n@@ -202,5 +202,9 @@ private void createInnerTypeFieldNameConstants(EclipseNode typeNode, EclipseNode\n \t\t\tinjectField(fieldsType, constantField);\n \t\t\tconstantField.traverse(generatedByVisitor, ((TypeDeclaration) fieldsType.get()).initializerScope);\n \t\t}\n+\t\t\n+\t\tif (genClinit) {\n+\t\t\tcli.traverse(generatedByVisitor, ((TypeDeclaration) fieldsType.get()).scope);\n+\t\t}\n \t}\n }",
      "parent_sha": "60a9799c24f182b3c7e262754b6cc2e3400a4993"
    }
  },
  {
    "oid": "e12a956c2579ae6d38ef9850fb29f3f720ddac47",
    "message": "ecj: builder generics [WIP]",
    "date": "2018-05-06T20:07:28Z",
    "url": "https://github.com/projectlombok/lombok/commit/e12a956c2579ae6d38ef9850fb29f3f720ddac47",
    "details": {
      "sha": "486e8f91d68bafef721785f945ab9c0affd96f98",
      "filename": "src/core/lombok/eclipse/handlers/HandleSuperBuilder.java",
      "status": "modified",
      "additions": 20,
      "deletions": 4,
      "changes": 24,
      "blob_url": "https://github.com/projectlombok/lombok/blob/e12a956c2579ae6d38ef9850fb29f3f720ddac47/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleSuperBuilder.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/e12a956c2579ae6d38ef9850fb29f3f720ddac47/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleSuperBuilder.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FHandleSuperBuilder.java?ref=e12a956c2579ae6d38ef9850fb29f3f720ddac47",
      "patch": "@@ -194,7 +194,7 @@ public void handle(AnnotationValues<SuperBuilder> annotation, Annotation ast, Ec\n \t\t}\n \n \t\t// Set the names of the builder classes.\n-\t\tString builderClassName = td.name.toString() + \"Builder\";\n+\t\tString builderClassName = String.valueOf(td.name) + \"Builder\";\n \t\tString builderImplClassName = builderClassName + \"Impl\";\n \n \t\tTypeReference extendsClause = td.superclass;\n@@ -224,8 +224,8 @@ public void handle(AnnotationValues<SuperBuilder> annotation, Annotation ast, Ec\n \t\t// If there is no superclass, superclassBuilderClassExpression is still == null at this point.\n \t\t// You can use it to check whether to inherit or not.\n \n-\t\treturnType = namePlusTypeParamsToTypeReference(td.name, td.typeParameters, p);\n \t\ttypeParams = td.typeParameters != null ? td.typeParameters : new TypeParameter[0];\n+\t\treturnType = namePlusTypeParamsToTypeReference(td.name, typeParams, p);\n \n \t\t// <C, B> are the generics for our builder.\n \t\tString classGenericName = \"C\";\n@@ -607,7 +607,7 @@ public MethodDeclaration generateBuilderMethod(String builderMethodName, String\n \t\tout.modifiers = ClassFileConstants.AccPublic | ClassFileConstants.AccStatic;\n \t\tout.bits |= ECLIPSE_DO_NOT_TOUCH_FLAG;\n \t\tout.returnType = namePlusTypeParamsToTypeReference(builderClassName.toCharArray(), typeParams, p);\n-\t\tout.typeParameters = copyTypeParams(typeParams, source);\n+\t\t//out.typeParameters = copyTypeParams(typeParams, source);\n \t\tAllocationExpression invoke = new AllocationExpression();\n \t\tinvoke.type = namePlusTypeParamsToTypeReference(builderClassName.toCharArray(), typeParams, p);\n \t\tout.statements = new Statement[] {new ReturnStatement(invoke, pS, pE)};\n@@ -770,6 +770,22 @@ public EclipseNode findInnerClass(EclipseNode parent, String name) {\n \t\treturn null;\n \t}\n \n+\tprivate TypeParameter[] copyTypeParamsAndAddBuilderParams(TypeParameter[] typeParams, ASTNode source, String classGenericName, String builderGenericName) {\n+\t\tTypeParameter[] result = Arrays.copyOf(copyTypeParams(typeParams, source), typeParams.length + 2);\n+\n+\t\tTypeParameter o = new TypeParameter();\n+\t\tsetGeneratedBy(o, source);\n+\t\to.name = classGenericName.toCharArray();\n+\t\tresult[result.length - 2] = o;\n+\n+\t\to = new TypeParameter();\n+\t\tsetGeneratedBy(o, source);\n+\t\to.name = builderGenericName.toCharArray();\n+\t\tresult[result.length - 1] = o;\n+\n+\t\treturn result;\n+\t}\n+\n \tpublic EclipseNode makeBuilderAbstractClass(EclipseNode tdParent, String builderClass,\n \t\t\tTypeReference superclassBuilderClass, TypeParameter[] typeParams,\n \t\t\tTypeParameter[] superclassTypeParams, ASTNode source, String classGenericName, String builderGenericName) {\n@@ -778,8 +794,8 @@ public EclipseNode makeBuilderAbstractClass(EclipseNode tdParent, String builder\n \t\tTypeDeclaration builder = new TypeDeclaration(parent.compilationResult);\n \t\tbuilder.bits |= Eclipse.ECLIPSE_DO_NOT_TOUCH_FLAG;\n \t\tbuilder.modifiers |= ClassFileConstants.AccPublic | ClassFileConstants.AccStatic | ClassFileConstants.AccAbstract;\n-\t\tbuilder.typeParameters = copyTypeParams(typeParams, source);\n \t\tbuilder.name = builderClass.toCharArray();\n+\t\tbuilder.typeParameters = copyTypeParamsAndAddBuilderParams(typeParams, source, classGenericName, builderGenericName);\n \t\tbuilder.superclass = superclassBuilderClass;\n \n //\t\t// Keep any type params of the annotated class.",
      "parent_sha": "eec57b87509c0a2841878aecb0e8f8f0839fa30c"
    }
  },
  {
    "oid": "46377b1be44c564ea7e37f30ddd7d81faf19d45e",
    "message": "do not scan classes from java or sun package for extensions",
    "date": "2018-08-20T18:46:31Z",
    "url": "https://github.com/projectlombok/lombok/commit/46377b1be44c564ea7e37f30ddd7d81faf19d45e",
    "details": {
      "sha": "5489f3ea933f4c235be102ceb246f495243311b4",
      "filename": "src/launch/lombok/launch/ShadowClassLoader.java",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/projectlombok/lombok/blob/46377b1be44c564ea7e37f30ddd7d81faf19d45e/src%2Flaunch%2Flombok%2Flaunch%2FShadowClassLoader.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/46377b1be44c564ea7e37f30ddd7d81faf19d45e/src%2Flaunch%2Flombok%2Flaunch%2FShadowClassLoader.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Flaunch%2Flombok%2Flaunch%2FShadowClassLoader.java?ref=46377b1be44c564ea7e37f30ddd7d81faf19d45e",
      "patch": "@@ -296,17 +296,18 @@ private URL getResourceFromLocation(String name, String altName, File location)\n \t\treturn null;\n \t}\n \t\n-\tprivate boolean partOfShadow(URL item, String name) {\n-\t\treturn inOwnBase(item, name) || isPartOfShadowSuffix(item, name, sclSuffix);\n+\tprivate boolean partOfShadow(String item, String name) {\n+\t\treturn !name.startsWith(\"java/\") \n+\t\t\t\t&& !name.startsWith(\"sun/\") \n+\t\t\t\t&& (inOwnBase(item, name) || isPartOfShadowSuffix(item, name, sclSuffix));\n \t}\n \t\n \t/**\n \t * Checks if the stated item is located inside the same classpath root as the jar that hosts ShadowClassLoader.class. {@code item} and {@code name} refer to the same thing.\n \t */\n-\tprivate boolean inOwnBase(URL item, String name) {\n+\tprivate boolean inOwnBase(String item, String name) {\n \t\tif (item == null) return false;\n-\t\tString itemString = item.toString();\n-\t\treturn (itemString.length() == SELF_BASE_LENGTH + name.length()) && SELF_BASE.regionMatches(0, itemString, 0, SELF_BASE_LENGTH);\n+\t\treturn (item.length() == SELF_BASE_LENGTH + name.length()) && SELF_BASE.regionMatches(0, item, 0, SELF_BASE_LENGTH);\n \t}\n \t\n \tprivate static boolean sclFileContainsSuffix(InputStream in, String suffix) throws IOException {\n@@ -386,12 +387,11 @@ private boolean isPartOfShadowSuffixJarBased(String jarLoc, String suffix) {\n \t\t}\n \t}\n \n-\tprivate boolean isPartOfShadowSuffix(URL item, String name, String suffix) {\n+\tprivate boolean isPartOfShadowSuffix(String url, String name, String suffix) {\n \t\t// Instead of throwing an exception or logging, weird, unexpected cases just return false.\n \t\t// This is better than throwing an exception, because exceptions would make your build tools unusable.\n \t\t// Such cases are marked with the comment: // *unexpected*\n-\t\tif (item == null) return false;\n-\t\tString url = item.toString();\n+\t\tif (url == null) return false;\n \t\tif (url.startsWith(\"file:/\")) {\n \t\t\turl = urlDecode(url.substring(5));\n \t\t\tif (url.length() <= name.length() || !url.endsWith(name) || url.charAt(url.length() - name.length() - 1) != '/') {\n@@ -436,14 +436,14 @@ private boolean isPartOfShadowSuffix(URL item, String name, String suffix) {\n \t\tEnumeration<URL> sec = super.getResources(name);\n \t\twhile (sec.hasMoreElements()) {\n \t\t\tURL item = sec.nextElement();\n-\t\t\tif (!partOfShadow(item, name)) vector.add(item);\n+\t\t\tif (!partOfShadow(item.toString(), name)) vector.add(item);\n \t\t}\n \t\t\n \t\tif (altName != null) {\n \t\t\tEnumeration<URL> tern = super.getResources(altName);\n \t\t\twhile (tern.hasMoreElements()) {\n \t\t\t\tURL item = tern.nextElement();\n-\t\t\t\tif (!partOfShadow(item, altName)) vector.add(item);\n+\t\t\t\tif (!partOfShadow(item.toString(), altName)) vector.add(item);\n \t\t\t}\n \t\t}\n \t\t\n@@ -483,11 +483,11 @@ private URL getResource_(String name, boolean noSuper) {\n \t\t\n \t\tif (altName != null) {\n \t\t\tURL res = super.getResource(altName);\n-\t\t\tif (res != null && (!noSuper || partOfShadow(res, altName))) return res;\n+\t\t\tif (res != null && (!noSuper || partOfShadow(res.toString(), altName))) return res;\n \t\t}\n \t\t\n \t\tURL res = super.getResource(name);\n-\t\tif (res != null && (!noSuper || partOfShadow(res, name))) return res;\n+\t\tif (res != null && (!noSuper || partOfShadow(res.toString(), name))) return res;\n \t\treturn null;\n \t}\n \t\n@@ -501,12 +501,12 @@ private boolean exclusionListMatch(String name) {\n \tprivate URL getResourceSkippingSelf(String name) throws IOException {\n \t\tURL candidate = super.getResource(name);\n \t\tif (candidate == null) return null;\n-\t\tif (!partOfShadow(candidate, name)) return candidate;\n+\t\tif (!partOfShadow(candidate.toString(), name)) return candidate;\n \t\t\n \t\tEnumeration<URL> en = super.getResources(name);\n \t\twhile (en.hasMoreElements()) {\n \t\t\tcandidate = en.nextElement();\n-\t\t\tif (!partOfShadow(candidate, name)) return candidate;\n+\t\t\tif (!partOfShadow(candidate.toString(), name)) return candidate;\n \t\t}\n \t\t\n \t\treturn null;",
      "parent_sha": "40570f7950dc05f90bea05396c9d23d426fe99ba"
    }
  },
  {
    "oid": "857a57cb1601773a9544d4eaed2f9fecc0741d46",
    "message": "[bugfix] eclipse version differences for weird LUB types",
    "date": "2020-07-10T00:57:45Z",
    "url": "https://github.com/projectlombok/lombok/commit/857a57cb1601773a9544d4eaed2f9fecc0741d46",
    "details": {
      "sha": "6bfcf16e963cf2926fb5d603408b4a994ff5560c",
      "filename": "src/core/lombok/eclipse/handlers/EclipseHandlerUtil.java",
      "status": "modified",
      "additions": 53,
      "deletions": 8,
      "changes": 61,
      "blob_url": "https://github.com/projectlombok/lombok/blob/857a57cb1601773a9544d4eaed2f9fecc0741d46/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FEclipseHandlerUtil.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/857a57cb1601773a9544d4eaed2f9fecc0741d46/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FEclipseHandlerUtil.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Feclipse%2Fhandlers%2FEclipseHandlerUtil.java?ref=857a57cb1601773a9544d4eaed2f9fecc0741d46",
      "patch": "@@ -330,14 +330,16 @@ static class EclipseReflectiveMembers {\n \t\tpublic static final Field STRING_LITERAL__LINE_NUMBER;\n \t\tpublic static final Field ANNOTATION__MEMBER_VALUE_PAIR_NAME;\n \t\tpublic static final Field TYPE_REFERENCE__ANNOTATIONS;\n-\t\tpublic static final Class<?> INTERSECTION_BINDING;\n-\t\tpublic static final Field INTERSECTION_BINDING_TYPES;\n+\t\tpublic static final Class<?> INTERSECTION_BINDING1, INTERSECTION_BINDING2;\n+\t\tpublic static final Field INTERSECTION_BINDING_TYPES1, INTERSECTION_BINDING_TYPES2;\n \t\tstatic {\n \t\t\tSTRING_LITERAL__LINE_NUMBER = getField(StringLiteral.class, \"lineNumber\");\n \t\t\tANNOTATION__MEMBER_VALUE_PAIR_NAME = getField(Annotation.class, \"memberValuePairName\");\n \t\t\tTYPE_REFERENCE__ANNOTATIONS = getField(TypeReference.class, \"annotations\");\n-\t\t\tINTERSECTION_BINDING = getClass(\"org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18\");\n-\t\t\tINTERSECTION_BINDING_TYPES = INTERSECTION_BINDING == null ? null : getField(INTERSECTION_BINDING, \"intersectingTypes\");\n+\t\t\tINTERSECTION_BINDING1 = getClass(\"org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18\");\n+\t\t\tINTERSECTION_BINDING2 = getClass(\"org.eclipse.jdt.internal.compiler.lookup.IntersectionCastTypeBinding\");\n+\t\t\tINTERSECTION_BINDING_TYPES1 = INTERSECTION_BINDING1 == null ? null : getField(INTERSECTION_BINDING1, \"intersectingTypes\");\n+\t\t\tINTERSECTION_BINDING_TYPES2 = INTERSECTION_BINDING2 == null ? null : getField(INTERSECTION_BINDING2, \"intersectingTypes\");\n \t\t}\n \t\t\n \t\tpublic static int reflectInt(Field f, Object o) {\n@@ -1045,11 +1047,54 @@ public static char[][] getQualifiedInnerName(EclipseNode parent, char[] name) {\n \t\t\n \t\treturn res;\n \t}\n-\n+\t\n+\tprivate static final char[] OBJECT_SIG = \"Ljava/lang/Object;\".toCharArray();\n+\t\n+\tprivate static int compare(char[] a, char[] b) {\n+\t\tif (a == null) return b == null ? 0 : -1;\n+\t\tif (b == null) return +1;\n+\t\tint len = Math.min(a.length, b.length);\n+\t\tfor (int i = 0; i < len; i++) {\n+\t\t\tif (a[i] < b[i]) return -1;\n+\t\t\tif (a[i] > b[i]) return +1;\n+\t\t}\n+\t\treturn a.length < b.length ? -1 : a.length > b.length ? +1 : 0;\n+\t}\n+\t\n \tpublic static TypeReference makeType(TypeBinding binding, ASTNode pos, boolean allowCompound) {\n-\t\tif (binding.getClass() == EclipseReflectiveMembers.INTERSECTION_BINDING) {\n-\t\t\tObject[] arr = (Object[]) EclipseReflectiveMembers.reflect(EclipseReflectiveMembers.INTERSECTION_BINDING_TYPES, binding);\n-\t\t\tbinding = (TypeBinding) arr[0];\n+\t\tObject[] arr = null;\n+\t\tif (binding.getClass() == EclipseReflectiveMembers.INTERSECTION_BINDING1) {\n+\t\t\tarr = (Object[]) EclipseReflectiveMembers.reflect(EclipseReflectiveMembers.INTERSECTION_BINDING_TYPES1, binding);\n+\t\t} else if (binding.getClass() == EclipseReflectiveMembers.INTERSECTION_BINDING2) {\n+\t\t\tarr = (Object[]) EclipseReflectiveMembers.reflect(EclipseReflectiveMembers.INTERSECTION_BINDING_TYPES2, binding);\n+\t\t}\n+\t\t\n+\t\tif (arr != null) {\n+\t\t\t// Is there a class? Alphabetically lowest wins.\n+\t\t\tTypeBinding winner = null;\n+\t\t\tint winLevel = 0; // 100 = array, 50 = class, 20 = typevar, 15 = wildcard, 10 = interface, 1 = Object.\n+\t\t\tfor (Object b : arr) {\n+\t\t\t\tif (b instanceof TypeBinding) {\n+\t\t\t\t\tTypeBinding tb = (TypeBinding) b;\n+\t\t\t\t\tint level = 0;\n+\t\t\t\t\tif (tb.isArrayType()) level = 100;\n+\t\t\t\t\telse if (tb.isClass()) level = 50;\n+\t\t\t\t\telse if (tb.isTypeVariable()) level = 20;\n+\t\t\t\t\telse if (tb.isWildcard()) level = 15;\n+\t\t\t\t\telse level = 10;\n+\t\t\t\t\t\n+\t\t\t\t\tif (level == 50 && compare(tb.signature(), OBJECT_SIG) == 0) level = 1;\n+\t\t\t\t\t\n+\t\t\t\t\tif (winLevel > level) continue;\n+\t\t\t\t\tif (winLevel < level) {\n+\t\t\t\t\t\twinner = tb;\n+\t\t\t\t\t\twinLevel = level;\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (compare(winner.signature(), tb.signature()) > 0) winner = tb;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tbinding = winner;\n \t\t}\n \t\tint dims = binding.dimensions();\n \t\tbinding = binding.leafComponentType();",
      "parent_sha": "baa3848498e8a96228e88fa0c54b9e119dba446c"
    }
  },
  {
    "oid": "3394b6ef7c00b25ad4ad4b64ac5f879aa16e4db5",
    "message": "eclipse downloader: When downloading sources, accept failure.",
    "date": "2024-10-24T20:32:51Z",
    "url": "https://github.com/projectlombok/lombok/commit/3394b6ef7c00b25ad4ad4b64ac5f879aa16e4db5",
    "details": {
      "sha": "e2ef2bbeacb79b5dda970199263401384db7b5fd",
      "filename": "src/support/lombok/eclipse/dependencies/DownloadEclipseDependencies.java",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/projectlombok/lombok/blob/3394b6ef7c00b25ad4ad4b64ac5f879aa16e4db5/src%2Fsupport%2Flombok%2Feclipse%2Fdependencies%2FDownloadEclipseDependencies.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/3394b6ef7c00b25ad4ad4b64ac5f879aa16e4db5/src%2Fsupport%2Flombok%2Feclipse%2Fdependencies%2FDownloadEclipseDependencies.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fsupport%2Flombok%2Feclipse%2Fdependencies%2FDownloadEclipseDependencies.java?ref=3394b6ef7c00b25ad4ad4b64ac5f879aa16e4db5",
      "patch": "@@ -23,7 +23,6 @@\n \n import java.io.BufferedInputStream;\n import java.io.ByteArrayInputStream;\n-import java.io.Closeable;\n import java.io.File;\n import java.io.FileOutputStream;\n import java.io.FilenameFilter;\n@@ -73,7 +72,12 @@ public static void main(String[] args) throws Exception {\n \t\t\t// Download artifact source\n \t\t\tint index = artifact.lastIndexOf(\"_\");\n \t\t\tString source = artifact.substring(0, index) + \".source\" + artifact.substring(index);\n-\t\t\tdownloadFile(source, pluginSource, pluginTarget);\n+\t\t\ttry {\n+\t\t\t\tdownloadFile(source, pluginSource, pluginTarget);\n+\t\t\t} catch (Exception e) {\n+\t\t\t\t// It's just the source; sometimes these aren't present (specifically, `org.eclipse.swt` doesn't currently appear to have the sources, at least not using the `_sources` naming scheme). Don't fail, just skip them.\n+\t\t\t\tSystem.out.println(\"[failed]\");\n+\t\t\t}\n \t\t}\n \t\t\n \t\twriteEclipseLibrary(target, eclipseVersion);",
      "parent_sha": "03cd61a9ec179689830fb948308ee2a92e554011"
    }
  },
  {
    "oid": "3b968fe57c3f816a27e5d57f1bf6060d6e4c4b4e",
    "message": "Fix binding patterns in delombok in Java 14+15",
    "date": "2023-03-22T09:22:34Z",
    "url": "https://github.com/projectlombok/lombok/commit/3b968fe57c3f816a27e5d57f1bf6060d6e4c4b4e",
    "details": {
      "sha": "35dd9d76b6bc05470666de2b8505da451e79b0af",
      "filename": "src/delombok/lombok/delombok/PrettyPrinter.java",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/projectlombok/lombok/blob/3b968fe57c3f816a27e5d57f1bf6060d6e4c4b4e/src%2Fdelombok%2Flombok%2Fdelombok%2FPrettyPrinter.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/3b968fe57c3f816a27e5d57f1bf6060d6e4c4b4e/src%2Fdelombok%2Flombok%2Fdelombok%2FPrettyPrinter.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fdelombok%2Flombok%2Fdelombok%2FPrettyPrinter.java?ref=3b968fe57c3f816a27e5d57f1bf6060d6e4c4b4e",
      "patch": "@@ -1434,7 +1434,13 @@ void printYieldExpression(JCTree tree) {\n \t\n \tvoid printBindingPattern(JCTree tree) {\n \t\tJCTree var = readObject(tree, \"var\", tree);\n-\t\tprintVarDef0((JCVariableDecl) var);\n+\t\tif (var instanceof JCVariableDecl) {\n+\t\t\tprintVarDef0((JCVariableDecl) var);\n+\t\t} else {\n+\t\t\tprint((JCExpression) readObject(var, \"vartype\", null));\n+\t\t\tprint(\" \");\n+\t\t\tprint((Name) readObject(var, \"name\", null));\n+\t\t}\n \t}\n \t\n \tvoid printDefaultCase(JCTree tree) {",
      "parent_sha": "780b75b0cb59a41ffaceba1c511833775b75df6e"
    }
  },
  {
    "oid": "0a2ed8197aa0a02249371f04cce7366b5e6b27a2",
    "message": "Potential solution for issue #913",
    "date": "2016-06-28T22:36:50Z",
    "url": "https://github.com/projectlombok/lombok/commit/0a2ed8197aa0a02249371f04cce7366b5e6b27a2",
    "details": {
      "sha": "02760e350beb1d566a5f0071bf95db9b723b64c3",
      "filename": "src/eclipseAgent/lombok/eclipse/agent/PatchDelegate.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/projectlombok/lombok/blob/0a2ed8197aa0a02249371f04cce7366b5e6b27a2/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchDelegate.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/0a2ed8197aa0a02249371f04cce7366b5e6b27a2/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchDelegate.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2FeclipseAgent%2Flombok%2Feclipse%2Fagent%2FPatchDelegate.java?ref=0a2ed8197aa0a02249371f04cce7366b5e6b27a2",
      "patch": "@@ -701,8 +701,7 @@ public DelegateRecursion(char[] type, char[] member) {\n \tprivate static void addAllMethodBindings0(List<BindingTuple> list, TypeBinding binding, Set<String> banList, char[] fieldName, ASTNode responsible) throws DelegateRecursion {\n \t\tif (binding instanceof SourceTypeBinding) {\n \t\t\tClassScope scope = ((SourceTypeBinding) binding).scope;\n-\t\t\tif (scope == null) return;\n-\t\t\tscope.environment().globalOptions.storeAnnotations = true;\n+\t\t\tif (scope != null) scope.environment().globalOptions.storeAnnotations = true;\n \t\t}\n \t\tif (binding == null) return;\n \t\t",
      "parent_sha": "b3ae90b273d7d926626546c367f7fbe6d25a6890"
    }
  },
  {
    "oid": "d7b72c41dc679ec96c1c32f7c66285f04f433536",
    "message": "fixes #1709 \u2013 boolean properties in lombok annotations, such as onlyExplicitlyIncluded, didn\u2019t work.",
    "date": "2018-06-04T18:53:01Z",
    "url": "https://github.com/projectlombok/lombok/commit/d7b72c41dc679ec96c1c32f7c66285f04f433536",
    "details": {
      "sha": "a24330fa38b54cbffbe737f3697f03badcd65608",
      "filename": "src/core/lombok/core/AnnotationValues.java",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/projectlombok/lombok/blob/d7b72c41dc679ec96c1c32f7c66285f04f433536/src%2Fcore%2Flombok%2Fcore%2FAnnotationValues.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/d7b72c41dc679ec96c1c32f7c66285f04f433536/src%2Fcore%2Flombok%2Fcore%2FAnnotationValues.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fcore%2FAnnotationValues.java?ref=d7b72c41dc679ec96c1c32f7c66285f04f433536",
      "patch": "@@ -200,12 +200,12 @@ public String getAsString(String methodName) {\n \tpublic boolean getAsBoolean(String methodName) {\n \t\tAnnotationValue v = values.get(methodName);\n \t\tif (v == null || v.valueGuesses.size() != 1) {\n-\t\t\treturn getDefaultIf(methodName, Boolean.class, false);\n+\t\t\treturn getDefaultIf(methodName, boolean.class, false);\n \t\t}\n \t\t\n-\t\tObject guess = guessToType(v.valueGuesses.get(0), Boolean.class, v, 0);\n+\t\tObject guess = guessToType(v.valueGuesses.get(0), boolean.class, v, 0);\n \t\tif (guess instanceof Boolean) return ((Boolean) guess).booleanValue();\n-\t\treturn getDefaultIf(methodName, Boolean.class, false);\n+\t\treturn getDefaultIf(methodName, boolean.class, false);\n \t}\n \t\n \tpublic <T> T getDefaultIf(String methodName, Class<T> type, T defaultValue) {\n@@ -286,47 +286,47 @@ public Object invoke(Object proxy, Method method, Object[] args) throws Throwabl\n \t}\n \t\n \tprivate Object guessToType(Object guess, Class<?> expected, AnnotationValue v, int pos) {\n-\t\tif (expected == int.class) {\n+\t\tif (expected == int.class || expected == Integer.class) {\n \t\t\tif (guess instanceof Integer || guess instanceof Short || guess instanceof Byte) {\n \t\t\t\treturn ((Number) guess).intValue();\n \t\t\t}\n \t\t}\n \t\t\n-\t\tif (expected == long.class) {\n+\t\tif (expected == long.class || expected == Long.class) {\n \t\t\tif (guess instanceof Long || guess instanceof Integer || guess instanceof Short || guess instanceof Byte) {\n \t\t\t\treturn ((Number) guess).longValue();\n \t\t\t}\n \t\t}\n \t\t\n-\t\tif (expected == short.class) {\n+\t\tif (expected == short.class || expected == Short.class) {\n \t\t\tif (guess instanceof Integer || guess instanceof Short || guess instanceof Byte) {\n \t\t\t\tint intVal = ((Number) guess).intValue();\n \t\t\t\tint shortVal = ((Number) guess).shortValue();\n \t\t\t\tif (shortVal == intVal) return shortVal;\n \t\t\t}\n \t\t}\n \t\t\n-\t\tif (expected == byte.class) {\n+\t\tif (expected == byte.class || expected == Byte.class) {\n \t\t\tif (guess instanceof Integer || guess instanceof Short || guess instanceof Byte) {\n \t\t\t\tint intVal = ((Number) guess).intValue();\n \t\t\t\tint byteVal = ((Number) guess).byteValue();\n \t\t\t\tif (byteVal == intVal) return byteVal;\n \t\t\t}\n \t\t}\n \t\t\n-\t\tif (expected == double.class) {\n+\t\tif (expected == double.class || expected == Double.class) {\n \t\t\tif (guess instanceof Number) return ((Number) guess).doubleValue();\n \t\t}\n \t\t\n-\t\tif (expected == float.class) {\n+\t\tif (expected == float.class || expected == Float.class) {\n \t\t\tif (guess instanceof Number) return ((Number) guess).floatValue();\n \t\t}\n \t\t\n-\t\tif (expected == boolean.class) {\n+\t\tif (expected == boolean.class || expected == Boolean.class) {\n \t\t\tif (guess instanceof Boolean) return ((Boolean) guess).booleanValue();\n \t\t}\n \t\t\n-\t\tif (expected == char.class) {\n+\t\tif (expected == char.class || expected == Character.class) {\n \t\t\tif (guess instanceof Character) return ((Character) guess).charValue();\n \t\t}\n \t\t\n@@ -346,7 +346,7 @@ private Object guessToType(Object guess, Class<?> expected, AnnotationValue v, i\n \t\t\t}\n \t\t}\n \t\t\n-\t\tif (Class.class == expected) {\n+\t\tif (expected == Class.class) {\n \t\t\tif (guess instanceof ClassLiteral) try {\n \t\t\t\tString classLit = ((ClassLiteral) guess).getClassName();\n \t\t\t\treturn Class.forName(toFQ(classLit));",
      "parent_sha": "6def033f13afe817fd862c05747d8eae32d5d547"
    }
  },
  {
    "oid": "49b9d073baa0039325065fa76747fa7384fa89be",
    "message": "Pre-beta-release",
    "date": "2010-11-18T19:48:54Z",
    "url": "https://github.com/projectlombok/lombok/commit/49b9d073baa0039325065fa76747fa7384fa89be",
    "details": {
      "sha": "8bd39dd4e6767b31e5475d1ac19b850aa898aee6",
      "filename": "src/core/lombok/core/Version.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/projectlombok/lombok/blob/49b9d073baa0039325065fa76747fa7384fa89be/src%2Fcore%2Flombok%2Fcore%2FVersion.java",
      "raw_url": "https://github.com/projectlombok/lombok/raw/49b9d073baa0039325065fa76747fa7384fa89be/src%2Fcore%2Flombok%2Fcore%2FVersion.java",
      "contents_url": "https://api.github.com/repos/projectlombok/lombok/contents/src%2Fcore%2Flombok%2Fcore%2FVersion.java?ref=49b9d073baa0039325065fa76747fa7384fa89be",
      "patch": "@@ -26,8 +26,8 @@\n  */\n public class Version {\n \t// ** CAREFUL ** - this class must always compile with 0 dependencies (it must not refer to any other sources or libraries).\n-\tprivate static final String VERSION = \"0.9.4-EDGE\";\n-\tprivate static final String RELEASE_NAME = \"burrowing whale\";\n+\tprivate static final String VERSION = \"0.10.0-BETA1\";\n+\tprivate static final String RELEASE_NAME = \"Burning Emu\";\n \t\n \tprivate Version() {\n \t\t//Prevent instantiation",
      "parent_sha": "ca24a4c3ec6c328463a07ce171c413f96be14d95"
    }
  }
]