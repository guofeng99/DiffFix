[
  {
    "oid": "d8b9c93243a891c864cf5bcb2013014d9272b14c",
    "message": "Revert \"Removed some unnecessary Observable.single() calls.\"\n\nThis reverts commit 0674ed699b5d71a653fa3f802e79307510458915.",
    "date": "2015-09-01T19:52:11Z",
    "url": "https://github.com/Netflix/zuul/commit/d8b9c93243a891c864cf5bcb2013014d9272b14c",
    "details": {
      "sha": "739b32cc382a52aff23cceed28cb06965e8518af",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/FilterProcessor.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/zuul/blob/d8b9c93243a891c864cf5bcb2013014d9272b14c/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/d8b9c93243a891c864cf5bcb2013014d9272b14c/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java?ref=d8b9c93243a891c864cf5bcb2013014d9272b14c",
      "patch": "@@ -219,7 +219,7 @@ protected Observable<ZuulMessage> applyFilterPhase(Observable<ZuulMessage> chain\n     {\n         List<ZuulFilter> filters = filterLoader.getFiltersByType(filterType);\n         for (ZuulFilter filter: filters) {\n-            chain = processFilterAsObservable(chain, filter, defaultFilterResultChooser);\n+            chain = processFilterAsObservable(chain, filter, defaultFilterResultChooser).single();\n         }\n         return chain;\n     }\n@@ -268,7 +268,7 @@ else if (msg.getContext().shouldStopFilterProcessing()) {\n                 // equal or above the requested.\n                 int requiredPriority = msg.getContext().getFilterPriorityToApply();\n                 if (isFilterPriority(filter, requiredPriority) && filter.shouldFilter(msg)) {\n-                    resultObs = filter.applyAsync(msg);\n+                    resultObs = filter.applyAsync(msg).single();\n                 } else {\n                     resultObs = Observable.just(defaultFilterResultChooser.call(msg));\n                     info.status = ExecutionStatus.SKIPPED;",
      "parent_sha": "721ea14d566bda74a94fdcff5555f8666fb631d4"
    }
  },
  {
    "oid": "bf1781196475e9534d18f61c88889694c45c1191",
    "message": "zuul-core: modernize FilterTest",
    "date": "2019-10-07T23:46:34Z",
    "url": "https://github.com/Netflix/zuul/commit/bf1781196475e9534d18f61c88889694c45c1191",
    "details": {
      "sha": "1266ec133b17e7f5b1898d281bb3e0def2882be6",
      "filename": "zuul-core/src/test/java/com/netflix/zuul/scriptManager/FilterVerifierTest.java",
      "status": "modified",
      "additions": 26,
      "deletions": 97,
      "changes": 123,
      "blob_url": "https://github.com/Netflix/zuul/blob/bf1781196475e9534d18f61c88889694c45c1191/zuul-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FscriptManager%2FFilterVerifierTest.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/bf1781196475e9534d18f61c88889694c45c1191/zuul-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FscriptManager%2FFilterVerifierTest.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FscriptManager%2FFilterVerifierTest.java?ref=bf1781196475e9534d18f61c88889694c45c1191",
      "patch": "@@ -19,15 +19,13 @@\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertThrows;\n \n import com.netflix.zuul.filters.FilterType;\n import org.codehaus.groovy.control.CompilationFailedException;\n-import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n-import org.mockito.MockitoAnnotations;\n \n \n /**\n@@ -36,7 +34,7 @@\n @RunWith(JUnit4.class)\n public class FilterVerifierTest {\n \n-    String sGoodGroovyScriptFilter = \"import com.netflix.zuul.filters.*\\n\" +\n+    private final String sGoodGroovyScriptFilter = \"import com.netflix.zuul.filters.*\\n\" +\n         \"import com.netflix.zuul.context.*\\n\" +\n         \"import com.netflix.zuul.message.*\\n\" +\n         \"import com.netflix.zuul.message.http.*\\n\" +\n@@ -62,7 +60,7 @@ public class FilterVerifierTest {\n         \"\\n\" +\n         \"}\";\n \n-    String sNotZuulFilterGroovy = \"import com.netflix.zuul.filters.*\\n\" +\n+    private final String sNotZuulFilterGroovy = \"import com.netflix.zuul.filters.*\\n\" +\n         \"import com.netflix.zuul.context.*\\n\" +\n         \"import com.netflix.zuul.message.*\\n\" +\n         \"import com.netflix.zuul.message.http.*\\n\" +\n@@ -88,7 +86,7 @@ public class FilterVerifierTest {\n         \"\\n\" +\n         \"}\";\n \n-    String sCompileFailCode = \"import com.netflix.zuul.filters.*\\n\" +\n+    private final String sCompileFailCode = \"import com.netflix.zuul.filters.*\\n\" +\n         \"import com.netflix.zuul.context.*\\n\" +\n         \"import com.netflix.zuul.message.*\\n\" +\n         \"import com.netflix.zuul.message.http.*\\n\" +\n@@ -114,112 +112,43 @@ public class FilterVerifierTest {\n         \"\\n\" +\n         \"}\";\n \n-\n-    @Before\n-    public void before() {\n-        MockitoAnnotations.initMocks(this);\n-    }\n-\n     @Test\n     public void testCompile() {\n-        Class filterClass = FilterVerifier.INSTANCE.compileGroovy(sGoodGroovyScriptFilter);\n+        Class<?> filterClass = FilterVerifier.INSTANCE.compileGroovy(sGoodGroovyScriptFilter);\n         assertNotNull(filterClass);\n         filterClass = FilterVerifier.INSTANCE.compileGroovy(sNotZuulFilterGroovy);\n         assertNotNull(filterClass);\n \n-        try {\n-            filterClass = FilterVerifier.INSTANCE.compileGroovy(sCompileFailCode);\n-            assertFalse(true); //we shouldn't get here\n-        } catch (Exception e) {\n-            assertTrue(true);\n-        }\n+        assertThrows(CompilationFailedException.class, () -> FilterVerifier.INSTANCE.compileGroovy(sCompileFailCode));\n     }\n \n     @Test\n-    public void testZuulFilterInstance() {\n-        Class filterClass = FilterVerifier.INSTANCE.compileGroovy(sGoodGroovyScriptFilter);\n+    public void testZuulFilterInstance() throws Exception {\n+        Class<?> filterClass = FilterVerifier.INSTANCE.compileGroovy(sGoodGroovyScriptFilter);\n         assertNotNull(filterClass);\n-        try {\n-            Object filter = FilterVerifier.INSTANCE.instanciateClass(filterClass);\n-            try {\n-                FilterVerifier.INSTANCE.checkZuulFilterInstance(filter);\n-            } catch (InstantiationException e) {\n-                e.printStackTrace();\n-                assertFalse(true); //we shouldn't get here\n-            }\n-        } catch (InstantiationException e) {\n-            e.printStackTrace();\n-            assertFalse(true); //we shouldn't get here\n-        } catch (IllegalAccessException e) {\n-            e.printStackTrace();\n-            assertFalse(true); //we shouldn't get here\n-        }\n+\n+        Object filter1 = FilterVerifier.INSTANCE.instanciateClass(filterClass);\n+        FilterVerifier.INSTANCE.checkZuulFilterInstance(filter1);\n \n         filterClass = FilterVerifier.INSTANCE.compileGroovy(sNotZuulFilterGroovy);\n         assertNotNull(filterClass);\n-        try {\n-            Object filter = FilterVerifier.INSTANCE.instanciateClass(filterClass);\n-            try {\n-                FilterVerifier.INSTANCE.checkZuulFilterInstance(filter);\n-                assertFalse(true); //we shouldn't get here\n-            } catch (InstantiationException e) {\n-                e.printStackTrace();\n-                assertTrue(true); //this\n-            }\n-        } catch (InstantiationException e) {\n-            e.printStackTrace();\n-            assertFalse(true); //we shouldn't get here\n-        } catch (IllegalAccessException e) {\n-            e.printStackTrace();\n-            assertFalse(true); //we shouldn't get here\n-        }\n-    }\n \n+        Object filter2 = FilterVerifier.INSTANCE.instanciateClass(filterClass);\n+        assertThrows(InstantiationException.class, () -> FilterVerifier.INSTANCE.checkZuulFilterInstance(filter2));\n+    }\n \n     @Test\n-    public void testVerify() {\n-\n-        try {\n-            FilterInfo filterInfo = FilterVerifier.INSTANCE.verifyFilter(sGoodGroovyScriptFilter);\n-            assertNotNull(filterInfo);\n-            assertEquals(filterInfo.getFilterID(), \"null:filter:in\");\n-            assertEquals(filterInfo.getFilterType(), FilterType.INBOUND);\n-            assertEquals(filterInfo.getFilterName(), \"filter\");\n-            assertFalse(filterInfo.isActive());\n-            assertFalse(filterInfo.isCanary());\n-\n-\n-        } catch (InstantiationException e) {\n-            e.printStackTrace();\n-            assertFalse(true); //we shouldn't get here\n-        } catch (IllegalAccessException e) {\n-            e.printStackTrace();\n-            assertFalse(true); //we shouldn't get here\n-        }\n-\n-        try {\n-            FilterInfo filterInfo = FilterVerifier.INSTANCE.verifyFilter(sNotZuulFilterGroovy);\n-            assertFalse(true);// shouldn't get here\n-        } catch (InstantiationException e) {\n-            e.printStackTrace();\n-            assertTrue(true); //we shouldn't get here\n-        } catch (IllegalAccessException e) {\n-            e.printStackTrace();\n-            assertFalse(true); //we shouldn't get here\n-        }\n-\n-        try {\n-            FilterInfo filterInfo = FilterVerifier.INSTANCE.verifyFilter(sCompileFailCode);\n-            assertFalse(true);// shouldn't get here\n-        } catch (CompilationFailedException e) {\n-            assertTrue(true); //we shouldn't get here\n-        } catch (InstantiationException e) {\n-            e.printStackTrace();\n-            assertFalse(true); //we shouldn't get here\n-        } catch (IllegalAccessException e) {\n-            e.printStackTrace();\n-            assertFalse(true); //we shouldn't get here\n-        }\n-\n+    public void testVerify() throws Exception {\n+        FilterInfo filterInfo1 = FilterVerifier.INSTANCE.verifyFilter(sGoodGroovyScriptFilter);\n+        assertNotNull(filterInfo1);\n+        assertEquals(filterInfo1.getFilterID(), \"null:filter:in\");\n+        assertEquals(filterInfo1.getFilterType(), FilterType.INBOUND);\n+        assertEquals(filterInfo1.getFilterName(), \"filter\");\n+        assertFalse(filterInfo1.isActive());\n+        assertFalse(filterInfo1.isCanary());\n+\n+        assertThrows(InstantiationException.class, () -> FilterVerifier.INSTANCE.verifyFilter(sNotZuulFilterGroovy));\n+\n+        assertThrows(CompilationFailedException.class, () -> FilterVerifier.INSTANCE.verifyFilter(sCompileFailCode));\n     }\n }",
      "parent_sha": "3eac370d6f8d2f995dd734531cdc8e5038a472ad"
    }
  },
  {
    "oid": "1742abbbb2f116bcdb3a3cd8ac53185bad441b65",
    "message": "zuul-core: fix direct memory usage by passing non-null ref",
    "date": "2020-04-28T04:04:53Z",
    "url": "https://github.com/Netflix/zuul/commit/1742abbbb2f116bcdb3a3cd8ac53185bad441b65",
    "details": {
      "sha": "065886bec995c63476b24b592dcd37bb38b3947e",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/server/DirectMemoryMonitor.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/zuul/blob/1742abbbb2f116bcdb3a3cd8ac53185bad441b65/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FDirectMemoryMonitor.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/1742abbbb2f116bcdb3a3cd8ac53185bad441b65/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FDirectMemoryMonitor.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FDirectMemoryMonitor.java?ref=1742abbbb2f116bcdb3a3cd8ac53185bad441b65",
      "patch": "@@ -99,14 +99,14 @@ public DirectMemoryMonitor(Registry registry) {\n                     .withName(PROP_PREFIX + \".reserved\")\n                     .withDelay(Duration.ofSeconds(TASK_DELAY_PROP.get()))\n                     .scheduleOn(service)\n-                    .monitorValue(null, DirectMemoryMonitor::getReservedMemory);\n+                    .monitorValue(DirectMemoryMonitor.class, DirectMemoryMonitor::getReservedMemory);\n         }\n         if (directMemoryLimitGetter != null) {\n             PolledMeter.using(registry)\n                     .withName(PROP_PREFIX + \".max\")\n                     .withDelay(Duration.ofSeconds(TASK_DELAY_PROP.get()))\n                     .scheduleOn(service)\n-                    .monitorValue(null, DirectMemoryMonitor::getMaxMemory);\n+                    .monitorValue(DirectMemoryMonitor.class, DirectMemoryMonitor::getMaxMemory);\n         }\n     }\n ",
      "parent_sha": "cab193ed7b269fcf9addd8ddda642d8b42906d7f"
    }
  },
  {
    "oid": "6a80b9c70e15e208fc8fb1674428cbe96687d7db",
    "message": "In ProxyEndpoint we need to also invoked origin.onRequestExceptionWithServer() for non-throttling errors too",
    "date": "2018-12-05T23:18:47Z",
    "url": "https://github.com/Netflix/zuul/commit/6a80b9c70e15e208fc8fb1674428cbe96687d7db",
    "details": {
      "sha": "ee0068aa171da9ff7f69575109da87eca8b563d7",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/filters/endpoint/ProxyEndpoint.java",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/Netflix/zuul/blob/6a80b9c70e15e208fc8fb1674428cbe96687d7db/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/6a80b9c70e15e208fc8fb1674428cbe96687d7db/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java?ref=6a80b9c70e15e208fc8fb1674428cbe96687d7db",
      "patch": "@@ -35,7 +35,6 @@\n import com.netflix.zuul.exception.OutboundException;\n import com.netflix.zuul.exception.ZuulException;\n import com.netflix.zuul.filters.SyncZuulFilterAdapter;\n-import com.netflix.zuul.message.Header;\n import com.netflix.zuul.message.HeaderName;\n import com.netflix.zuul.message.Headers;\n import com.netflix.zuul.message.ZuulMessage;\n@@ -847,10 +846,12 @@ protected void handleOriginNonSuccessResponse(final HttpResponse originResponse,\n         final int respStatus = originResponse.status().code();\n         OutboundException obe;\n         StatusCategory statusCategory;\n+        ClientException.ErrorType niwsErrorType;\n \n         if (respStatus == 503) {\n             //Treat 503 status from Origin similarly to connection failures, ie. we want to back off from this server\n             statusCategory = FAILURE_ORIGIN_THROTTLED;\n+            niwsErrorType = ClientException.ErrorType.SERVER_THROTTLED;\n             obe = new OutboundException(OutboundErrorType.SERVICE_UNAVAILABLE, requestAttempts);\n             if (originConn != null) {\n                 originConn.getServerStats().incrementSuccessiveConnectionFailureCount();\n@@ -863,6 +864,7 @@ protected void handleOriginNonSuccessResponse(final HttpResponse originResponse,\n             }\n         } else {\n             statusCategory = FAILURE_ORIGIN;\n+            niwsErrorType = ClientException.ErrorType.GENERAL;\n             obe = new OutboundException(OutboundErrorType.ERROR_STATUS_RESPONSE, requestAttempts);\n             if (requestStat != null) {\n                 requestStat.updateWithHttpStatusCode(respStatus);\n@@ -881,11 +883,9 @@ protected void handleOriginNonSuccessResponse(final HttpResponse originResponse,\n             currentRequestAttempt.complete(respStatus, duration, obe);\n         }\n \n-        // If throttled by origin server, then we also need to invoke onRequestExceptionWithServer().\n-        if (statusCategory == FAILURE_ORIGIN_THROTTLED) {\n-            origin.onRequestExceptionWithServer(zuulRequest, chosenServer, attemptNum,\n-                    new ClientException(ClientException.ErrorType.SERVER_THROTTLED));\n-        }\n+        // Flag this error with the ExecutionListener.\n+        origin.onRequestExceptionWithServer(zuulRequest, chosenServer, attemptNum,\n+                new ClientException(niwsErrorType));\n \n         if ((isBelowRetryLimit()) && (isRetryable5xxResponse(zuulRequest, originResponse))) {\n             LOG.debug(\"Retrying: status={}, attemptNum={}, maxRetries={}, startedSendingResponseToClient={}, hasCompleteBody={}, method={}\",",
      "parent_sha": "a5030c8ef0eda30df347f49107614c7c4b6e987e"
    }
  },
  {
    "oid": "4763087e38136e709985e8958bccc5e7b4473926",
    "message": "add gauge for tracking concurrent requests and counter for rejected ones",
    "date": "2018-05-02T23:34:28Z",
    "url": "https://github.com/Netflix/zuul/commit/4763087e38136e709985e8958bccc5e7b4473926",
    "details": {
      "sha": "432f659d0ca0d19ce3ed0b6bfe91de4410fb72ff",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/origins/BasicNettyOrigin.java",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/Netflix/zuul/blob/4763087e38136e709985e8958bccc5e7b4473926/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Forigins%2FBasicNettyOrigin.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/4763087e38136e709985e8958bccc5e7b4473926/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Forigins%2FBasicNettyOrigin.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Forigins%2FBasicNettyOrigin.java?ref=4763087e38136e709985e8958bccc5e7b4473926",
      "patch": "@@ -24,13 +24,15 @@\n import com.netflix.loadbalancer.Server;\n import com.netflix.loadbalancer.reactive.ExecutionContext;\n import com.netflix.niws.loadbalancer.DiscoveryEnabledServer;\n+import com.netflix.spectator.api.Counter;\n import com.netflix.spectator.api.Registry;\n import com.netflix.zuul.context.CommonContextKeys;\n import com.netflix.zuul.context.SessionContext;\n import com.netflix.zuul.exception.ErrorType;\n import com.netflix.zuul.message.http.HttpRequestMessage;\n import com.netflix.zuul.message.http.HttpResponseMessage;\n import com.netflix.zuul.netty.NettyRequestAttemptFactory;\n+import com.netflix.zuul.netty.SpectatorUtils;\n import com.netflix.zuul.netty.connectionpool.ClientChannelManager;\n import com.netflix.zuul.netty.connectionpool.DefaultClientChannelManager;\n import com.netflix.zuul.netty.connectionpool.PooledConnection;\n@@ -67,6 +69,7 @@ public class BasicNettyOrigin implements NettyOrigin {\n     private final NettyRequestAttemptFactory requestAttemptFactory;\n \n     private final AtomicInteger concurrentRequests;\n+    private final Counter rejectedRequests;\n     private final CachedDynamicIntProperty concurrencyMax;\n     private final CachedDynamicBooleanProperty concurrencyProtectionEnabled;\n \n@@ -79,7 +82,8 @@ public BasicNettyOrigin(String name, String vip, Registry registry) {\n         this.clientChannelManager.init();\n         this.requestAttemptFactory = new NettyRequestAttemptFactory();\n \n-        this.concurrentRequests = new AtomicInteger(0);\n+        this.concurrentRequests = SpectatorUtils.newGauge(\"zuul.origin.concurrent.requests\", name, new AtomicInteger(0));\n+        this.rejectedRequests = SpectatorUtils.newCounter(\"zuul.origin.rejected.requests\", name);\n         this.concurrencyMax = new CachedDynamicIntProperty(\"zuul.origin.\" + name + \".concurrency.max.requests\", 200);\n         this.concurrencyProtectionEnabled = new CachedDynamicBooleanProperty(\"zuul.origin.\" + name + \".concurrency.protect.enabled\", true);\n     }\n@@ -221,6 +225,7 @@ else if (StatusCategoryUtils.isResponseHttpErrorStatus(originStatusCode)) {\n     @Override\n     public void preRequestChecks(HttpRequestMessage zuulRequest) {\n         if (concurrencyProtectionEnabled.get() && concurrentRequests.get() > concurrencyMax.get()) {\n+            rejectedRequests.increment();\n             throw new OriginConcurrencyExceededException(getName());\n         }\n ",
      "parent_sha": "480581fab6a8f45e85a184c61641ecc5bd93b106"
    }
  },
  {
    "oid": "5bfd822c268184826898231365dcc2bcc2752299",
    "message": "Properly apply socket options (#1638)",
    "date": "2023-09-11T15:53:37Z",
    "url": "https://github.com/Netflix/zuul/commit/5bfd822c268184826898231365dcc2bcc2752299",
    "details": {
      "sha": "ad18914db8136b623b1c0c2a21442c1c8d04a99c",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/server/Server.java",
      "status": "modified",
      "additions": 5,
      "deletions": 11,
      "changes": 16,
      "blob_url": "https://github.com/Netflix/zuul/blob/5bfd822c268184826898231365dcc2bcc2752299/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FServer.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/5bfd822c268184826898231365dcc2bcc2752299/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FServer.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FServer.java?ref=5bfd822c268184826898231365dcc2bcc2752299",
      "patch": "@@ -269,20 +269,14 @@ private ChannelFuture setupServerBootstrap(\n         ServerBootstrap serverBootstrap =\n                 new ServerBootstrap().group(serverGroup.clientToProxyBossPool, serverGroup.clientToProxyWorkerPool);\n \n-        // Choose socket options.\n-        Map<ChannelOption<?>, Object> channelOptions = new HashMap<>();\n-        channelOptions.put(ChannelOption.SO_BACKLOG, 128);\n-        channelOptions.put(ChannelOption.SO_LINGER, -1);\n-        channelOptions.put(ChannelOption.TCP_NODELAY, true);\n-        channelOptions.put(ChannelOption.SO_KEEPALIVE, true);\n-\n         LOG.info(\"Proxy listening with {}\", serverGroup.channelType);\n         serverBootstrap.channel(serverGroup.channelType);\n \n-        // Apply socket options.\n-        for (Map.Entry<ChannelOption<?>, ?> optionEntry : channelOptions.entrySet()) {\n-            serverBootstrap = serverBootstrap.option((ChannelOption) optionEntry.getKey(), optionEntry.getValue());\n-        }\n+        serverBootstrap.option(ChannelOption.SO_BACKLOG, 128);\n+        serverBootstrap.childOption(ChannelOption.SO_LINGER, -1);\n+        serverBootstrap.childOption(ChannelOption.TCP_NODELAY, true);\n+        serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, true);\n+\n         // Apply transport specific socket options.\n         for (Map.Entry<ChannelOption<?>, ?> optionEntry : serverGroup.transportChannelOptions.entrySet()) {\n             serverBootstrap = serverBootstrap.option((ChannelOption) optionEntry.getKey(), optionEntry.getValue());",
      "parent_sha": "61f7cea20b70bfa2a878fb397b314cc794adaf1f"
    }
  },
  {
    "oid": "85c939a725fb05fa1864def796d4a86fa80bbabd",
    "message": "Copy the X509 cert from ServletRequest attributes to the SessionContext.",
    "date": "2015-07-30T03:25:50Z",
    "url": "https://github.com/Netflix/zuul/commit/85c939a725fb05fa1864def796d4a86fa80bbabd",
    "details": {
      "sha": "d047a014b20e3d6dbb24b312d899eeaac28916c5",
      "filename": "zuul-servletapi/src/main/java/com/netflix/zuul/context/ServletSessionContextFactory.java",
      "status": "modified",
      "additions": 16,
      "deletions": 2,
      "changes": 18,
      "blob_url": "https://github.com/Netflix/zuul/blob/85c939a725fb05fa1864def796d4a86fa80bbabd/zuul-servletapi%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fcontext%2FServletSessionContextFactory.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/85c939a725fb05fa1864def796d4a86fa80bbabd/zuul-servletapi%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fcontext%2FServletSessionContextFactory.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-servletapi%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fcontext%2FServletSessionContextFactory.java?ref=85c939a725fb05fa1864def796d4a86fa80bbabd",
      "patch": "@@ -20,7 +20,10 @@\n import com.netflix.zuul.message.Header;\n import com.netflix.zuul.message.Headers;\n import com.netflix.zuul.message.ZuulMessage;\n-import com.netflix.zuul.message.http.*;\n+import com.netflix.zuul.message.http.HttpQueryParams;\n+import com.netflix.zuul.message.http.HttpRequestMessage;\n+import com.netflix.zuul.message.http.HttpRequestMessageImpl;\n+import com.netflix.zuul.message.http.HttpResponseMessage;\n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.Unpooled;\n import org.slf4j.Logger;\n@@ -33,8 +36,8 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.net.SocketTimeoutException;\n+import java.security.cert.X509Certificate;\n import java.util.Enumeration;\n-import java.util.Map;\n \n /**\n  * User: michaels@netflix.com\n@@ -44,6 +47,7 @@\n public class ServletSessionContextFactory implements SessionContextFactory<HttpServletRequest, HttpServletResponse>\n {\n     private static final Logger LOG = LoggerFactory.getLogger(ServletSessionContextFactory.class);\n+    private static final String JAVAX_SERVLET_REQUEST_X509_CERTIFICATE = \"javax.servlet.request.X509Certificate\";\n \n     @Override\n     public ZuulMessage create(SessionContext context, HttpServletRequest servletRequest)\n@@ -125,6 +129,16 @@ private void copyServletRequestAttributes(SessionContext context, HttpServletReq\n                 context.put(attrName.substring(zuulAttrPrefix.length()), servletRequest.getAttribute(attrName));\n             }\n         }\n+\n+        copyServletRequestX509Attributes(context, servletRequest);\n+    }\n+\n+    private void copyServletRequestX509Attributes(SessionContext context, HttpServletRequest servletRequest)\n+    {\n+        // Copy X509 request attribute into the context.\n+        X509Certificate[] certs = (X509Certificate[]) servletRequest.getAttribute(JAVAX_SERVLET_REQUEST_X509_CERTIFICATE);\n+        if (certs != null)\n+            context.set(JAVAX_SERVLET_REQUEST_X509_CERTIFICATE, certs);\n     }\n \n     @Override",
      "parent_sha": "7365b961f01d5b9b5eb77304daccba76ffd47334"
    }
  },
  {
    "oid": "0bdae8d738cd579d1bab23fa8f10f9acb941ccf9",
    "message": "Remove now unnecessary addServerMetrics empty method from DefaultClientChannelManager",
    "date": "2018-01-09T20:28:07Z",
    "url": "https://github.com/Netflix/zuul/commit/0bdae8d738cd579d1bab23fa8f10f9acb941ccf9",
    "details": {
      "sha": "f10d47ef7a2041ddc5eb331dae87a59f880d8f7c",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/connectionpool/DefaultClientChannelManager.java",
      "status": "modified",
      "additions": 1,
      "deletions": 16,
      "changes": 17,
      "blob_url": "https://github.com/Netflix/zuul/blob/0bdae8d738cd579d1bab23fa8f10f9acb941ccf9/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fconnectionpool%2FDefaultClientChannelManager.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/0bdae8d738cd579d1bab23fa8f10f9acb941ccf9/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fconnectionpool%2FDefaultClientChannelManager.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fconnectionpool%2FDefaultClientChannelManager.java?ref=0bdae8d738cd579d1bab23fa8f10f9acb941ccf9",
      "patch": "@@ -19,11 +19,7 @@\n import com.google.common.collect.Sets;\n import com.netflix.appinfo.InstanceInfo;\n import com.netflix.client.config.IClientConfig;\n-import com.netflix.loadbalancer.DynamicServerListLoadBalancer;\n-import com.netflix.loadbalancer.LoadBalancerStats;\n-import com.netflix.loadbalancer.Server;\n-import com.netflix.loadbalancer.ServerStats;\n-import com.netflix.loadbalancer.ZoneAwareLoadBalancer;\n+import com.netflix.loadbalancer.*;\n import com.netflix.niws.loadbalancer.DiscoveryEnabledServer;\n import com.netflix.spectator.api.Counter;\n import com.netflix.spectator.api.Registry;\n@@ -166,17 +162,6 @@ protected void removeMissingServerConnectionPools(List<Server> oldList, List<Ser\n                 }\n             }\n         }\n-\n-        try {\n-            addServerMetrics(newSet);\n-        }\n-        catch (Throwable t) {\n-            LOG.warn(\"Could not update server list for Zuul Netty Metrics Registry.\", t);\n-        }\n-    }\n-\n-    protected void addServerMetrics(Set<Server> newSet) {\n-        // override for server metrics\n     }\n \n     @Override",
      "parent_sha": "c1ae561358e6841bd24c5efcfdfe438ebc86baba"
    }
  },
  {
    "oid": "e75bf502070a7c20afae3dc549207498c1e28a60",
    "message": "Change the default TCP Passthrough (NLB) port to be different from ELB",
    "date": "2018-06-29T20:09:25Z",
    "url": "https://github.com/Netflix/zuul/commit/e75bf502070a7c20afae3dc549207498c1e28a60",
    "details": {
      "sha": "4205a4550d81bf0c2bead126b5de4ef8b606c0d6",
      "filename": "zuul-core/src/main/java/com/netflix/netty/common/SourceAddressChannelHandler.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/zuul/blob/e75bf502070a7c20afae3dc549207498c1e28a60/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fnetty%2Fcommon%2FSourceAddressChannelHandler.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/e75bf502070a7c20afae3dc549207498c1e28a60/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fnetty%2Fcommon%2FSourceAddressChannelHandler.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fnetty%2Fcommon%2FSourceAddressChannelHandler.java?ref=e75bf502070a7c20afae3dc549207498c1e28a60",
      "patch": "@@ -47,7 +47,7 @@ public class SourceAddressChannelHandler extends ChannelInboundHandlerAdapter\n \n     public static final AttributeKey<Boolean> ATTR_TCP_PASSTHROUGH_INBOUND_CONN = AttributeKey.newInstance(\"_tcp_passthrough_inbound_conn\");\n     public static final DynamicIntProperty INBOUND_TCP_PASSTHROUGH__PORT =\n-            new DynamicIntProperty(\"zuul.server.port.tcp.passthrough\", 7006);\n+            new DynamicIntProperty(\"zuul.server.port.tcp.passthrough\", 7009);\n \n     @Override\n     public void channelActive(ChannelHandlerContext ctx) throws Exception",
      "parent_sha": "c34a5e47562b379d84ece323a8729985649b60cd"
    }
  },
  {
    "oid": "4edecb06d56bec7deb4f62fb91e1f59d87f60903",
    "message": "ensure we release FullHttpResponse messages",
    "date": "2023-01-24T18:44:45Z",
    "url": "https://github.com/Netflix/zuul/commit/4edecb06d56bec7deb4f62fb91e1f59d87f60903",
    "details": {
      "sha": "6ac1813d96e07b7ce238cc7caa55a873c6a69e5d",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/server/OriginResponseReceiver.java",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/Netflix/zuul/blob/4edecb06d56bec7deb4f62fb91e1f59d87f60903/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FOriginResponseReceiver.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/4edecb06d56bec7deb4f62fb91e1f59d87f60903/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FOriginResponseReceiver.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FOriginResponseReceiver.java?ref=4edecb06d56bec7deb4f62fb91e1f59d87f60903",
      "patch": "@@ -83,16 +83,18 @@ private void channelReadInternal(final ChannelHandlerContext ctx, Object msg) th\n         if (msg instanceof HttpResponse) {\n             if (edgeProxy != null) {\n                 edgeProxy.responseFromOrigin((HttpResponse) msg);\n+            } else if (ReferenceCountUtil.refCnt(msg) > 0){\n+                // this handles the case of a DefaultHttpResponse that could have content that needs to be released\n+                ReferenceCountUtil.safeRelease(msg);\n             }\n             ctx.channel().read();\n         }\n         else if (msg instanceof HttpContent) {\n             final HttpContent chunk = (HttpContent) msg;\n             if (edgeProxy != null) {\n                 edgeProxy.invokeNext(chunk);\n-            }\n-            else {\n-                chunk.release();\n+            } else {\n+                ReferenceCountUtil.safeRelease(chunk);\n             }\n             ctx.channel().read();\n         }",
      "parent_sha": "b9c868ca16522781f3e4009b90e6bd0a0e132acc"
    }
  },
  {
    "oid": "b9c23a3312b0211914fc4eea42dd99ddc9754087",
    "message": "Add helper method to retrieve headers",
    "date": "2014-04-08T00:24:42Z",
    "url": "https://github.com/Netflix/zuul/commit/b9c23a3312b0211914fc4eea42dd99ddc9754087",
    "details": {
      "sha": "4bf036411b72c99db0fd7633cdd0f6dd2d9a2a00",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/util/HTTPRequestUtils.java",
      "status": "modified",
      "additions": 201,
      "deletions": 170,
      "changes": 371,
      "blob_url": "https://github.com/Netflix/zuul/blob/b9c23a3312b0211914fc4eea42dd99ddc9754087/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Futil%2FHTTPRequestUtils.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/b9c23a3312b0211914fc4eea42dd99ddc9754087/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Futil%2FHTTPRequestUtils.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Futil%2FHTTPRequestUtils.java?ref=b9c23a3312b0211914fc4eea42dd99ddc9754087",
      "patch": "@@ -16,12 +16,17 @@\n package com.netflix.zuul.util;\n \n import com.netflix.zuul.context.RequestContext;\n+\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import javax.servlet.http.HttpServletRequest;\n+\n import java.net.URLDecoder;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Enumeration;\n import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n@@ -40,175 +45,201 @@\n  * Time: 8:22 AM\n  */\n public class HTTPRequestUtils {\n-    \n-    private final static HTTPRequestUtils INSTANCE = new HTTPRequestUtils();\n-    \n-    public static final String X_FORWARDED_FOR_HEADER = \"x-forwarded-for\";\n-\n-\n-    /**\n-     * Get the IP address of client making the request.\n-     *\n-     * Uses the \"x-forwarded-for\" HTTP header if available, otherwise uses the remote\n-     * IP of requester.\n-     *\n-     * @param request <code>HttpServletRequest</code>\n-     * @return <code>String</code> IP address\n-     */\n-    public String getClientIP(HttpServletRequest request) {\n-        final String xForwardedFor = request.getHeader(X_FORWARDED_FOR_HEADER);\n-        String clientIP = null;\n-        if (xForwardedFor == null) {\n-            clientIP = request.getRemoteAddr();\n-        } else {\n-            clientIP = extractClientIpFromXForwardedFor(xForwardedFor);\n-        }\n-        return clientIP;\n-    }\n-\n-    /**\n-     * Extract the client IP address from an x-forwarded-for header. Returns null if there is no x-forwarded-for header\n-     *\n-     * @param xForwardedFor a <code>String</code> value\n-     * @return a <code>String</code> value\n-     */\n-    public final String extractClientIpFromXForwardedFor(String xForwardedFor) {\n-        if (xForwardedFor == null) {\n-            return null;\n-        }\n-        xForwardedFor = xForwardedFor.trim();\n-        String tokenized[] = xForwardedFor.split(\",\");\n-        if (tokenized.length == 0) {\n-            return null;\n-        } else {\n-            return tokenized[0].trim();\n-        }\n-    }\n-\n-    /**\n-     * return singleton HTTPRequestUtils object\n-     *\n-     * @return a <code>HTTPRequestUtils</code> value\n-     */\n-    public static HTTPRequestUtils getInstance() {\n-        return INSTANCE;\n-    }\n-\n-    /**\n-     * returns the Header value for the given sHeaderName\n-     *\n-     * @param sHeaderName a <code>String</code> value\n-     * @return a <code>String</code> value\n-     */\n-    public String getHeaderValue(String sHeaderName) {\n-        return RequestContext.getCurrentContext().getRequest().getHeader(sHeaderName);\n-    }\n-\n-    /**\n-     * returns a form value from a given sHeaderName\n-     *\n-     * @param sHeaderName a <code>String</code> value\n-     * @return a <code>String</code> value\n-     */\n-    public String getFormValue(String sHeaderName) {\n-        return RequestContext.getCurrentContext().getRequest().getParameter(sHeaderName);\n-    }\n-\n-    /**\n-     * returns query params as a Map with String keys and Lists of Strings as values\n-     * @return\n-     */\n-    public Map<String, List<String>> getQueryParams() {\n-\n-        Map<String, List<String>> qp = RequestContext.getCurrentContext().getRequestQueryParams();\n-        if (qp != null) return qp;\n-\n-        HttpServletRequest request = RequestContext.getCurrentContext().getRequest();\n-\n-        qp = new HashMap<String, List<String>>();\n-\n-        if (request.getQueryString() == null) return null;\n-        StringTokenizer st = new StringTokenizer(request.getQueryString(), \"&\");\n-        int i;\n-\n-        while (st.hasMoreTokens()) {\n-            String s = st.nextToken();\n-            i = s.indexOf(\"=\");\n-            if (i > 0 && s.length() > i + 1) {\n-                String name = s.substring(0, i);\n-                String value = s.substring(i + 1);\n-\n-                try {\n-                    name = URLDecoder.decode(name, \"UTF-8\");\n-                } catch (Exception e) {\n-                }\n-                try {\n-                    value = URLDecoder.decode(value, \"UTF-8\");\n-                } catch (Exception e) {\n-                }\n-\n-                List valueList = qp.get(name);\n-                if (valueList == null) {\n-                    valueList = new LinkedList<String>();\n-                    qp.put(name, valueList);\n-                }\n-\n-                valueList.add(value);\n-            }\n-        }\n-\n-        RequestContext.getCurrentContext().setRequestQueryParams(qp);\n-        return qp;\n-    }\n-\n-    /**\n-     * Checks headers, query string, and form body for a given parameter\n-     *\n-     * @param sName\n-     * @return\n-     */\n-    public String getValueFromRequestElements(String sName) {\n-        String sValue = null;\n-        if (getQueryParams() != null) {\n-            final List<String> v = getQueryParams().get(sName);\n-            if (v != null && !v.isEmpty()) sValue = v.iterator().next();\n-        }\n-        if (sValue != null) return sValue;\n-        sValue = getHeaderValue(sName);\n-        if (sValue != null) return sValue;\n-        sValue = getFormValue(sName);\n-        if (sValue != null) return sValue;\n-        return null;\n-    }\n-\n-    /**\n-     * return true if the client requested gzip content\n-     *\n-     * @param contentEncoding a <code>String</code> value\n-     * @return true if the content-encoding param containg gzip\n-     */\n-    public boolean isGzipped(String contentEncoding) {\n-        return contentEncoding.contains(\"gzip\");\n-    }\n-    \n-    public static class UnitTest {\n-\n-\n-        @Test\n-        public void detectsGzip() {\n-            assertTrue(HTTPRequestUtils.getInstance().isGzipped(\"gzip\"));\n-        }\n-\n-        @Test\n-        public void detectsNonGzip() {\n-            assertFalse(HTTPRequestUtils.getInstance().isGzipped(\"identity\"));\n-        }\n-\n-        @Test\n-        public void detectsGzipAmongOtherEncodings() {\n-            assertTrue(HTTPRequestUtils.getInstance().isGzipped(\"gzip, deflate\"));\n-        }\n-\n-    }\n+\n+\tprivate final static HTTPRequestUtils INSTANCE = new HTTPRequestUtils();\n+\n+\tpublic static final String X_FORWARDED_FOR_HEADER = \"x-forwarded-for\";\n+\n+\n+\t/**\n+\t * Get the IP address of client making the request.\n+\t *\n+\t * Uses the \"x-forwarded-for\" HTTP header if available, otherwise uses the remote\n+\t * IP of requester.\n+\t *\n+\t * @param request <code>HttpServletRequest</code>\n+\t * @return <code>String</code> IP address\n+\t */\n+\tpublic String getClientIP(HttpServletRequest request) {\n+\t\tfinal String xForwardedFor = request.getHeader(X_FORWARDED_FOR_HEADER);\n+\t\tString clientIP = null;\n+\t\tif (xForwardedFor == null) {\n+\t\t\tclientIP = request.getRemoteAddr();\n+\t\t} else {\n+\t\t\tclientIP = extractClientIpFromXForwardedFor(xForwardedFor);\n+\t\t}\n+\t\treturn clientIP;\n+\t}\n+\n+\t/**\n+\t * Extract the client IP address from an x-forwarded-for header. Returns null if there is no x-forwarded-for header\n+\t *\n+\t * @param xForwardedFor a <code>String</code> value\n+\t * @return a <code>String</code> value\n+\t */\n+\tpublic final String extractClientIpFromXForwardedFor(String xForwardedFor) {\n+\t\tif (xForwardedFor == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\txForwardedFor = xForwardedFor.trim();\n+\t\tString tokenized[] = xForwardedFor.split(\",\");\n+\t\tif (tokenized.length == 0) {\n+\t\t\treturn null;\n+\t\t} else {\n+\t\t\treturn tokenized[0].trim();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * return singleton HTTPRequestUtils object\n+\t *\n+\t * @return a <code>HTTPRequestUtils</code> value\n+\t */\n+\tpublic static HTTPRequestUtils getInstance() {\n+\t\treturn INSTANCE;\n+\t}\n+\n+\t/**\n+\t * returns the Header value for the given sHeaderName\n+\t *\n+\t * @param sHeaderName a <code>String</code> value\n+\t * @return a <code>String</code> value\n+\t */\n+\tpublic String getHeaderValue(String sHeaderName) {\n+\t\treturn RequestContext.getCurrentContext().getRequest().getHeader(sHeaderName);\n+\t}\n+\n+\t/**\n+\t * returns a form value from a given sHeaderName\n+\t *\n+\t * @param sHeaderName a <code>String</code> value\n+\t * @return a <code>String</code> value\n+\t */\n+\tpublic String getFormValue(String sHeaderName) {\n+\t\treturn RequestContext.getCurrentContext().getRequest().getParameter(sHeaderName);\n+\t}\n+\t\n+\t/**\n+\t * returns headers as a Map with String keys and Lists of Strings as values\n+\t * @return\n+\t */\n+\n+\tpublic Map<String, List<String>> getRequestHeaderMap() {\n+\t\tHttpServletRequest request = RequestContext.getCurrentContext().getRequest();\n+\t\tMap<String,List<String>> headers = new HashMap<String,List<String>>();\n+\t\tEnumeration<String> headerNames = request.getHeaderNames();\n+\t\tif(headerNames != null) {\n+\t\t\twhile (headerNames.hasMoreElements()) {\n+\t\t\t\tString name = headerNames.nextElement().toLowerCase();\n+\t\t\t\tString value = request.getHeader(name);\n+\t\t\t\t\n+\t\t\t\tList<String> valueList = new ArrayList<String>();\n+\t\t\t\tif(headers.containsKey(name)) {\n+\t\t\t\t\theaders.get(name).add(value);\n+\t\t\t\t}\n+\t\t\t\tvalueList.add(value);\n+\t\t\t\theaders.put(name, valueList);\n+\t\t\t}\n+\t\t}\n+\t\treturn Collections.unmodifiableMap(headers);\n+\n+\t}\n+\n+\t/**\n+\t * returns query params as a Map with String keys and Lists of Strings as values\n+\t * @return\n+\t */\n+\tpublic Map<String, List<String>> getQueryParams() {\n+\n+\t\tMap<String, List<String>> qp = RequestContext.getCurrentContext().getRequestQueryParams();\n+\t\tif (qp != null) return qp;\n+\n+\t\tHttpServletRequest request = RequestContext.getCurrentContext().getRequest();\n+\n+\t\tqp = new HashMap<String, List<String>>();\n+\n+\t\tif (request.getQueryString() == null) return null;\n+\t\tStringTokenizer st = new StringTokenizer(request.getQueryString(), \"&\");\n+\t\tint i;\n+\n+\t\twhile (st.hasMoreTokens()) {\n+\t\t\tString s = st.nextToken();\n+\t\t\ti = s.indexOf(\"=\");\n+\t\t\tif (i > 0 && s.length() > i + 1) {\n+\t\t\t\tString name = s.substring(0, i);\n+\t\t\t\tString value = s.substring(i + 1);\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tname = URLDecoder.decode(name, \"UTF-8\");\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t}\n+\t\t\t\ttry {\n+\t\t\t\t\tvalue = URLDecoder.decode(value, \"UTF-8\");\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t}\n+\n+\t\t\t\tList<String> valueList = qp.get(name);\n+\t\t\t\tif (valueList == null) {\n+\t\t\t\t\tvalueList = new LinkedList<String>();\n+\t\t\t\t\tqp.put(name, valueList);\n+\t\t\t\t}\n+\n+\t\t\t\tvalueList.add(value);\n+\t\t\t}\n+\t\t}\n+\n+\t\tRequestContext.getCurrentContext().setRequestQueryParams(qp);\n+\t\treturn qp;\n+\t}\n+\n+\t/**\n+\t * Checks headers, query string, and form body for a given parameter\n+\t *\n+\t * @param sName\n+\t * @return\n+\t */\n+\tpublic String getValueFromRequestElements(String sName) {\n+\t\tString sValue = null;\n+\t\tif (getQueryParams() != null) {\n+\t\t\tfinal List<String> v = getQueryParams().get(sName);\n+\t\t\tif (v != null && !v.isEmpty()) sValue = v.iterator().next();\n+\t\t}\n+\t\tif (sValue != null) return sValue;\n+\t\tsValue = getHeaderValue(sName);\n+\t\tif (sValue != null) return sValue;\n+\t\tsValue = getFormValue(sName);\n+\t\tif (sValue != null) return sValue;\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * return true if the client requested gzip content\n+\t *\n+\t * @param contentEncoding a <code>String</code> value\n+\t * @return true if the content-encoding param containg gzip\n+\t */\n+\tpublic boolean isGzipped(String contentEncoding) {\n+\t\treturn contentEncoding.contains(\"gzip\");\n+\t}\n+\n+\tpublic static class UnitTest {\n+\n+\n+\t\t@Test\n+\t\tpublic void detectsGzip() {\n+\t\t\tassertTrue(HTTPRequestUtils.getInstance().isGzipped(\"gzip\"));\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void detectsNonGzip() {\n+\t\t\tassertFalse(HTTPRequestUtils.getInstance().isGzipped(\"identity\"));\n+\t\t}\n+\n+\t\t@Test\n+\t\tpublic void detectsGzipAmongOtherEncodings() {\n+\t\t\tassertTrue(HTTPRequestUtils.getInstance().isGzipped(\"gzip, deflate\"));\n+\t\t}\n+\n+\t}\n \n }",
      "parent_sha": "6a5e5a9fcd8e4ba3f6e3fabcc022ccb416037b6c"
    }
  },
  {
    "oid": "d8b8572625739f6c3edd88b0ce8a5dc193c045fb",
    "message": "zuul-core: use less sensitive timer",
    "date": "2020-08-21T19:22:07Z",
    "url": "https://github.com/Netflix/zuul/commit/d8b8572625739f6c3edd88b0ce8a5dc193c045fb",
    "details": {
      "sha": "1a6e947124c0fc8c3279f889ebf107726ea0b470",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/monitoring/ConnTimer.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/zuul/blob/d8b8572625739f6c3edd88b0ce8a5dc193c045fb/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmonitoring%2FConnTimer.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/d8b8572625739f6c3edd88b0ce8a5dc193c045fb/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmonitoring%2FConnTimer.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmonitoring%2FConnTimer.java?ref=d8b8572625739f6c3edd88b0ce8a5dc193c045fb",
      "patch": "@@ -39,7 +39,7 @@ public final class ConnTimer {\n \n     private static final AttributeKey<ConnTimer> CONN_TIMER = AttributeKey.newInstance(\"zuul.conntimer\");\n \n-    private static final Duration MIN_CONN_TIMING = Duration.ofNanos(512);\n+    private static final Duration MIN_CONN_TIMING = Duration.ofNanos(1024);\n     private static final Duration MAX_CONN_TIMING = Duration.ofDays(366);\n \n     private final Registry registry;",
      "parent_sha": "220db3f4f74ae92827eeae2d27a5aa069e46ab7c"
    }
  },
  {
    "oid": "a4da4a65f5f69d16c94d0f230ca46bff79124971",
    "message": "Another fix to unit-test working differently on the jenkins build. The ordering of url parameters is not determinate, so need to avoid testing order of them.",
    "date": "2015-05-06T06:57:08Z",
    "url": "https://github.com/Netflix/zuul/commit/a4da4a65f5f69d16c94d0f230ca46bff79124971",
    "details": {
      "sha": "e342af214636a79b8d1f6c5d43515187e814b764",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/context/HttpQueryParams.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/Netflix/zuul/blob/a4da4a65f5f69d16c94d0f230ca46bff79124971/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fcontext%2FHttpQueryParams.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/a4da4a65f5f69d16c94d0f230ca46bff79124971/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fcontext%2FHttpQueryParams.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fcontext%2FHttpQueryParams.java?ref=a4da4a65f5f69d16c94d0f230ca46bff79124971",
      "patch": "@@ -140,9 +140,11 @@ public void testToEncodedString()\n         {\n             HttpQueryParams qp = new HttpQueryParams();\n             qp.add(\"k'1\", \"v1&\");\n-            qp.add(\"k2%\", \"v2\");\n+            assertEquals(\"k%271=v1%26&\", qp.toEncodedString());\n \n-            assertEquals(\"k%271=v1%26&k2%25=v2&\", qp.toEncodedString());\n+            qp = new HttpQueryParams();\n+            qp.add(\"k+\", \"\\n\");\n+            assertEquals(\"k%2B=%0A&\", qp.toEncodedString());\n         }\n     }\n }",
      "parent_sha": "9122e87c6d5fbd0d4e68377c34d0171696d2e365"
    }
  },
  {
    "oid": "f1ea8ddc0f8af8ea476a0a2d71fdf2420f3f0ada",
    "message": "Added a warn log statement in HttpResponseMessageImpl if constructed with a request object that does not have a stored inboundRequest.",
    "date": "2015-08-05T23:04:14Z",
    "url": "https://github.com/Netflix/zuul/commit/f1ea8ddc0f8af8ea476a0a2d71fdf2420f3f0ada",
    "details": {
      "sha": "8169c2fd4f9b2f37496245c4a0914a036880a787",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/message/http/HttpResponseMessageImpl.java",
      "status": "modified",
      "additions": 10,
      "deletions": 4,
      "changes": 14,
      "blob_url": "https://github.com/Netflix/zuul/blob/f1ea8ddc0f8af8ea476a0a2d71fdf2420f3f0ada/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2Fhttp%2FHttpResponseMessageImpl.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/f1ea8ddc0f8af8ea476a0a2d71fdf2420f3f0ada/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2Fhttp%2FHttpResponseMessageImpl.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2Fhttp%2FHttpResponseMessageImpl.java?ref=f1ea8ddc0f8af8ea476a0a2d71fdf2420f3f0ada",
      "patch": "@@ -26,6 +26,8 @@\n import io.netty.handler.codec.http.Cookie;\n import io.netty.handler.codec.http.CookieDecoder;\n import io.netty.handler.codec.http.ServerCookieEncoder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import rx.Observable;\n \n import java.nio.charset.Charset;\n@@ -39,23 +41,27 @@ public class HttpResponseMessageImpl implements HttpResponseMessage\n {\n     private static final DynamicIntProperty MAX_BODY_SIZE_PROP = DynamicPropertyFactory.getInstance().getIntProperty(\n             \"zuul.HttpResponseMessage.body.max.size\", 25 * 1000 * 1024);\n+    private static final Logger LOG = LoggerFactory.getLogger(HttpResponseMessageImpl.class);\n \n     private ZuulMessage message;\n     private HttpRequestMessage outboundRequest;\n     private int status;\n     private HttpResponseInfo inboundResponse = null;\n \n-    public HttpResponseMessageImpl(SessionContext context, HttpRequestMessage request, int defaultStatus)\n+    public HttpResponseMessageImpl(SessionContext context, HttpRequestMessage request, int status)\n     {\n-        this.message = new ZuulMessageImpl(context, new Headers());\n-        this.outboundRequest = request;\n-        this.status = defaultStatus;\n+        this(context, new Headers(), request, status);\n     }\n \n     public HttpResponseMessageImpl(SessionContext context, Headers headers, HttpRequestMessage request, int status)\n     {\n         this.message = new ZuulMessageImpl(context, headers);\n         this.outboundRequest = request;\n+        if (this.outboundRequest.getInboundRequest() == null) {\n+            LOG.warn(\"HttpResponseMessage created with a request that does not have a stored inboundRequest! \" +\n+                    \"Probably a bug in the filter that is creating this response.\",\n+                    new RuntimeException(\"Invalid HttpRequestMessage\"));\n+        }\n         this.status = status;\n     }\n ",
      "parent_sha": "af8916c5ef01840f44a416f7cf588b00e64c3e6f"
    }
  },
  {
    "oid": "0d4087b2553bceda074e2825a3577302b84cde24",
    "message": "Bugfix - in ProxyEndpoint, had the execution listeners being invoked before the response headers were collected",
    "date": "2018-03-05T22:38:48Z",
    "url": "https://github.com/Netflix/zuul/commit/0d4087b2553bceda074e2825a3577302b84cde24",
    "details": {
      "sha": "fea2ce6963368e67e21a7c1be4038053cda28d0d",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/filters/endpoint/ProxyEndpoint.java",
      "status": "modified",
      "additions": 21,
      "deletions": 17,
      "changes": 38,
      "blob_url": "https://github.com/Netflix/zuul/blob/0d4087b2553bceda074e2825a3577302b84cde24/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/0d4087b2553bceda074e2825a3577302b84cde24/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java?ref=0d4087b2553bceda074e2825a3577302b84cde24",
      "patch": "@@ -732,27 +732,11 @@ protected void handleOriginSuccessResponse(final HttpResponse originResponse, Se\n     private HttpResponseMessage buildZuulHttpResponse(final HttpResponse httpResponse, final StatusCategory statusCategory, final Throwable ex) {\n         startedSendingResponseToClient = true;\n \n+        // Translate the netty HttpResponse into a zuul HttpResponseMessage.\n         final SessionContext zuulCtx = context;\n         final int respStatus = httpResponse.status().code();\n         final HttpResponseMessage zuulResponse = new HttpResponseMessageImpl(zuulCtx, zuulRequest, respStatus);\n \n-        // Request was a success even if server may have responded with an error code 5XX, except for 503.\n-        if (originConn != null) {\n-            if (statusCategory == ZuulStatusCategory.FAILURE_ORIGIN_THROTTLED) {\n-                origin.onRequestExecutionFailed(zuulRequest, originConn.getServer(), attemptNum,\n-                        new ClientException(ClientException.ErrorType.SERVER_THROTTLED));\n-            }\n-            else {\n-                origin.onRequestExecutionSuccess(zuulRequest, zuulResponse, originConn.getServer(), attemptNum);\n-            }\n-        }\n-        origin.recordFinalResponse(zuulResponse);\n-        origin.recordFinalError(zuulRequest, ex);\n-        origin.getProxyTiming(zuulRequest).end();\n-        zuulCtx.set(CommonContextKeys.STATUS_CATGEORY, statusCategory);\n-        zuulCtx.setError(ex);\n-        zuulCtx.put(\"origin_http_status\", Integer.toString(respStatus));\n-\n         final Headers respHeaders = zuulResponse.getHeaders();\n         for (Map.Entry<String, String> entry : httpResponse.headers()) {\n             respHeaders.add(entry.getKey(), entry.getValue());\n@@ -775,6 +759,26 @@ private HttpResponseMessage buildZuulHttpResponse(final HttpResponse httpRespons\n             zuulResponse.bufferBodyContents(new DefaultLastHttpContent(chunk));\n         }\n \n+        // Invoke any Ribbon execution listeners.\n+        // Request was a success even if server may have responded with an error code 5XX, except for 503.\n+        if (originConn != null) {\n+            if (statusCategory == ZuulStatusCategory.FAILURE_ORIGIN_THROTTLED) {\n+                origin.onRequestExecutionFailed(zuulRequest, originConn.getServer(), attemptNum,\n+                        new ClientException(ClientException.ErrorType.SERVER_THROTTLED));\n+            }\n+            else {\n+                origin.onRequestExecutionSuccess(zuulRequest, zuulResponse, originConn.getServer(), attemptNum);\n+            }\n+        }\n+\n+        // Collect some info about the received response.\n+        origin.recordFinalResponse(zuulResponse);\n+        origin.recordFinalError(zuulRequest, ex);\n+        origin.getProxyTiming(zuulRequest).end();\n+        zuulCtx.set(CommonContextKeys.STATUS_CATGEORY, statusCategory);\n+        zuulCtx.setError(ex);\n+        zuulCtx.put(\"origin_http_status\", Integer.toString(respStatus));\n+\n         return transformResponse(zuulResponse);\n     }\n ",
      "parent_sha": "9f02193cd387971c6cc6dab040724d1a82721579"
    }
  },
  {
    "oid": "6b4ec86a33387f7d39e021b12e4a87056fbedbcc",
    "message": "zuul-core: fix gzip filter order",
    "date": "2020-04-10T04:48:42Z",
    "url": "https://github.com/Netflix/zuul/commit/6b4ec86a33387f7d39e021b12e4a87056fbedbcc",
    "details": {
      "sha": "d06251a4e19ec7b7c4e391e110f901c7cb519949",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/filters/common/GZipResponseFilter.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/zuul/blob/6b4ec86a33387f7d39e021b12e4a87056fbedbcc/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fcommon%2FGZipResponseFilter.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/6b4ec86a33387f7d39e021b12e4a87056fbedbcc/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fcommon%2FGZipResponseFilter.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fcommon%2FGZipResponseFilter.java?ref=6b4ec86a33387f7d39e021b12e4a87056fbedbcc",
      "patch": "@@ -43,7 +43,7 @@\n  *\n  * @author Mike Smith\n  */\n-@Filter(order = 101, type = FilterType.OUTBOUND)\n+@Filter(order = 110, type = FilterType.OUTBOUND)\n public class GZipResponseFilter extends HttpOutboundSyncFilter\n {\n     private static DynamicStringSetProperty GZIPPABLE_CONTENT_TYPES = new DynamicStringSetProperty(\"zuul.gzip.contenttypes\",",
      "parent_sha": "1d7358901e24f96794677fe2cb0b689ea74feb53"
    }
  },
  {
    "oid": "10974bcdb60ac0a8a3c584e830334f0c35c7b5e6",
    "message": "Don't return origin connections to pool if server responds with 'Connection: close'",
    "date": "2019-04-09T15:47:30Z",
    "url": "https://github.com/Netflix/zuul/commit/10974bcdb60ac0a8a3c584e830334f0c35c7b5e6",
    "details": {
      "sha": "a675d85865d3f1410f6d133efaa89f906ca17318",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/connectionpool/ConnectionPoolHandler.java",
      "status": "modified",
      "additions": 22,
      "deletions": 3,
      "changes": 25,
      "blob_url": "https://github.com/Netflix/zuul/blob/10974bcdb60ac0a8a3c584e830334f0c35c7b5e6/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fconnectionpool%2FConnectionPoolHandler.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/10974bcdb60ac0a8a3c584e830334f0c35c7b5e6/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fconnectionpool%2FConnectionPoolHandler.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fconnectionpool%2FConnectionPoolHandler.java?ref=10974bcdb60ac0a8a3c584e830334f0c35c7b5e6",
      "patch": "@@ -22,6 +22,9 @@\n import io.netty.channel.ChannelDuplexHandler;\n import io.netty.channel.ChannelHandler;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.netty.handler.codec.http.HttpHeaders;\n+import io.netty.handler.codec.http.HttpResponse;\n import io.netty.handler.timeout.IdleStateEvent;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -70,12 +73,19 @@ else if (evt instanceof CompleteEvent) {\n             // The HttpLifecycleChannelHandler instance will fire this event when either a response has finished being written, or\n             // the channel is no longer active or disconnected.\n             // Return the connection to pool.\n-            final CompleteReason reason = ((CompleteEvent) evt).getReason();\n+            CompleteEvent completeEvt = (CompleteEvent) evt;\n+            final CompleteReason reason = completeEvt.getReason();\n             if (reason == SESSION_COMPLETE) {\n                 final PooledConnection conn = PooledConnection.getFromChannel(ctx.channel());\n                 if (conn != null) {\n-                    conn.setConnectionState(PooledConnection.ConnectionState.WRITE_READY);\n-                    conn.release();\n+                    if (\"close\".equalsIgnoreCase(getConnectionHeader(completeEvt))) {\n+                        final String msg = \"Origin channel for origin - \" + originName + \" - completed because of expired keep-alive. \"\n+                                + ChannelUtils.channelInfoForLogging(ctx.channel());\n+                        closeConnection(ctx, msg);\n+                    } else {\n+                        conn.setConnectionState(PooledConnection.ConnectionState.WRITE_READY);\n+                        conn.release();\n+                    }\n                 }\n             } else {\n                 final String msg = \"Origin channel for origin - \" + originName + \" - completed with reason \"\n@@ -136,4 +146,13 @@ private void flagCloseAndReleaseConnection(PooledConnection pooledConnection) {\n             pooledConnection.release();\n         }\n     }\n+\n+    private static String getConnectionHeader(CompleteEvent completeEvt) {\n+        HttpResponse response = completeEvt.getResponse();\n+        if (response != null) {\n+            return response.headers().get(HttpHeaderNames.CONNECTION);\n+        }\n+\n+        return null;\n+    }\n }",
      "parent_sha": "030d30fd73bf5003be692abad8d2602ab9a19687"
    }
  },
  {
    "oid": "7f70b7e1331ae977312d2f9346a89450d9ebe47b",
    "message": "Do not propagate exception once context has been closed in PushRegistrationHandler",
    "date": "2022-08-09T20:39:03Z",
    "url": "https://github.com/Netflix/zuul/commit/7f70b7e1331ae977312d2f9346a89450d9ebe47b",
    "details": {
      "sha": "020dca8d8332654ad7add81234c193f5b99fd8e2",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/server/push/PushRegistrationHandler.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/Netflix/zuul/blob/7f70b7e1331ae977312d2f9346a89450d9ebe47b/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2Fpush%2FPushRegistrationHandler.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/7f70b7e1331ae977312d2f9346a89450d9ebe47b/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2Fpush%2FPushRegistrationHandler.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2Fpush%2FPushRegistrationHandler.java?ref=7f70b7e1331ae977312d2f9346a89450d9ebe47b",
      "patch": "@@ -95,10 +95,9 @@ public final void channelInactive(ChannelHandlerContext ctx) throws Exception {\n     }\n \n     @Override\n-    public final void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n         logger.error(\"Exception caught, closing push channel for \" + authEvent, cause);\n         ctx.close();\n-        super.exceptionCaught(ctx, cause);\n     }\n \n     protected final void forceCloseConnectionFromServerSide() {",
      "parent_sha": "4ee00db02afb5ab086ca061255ab5a501d8c93c4"
    }
  },
  {
    "oid": "223c53ac5deb60f0193e984ef73d4aeaa2c19759",
    "message": "change getbody impl",
    "date": "2017-06-22T03:33:05Z",
    "url": "https://github.com/Netflix/zuul/commit/223c53ac5deb60f0193e984ef73d4aeaa2c19759",
    "details": {
      "sha": "b3a78e7b8ad64cb65c2624c73e1bd86aabd01e4f",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/message/ZuulMessageImpl.java",
      "status": "modified",
      "additions": 21,
      "deletions": 14,
      "changes": 35,
      "blob_url": "https://github.com/Netflix/zuul/blob/223c53ac5deb60f0193e984ef73d4aeaa2c19759/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2FZuulMessageImpl.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/223c53ac5deb60f0193e984ef73d4aeaa2c19759/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2FZuulMessageImpl.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2FZuulMessageImpl.java?ref=223c53ac5deb60f0193e984ef73d4aeaa2c19759",
      "patch": "@@ -136,9 +136,8 @@ public void setBody(byte[] body) {\n \n     @Override\n     public String getBodyAsText() {\n-        final StringBuilder builder = new StringBuilder();\n-        bodyChunks.forEach(chunk -> builder.append(chunk.content().toString(Charsets.UTF_8)));\n-        return builder.toString();\n+        final byte[] body = getBody();\n+        return (body != null && body.length > 0) ? new String(getBody(), Charsets.UTF_8) : null;\n     }\n \n     @Override\n@@ -147,26 +146,34 @@ public byte[] getBody() {\n             return null;\n         }\n \n-        final CompositeByteBuf cbuff = Unpooled.compositeBuffer();\n-        bodyChunks.forEach(chunk -> {\n-            chunk.retain(); //CompositeByteBuf calls release() on ByteBuf\n-            cbuff.addComponent(true, chunk.content());\n-        });\n-        final byte[] bytes = new byte[cbuff.readableBytes()];\n-        cbuff.readBytes(bytes);\n-        cbuff.release();\n-        return bytes;\n+        int size = 0;\n+        for (final HttpContent chunk : bodyChunks) {\n+            size += chunk.content().readableBytes();\n+        }\n+        final byte[] body = new byte[size];\n+        int offset = 0;\n+        for (final HttpContent chunk : bodyChunks) {\n+            final ByteBuf content = chunk.content();\n+            final int len = content.readableBytes();\n+            content.getBytes(content.readerIndex(), body, offset, len);\n+            offset += len;\n+        }\n+        return body;\n     }\n \n     @Override\n     public int getBodyLength() {\n-        return bodyChunks.stream().mapToInt((chunk) -> chunk.content().readableBytes()).sum();\n+        int size = 0;\n+        for (final HttpContent chunk : bodyChunks) {\n+            size += chunk.content().readableBytes();\n+        }\n+        return size;\n     }\n \n     @Override\n     public void writeBufferedBodyContent(Channel channel, boolean retainBeyondWrite) {\n         bodyChunks.forEach(chunk -> {\n-            if (retainBeyondWrite) {\n+            if (retainBeyondWrite && chunk.refCnt() > 0) {\n                 chunk.retain();\n             }\n             channel.write(chunk);",
      "parent_sha": "16678a0fb40f901a2c307c64d023c26eca825c2c"
    }
  },
  {
    "oid": "489765350ccdd58b0719be1652368c736dae5769",
    "message": "fix test typo",
    "date": "2021-03-23T20:45:24Z",
    "url": "https://github.com/Netflix/zuul/commit/489765350ccdd58b0719be1652368c736dae5769",
    "details": {
      "sha": "c79acc22a20100deed3e757e08b798e8f95ca3cf",
      "filename": "zuul-core/src/test/java/com/netflix/zuul/netty/timeouts/OriginTimeoutManagerTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/zuul/blob/489765350ccdd58b0719be1652368c736dae5769/zuul-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ftimeouts%2FOriginTimeoutManagerTest.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/489765350ccdd58b0719be1652368c736dae5769/zuul-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ftimeouts%2FOriginTimeoutManagerTest.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ftimeouts%2FOriginTimeoutManagerTest.java?ref=489765350ccdd58b0719be1652368c736dae5769",
      "patch": "@@ -115,12 +115,12 @@ public void computeReadTimeout_bolth_originLower() {\n \n     @Test\n     public void computeReadTimeout_bolth_requestLower() {\n-        requestConfig.set(CommonClientConfigKey.ReadTimeout, 1000);\n+        requestConfig.set(CommonClientConfigKey.ReadTimeout, 100);\n         originConfig.set(CommonClientConfigKey.ReadTimeout, 1000);\n \n         Duration timeout = originTimeoutManager.computeReadTimeout(request, 1);\n \n-        assertEquals(1000, timeout.toMillis());\n+        assertEquals(100, timeout.toMillis());\n     }\n \n     @Test",
      "parent_sha": "f71b274f8757a30db06264cc9225be2bd7becb38"
    }
  },
  {
    "oid": "1906f769ad3df0a60b4ccae1e76ab8db54e0a211",
    "message": "Should call ServerStats.incrementActiveRequestsCount() _before_ acquiring each connection\n\nand therefore also need to decrement in case when unable to establish a new connection.",
    "date": "2018-03-29T23:02:04Z",
    "url": "https://github.com/Netflix/zuul/commit/1906f769ad3df0a60b4ccae1e76ab8db54e0a211",
    "details": {
      "sha": "16fae9c2fe5dc4035f23c9c2b70461b4e2541851",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/connectionpool/PerServerConnectionPool.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/zuul/blob/1906f769ad3df0a60b4ccae1e76ab8db54e0a211/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fconnectionpool%2FPerServerConnectionPool.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/1906f769ad3df0a60b4ccae1e76ab8db54e0a211/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fconnectionpool%2FPerServerConnectionPool.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fconnectionpool%2FPerServerConnectionPool.java?ref=1906f769ad3df0a60b4ccae1e76ab8db54e0a211",
      "patch": "@@ -153,6 +153,7 @@ public Promise<PooledConnection> acquire(EventLoop eventLoop, Object key, String\n                                              int attemptNum, CurrentPassport passport)\n     {\n         requestConnCounter.increment();\n+        stats.incrementActiveRequestsCount();\n         \n         Promise<PooledConnection> promise = eventLoop.newPromise();\n \n@@ -161,7 +162,6 @@ public Promise<PooledConnection> acquire(EventLoop eventLoop, Object key, String\n         if (conn != null) {\n             // There was a pooled connection available, so use this one.\n             conn.startRequestTimer();\n-            stats.incrementActiveRequestsCount();\n             conn.incrementUsageCount();\n             conn.getChannel().read();\n             onAcquire(conn, httpMethod, uri, attemptNum, passport);\n@@ -317,7 +317,6 @@ private void handleConnectCompletion(final ChannelFuture cf,\n             passport.add(PassportState.ORIGIN_CH_CONNECTED);\n             \n             stats.incrementOpenConnectionsCount();\n-            stats.incrementActiveRequestsCount();\n             createConnSucceededCounter.increment();\n             connsInUse.incrementAndGet();\n             \n@@ -332,6 +331,7 @@ private void handleConnectCompletion(final ChannelFuture cf,\n         else {\n             stats.incrementSuccessiveConnectionFailureCount();\n             stats.addToFailureCount();\n+            stats.decrementActiveRequestsCount();\n             createConnFailedCounter.increment();\n             callerPromise.setFailure(new OriginConnectException(cf.cause().getMessage(), OutboundErrorType.CONNECT_ERROR));\n         }",
      "parent_sha": "0195bbfeacfdbb41b41117c2764ce5597c4a8067"
    }
  },
  {
    "oid": "f8ef3551d8dd57a512336315ec51bb6c0444c517",
    "message": "BaseZuulFilterRunner now measures filter elapsed time in nanos\n\nWhile the existing log messages/statistics around filter timings\nweren't changed, ZuulFilterRunner implementations now have access\nto higher precision elapsed time readings.",
    "date": "2019-10-08T01:32:37Z",
    "url": "https://github.com/Netflix/zuul/commit/f8ef3551d8dd57a512336315ec51bb6c0444c517",
    "details": {
      "sha": "ccefbb0c54771daf048d630ead88c8400ab1ec51",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/filter/BaseZuulFilterRunner.java",
      "status": "modified",
      "additions": 8,
      "deletions": 7,
      "changes": 15,
      "blob_url": "https://github.com/Netflix/zuul/blob/f8ef3551d8dd57a512336315ec51bb6c0444c517/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ffilter%2FBaseZuulFilterRunner.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/f8ef3551d8dd57a512336315ec51bb6c0444c517/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ffilter%2FBaseZuulFilterRunner.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ffilter%2FBaseZuulFilterRunner.java?ref=f8ef3551d8dd57a512336315ec51bb6c0444c517",
      "patch": "@@ -131,7 +131,7 @@ protected final void invokeNextStage(final O zuulMesg) {\n     }\n \n     protected final O filter(final ZuulFilter<I, O> filter, final I inMesg) {\n-        final long startTime = System.currentTimeMillis();\n+        final long startTime = System.nanoTime();\n         final ZuulMessage snapshot = inMesg.getContext().debugRouting() ? inMesg.clone() : null;\n         FilterChainResumer resumer = null;\n \n@@ -255,22 +255,23 @@ protected void recordFilterCompletion(final ExecutionStatus status, final ZuulFi\n                                           final ZuulMessage zuulMesg, final ZuulMessage startSnapshot) {\n \n         final SessionContext zuulCtx = zuulMesg.getContext();\n-        final long execTime = System.currentTimeMillis() - startTime;\n-        if (execTime >= FILTER_EXCESSIVE_EXEC_TIME.get()) {\n-            LOG.warn(\"Filter {} took {} ms to complete! status = {}\", filter.filterName(), execTime, status.name());\n+        final long execTimeNs = System.nanoTime() - startTime;\n+        final long execTimeMs = execTimeNs / 1_000_000L;\n+        if (execTimeMs >= FILTER_EXCESSIVE_EXEC_TIME.get()) {\n+            LOG.warn(\"Filter {} took {} ms to complete! status = {}\", filter.filterName(), execTimeMs, status.name());\n         }\n \n         // Record the execution summary in context.\n         switch (status) {\n             case FAILED:\n-                zuulCtx.addFilterExecutionSummary(filter.filterName(), FAILED.name(), execTime);\n+                zuulCtx.addFilterExecutionSummary(filter.filterName(), FAILED.name(), execTimeMs);\n                 break;\n             case SUCCESS:\n-                zuulCtx.addFilterExecutionSummary(filter.filterName(), SUCCESS.name(), execTime);\n+                zuulCtx.addFilterExecutionSummary(filter.filterName(), SUCCESS.name(), execTimeMs);\n                 if (startSnapshot != null) {\n                     //debugRouting == true\n                     Debug.addRoutingDebug(zuulCtx, \"Filter {\" + filter.filterName() + \" TYPE:\" + filter.filterType().toString()\n-                            + \" ORDER:\" + filter.filterOrder() + \"} Execution time = \" + execTime + \"ms\");\n+                            + \" ORDER:\" + filter.filterOrder() + \"} Execution time = \" + execTimeMs + \"ms\");\n                     Debug.compareContextState(filter.filterName(), zuulCtx, startSnapshot.getContext());\n                 }\n                 break;",
      "parent_sha": "5fdf5d9da5cd7586f8567b90ff8a4700ca85c87c"
    }
  },
  {
    "oid": "831442822cf5edc62b48a353e9ffbbfee016eb09",
    "message": "Use default values for missing tags for ssl handshake metric\nto fix broken atlas-aggregator",
    "date": "2018-07-31T20:40:56Z",
    "url": "https://github.com/Netflix/zuul/commit/831442822cf5edc62b48a353e9ffbbfee016eb09",
    "details": {
      "sha": "8f5e65b390cadc470ae12ae88cbf2fd322817905",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/server/ssl/SslHandshakeInfoHandler.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/Netflix/zuul/blob/831442822cf5edc62b48a353e9ffbbfee016eb09/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2Fssl%2FSslHandshakeInfoHandler.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/831442822cf5edc62b48a353e9ffbbfee016eb09/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2Fssl%2FSslHandshakeInfoHandler.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2Fssl%2FSslHandshakeInfoHandler.java?ref=831442822cf5edc62b48a353e9ffbbfee016eb09",
      "patch": "@@ -186,10 +186,12 @@ private void incrementCounters(SslHandshakeCompletionEvent sslHandshakeCompletio\n     {\n         try {\n             if (sslHandshakeCompletionEvent.isSuccess()) {\n+                String proto = handshakeInfo.getProtocol().length() > 0 ? handshakeInfo.getProtocol() : \"unknown\";\n+                String ciphsuite = handshakeInfo.getCipherSuite().length() > 0 ? handshakeInfo.getCipherSuite() : \"unknown\";\n                 spectatorRegistry.counter(\"server.ssl.handshake\",\n                         \"success\", String.valueOf(sslHandshakeCompletionEvent.isSuccess()),\n-                        \"protocol\", String.valueOf(handshakeInfo.getProtocol()),\n-                        \"ciphersuite\", String.valueOf(handshakeInfo.getCipherSuite()),\n+                        \"protocol\", String.valueOf(proto),\n+                        \"ciphersuite\", String.valueOf(ciphsuite),\n                         \"clientauth\", String.valueOf(handshakeInfo.getClientAuthRequirement())\n                                          )\n                         .increment();",
      "parent_sha": "6e47db17395690d8b569aa99fe484dd24df81a33"
    }
  },
  {
    "oid": "37b69289c71dc678de83cfacd40a1bcffa31fa50",
    "message": "Remove reflection from direct memory monitor",
    "date": "2022-10-19T19:15:47Z",
    "url": "https://github.com/Netflix/zuul/commit/37b69289c71dc678de83cfacd40a1bcffa31fa50",
    "details": {
      "sha": "2405885a6dfeae5bc773f9ddc984513b96a0d863",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/server/DirectMemoryMonitor.java",
      "status": "modified",
      "additions": 17,
      "deletions": 62,
      "changes": 79,
      "blob_url": "https://github.com/Netflix/zuul/blob/37b69289c71dc678de83cfacd40a1bcffa31fa50/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FDirectMemoryMonitor.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/37b69289c71dc678de83cfacd40a1bcffa31fa50/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FDirectMemoryMonitor.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FDirectMemoryMonitor.java?ref=37b69289c71dc678de83cfacd40a1bcffa31fa50",
      "patch": "@@ -20,6 +20,7 @@\n import com.netflix.config.DynamicIntProperty;\n import com.netflix.spectator.api.Registry;\n import com.netflix.spectator.api.patterns.PolledMeter;\n+import io.netty.util.internal.PlatformDependent;\n import java.lang.reflect.Field;\n import java.time.Duration;\n import java.util.concurrent.Executors;\n@@ -42,50 +43,6 @@ public final class DirectMemoryMonitor {\n     private static final String PROP_PREFIX = \"zuul.directmemory\";\n     private static final DynamicIntProperty TASK_DELAY_PROP = new DynamicIntProperty(PROP_PREFIX + \".task.delay\", 10);\n \n-    private static final Supplier<Long> directMemoryLimitGetter;\n-    private static final Supplier<Long> reservedMemoryGetter;\n-\n-    static {\n-        Supplier<Long> directMemoryLimit;\n-        Supplier<Long> reservedMemory;\n-        try {\n-            Class<?> c = Class.forName(\"io.netty.util.internal.PlatformDependent\");\n-            Field directMemoryLimitField = c.getDeclaredField(\"DIRECT_MEMORY_LIMIT\");\n-            directMemoryLimitField.setAccessible(true);\n-            directMemoryLimit = () -> {\n-                try {\n-                    return (long) directMemoryLimitField.get(null);\n-                } catch (IllegalAccessException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            };\n-            // Check that the call works\n-            directMemoryLimit.get();\n-            Field reservedMemoryField = c.getDeclaredField(\"DIRECT_MEMORY_COUNTER\");\n-            reservedMemoryField.setAccessible(true);\n-            reservedMemory = () -> {\n-                try {\n-                    AtomicLong value = (AtomicLong) reservedMemoryField.get(null);\n-                    // Matches behavior in PlatformDependent.usedDirectMemory.\n-                    return value == null ? -1 : value.get();\n-                } catch (IllegalAccessException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            };\n-            if (reservedMemory.get() == -1) {\n-                // This can occur when using JDK 11, which can prevent some of the reflective operations\n-                // PlatformDependent depends on.\n-                LOG.debug(\"Unable to get direct memory\");\n-            }\n-        } catch (Throwable t) {\n-            LOG.warn(\"Unable to query direct memory, disabling monitor\", t);\n-            directMemoryLimit = null;\n-            reservedMemory = null;\n-        }\n-        directMemoryLimitGetter = directMemoryLimit;\n-        reservedMemoryGetter = reservedMemory;\n-    }\n-\n     // TODO(carl-mastrangelo): this should be passed in as a dependency, so it can be shutdown and waited on for\n     //    termination.\n     private final ScheduledExecutorService service =\n@@ -94,35 +51,33 @@ public final class DirectMemoryMonitor {\n \n     @Inject\n     public DirectMemoryMonitor(Registry registry) {\n-        if (reservedMemoryGetter != null) {\n-            PolledMeter.using(registry)\n-                    .withName(PROP_PREFIX + \".reserved\")\n-                    .withDelay(Duration.ofSeconds(TASK_DELAY_PROP.get()))\n-                    .scheduleOn(service)\n-                    .monitorValue(DirectMemoryMonitor.class, DirectMemoryMonitor::getReservedMemory);\n-        }\n-        if (directMemoryLimitGetter != null) {\n-            PolledMeter.using(registry)\n-                    .withName(PROP_PREFIX + \".max\")\n-                    .withDelay(Duration.ofSeconds(TASK_DELAY_PROP.get()))\n-                    .scheduleOn(service)\n-                    .monitorValue(DirectMemoryMonitor.class, DirectMemoryMonitor::getMaxMemory);\n-        }\n+        PolledMeter.using(registry)\n+                   .withName(PROP_PREFIX + \".reserved\")\n+                   .withDelay(Duration.ofSeconds(TASK_DELAY_PROP.get()))\n+                   .scheduleOn(service)\n+                   .monitorValue(DirectMemoryMonitor.class, DirectMemoryMonitor::getReservedMemory);\n+\n+        PolledMeter.using(registry)\n+                   .withName(PROP_PREFIX + \".max\")\n+                   .withDelay(Duration.ofSeconds(TASK_DELAY_PROP.get()))\n+                   .scheduleOn(service)\n+                   .monitorValue(DirectMemoryMonitor.class, DirectMemoryMonitor::getMaxMemory);\n+\n     }\n \n     private static double getReservedMemory(Object discard) {\n         try {\n-            return reservedMemoryGetter.get();\n-        } catch (RuntimeException | Error e) {\n+            return PlatformDependent.maxDirectMemory();\n+        } catch (Throwable e) {\n             LOG.warn(\"Error in DirectMemoryMonitor task.\", e);\n         }\n         return -1;\n     }\n \n     private static double getMaxMemory(Object discard) {\n         try {\n-            return directMemoryLimitGetter.get();\n-        } catch (RuntimeException | Error e) {\n+            return PlatformDependent.usedDirectMemory();\n+        } catch (Throwable e) {\n             LOG.warn(\"Error in DirectMemoryMonitor task.\", e);\n         }\n         return -1;",
      "parent_sha": "96e0dd33e6b7b3fd639655a67fb77d7a76f4e6bd"
    }
  },
  {
    "oid": "9ce0eab3b71dd13a471f3a7a57da739c2ada653c",
    "message": "Only check filter body buffering if message content still inflight (#1779)",
    "date": "2024-05-28T21:11:43Z",
    "url": "https://github.com/Netflix/zuul/commit/9ce0eab3b71dd13a471f3a7a57da739c2ada653c",
    "details": {
      "sha": "37c1a3bcbd1f578125adf12e669684d0836ad831",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/filter/BaseZuulFilterRunner.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/zuul/blob/9ce0eab3b71dd13a471f3a7a57da739c2ada653c/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ffilter%2FBaseZuulFilterRunner.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/9ce0eab3b71dd13a471f3a7a57da739c2ada653c/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ffilter%2FBaseZuulFilterRunner.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ffilter%2FBaseZuulFilterRunner.java?ref=9ce0eab3b71dd13a471f3a7a57da739c2ada653c",
      "patch": "@@ -302,8 +302,8 @@ protected final boolean shouldSkipFilter(final I inMesg, final ZuulFilter<I, O>\n         return false;\n     }\n \n-    private boolean isMessageBodyReadyForFilter(final ZuulFilter filter, final I inMesg) {\n-        return ((!filter.needsBodyBuffered(inMesg)) || (inMesg.hasCompleteBody()));\n+    private boolean isMessageBodyReadyForFilter(final ZuulFilter<I, O> filter, final I inMesg) {\n+        return inMesg.hasCompleteBody() || (!filter.needsBodyBuffered(inMesg));\n     }\n \n     protected O handleFilterException(final I inMesg, final ZuulFilter<I, O> filter, final Throwable ex) {",
      "parent_sha": "5f10b9a52790a96ca626f332de5354a8a3f03a55"
    }
  },
  {
    "oid": "c1b0b5f9b7a96b56c2e4ea8cca5e517f42e49188",
    "message": "Remove redundant clientRequest.toString()",
    "date": "2021-05-12T18:17:44Z",
    "url": "https://github.com/Netflix/zuul/commit/c1b0b5f9b7a96b56c2e4ea8cca5e517f42e49188",
    "details": {
      "sha": "c85031fb4daa5997a33133d605ead4ad0b268858",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/server/ClientRequestReceiver.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/zuul/blob/c1b0b5f9b7a96b56c2e4ea8cca5e517f42e49188/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FClientRequestReceiver.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/c1b0b5f9b7a96b56c2e4ea8cca5e517f42e49188/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FClientRequestReceiver.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FClientRequestReceiver.java?ref=c1b0b5f9b7a96b56c2e4ea8cca5e517f42e49188",
      "patch": "@@ -132,7 +132,7 @@ private void channelReadInternal(final ChannelHandlerContext ctx, Object msg) th\n             if (clientRequest.decoderResult().isFailure()) {\n                 LOG.warn(\n                         \"Invalid http request. clientRequest = {} , uri = {}, info = {}\",\n-                        clientRequest.toString(),\n+                        clientRequest,\n                         clientRequest.uri(),\n                         ChannelUtils.channelInfoForLogging(ctx.channel()),\n                         clientRequest.decoderResult().cause());\n@@ -161,7 +161,7 @@ private void channelReadInternal(final ChannelHandlerContext ctx, Object msg) th\n             } else if (zuulRequest.getHeaders().getAll(HttpHeaderNames.HOST.toString()).size() > 1) {\n                 LOG.debug(\n                         \"Duplicate Host headers. clientRequest = {} , uri = {}, info = {}\",\n-                        clientRequest.toString(),\n+                        clientRequest,\n                         clientRequest.uri(),\n                         ChannelUtils.channelInfoForLogging(ctx.channel()));\n                 final ZuulException ze = new ZuulException(\"Duplicate Host headers\");",
      "parent_sha": "236bf03544b5d1d74866e08811b9cc5897df8d4b"
    }
  },
  {
    "oid": "03d269731c533d853678256181334067b7334c5f",
    "message": "Add some ZuulException constructors that allow avoiding generation of stacktraces",
    "date": "2016-09-22T00:28:52Z",
    "url": "https://github.com/Netflix/zuul/commit/03d269731c533d853678256181334067b7334c5f",
    "details": {
      "sha": "fb7941fb4cdc751fc1a3ada8faf0c3bcf508afc8",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/exception/ZuulException.java",
      "status": "modified",
      "additions": 10,
      "deletions": 2,
      "changes": 12,
      "blob_url": "https://github.com/Netflix/zuul/blob/03d269731c533d853678256181334067b7334c5f/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fexception%2FZuulException.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/03d269731c533d853678256181334067b7334c5f/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fexception%2FZuulException.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fexception%2FZuulException.java?ref=03d269731c533d853678256181334067b7334c5f",
      "patch": "@@ -44,7 +44,11 @@ public ZuulException(String sMessage, Throwable throwable, String errorCause) {\n      * @param errorCause\n      */\n     public ZuulException(String sMessage, String errorCause) {\n-        super(sMessage);\n+        this(sMessage, errorCause, false);\n+    }\n+\n+    public ZuulException(String sMessage, String errorCause, boolean noStackTrace) {\n+        super(sMessage, null, noStackTrace, ! noStackTrace);\n         this.errorCause = errorCause;\n     }\n \n@@ -59,7 +63,11 @@ public ZuulException(Throwable throwable) {\n     }\n \n     public ZuulException(String sMessage) {\n-        super(sMessage);\n+        this(sMessage, false);\n+    }\n+\n+    public ZuulException(String sMessage, boolean noStackTrace) {\n+        super(sMessage, null, noStackTrace, ! noStackTrace);\n         this.errorCause = \"GENERAL\";\n     }\n ",
      "parent_sha": "c5e8178ebd3a0005ac29b9a298ee4c8ffdfc5dfa"
    }
  },
  {
    "oid": "6e73878c0a1e3200f6b5623267e06c13f2e9d898",
    "message": "Revert sample server from WebSockes back to HTTP",
    "date": "2018-05-22T17:29:07Z",
    "url": "https://github.com/Netflix/zuul/commit/6e73878c0a1e3200f6b5623267e06c13f2e9d898",
    "details": {
      "sha": "90558dd055ffaad9582ec0bf39ff378c5b33a5dc",
      "filename": "zuul-sample/src/main/java/com/netflix/zuul/sample/SampleServerStartup.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/zuul/blob/6e73878c0a1e3200f6b5623267e06c13f2e9d898/zuul-sample%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fsample%2FSampleServerStartup.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/6e73878c0a1e3200f6b5623267e06c13f2e9d898/zuul-sample%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fsample%2FSampleServerStartup.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-sample%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fsample%2FSampleServerStartup.java?ref=6e73878c0a1e3200f6b5623267e06c13f2e9d898",
      "patch": "@@ -64,7 +64,7 @@ enum ServerType {\n     }\n \n     private static final String[] WWW_PROTOCOLS = new String[]{\"TLSv1.2\", \"TLSv1.1\", \"TLSv1\", \"SSLv3\"};\n-    private static final ServerType SERVER_TYPE = ServerType.WEBSOCKET;\n+    private static final ServerType SERVER_TYPE = ServerType.HTTP;\n     private final PushConnectionRegistry pushConnectionRegistry;\n     private final SamplePushMessageSenderInitializer pushSenderInitializer;\n ",
      "parent_sha": "8bde01cfe5dacb3f3f251ca62a5ab02df2fb3d4b"
    }
  },
  {
    "oid": "9f4f42331453b99949338fb3e417d779d9ae40ab",
    "message": "Ensuring that the message passed along from a filter failure does not cause ClassCastException when received by filter in next phase.",
    "date": "2015-05-21T01:38:43Z",
    "url": "https://github.com/Netflix/zuul/commit/9f4f42331453b99949338fb3e417d779d9ae40ab",
    "details": {
      "sha": "1cab6183644b12ba7ac1903a7b494aee8370e1d2",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/FilterProcessor.java",
      "status": "modified",
      "additions": 28,
      "deletions": 19,
      "changes": 47,
      "blob_url": "https://github.com/Netflix/zuul/blob/9f4f42331453b99949338fb3e417d779d9ae40ab/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/9f4f42331453b99949338fb3e417d779d9ae40ab/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java?ref=9f4f42331453b99949338fb3e417d779d9ae40ab",
      "patch": "@@ -38,6 +38,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import rx.Observable;\n+import rx.functions.Func1;\n \n import javax.inject.Inject;\n import javax.inject.Singleton;\n@@ -83,7 +84,7 @@ public void setFilterUsageNotifier(FilterUsageNotifier notifier) {\n \n     public Observable<ZuulMessage> applyInboundFilters(Observable<ZuulMessage> chain)\n     {\n-        return applyFilterPhase(chain, \"in\");\n+        return applyFilterPhase(chain, \"in\", (request) -> request);\n     }\n \n     public Observable<ZuulMessage> applyErrorFilterIfNeeded(Observable<ZuulMessage> chain)\n@@ -119,10 +120,10 @@ public Observable<ZuulMessage> applyErrorFilterIfNeeded(Observable<ZuulMessage>\n                 if (msg.getClass().isAssignableFrom(HttpResponseMessage.class)) {\n                     // if msg is a response, then we need to get it's request to pass to the error filter.\n                     HttpResponseMessage response = (HttpResponseMessage) msg;\n-                    return processAsyncFilter(response.getRequest(), endpointFilter);\n+                    return processAsyncFilter(response.getRequest(), endpointFilter, (m2) -> m2);\n                 }\n                 else {\n-                    return processAsyncFilter(msg, endpointFilter);\n+                    return processAsyncFilter(msg, endpointFilter, (m2) -> m2);\n                 }\n             }\n             else {\n@@ -169,8 +170,13 @@ public Observable<ZuulMessage> applyEndpointFilter(Observable<ZuulMessage> chain\n                 return applyErrorFilterIfNeeded(Observable.just(msg));\n             }\n \n-            // Apply this endpoint.\n-            return processAsyncFilter(msg, endpointFilter);\n+            // Apply this endpoint. Make the default filter result be a HttpResponseMessage so that if this filter apply fails, the next filter still gets\n+            // expected input.\n+            return processAsyncFilter(msg, endpointFilter, (request) -> {\n+                // If the Endpoint filter does not run, or throws an exception, then this should always require an error response to be sent.\n+                request.getContext().getAttributes().setShouldSendErrorResponse(true);\n+                return new HttpResponseMessage(request.getContext(), (HttpRequestMessage) request, 500);\n+            });\n         });\n \n         // Apply the error filters AGAIN. This is for if there was an error during the endpoint phase.\n@@ -182,7 +188,8 @@ public Observable<ZuulMessage> applyEndpointFilter(Observable<ZuulMessage> chain\n     public Observable<ZuulMessage> applyOutboundFilters(Observable<ZuulMessage> chain)\n     {\n         // Apply POST filters.\n-        chain = applyFilterPhase(chain, \"out\");\n+        chain = applyFilterPhase(chain, \"out\", (response) -> response );\n+\n \n         // TODO - can't apply error filters here because the input to the filter is now a response object, but endpoint/error filters\n         // need a request object.\n@@ -193,18 +200,18 @@ public Observable<ZuulMessage> applyOutboundFilters(Observable<ZuulMessage> chai\n         return chain;\n     }\n \n-    protected Observable<ZuulMessage> applyFilterPhase(Observable<ZuulMessage> chain, String filterType)\n+    protected Observable<ZuulMessage> applyFilterPhase(Observable<ZuulMessage> chain, String filterType, Func1<ZuulMessage, ZuulMessage> defaultFilterResultChooser)\n     {\n         List<ZuulFilter> filters = filterLoader.getFiltersByType(filterType);\n         for (ZuulFilter filter: filters) {\n-            chain = processFilterAsObservable(chain, filter).single();\n+            chain = processFilterAsObservable(chain, filter, defaultFilterResultChooser).single();\n         }\n         return chain;\n     }\n \n-    public Observable<ZuulMessage> processFilterAsObservable(Observable<ZuulMessage> input, ZuulFilter filter)\n+    public Observable<ZuulMessage> processFilterAsObservable(Observable<ZuulMessage> input, ZuulFilter filter, Func1<ZuulMessage, ZuulMessage> defaultFilterResultChooser)\n     {\n-        return input.flatMap(msg -> processAsyncFilter(msg, filter) );\n+        return input.flatMap(msg -> processAsyncFilter(msg, filter, defaultFilterResultChooser) );\n     }\n \n     /**\n@@ -215,7 +222,7 @@ public Observable<ZuulMessage> processFilterAsObservable(Observable<ZuulMessage>\n      * @param filter IZuulFilter\n      * @return the return value for that filter\n      */\n-    public Observable<ZuulMessage> processAsyncFilter(ZuulMessage msg, ZuulFilter filter)\n+    public Observable<ZuulMessage> processAsyncFilter(ZuulMessage msg, ZuulFilter filter, Func1<ZuulMessage, ZuulMessage> defaultFilterResultChooser)\n     {\n         final FilterExecInfo info = new FilterExecInfo();\n         info.bDebug = msg.getContext().getAttributes().debugRouting();\n@@ -230,35 +237,37 @@ public Observable<ZuulMessage> processAsyncFilter(ZuulMessage msg, ZuulFilter fi\n         long ltime = System.currentTimeMillis();\n         try {\n             if (filter.isDisabled()) {\n-                resultObs = Observable.just(msg);\n+                resultObs = Observable.just(defaultFilterResultChooser.call(msg));\n                 info.status = ExecutionStatus.DISABLED;\n             } else {\n                 // Only apply the filter if both the shouldFilter() method AND any additional\n                 // ShouldFilter impl pass.\n                 if (filter.shouldFilter(msg)) {\n                     resultObs = filter.applyAsync(msg).single();\n                 } else {\n-                    resultObs = Observable.just(msg);\n+                    resultObs = Observable.just(defaultFilterResultChooser.call(msg));\n                     info.status = ExecutionStatus.SKIPPED;\n                 }\n             }\n         }\n         catch (Exception e) {\n-            resultObs = Observable.just(msg);\n+            msg.getContext().getAttributes().setThrowable(e);\n+            resultObs = Observable.just(defaultFilterResultChooser.call(msg));\n             info.status = ExecutionStatus.FAILED;\n             recordFilterError(filter, msg, e);\n         }\n \n         // Handle errors from the filter. Don't break out of the filter chain - instead just record info about the error\n         // in context, and continue.\n         resultObs = resultObs.onErrorReturn((e) -> {\n+            msg.getContext().getAttributes().setThrowable(e);\n             info.status = ExecutionStatus.FAILED;\n             recordFilterError(filter, msg, e);\n-            return msg;\n+            return defaultFilterResultChooser.call(msg);\n         });\n \n         // If no resultContext returned from filter, then use the original context.\n-        resultObs = resultObs.map(msg2 -> msg2 == null ? msg : msg2);\n+        resultObs = resultObs.map(msg2 -> msg2 == null ? defaultFilterResultChooser.call(msg) : msg2);\n \n         // Record info when filter processing completes.\n         resultObs = resultObs.doOnCompleted(() -> {\n@@ -371,15 +380,15 @@ public void before() {\n         @Test\n         public void testProcessFilter() throws Exception {\n             when(filter.applyAsync(request)).thenReturn(Observable.just(request));\n-            processor.processAsyncFilter(request, filter).toBlocking().first();\n+            processor.processAsyncFilter(request, filter, (m) -> m).toBlocking().first();\n             verify(filter, times(1)).applyAsync(request);\n         }\n \n         @Test\n         public void testProcessFilter_ShouldFilterFalse() throws Exception\n         {\n             when(filter.shouldFilter(request)).thenReturn(false);\n-            processor.processAsyncFilter(request, filter).toBlocking().first();\n+            processor.processAsyncFilter(request, filter, (m) -> m).toBlocking().first();\n             verify(filter, times(0)).applyAsync(request);\n         }\n \n@@ -388,7 +397,7 @@ public void testProcessFilterException()\n         {\n             Exception e = new RuntimeException(\"Blah\");\n             when(filter.applyAsync(request)).thenThrow(e);\n-            processor.processAsyncFilter(request, filter).toBlocking().first();\n+            processor.processAsyncFilter(request, filter, (m) -> m).toBlocking().first();\n \n             verify(processor).recordFilterError(filter, request, e);\n ",
      "parent_sha": "e0cd660635da681ed3a3f90a88a35b73fc74b2c0"
    }
  },
  {
    "oid": "0d2c5f69faf16534e3f07f7e41e4cd9b25813c14",
    "message": "don't compare bytebufs",
    "date": "2022-10-18T23:48:24Z",
    "url": "https://github.com/Netflix/zuul/commit/0d2c5f69faf16534e3f07f7e41e4cd9b25813c14",
    "details": {
      "sha": "c814762f44180c4ada1aca747336c8b0fbbe55b4",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/context/Debug.java",
      "status": "modified",
      "additions": 8,
      "deletions": 5,
      "changes": 13,
      "blob_url": "https://github.com/Netflix/zuul/blob/0d2c5f69faf16534e3f07f7e41e4cd9b25813c14/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fcontext%2FDebug.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/0d2c5f69faf16534e3f07f7e41e4cd9b25813c14/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fcontext%2FDebug.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fcontext%2FDebug.java?ref=0d2c5f69faf16534e3f07f7e41e4cd9b25813c14",
      "patch": "@@ -19,6 +19,7 @@\n import com.netflix.zuul.message.ZuulMessage;\n import com.netflix.zuul.message.http.HttpRequestInfo;\n import com.netflix.zuul.message.http.HttpResponseInfo;\n+import io.netty.util.ReferenceCounted;\n import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.List;\n@@ -131,11 +132,13 @@ public static void compareContextState(String filterName, SessionContext context\n             if ((!key.equals(\"routingDebug\") && !key.equals(\"requestDebug\"))) {\n                 Object newValue = context.get(key);\n                 Object oldValue = copy.get(key);\n-                if (oldValue == null && newValue != null) {\n-                    addRoutingDebug(context, \"{\" + filterName + \"} added \" + key + \"=\" + newValue.toString());\n-                } else if (oldValue != null && newValue != null) {\n-                    if (!(oldValue.equals(newValue))) {\n-                        addRoutingDebug(context, \"{\" +filterName + \"} changed \" + key + \"=\" + newValue.toString());\n+                if (!(newValue instanceof ReferenceCounted) && !(oldValue instanceof ReferenceCounted)) {\n+                    if (oldValue == null && newValue != null) {\n+                        addRoutingDebug(context, \"{\" + filterName + \"} added \" + key + \"=\" + newValue.toString());\n+                    } else if (oldValue != null && newValue != null) {\n+                        if (!(oldValue.equals(newValue))) {\n+                            addRoutingDebug(context, \"{\" +filterName + \"} changed \" + key + \"=\" + newValue.toString());\n+                        }\n                     }\n                 }\n             }",
      "parent_sha": "69956831ad3fd0a89571a0b075bb45aa5feb4998"
    }
  },
  {
    "oid": "735ac342f4921ae4f3ce31bd38d2db1b93c99763",
    "message": "zuul-core: Add sockaddr overloads for server startup logging (#649)\n\n* Lowered severity from warn to info\r\n* Made the calls final since I don't think they need to be overridden\r\n* Made generics more relaxed since logger doesn't actually use the values.\r\n* Unchained `logPortConfigured(int)` from `logPortConfigured(int, ServerSslConfig)`, since the overload of the SSL log should not affect the other.\r\n\r\nIn theory these functions could be static, but I think that would be API limiting if in the future they turned out to depend  on the BaseServerStarter instance.",
    "date": "2019-10-23T22:30:39Z",
    "url": "https://github.com/Netflix/zuul/commit/735ac342f4921ae4f3ce31bd38d2db1b93c99763",
    "details": {
      "sha": "c0c6549074820157633a5dc4eb8240291850a871",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/server/BaseServerStartup.java",
      "status": "modified",
      "additions": 36,
      "deletions": 13,
      "changes": 49,
      "blob_url": "https://github.com/Netflix/zuul/blob/735ac342f4921ae4f3ce31bd38d2db1b93c99763/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FBaseServerStartup.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/735ac342f4921ae4f3ce31bd38d2db1b93c99763/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FBaseServerStartup.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FBaseServerStartup.java?ref=735ac342f4921ae4f3ce31bd38d2db1b93c99763",
      "patch": "@@ -45,7 +45,9 @@\n import io.netty.handler.ssl.SslContext;\n import io.netty.util.DomainNameMapping;\n import io.netty.util.concurrent.GlobalEventExecutor;\n+import java.net.InetSocketAddress;\n import java.net.SocketAddress;\n+import javax.annotation.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -267,26 +269,47 @@ public static void addHttp2DefaultConfig(ChannelConfig config, String portName)\n                 chooseBooleanChannelProperty(portName, \"connection.close.swallow.unknown.exceptions\", false)));\n     }\n \n-    protected void logPortConfigured(int port)\n-    {\n-        logPortConfigured(port, (ServerSslConfig) null);\n+    /**\n+     * Use {@link #logAddrConfigured(SocketAddress)} instead.\n+     */\n+    @Deprecated\n+    protected void logPortConfigured(int port) {\n+        logAddrConfigured(new InetSocketAddress(port));\n     }\n \n-    protected void logPortConfigured(int port, ServerSslConfig serverSslConfig)\n-    {\n-        String msg = \"Configured port: \" + port;\n+    /**\n+     * Use {@link #logAddrConfigured(SocketAddress, ServerSslConfig)} instead.\n+     */\n+    @Deprecated\n+    protected void logPortConfigured(int port, ServerSslConfig serverSslConfig) {\n+        logAddrConfigured(new InetSocketAddress(port), serverSslConfig);\n+    }\n+\n+    /**\n+     * Use {@link #logAddrConfigured(SocketAddress, DomainNameMapping)} instead.\n+     */\n+    @Deprecated\n+    protected void logPortConfigured(int port, DomainNameMapping<SslContext> sniMapping) {\n+        logAddrConfigured(new InetSocketAddress(port), sniMapping);\n+    }\n+\n+    protected final void logAddrConfigured(SocketAddress socketAddress) {\n+        LOG.info(\"Configured address: {}\", socketAddress);\n+    }\n+\n+    protected final void logAddrConfigured(SocketAddress socketAddress, @Nullable ServerSslConfig serverSslConfig) {\n+        String msg = \"Configured address: \" + socketAddress;\n         if (serverSslConfig != null) {\n-            msg = msg + \" with SSL config: \" + serverSslConfig.toString();\n+            msg = msg + \" with SSL config: \" + serverSslConfig;\n         }\n-        LOG.warn(msg);\n+        LOG.info(msg);\n     }\n \n-    protected void logPortConfigured(int port, DomainNameMapping<SslContext> sniMapping)\n-    {\n-        String msg = \"Configured port: \" + port;\n+    protected final void logAddrConfigured(SocketAddress socketAddress, @Nullable DomainNameMapping<?> sniMapping) {\n+        String msg = \"Configured address: \" + socketAddress;\n         if (sniMapping != null) {\n-            msg = msg + \" with SNI config: \" + sniMapping.asMap().toString();\n+            msg = msg + \" with SNI config: \" + sniMapping.asMap();\n         }\n-        LOG.warn(msg);\n+        LOG.info(msg);\n     }\n }",
      "parent_sha": "7257087f872df7bee9ef922aeb44fcf6c2363973"
    }
  },
  {
    "oid": "b940881adc9e9c370704f26ecf2f23c18d5c932e",
    "message": "refactor processing chain to allow for extensibility and to show clearer intent",
    "date": "2016-08-02T01:21:27Z",
    "url": "https://github.com/Netflix/zuul/commit/b940881adc9e9c370704f26ecf2f23c18d5c932e",
    "details": {
      "sha": "a5313fa260cf0092d373bf3a19527f6ffcdf5e47",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/FilterProcessorImpl.java",
      "status": "modified",
      "additions": 20,
      "deletions": 13,
      "changes": 33,
      "blob_url": "https://github.com/Netflix/zuul/blob/b940881adc9e9c370704f26ecf2f23c18d5c932e/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessorImpl.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/b940881adc9e9c370704f26ecf2f23c18d5c932e/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessorImpl.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessorImpl.java?ref=b940881adc9e9c370704f26ecf2f23c18d5c932e",
      "patch": "@@ -67,19 +67,28 @@ public FilterProcessorImpl(FilterLoader loader, FilterUsageNotifier usageNotifie\n     @Override\n     public Observable<ZuulMessage> applyFilterChain(ZuulMessage msg)\n     {\n-        Observable<ZuulMessage> chain;\n+        Observable<ZuulMessage> chain = Observable.just(msg);\n \n-        Iterator<ZuulFilter> inFilterIterator = filterLoader.getFiltersByType(FilterType.INBOUND).iterator();\n-        chain = chainFilters(msg, inFilterIterator, FilterType.INBOUND);\n+        chain = applyInboundFilters(msg, chain);\n+        chain = applyEndpointFilter(msg, chain);\n+        chain = applyOutboundFilters(msg, chain);\n \n-        chain = applyEndpointFilter(chain);\n+        return chain;\n+    }\n \n-        chain = chain.flatMap(msg2 -> {\n-            Iterator<ZuulFilter> outFilterIterator = filterLoader.getFiltersByType(FilterType.OUTBOUND).iterator();\n-            return chainFilters(msg2, outFilterIterator, FilterType.OUTBOUND);\n-        });\n+    protected Observable<ZuulMessage> applyInboundFilters(final ZuulMessage message, final Observable<ZuulMessage> chain) {\n+        return applyFilters(chain, FilterType.INBOUND);\n+    }\n \n-        return chain;\n+    protected Observable<ZuulMessage> applyOutboundFilters(final ZuulMessage message, final Observable<ZuulMessage> chain) {\n+        return applyFilters(chain, FilterType.OUTBOUND);\n+    }\n+\n+    private Observable<ZuulMessage> applyFilters(final Observable<ZuulMessage> chain, final FilterType type) {\n+        return chain.flatMap(msg -> {\n+            Iterator<ZuulFilter> filterIterator = filterLoader.getFiltersByType(type).iterator();\n+            return chainFilters(msg, filterIterator, type);\n+        });\n     }\n \n \n@@ -215,9 +224,9 @@ protected HttpRequestMessage getRequestMessage(ZuulMessage msg)\n      * @param chain\n      * @return\n      */\n-    public Observable<ZuulMessage> applyEndpointFilter(Observable<ZuulMessage> chain)\n+    public Observable<ZuulMessage> applyEndpointFilter(final ZuulMessage message, final Observable<ZuulMessage> chain)\n     {\n-        chain = chain.flatMap(msg -> {\n+        return chain.flatMap(msg -> {\n \n             SessionContext context = msg.getContext();\n \n@@ -261,8 +270,6 @@ public Observable<ZuulMessage> applyEndpointFilter(Observable<ZuulMessage> chain\n             // Apply this endpoint.\n             return processAsyncFilter(msg, endpointFilter, true);\n         });\n-\n-        return chain;\n     }\n \n     private HttpResponseMessageImpl defaultErrorResponse(HttpRequestMessage request)",
      "parent_sha": "09740c7798190df3c8308a98790c7c054f7d153d"
    }
  },
  {
    "oid": "82af26593b62fcb78844affea2d42ebadd7f0346",
    "message": "Made the handling of SocketTimeoutException when reading request body be configurable. Either just log and continue with an empty body, or respond with a 400 status error to client.",
    "date": "2015-09-03T22:19:49Z",
    "url": "https://github.com/Netflix/zuul/commit/82af26593b62fcb78844affea2d42ebadd7f0346",
    "details": {
      "sha": "a3bdf73d4ccccd2475b37852426a066046a8f29d",
      "filename": "zuul-servletapi/src/main/java/com/netflix/zuul/context/ServletSessionContextFactory.java",
      "status": "modified",
      "additions": 18,
      "deletions": 8,
      "changes": 26,
      "blob_url": "https://github.com/Netflix/zuul/blob/82af26593b62fcb78844affea2d42ebadd7f0346/zuul-servletapi%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fcontext%2FServletSessionContextFactory.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/82af26593b62fcb78844affea2d42ebadd7f0346/zuul-servletapi%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fcontext%2FServletSessionContextFactory.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-servletapi%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fcontext%2FServletSessionContextFactory.java?ref=82af26593b62fcb78844affea2d42ebadd7f0346",
      "patch": "@@ -15,6 +15,8 @@\n  */\n package com.netflix.zuul.context;\n \n+import com.netflix.config.DynamicBooleanProperty;\n+import com.netflix.config.DynamicPropertyFactory;\n import com.netflix.zuul.bytebuf.ByteBufUtils;\n import com.netflix.zuul.exception.ZuulException;\n import com.netflix.zuul.message.Header;\n@@ -47,6 +49,9 @@ public class ServletSessionContextFactory implements SessionContextFactory<HttpS\n     private static final Logger LOG = LoggerFactory.getLogger(ServletSessionContextFactory.class);\n     private static final String JAVAX_SERVLET_REQUEST_X509_CERTIFICATE = \"javax.servlet.request.X509Certificate\";\n \n+    private static final DynamicBooleanProperty SHOULD_ERROR_ON_SOCKET_READ_TIMEOUT = DynamicPropertyFactory.getInstance().getBooleanProperty(\n+            \"zuul.ServletSessionContextFactory.errorOnSocketReadTimeout\", false);\n+\n     @Override\n     public ZuulMessage create(SessionContext context, HttpServletRequest servletRequest)\n     {\n@@ -93,22 +98,27 @@ public ZuulMessage create(SessionContext context, HttpServletRequest servletRequ\n             Observable<ByteBuf> bodyObs = ByteBufUtils.fromInputStream(bodyInput);\n             bodyObs = bodyObs.onErrorReturn((e) -> {\n                 if (SocketTimeoutException.class.isAssignableFrom(e.getClass())) {\n+\n                     // This can happen if the request body is smaller than the size specified in the\n                     // Content-Length header, and using tomcat APR connector.\n                     LOG.error(\"SocketTimeoutException reading request body from inputstream. error=\"\n                             + String.valueOf(e.getMessage()) + \", request-info: \" + request.getInfoForLogging());\n-                } else {\n+\n+                    // Store the exception.\n+                    ZuulException ze = new ZuulException(e.getMessage(), e, \"TIMEOUT_READING_REQ_BODY\");\n+                    ze.setStatusCode(400);\n+                    request.getContext().setError(ze);\n+\n+                    if (SHOULD_ERROR_ON_SOCKET_READ_TIMEOUT.get()) {\n+                        // Flag to respond to client with an error. As we don't want to attempt proxying if we failed to read the body.\n+                        request.getContext().setShouldSendErrorResponse(true);\n+                    }\n+                }\n+                else {\n                     LOG.error(\"Error reading request body from inputstream. error=\"\n                             + String.valueOf(e.getMessage()) + \", request-info: \" + request.getInfoForLogging());\n                 }\n \n-                // Store the exception, and flag to respond to client with an error. As we don't want\n-                // to attempt proxying if we failed to read the body.\n-                ZuulException ze = new ZuulException(e.getMessage(), e, \"TIMEOUT_READING_REQ_BODY\");\n-                ze.setStatusCode(400);\n-                request.getContext().setError(ze);\n-                request.getContext().setShouldSendErrorResponse(true);\n-\n                 // Return an empty bytebuf.\n                 return Unpooled.EMPTY_BUFFER;\n             });",
      "parent_sha": "976835aa79083943ed1d40fc597d0dc008c3a08c"
    }
  },
  {
    "oid": "2193f0bdec12bab1550c56ac1b6b73d0141aa2f7",
    "message": "Fix NPE",
    "date": "2018-05-03T22:48:49Z",
    "url": "https://github.com/Netflix/zuul/commit/2193f0bdec12bab1550c56ac1b6b73d0141aa2f7",
    "details": {
      "sha": "1df683f76e5a34f96d63c0851db6632e03ee1100",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/filter/ZuulFilterChainHandler.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/zuul/blob/2193f0bdec12bab1550c56ac1b6b73d0141aa2f7/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ffilter%2FZuulFilterChainHandler.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/2193f0bdec12bab1550c56ac1b6b73d0141aa2f7/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ffilter%2FZuulFilterChainHandler.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ffilter%2FZuulFilterChainHandler.java?ref=2193f0bdec12bab1550c56ac1b6b73d0141aa2f7",
      "patch": "@@ -77,7 +77,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception\n \n             requestFilterChain.filter(zuulRequest);\n         }\n-        else if (msg instanceof HttpContent) {\n+        else if ((msg instanceof HttpContent)&&(zuulRequest != null)) {\n             requestFilterChain.filter(zuulRequest, (HttpContent) msg);\n         }\n         else {",
      "parent_sha": "8c5714ea737437c790143cb8ae22441b5202ad8a"
    }
  },
  {
    "oid": "10f787abfbfca1af2c2397fcc7f02a2cd961ac3f",
    "message": "Only capture the first failure state in passport future listener (#1347)",
    "date": "2022-10-19T16:48:54Z",
    "url": "https://github.com/Netflix/zuul/commit/10f787abfbfca1af2c2397fcc7f02a2cd961ac3f",
    "details": {
      "sha": "17127f80b75399b94d1c6a37305ba8428cb8b0be",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/insights/PassportStateListener.java",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/Netflix/zuul/blob/10f787abfbfca1af2c2397fcc7f02a2cd961ac3f/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Finsights%2FPassportStateListener.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/10f787abfbfca1af2c2397fcc7f02a2cd961ac3f/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Finsights%2FPassportStateListener.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Finsights%2FPassportStateListener.java?ref=10f787abfbfca1af2c2397fcc7f02a2cd961ac3f",
      "patch": "@@ -48,8 +48,12 @@ public void operationComplete(Future future) throws Exception\n             passport.add(successState);\n         }\n         else {\n-            if (failState != null)\n-                passport.add(failState);\n+            if (failState != null) {\n+                // only capture a single failure state event,\n+                // as sending content errors will fire for all content chunks,\n+                // and we only need the first one\n+                passport.addIfNotAlready(failState);\n+            }\n         }\n     }\n }\n\\ No newline at end of file",
      "parent_sha": "a6cbfe9ef081309dc70bf7541f1430a656746f60"
    }
  },
  {
    "oid": "0b0830e7c02e554c0818b90aff2b3c119ac74cf2",
    "message": "Bugfix for incorrect parsing of uri query strings that have a key without a value (eg. \"key1=&key2=\")",
    "date": "2017-08-25T22:17:07Z",
    "url": "https://github.com/Netflix/zuul/commit/0b0830e7c02e554c0818b90aff2b3c119ac74cf2",
    "details": {
      "sha": "c7aa8e328e1b05fda5588c55424d227ad7636bf4",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/message/http/HttpQueryParams.java",
      "status": "modified",
      "additions": 29,
      "deletions": 1,
      "changes": 30,
      "blob_url": "https://github.com/Netflix/zuul/blob/0b0830e7c02e554c0818b90aff2b3c119ac74cf2/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2Fhttp%2FHttpQueryParams.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/0b0830e7c02e554c0818b90aff2b3c119ac74cf2/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2Fhttp%2FHttpQueryParams.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2Fhttp%2FHttpQueryParams.java?ref=0b0830e7c02e554c0818b90aff2b3c119ac74cf2",
      "patch": "@@ -64,7 +64,7 @@ public static HttpQueryParams parse(String queryString)\n         while (st.hasMoreTokens()) {\n             String s = st.nextToken();\n             i = s.indexOf(\"=\");\n-            if (i > 0 && s.length() > i + 1) {\n+            if (i > 0 && s.length() >= i + 1) {\n                 String name = s.substring(0, i);\n                 String value = s.substring(i + 1);\n \n@@ -283,5 +283,33 @@ public void testEquals()\n \n             assertEquals(qp1, qp2);\n         }\n+\n+        @Test\n+        public void testParseKeysWithoutValues()\n+        {\n+            HttpQueryParams expected = new HttpQueryParams();\n+            expected.add(\"k1\", \"\");\n+            expected.add(\"k2\", \"v2\");\n+            expected.add(\"k3\", \"\");\n+\n+            HttpQueryParams actual = HttpQueryParams.parse(\"k1=&k2=v2&k3=\");\n+\n+            assertEquals(expected, actual);\n+\n+            assertEquals(\"k1=&k2=v2&k3=\", actual.toEncodedString());\n+        }\n+\n+        @Test\n+        public void testParseKeyWithoutValue()\n+        {\n+            HttpQueryParams expected = new HttpQueryParams();\n+            expected.add(\"k1\", \"\");\n+\n+            HttpQueryParams actual = HttpQueryParams.parse(\"k1=\");\n+\n+            assertEquals(expected, actual);\n+\n+            assertEquals(\"k1=\", actual.toEncodedString());\n+        }\n     }\n }",
      "parent_sha": "1a1e6b02d41a792f06cb6e7fec13249add9b885f"
    }
  },
  {
    "oid": "d97cead4fbc09d13d648bb751b68f2cb67e7c21f",
    "message": "Instrument circuit breaker in the connection pool (#1693)\n\n* Switch to using registry instead of static. Add counter for circuit breaker\r\n\r\n* Move underscore to prefix to improve readability",
    "date": "2023-11-03T14:50:00Z",
    "url": "https://github.com/Netflix/zuul/commit/d97cead4fbc09d13d648bb751b68f2cb67e7c21f",
    "details": {
      "sha": "fbee8bab3fa613838c4cb8b9479cf3a725223630",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/connectionpool/DefaultClientChannelManager.java",
      "status": "modified",
      "additions": 41,
      "deletions": 32,
      "changes": 73,
      "blob_url": "https://github.com/Netflix/zuul/blob/d97cead4fbc09d13d648bb751b68f2cb67e7c21f/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fconnectionpool%2FDefaultClientChannelManager.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/d97cead4fbc09d13d648bb751b68f2cb67e7c21f/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fconnectionpool%2FDefaultClientChannelManager.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fconnectionpool%2FDefaultClientChannelManager.java?ref=d97cead4fbc09d13d648bb751b68f2cb67e7c21f",
      "patch": "@@ -22,6 +22,7 @@\n import com.netflix.spectator.api.Counter;\n import com.netflix.spectator.api.Registry;\n import com.netflix.spectator.api.histogram.PercentileTimer;\n+import com.netflix.spectator.api.patterns.PolledMeter;\n import com.netflix.zuul.discovery.DiscoveryResult;\n import com.netflix.zuul.discovery.DynamicServerResolver;\n import com.netflix.zuul.discovery.ResolverResult;\n@@ -62,12 +63,12 @@\n public class DefaultClientChannelManager implements ClientChannelManager {\n     private static final Logger LOG = LoggerFactory.getLogger(DefaultClientChannelManager.class);\n \n-    public static final String METRIC_PREFIX = \"connectionpool\";\n+    public static final String METRIC_PREFIX = \"connectionpool_\";\n \n     private final Resolver<DiscoveryResult> dynamicServerResolver;\n     private final ConnectionPoolConfig connPoolConfig;\n     private final IClientConfig clientConfig;\n-    private final Registry spectatorRegistry;\n+    private final Registry registry;\n \n     private final OriginName originName;\n \n@@ -89,6 +90,8 @@ public class DefaultClientChannelManager implements ClientChannelManager {\n     private final Counter connTakenFromPoolIsNotOpen;\n     private final Counter maxConnsPerHostExceededCounter;\n     private final Counter closeWrtBusyConnCounter;\n+    private final Counter circuitBreakerClose;\n+\n     private final PercentileTimer connEstablishTimer;\n     private final AtomicInteger connsInPool;\n     private final AtomicInteger connsInUse;\n@@ -100,55 +103,49 @@ public class DefaultClientChannelManager implements ClientChannelManager {\n \n     public static final String IDLE_STATE_HANDLER_NAME = \"idleStateHandler\";\n \n-    public DefaultClientChannelManager(OriginName originName, IClientConfig clientConfig, Registry spectatorRegistry) {\n-        this(originName, clientConfig, new DynamicServerResolver(clientConfig), spectatorRegistry);\n+    public DefaultClientChannelManager(OriginName originName, IClientConfig clientConfig, Registry registry) {\n+        this(originName, clientConfig, new DynamicServerResolver(clientConfig), registry);\n     }\n \n     public DefaultClientChannelManager(\n-            OriginName originName,\n-            IClientConfig clientConfig,\n-            Resolver<DiscoveryResult> resolver,\n-            Registry spectatorRegistry) {\n+            OriginName originName, IClientConfig clientConfig, Resolver<DiscoveryResult> resolver, Registry registry) {\n         this.originName = Objects.requireNonNull(originName, \"originName\");\n         this.dynamicServerResolver = resolver;\n \n-        String metricId = originName.getMetricId();\n-\n         this.clientConfig = clientConfig;\n-        this.spectatorRegistry = spectatorRegistry;\n+        this.registry = registry;\n         this.perServerPools = new ConcurrentHashMap<>(200);\n \n         this.connPoolConfig = new ConnectionPoolConfigImpl(originName, this.clientConfig);\n \n-        this.createNewConnCounter = SpectatorUtils.newCounter(METRIC_PREFIX + \"_create\", metricId);\n-        this.createConnSucceededCounter = SpectatorUtils.newCounter(METRIC_PREFIX + \"_create_success\", metricId);\n-        this.createConnFailedCounter = SpectatorUtils.newCounter(METRIC_PREFIX + \"_create_fail\", metricId);\n-\n-        this.closeConnCounter = SpectatorUtils.newCounter(METRIC_PREFIX + \"_close\", metricId);\n-        this.closeAbovePoolHighWaterMarkCounter =\n-                SpectatorUtils.newCounter(METRIC_PREFIX + \"_closeAbovePoolHighWaterMark\", metricId);\n-        this.closeExpiredConnLifetimeCounter =\n-                SpectatorUtils.newCounter(METRIC_PREFIX + \"_closeExpiredConnLifetime\", metricId);\n-        this.requestConnCounter = SpectatorUtils.newCounter(METRIC_PREFIX + \"_request\", metricId);\n-        this.reuseConnCounter = SpectatorUtils.newCounter(METRIC_PREFIX + \"_reuse\", metricId);\n-        this.releaseConnCounter = SpectatorUtils.newCounter(METRIC_PREFIX + \"_release\", metricId);\n-        this.alreadyClosedCounter = SpectatorUtils.newCounter(METRIC_PREFIX + \"_alreadyClosed\", metricId);\n-        this.connTakenFromPoolIsNotOpen = SpectatorUtils.newCounter(METRIC_PREFIX + \"_fromPoolIsClosed\", metricId);\n-        this.maxConnsPerHostExceededCounter =\n-                SpectatorUtils.newCounter(METRIC_PREFIX + \"_maxConnsPerHostExceeded\", metricId);\n-        this.closeWrtBusyConnCounter = SpectatorUtils.newCounter(METRIC_PREFIX + \"_closeWrtBusyConnCounter\", metricId);\n+        this.createNewConnCounter = newCounter(\"create\");\n+        this.createConnSucceededCounter = newCounter(\"create_success\");\n+        this.createConnFailedCounter = newCounter(\"create_fail\");\n+\n+        this.closeConnCounter = newCounter(\"close\");\n+        this.closeAbovePoolHighWaterMarkCounter = newCounter(\"closeAbovePoolHighWaterMark\");\n+        this.closeExpiredConnLifetimeCounter = newCounter(\"closeExpiredConnLifetime\");\n+        this.requestConnCounter = newCounter(\"request\");\n+        this.reuseConnCounter = newCounter(\"reuse\");\n+        this.releaseConnCounter = newCounter(\"release\");\n+        this.alreadyClosedCounter = newCounter(\"alreadyClosed\");\n+        this.connTakenFromPoolIsNotOpen = newCounter(\"fromPoolIsClosed\");\n+        this.maxConnsPerHostExceededCounter = newCounter(\"maxConnsPerHostExceeded\");\n+        this.closeWrtBusyConnCounter = newCounter(\"closeWrtBusyConnCounter\");\n+        this.circuitBreakerClose = newCounter(\"closeCircuitBreaker\");\n+\n         this.connEstablishTimer = PercentileTimer.get(\n-                spectatorRegistry, spectatorRegistry.createId(METRIC_PREFIX + \"_createTiming\", \"id\", metricId));\n-        this.connsInPool = SpectatorUtils.newGauge(METRIC_PREFIX + \"_inPool\", metricId, new AtomicInteger());\n-        this.connsInUse = SpectatorUtils.newGauge(METRIC_PREFIX + \"_inUse\", metricId, new AtomicInteger());\n+                registry, registry.createId(METRIC_PREFIX + \"createTiming\", \"id\", originName.getMetricId()));\n+        this.connsInPool = newGauge(\"inPool\");\n+        this.connsInUse = newGauge(\"inUse\");\n     }\n \n     @Override\n     public void init() {\n         dynamicServerResolver.setListener(new ServerPoolListener());\n         // Load channel initializer and conn factory.\n         // We don't do this within the constructor because some subclass may not be initialized until post-construct.\n-        this.channelInitializer = createChannelInitializer(clientConfig, connPoolConfig, spectatorRegistry);\n+        this.channelInitializer = createChannelInitializer(clientConfig, connPoolConfig, registry);\n         this.clientConnFactory = createNettyClientConnectionFactory(connPoolConfig, channelInitializer);\n     }\n \n@@ -242,6 +239,7 @@ public boolean release(final PooledConnection conn) {\n             LOG.debug(\n                     \"[{}] closing conn, server circuit breaker tripped\",\n                     conn.getChannel().id());\n+            circuitBreakerClose.increment();\n             // Don't put conns for currently circuit-tripped servers back into the pool.\n             conn.setInPool(false);\n             conn.close();\n@@ -492,4 +490,15 @@ static SocketAddress pickAddressInternal(ResolverResult chosenServer, @Nullable\n     protected SocketAddress pickAddress(DiscoveryResult chosenServer) {\n         return pickAddressInternal(chosenServer, connPoolConfig.getOriginName());\n     }\n+\n+    private AtomicInteger newGauge(String name) {\n+        return PolledMeter.using(registry)\n+                .withName(METRIC_PREFIX + name)\n+                .withTag(\"id\", originName.getMetricId())\n+                .monitorValue(new AtomicInteger());\n+    }\n+\n+    private Counter newCounter(String name) {\n+        return registry.counter(METRIC_PREFIX + name, \"id\", originName.getMetricId());\n+    }\n }",
      "parent_sha": "ffce2128a17aee3e2c89117066af914d06cbf3a1"
    }
  },
  {
    "oid": "02aa84eeb98411df6175ea0d929beac99b352b10",
    "message": "only parses params from body for POSTS with form bodies",
    "date": "2015-05-15T22:14:06Z",
    "url": "https://github.com/Netflix/zuul/commit/02aa84eeb98411df6175ea0d929beac99b352b10",
    "details": {
      "sha": "814f143eaad1ea580115228619124f49344c3d20",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/http/HttpServletRequestWrapper.java",
      "status": "modified",
      "additions": 102,
      "deletions": 56,
      "changes": 158,
      "blob_url": "https://github.com/Netflix/zuul/blob/02aa84eeb98411df6175ea0d929beac99b352b10/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fhttp%2FHttpServletRequestWrapper.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/02aa84eeb98411df6175ea0d929beac99b352b10/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fhttp%2FHttpServletRequestWrapper.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fhttp%2FHttpServletRequestWrapper.java?ref=02aa84eeb98411df6175ea0d929beac99b352b10",
      "patch": "@@ -164,40 +164,44 @@ private void parseRequest() throws IOException {\n                 LOG.error(\"Error checking if request body gzipped!\", e);\n             }\n \n-            String enc = req.getCharacterEncoding();\n-\n-            if (enc == null)\n-                enc = \"UTF-8\";\n-            String s = new String(contentData, enc), name, value;\n-            StringTokenizer st = new StringTokenizer(s, \"&\");\n-            int i;\n-\n-            boolean decode = req.getContentType() != null && req.getContentType().equalsIgnoreCase(\"application/x-www-form-urlencoded\");\n-            while (st.hasMoreTokens()) {\n-                s = st.nextToken();\n-                i = s.indexOf(\"=\");\n-                if (i > 0 && s.length() > i + 1) {\n-                    name = s.substring(0, i);\n-                    value = s.substring(i + 1);\n-                    if (decode) {\n-                        try {\n-                            name = URLDecoder.decode(name, \"UTF-8\");\n-                        } catch (Exception e) {\n+            final boolean isPost = req.getMethod().equals(\"POST\");\n+            final boolean isFormBody = req.getContentType().contains(\"application/x-www-form-urlencoded\");\n+\n+            // only does magic body param parsing for POST form bodies\n+            if (isPost && isFormBody) {\n+                String enc = req.getCharacterEncoding();\n+\n+                if (enc == null) enc = \"UTF-8\";\n+                String s = new String(contentData, enc), name, value;\n+                StringTokenizer st = new StringTokenizer(s, \"&\");\n+                int i;\n+\n+                boolean decode = req.getContentType() != null;\n+                while (st.hasMoreTokens()) {\n+                    s = st.nextToken();\n+                    i = s.indexOf(\"=\");\n+                    if (i > 0 && s.length() > i + 1) {\n+                        name = s.substring(0, i);\n+                        value = s.substring(i + 1);\n+                        if (decode) {\n+                            try {\n+                                name = URLDecoder.decode(name, \"UTF-8\");\n+                            } catch (Exception e) {\n+                            }\n+                            try {\n+                                value = URLDecoder.decode(value, \"UTF-8\");\n+                            } catch (Exception e) {\n+                            }\n                         }\n-                        try {\n-                            value = URLDecoder.decode(value, \"UTF-8\");\n-                        } catch (Exception e) {\n+                        list = mapA.get(name);\n+                        if (list == null) {\n+                            list = new LinkedList<String>();\n+                            mapA.put(name, list);\n                         }\n+                        list.add(value);\n                     }\n-                    list = mapA.get(name);\n-                    if (list == null) {\n-                        list = new LinkedList<String>();\n-                        mapA.put(name, list);\n-                    }\n-                    list.add(value);\n                 }\n             }\n-\n         }\n \n         HashMap<String, String[]> map = new HashMap<String, String[]>(mapA.size() * 2);\n@@ -697,13 +701,55 @@ public void before() {\n             MockitoAnnotations.initMocks(this);\n \n             RequestContext.getCurrentContext().setRequest(request);\n+\n+            method(\"GET\");\n+            contentType(\"zuul/test-content-type\");\n         }\n \n         private void body(byte[] body) throws IOException {\n             when(request.getInputStream()).thenReturn(new ServletInputStreamWrapper(body));\n             when(request.getContentLength()).thenReturn(body.length);\n         }\n \n+        private void method(String s) {\n+            when(request.getMethod()).thenReturn(s);\n+        }\n+\n+        private void contentType(String s) {\n+            when(request.getContentType()).thenReturn(s);\n+        }\n+\n+        private static String readZipInputStream(InputStream input) throws IOException {\n+\n+            byte[] uploadedBytes = getBytesFromInputStream(input);\n+            input.close();\n+\n+            /* try to read it as a zip file */\n+            String uploadFileTxt = null;\n+            ZipInputStream zInput = new ZipInputStream(new ByteArrayInputStream(uploadedBytes));\n+            ZipEntry zipEntry = zInput.getNextEntry();\n+            if (zipEntry != null) {\n+                // we have a ZipEntry, so this is a zip file\n+                while (zipEntry != null) {\n+                    byte[] fileBytes = getBytesFromInputStream(zInput);\n+                    uploadFileTxt = new String(fileBytes);\n+\n+                    zipEntry = zInput.getNextEntry();\n+                }\n+            }\n+            return uploadFileTxt;\n+        }\n+\n+        private static byte[] getBytesFromInputStream(InputStream input) throws IOException {\n+            int v = 0;\n+            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+            while ((v = input.read()) != -1) {\n+                bos.write(v);\n+            }\n+            bos.close();\n+            return bos.toByteArray();\n+        }\n+\n         @Test\n         public void handlesDuplicateParams() {\n             when(request.getQueryString()).thenReturn(\"path=one&key1=val1&path=two\");\n@@ -767,41 +813,41 @@ public void handlesZipRequestBody() throws IOException {\n \n \n             assertEquals(body, readZipInputStream(wrapper.getInputStream()));\n-\n-\n         }\n \n-        public String readZipInputStream(InputStream input) throws IOException {\n+        @Test\n+        public void parsesParamsFromFormBody() throws Exception {\n+            method(\"POST\");\n+            body(\"one=1&two=2\".getBytes());\n+            contentType(\"application/x-www-form-urlencoded\");\n \n-            byte[] uploadedBytes = getBytesFromInputStream(input);\n-            input.close();\n+            final HttpServletRequestWrapper wrapper = new HttpServletRequestWrapper(request);\n+            final Map params = wrapper.getParameterMap();\n+            assertTrue(params.containsKey(\"one\"));\n+            assertTrue(params.containsKey(\"two\"));\n+        }\n \n-            /* try to read it as a zip file */\n-            String uploadFileTxt = null;\n-            ZipInputStream zInput = new ZipInputStream(new ByteArrayInputStream(uploadedBytes));\n-            ZipEntry zipEntry = zInput.getNextEntry();\n-            if (zipEntry != null) {\n-                // we have a ZipEntry, so this is a zip file\n-                while (zipEntry != null) {\n-                    byte[] fileBytes = getBytesFromInputStream(zInput);\n-                    uploadFileTxt = new String(fileBytes);\n+        @Test\n+        public void ignoresParamsInBodyForNonPosts() throws Exception {\n+            method(\"PUT\");\n+            body(\"one=1&two=2\".getBytes());\n+            contentType(\"application/x-www-form-urlencoded\");\n \n-                    zipEntry = zInput.getNextEntry();\n-                }\n-            }\n-            return uploadFileTxt;\n+            final HttpServletRequestWrapper wrapper = new HttpServletRequestWrapper(request);\n+            final Map params = wrapper.getParameterMap();\n+            assertFalse(params.containsKey(\"one\"));\n         }\n \n-        private byte[] getBytesFromInputStream(InputStream input) throws IOException {\n-            int v = 0;\n-            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-            while ((v = input.read()) != -1) {\n-                bos.write(v);\n-            }\n-            bos.close();\n-            return bos.toByteArray();\n-        }\n+        @Test\n+        public void ignoresParamsInBodyForNonForms() throws Exception {\n+            method(\"POST\");\n+            body(\"one=1&two=2\".getBytes());\n+            contentType(\"application/json\");\n \n+            final HttpServletRequestWrapper wrapper = new HttpServletRequestWrapper(request);\n+            final Map params = wrapper.getParameterMap();\n+            assertFalse(params.containsKey(\"one\"));\n+        }\n \n     }\n ",
      "parent_sha": "3378b35cbc633061cd05c132062c1c058826b6d1"
    }
  },
  {
    "oid": "cf6e8c60e10f799af6276391ce24cc9767716ee5",
    "message": "simplify release for content length enforcement handler",
    "date": "2022-10-12T16:44:59Z",
    "url": "https://github.com/Netflix/zuul/commit/cf6e8c60e10f799af6276391ce24cc9767716ee5",
    "details": {
      "sha": "bfceba0945a0a7ad85e4b1d3d657ba8ce5fe4f1b",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/server/http2/Http2ContentLengthEnforcingHandler.java",
      "status": "modified",
      "additions": 25,
      "deletions": 32,
      "changes": 57,
      "blob_url": "https://github.com/Netflix/zuul/blob/cf6e8c60e10f799af6276391ce24cc9767716ee5/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2Fhttp2%2FHttp2ContentLengthEnforcingHandler.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/cf6e8c60e10f799af6276391ce24cc9767716ee5/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2Fhttp2%2FHttp2ContentLengthEnforcingHandler.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2Fhttp2%2FHttp2ContentLengthEnforcingHandler.java?ref=cf6e8c60e10f799af6276391ce24cc9767716ee5",
      "patch": "@@ -53,51 +53,44 @@ public final class Http2ContentLengthEnforcingHandler extends ChannelInboundHand\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n         if (msg instanceof HttpRequest) {\n-            try {\n-                HttpRequest req = (HttpRequest) msg;\n-                List<String> lengthHeaders = req.headers().getAll(HttpHeaderNames.CONTENT_LENGTH);\n-                if (lengthHeaders.size() > 1) {\n-                    ctx.writeAndFlush(new DefaultHttp2ResetFrame(Http2Error.PROTOCOL_ERROR));\n-                    return;\n-                } else if (lengthHeaders.size() == 1) {\n-                    expectedContentLength = Long.parseLong(lengthHeaders.get(0));\n-                    if (expectedContentLength < 0) {\n-                        // TODO(carl-mastrangelo): this is not right, but meh.  Fix this to return a proper 400.\n-                        ctx.writeAndFlush(new DefaultHttp2ResetFrame(Http2Error.PROTOCOL_ERROR));\n-                        return;\n-                    }\n-                }\n-                if (hasContentLength() && HttpUtil.isTransferEncodingChunked(req)) {\n+            HttpRequest req = (HttpRequest) msg;\n+            List<String> lengthHeaders = req.headers().getAll(HttpHeaderNames.CONTENT_LENGTH);\n+            if (lengthHeaders.size() > 1) {\n+                ctx.writeAndFlush(new DefaultHttp2ResetFrame(Http2Error.PROTOCOL_ERROR));\n+                ReferenceCountUtil.safeRelease(msg);\n+                return;\n+            } else if (lengthHeaders.size() == 1) {\n+                expectedContentLength = Long.parseLong(lengthHeaders.get(0));\n+                if (expectedContentLength < 0) {\n                     // TODO(carl-mastrangelo): this is not right, but meh.  Fix this to return a proper 400.\n                     ctx.writeAndFlush(new DefaultHttp2ResetFrame(Http2Error.PROTOCOL_ERROR));\n+                    ReferenceCountUtil.safeRelease(msg);\n                     return;\n                 }\n-            } finally {\n+            }\n+            if (hasContentLength() && HttpUtil.isTransferEncodingChunked(req)) {\n+                // TODO(carl-mastrangelo): this is not right, but meh.  Fix this to return a proper 400.\n+                ctx.writeAndFlush(new DefaultHttp2ResetFrame(Http2Error.PROTOCOL_ERROR));\n                 ReferenceCountUtil.safeRelease(msg);\n+                return;\n             }\n         }\n         if (msg instanceof HttpContent) {\n-            try {\n-                ByteBuf content = ((HttpContent) msg).content();\n-                incrementSeenContent(content.readableBytes());\n-                if (hasContentLength() && seenContentLength > expectedContentLength) {\n-                    // TODO(carl-mastrangelo): this is not right, but meh.  Fix this to return a proper 400.\n-                    ctx.writeAndFlush(new DefaultHttp2ResetFrame(Http2Error.PROTOCOL_ERROR));\n-                    return;\n-                }\n-            } finally {\n+            ByteBuf content = ((HttpContent) msg).content();\n+            incrementSeenContent(content.readableBytes());\n+            if (hasContentLength() && seenContentLength > expectedContentLength) {\n+                // TODO(carl-mastrangelo): this is not right, but meh.  Fix this to return a proper 400.\n+                ctx.writeAndFlush(new DefaultHttp2ResetFrame(Http2Error.PROTOCOL_ERROR));\n                 ReferenceCountUtil.safeRelease(msg);\n+                return;\n             }\n         }\n         if (msg instanceof LastHttpContent) {\n-            try {\n-                if (hasContentLength() && seenContentLength != expectedContentLength) {\n-                    // TODO(carl-mastrangelo): this is not right, but meh.  Fix this to return a proper 400.\n-                    ctx.writeAndFlush(new DefaultHttp2ResetFrame(Http2Error.PROTOCOL_ERROR));\n-                    return;\n-                }\n-            } finally {\n+            if (hasContentLength() && seenContentLength != expectedContentLength) {\n+                // TODO(carl-mastrangelo): this is not right, but meh.  Fix this to return a proper 400.\n+                ctx.writeAndFlush(new DefaultHttp2ResetFrame(Http2Error.PROTOCOL_ERROR));\n                 ReferenceCountUtil.safeRelease(msg);\n+                return;\n             }\n         }\n         super.channelRead(ctx, msg);",
      "parent_sha": "6c04c7673a030d310ab3d7953bf6e40724a4a36e"
    }
  },
  {
    "oid": "ad5b231fbb225f126af6e5d125d054c2fc688dea",
    "message": "Move GZipResponseFilter down the filter chain to\nas late as possible to ensure any response body encoding/encrypt\nthat might happen before that is considered in Gzipping.",
    "date": "2019-01-25T19:33:06Z",
    "url": "https://github.com/Netflix/zuul/commit/ad5b231fbb225f126af6e5d125d054c2fc688dea",
    "details": {
      "sha": "ef3b0880c2b6a83bd8ded9b8dc8320b904add403",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/filters/common/GZipResponseFilter.java",
      "status": "modified",
      "additions": 9,
      "deletions": 2,
      "changes": 11,
      "blob_url": "https://github.com/Netflix/zuul/blob/ad5b231fbb225f126af6e5d125d054c2fc688dea/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fcommon%2FGZipResponseFilter.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/ad5b231fbb225f126af6e5d125d054c2fc688dea/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fcommon%2FGZipResponseFilter.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fcommon%2FGZipResponseFilter.java?ref=ad5b231fbb225f126af6e5d125d054c2fc688dea",
      "patch": "@@ -17,6 +17,7 @@\n package com.netflix.zuul.filters.common;\n \n import com.google.common.annotations.VisibleForTesting;\n+import com.netflix.config.CachedDynamicBooleanProperty;\n import com.netflix.config.CachedDynamicIntProperty;\n import com.netflix.config.DynamicStringSetProperty;\n import com.netflix.zuul.context.CommonContextKeys;\n@@ -68,14 +69,20 @@ public class GZipResponseFilter extends HttpOutboundSyncFilter\n     private static final CachedDynamicIntProperty MIN_BODY_SIZE_FOR_GZIP =\n             new CachedDynamicIntProperty(\"zuul.min.gzip.body.size\", 860);\n \n+    private static final CachedDynamicBooleanProperty ENABLED =\n+            new CachedDynamicBooleanProperty(\"zuul.response.gzip.filter.enabled\", true);\n+\n     @Override\n     public int filterOrder() {\n-        return 5;\n+\n+        // run as late as possible to ensure the\n+        // final encoded body length is considered\n+        return 110;\n     }\n \n     @Override\n     public boolean shouldFilter(HttpResponseMessage response) {\n-        if (!response.hasBody() || response.getContext().isInBrownoutMode()) {\n+        if (!ENABLED.get() || !response.hasBody() || response.getContext().isInBrownoutMode()) {\n             return false;\n         }\n ",
      "parent_sha": "30e49ea6c319052bfa4c4410b209fcba0ae81686"
    }
  },
  {
    "oid": "d24d972e61413813f189fe92944f17a5a260655d",
    "message": "make ATTR public",
    "date": "2020-08-11T16:52:54Z",
    "url": "https://github.com/Netflix/zuul/commit/d24d972e61413813f189fe92944f17a5a260655d",
    "details": {
      "sha": "ccfa1d6c99fd042ab896c1d569409061495924b2",
      "filename": "zuul-core/src/main/java/com/netflix/netty/common/throttle/MaxInboundConnectionsHandler.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/zuul/blob/d24d972e61413813f189fe92944f17a5a260655d/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fnetty%2Fcommon%2Fthrottle%2FMaxInboundConnectionsHandler.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/d24d972e61413813f189fe92944f17a5a260655d/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fnetty%2Fcommon%2Fthrottle%2FMaxInboundConnectionsHandler.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fnetty%2Fcommon%2Fthrottle%2FMaxInboundConnectionsHandler.java?ref=d24d972e61413813f189fe92944f17a5a260655d",
      "patch": "@@ -39,9 +39,9 @@\n public class MaxInboundConnectionsHandler extends ChannelInboundHandlerAdapter\n {\n     public static final String CONNECTION_THROTTLED_EVENT = \"connection_throttled\";\n+    public static final AttributeKey<Boolean> ATTR_CH_THROTTLED = AttributeKey.newInstance(\"_channel_throttled\");\n \n     private static final Logger LOG = LoggerFactory.getLogger(MaxInboundConnectionsHandler.class);\n-    private static final AttributeKey<Boolean> ATTR_CH_THROTTLED = AttributeKey.newInstance(\"_channel_throttled\");\n \n     private final static AtomicInteger connections = new AtomicInteger(0);\n     private final int maxConnections;",
      "parent_sha": "06767fd62313e47f491f840ce8c6d3389371df38"
    }
  },
  {
    "oid": "e6f76ec2259c25c76cb2a1d60595d333ff5fad24",
    "message": "Update ProxyEndpoint.java (#638)\n\nthe attempToIpAddressMap should change to attempToChosenHostMap in 364 line.",
    "date": "2019-10-18T00:52:55Z",
    "url": "https://github.com/Netflix/zuul/commit/e6f76ec2259c25c76cb2a1d60595d333ff5fad24",
    "details": {
      "sha": "bd4e14088f200ee07c787abc431363fb721f9717",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/filters/endpoint/ProxyEndpoint.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/zuul/blob/e6f76ec2259c25c76cb2a1d60595d333ff5fad24/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/e6f76ec2259c25c76cb2a1d60595d333ff5fad24/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java?ref=e6f76ec2259c25c76cb2a1d60595d333ff5fad24",
      "patch": "@@ -361,7 +361,7 @@ private void storeAndLogOriginRequestInfo() {\n         }\n         if (chosenHostAddr.get() != null) {\n             attempToChosenHostMap.put(attemptNum, chosenHostAddr.get());\n-            eventProps.put(CommonContextKeys.ZUUL_ORIGIN_CHOSEN_HOST_ADDR_MAP_KEY, attempToIpAddressMap);\n+            eventProps.put(CommonContextKeys.ZUUL_ORIGIN_CHOSEN_HOST_ADDR_MAP_KEY, attempToChosenHostMap);\n             context.put(CommonContextKeys.ZUUL_ORIGIN_CHOSEN_HOST_ADDR_MAP_KEY, attempToChosenHostMap);\n         }\n ",
      "parent_sha": "8d541fb7bdf63c60d9f8ad63b3a534339084bb54"
    }
  },
  {
    "oid": "880006f8c07fc9f8a05f7903a9a208f8824e20ca",
    "message": "Some more perf optimizations to HttpRequestMessageImpl.",
    "date": "2015-08-06T08:22:41Z",
    "url": "https://github.com/Netflix/zuul/commit/880006f8c07fc9f8a05f7903a9a208f8824e20ca",
    "details": {
      "sha": "b831b47809a2e3f861d3005a15558d77a666ba86",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/message/http/HttpRequestMessageImpl.java",
      "status": "modified",
      "additions": 10,
      "deletions": 7,
      "changes": 17,
      "blob_url": "https://github.com/Netflix/zuul/blob/880006f8c07fc9f8a05f7903a9a208f8824e20ca/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2Fhttp%2FHttpRequestMessageImpl.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/880006f8c07fc9f8a05f7903a9a208f8824e20ca/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2Fhttp%2FHttpRequestMessageImpl.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2Fhttp%2FHttpRequestMessageImpl.java?ref=880006f8c07fc9f8a05f7903a9a208f8824e20ca",
      "patch": "@@ -36,6 +36,7 @@\n import java.net.URISyntaxException;\n import java.nio.charset.Charset;\n import java.util.Set;\n+import java.util.regex.Pattern;\n \n /**\n  * User: michaels\n@@ -47,6 +48,8 @@ public class HttpRequestMessageImpl implements HttpRequestMessage\n     private static final DynamicIntProperty MAX_BODY_SIZE_PROP = DynamicPropertyFactory.getInstance().getIntProperty(\n             \"zuul.HttpRequestMessage.body.max.size\", 15 * 1000 * 1024);\n \n+    private static final Pattern PTN_COLON = Pattern.compile(\":\");\n+\n     private ZuulMessage message;\n     private String protocol;\n     private String method;\n@@ -322,12 +325,12 @@ public String getInfoForLogging()\n     @Override\n     public String getOriginalHost()\n     {\n-        String host = getHeaders().getFirst(\"X-Forwarded-Host\");\n+        String host = getHeaders().getFirst(HttpHeaderNames.X_FORWARDED_HOST);\n         if (host == null) {\n-            host = getHeaders().getFirst(\"Host\");\n+            host = getHeaders().getFirst(HttpHeaderNames.HOST);\n             if (host != null) {\n                 // Host header may have a trailing port. Strip that out if it does.\n-                host = host.split(\":\")[0];\n+                host = PTN_COLON.split(host)[0];\n             }\n \n             if (host == null) {\n@@ -340,7 +343,7 @@ public String getOriginalHost()\n     @Override\n     public String getOriginalScheme()\n     {\n-        String scheme = getHeaders().getFirst(\"X-Forwarded-Proto\");\n+        String scheme = getHeaders().getFirst(HttpHeaderNames.X_FORWARDED_PROTO);\n         if (scheme == null) {\n             scheme = getScheme();\n         }\n@@ -351,12 +354,12 @@ public String getOriginalScheme()\n     public int getOriginalPort()\n     {\n         int port;\n-        String portStr = getHeaders().getFirst(\"X-Forwarded-Port\");\n+        String portStr = getHeaders().getFirst(HttpHeaderNames.X_FORWARDED_PORT);\n         if (portStr == null) {\n             // Check if port was specified on a Host header.\n-            String hostHeader = getHeaders().getFirst(\"Host\");\n+            String hostHeader = getHeaders().getFirst(HttpHeaderNames.HOST);\n             if (hostHeader != null) {\n-                String[] hostParts = hostHeader.split(\":\");\n+                String[] hostParts = PTN_COLON.split(hostHeader);\n                 if (hostParts.length == 2) {\n                     port = Integer.parseInt(hostParts[1]);\n                 }",
      "parent_sha": "b421f325b20fd20cdc5f04574f4332be3cf90398"
    }
  },
  {
    "oid": "75fa277249d43a093ad721c474c0cf0c4892c318",
    "message": "cleanup for readability",
    "date": "2024-05-07T18:36:23Z",
    "url": "https://github.com/Netflix/zuul/commit/75fa277249d43a093ad721c474c0cf0c4892c318",
    "details": {
      "sha": "6c165b2e5ce2b4909ceabc4e163fe40f319fadc9",
      "filename": "zuul-core/src/main/java/com/netflix/netty/common/proxyprotocol/HAProxyMessageChannelHandler.java",
      "status": "modified",
      "additions": 77,
      "deletions": 81,
      "changes": 158,
      "blob_url": "https://github.com/Netflix/zuul/blob/75fa277249d43a093ad721c474c0cf0c4892c318/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fnetty%2Fcommon%2Fproxyprotocol%2FHAProxyMessageChannelHandler.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/75fa277249d43a093ad721c474c0cf0c4892c318/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fnetty%2Fcommon%2Fproxyprotocol%2FHAProxyMessageChannelHandler.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fnetty%2Fcommon%2Fproxyprotocol%2FHAProxyMessageChannelHandler.java?ref=75fa277249d43a093ad721c474c0cf0c4892c318",
      "patch": "@@ -70,92 +70,88 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception\n             final List<HAProxyTLV> tlvList = hapm.tlvs().stream().filter(tlv -> tlv.type() == Type.OTHER)\n                     .collect(Collectors.toList());\n             channel.attr(ATTR_HAPROXY_CUSTOM_TLVS).set(tlvList);\n-            // Get the real host and port that the client connected to ELB with.\n-            String destinationAddress = hapm.destinationAddress();\n-            if (destinationAddress != null) {\n-                channel.attr(SourceAddressChannelHandler.ATTR_LOCAL_ADDRESS).set(destinationAddress);\n-                SocketAddress addr;\n-                out:\n-                {\n-                    switch (hapm.proxiedProtocol()) {\n-                        case UNKNOWN:\n-                            throw new IllegalArgumentException(\"unknown proxy protocol\" + destinationAddress);\n-                        case TCP4:\n-                        case TCP6:\n-                            InetSocketAddress inetAddr = new InetSocketAddress(\n-                                    InetAddresses.forString(destinationAddress), hapm.destinationPort());\n-                            addr = inetAddr;\n-                            // setting PPv2 explicitly because SourceAddressChannelHandler.ATTR_LOCAL_ADDR could be PPv2\n-                            // or not\n-                            channel.attr(SourceAddressChannelHandler.ATTR_PROXY_PROTOCOL_DESTINATION_ADDRESS)\n-                                    .set(inetAddr);\n-                            Attrs attrs =\n-                                    ctx.channel().attr(Server.CONN_DIMENSIONS).get();\n-                            if (inetAddr.getAddress() instanceof Inet4Address) {\n-                                HAPM_DEST_IP_VERSION.put(attrs, \"v4\");\n-                            } else if (inetAddr.getAddress() instanceof Inet6Address) {\n-                                HAPM_DEST_IP_VERSION.put(attrs, \"v6\");\n-                            } else {\n-                                HAPM_DEST_IP_VERSION.put(attrs, \"unknown\");\n-                            }\n-                            HAPM_DEST_PORT.put(attrs, hapm.destinationPort());\n-                            break out;\n-                        case UNIX_STREAM: // TODO: implement\n-                        case UDP4:\n-                        case UDP6:\n-                        case UNIX_DGRAM:\n-                            throw new IllegalArgumentException(\"unknown proxy protocol\" + destinationAddress);\n-                    }\n-                    throw new AssertionError(hapm.proxiedProtocol());\n-                }\n-                channel.attr(SourceAddressChannelHandler.ATTR_LOCAL_ADDR).set(addr);\n-            }\n+            // Get the real host and port that the client connected with.\n+            parseDstAddr(hapm, channel);\n+            parseSrcAddr(hapm, channel);\n+            // Remove ourselves (this handler) from the channel now, as this is conn. level info\n+            ctx.pipeline().remove(this);\n+        }\n+    }\n \n-            // Get the real client IP from the ProxyProtocol message sent by the ELB, and overwrite the SourceAddress\n-            // channel attribute.\n-            String sourceAddress = hapm.sourceAddress();\n-            if (sourceAddress != null) {\n-                channel.attr(SourceAddressChannelHandler.ATTR_SOURCE_ADDRESS).set(sourceAddress);\n+    private void parseSrcAddr(HAProxyMessage hapm, Channel channel) {\n+        String sourceAddress = hapm.sourceAddress();\n+        if (sourceAddress != null) {\n+            channel.attr(SourceAddressChannelHandler.ATTR_SOURCE_ADDRESS).set(sourceAddress);\n \n-                SocketAddress addr;\n-                out:\n-                {\n-                    switch (hapm.proxiedProtocol()) {\n-                        case UNKNOWN:\n-                            throw new IllegalArgumentException(\"unknown proxy protocol\" + sourceAddress);\n-                        case TCP4:\n-                        case TCP6:\n-                            InetSocketAddress inetAddr;\n-                            addr = inetAddr =\n-                                    new InetSocketAddress(InetAddresses.forString(sourceAddress), hapm.sourcePort());\n-                            Attrs attrs =\n-                                    ctx.channel().attr(Server.CONN_DIMENSIONS).get();\n-                            if (inetAddr.getAddress() instanceof Inet4Address) {\n-                                HAPM_SRC_IP_VERSION.put(attrs, \"v4\");\n-                            } else if (inetAddr.getAddress() instanceof Inet6Address) {\n-                                HAPM_SRC_IP_VERSION.put(attrs, \"v6\");\n-                            } else {\n-                                HAPM_SRC_IP_VERSION.put(attrs, \"unknown\");\n-                            }\n-                            break out;\n-                        case UNIX_STREAM: // TODO: implement\n-                        case UDP4:\n-                        case UDP6:\n-                        case UNIX_DGRAM:\n-                            throw new IllegalArgumentException(\"unknown proxy protocol\" + sourceAddress);\n-                    }\n-                    throw new AssertionError(hapm.proxiedProtocol());\n+            SocketAddress srcAddr;\n+            out:\n+            {\n+                switch (hapm.proxiedProtocol()) {\n+                    case UNKNOWN:\n+                        throw new IllegalArgumentException(\"unknown proxy protocol\" + sourceAddress);\n+                    case TCP4:\n+                    case TCP6:\n+                        InetSocketAddress inetAddr;\n+                        srcAddr = inetAddr =\n+                                new InetSocketAddress(InetAddresses.forString(sourceAddress), hapm.sourcePort());\n+                        Attrs attrs = channel.attr(Server.CONN_DIMENSIONS).get();\n+                        if (inetAddr.getAddress() instanceof Inet4Address) {\n+                            HAPM_SRC_IP_VERSION.put(attrs, \"v4\");\n+                        } else if (inetAddr.getAddress() instanceof Inet6Address) {\n+                            HAPM_SRC_IP_VERSION.put(attrs, \"v6\");\n+                        } else {\n+                            HAPM_SRC_IP_VERSION.put(attrs, \"unknown\");\n+                        }\n+                        break out;\n+                    case UNIX_STREAM: // TODO: implement\n+                    case UDP4:\n+                    case UDP6:\n+                    case UNIX_DGRAM:\n+                        throw new IllegalArgumentException(\"unknown proxy protocol\" + sourceAddress);\n                 }\n-                channel.attr(SourceAddressChannelHandler.ATTR_REMOTE_ADDR).set(addr);\n+                throw new AssertionError(hapm.proxiedProtocol());\n             }\n+            channel.attr(SourceAddressChannelHandler.ATTR_REMOTE_ADDR).set(srcAddr);\n+        }\n+    }\n \n-            // TODO - fire an additional event to notify interested parties that we now know the IP?\n-\n-            // Remove ourselves (this handler) from the channel now, as no more work to do.\n-            ctx.pipeline().remove(this);\n-\n-            // Do not continue propagating the message.\n-            return;\n+    private void parseDstAddr(HAProxyMessage hapm, Channel channel) {\n+        String destinationAddress = hapm.destinationAddress();\n+        if (destinationAddress != null) {\n+            channel.attr(SourceAddressChannelHandler.ATTR_LOCAL_ADDRESS).set(destinationAddress);\n+            SocketAddress dstAddr;\n+            out:\n+            {\n+                switch (hapm.proxiedProtocol()) {\n+                    case UNKNOWN:\n+                        throw new IllegalArgumentException(\"unknown proxy protocol\" + destinationAddress);\n+                    case TCP4:\n+                    case TCP6:\n+                        InetSocketAddress inetAddr = new InetSocketAddress(\n+                                InetAddresses.forString(destinationAddress), hapm.destinationPort());\n+                        dstAddr = inetAddr;\n+                        // set ppv2 attr explicitly because ATTR_LOCAL_ADDR could be non ppv2\n+                        channel.attr(SourceAddressChannelHandler.ATTR_PROXY_PROTOCOL_DESTINATION_ADDRESS)\n+                                .set(inetAddr);\n+                        Attrs attrs = channel.attr(Server.CONN_DIMENSIONS).get();\n+                        if (inetAddr.getAddress() instanceof Inet4Address) {\n+                            HAPM_DEST_IP_VERSION.put(attrs, \"v4\");\n+                        } else if (inetAddr.getAddress() instanceof Inet6Address) {\n+                            HAPM_DEST_IP_VERSION.put(attrs, \"v6\");\n+                        } else {\n+                            HAPM_DEST_IP_VERSION.put(attrs, \"unknown\");\n+                        }\n+                        HAPM_DEST_PORT.put(attrs, hapm.destinationPort());\n+                        break out;\n+                    case UNIX_STREAM: // TODO: implement\n+                    case UDP4:\n+                    case UDP6:\n+                    case UNIX_DGRAM:\n+                        throw new IllegalArgumentException(\"unknown proxy protocol\" + destinationAddress);\n+                }\n+                throw new AssertionError(hapm.proxiedProtocol());\n+            }\n+            channel.attr(SourceAddressChannelHandler.ATTR_LOCAL_ADDR).set(dstAddr);\n         }\n     }\n }",
      "parent_sha": "99b5b5b869710219b905f093a82ee602f8dfd7c9"
    }
  },
  {
    "oid": "0dd5b6477530d76d4cb6bb350c818fe029b62c8d",
    "message": "zuul-core: rethrow bind exceptions with more detail",
    "date": "2020-02-19T00:38:51Z",
    "url": "https://github.com/Netflix/zuul/commit/0dd5b6477530d76d4cb6bb350c818fe029b62c8d",
    "details": {
      "sha": "11bee8442aa944d0b94d1b6a88c8da8c2f491bc7",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/server/Server.java",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/Netflix/zuul/blob/0dd5b6477530d76d4cb6bb350c818fe029b62c8d/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FServer.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/0dd5b6477530d76d4cb6bb350c818fe029b62c8d/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FServer.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FServer.java?ref=0dd5b6477530d76d4cb6bb350c818fe029b62c8d",
      "patch": "@@ -254,7 +254,14 @@ private ChannelFuture setupServerBootstrap(\n         serverStatusManager.localStatus(InstanceInfo.InstanceStatus.UP);\n \n         // Bind and start to accept incoming connections.\n-        return serverBootstrap.bind(listenAddress).sync();\n+        ChannelFuture bindFuture = serverBootstrap.bind(listenAddress);\n+        try {\n+            return bindFuture.sync();\n+        } catch (Exception e) {\n+            // sync() sneakily throws a checked Exception, but doesn't declare it. This can happen if there is a bind\n+            // failure, which is typically an IOException.  Just chain it and rethrow.\n+            throw new RuntimeException(\"Failed to bind on addr \" + listenAddress, e);\n+        }\n     }\n \n     /**",
      "parent_sha": "ce3286b76776a446543f4bffea2acb3202caa1c2"
    }
  },
  {
    "oid": "1a99bf78f3ca1ad2ebd38583d804ecbaf4473195",
    "message": "Make PushConnectionRegistry ctor public for easier creation (#1610)",
    "date": "2023-07-20T18:13:41Z",
    "url": "https://github.com/Netflix/zuul/commit/1a99bf78f3ca1ad2ebd38583d804ecbaf4473195",
    "details": {
      "sha": "3ab1dd865ecc88f8f695f359d5334785c8a97546",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/server/push/PushConnectionRegistry.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/zuul/blob/1a99bf78f3ca1ad2ebd38583d804ecbaf4473195/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2Fpush%2FPushConnectionRegistry.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/1a99bf78f3ca1ad2ebd38583d804ecbaf4473195/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2Fpush%2FPushConnectionRegistry.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2Fpush%2FPushConnectionRegistry.java?ref=1a99bf78f3ca1ad2ebd38583d804ecbaf4473195",
      "patch": "@@ -36,7 +36,7 @@ public class PushConnectionRegistry {\n     private final SecureRandom secureTokenGenerator;\n \n     @Inject\n-    PushConnectionRegistry() {\n+    public PushConnectionRegistry() {\n         clientPushConnectionMap = new ConcurrentHashMap<>(1024 * 32);\n         secureTokenGenerator = new SecureRandom();\n     }",
      "parent_sha": "423c3c8168532451dd1099081b962388d6ac6356"
    }
  },
  {
    "oid": "15179f47bc4ac0b41703a15710998661b4a900ce",
    "message": "zuul-core: only pick a new server address after deciding to create a new connection",
    "date": "2020-11-04T23:46:44Z",
    "url": "https://github.com/Netflix/zuul/commit/15179f47bc4ac0b41703a15710998661b4a900ce",
    "details": {
      "sha": "ae4d18c2e8efdc94f2bd56bbf8b71f0e9fb2f262",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/connectionpool/DefaultClientChannelManager.java",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/Netflix/zuul/blob/15179f47bc4ac0b41703a15710998661b4a900ce/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fconnectionpool%2FDefaultClientChannelManager.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/15179f47bc4ac0b41703a15710998661b4a900ce/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fconnectionpool%2FDefaultClientChannelManager.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fconnectionpool%2FDefaultClientChannelManager.java?ref=15179f47bc4ac0b41703a15710998661b4a900ce",
      "patch": "@@ -342,13 +342,12 @@ public Promise<PooledConnection> acquire(\n             return promise;\n         }\n \n-        SocketAddress finalServerAddr = pickAddress(chosenServer);\n-        InstanceInfo instanceInfo = deriveInstanceInfoInternal(chosenServer);\n-\n         selectedServer.set(chosenServer);\n \n         // Now get the connection-pool for this server.\n         IConnectionPool pool = perServerPools.computeIfAbsent(chosenServer, s -> {\n+            SocketAddress finalServerAddr = pickAddress(chosenServer);\n+            InstanceInfo instanceInfo = deriveInstanceInfoInternal(chosenServer);\n             // Get the stats from LB for this server.\n             LoadBalancerStats lbStats = loadBalancer.getLoadBalancerStats();\n             ServerStats stats = lbStats.getSingleServerStat(chosenServer);",
      "parent_sha": "95519f53e85b277e572d361be3b7e38f9732ffd8"
    }
  },
  {
    "oid": "74bd73d56d10917ca55882f1788656c0842ceea5",
    "message": "null check",
    "date": "2021-03-09T22:20:12Z",
    "url": "https://github.com/Netflix/zuul/commit/74bd73d56d10917ca55882f1788656c0842ceea5",
    "details": {
      "sha": "512a6e44e4c412dff7725af4af4dc7560331a275",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/timeouts/OriginTimeoutManager.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/Netflix/zuul/blob/74bd73d56d10917ca55882f1788656c0842ceea5/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ftimeouts%2FOriginTimeoutManager.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/74bd73d56d10917ca55882f1788656c0842ceea5/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ftimeouts%2FOriginTimeoutManager.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ftimeouts%2FOriginTimeoutManager.java?ref=74bd73d56d10917ca55882f1788656c0842ceea5",
      "patch": "@@ -26,6 +26,7 @@\n import com.netflix.zuul.message.http.HttpRequestMessage;\n import com.netflix.zuul.origins.NettyOrigin;\n import java.time.Duration;\n+import java.util.Objects;\n import javax.annotation.Nullable;\n \n /**\n@@ -39,7 +40,7 @@ public class OriginTimeoutManager {\n     private final NettyOrigin origin;\n \n     public OriginTimeoutManager(NettyOrigin origin) {\n-        this.origin = origin;\n+        this.origin = Objects.requireNonNull(origin);\n     }\n \n     private static final DynamicLongProperty MAX_OUTBOUND_READ_TIMEOUT_MS =",
      "parent_sha": "6f22bd5ac9c102a1f32ff0dbc559b7395676f689"
    }
  },
  {
    "oid": "9badfe3061bc65661562703a82e645957b4bc8d8",
    "message": "Changed HttpRequestMessage.getInfoForLoggin() to use reconstructURI() instead of just pathAndQuery and Host.",
    "date": "2015-06-26T20:11:09Z",
    "url": "https://github.com/Netflix/zuul/commit/9badfe3061bc65661562703a82e645957b4bc8d8",
    "details": {
      "sha": "6e7932bff1786b57f9615263574325af4d39563d",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/context/HttpRequestMessage.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/zuul/blob/9badfe3061bc65661562703a82e645957b4bc8d8/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fcontext%2FHttpRequestMessage.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/9badfe3061bc65661562703a82e645957b4bc8d8/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fcontext%2FHttpRequestMessage.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fcontext%2FHttpRequestMessage.java?ref=9badfe3061bc65661562703a82e645957b4bc8d8",
      "patch": "@@ -177,8 +177,8 @@ public ZuulMessage clone()\n     public String getInfoForLogging()\n     {\n         StringBuilder sb = new StringBuilder()\n-                .append(\"url=\").append(getPathAndQuery())\n-                .append(\",host=\").append(String.valueOf(getHeaders().getFirst(\"Host\")))\n+                .append(\"uri=\").append(reconstructURI().toString())\n+                .append(\", method=\").append(getMethod())\n                 ;\n         return sb.toString();\n     }",
      "parent_sha": "7cbb1d4676a62e26e50f22bb9597e4a7422be4e3"
    }
  },
  {
    "oid": "26642c9845a453f7afa0a3abfe9326a754bb5e0f",
    "message": "remove full request from filter iterating touch",
    "date": "2022-10-20T00:18:17Z",
    "url": "https://github.com/Netflix/zuul/commit/26642c9845a453f7afa0a3abfe9326a754bb5e0f",
    "details": {
      "sha": "853243ecf70e9a9c035cb3aaa23a5ba0963dfc07",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/filter/ZuulFilterChainRunner.java",
      "status": "modified",
      "additions": 2,
      "deletions": 4,
      "changes": 6,
      "blob_url": "https://github.com/Netflix/zuul/blob/26642c9845a453f7afa0a3abfe9326a754bb5e0f/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ffilter%2FZuulFilterChainRunner.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/26642c9845a453f7afa0a3abfe9326a754bb5e0f/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ffilter%2FZuulFilterChainRunner.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ffilter%2FZuulFilterChainRunner.java?ref=26642c9845a453f7afa0a3abfe9326a754bb5e0f",
      "patch": "@@ -108,17 +108,15 @@ public void filter(T inMesg, HttpContent chunk) {\n                 final ZuulFilter<T, T> filter = filters[i];\n                 filterName = filter.filterName();\n                 if ((! filter.isDisabled()) && (! shouldSkipFilter(inMesg, filter))) {\n-                    chunk.touch(\"Filter runner processing chunk, filter: \" + filter.filterName() +\n-                            \",  message: \" + inMesg);\n+                    chunk.touch(\"Filter runner processing chunk, filter: \" + filter.filterName());\n                     final HttpContent newChunk = filter.processContentChunk(inMesg, chunk);\n                     if (newChunk == null)  {\n                         //Filter wants to break the chain and stop propagating this chunk any further\n                         return;\n                     }\n                     //deallocate original chunk if necessary\n                     if ((newChunk != chunk) && (chunk.refCnt() > 0)) {\n-                        chunk.touch(\"Filter runner processing newChunk, filter: \" + filter.filterName() +\n-                                \",  message: \" + inMesg);\n+                        chunk.touch(\"Filter runner processing newChunk, filter: \" + filter.filterName());\n                         chunk.release(chunk.refCnt());\n                     }\n                     chunk = newChunk;",
      "parent_sha": "a10e80d93e10df9e95b4d4763c09627b71a0bca1"
    }
  },
  {
    "oid": "67e48c5144a481f0c47c973a904af2f52a4dbbce",
    "message": "Lower log severity and print exception (#1671)",
    "date": "2023-10-20T22:15:33Z",
    "url": "https://github.com/Netflix/zuul/commit/67e48c5144a481f0c47c973a904af2f52a4dbbce",
    "details": {
      "sha": "dbfabfa257d9d62c6f67abcde6de46ececa0af78",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/message/http/HttpRequestMessageImpl.java",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/Netflix/zuul/blob/67e48c5144a481f0c47c973a904af2f52a4dbbce/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2Fhttp%2FHttpRequestMessageImpl.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/67e48c5144a481f0c47c973a904af2f52a4dbbce/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2Fhttp%2FHttpRequestMessageImpl.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2Fhttp%2FHttpRequestMessageImpl.java?ref=67e48c5144a481f0c47c973a904af2f52a4dbbce",
      "patch": "@@ -30,9 +30,6 @@\n import io.netty.handler.codec.http.Cookie;\n import io.netty.handler.codec.http.CookieDecoder;\n import io.netty.handler.codec.http.HttpContent;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import java.net.InetSocketAddress;\n import java.net.SocketAddress;\n import java.net.URI;\n@@ -44,6 +41,8 @@\n import java.util.Set;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * User: michaels\n@@ -394,10 +393,11 @@ public Cookies reParseCookies() {\n                     cookies.add(cookie);\n                 }\n             } catch (Exception e) {\n-                LOG.error(\n+                LOG.warn(\n                         \"Error parsing request Cookie header. cookie={}, request-info={}\",\n                         aCookieHeader,\n-                        getInfoForLogging());\n+                        getInfoForLogging(),\n+                        e);\n             }\n         }\n         parsedCookies = cookies;",
      "parent_sha": "b1f3cf4f734885b81e898f4da39ec730a4e1c60f"
    }
  },
  {
    "oid": "fe942fde4377a91b9fae7187ae3e3a8547d4f991",
    "message": "respect trailing equals for key-only query params",
    "date": "2018-06-21T18:21:20Z",
    "url": "https://github.com/Netflix/zuul/commit/fe942fde4377a91b9fae7187ae3e3a8547d4f991",
    "details": {
      "sha": "4009d7a3e82f660419b335631d66d989b6c610cd",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/message/http/HttpQueryParams.java",
      "status": "modified",
      "additions": 37,
      "deletions": 2,
      "changes": 39,
      "blob_url": "https://github.com/Netflix/zuul/blob/fe942fde4377a91b9fae7187ae3e3a8547d4f991/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2Fhttp%2FHttpQueryParams.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/fe942fde4377a91b9fae7187ae3e3a8547d4f991/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2Fhttp%2FHttpQueryParams.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2Fhttp%2FHttpQueryParams.java?ref=fe942fde4377a91b9fae7187ae3e3a8547d4f991",
      "patch": "@@ -40,17 +40,20 @@ public class HttpQueryParams implements Cloneable\n {\n     private final ListMultimap<String, String> delegate;\n     private final boolean immutable;\n+    private final HashMap<String, Boolean> trailingEquals;\n \n     public HttpQueryParams()\n     {\n         delegate = ArrayListMultimap.create();\n         immutable = false;\n+        trailingEquals = new HashMap<>();\n     }\n \n     private HttpQueryParams(ListMultimap<String, String> delegate)\n     {\n         this.delegate = delegate;\n         immutable = ImmutableListMultimap.class.isAssignableFrom(delegate.getClass());\n+        trailingEquals = new HashMap<>();\n     }\n \n     public static HttpQueryParams parse(String queryString) {\n@@ -78,6 +81,11 @@ public static HttpQueryParams parse(String queryString) {\n                 }\n \n                 queryParams.add(name, value);\n+\n+                // respect trailing equals for key-only params\n+                if (s.endsWith(\"=\") && StringUtils.isBlank(value)) {\n+                    queryParams.setTrailingEquals(name, true);\n+                }\n             }\n             // key only\n             else if (s.length() > 0) {\n@@ -176,6 +184,9 @@ public String toEncodedString()\n                     sb.append('=');\n                     sb.append(URLEncoder.encode(entry.getValue(), \"UTF-8\"));\n                 }\n+                else if (isTrailingEquals(entry.getKey())) {\n+                    sb.append('=');\n+                }\n                 sb.append('&');\n             }\n \n@@ -229,6 +240,13 @@ public boolean isImmutable()\n         return immutable;\n     }\n \n+    public boolean isTrailingEquals(String key) {\n+        return trailingEquals.getOrDefault(key, false);\n+    }\n+\n+    public void setTrailingEquals(String key, boolean trailingEquals) {\n+        this.trailingEquals.put(key, trailingEquals);\n+    }\n \n     @Override\n     public int hashCode()\n@@ -312,7 +330,7 @@ public void testParseKeysWithoutValues()\n \n             assertEquals(expected, actual);\n \n-            assertEquals(\"k1&k2=v2&k3\", actual.toEncodedString());\n+            assertEquals(\"k1=&k2=v2&k3=\", actual.toEncodedString());\n         }\n \n         @Test\n@@ -325,7 +343,7 @@ public void testParseKeyWithoutValueEquals()\n \n             assertEquals(expected, actual);\n \n-            assertEquals(\"k1\", actual.toEncodedString());\n+            assertEquals(\"k1=\", actual.toEncodedString());\n         }\n \n         @Test\n@@ -353,5 +371,22 @@ public void testParseKeyWithoutValueShort()\n \n             assertEquals(\"%3D\", actual.toEncodedString());\n         }\n+\n+        @Test\n+        public void testParseKeysWithoutValuesMixedTrailers()\n+        {\n+            HttpQueryParams expected = new HttpQueryParams();\n+            expected.add(\"k1\", \"\");\n+            expected.add(\"k2\", \"v2\");\n+            expected.add(\"k3\", \"\");\n+            expected.add(\"k4\", \"v4\");\n+\n+            HttpQueryParams actual = HttpQueryParams.parse(\"k1=&k2=v2&k3&k4=v4\");\n+\n+            assertEquals(expected, actual);\n+\n+            assertEquals(\"k1=&k2=v2&k3&k4=v4\", actual.toEncodedString());\n+        }\n+\n     }\n }",
      "parent_sha": "6b503d781a6ddbb5db5770dbe51f99041af1bb79"
    }
  },
  {
    "oid": "ffdd31005a5ea378325b394a26c1116bc2c9506f",
    "message": "Add more logging",
    "date": "2024-10-23T17:18:41Z",
    "url": "https://github.com/Netflix/zuul/commit/ffdd31005a5ea378325b394a26c1116bc2c9506f",
    "details": {
      "sha": "81bc7db62453cf0a94c98ddf906e1cf996163787",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/server/ClientConnectionsShutdown.java",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/Netflix/zuul/blob/ffdd31005a5ea378325b394a26c1116bc2c9506f/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FClientConnectionsShutdown.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/ffdd31005a5ea378325b394a26c1116bc2c9506f/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FClientConnectionsShutdown.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FClientConnectionsShutdown.java?ref=ffdd31005a5ea378325b394a26c1116bc2c9506f",
      "patch": "@@ -30,10 +30,11 @@\n import io.netty.util.concurrent.EventExecutor;\n import io.netty.util.concurrent.Promise;\n import io.netty.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.concurrent.TimeUnit;\n+\n /**\n  * TODO: Change this class to be an instance per-port.\n  * So that then the configuration can be different per-port, which is need for the combined FTL/Cloud clusters.\n@@ -110,6 +111,7 @@ Promise<Void> gracefullyShutdownClientChannels(ShutdownType shutdownType) {\n             flagChannelForClose(channel, shutdownType);\n         }\n \n+        LOG.info(\"Setting up scheduled task for {} with shutdownType: {}\", closeFuture, shutdownType);\n         Promise<Void> promise = executor.newPromise();\n         Runnable cancelTimeoutTask;\n         if (shutdownType == ShutdownType.SHUTDOWN) {\n@@ -129,6 +131,7 @@ Promise<Void> gracefullyShutdownClientChannels(ShutdownType shutdownType) {\n                     TimeUnit.SECONDS);\n             cancelTimeoutTask = () -> {\n                 if (!timeoutTask.isDone()) {\n+                    LOG.info(\"Timeout task canceled before completion.\");\n                     // close happened before the timeout\n                     timeoutTask.cancel(false);\n                 }\n@@ -138,6 +141,7 @@ Promise<Void> gracefullyShutdownClientChannels(ShutdownType shutdownType) {\n         }\n \n         closeFuture.addListener(future -> {\n+            LOG.info(\"CloseFuture completed successfully: {}\", future.isSuccess());\n             cancelTimeoutTask.run();\n             promise.setSuccess(null);\n         });",
      "parent_sha": "1d99787513b6a545a78c3065e0335bee9c994556"
    }
  },
  {
    "oid": "a56514c19294c8d833d8fa016b728ac9dc191214",
    "message": "Perf optimization for the HttpUtils.stripMaliciousHeaderChars() method\n\nWas showing up as a hotspot in profiling.",
    "date": "2016-10-04T00:39:49Z",
    "url": "https://github.com/Netflix/zuul/commit/a56514c19294c8d833d8fa016b728ac9dc191214",
    "details": {
      "sha": "ee513999188d9f5bcfb89fdb4e49c05c5294ced8",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/util/HttpUtils.java",
      "status": "modified",
      "additions": 20,
      "deletions": 9,
      "changes": 29,
      "blob_url": "https://github.com/Netflix/zuul/blob/a56514c19294c8d833d8fa016b728ac9dc191214/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Futil%2FHttpUtils.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/a56514c19294c8d833d8fa016b728ac9dc191214/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Futil%2FHttpUtils.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Futil%2FHttpUtils.java?ref=a56514c19294c8d833d8fa016b728ac9dc191214",
      "patch": "@@ -18,11 +18,11 @@\n import com.netflix.zuul.message.Headers;\n import com.netflix.zuul.message.http.HttpHeaderNames;\n import com.netflix.zuul.message.http.HttpRequestInfo;\n-import org.apache.commons.lang3.text.translate.LookupTranslator;\n import org.junit.Test;\n \n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertTrue;\n+import java.util.regex.Pattern;\n+\n+import static org.junit.Assert.*;\n \n /**\n  * User: Mike Smith\n@@ -31,6 +31,8 @@\n  */\n public class HttpUtils\n {\n+    private static final Pattern RE_MALICIOUS_HEADER_CHARS = Pattern.compile(\"(\\r|\\n)\");\n+\n     /**\n      * Get the IP address of client making the request.\n      *\n@@ -98,13 +100,12 @@ public static boolean acceptsGzip(Headers headers) {\n      * @return - clean header string\n      */\n     public static String stripMaliciousHeaderChars(String input) {\n-        return MALICIOUS_HEADER_CHARS.translate(input);\n-    }\n \n-    private static final LookupTranslator MALICIOUS_HEADER_CHARS = new LookupTranslator(new String[][] {\n-            {\"\\r\", \"\"},\n-            {\"\\n\", \"\"},\n-    });\n+        if (input == null) {\n+            return null;\n+        }\n+        return RE_MALICIOUS_HEADER_CHARS.matcher(input).replaceAll(\"\");\n+    }\n \n \n     public static class UnitTest {\n@@ -123,5 +124,15 @@ public void detectsNonGzip() {\n         public void detectsGzipAmongOtherEncodings() {\n             assertTrue(HttpUtils.isGzipped(\"gzip, deflate\"));\n         }\n+\n+        @Test\n+        public void stripMaliciousHeaderChars() {\n+            assertEquals(\"something\", HttpUtils.stripMaliciousHeaderChars(\"some\\r\\nthing\"));\n+            assertEquals(\"some thing\", HttpUtils.stripMaliciousHeaderChars(\"some thing\"));\n+            assertEquals(\"something\", HttpUtils.stripMaliciousHeaderChars(\"\\nsome\\r\\nthing\\r\"));\n+            assertEquals(\"\", HttpUtils.stripMaliciousHeaderChars(\"\\r\"));\n+            assertEquals(\"\", HttpUtils.stripMaliciousHeaderChars(\"\"));\n+            assertNull(HttpUtils.stripMaliciousHeaderChars(null));\n+        }\n     }\n }",
      "parent_sha": "7de8ebd82a49945b9001ef0b654154356bb7b4c4"
    }
  },
  {
    "oid": "96f905c8f5595318de7f6c4ecedaa274257b44c3",
    "message": "add a flag to disable manual Eureka status management",
    "date": "2020-04-08T22:58:36Z",
    "url": "https://github.com/Netflix/zuul/commit/96f905c8f5595318de7f6c4ecedaa274257b44c3",
    "details": {
      "sha": "9b435c641bbcfaf3dbfb6c7661239e484d713cd6",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/server/Server.java",
      "status": "modified",
      "additions": 12,
      "deletions": 6,
      "changes": 18,
      "blob_url": "https://github.com/Netflix/zuul/blob/96f905c8f5595318de7f6c4ecedaa274257b44c3/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FServer.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/96f905c8f5595318de7f6c4ecedaa274257b44c3/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FServer.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FServer.java?ref=96f905c8f5595318de7f6c4ecedaa274257b44c3",
      "patch": "@@ -99,6 +99,9 @@ public class Server\n     private static final DynamicBooleanProperty USE_LEASTCONNS_FOR_EVENTLOOPS =\n             new DynamicBooleanProperty(\"zuul.server.eventloops.use_leastconns\", false);\n \n+    private static final DynamicBooleanProperty MANUAL_DISCOVERY_STATUS =\n+            new DynamicBooleanProperty(\"zuul.server.netty.manual.discovery.status\", true);\n+\n     private final EventLoopGroupMetrics eventLoopGroupMetrics;\n \n     private final Thread jvmShutdownHook = new Thread(this::stop, \"Zuul-JVM-shutdown-hook\");\n@@ -250,8 +253,10 @@ private ChannelFuture setupServerBootstrap(\n \n         LOG.info(\"Binding to : \" + listenAddress);\n \n-        // Flag status as UP just before binding to the port.\n-        serverStatusManager.localStatus(InstanceInfo.InstanceStatus.UP);\n+        if (MANUAL_DISCOVERY_STATUS.get()) {\n+            // Flag status as UP just before binding to the port.\n+            serverStatusManager.localStatus(InstanceInfo.InstanceStatus.UP);\n+        }\n \n         // Bind and start to accept incoming connections.\n         ChannelFuture bindFuture = serverBootstrap.bind(listenAddress);\n@@ -393,10 +398,11 @@ synchronized private void stop()\n             // TODO(carl-mastrangelo): shutdown the netty servers accepting new connections.\n             nettyServers.clear();\n \n-            // Flag status as down.\n-            // TODO - is this _only_ changing the local status? And therefore should we also implement a HealthCheckHandler\n-            // that we can flag to return DOWN here (would that then update Discovery? or still be a delay?)\n-            serverStatusManager.localStatus(InstanceInfo.InstanceStatus.DOWN);\n+            if (MANUAL_DISCOVERY_STATUS.get()) {\n+                // Flag status as down.\n+                // that we can flag to return DOWN here (would that then update Discovery? or still be a delay?)\n+                serverStatusManager.localStatus(InstanceInfo.InstanceStatus.DOWN);\n+            }\n \n             // Shutdown each of the client connections (blocks until complete).\n             // NOTE: ClientConnectionsShutdown can also be configured to gracefully close connections when the",
      "parent_sha": "5565180f5a96a0ed5b01092c273aba14e7bf3543"
    }
  },
  {
    "oid": "9f02193cd387971c6cc6dab040724d1a82721579",
    "message": "Fix for ProxyEndpoint not correctly invoking the origin.origin.onRequest*() interface",
    "date": "2018-03-04T03:30:21Z",
    "url": "https://github.com/Netflix/zuul/commit/9f02193cd387971c6cc6dab040724d1a82721579",
    "details": {
      "sha": "7fee589b200d03efd3308d93180e55efff7ad827",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/filters/endpoint/ProxyEndpoint.java",
      "status": "modified",
      "additions": 52,
      "deletions": 59,
      "changes": 111,
      "blob_url": "https://github.com/Netflix/zuul/blob/9f02193cd387971c6cc6dab040724d1a82721579/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/9f02193cd387971c6cc6dab040724d1a82721579/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java?ref=9f02193cd387971c6cc6dab040724d1a82721579",
      "patch": "@@ -40,7 +40,10 @@\n import com.netflix.zuul.message.Headers;\n import com.netflix.zuul.message.ZuulMessage;\n import com.netflix.zuul.message.http.HttpHeaderNames;\n-import com.netflix.zuul.message.http.*;\n+import com.netflix.zuul.message.http.HttpQueryParams;\n+import com.netflix.zuul.message.http.HttpRequestMessage;\n+import com.netflix.zuul.message.http.HttpResponseMessage;\n+import com.netflix.zuul.message.http.HttpResponseMessageImpl;\n import com.netflix.zuul.netty.ChannelUtils;\n import com.netflix.zuul.netty.NettyRequestAttemptFactory;\n import com.netflix.zuul.netty.SpectatorUtils;\n@@ -67,7 +70,11 @@\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.ChannelPipeline;\n-import io.netty.handler.codec.http.*;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.DefaultLastHttpContent;\n+import io.netty.handler.codec.http.HttpContent;\n+import io.netty.handler.codec.http.HttpResponse;\n+import io.netty.handler.codec.http.LastHttpContent;\n import io.netty.util.concurrent.Future;\n import io.netty.util.concurrent.GenericFutureListener;\n import io.netty.util.concurrent.Promise;\n@@ -170,7 +177,7 @@ public RequestAttempts getRequestAttempts() {\n     }\n \n     protected RequestAttempt getCurrentRequestAttempt() {\n-       return currentRequestAttempt;\n+        return currentRequestAttempt;\n     }\n \n     public CurrentPassport getPassport() {\n@@ -364,8 +371,39 @@ public void operationComplete(final Future<PooledConnection> connectResult) {\n         // MUST run this within bindingcontext because RequestExpiryProcessor (and probably other things) depends on ThreadVariables.\n         try {\n             methodBinding.bind(() -> {\n+\n+                // Invoke the ribbon execution listeners (including RequestExpiry).\n+                final ExecutionContext<?> executionContext = origin.getExecutionContext(zuulRequest, attemptNum);\n+                IClientConfig requestConfig = executionContext.getRequestConfig();\n+                final Object previousOverriddenReadTimeout = requestConfig.getProperty(ReadTimeout, null);\n+                Integer readTimeout;\n+                try {\n+                    Server server = chosenServer.get();\n+                    if (requestStat != null)\n+                        requestStat.server(server);\n+\n+                    readTimeout = getReadTimeout(requestConfig, attemptNum);\n+                    requestConfig.set(ReadTimeout, readTimeout);\n+\n+                    origin.onRequestStartWithServer(zuulRequest, server, attemptNum);\n+                }\n+                catch (Throwable e) {\n+                    handleError(e);\n+                    return;\n+                }\n+                finally {\n+                    // Reset the timeout in overriddenConfig back to what it was before, otherwise it will take\n+                    // preference on subsequent retry attempts in RequestExpiryProcessor.\n+                    if (previousOverriddenReadTimeout == null) {\n+                        requestConfig.setProperty(ReadTimeout, null);\n+                    } else {\n+                        requestConfig.setProperty(ReadTimeout, previousOverriddenReadTimeout);\n+                    }\n+                }\n+\n+                // Handle the connection.\n                 if (connectResult.isSuccess()) {\n-                    onOriginConnectSucceeded(connectResult.getNow());\n+                    onOriginConnectSucceeded(connectResult.getNow(), readTimeout);\n                 } else {\n                     onOriginConnectFailed(connectResult.cause());\n                 }\n@@ -381,44 +419,13 @@ public void operationComplete(final Future<PooledConnection> connectResult) {\n         }\n     }\n \n-    private void onOriginConnectSucceeded(PooledConnection conn) {\n+    private void onOriginConnectSucceeded(PooledConnection conn, int readTimeout) {\n         passport.add(ORIGIN_CONN_ACQUIRE_END);\n \n         if (context.isCancelled()) {\n             conn.release();\n         }\n         else {\n-\n-            final ExecutionContext<?> executionContext = origin.getExecutionContext(zuulRequest, attemptNum);\n-            IClientConfig requestConfig = executionContext.getRequestConfig();\n-            final Object previousOverriddenReadTimeout = requestConfig.getProperty(ReadTimeout, null);\n-\n-            Integer readTimeout;\n-            try {\n-                Server server = conn.getServer();\n-                if (requestStat != null)\n-                    requestStat.server(server);\n-\n-                readTimeout = getReadTimeout(requestConfig, attemptNum);\n-                requestConfig.set(ReadTimeout, readTimeout);\n-\n-                // Invoke the niws execution listeners (including RequestExpiry).\n-                origin.onRequestStartWithServer(zuulRequest, server, attemptNum);\n-            }\n-            catch (Throwable e) {\n-                handleError(e);\n-                return;\n-            }\n-            finally {\n-                // Reset the timeout in overriddenConfig back to what it was before, otherwise it will take\n-                // preference on subsequent retry attempts in RequestExpiryProcessor.\n-                if (previousOverriddenReadTimeout == null) {\n-                    requestConfig.setProperty(ReadTimeout, null);\n-                } else {\n-                    requestConfig.setProperty(ReadTimeout, previousOverriddenReadTimeout);\n-                }\n-            }\n-\n             // Set the read timeout (we only do this late because this timeout can be adjusted dynamically by the niws RequestExpiryExecutionListener\n             // that is run as part of onRequestStartWithServer() above.\n             // Add a ReadTimeoutHandler to the channel before we send a request on it.\n@@ -729,9 +736,15 @@ private HttpResponseMessage buildZuulHttpResponse(final HttpResponse httpRespons\n         final int respStatus = httpResponse.status().code();\n         final HttpResponseMessage zuulResponse = new HttpResponseMessageImpl(zuulCtx, zuulRequest, respStatus);\n \n-        //Request was a success even if server may have responded with an error code 5XX\n+        // Request was a success even if server may have responded with an error code 5XX, except for 503.\n         if (originConn != null) {\n-            origin.onRequestExecutionSuccess(zuulRequest, zuulResponse, originConn.getServer(), attemptNum);\n+            if (statusCategory == ZuulStatusCategory.FAILURE_ORIGIN_THROTTLED) {\n+                origin.onRequestExecutionFailed(zuulRequest, originConn.getServer(), attemptNum,\n+                        new ClientException(ClientException.ErrorType.SERVER_THROTTLED));\n+            }\n+            else {\n+                origin.onRequestExecutionSuccess(zuulRequest, zuulResponse, originConn.getServer(), attemptNum);\n+            }\n         }\n         origin.recordFinalResponse(zuulResponse);\n         origin.recordFinalError(zuulRequest, ex);\n@@ -762,27 +775,7 @@ private HttpResponseMessage buildZuulHttpResponse(final HttpResponse httpRespons\n             zuulResponse.bufferBodyContents(new DefaultLastHttpContent(chunk));\n         }\n \n-        transformResponse(zuulResponse);\n-\n-        // Request was a success even if server may have responded with an error code 5XX, except for 503.\n-        if (originConn != null) {\n-            if (statusCategory == ZuulStatusCategory.FAILURE_ORIGIN_THROTTLED) {\n-                origin.onRequestExecutionFailed(zuulRequest, originConn.getServer(), attemptNum,\n-                        new ClientException(ClientException.ErrorType.SERVER_THROTTLED));\n-            }\n-            else {\n-                origin.onRequestExecutionSuccess(zuulRequest, zuulResponse, originConn.getServer(), attemptNum);\n-            }\n-        }\n-\n-        origin.recordFinalResponse(zuulResponse);\n-        origin.recordFinalError(zuulRequest, ex);\n-        origin.getProxyTiming(zuulRequest).end();\n-        zuulCtx.set(CommonContextKeys.STATUS_CATGEORY, statusCategory);\n-        zuulCtx.setError(ex);\n-        zuulCtx.put(\"origin_http_status\", Integer.toString(respStatus));\n-\n-        return zuulResponse;\n+        return transformResponse(zuulResponse);\n     }\n \n     private HttpResponseMessage transformResponse(HttpResponseMessage resp) {",
      "parent_sha": "a4f3fbefc93c57c069a23d3e8493d15f19ebc600"
    }
  },
  {
    "oid": "517e0c136187ba5105f4c9b989314efbea54d696",
    "message": "zuul-core: always cache full bodies, regardless of SSL\n\nIn the scope of Retrying POST bodies in response to 503's Zuul keeps a copy of the body to send again in certain circumstances.   Normally, if the body has not been sent to the origin, and Zuul has not sent anything to the client, Zuul will compromise the HTTP spec and consider POSTs retryable.   (Too many things depend on this wrong behavior; it would risky to change.)  In the current code, Netty's SSL handler will mutate the body when sending it, so the ProxyEndpoint will keep a pristine copy of the body assuming the full body is present.  In the case SSL was not requested, Zuul depends on Netty not clearing the buffers as it sends, and thus doesn't keep the copy around.\r\n\r\nInternally at Netflix, we want to automatically upgrade to SSL if possible, but that is only after the ProxyEndpoint code has decided to cache or not.   An Origin may not explicit ask for SSL, but eventually use it, so it is too late to set the NIWS `IsSecure` bit and cache the body.   (Requesting SSL is per Origin, using SSL is per Server).\r\n\r\nTo ensure that 503's are retryable, and that we don't depend on Netty's HTTP subtleties, this change unconditionally caches the body, and pessimistically assumes that the body could be mutated.  This allows for auto SSL upgrades later down the call chain as well.\r\n\r\nSorry, no tests.   This code definitely warrants a test, but it is ridiculously difficult to add one.   I'm taking out a loan on our tech debt, which I hope to one day pay back.",
    "date": "2020-12-09T22:09:21Z",
    "url": "https://github.com/Netflix/zuul/commit/517e0c136187ba5105f4c9b989314efbea54d696",
    "details": {
      "sha": "5fcc65ee77f5f5b54312112a34cbf54d813cb8c7",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/filters/endpoint/ProxyEndpoint.java",
      "status": "modified",
      "additions": 16,
      "deletions": 14,
      "changes": 30,
      "blob_url": "https://github.com/Netflix/zuul/blob/517e0c136187ba5105f4c9b989314efbea54d696/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/517e0c136187ba5105f4c9b989314efbea54d696/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java?ref=517e0c136187ba5105f4c9b989314efbea54d696",
      "patch": "@@ -145,11 +145,11 @@ public class ProxyEndpoint extends SyncZuulFilterAdapter<HttpRequestMessage, Htt\n     protected RequestAttempt currentRequestAttempt;\n     protected List<RequestStat> requestStats = new ArrayList<>();\n     protected RequestStat currentRequestStat;\n-    private final byte[] sslRetryBodyCache;\n+    private final byte[] retryBodyCache;\n \n     public static final Set<String> IDEMPOTENT_HTTP_METHODS = Sets.newHashSet(\"GET\", \"HEAD\", \"OPTIONS\");\n     private static final DynamicIntegerSetProperty RETRIABLE_STATUSES_FOR_IDEMPOTENT_METHODS = new DynamicIntegerSetProperty(\"zuul.retry.allowed.statuses.idempotent\", \"500\");\n-    private static final DynamicBooleanProperty ENABLE_CACHING_SSL_BODIES = new DynamicBooleanProperty(\"zuul.cache.ssl.bodies\", true);\n+    private static final DynamicBooleanProperty ENABLE_CACHING_BODIES = new DynamicBooleanProperty(\"zuul.cache.bodies\", true);\n \n     private static final CachedDynamicIntProperty MAX_OUTBOUND_READ_TIMEOUT = new CachedDynamicIntProperty(\"zuul.origin.readtimeout.max\", 90 * 1000);\n \n@@ -159,7 +159,7 @@ public class ProxyEndpoint extends SyncZuulFilterAdapter<HttpRequestMessage, Htt\n     private static final Logger LOG = LoggerFactory.getLogger(ProxyEndpoint.class);\n     private static final Counter NO_RETRY_INCOMPLETE_BODY = SpectatorUtils.newCounter(\"zuul.no.retry\",\"incomplete_body\");\n     private static final Counter NO_RETRY_RESP_STARTED = SpectatorUtils.newCounter(\"zuul.no.retry\",\"resp_started\");\n-    private final Counter populatedSslRetryBody;\n+    private final Counter populatedRetryBody;\n \n \n     public ProxyEndpoint(final HttpRequestMessage inMesg, final ChannelHandlerContext ctx,\n@@ -180,9 +180,9 @@ public ProxyEndpoint(final HttpRequestMessage inMesg, final ChannelHandlerContex\n         chosenServer = new AtomicReference<>();\n         chosenHostAddr = new AtomicReference<>();\n \n-        this.sslRetryBodyCache = preCacheBodyForRetryingSslRequests();\n-        this.populatedSslRetryBody = SpectatorUtils.newCounter(\n-                \"zuul.populated.ssl.retry.body\", origin == null ? \"null\" : origin.getName().getTarget());\n+        this.retryBodyCache = preCacheBodyForRetryingRequests();\n+        this.populatedRetryBody = SpectatorUtils.newCounter(\n+                \"zuul.populated.retry.body\", origin == null ? \"null\" : origin.getName().getTarget());\n \n         this.methodBinding = methodBinding;\n         this.requestAttemptFactory = requestAttemptFactory;\n@@ -565,22 +565,24 @@ private void onOriginConnectFailed(Throwable cause) {\n         }\n     }\n \n-    private byte[] preCacheBodyForRetryingSslRequests() {\n+    private byte[] preCacheBodyForRetryingRequests() {\n         // Netty SSL handler clears body ByteBufs, so we need to cache the body if we want to retry POSTs\n-        if (ENABLE_CACHING_SSL_BODIES.get() && origin != null &&\n-                // only cache requests if already buffered\n-                origin.getClientConfig().get(IClientConfigKey.Keys.IsSecure, false) && zuulRequest.hasCompleteBody()) {\n+        // Followup: We expect most origin connections to be secure, so it's okay to unconditionally cache here.\n+        // Additionally, it's risky to assume the plaintext handlers won't clear the body (they do), so just pay the\n+        // cost caching regardless.\n+        if (ENABLE_CACHING_BODIES.get() && origin != null && zuulRequest.hasCompleteBody()) {\n+            // only cache requests if already buffered\n             return zuulRequest.getBody();\n         }\n         return null;\n     }\n \n     private void repopulateRetryBody() {\n-        // if SSL origin request body is cached and has been cleared by Netty SslHandler, set it from cache\n         // note: it's not null but is empty because the content chunks exist but the actual readable bytes are 0\n-        if (sslRetryBodyCache != null && attemptNum > 1 && zuulRequest.getBody() != null && zuulRequest.getBody().length == 0) {\n-            zuulRequest.setBody(sslRetryBodyCache);\n-            populatedSslRetryBody.increment();\n+        if (retryBodyCache != null && attemptNum > 1\n+                && zuulRequest.getBodyLength() == 0 && zuulRequest.getBody() != null) {\n+            zuulRequest.setBody(retryBodyCache);\n+            populatedRetryBody.increment();\n         }\n     }\n ",
      "parent_sha": "f94164b786f98b3e3c0ceeabffcc0d42b536c93b"
    }
  },
  {
    "oid": "2693aba067f97cc4a6e31f20a5ed26ca9e2323d4",
    "message": "Bugfix in FilterProcessor when casting msg to either HttpRequest or HttpResponse.",
    "date": "2015-07-06T22:54:22Z",
    "url": "https://github.com/Netflix/zuul/commit/2693aba067f97cc4a6e31f20a5ed26ca9e2323d4",
    "details": {
      "sha": "ea5b757ecb53dbb70299ee725fa867fbb2eb309e",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/FilterProcessor.java",
      "status": "modified",
      "additions": 10,
      "deletions": 1,
      "changes": 11,
      "blob_url": "https://github.com/Netflix/zuul/blob/2693aba067f97cc4a6e31f20a5ed26ca9e2323d4/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/2693aba067f97cc4a6e31f20a5ed26ca9e2323d4/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java?ref=2693aba067f97cc4a6e31f20a5ed26ca9e2323d4",
      "patch": "@@ -107,7 +107,16 @@ public Observable<ZuulMessage> applyErrorEndpointIfNeeded(Observable<ZuulMessage\n                     String errorStr = \"No error filter found of chosen name! name=\" + endpointName;\n                     LOG.error(\"Errored but no error filter found, so sent default error response. \" + errorStr, context.getError());\n \n-                    HttpResponseMessage response = new HttpResponseMessage(msg.getContext(), (HttpRequestMessage) msg, 500);\n+                    // Pull out the request object to use for building a new response.\n+                    HttpRequestMessage request;\n+                    if (HttpResponseMessage.class.isAssignableFrom(msg.getClass())) {\n+                        request = ((HttpResponseMessage) msg).getRequest();\n+                    } else {\n+                        request = (HttpRequestMessage) msg;\n+                    }\n+\n+                    // Build the error response.\n+                    HttpResponseMessage response = new HttpResponseMessage(msg.getContext(), request, 500);\n                     response.getHeaders().set(\"X-Zuul-Error-Cause\", errorStr);\n \n                     return Observable.just(response);",
      "parent_sha": "ad2ef6a413d1ee41fa2723d9f70365ae3aeee499"
    }
  },
  {
    "oid": "420e163a9f2a7f94f7a7e4fa9333b6be3e05c301",
    "message": "- HttpServletRequestWrapper:\n-- Changed from using IOUtils.toByteArray() to IOUtils.copy() because copy() was sometimes returning an incomplete byte array (ie. was truncated).\n-- Added some more debug logging.",
    "date": "2014-03-06T21:18:45Z",
    "url": "https://github.com/Netflix/zuul/commit/420e163a9f2a7f94f7a7e4fa9333b6be3e05c301",
    "details": {
      "sha": "02b2d9039156af78aa1ab5c3c9fa99d63b09128b",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/http/HttpServletRequestWrapper.java",
      "status": "modified",
      "additions": 16,
      "deletions": 2,
      "changes": 18,
      "blob_url": "https://github.com/Netflix/zuul/blob/420e163a9f2a7f94f7a7e4fa9333b6be3e05c301/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fhttp%2FHttpServletRequestWrapper.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/420e163a9f2a7f94f7a7e4fa9333b6be3e05c301/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fhttp%2FHttpServletRequestWrapper.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fhttp%2FHttpServletRequestWrapper.java?ref=420e163a9f2a7f94f7a7e4fa9333b6be3e05c301",
      "patch": "@@ -139,10 +139,20 @@ private void parseRequest() throws IOException {\n             }\n         }\n \n+        LOG.debug(\"Path = \" + req.getPathInfo());\n+        LOG.debug(\"Transfer-Encoding = \" + String.valueOf(req.getHeader(ZuulHeaders.TRANSFER_ENCODING)));\n+        LOG.debug(\"Content-Encoding = \" + String.valueOf(req.getHeader(ZuulHeaders.CONTENT_ENCODING)));\n+\n+        LOG.debug(\"Content-Length header = \" + req.getContentLength());\n         if (req.getContentLength() > 0) {\n \n-            contentData = IOUtils.toByteArray(req.getInputStream());\n+            // Read the request body inputstream into a byte array.\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            IOUtils.copy(req.getInputStream(), baos);\n+            contentData = baos.toByteArray();\n+\n             try {\n+                LOG.debug(\"Length of contentData byte array = \" + contentData.length);\n                 if (req.getContentLength() != contentData.length) {\n                     LOG.warn(\"Content-length different from byte array length! cl=\" + req.getContentLength() + \", array=\" + contentData.length);\n                 }\n@@ -186,8 +196,12 @@ private void parseRequest() throws IOException {\n \n         } else if (req.getContentLength() == -1) {\n             final String transferEncoding = req.getHeader(ZuulHeaders.TRANSFER_ENCODING);\n-            if (transferEncoding != null && transferEncoding.equals(ZuulHeaders.CHUNKED))\n+            if (transferEncoding != null && transferEncoding.equals(ZuulHeaders.CHUNKED)) {\n                 RequestContext.getCurrentContext().setChunkedRequestBody();\n+                LOG.debug(\"Set flag that request body is chunked.\");\n+            }\n+        } else {\n+            LOG.warn(\"Content-Length is neither greater than zero or -1. = \" + req.getContentLength());\n         }\n \n         HashMap<String, String[]> map = new HashMap<String, String[]>(mapA.size() * 2);",
      "parent_sha": "15edce92a538d73805175430f74388daba9d3670"
    }
  },
  {
    "oid": "aea6d390152cae6ad1720c076936a8eda71a2c73",
    "message": "Marking the default response status code as 500 in the RequestContext instead of the Servlet Response object",
    "date": "2014-02-23T21:05:03Z",
    "url": "https://github.com/Netflix/zuul/commit/aea6d390152cae6ad1720c076936a8eda71a2c73",
    "details": {
      "sha": "277c96b4a98612dbb09ee240926ff1824139e32c",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/ZuulRunner.java",
      "status": "modified",
      "additions": 16,
      "deletions": 17,
      "changes": 33,
      "blob_url": "https://github.com/Netflix/zuul/blob/aea6d390152cae6ad1720c076936a8eda71a2c73/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FZuulRunner.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/aea6d390152cae6ad1720c076936a8eda71a2c73/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FZuulRunner.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FZuulRunner.java?ref=aea6d390152cae6ad1720c076936a8eda71a2c73",
      "patch": "@@ -15,24 +15,28 @@\n  */\n package com.netflix.zuul;\n \n-import com.netflix.zuul.context.RequestContext;\n-import com.netflix.zuul.exception.ZuulException;\n-import com.netflix.zuul.http.HttpServletRequestWrapper;\n-import com.netflix.zuul.http.HttpServletResponseWrapper;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.PrintWriter;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n import org.mockito.runners.MockitoJUnitRunner;\n \n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import java.io.PrintWriter;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-import static org.mockito.Mockito.*;\n+import com.netflix.zuul.context.RequestContext;\n+import com.netflix.zuul.exception.ZuulException;\n+import com.netflix.zuul.http.HttpServletRequestWrapper;\n+import com.netflix.zuul.http.HttpServletResponseWrapper;\n \n \n /**\n@@ -57,9 +61,9 @@ public ZuulRunner() {\n      * @param servletResponse\n      */\n     public void init(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {\n-        servletResponse.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n         RequestContext.getCurrentContext().setRequest(new HttpServletRequestWrapper(servletRequest));\n         RequestContext.getCurrentContext().setResponse(new HttpServletResponseWrapper(servletResponse));\n+        RequestContext.getCurrentContext().setResponseStatusCode(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n     }\n \n     /**\n@@ -112,7 +116,6 @@ public static class UnitTest {\n         @Mock\n         FilterProcessor processor;\n \n-\n         @Mock\n         PrintWriter writer;\n \n@@ -128,7 +131,6 @@ public void testProcessZuulFilter() {\n             runner = spy(runner);\n             RequestContext context = spy(RequestContext.getCurrentContext());\n \n-\n             try {\n                 FilterProcessor.setProcessor(processor);\n                 RequestContext.testSetCurrentContext(context);\n@@ -144,7 +146,6 @@ public void testProcessZuulFilter() {\n \n                 runner.postRoute();\n                 verify(processor, times(1)).postRoute();\n-//                verify(context, times(1)).unset();\n \n                 runner.route();\n                 verify(processor, times(1)).route();\n@@ -153,8 +154,6 @@ public void testProcessZuulFilter() {\n             } catch (Exception e) {\n                 e.printStackTrace();\n             }\n-\n-\n         }\n     }\n }\n\\ No newline at end of file",
      "parent_sha": "01519b8617a6a386276ff081e3db3b20435a35cb"
    }
  },
  {
    "oid": "17c4c1b8d1c1ac549601288585c970c3abcf0a56",
    "message": "Adding missed redirect paths",
    "date": "2014-06-01T03:55:04Z",
    "url": "https://github.com/Netflix/zuul/commit/17c4c1b8d1c1ac549601288585c970c3abcf0a56",
    "details": {
      "sha": "a894d2867f13ee5fff8633747dff8f977a07d89a",
      "filename": "zuul-netflix/src/main/java/com/netflix/zuul/scriptManager/FilterScriptManagerServlet.java",
      "status": "modified",
      "additions": 3,
      "deletions": 22,
      "changes": 25,
      "blob_url": "https://github.com/Netflix/zuul/blob/17c4c1b8d1c1ac549601288585c970c3abcf0a56/zuul-netflix%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FscriptManager%2FFilterScriptManagerServlet.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/17c4c1b8d1c1ac549601288585c970c3abcf0a56/zuul-netflix%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FscriptManager%2FFilterScriptManagerServlet.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-netflix%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FscriptManager%2FFilterScriptManagerServlet.java?ref=17c4c1b8d1c1ac549601288585c970c3abcf0a56",
      "patch": "@@ -356,12 +356,12 @@ private void handleActivateAction(HttpServletRequest request, HttpServletRespons\n                     return;\n                 }\n                 try {\n-                    FilterInfo filterInfo = scriptDAO.setFilterActive(filter_id, revisionNumber);\n+                   scriptDAO.setFilterActive(filter_id, revisionNumber);\n                 } catch (Exception e) {\n                     setUsageError(400, \"ERROR: \" + e.getMessage(), response);\n                     return;\n                 }\n-                response.sendRedirect(\"filterLoader.jsp\");\n+                response.sendRedirect(redirectPath.get());\n \n                 //                Map<String, Object> scriptJson = createEndpointScriptJSON(filterInfo);\n                 //              response.getWriter().write(JsonUtility.jsonFromMap(scriptJson));\n@@ -391,10 +391,7 @@ private void handleUploadAction(HttpServletRequest request, HttpServletResponse\n                 setUsageError(500, \"ERROR: Unable to process uploaded data.\", response);\n                 return;\n             }\n-            response.sendRedirect(\"filterLoader.jsp\");\n-\n-            //            Map<String, Object> scriptJson = createEndpointScriptJSON(filterInfo);\n-            //            response.getWriter().write(JsonUtility.jsonFromMap(scriptJson));\n+            response.sendRedirect(redirectPath.get());\n         }\n     }\n \n@@ -633,9 +630,6 @@ public void testListScripts() throws Exception {\n             /* setup mock DAO */\n \n             ZuulFilterDAO dao = mock(ZuulFilterDAOCassandra.class);\n-\n-            Calendar now = Calendar.getInstance();\n-\n             List<FilterInfo> scriptsForEndpoint = new ArrayList<FilterInfo>();\n             scriptsForEndpoint.add(new FilterInfo(\"name1:type\", \"code\", \"type\", \"name\", \"disable\", \"order\", \"app\"));\n             scriptsForEndpoint.add(new FilterInfo(\"name2:type\", \"code\", \"type\", \"name\", \"disable\", \"order\", \"app\"));\n@@ -917,9 +911,6 @@ public void testActivateRevision() throws Exception {\n             /* verify the default status is used */\n             verify(response, never()).setStatus(anyInt());\n             verify(dao).setFilterActive(endpoint, 2);\n-\n-            Map<String, Object> expectedJson = createExpectedJsonMap(script);\n-\n         }\n \n         @Test\n@@ -985,15 +976,5 @@ private FilterInfo mockEndpointScript() {\n             when(script.isCanary()).thenReturn(false);\n             return script;\n         }\n-\n-        private Integer[] getStringAsIntegerArray(String scriptBody) {\n-            char[] chars = scriptBody.toCharArray();\n-            Integer[] bytes = new Integer[chars.length + 1];\n-            for (int i = 0; i < chars.length; i++) {\n-                bytes[i] = Integer.valueOf(chars[i]);\n-            }\n-            bytes[bytes.length - 1] = -1;\n-            return bytes;\n-        }\n     }\n }",
      "parent_sha": "87c3571a34283a8a0f0228b60211efae33f2b915"
    }
  },
  {
    "oid": "b95759670ec802d88c40778025c852572d1225c4",
    "message": "zuul-core: selectively increase precision on conn timer",
    "date": "2020-12-12T00:51:47Z",
    "url": "https://github.com/Netflix/zuul/commit/b95759670ec802d88c40778025c852572d1225c4",
    "details": {
      "sha": "bec7c7c9a6efd765a453215a006809b4e8a483f5",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/monitoring/ConnTimer.java",
      "status": "modified",
      "additions": 21,
      "deletions": 4,
      "changes": 25,
      "blob_url": "https://github.com/Netflix/zuul/blob/b95759670ec802d88c40778025c852572d1225c4/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmonitoring%2FConnTimer.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/b95759670ec802d88c40778025c852572d1225c4/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmonitoring%2FConnTimer.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmonitoring%2FConnTimer.java?ref=b95759670ec802d88c40778025c852572d1225c4",
      "patch": "@@ -16,6 +16,7 @@\n \n package com.netflix.zuul.monitoring;\n \n+import com.netflix.config.DynamicBooleanProperty;\n import com.netflix.spectator.api.Id;\n import com.netflix.spectator.api.Registry;\n import com.netflix.spectator.api.histogram.PercentileTimer;\n@@ -31,12 +32,16 @@\n import java.util.Objects;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n \n /**\n  * A timer for connection stats.  Not thread-safe.\n  */\n public final class ConnTimer {\n \n+    private static final DynamicBooleanProperty PRECISE_TIMING =\n+            new DynamicBooleanProperty(\"zuul.conn.precise_timing\", false);\n+\n     private static final AttributeKey<ConnTimer> CONN_TIMER = AttributeKey.newInstance(\"zuul.conntimer\");\n \n     private static final Duration MIN_CONN_TIMING = Duration.ofNanos(1024);\n@@ -46,13 +51,20 @@ public final class ConnTimer {\n     private final Channel chan;\n     // TODO(carl-mastrangelo): make this changable.\n     private final Id metricBase;\n+    @Nullable\n+    private final Id preciseMetricBase;\n \n     private final Map<String, Long> timings = new LinkedHashMap<>();\n \n     private ConnTimer(Registry registry, Channel chan, Id metricBase) {\n         this.registry = Objects.requireNonNull(registry);\n         this.chan = Objects.requireNonNull(chan);\n         this.metricBase = Objects.requireNonNull(metricBase);\n+        if (PRECISE_TIMING.get()) {\n+            preciseMetricBase = registry.createId(metricBase.name() + \".pct\").withTags(metricBase.tags());\n+        } else {\n+            preciseMetricBase = null;\n+        }\n     }\n \n     public static ConnTimer install(Channel chan, Registry registry, Id metricBase) {\n@@ -85,6 +97,7 @@ public void record(Long now, String event) {\n         for (Key<?> key : dims.keySet()) {\n             dimTags.put(key.name(), String.valueOf(key.get(dims)));\n         }\n+        dimTags.put(\"to\", event);\n \n         // Note: this is effectively O(n^2) because it will be called for each event in the connection\n         // setup.  It should be bounded to at most 10 or so.\n@@ -95,11 +108,15 @@ public void record(Long now, String event) {\n                 // it.\n                 return;\n             }\n-            PercentileTimer.builder(registry)\n-                    .withId(metricBase.withTags(dimTags).withTags(\"from\", k, \"to\", event))\n-                    .withRange(MIN_CONN_TIMING, MAX_CONN_TIMING)\n-                    .build()\n+            registry.timer(metricBase.withTags(dimTags).withTags(\"from\", k))\n                     .record(durationNanos, TimeUnit.NANOSECONDS);\n+            if (preciseMetricBase != null) {\n+                PercentileTimer.builder(registry)\n+                        .withId(preciseMetricBase.withTags(dimTags).withTags(\"from\", k))\n+                        .withRange(MIN_CONN_TIMING, MAX_CONN_TIMING)\n+                        .build()\n+                        .record(durationNanos, TimeUnit.NANOSECONDS);\n+            }\n         });\n         timings.put(event, now);\n     }",
      "parent_sha": "203d851240ba1371224f09e4cfba370164330a15"
    }
  },
  {
    "oid": "ef2934eead54e47fda09ed0db309493cef99051a",
    "message": "add Chunked dribble delay test (#1352)",
    "date": "2022-10-20T17:30:14Z",
    "url": "https://github.com/Netflix/zuul/commit/ef2934eead54e47fda09ed0db309493cef99051a",
    "details": {
      "sha": "a6a8daca9642a3f423d178a0110e58cfa6514ed6",
      "filename": "zuul-integration-test/src/test/java/com/netflix/zuul/integration/IntegrationTest.java",
      "status": "modified",
      "additions": 21,
      "deletions": 1,
      "changes": 22,
      "blob_url": "https://github.com/Netflix/zuul/blob/ef2934eead54e47fda09ed0db309493cef99051a/zuul-integration-test%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fintegration%2FIntegrationTest.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/ef2934eead54e47fda09ed0db309493cef99051a/zuul-integration-test%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fintegration%2FIntegrationTest.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-integration-test%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fintegration%2FIntegrationTest.java?ref=ef2934eead54e47fda09ed0db309493cef99051a",
      "patch": "@@ -75,9 +75,11 @@ public class IntegrationTest {\n                 CustomLeakDetector.class.getCanonicalName());\n     }\n \n+\n     static private Bootstrap bootstrap;\n     static private final int ZUUL_SERVER_PORT = findAvailableTcpPort();\n \n+    static private final Duration CLIENT_READ_TIMEOUT = Duration.ofMillis(3000);\n     static private final Duration ORIGIN_READ_TIMEOUT = Duration.ofMillis(1000);\n     private final String zuulBaseUri = \"http://localhost:\" + ZUUL_SERVER_PORT;\n     private String path;\n@@ -126,7 +128,7 @@ void beforeEachTest(final WireMockRuntimeInfo wmRuntimeInfo) {\n     private static OkHttpClient setupOkHttpClient(final Protocol... protocols) {\n         return new OkHttpClient.Builder()\n                 .connectTimeout(30, TimeUnit.MILLISECONDS)\n-                .readTimeout(5, TimeUnit.SECONDS)\n+                .readTimeout(CLIENT_READ_TIMEOUT)\n                 .followRedirects(false)\n                 .followSslRedirects(false)\n                 .retryOnConnectionFailure(false)\n@@ -305,6 +307,24 @@ void httpGetReturnsStatus500DueToConnectionResetByPeer(final String description,\n         verify(0, postRequestedFor(anyUrl()));\n     }\n \n+    @ParameterizedTest\n+    @MethodSource(\"arguments\")\n+    void httpGet_ServerChunkedDribbleDelay(final String description, final OkHttpClient okHttp) throws Exception {\n+        final WireMock wireMock = wmRuntimeInfo.getWireMock();\n+        wireMock.register(\n+                get(path)\n+                        .willReturn(\n+                                aResponse()\n+                                        .withStatus(200)\n+                                        .withBody(\"Hello world, is anybody listening?\")\n+                                        .withChunkedDribbleDelay(10, (int) CLIENT_READ_TIMEOUT.toMillis() + 500)));\n+\n+        Request request = new Request.Builder().url(zuulBaseUri + path).get().build();\n+        Response response = okHttp.newCall(request).execute();\n+        assertThat(response.code()).isEqualTo(200);\n+        response.close();\n+    }\n+\n     private static String randomPath() {\n         return \"/\" + UUID.randomUUID();\n     }",
      "parent_sha": "9728cf588a1f4b9fdff6df1586f7937b5775b425"
    }
  },
  {
    "oid": "f2f3ae93c8e6b83e33bef874774ae6e9f0164ba5",
    "message": "zuul-core: fix NPE in CurrentPassport debugging",
    "date": "2020-11-19T02:01:57Z",
    "url": "https://github.com/Netflix/zuul/commit/f2f3ae93c8e6b83e33bef874774ae6e9f0164ba5",
    "details": {
      "sha": "8334266ce1ee2038e624c6aeb93ed3a8531c8cf3",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/passport/CurrentPassport.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/zuul/blob/f2f3ae93c8e6b83e33bef874774ae6e9f0164ba5/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fpassport%2FCurrentPassport.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/f2f3ae93c8e6b83e33bef874774ae6e9f0164ba5/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fpassport%2FCurrentPassport.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fpassport%2FCurrentPassport.java?ref=f2f3ae93c8e6b83e33bef874774ae6e9f0164ba5",
      "patch": "@@ -88,9 +88,11 @@ protected Thread getOwner() {\n     private Unlocker lock() {\n         boolean locked = false;\n         if ((historyLock.isLocked() && !historyLock.isHeldByCurrentThread()) || !(locked = historyLock.tryLock())) {\n+            Thread owner = historyLock.getOwner();\n+            String ownerStack = String.valueOf(owner != null ? Arrays.asList(owner.getStackTrace()) : historyLock);\n             logger.warn(\n                     \"CurrentPassport already locked!, other={}, self={}\",\n-                    Arrays.asList(historyLock.getOwner().getStackTrace()),\n+                    ownerStack,\n                     Thread.currentThread(),\n                     new ConcurrentModificationException());\n         }",
      "parent_sha": "17195fa86cdf124ceb1b1dc3173cc7ded43d1da7"
    }
  },
  {
    "oid": "eb30e2f4b1b9060d3160ab80bc0a745baa1d2148",
    "message": "Fix that on first invocation of setReadTimeoutOnContext() in ProxyEndpoint, the attemptNum has not yet been incremented",
    "date": "2018-08-24T03:02:18Z",
    "url": "https://github.com/Netflix/zuul/commit/eb30e2f4b1b9060d3160ab80bc0a745baa1d2148",
    "details": {
      "sha": "7a27ad2cad407496e970b648a4998a5292f4f48b",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/filters/endpoint/ProxyEndpoint.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/Netflix/zuul/blob/eb30e2f4b1b9060d3160ab80bc0a745baa1d2148/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/eb30e2f4b1b9060d3160ab80bc0a745baa1d2148/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java?ref=eb30e2f4b1b9060d3160ab80bc0a745baa1d2148",
      "patch": "@@ -255,7 +255,7 @@ public HttpResponseMessage apply(final HttpRequestMessage input) {\n             // To act the same as Ribbon, we must do this before starting execution (as well as before each attempt).\n             IClientConfig requestConfig = origin.getExecutionContext(zuulRequest).getRequestConfig();\n             originalReadTimeout = requestConfig.getProperty(ReadTimeout, null);\n-            setReadTimeoutOnContext(requestConfig);\n+            setReadTimeoutOnContext(requestConfig, 1);\n \n             origin.onRequestExecutionStart(zuulRequest);\n             proxyRequestToOrigin();\n@@ -395,9 +395,9 @@ protected RequestStat createRequestStat() {\n         return basicRequestStat;\n     }\n \n-    private Integer setReadTimeoutOnContext(IClientConfig requestConfig)\n+    private Integer setReadTimeoutOnContext(IClientConfig requestConfig, int attempt)\n     {\n-        Integer readTimeout = getReadTimeout(requestConfig, attemptNum);\n+        Integer readTimeout = getReadTimeout(requestConfig, attempt);\n         requestConfig.set(ReadTimeout, readTimeout);\n         return readTimeout;\n     }\n@@ -421,7 +421,7 @@ public void operationComplete(final Future<PooledConnection> connectResult) {\n                     final ExecutionContext<?> executionContext = origin.getExecutionContext(zuulRequest);\n                     IClientConfig requestConfig = executionContext.getRequestConfig();\n                     try {\n-                        readTimeout = setReadTimeoutOnContext(requestConfig);\n+                        readTimeout = setReadTimeoutOnContext(requestConfig, attemptNum);\n \n                         origin.onRequestStartWithServer(zuulRequest, server, attemptNum);\n                     }",
      "parent_sha": "ca6f8196a0280f560863eb636d9d47f9ee138778"
    }
  },
  {
    "oid": "396f320ee9177685c53952aa4234cb7463cdf9fa",
    "message": "Revert \"ensure buffered bodies are fully disposed\"\n\nThis reverts commit d666b85ab4208f5bf984627cfc9b6ec32a38c0b7.",
    "date": "2022-10-15T00:03:50Z",
    "url": "https://github.com/Netflix/zuul/commit/396f320ee9177685c53952aa4234cb7463cdf9fa",
    "details": {
      "sha": "5b6e957c9952b9223fccaa79871d14d16fedb87a",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/message/ZuulMessageImpl.java",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/Netflix/zuul/blob/396f320ee9177685c53952aa4234cb7463cdf9fa/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2FZuulMessageImpl.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/396f320ee9177685c53952aa4234cb7463cdf9fa/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2FZuulMessageImpl.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2FZuulMessageImpl.java?ref=396f320ee9177685c53952aa4234cb7463cdf9fa",
      "patch": "@@ -27,7 +27,6 @@\n import io.netty.handler.codec.http.HttpContent;\n import io.netty.handler.codec.http.LastHttpContent;\n \n-import io.netty.util.ReferenceCountUtil;\n import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Collections;\n@@ -198,8 +197,8 @@ public boolean finishBufferedBodyIfIncomplete() {\n     @Override\n     public void disposeBufferedBody() {\n         bodyChunks.forEach(chunk -> {\n-            if (ReferenceCountUtil.refCnt(chunk) > 0) {\n-                ReferenceCountUtil.safeRelease(chunk, chunk.refCnt());\n+            if ((chunk != null) && (chunk.refCnt() > 0)) {\n+                chunk.release();\n             }\n         });\n         bodyChunks.clear();\n@@ -215,8 +214,9 @@ public void runBufferedBodyContentThroughFilter(ZuulFilter<?, ?> filter) {\n             if ((filteredChunk != null) && (filteredChunk != origChunk)) {\n                 //filter actually did some processing, set the new chunk in and release the old chunk.\n                 bodyChunks.set(i, filteredChunk);\n-                if (ReferenceCountUtil.refCnt(origChunk) > 0) {\n-                    ReferenceCountUtil.safeRelease(origChunk, origChunk.refCnt());\n+                final int refCnt = origChunk.refCnt();\n+                if (refCnt > 0) {\n+                    origChunk.release(refCnt);\n                 }\n             }\n         }",
      "parent_sha": "24f1fe33d071647084fd97628e97e249d579b1a1"
    }
  },
  {
    "oid": "74fa3d054daee9611ef5ab00b19ab6255de7eaa6",
    "message": "add prefix to all metrics",
    "date": "2014-03-20T23:12:00Z",
    "url": "https://github.com/Netflix/zuul/commit/74fa3d054daee9611ef5ab00b19ab6255de7eaa6",
    "details": {
      "sha": "501180d15db2c0344cc3d99ae887d218b7871c75",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/FilterProcessor.java",
      "status": "modified",
      "additions": 5,
      "deletions": 4,
      "changes": 9,
      "blob_url": "https://github.com/Netflix/zuul/blob/74fa3d054daee9611ef5ab00b19ab6255de7eaa6/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/74fa3d054daee9611ef5ab00b19ab6255de7eaa6/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java?ref=74fa3d054daee9611ef5ab00b19ab6255de7eaa6",
      "patch": "@@ -166,6 +166,7 @@ public Object processZuulFilter(ZuulFilter filter) throws ZuulException {\n \n         RequestContext ctx = RequestContext.getCurrentContext();\n         boolean bDebug = ctx.debugRouting();\n+        final String metricPrefix = \"zuul.filter-\";\n         long execTime = 0;\n         String filterName = \"\";\n         try {\n@@ -190,10 +191,10 @@ public Object processZuulFilter(ZuulFilter filter) throws ZuulException {\n                     t = result.getException();\n                     ctx.addFilterExecutionSummary(filterName, ExecutionStatus.FAILED.name(), execTime);\n                     \n-                    DynamicCounter.increment(filterName, \"status\",\"fail\", \"type\",filter.filterType());\n+                    DynamicCounter.increment(metricPrefix + filterName, \"status\",\"fail\", \"type\",filter.filterType());\n                     break;\n                 case SUCCESS:\n-                \tDynamicCounter.increment(filterName, \"status\",\"success\", \"type\", filter.filterType());\n+                \tDynamicCounter.increment(metricPrefix + filterName, \"status\",\"success\", \"type\", filter.filterType());\n                     o = result.getResult();\n                     ctx.addFilterExecutionSummary(filterName, ExecutionStatus.SUCCESS.name(), execTime);\n                     if (bDebug) {\n@@ -202,7 +203,7 @@ public Object processZuulFilter(ZuulFilter filter) throws ZuulException {\n                     }\n                     break;\n                 default:\n-                \tDynamicCounter.increment(filterName, \"status\", \"unknown\", \"type\", filter.filterType());\n+                \tDynamicCounter.increment(metricPrefix + filterName, \"status\", \"unknown\", \"type\", filter.filterType());\n                     break;\n             }\n             \n@@ -212,7 +213,7 @@ public Object processZuulFilter(ZuulFilter filter) throws ZuulException {\n             if (bDebug) {\n                 Debug.addRoutingDebug(\"Running Filter failed \" + filterName + \" type:\" + filter.filterType() + \" order:\" + filter.filterOrder() + \" \" + e.getMessage());\n             }\n-            DynamicCounter.increment(filterName, \"status\", \"fail\", \"type\", filter.filterType());\n+            DynamicCounter.increment(metricPrefix + filterName, \"status\", \"fail\", \"type\", filter.filterType());\n             if (e instanceof ZuulException) {\n                 throw (ZuulException) e;\n             } else {",
      "parent_sha": "4ae974713f0c36847e4f1bee8ee7bede4f2a8ded"
    }
  },
  {
    "oid": "0674ed699b5d71a653fa3f802e79307510458915",
    "message": "Removed some unnecessary Observable.single() calls.",
    "date": "2015-08-23T00:31:58Z",
    "url": "https://github.com/Netflix/zuul/commit/0674ed699b5d71a653fa3f802e79307510458915",
    "details": {
      "sha": "46cd9a8a5142fe7dc240cd9efb0988a037837d33",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/FilterProcessor.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/zuul/blob/0674ed699b5d71a653fa3f802e79307510458915/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/0674ed699b5d71a653fa3f802e79307510458915/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java?ref=0674ed699b5d71a653fa3f802e79307510458915",
      "patch": "@@ -212,7 +212,7 @@ protected Observable<ZuulMessage> applyFilterPhase(Observable<ZuulMessage> chain\n     {\n         List<ZuulFilter> filters = filterLoader.getFiltersByType(filterType);\n         for (ZuulFilter filter: filters) {\n-            chain = processFilterAsObservable(chain, filter, defaultFilterResultChooser).single();\n+            chain = processFilterAsObservable(chain, filter, defaultFilterResultChooser);\n         }\n         return chain;\n     }\n@@ -261,7 +261,7 @@ public Observable<ZuulMessage> processAsyncFilter(ZuulMessage msg, ZuulFilter fi\n                 // equal or above the requested.\n                 FilterPriority requiredPriority = overrideFilterPriority == null ? msg.getContext().getFilterPriorityToApply() : overrideFilterPriority;\n                 if (isFilterPriority(filter, requiredPriority) && filter.shouldFilter(msg)) {\n-                    resultObs = filter.applyAsync(msg).single();\n+                    resultObs = filter.applyAsync(msg);\n                 } else {\n                     resultObs = Observable.just(defaultFilterResultChooser.call(msg));\n                     info.status = ExecutionStatus.SKIPPED;",
      "parent_sha": "27b066450a6cb98c896277e370562ffdf004ad47"
    }
  },
  {
    "oid": "d8ba9299a27afaaf9533172c61539ab7e3e1a306",
    "message": "Optimize the HttpUtils.stripMaliciousHeaderChars() method to not use regex",
    "date": "2017-04-02T23:53:37Z",
    "url": "https://github.com/Netflix/zuul/commit/d8ba9299a27afaaf9533172c61539ab7e3e1a306",
    "details": {
      "sha": "afd7432c473ad8a27f8181a7c436dad778eadb88",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/util/HttpUtils.java",
      "status": "modified",
      "additions": 6,
      "deletions": 8,
      "changes": 14,
      "blob_url": "https://github.com/Netflix/zuul/blob/d8ba9299a27afaaf9533172c61539ab7e3e1a306/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Futil%2FHttpUtils.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/d8ba9299a27afaaf9533172c61539ab7e3e1a306/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Futil%2FHttpUtils.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Futil%2FHttpUtils.java?ref=d8ba9299a27afaaf9533172c61539ab7e3e1a306",
      "patch": "@@ -24,8 +24,6 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.regex.Pattern;\n-\n import static org.junit.Assert.*;\n \n /**\n@@ -36,7 +34,7 @@\n public class HttpUtils\n {\n     private static final Logger LOG = LoggerFactory.getLogger(HttpUtils.class);\n-    private static final Pattern RE_MALICIOUS_HEADER_CHARS = Pattern.compile(\"(\\r|\\n)\");\n+    private static final char[] MALICIOUS_HEADER_CHARS = {'\\r', '\\n'};\n \n     /**\n      * Get the IP address of client making the request.\n@@ -104,12 +102,12 @@ public static boolean acceptsGzip(Headers headers) {\n      * @param input - decoded header string\n      * @return - clean header string\n      */\n-    public static String stripMaliciousHeaderChars(String input) {\n-\n-        if (input == null) {\n-            return null;\n+    public static String stripMaliciousHeaderChars(String input) \n+    {\n+        for (char c : MALICIOUS_HEADER_CHARS) {\n+            input = StringUtils.remove(input, c);\n         }\n-        return RE_MALICIOUS_HEADER_CHARS.matcher(input).replaceAll(\"\");\n+        return input;\n     }\n \n ",
      "parent_sha": "b1f42e3b7cffca6e85162b09a4304b4301502f81"
    }
  },
  {
    "oid": "2bfbea950f5c09cfe35a35e0668db633123b6113",
    "message": "Revert \"core: adjust release count (#618)\" (#619)\n\n* Revert \"core: adjust release count (#618)\"\r\n\r\nThis reverts commit 6737e6259fc7fc444c70e7df68c8a73b4d0ef3a1.\r\n\r\nBreaks internal build\r\n\r\n* Revert \"core: make sure not to fire HAProxy messages on completion\"\r\n\r\nThis reverts commit e1c7481e5ab52f0903fb10dcc0b29c1ab4ed7c77.",
    "date": "2019-09-12T23:51:16Z",
    "url": "https://github.com/Netflix/zuul/commit/2bfbea950f5c09cfe35a35e0668db633123b6113",
    "details": {
      "sha": "96a018a309569ad2d95c68f940d106442cd91693",
      "filename": "zuul-core/src/main/java/com/netflix/netty/common/proxyprotocol/ElbProxyProtocolChannelHandler.java",
      "status": "modified",
      "additions": 2,
      "deletions": 11,
      "changes": 13,
      "blob_url": "https://github.com/Netflix/zuul/blob/2bfbea950f5c09cfe35a35e0668db633123b6113/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fnetty%2Fcommon%2Fproxyprotocol%2FElbProxyProtocolChannelHandler.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/2bfbea950f5c09cfe35a35e0668db633123b6113/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fnetty%2Fcommon%2Fproxyprotocol%2FElbProxyProtocolChannelHandler.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fnetty%2Fcommon%2Fproxyprotocol%2FElbProxyProtocolChannelHandler.java?ref=2bfbea950f5c09cfe35a35e0668db633123b6113",
      "patch": "@@ -74,7 +74,6 @@ public void addProxyProtocol(ChannelPipeline pipeline)\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception\n     {\n-        boolean stillRead = true;\n         if (withProxyProtocol) {\n             if (msg instanceof HAProxyMessage && msg != null) {\n                 HAProxyMessage hapm = (HAProxyMessage) msg;\n@@ -107,22 +106,14 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception\n                         haProxyTLV.release();\n                     }\n                 }\n-                stillRead = false;\n-                if (hapm.refCnt() > 1) {\n-                    // TODO(carl-mastrangelo): test to see if this is still needed.\n-                    hapm.release();\n-                } else {\n-                    logger.warn(\"Unexpected ref count on HAProxyMessage\");\n-                }\n \n                 // TODO - fire an additional event to notify interested parties that we now know the IP?\n \n                 // Remove ourselves (this handler) from the channel now, as no more work to do.\n                 ctx.pipeline().remove(this);\n             }\n         }\n-        if (stillRead) {\n-            super.channelRead(ctx, msg);\n-        }\n+\n+        super.channelRead(ctx, msg);\n     }\n }",
      "parent_sha": "6737e6259fc7fc444c70e7df68c8a73b4d0ef3a1"
    }
  },
  {
    "oid": "5a3f145c11358f6d98fae482d6b2c5bb9c6ba351",
    "message": "Cleanup 503 LB feature flag (#1899)\n\nCo-authored-by: alaborda <alaborda@netflix.com>",
    "date": "2025-02-27T21:56:20Z",
    "url": "https://github.com/Netflix/zuul/commit/5a3f145c11358f6d98fae482d6b2c5bb9c6ba351",
    "details": {
      "sha": "8baa0584bbd0fb219de2ac8f6c82577bfe2af158",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/filters/endpoint/ProxyEndpoint.java",
      "status": "modified",
      "additions": 1,
      "deletions": 13,
      "changes": 14,
      "blob_url": "https://github.com/Netflix/zuul/blob/5a3f145c11358f6d98fae482d6b2c5bb9c6ba351/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/5a3f145c11358f6d98fae482d6b2c5bb9c6ba351/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java?ref=5a3f145c11358f6d98fae482d6b2c5bb9c6ba351",
      "patch": "@@ -23,7 +23,6 @@\n import com.netflix.client.ClientException;\n import com.netflix.client.config.IClientConfigKey;\n import com.netflix.config.CachedDynamicLongProperty;\n-import com.netflix.config.DynamicBooleanProperty;\n import com.netflix.config.DynamicIntegerSetProperty;\n import com.netflix.netty.common.ByteBufUtil;\n import com.netflix.spectator.api.Counter;\n@@ -154,8 +153,6 @@ public class ProxyEndpoint extends SyncZuulFilterAdapter<HttpRequestMessage, Htt\n     public static final Set<String> IDEMPOTENT_HTTP_METHODS = Sets.newHashSet(\"GET\", \"HEAD\", \"OPTIONS\");\n     private static final DynamicIntegerSetProperty RETRIABLE_STATUSES_FOR_IDEMPOTENT_METHODS =\n             new DynamicIntegerSetProperty(\"zuul.retry.allowed.statuses.idempotent\", \"500\");\n-    private static final DynamicBooleanProperty ENABLE_ORIGIN_THROTTLED_FOR_LB_ERRORS =\n-            new DynamicBooleanProperty(\"zuul.lb.503error.enabled\", false);\n \n     /**\n      * Indicates how long Zuul should remember throttle events for an origin.  As of this writing, throttling is used\n@@ -847,16 +844,7 @@ private HttpResponseMessage buildZuulHttpResponse(\n         // Invoke any Ribbon execution listeners.\n         // Request was a success even if server may have responded with an error code 5XX.\n         if (originConn != null) {\n-            if (!ENABLE_ORIGIN_THROTTLED_FOR_LB_ERRORS.get()\n-                    && statusCategory == ZuulStatusCategory.FAILURE_ORIGIN_THROTTLED) {\n-                origin.onRequestExecutionFailed(\n-                        zuulRequest,\n-                        originConn.getServer(),\n-                        attemptNum,\n-                        new ClientException(ClientException.ErrorType.SERVER_THROTTLED));\n-            } else {\n-                origin.onRequestExecutionSuccess(zuulRequest, zuulResponse, originConn.getServer(), attemptNum);\n-            }\n+            origin.onRequestExecutionSuccess(zuulRequest, zuulResponse, originConn.getServer(), attemptNum);\n         }\n \n         // Collect some info about the received response.",
      "parent_sha": "ea8d2727aa56e8b3163118b861ea760f373b25e5"
    }
  },
  {
    "oid": "0e818fbe3c0381827aa1dd01a4de13c55682a41a",
    "message": "Tests for bug fix on server ref update during conn. acquire",
    "date": "2021-03-11T23:44:02Z",
    "url": "https://github.com/Netflix/zuul/commit/0e818fbe3c0381827aa1dd01a4de13c55682a41a",
    "details": {
      "sha": "9c443f33c3c1864cc961a11d24d3673e243fb41e",
      "filename": "zuul-core/src/test/java/com/netflix/zuul/netty/connectionpool/DefaultClientChannelManagerTest.java",
      "status": "modified",
      "additions": 58,
      "deletions": 2,
      "changes": 60,
      "blob_url": "https://github.com/Netflix/zuul/blob/0e818fbe3c0381827aa1dd01a4de13c55682a41a/zuul-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fconnectionpool%2FDefaultClientChannelManagerTest.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/0e818fbe3c0381827aa1dd01a4de13c55682a41a/zuul-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fconnectionpool%2FDefaultClientChannelManagerTest.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fconnectionpool%2FDefaultClientChannelManagerTest.java?ref=0e818fbe3c0381827aa1dd01a4de13c55682a41a",
      "patch": "@@ -18,22 +18,32 @@\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n import com.google.common.net.InetAddresses;\n import com.google.common.truth.Truth;\n import com.netflix.appinfo.InstanceInfo;\n import com.netflix.appinfo.InstanceInfo.Builder;\n+import com.netflix.client.config.DefaultClientConfigImpl;\n+import com.netflix.spectator.api.DefaultRegistry;\n import com.netflix.zuul.discovery.DiscoveryResult;\n+import com.netflix.zuul.discovery.DynamicServerResolver;\n import com.netflix.zuul.discovery.NonDiscoveryServer;\n import com.netflix.zuul.origins.OriginName;\n+import com.netflix.zuul.passport.CurrentPassport;\n+import io.netty.channel.DefaultEventLoop;\n+import io.netty.util.concurrent.Promise;\n import java.net.InetSocketAddress;\n import java.net.SocketAddress;\n+import java.util.concurrent.atomic.AtomicReference;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n /**\n- * Tests for {@link DefaultClientChannelManager}.  These tests don't use IPv6 addresses because {@link InstanceInfo}\n- * is not capable of expressing them.\n+ * Tests for {@link DefaultClientChannelManager}.  These tests don't use IPv6 addresses because {@link InstanceInfo} is\n+ * not capable of expressing them.\n  */\n @RunWith(JUnit4.class)\n public class DefaultClientChannelManagerTest {\n@@ -91,4 +101,50 @@ public void pickAddressInternal_nonDiscovery_unresolved() {\n         assertTrue(socketAddress.toString(), socketAddress.getAddress().isLoopbackAddress());\n         assertEquals(443, socketAddress.getPort());\n     }\n+\n+    @Test\n+    public void updateServerRefOnEmptyDiscoveryResult() {\n+        OriginName originName = OriginName.fromVip(\"vip\", \"test\");\n+        final DefaultClientConfigImpl clientConfig = new DefaultClientConfigImpl();\n+        final DynamicServerResolver resolver = mock(DynamicServerResolver.class);\n+\n+        when(resolver.resolve(any())).thenReturn(DiscoveryResult.EMPTY);\n+\n+        final DefaultClientChannelManager clientChannelManager = new DefaultClientChannelManager(originName,\n+                clientConfig, resolver, new DefaultRegistry());\n+\n+        final AtomicReference<DiscoveryResult> serverRef = new AtomicReference<>();\n+\n+        final Promise<PooledConnection> promise = clientChannelManager\n+                .acquire(new DefaultEventLoop(), null, CurrentPassport.create(), serverRef, new AtomicReference<>());\n+\n+        Truth.assertThat(promise.isSuccess()).isFalse();\n+        Truth.assertThat(serverRef.get()).isSameInstanceAs(DiscoveryResult.EMPTY);\n+    }\n+\n+    @Test\n+    public void updateServerRefOnValidDiscoveryResult() {\n+        OriginName originName = OriginName.fromVip(\"vip\", \"test\");\n+        final DefaultClientConfigImpl clientConfig = new DefaultClientConfigImpl();\n+\n+        final DynamicServerResolver resolver = mock(DynamicServerResolver.class);\n+        final InstanceInfo instanceInfo = Builder.newBuilder()\n+                .setAppName(\"server-equality\")\n+                .setHostName(\"server-equality\")\n+                .setPort(7777).build();\n+        final DiscoveryResult discoveryResult = DiscoveryResult.from(instanceInfo, false);\n+\n+        when(resolver.resolve(any())).thenReturn(discoveryResult);\n+\n+        final DefaultClientChannelManager clientChannelManager = new DefaultClientChannelManager(originName,\n+                clientConfig, resolver, new DefaultRegistry());\n+\n+        final AtomicReference<DiscoveryResult> serverRef = new AtomicReference<>();\n+\n+        //TODO(argha-c) capture and assert on the promise once we have a dummy with ServerStats initialized\n+        clientChannelManager\n+                .acquire(new DefaultEventLoop(), null, CurrentPassport.create(), serverRef, new AtomicReference<>());\n+\n+        Truth.assertThat(serverRef.get()).isSameInstanceAs(discoveryResult);\n+    }\n }",
      "parent_sha": "62878797cbab4ff4ca0fdc2884f7e7a85c081643"
    }
  },
  {
    "oid": "1a1e6b02d41a792f06cb6e7fec13249add9b885f",
    "message": "Complete static error response body",
    "date": "2017-08-17T00:03:21Z",
    "url": "https://github.com/Netflix/zuul/commit/1a1e6b02d41a792f06cb6e7fec13249add9b885f",
    "details": {
      "sha": "1bce8215a60c2b7d3a15949f28f0d709a2edbc69",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/message/http/HttpResponseMessageImpl.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/zuul/blob/1a1e6b02d41a792f06cb6e7fec13249add9b885f/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2Fhttp%2FHttpResponseMessageImpl.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/1a1e6b02d41a792f06cb6e7fec13249add9b885f/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2Fhttp%2FHttpResponseMessageImpl.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2Fhttp%2FHttpResponseMessageImpl.java?ref=1a1e6b02d41a792f06cb6e7fec13249add9b885f",
      "patch": "@@ -75,7 +75,9 @@ public HttpResponseMessageImpl(SessionContext context, Headers headers, HttpRequ\n \n     public static HttpResponseMessage defaultErrorResponse(HttpRequestMessage request)\n     {\n-        return new HttpResponseMessageImpl(request.getContext(), request, 500);\n+        final HttpResponseMessage resp = new HttpResponseMessageImpl(request.getContext(), request, 500);\n+        resp.finishBufferedBodyIfIncomplete();\n+        return resp;\n     }\n \n     @Override",
      "parent_sha": "ca4a3aa6b39ce7ce71f5f946642f884a75e50849"
    }
  },
  {
    "oid": "7e27f1081ad0b61731c5e5e54beb3a9b0a45cd57",
    "message": "Bugfix on Timing class. When switched to using nanoseconds, I missed one of the places I needed to change.",
    "date": "2015-08-27T00:30:53Z",
    "url": "https://github.com/Netflix/zuul/commit/7e27f1081ad0b61731c5e5e54beb3a9b0a45cd57",
    "details": {
      "sha": "9aaa39730219a5e09b1f2b7e654ee9992273591c",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/stats/Timing.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/zuul/blob/7e27f1081ad0b61731c5e5e54beb3a9b0a45cd57/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fstats%2FTiming.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/7e27f1081ad0b61731c5e5e54beb3a9b0a45cd57/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fstats%2FTiming.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fstats%2FTiming.java?ref=7e27f1081ad0b61731c5e5e54beb3a9b0a45cd57",
      "patch": "@@ -43,7 +43,7 @@ public void start() {\n     }\n \n     public void end() {\n-        this.endTime = System.currentTimeMillis();\n+        this.endTime = System.nanoTime();\n         this.duration = endTime - startTime;\n \n         if (LOG.isDebugEnabled()) {",
      "parent_sha": "ec2c17558f99ea60ab68e8f2f5b253806986a6d8"
    }
  },
  {
    "oid": "bd7343a3850edce37c73f58fb1e98481cf8e3a1d",
    "message": "downgrade http pipelining logs",
    "date": "2023-04-28T14:15:49Z",
    "url": "https://github.com/Netflix/zuul/commit/bd7343a3850edce37c73f58fb1e98481cf8e3a1d",
    "details": {
      "sha": "a087ae9c27277eee5a44ad97cd3ebdf9297e07bf",
      "filename": "zuul-core/src/main/java/com/netflix/netty/common/HttpLifecycleChannelHandler.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/zuul/blob/bd7343a3850edce37c73f58fb1e98481cf8e3a1d/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fnetty%2Fcommon%2FHttpLifecycleChannelHandler.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/bd7343a3850edce37c73f58fb1e98481cf8e3a1d/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fnetty%2Fcommon%2FHttpLifecycleChannelHandler.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fnetty%2Fcommon%2FHttpLifecycleChannelHandler.java?ref=bd7343a3850edce37c73f58fb1e98481cf8e3a1d",
      "patch": "@@ -34,7 +34,7 @@\n  * Time: 4:09 PM\n  */\n public abstract class HttpLifecycleChannelHandler {\n-    private static final Logger LOG = LoggerFactory.getLogger(HttpLifecycleChannelHandler.class);\n+    private static final Logger logger = LoggerFactory.getLogger(HttpLifecycleChannelHandler.class);\n \n     public static final AttributeKey<HttpRequest> ATTR_HTTP_REQ = AttributeKey.newInstance(\"_http_request\");\n     public static final AttributeKey<HttpResponse> ATTR_HTTP_RESP = AttributeKey.newInstance(\"_http_response\");\n@@ -57,7 +57,7 @@ protected static boolean fireStartEvent(ChannelHandlerContext ctx, HttpRequest r\n         if (state == State.STARTED) {\n             // This could potentially happen if a bad client sends a 2nd request on the same connection\n             // without waiting for the response from the first. And we don't support HTTP Pipelining.\n-            LOG.error(\"Received a http request on connection where we already have a request being processed. Closing the connection now. channel = {}\", channel.id().asLongText());\n+            logger.debug(\"Received a http request on connection where we already have a request being processed. Closing the connection now. channel = {}\", channel.id().asLongText());\n             channel.attr(ATTR_HTTP_PIPELINE_REJECT).set(Boolean.TRUE);\n             channel.close();\n             return false;",
      "parent_sha": "e929bb8b03e372e03b639a4d071bb2b543102bf2"
    }
  },
  {
    "oid": "43e878f2cd8ae3392a35730cee3f40e6fa8300e1",
    "message": "Use a metric instead of logging excessive filter execution time",
    "date": "2021-08-17T23:52:56Z",
    "url": "https://github.com/Netflix/zuul/commit/43e878f2cd8ae3392a35730cee3f40e6fa8300e1",
    "details": {
      "sha": "9f3d2894aebe1bce38163d68f60314fbc12f4351",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/filter/BaseZuulFilterRunner.java",
      "status": "modified",
      "additions": 13,
      "deletions": 2,
      "changes": 15,
      "blob_url": "https://github.com/Netflix/zuul/blob/43e878f2cd8ae3392a35730cee3f40e6fa8300e1/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ffilter%2FBaseZuulFilterRunner.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/43e878f2cd8ae3392a35730cee3f40e6fa8300e1/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ffilter%2FBaseZuulFilterRunner.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ffilter%2FBaseZuulFilterRunner.java?ref=43e878f2cd8ae3392a35730cee3f40e6fa8300e1",
      "patch": "@@ -17,6 +17,8 @@\n package com.netflix.zuul.netty.filter;\n \n import com.netflix.config.CachedDynamicIntProperty;\n+import com.netflix.spectator.api.Id;\n+import com.netflix.spectator.api.Registry;\n import com.netflix.spectator.impl.Preconditions;\n import com.netflix.zuul.ExecutionStatus;\n import com.netflix.zuul.FilterUsageNotifier;\n@@ -37,6 +39,8 @@\n import io.netty.handler.codec.http.HttpContent;\n import io.perfmark.Link;\n import io.perfmark.TaskCloseable;\n+\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicReference;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -78,12 +82,16 @@ public abstract class BaseZuulFilterRunner<I extends ZuulMessage, O extends Zuul\n \n     private static final CachedDynamicIntProperty FILTER_EXCESSIVE_EXEC_TIME = new CachedDynamicIntProperty(\"zuul.filters.excessive.execTime\", 500);\n \n+    private final Registry registry;\n+    private final Id filterExcessiveTimerId;\n \n-    protected BaseZuulFilterRunner(FilterType filterType, FilterUsageNotifier usageNotifier, FilterRunner<O, ?> nextStage) {\n+    protected BaseZuulFilterRunner(FilterType filterType, FilterUsageNotifier usageNotifier, FilterRunner<O, ?> nextStage, Registry registry) {\n         this.usageNotifier = Preconditions.checkNotNull(usageNotifier, \"filter usage notifier\");\n         this.nextStage = nextStage;\n         this.RUNNING_FILTER_IDX_SESSION_CTX_KEY = filterType + \"RunningFilterIndex\";\n         this.AWAITING_BODY_FLAG_SESSION_CTX_KEY = filterType + \"IsAwaitingBody\";\n+        this.registry = registry;\n+        this.filterExcessiveTimerId = registry.createId(\"zuul.request.timing.filterExcessive\");\n     }\n \n     public static final ChannelHandlerContext getChannelHandlerContext(final ZuulMessage mesg) {\n@@ -318,7 +326,10 @@ protected void recordFilterCompletion(final ExecutionStatus status, final ZuulFi\n         final long execTimeNs = System.nanoTime() - startTime;\n         final long execTimeMs = execTimeNs / 1_000_000L;\n         if (execTimeMs >= FILTER_EXCESSIVE_EXEC_TIME.get()) {\n-            logger.warn(\"Filter {} took {} ms to complete! status = {}\", filter.filterName(), execTimeMs, status.name());\n+            registry.timer(filterExcessiveTimerId\n+                    .withTag(\"id\", filter.filterName())\n+                    .withTag(\"status\", status.name()))\n+                    .record(execTimeMs, TimeUnit.MILLISECONDS);\n         }\n \n         // Record the execution summary in context.",
      "parent_sha": "3f8e4ee545cd0c1752aab99fda2af34af16a2d65"
    }
  },
  {
    "oid": "d9d5cbd9b52a2145eff420f8f8c42418b3c9a13d",
    "message": "Bugfix in FilterProcessor for ClassCastException after sending error response.",
    "date": "2015-07-30T21:30:51Z",
    "url": "https://github.com/Netflix/zuul/commit/d9d5cbd9b52a2145eff420f8f8c42418b3c9a13d",
    "details": {
      "sha": "62d84fb0200e54b4b7f14e23086f30844abc93a5",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/FilterProcessor.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/Netflix/zuul/blob/d9d5cbd9b52a2145eff420f8f8c42418b3c9a13d/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/d9d5cbd9b52a2145eff420f8f8c42418b3c9a13d/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java?ref=d9d5cbd9b52a2145eff420f8f8c42418b3c9a13d",
      "patch": "@@ -158,14 +158,15 @@ public Observable<ZuulMessage> applyEndpointFilter(Observable<ZuulMessage> chain\n         chain = chain.flatMap(msg -> {\n \n             SessionContext context = msg.getContext();\n-            HttpRequestMessage request = (HttpRequestMessage) msg;\n \n             // If an error filter has already generated a response, then don't run the endpoint.\n             if (context.errorResponseSent()) {\n                 // Therefore this msg is already a response, so just return that.\n                 return Observable.just(msg);\n             }\n \n+            HttpRequestMessage request = (HttpRequestMessage) msg;\n+\n             // Get the previously chosen endpoint filter to use.\n             String endpointName = context.getEndpoint();\n             if (endpointName == null) {",
      "parent_sha": "98eb81b511acddda912647fdc34c61ad3b950669"
    }
  },
  {
    "oid": "e5d6d6f10d94713ad68575dc10663b6601403e49",
    "message": "Fix BadInstanceof lints: https://errorprone.info/bugpattern/BadInstanceof",
    "date": "2025-03-26T21:34:01Z",
    "url": "https://github.com/Netflix/zuul/commit/e5d6d6f10d94713ad68575dc10663b6601403e49",
    "details": {
      "sha": "261eb9078dc9aedd408bb8a54b8f72829cee8b77",
      "filename": "zuul-discovery/src/main/java/com/netflix/zuul/discovery/DiscoveryResult.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/zuul/blob/e5d6d6f10d94713ad68575dc10663b6601403e49/zuul-discovery%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fdiscovery%2FDiscoveryResult.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/e5d6d6f10d94713ad68575dc10663b6601403e49/zuul-discovery%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fdiscovery%2FDiscoveryResult.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-discovery%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fdiscovery%2FDiscoveryResult.java?ref=e5d6d6f10d94713ad68575dc10663b6601403e49",
      "patch": "@@ -102,7 +102,7 @@ public String getHost() {\n \n     @Override\n     public boolean isDiscoveryEnabled() {\n-        return server instanceof DiscoveryEnabledServer;\n+        return server != null;\n     }\n \n     @Override",
      "parent_sha": "afcffdd56db3919353d77a8dc548600c8f272507"
    }
  },
  {
    "oid": "a262b563312801600f078f5e2497a8ddbfedcc22",
    "message": "make open rewrite recipe happy",
    "date": "2023-05-10T18:35:59Z",
    "url": "https://github.com/Netflix/zuul/commit/a262b563312801600f078f5e2497a8ddbfedcc22",
    "details": {
      "sha": "d1e0bda4a8910d58cca32227a511d4aff49b0d36",
      "filename": "zuul-core/src/test/java/com/netflix/zuul/netty/server/ClientResponseWriterTest.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/Netflix/zuul/blob/a262b563312801600f078f5e2497a8ddbfedcc22/zuul-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FClientResponseWriterTest.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/a262b563312801600f078f5e2497a8ddbfedcc22/zuul-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FClientResponseWriterTest.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FClientResponseWriterTest.java?ref=a262b563312801600f078f5e2497a8ddbfedcc22",
      "patch": "@@ -19,7 +19,7 @@\n class ClientResponseWriterTest {\n \n     @Test\n-    public void exemptClientTimeoutResponseBeforeRequestRead() {\n+    void exemptClientTimeoutResponseBeforeRequestRead() {\n         final ClientResponseWriter responseWriter = new ClientResponseWriter(new BasicRequestCompleteHandler());\n         final EmbeddedChannel channel = new EmbeddedChannel();\n \n@@ -32,7 +32,7 @@ public void exemptClientTimeoutResponseBeforeRequestRead() {\n     }\n \n     @Test\n-    public void flagResponseBeforeRequestRead() {\n+    void flagResponseBeforeRequestRead() {\n         final ClientResponseWriter responseWriter = new ClientResponseWriter(new BasicRequestCompleteHandler());\n         final EmbeddedChannel channel = new EmbeddedChannel();\n \n@@ -45,7 +45,7 @@ public void flagResponseBeforeRequestRead() {\n     }\n \n     @Test\n-    public void allowExtensionForPremptingResponse() {\n+    void allowExtensionForPremptingResponse() {\n \n         final ZuulStatusCategory customStatus = ZuulStatusCategory.SUCCESS_LOCAL_NO_ROUTE;\n         final ClientResponseWriter responseWriter = new ClientResponseWriter(new BasicRequestCompleteHandler()) {",
      "parent_sha": "680daa8c255985f84c5355bb3b5abce6129a7c41"
    }
  },
  {
    "oid": "512fcc4bbaf897e735e1c9faf1d663b61eb31697",
    "message": "core: minor formatting changes for bootstrap (#1102)",
    "date": "2021-09-01T18:43:18Z",
    "url": "https://github.com/Netflix/zuul/commit/512fcc4bbaf897e735e1c9faf1d663b61eb31697",
    "details": {
      "sha": "b1a995320158fc0cdff153be2e96d92729cbdeaa",
      "filename": "zuul-sample/src/main/java/com/netflix/zuul/sample/Bootstrap.java",
      "status": "modified",
      "additions": 15,
      "deletions": 8,
      "changes": 23,
      "blob_url": "https://github.com/Netflix/zuul/blob/512fcc4bbaf897e735e1c9faf1d663b61eb31697/zuul-sample%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fsample%2FBootstrap.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/512fcc4bbaf897e735e1c9faf1d663b61eb31697/zuul-sample%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fsample%2FBootstrap.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-sample%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fsample%2FBootstrap.java?ref=512fcc4bbaf897e735e1c9faf1d663b61eb31697",
      "patch": "@@ -20,6 +20,9 @@\n import com.google.inject.Injector;\n import com.netflix.zuul.netty.server.BaseServerStartup;\n import com.netflix.zuul.netty.server.Server;\n+import java.util.concurrent.TimeUnit;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * Bootstrap\n@@ -29,13 +32,15 @@\n  */\n public class Bootstrap {\n \n+    private static final Logger logger = LoggerFactory.getLogger(Bootstrap.class);\n+\n     public static void main(String[] args) {\n         new Bootstrap().start();\n     }\n \n     public void start() {\n-        System.out.println(\"Zuul Sample: starting up.\");\n-        long startTime = System.currentTimeMillis();\n+        long startNanos = System.nanoTime();\n+        logger.info(\"Zuul Sample: starting up.\");\n         int exitCode = 0;\n \n         Server server = null;\n@@ -45,13 +50,13 @@ public void start() {\n             BaseServerStartup serverStartup = injector.getInstance(BaseServerStartup.class);\n             server = serverStartup.server();\n \n-            long startupDuration = System.currentTimeMillis() - startTime;\n-            System.out.println(\"Zuul Sample: finished startup. Duration = \" + startupDuration + \" ms\");\n-\n             server.start();\n+            long startupDuration = System.nanoTime() - startNanos;\n+            logger.info(\n+                    \"Zuul Sample: finished startup. Duration = {}ms\", TimeUnit.NANOSECONDS.toMillis(startupDuration));\n             server.awaitTermination();\n-        }\n-        catch (Throwable t) {\n+        } catch (Throwable t) {\n+            // Don't use logger here, as we may be shutting down the JVM and the logs won't be printed.\n             t.printStackTrace();\n             System.err.println(\"###############\");\n             System.err.println(\"Zuul Sample: initialization failed. Forcing shutdown now.\");\n@@ -60,7 +65,9 @@ public void start() {\n         }\n         finally {\n             // server shutdown\n-            if (server != null) server.stop();\n+            if (server != null) {\n+                server.stop();\n+            }\n \n             System.exit(exitCode);\n         }",
      "parent_sha": "44c0765c4329ca4ff00f34e6c5555c2b911eb3fc"
    }
  },
  {
    "oid": "77b7d48945beb81828a6eea0e572f2c14172f3a0",
    "message": "Pass the correct promise from parent channel to close with parent channel",
    "date": "2019-02-22T20:40:50Z",
    "url": "https://github.com/Netflix/zuul/commit/77b7d48945beb81828a6eea0e572f2c14172f3a0",
    "details": {
      "sha": "dfb40baa40dff2c293dbdb0e7481c395dd1fc6da",
      "filename": "zuul-core/src/main/java/com/netflix/netty/common/Http2ConnectionCloseHandler.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/Netflix/zuul/blob/77b7d48945beb81828a6eea0e572f2c14172f3a0/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fnetty%2Fcommon%2FHttp2ConnectionCloseHandler.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/77b7d48945beb81828a6eea0e572f2c14172f3a0/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fnetty%2Fcommon%2FHttp2ConnectionCloseHandler.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fnetty%2Fcommon%2FHttp2ConnectionCloseHandler.java?ref=77b7d48945beb81828a6eea0e572f2c14172f3a0",
      "patch": "@@ -110,7 +110,8 @@ public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exce\n         // Close according to the specified close type.\n         Channel parent = parentChannel(ctx);\n         ConnectionCloseType type = ConnectionCloseType.fromChannel(parent);\n-        closeChannel(ctx, parent, type, promise);\n+        ChannelPromise parentPromise = parent.newPromise();\n+        closeChannel(ctx, parent, type, parentPromise);\n \n         // Don't pass this event further down the pipeline.\n     }",
      "parent_sha": "5d5827e4d9b590849448e6907530fc59cacbcbdc"
    }
  },
  {
    "oid": "d6513af1c13ea5f122eccfb2629bce0b677ecdd9",
    "message": "JsonUtility logging cleanup (#1178)",
    "date": "2022-01-27T03:01:32Z",
    "url": "https://github.com/Netflix/zuul/commit/d6513af1c13ea5f122eccfb2629bce0b677ecdd9",
    "details": {
      "sha": "287268364f6e25d92ae598b708af573b00b3fb11",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/util/JsonUtility.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/zuul/blob/d6513af1c13ea5f122eccfb2629bce0b677ecdd9/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Futil%2FJsonUtility.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/d6513af1c13ea5f122eccfb2629bce0b677ecdd9/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Futil%2FJsonUtility.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Futil%2FJsonUtility.java?ref=d6513af1c13ea5f122eccfb2629bce0b677ecdd9",
      "patch": "@@ -73,7 +73,7 @@ public static String jsonFromMap(Map<String, Object> jsonData) {\n \n             json.endGroup();\n \n-            logger.debug(\"created json from map => \" + json.toString());\n+            logger.debug(\"created json from map => {}\", json);\n             return json.toString();\n         } catch (Exception e) {\n             logger.error(\"Could not create JSON from Map. \", e);\n@@ -148,4 +148,4 @@ public static interface JsonCapableObject {\n         public Map<String, Object> jsonMap();\n \n     }\n-}\n\\ No newline at end of file\n+}",
      "parent_sha": "7e8b022063b59d34e080082e0b44af299df9bcf2"
    }
  },
  {
    "oid": "4019f6dafc3afe6e8770abfb8d17c469f664db58",
    "message": "Don't allow null values into Headers. If attempted, assume means to remove any existing header of that name.",
    "date": "2015-07-18T00:09:07Z",
    "url": "https://github.com/Netflix/zuul/commit/4019f6dafc3afe6e8770abfb8d17c469f664db58",
    "details": {
      "sha": "ade9d1da8a93be9ec9779d735809c66165f3ceec",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/message/Headers.java",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/Netflix/zuul/blob/4019f6dafc3afe6e8770abfb8d17c469f664db58/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2FHeaders.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/4019f6dafc3afe6e8770abfb8d17c469f664db58/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2FHeaders.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmessage%2FHeaders.java?ref=4019f6dafc3afe6e8770abfb8d17c469f664db58",
      "patch": "@@ -93,14 +93,18 @@ public List<String> get(String name)\n     /**\n      * Replace any/all entries with this key, with this single entry.\n      *\n+     * If value is null, then not added, but any existing header of same name is removed.\n+     *\n      * @param name\n      * @param value\n      */\n     public void set(String name, String value)\n     {\n         String lc_name = name.toLowerCase();\n         delegate.removeAll(lc_name);\n-        delegate.put(lc_name,  value);\n+        if (value != null) {\n+            delegate.put(lc_name, value);\n+        }\n     }\n \n     public boolean setIfAbsent(String name, String value)",
      "parent_sha": "220eb501a8953f1001dc431c0703034e2319e7d3"
    }
  },
  {
    "oid": "212780325125ea7640263de1c2cddceffe7cb3a7",
    "message": "Revert \"enable IP_TRANSPARENT on epoll channel bind\"\n\nThis reverts commit 80adf7e911f5aa5b2ffb8c5e576e9ea14b5ca3bf.",
    "date": "2023-10-03T00:19:30Z",
    "url": "https://github.com/Netflix/zuul/commit/212780325125ea7640263de1c2cddceffe7cb3a7",
    "details": {
      "sha": "675db44d065b5115f1e737819b7b490afed47d91",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/server/Server.java",
      "status": "modified",
      "additions": 22,
      "deletions": 27,
      "changes": 49,
      "blob_url": "https://github.com/Netflix/zuul/blob/212780325125ea7640263de1c2cddceffe7cb3a7/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FServer.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/212780325125ea7640263de1c2cddceffe7cb3a7/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FServer.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FServer.java?ref=212780325125ea7640263de1c2cddceffe7cb3a7",
      "patch": "@@ -16,7 +16,6 @@\n \n package com.netflix.zuul.netty.server;\n \n-import static com.google.common.base.Preconditions.checkNotNull;\n import com.google.common.annotations.VisibleForTesting;\n import com.netflix.appinfo.InstanceInfo;\n import com.netflix.config.DynamicBooleanProperty;\n@@ -64,6 +63,9 @@\n import io.netty.util.concurrent.EventExecutor;\n import io.netty.util.concurrent.EventExecutorChooserFactory;\n import io.netty.util.concurrent.ThreadPerTaskExecutor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n import java.net.InetSocketAddress;\n import java.nio.channels.spi.SelectorProvider;\n import java.util.ArrayList;\n@@ -78,19 +80,21 @@\n import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicReference;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n \n /**\n+ *\n  * NOTE: Shout-out to <a href=\"https://github.com/adamfisk/LittleProxy\">LittleProxy</a> which was great as a reference.\n- * <p>\n- * User: michaels Date: 11/8/14 Time: 8:39 PM\n+ *\n+ * User: michaels\n+ * Date: 11/8/14\n+ * Time: 8:39 PM\n  */\n public class Server {\n-\n     /**\n-     * This field is effectively a noop, as Epoll is enabled automatically if available.   This can be disabled by using\n-     * the {@link #FORCE_NIO} property.\n+     * This field is effectively a noop, as Epoll is enabled automatically if available.   This can be disabled by\n+     * using the {@link #FORCE_NIO} property.\n      */\n     @Deprecated\n     public static final DynamicBooleanProperty USE_EPOLL =\n@@ -137,9 +141,9 @@ public class Server {\n     public static final AtomicReference<Class<? extends Channel>> defaultOutboundChannelType = new AtomicReference<>();\n \n     /**\n-     * Use\n-     * {@link #Server(Registry, ServerStatusManager, Map, ClientConnectionsShutdown, EventLoopGroupMetrics,\n-     * EventLoopConfig)} instead.\n+     * Use {@link #Server(Registry, ServerStatusManager, Map, ClientConnectionsShutdown, EventLoopGroupMetrics,\n+     * EventLoopConfig)}\n+     * instead.\n      */\n     @SuppressWarnings(\"rawtypes\")\n     @Deprecated\n@@ -157,9 +161,9 @@ public Server(\n     }\n \n     /**\n-     * Use\n-     * {@link #Server(Registry, ServerStatusManager, Map, ClientConnectionsShutdown, EventLoopGroupMetrics,\n-     * EventLoopConfig)} instead.\n+     * Use {@link #Server(Registry, ServerStatusManager, Map, ClientConnectionsShutdown, EventLoopGroupMetrics,\n+     * EventLoopConfig)}\n+     * instead.\n      */\n     @SuppressWarnings({\"unchecked\", \"rawtypes\"\n     }) // Channel init map has the wrong generics and we can't fix without api breakage.\n@@ -294,11 +298,6 @@ private ChannelFuture setupServerBootstrap(\n         serverBootstrap.childOption(ChannelOption.TCP_NODELAY, true);\n         serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, true);\n \n-        if (epollIsAvailable()) {\n-            LOG.info(\"******* Enabling IP_TRANSPARENT for epoll channel bound to {}\", listenAddress);\n-            serverBootstrap.childOption(EpollChannelOption.IP_TRANSPARENT, true);\n-        }\n-\n         // Apply transport specific socket options.\n         for (Map.Entry<ChannelOption<?>, ?> optionEntry : serverGroup.transportChannelOptions.entrySet()) {\n             serverBootstrap = serverBootstrap.option((ChannelOption) optionEntry.getKey(), optionEntry.getValue());\n@@ -330,18 +329,14 @@ private ChannelFuture setupServerBootstrap(\n     /**\n      * Override for metrics or informational purposes\n      *\n-     * @param clientToProxyBossPool   - acceptor pool\n+     * @param clientToProxyBossPool - acceptor pool\n      * @param clientToProxyWorkerPool - worker pool\n      */\n     public void postEventLoopCreationHook(\n-            EventLoopGroup clientToProxyBossPool, EventLoopGroup clientToProxyWorkerPool) {\n-    }\n+            EventLoopGroup clientToProxyBossPool, EventLoopGroup clientToProxyWorkerPool) {}\n \n     private final class ServerGroup {\n-\n-        /**\n-         * A name for this ServerGroup to use in naming threads.\n-         */\n+        /** A name for this ServerGroup to use in naming threads. */\n         private final String name;\n \n         private final int acceptorThreads;\n@@ -548,4 +543,4 @@ private static boolean kqueueIsAvailable() {\n         }\n         return available;\n     }\n-}\n+}\n\\ No newline at end of file",
      "parent_sha": "1d4541fa27eaa5cd116eaf26efd70cee76b4c30d"
    }
  },
  {
    "oid": "0c48406691ba164b7bcefbc0f4a16d508a5444ae",
    "message": "Print stack trace only when the exception is a non i/o exception",
    "date": "2018-07-13T21:55:56Z",
    "url": "https://github.com/Netflix/zuul/commit/0c48406691ba164b7bcefbc0f4a16d508a5444ae",
    "details": {
      "sha": "df3fa77f7da395055e744b2c49dd55301ca4561f",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/filter/ZuulFilterChainHandler.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/zuul/blob/0c48406691ba164b7bcefbc0f4a16d508a5444ae/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ffilter%2FZuulFilterChainHandler.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/0c48406691ba164b7bcefbc0f4a16d508a5444ae/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ffilter%2FZuulFilterChainHandler.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Ffilter%2FZuulFilterChainHandler.java?ref=0c48406691ba164b7bcefbc0f4a16d508a5444ae",
      "patch": "@@ -147,8 +147,8 @@ protected void fireEndpointFinish(final boolean error) {\n \n     @Override\n     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n-        LOG.error(\"zuul filter chain handler caught exception. cause=\" + String.valueOf(cause), cause);\n         if (zuulRequest != null && !isClientChannelClosed(cause)) {\n+            LOG.error(\"zuul filter chain handler caught exception. cause=\" + String.valueOf(cause), cause);\n             final SessionContext zuulCtx = zuulRequest.getContext();\n             zuulCtx.setError(cause);\n             zuulCtx.setShouldSendErrorResponse(true);",
      "parent_sha": "55a1da806129aff677c479f0f0841912eab029f5"
    }
  },
  {
    "oid": "ae0cf72e022baa486db4d0f02b839326ca716221",
    "message": "Use ReferenceCountUtil.release",
    "date": "2022-08-11T23:17:58Z",
    "url": "https://github.com/Netflix/zuul/commit/ae0cf72e022baa486db4d0f02b839326ca716221",
    "details": {
      "sha": "3c3fddb0e5f0144377eba8becebb598139896125",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/server/push/PushMessageSender.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/Netflix/zuul/blob/ae0cf72e022baa486db4d0f02b839326ca716221/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2Fpush%2FPushMessageSender.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/ae0cf72e022baa486db4d0f02b839326ca716221/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2Fpush%2FPushMessageSender.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2Fpush%2FPushMessageSender.java?ref=ae0cf72e022baa486db4d0f02b839326ca716221",
      "patch": "@@ -38,6 +38,7 @@\n import io.netty.handler.codec.http.HttpMethod;\n import io.netty.handler.codec.http.HttpResponseStatus;\n import io.netty.handler.codec.http.HttpUtil;\n+import io.netty.util.ReferenceCountUtil;\n \n import javax.inject.Inject;\n import javax.inject.Singleton;\n@@ -151,7 +152,7 @@ protected void channelRead0(final ChannelHandlerContext ctx, final FullHttpReque\n                 sendHttpResponse(ctx, request, NO_CONTENT, userAuth);\n                 // Because we are not passing the body to the pushConn (who would normally handle destroying),\n                 // we need to release it here.\n-                body.release();\n+                ReferenceCountUtil.release(body);\n                 return;\n             }\n ",
      "parent_sha": "c8ecf977744eff6fdf378ec2c7f147c1b235d3eb"
    }
  },
  {
    "oid": "195d0d6805a65c1c323ebca638d201734ff8f4c3",
    "message": "- Catching SocketTimeoutException when copying request body inputstream and treating as empty body, with a log statement. This is to more gracefully handle the case of truncated post bodies when using tomcat APR connector (which fails differently to BIO connector).",
    "date": "2015-04-22T05:16:07Z",
    "url": "https://github.com/Netflix/zuul/commit/195d0d6805a65c1c323ebca638d201734ff8f4c3",
    "details": {
      "sha": "cf52afbe5cdda4f378c4cf7d20795704dac9b91d",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/http/HttpServletRequestWrapper.java",
      "status": "modified",
      "additions": 14,
      "deletions": 4,
      "changes": 18,
      "blob_url": "https://github.com/Netflix/zuul/blob/195d0d6805a65c1c323ebca638d201734ff8f4c3/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fhttp%2FHttpServletRequestWrapper.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/195d0d6805a65c1c323ebca638d201734ff8f4c3/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fhttp%2FHttpServletRequestWrapper.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fhttp%2FHttpServletRequestWrapper.java?ref=195d0d6805a65c1c323ebca638d201734ff8f4c3",
      "patch": "@@ -33,6 +33,7 @@\n import javax.servlet.http.HttpServletRequest;\n import javax.servlet.http.HttpSession;\n import java.io.*;\n+import java.net.SocketTimeoutException;\n import java.net.URLDecoder;\n import java.security.Principal;\n import java.util.*;\n@@ -60,8 +61,8 @@ public class HttpServletRequestWrapper implements HttpServletRequest {\n     protected static final Logger LOG = LoggerFactory.getLogger(HttpServletRequestWrapper.class);\n \n     private HttpServletRequest req;\n-    private byte[] contentData;\n-    private HashMap<String, String[]> parameters;\n+    private byte[] contentData = null;\n+    private HashMap<String, String[]> parameters = null;\n \n     public HttpServletRequestWrapper() {\n         //a trick for Groovy\n@@ -148,8 +149,17 @@ private void parseRequest() throws IOException {\n \n             // Read the request body inputstream into a byte array.\n             ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-            IOUtils.copy(req.getInputStream(), baos);\n-            contentData = baos.toByteArray();\n+            try {\n+                IOUtils.copy(req.getInputStream(), baos);\n+                contentData = baos.toByteArray();\n+            } catch (SocketTimeoutException e) {\n+                // This can happen if the request body is smaller than the size specified in the\n+                // Content-Length header, and using tomcat APR connector.\n+                LOG.error(\"SocketTimeoutException reading request body from inputstream. error=\" + String.valueOf(e.getMessage()));\n+                if (contentData == null) {\n+                    contentData = new byte[0];\n+                }\n+            }\n \n             try {\n                 LOG.debug(\"Length of contentData byte array = \" + contentData.length);",
      "parent_sha": "92242957040c00ac84e312363cd9f55727d1ec75"
    }
  },
  {
    "oid": "c0a87e17bf0d9536fb8572b49667a619e15a6119",
    "message": "change filter type tag name",
    "date": "2014-03-27T20:01:20Z",
    "url": "https://github.com/Netflix/zuul/commit/c0a87e17bf0d9536fb8572b49667a619e15a6119",
    "details": {
      "sha": "761074512476146df393a613e69aaae843722283",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/FilterProcessor.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/Netflix/zuul/blob/c0a87e17bf0d9536fb8572b49667a619e15a6119/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/c0a87e17bf0d9536fb8572b49667a619e15a6119/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java?ref=c0a87e17bf0d9536fb8572b49667a619e15a6119",
      "patch": "@@ -191,10 +191,10 @@ public Object processZuulFilter(ZuulFilter filter) throws ZuulException {\n                     t = result.getException();\n                     ctx.addFilterExecutionSummary(filterName, ExecutionStatus.FAILED.name(), execTime);\n                     \n-                    DynamicCounter.increment(metricPrefix + filterName, \"status\",\"fail\", \"type\",filter.filterType());\n+                    DynamicCounter.increment(metricPrefix + filterName, \"status\",\"fail\", \"filtertype\",filter.filterType());\n                     break;\n                 case SUCCESS:\n-                \tDynamicCounter.increment(metricPrefix + filterName, \"status\",\"success\", \"type\", filter.filterType());\n+                \tDynamicCounter.increment(metricPrefix + filterName, \"status\",\"success\", \"filtertype\", filter.filterType());\n                     o = result.getResult();\n                     ctx.addFilterExecutionSummary(filterName, ExecutionStatus.SUCCESS.name(), execTime);\n                     if (bDebug) {\n@@ -203,7 +203,7 @@ public Object processZuulFilter(ZuulFilter filter) throws ZuulException {\n                     }\n                     break;\n                 default:\n-                \tDynamicCounter.increment(metricPrefix + filterName, \"status\", \"unknown\", \"type\", filter.filterType());\n+                \tDynamicCounter.increment(metricPrefix + filterName, \"status\", \"skip\", \"filtertype\", filter.filterType());\n                     break;\n             }\n             \n@@ -213,7 +213,7 @@ public Object processZuulFilter(ZuulFilter filter) throws ZuulException {\n             if (bDebug) {\n                 Debug.addRoutingDebug(\"Running Filter failed \" + filterName + \" type:\" + filter.filterType() + \" order:\" + filter.filterOrder() + \" \" + e.getMessage());\n             }\n-            DynamicCounter.increment(metricPrefix + filterName, \"status\", \"fail\", \"type\", filter.filterType());\n+            DynamicCounter.increment(metricPrefix + filterName, \"status\", \"fail\", \"filtertype\", filter.filterType());\n             if (e instanceof ZuulException) {\n                 throw (ZuulException) e;\n             } else {",
      "parent_sha": "93c2bb8ace3647e07fdab2fdd064b9acc5039162"
    }
  },
  {
    "oid": "edf4194fe0806cf30082d1f68fdfbb728e028d97",
    "message": "core: record initial channel accept time for use with child initializers",
    "date": "2020-08-12T17:23:28Z",
    "url": "https://github.com/Netflix/zuul/commit/edf4194fe0806cf30082d1f68fdfbb728e028d97",
    "details": {
      "sha": "c76b74375d27e8efc13e08bc204fcf00b32eb786",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/server/Server.java",
      "status": "modified",
      "additions": 23,
      "deletions": 2,
      "changes": 25,
      "blob_url": "https://github.com/Netflix/zuul/blob/edf4194fe0806cf30082d1f68fdfbb728e028d97/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FServer.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/edf4194fe0806cf30082d1f68fdfbb728e028d97/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FServer.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FServer.java?ref=edf4194fe0806cf30082d1f68fdfbb728e028d97",
      "patch": "@@ -26,6 +26,9 @@\n import io.netty.bootstrap.ServerBootstrap;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n import io.netty.channel.ChannelInitializer;\n import io.netty.channel.ChannelOption;\n import io.netty.channel.DefaultSelectStrategyFactory;\n@@ -43,12 +46,14 @@\n import io.netty.channel.nio.NioEventLoopGroup;\n import io.netty.channel.socket.nio.NioServerSocketChannel;\n import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.util.AttributeKey;\n import io.netty.util.concurrent.DefaultEventExecutorChooserFactory;\n import io.netty.util.concurrent.EventExecutor;\n import io.netty.util.concurrent.EventExecutorChooserFactory;\n import io.netty.util.concurrent.ThreadPerTaskExecutor;\n import java.util.LinkedHashMap;\n import java.util.LinkedHashSet;\n+import java.util.Objects;\n import java.util.Set;\n import java.util.concurrent.atomic.AtomicReference;\n import org.slf4j.Logger;\n@@ -155,8 +160,7 @@ public Server(ServerStatusManager serverStatusManager,\n         this.eventLoopGroupMetrics = checkNotNull(eventLoopGroupMetrics, \"eventLoopGroupMetrics\");\n     }\n \n-    public void stop()\n-    {\n+    public void stop() {\n         LOG.info(\"Shutting down Zuul.\");\n         serverGroup.stop();\n \n@@ -248,6 +252,7 @@ private ChannelFuture setupServerBootstrap(\n             serverBootstrap = serverBootstrap.option(optionEntry.getKey(), optionEntry.getValue());\n         }\n \n+        serverBootstrap.handler(new NewConnHandler());\n         serverBootstrap.childHandler(channelInitializer);\n         serverBootstrap.validate();\n \n@@ -437,6 +442,22 @@ synchronized private void stop()\n         }\n     }\n \n+    public static final AttributeKey<Map<String, Long>> CONN_TIMING = AttributeKey.newInstance(\"zuulconntiming\");\n+    public static final String CONN_ACCEPT = \"ACCEPT\";\n+\n+    private static final class NewConnHandler extends ChannelInboundHandlerAdapter {\n+\n+        @Override\n+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+            Long now = System.nanoTime();\n+            Map<String, Long> timings = new LinkedHashMap<>();\n+            timings.put(CONN_ACCEPT, now);\n+            final Channel child = (Channel) msg;\n+            child.attr(CONN_TIMING).set(timings);\n+            super.channelRead(ctx, msg);\n+        }\n+    }\n+\n     static Map<SocketAddress, ChannelInitializer<?>> convertPortMap(\n             Map<Integer, ChannelInitializer<?>> portsToChannelInitializers) {\n         Map<SocketAddress, ChannelInitializer<?>> addrsToInitializers =",
      "parent_sha": "b67d383b48427f8ccbc116f4d11253920d9870eb"
    }
  },
  {
    "oid": "01b3f70c0e3a0252882160d120a6a6d917f21e7b",
    "message": "If a channel is closed by client or idle time-outs before an ssl handshake completes, then don't treat as a handshake failure",
    "date": "2018-02-10T03:03:38Z",
    "url": "https://github.com/Netflix/zuul/commit/01b3f70c0e3a0252882160d120a6a6d917f21e7b",
    "details": {
      "sha": "433600b9d6ab5fbf3686f674accdbb822584c70c",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/server/ssl/SslHandshakeInfoHandler.java",
      "status": "modified",
      "additions": 25,
      "deletions": 10,
      "changes": 35,
      "blob_url": "https://github.com/Netflix/zuul/blob/01b3f70c0e3a0252882160d120a6a6d917f21e7b/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2Fssl%2FSslHandshakeInfoHandler.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/01b3f70c0e3a0252882160d120a6a6d917f21e7b/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2Fssl%2FSslHandshakeInfoHandler.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2Fssl%2FSslHandshakeInfoHandler.java?ref=01b3f70c0e3a0252882160d120a6a6d917f21e7b",
      "patch": "@@ -100,17 +100,32 @@ else if (LOG.isInfoEnabled()) {\n                 else {\n                     String clientIP = ctx.channel().attr(SourceAddressChannelHandler.ATTR_SOURCE_ADDRESS).get();\n                     Throwable cause = sslEvent.cause();\n-                    String msg = \"Unsuccessful SSL Handshake: \" + String.valueOf(sslEvent)\n-                            + \", client_ip = \" + String.valueOf(clientIP)\n-                            + \", channel_info = \" + ChannelUtils.channelInfoForLogging(ctx.channel())\n-                            + \", error = \" + String.valueOf(cause);\n-                    if (cause != null && cause instanceof ClosedChannelException) {\n-                        LOG.warn(msg);\n-                    } else {\n-                        LOG.warn(msg, cause);\n-                    }\n-                    incrementCounters(sslEvent, null);\n \n+                    PassportState passportState = CurrentPassport.fromChannel(ctx.channel()).getState();\n+                    if (cause instanceof ClosedChannelException &&\n+                            (PassportState.SERVER_CH_INACTIVE.equals(passportState) || PassportState.SERVER_CH_IDLE_TIMEOUT.equals(passportState))) {\n+                        // Either client closed the connection without/before having completed a handshake, or\n+                        // the connection idle timed-out before handshake.\n+                        // NOTE: we were seeing a lot of these in prod and can repro by just telnetting to port and then closing terminal\n+                        // without sending anything.\n+                        // So don't treat these as SSL handshake failures.\n+                        LOG.info(\"Client closed connection or it idle timed-out without doing an ssl handshake. \"\n+                                + \", client_ip = \" + String.valueOf(clientIP)\n+                                + \", channel_info = \" + ChannelUtils.channelInfoForLogging(ctx.channel()));\n+                    }\n+                    else {\n+                        String msg = \"Unsuccessful SSL Handshake: \" + String.valueOf(sslEvent)\n+                                + \", client_ip = \" + String.valueOf(clientIP)\n+                                + \", channel_info = \" + ChannelUtils.channelInfoForLogging(ctx.channel())\n+                                + \", error = \" + String.valueOf(cause);\n+                        if (cause != null && cause instanceof ClosedChannelException) {\n+                            LOG.warn(msg);\n+                        }\n+                        else {\n+                            LOG.warn(msg, cause);\n+                        }\n+                        incrementCounters(sslEvent, null);\n+                    }\n \n                     // ### TESTING\n ",
      "parent_sha": "3c04b4bff72200c6f88efc45037a1f4d66d8e13b"
    }
  },
  {
    "oid": "494d79fa40ca140fbbd92f2c22cec8ae32dc5f0f",
    "message": "Check sentinel value when no origin servers resolved",
    "date": "2021-03-06T04:06:04Z",
    "url": "https://github.com/Netflix/zuul/commit/494d79fa40ca140fbbd92f2c22cec8ae32dc5f0f",
    "details": {
      "sha": "952776a0e71c628e1baffc5c8057b0b69382ce75",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/filters/endpoint/ProxyEndpoint.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/Netflix/zuul/blob/494d79fa40ca140fbbd92f2c22cec8ae32dc5f0f/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/494d79fa40ca140fbbd92f2c22cec8ae32dc5f0f/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java?ref=494d79fa40ca140fbbd92f2c22cec8ae32dc5f0f",
      "patch": "@@ -468,8 +468,8 @@ public void operationComplete(final Future<PooledConnection> connectResult) {\n                 Integer readTimeout = null;\n                 DiscoveryResult server = chosenServer.get();\n \n-                // The chosen server would be null if the loadbalancer found no available servers.\n-                if (server != null) {\n+                // The discovery result lookup is EMPTY if the loadbalancer resolves no available servers.\n+                if (server != DiscoveryResult.EMPTY) {\n                     if (currentRequestStat != null) {\n                         currentRequestStat.server(server);\n                     }\n@@ -738,7 +738,7 @@ private void processErrorFromOrigin(final Throwable ex, final Channel origCh) {\n             postErrorProcessing(ex, zuulCtx, err, chosenServer.get(), attemptNum);\n \n             final ClientException niwsEx = new ClientException(ClientException.ErrorType.valueOf(err.getClientErrorType().name()));\n-            if (chosenServer.get() != null) {\n+            if (chosenServer.get() != DiscoveryResult.EMPTY) {\n                 origin.onRequestExceptionWithServer(zuulRequest, chosenServer.get(), attemptNum, niwsEx);\n             }\n ",
      "parent_sha": "1b4257c81006b6fa1a0dc17ad691cf5a590bbc67"
    }
  },
  {
    "oid": "083e60049a06ebe413a8f13522e65ecb406db62e",
    "message": "ServerTest verifies the number of NioSocketChannel's (#1194)",
    "date": "2022-02-08T01:17:28Z",
    "url": "https://github.com/Netflix/zuul/commit/083e60049a06ebe413a8f13522e65ecb406db62e",
    "details": {
      "sha": "089773a4e8e771073da48baa96de029b7d5797b0",
      "filename": "zuul-core/src/test/java/com/netflix/zuul/netty/server/ServerTest.java",
      "status": "modified",
      "additions": 28,
      "deletions": 5,
      "changes": 33,
      "blob_url": "https://github.com/Netflix/zuul/blob/083e60049a06ebe413a8f13522e65ecb406db62e/zuul-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FServerTest.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/083e60049a06ebe413a8f13522e65ecb406db62e/zuul-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FServerTest.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FServerTest.java?ref=083e60049a06ebe413a8f13522e65ecb406db62e",
      "patch": "@@ -16,6 +16,8 @@\n \n package com.netflix.zuul.netty.server;\n \n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.awaitility.Awaitility.await;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertNotEquals;\n import static org.junit.Assert.assertTrue;\n@@ -30,17 +32,15 @@\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelInitializer;\n import io.netty.channel.group.DefaultChannelGroup;\n-import io.netty.channel.socket.nio.NioServerSocketChannel;\n import io.netty.channel.socket.nio.NioSocketChannel;\n import io.netty.util.concurrent.GlobalEventExecutor;\n \n-import java.io.IOException;\n import java.io.OutputStream;\n-import java.net.InetAddress;\n import java.net.InetSocketAddress;\n import java.net.Socket;\n-import java.net.SocketAddress;\n import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n@@ -50,12 +50,15 @@\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * Tests for {@link Server}.\n  */\n @RunWith(JUnit4.class)\n public class ServerTest {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ServerTest.class);\n \n     @Before\n     public void beforeTest() {\n@@ -68,9 +71,20 @@ public void beforeTest() {\n     public void getListeningSockets() throws Exception {\n         ServerStatusManager ssm = mock(ServerStatusManager.class);\n         Map<NamedSocketAddress, ChannelInitializer<?>> initializers = new HashMap<>();\n+        final List<NioSocketChannel> nioChannels = Collections.synchronizedList(new ArrayList<NioSocketChannel>());\n         ChannelInitializer<Channel> init = new ChannelInitializer<Channel>() {\n             @Override\n-            protected void initChannel(Channel ch) {}\n+            protected void initChannel(final Channel ch) {\n+                LOGGER.info(\"Channel: \"\n+                        + ch.getClass().getName()\n+                        + \", isActive=\"\n+                        + ch.isActive()\n+                        + \", isOpen=\"\n+                        + ch.isOpen());\n+                if (ch instanceof NioSocketChannel) {\n+                    nioChannels.add((NioSocketChannel)ch);\n+                }\n+            }\n         };\n         initializers.put(new NamedSocketAddress(\"test\", new InetSocketAddress(0)), init);\n         // The port to channel map keys on the port, post bind. This should be unique even if InetAddress is same\n@@ -104,8 +118,17 @@ public int acceptorCount() {\n             checkConnection(port);\n         }\n \n+        await()\n+                .atMost(1, SECONDS)\n+                .until(() -> nioChannels.size() == 2);\n+\n         s.stop();\n \n+        assertEquals(2, nioChannels.size());\n+\n+        for (NioSocketChannel ch : nioChannels) {\n+            assertTrue(\"isShutdown\", ch.isShutdown());\n+        }\n     }\n \n     private static void checkConnection(final int port) {",
      "parent_sha": "318b7805857d2f6390c81bb7b5f9da329a673a6c"
    }
  },
  {
    "oid": "6215bf99b5bf0ed50aca7a33228471984af0cb80",
    "message": "zuul-core: use Duration for ReadTimeouts",
    "date": "2021-01-11T23:37:20Z",
    "url": "https://github.com/Netflix/zuul/commit/6215bf99b5bf0ed50aca7a33228471984af0cb80",
    "details": {
      "sha": "83fb75068541386e8f463fa29c92156088e0ac9f",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/filters/endpoint/ProxyEndpoint.java",
      "status": "modified",
      "additions": 40,
      "deletions": 24,
      "changes": 64,
      "blob_url": "https://github.com/Netflix/zuul/blob/6215bf99b5bf0ed50aca7a33228471984af0cb80/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/6215bf99b5bf0ed50aca7a33228471984af0cb80/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java?ref=6215bf99b5bf0ed50aca7a33228471984af0cb80",
      "patch": "@@ -36,7 +36,7 @@\n import com.netflix.client.config.IClientConfig;\n import com.netflix.client.config.IClientConfigKey;\n import com.netflix.client.config.IClientConfigKey.Keys;\n-import com.netflix.config.CachedDynamicIntProperty;\n+import com.netflix.config.CachedDynamicLongProperty;\n import com.netflix.config.DynamicBooleanProperty;\n import com.netflix.config.DynamicIntegerSetProperty;\n import com.netflix.loadbalancer.Server;\n@@ -99,6 +99,7 @@\n import java.io.UnsupportedEncodingException;\n import java.net.InetAddress;\n import java.net.URLDecoder;\n+import java.time.Duration;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n@@ -153,7 +154,8 @@ public class ProxyEndpoint extends SyncZuulFilterAdapter<HttpRequestMessage, Htt\n     private static final DynamicBooleanProperty ENABLE_CACHING_PLAINTEXT_BODIES =\n             new DynamicBooleanProperty(\"zuul.cache.bodies.plaintext\", false);\n \n-    private static final CachedDynamicIntProperty MAX_OUTBOUND_READ_TIMEOUT = new CachedDynamicIntProperty(\"zuul.origin.readtimeout.max\", 90 * 1000);\n+    private static final CachedDynamicLongProperty MAX_OUTBOUND_READ_TIMEOUT_MS =\n+            new CachedDynamicLongProperty(\"zuul.origin.readtimeout.max\", Duration.ofSeconds(90).toMillis());\n \n     private static final Set<HeaderName> REQUEST_HEADERS_TO_REMOVE = Sets.newHashSet(HttpHeaderNames.CONNECTION, HttpHeaderNames.KEEP_ALIVE);\n     private static final Set<HeaderName> RESPONSE_HEADERS_TO_REMOVE = Sets.newHashSet(HttpHeaderNames.CONNECTION, HttpHeaderNames.KEEP_ALIVE);\n@@ -441,11 +443,9 @@ protected RequestStat createRequestStat() {\n         return basicRequestStat;\n     }\n \n-    private Integer setReadTimeoutOnContext(IClientConfig requestConfig, int attempt)\n-    {\n-        Integer readTimeout = getReadTimeout(requestConfig, attempt);\n-        requestConfig.set(ReadTimeout, readTimeout);\n-        return readTimeout;\n+    private void setReadTimeoutOnContext(IClientConfig requestConfig, int attempt) {\n+        Duration readTimeout = getReadTimeout(requestConfig, attempt);\n+        requestConfig.set(ReadTimeout, Math.toIntExact(readTimeout.toMillis()));\n     }\n \n     @Override\n@@ -532,30 +532,46 @@ private void onOriginConnectSucceeded(PooledConnection conn, int readTimeout) {\n         }\n     }\n \n-    protected Integer getReadTimeout(IClientConfig requestConfig, int attemptNum) {\n-        Integer originTimeout = parseReadTimeout(origin.getClientConfig().getProperty(IClientConfigKey.Keys.ReadTimeout, null));\n-        Integer requestTimeout = parseReadTimeout(requestConfig.getProperty(IClientConfigKey.Keys.ReadTimeout, null));\n+    /**\n+     * Derives the read timeout from the configuration.  This implementation prefers the longer of either the origin\n+     * timeout or the request timeout.\n+     *\n+     * @param requestConfig the config for the request.\n+     * @param attemptNum the attempt number, starting at 1.\n+     */\n+    protected Duration getReadTimeout(IClientConfig requestConfig, int attemptNum) {\n+        Long noTimeout = null;\n+        // TODO(carl-mastrangelo): getProperty is deprecated, and suggests using the typed overload `get`.   However,\n+        //  the value is parsed using parseReadTimeoutMs, which supports String, implying not all timeouts are Integer.\n+        //  Figure out where a string ReadTimeout is coming from and replace it.\n+        Long originTimeout =\n+                parseReadTimeoutMs(origin.getClientConfig().getProperty(IClientConfigKey.Keys.ReadTimeout, noTimeout));\n+        Long requestTimeout =\n+                parseReadTimeoutMs(requestConfig.getProperty(IClientConfigKey.Keys.ReadTimeout, noTimeout));\n \n         if (originTimeout == null && requestTimeout == null) {\n-            return MAX_OUTBOUND_READ_TIMEOUT.get();\n-        }\n-        else if (originTimeout == null || requestTimeout == null) {\n-            return originTimeout == null ? requestTimeout : originTimeout;\n-        }\n-        else {\n+            return Duration.ofMillis(MAX_OUTBOUND_READ_TIMEOUT_MS.get());\n+        } else if (originTimeout == null || requestTimeout == null) {\n+            return Duration.ofMillis(originTimeout == null ? requestTimeout : originTimeout);\n+        } else {\n             // return the greater of two timeouts\n-            return originTimeout > requestTimeout ? originTimeout : requestTimeout;\n+            return Duration.ofMillis(originTimeout > requestTimeout ? originTimeout : requestTimeout);\n         }\n     }\n \n-    private Integer parseReadTimeout(Object p) {\n+    /**\n+     * An Integer is expected as an input, but supports parsing Long and String.  Returns {@code null} if no type is\n+     * acceptable.\n+     */\n+    @Nullable\n+    private Long parseReadTimeoutMs(Object p) {\n         if (p instanceof String && !Strings.isNullOrEmpty((String) p)) {\n-            return Integer.valueOf((String)p);\n-        }\n-        else if (p instanceof Integer) {\n-            return (Integer) p;\n-        }\n-        else {\n+            return Long.valueOf((String)p);\n+        } else if (p instanceof Long) {\n+            return (Long) p;\n+        } else if (p instanceof Integer) {\n+            return Long.valueOf((Integer) p);\n+        } else {\n             return null;\n         }\n     }",
      "parent_sha": "06a8f2bc4b66cd938a80ddc227135a17411f4991"
    }
  },
  {
    "oid": "411aeffb7473ccd36a5c8c40ae4ad1c2ce8081c2",
    "message": "core: avoid noisy assert in tests when NoopGauge is being used.",
    "date": "2021-02-02T22:04:17Z",
    "url": "https://github.com/Netflix/zuul/commit/411aeffb7473ccd36a5c8c40ae4ad1c2ce8081c2",
    "details": {
      "sha": "e96508d0f90a88f6391d0497b6e299820008d113",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/monitoring/ConnCounter.java",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/Netflix/zuul/blob/411aeffb7473ccd36a5c8c40ae4ad1c2ce8081c2/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmonitoring%2FConnCounter.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/411aeffb7473ccd36a5c8c40ae4ad1c2ce8081c2/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmonitoring%2FConnCounter.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fmonitoring%2FConnCounter.java?ref=411aeffb7473ccd36a5c8c40ae4ad1c2ce8081c2",
      "patch": "@@ -130,7 +130,10 @@ public void decrement(String event) {\n             return;\n         }\n         synchronized (getLock(gauge.id())) {\n-            assert !Double.isNaN(gauge.value());\n+            // Noop gauges break this assertion in tests, but the type is package private.   Check to make sure\n+            // the gauge has a value, or by implementation cannot have a value.\n+            assert !Double.isNaN(gauge.value())\n+                    || gauge.getClass().getName().equals(\"com.netflix.spectator.api.NoopGauge\");\n             gauge.set(gauge.value() - 1);\n         }\n     }",
      "parent_sha": "37cfe0cbab46d617e6e53047af0fabd3bcd72915"
    }
  },
  {
    "oid": "1b328f211ff2ef8db3b44564ee402231480d90b0",
    "message": "downgrade noise logging",
    "date": "2021-03-24T01:17:09Z",
    "url": "https://github.com/Netflix/zuul/commit/1b328f211ff2ef8db3b44564ee402231480d90b0",
    "details": {
      "sha": "892ba6d83a52acf24a65e63277b6dd72f39db6c4",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/server/ClientResponseWriter.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/zuul/blob/1b328f211ff2ef8db3b44564ee402231480d90b0/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FClientResponseWriter.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/1b328f211ff2ef8db3b44564ee402231480d90b0/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FClientResponseWriter.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FClientResponseWriter.java?ref=1b328f211ff2ef8db3b44564ee402231480d90b0",
      "patch": "@@ -259,7 +259,7 @@ else if (evt instanceof IdleStateEvent) {\n             LOG.debug(\"Received IdleStateEvent.\");\n         }\n         else {\n-            LOG.info(\"ClientResponseWriter Received event {}\", evt);\n+            LOG.debug(\"ClientResponseWriter Received event {}\", evt);\n         }\n     }\n ",
      "parent_sha": "023b30f6961b7ca5a7cc2c846d739be6e96944d1"
    }
  },
  {
    "oid": "30e49ea6c319052bfa4c4410b209fcba0ae81686",
    "message": "logging tweak",
    "date": "2019-01-25T00:34:37Z",
    "url": "https://github.com/Netflix/zuul/commit/30e49ea6c319052bfa4c4410b209fcba0ae81686",
    "details": {
      "sha": "7678df42a975a92a9b7838d99df0c69f3d5eb641",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/server/ClientResponseWriter.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/Netflix/zuul/blob/30e49ea6c319052bfa4c4410b209fcba0ae81686/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FClientResponseWriter.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/30e49ea6c319052bfa4c4410b209fcba0ae81686/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FClientResponseWriter.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FClientResponseWriter.java?ref=30e49ea6c319052bfa4c4410b209fcba0ae81686",
      "patch": "@@ -247,7 +247,8 @@ else if (evt instanceof CompleteEvent) {\n             }\n             else {\n                 if (isHandlingRequest) {\n-                    LOG.warn(\"Received complete event while still handling the request. With reason: \" + reason.name() + ChannelUtils.channelInfoForLogging(ctx.channel()));\n+                    LOG.warn(\"Received complete event while still handling the request. With reason: \" + reason.name() + \" -- \" +\n+                            ChannelUtils.channelInfoForLogging(ctx.channel()));\n                 }\n                 ctx.close();\n             }",
      "parent_sha": "e9a6d351ec5372359f80adf3c80a73b8edb8b82d"
    }
  },
  {
    "oid": "2f96c17ad59e4986b2db10c08be67e818bb4bf6a",
    "message": "Bugfix in ProxyEndpoint\n\nIn operationComplete(), the onRequestStartWithServer() call was being made even if there were no-available-servers, in which\ncase the chosenServer is null. This wasn't breaking the flow, but was causing stacktraces in logs from an ExecutionListener.",
    "date": "2018-07-17T23:16:10Z",
    "url": "https://github.com/Netflix/zuul/commit/2f96c17ad59e4986b2db10c08be67e818bb4bf6a",
    "details": {
      "sha": "7810b8528d485cc0cd4139e37eb0a82a645c0606",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/filters/endpoint/ProxyEndpoint.java",
      "status": "modified",
      "additions": 29,
      "deletions": 30,
      "changes": 59,
      "blob_url": "https://github.com/Netflix/zuul/blob/2f96c17ad59e4986b2db10c08be67e818bb4bf6a/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/2f96c17ad59e4986b2db10c08be67e818bb4bf6a/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Ffilters%2Fendpoint%2FProxyEndpoint.java?ref=2f96c17ad59e4986b2db10c08be67e818bb4bf6a",
      "patch": "@@ -381,38 +381,37 @@ public void operationComplete(final Future<PooledConnection> connectResult) {\n         // MUST run this within bindingcontext because RequestExpiryProcessor (and probably other things) depends on ThreadVariables.\n         try {\n             methodBinding.bind(() -> {\n-\n-                // Invoke the ribbon execution listeners (including RequestExpiry).\n-                final ExecutionContext<?> executionContext = origin.getExecutionContext(zuulRequest, attemptNum);\n-                IClientConfig requestConfig = executionContext.getRequestConfig();\n-                final Object previousOverriddenReadTimeout = requestConfig.getProperty(ReadTimeout, null);\n-                Integer readTimeout;\n-                try {\n-                    Server server = chosenServer.get();\n-                    if (requestStat != null)\n-                        requestStat.server(server);\n-\n-                    readTimeout = getReadTimeout(requestConfig, attemptNum);\n-                    requestConfig.set(ReadTimeout, readTimeout);\n-\n-                    origin.onRequestStartWithServer(zuulRequest, server, attemptNum);\n-                }\n-                catch (Throwable e) {\n-                    handleError(e);\n-                    return;\n-                }\n-                finally {\n-                    // Reset the timeout in overriddenConfig back to what it was before, otherwise it will take\n-                    // preference on subsequent retry attempts in RequestExpiryProcessor.\n-                    if (previousOverriddenReadTimeout == null) {\n-                        requestConfig.setProperty(ReadTimeout, null);\n-                    } else {\n-                        requestConfig.setProperty(ReadTimeout, previousOverriddenReadTimeout);\n-                    }\n-                }\n-\n                 // Handle the connection.\n                 if (connectResult.isSuccess()) {\n+                    // Invoke the ribbon execution listeners (including RequestExpiry).\n+                    final ExecutionContext<?> executionContext = origin.getExecutionContext(zuulRequest, attemptNum);\n+                    IClientConfig requestConfig = executionContext.getRequestConfig();\n+                    final Object previousOverriddenReadTimeout = requestConfig.getProperty(ReadTimeout, null);\n+                    Integer readTimeout;\n+                    try {\n+                        Server server = chosenServer.get();\n+                        if (requestStat != null)\n+                            requestStat.server(server);\n+\n+                        readTimeout = getReadTimeout(requestConfig, attemptNum);\n+                        requestConfig.set(ReadTimeout, readTimeout);\n+\n+                        origin.onRequestStartWithServer(zuulRequest, server, attemptNum);\n+                    }\n+                    catch (Throwable e) {\n+                        handleError(e);\n+                        return;\n+                    }\n+                    finally {\n+                        // Reset the timeout in overriddenConfig back to what it was before, otherwise it will take\n+                        // preference on subsequent retry attempts in RequestExpiryProcessor.\n+                        if (previousOverriddenReadTimeout == null) {\n+                            requestConfig.setProperty(ReadTimeout, null);\n+                        } else {\n+                            requestConfig.setProperty(ReadTimeout, previousOverriddenReadTimeout);\n+                        }\n+                    }\n+\n                     onOriginConnectSucceeded(connectResult.getNow(), readTimeout);\n                 } else {\n                     onOriginConnectFailed(connectResult.cause());",
      "parent_sha": "d1b1d8ed7b6c66e37586e3e057388696aa4ab95b"
    }
  },
  {
    "oid": "c43fbbd9e88f4e81f9be99d2f37ea39a86b82a6c",
    "message": "Register the allocator memory metric polled gauge only once",
    "date": "2021-07-29T19:11:10Z",
    "url": "https://github.com/Netflix/zuul/commit/c43fbbd9e88f4e81f9be99d2f37ea39a86b82a6c",
    "details": {
      "sha": "fb5c7ade718fe8951fb8fecdb3fb44e9fd28b08d",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/netty/server/Server.java",
      "status": "modified",
      "additions": 13,
      "deletions": 9,
      "changes": 22,
      "blob_url": "https://github.com/Netflix/zuul/blob/c43fbbd9e88f4e81f9be99d2f37ea39a86b82a6c/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FServer.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/c43fbbd9e88f4e81f9be99d2f37ea39a86b82a6c/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FServer.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Fnetty%2Fserver%2FServer.java?ref=c43fbbd9e88f4e81f9be99d2f37ea39a86b82a6c",
      "patch": "@@ -203,6 +203,19 @@ public void start()\n                 addressesToChannels.put(requestedNamedAddr.withNewSocket(chan.localAddress()), chan);\n                 allBindFutures.add(nettyServerFuture);\n             }\n+\n+            // All channels should share a single ByteBufAllocator instance.\n+            // Add metrics to monitor that allocator's memory usage.\n+            if (!allBindFutures.isEmpty()) {\n+                ByteBufAllocator alloc = allBindFutures.get(0).channel().alloc();\n+                if (alloc instanceof ByteBufAllocatorMetricProvider) {\n+                    ByteBufAllocatorMetric metrics = ((ByteBufAllocatorMetricProvider) alloc).metric();\n+                    PolledMeter.using(registry).withId(registry.createId(\"zuul.nettybuffermem.live\", \"type\", \"heap\"))\n+                            .monitorValue(metrics, ByteBufAllocatorMetric::usedHeapMemory);\n+                    PolledMeter.using(registry).withId(registry.createId(\"zuul.nettybuffermem.live\", \"type\", \"direct\"))\n+                            .monitorValue(metrics, ByteBufAllocatorMetric::usedDirectMemory);\n+                }\n+            }\n         }\n         catch (InterruptedException e) {\n             Thread.currentThread().interrupt();\n@@ -277,15 +290,6 @@ private ChannelFuture setupServerBootstrap(\n         // Bind and start to accept incoming connections.\n         ChannelFuture bindFuture = serverBootstrap.bind(listenAddress.unwrap());\n \n-        ByteBufAllocator alloc = bindFuture.channel().alloc();\n-        if (alloc instanceof ByteBufAllocatorMetricProvider) {\n-            ByteBufAllocatorMetric metrics = ((ByteBufAllocatorMetricProvider) alloc).metric();\n-            PolledMeter.using(registry).withId(registry.createId(\"zuul.nettybuffermem.live\", \"type\", \"heap\"))\n-                    .monitorValue(metrics, ByteBufAllocatorMetric::usedHeapMemory);\n-            PolledMeter.using(registry).withId(registry.createId(\"zuul.nettybuffermem.live\", \"type\", \"direct\"))\n-                    .monitorValue(metrics, ByteBufAllocatorMetric::usedDirectMemory);\n-        }\n-\n         try {\n             return bindFuture.sync();\n         } catch (Exception e) {",
      "parent_sha": "3f8e4ee545cd0c1752aab99fda2af34af16a2d65"
    }
  },
  {
    "oid": "eb9e7ff7cd427d6a99de0f445104eab4399b6c54",
    "message": "track filter success and failures via counters",
    "date": "2014-03-20T19:05:47Z",
    "url": "https://github.com/Netflix/zuul/commit/eb9e7ff7cd427d6a99de0f445104eab4399b6c54",
    "details": {
      "sha": "8112cd804ba861659ce8e71f207ebb0eaec5e12b",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/FilterProcessor.java",
      "status": "modified",
      "additions": 16,
      "deletions": 1,
      "changes": 17,
      "blob_url": "https://github.com/Netflix/zuul/blob/eb9e7ff7cd427d6a99de0f445104eab4399b6c54/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/eb9e7ff7cd427d6a99de0f445104eab4399b6c54/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2FFilterProcessor.java?ref=eb9e7ff7cd427d6a99de0f445104eab4399b6c54",
      "patch": "@@ -32,6 +32,8 @@\n import javax.servlet.http.HttpServletResponse;\n import java.util.List;\n \n+import com.netflix.servo.monitor.DynamicCounter;\n+\n import static org.junit.Assert.*;\n import static org.mockito.Mockito.*;\n \n@@ -187,8 +189,11 @@ public Object processZuulFilter(ZuulFilter filter) throws ZuulException {\n                 case FAILED:\n                     t = result.getException();\n                     ctx.addFilterExecutionSummary(filterName, ExecutionStatus.FAILED.name(), execTime);\n+                    \n+                    DynamicCounter.increment(filterName, \"fail\",filter.filterType());\n                     break;\n                 case SUCCESS:\n+                \tDynamicCounter.increment(filterName,\"success\", filter.filterType());\n                     o = result.getResult();\n                     ctx.addFilterExecutionSummary(filterName, ExecutionStatus.SUCCESS.name(), execTime);\n                     if (bDebug) {\n@@ -197,6 +202,7 @@ public Object processZuulFilter(ZuulFilter filter) throws ZuulException {\n                     }\n                     break;\n                 default:\n+                \tDynamicCounter.increment(filterName, \"unknown\", filter.filterType());\n                     break;\n             }\n             \n@@ -206,7 +212,7 @@ public Object processZuulFilter(ZuulFilter filter) throws ZuulException {\n             if (bDebug) {\n                 Debug.addRoutingDebug(\"Running Filter failed \" + filterName + \" type:\" + filter.filterType() + \" order:\" + filter.filterOrder() + \" \" + e.getMessage());\n             }\n-            \n+            DynamicCounter.increment(filterName, \"fail\", filter.filterType());\n             if (e instanceof ZuulException) {\n                 throw (ZuulException) e;\n             } else {\n@@ -253,6 +259,7 @@ public void testProcessZuulFilterException() {\n                 ZuulFilterResult r = new ZuulFilterResult(ExecutionStatus.FAILED);\n                 r.setException(new Exception(\"Test\"));\n                 when(filter.runFilter()).thenReturn(r);\n+                when(filter.filterType()).thenReturn(\"post\");\n                 processor.processZuulFilter(filter);\n                 assertFalse(true);\n             } catch (Throwable e) {\n@@ -308,6 +315,7 @@ public void testRouteProcessHttpException() {\n             processor = spy(processor);\n             try {\n                 when(processor.runFilters(\"route\")).thenThrow(new ZuulException(\"test\", 400, \"test\"));\n+                when(filter.filterType()).thenReturn(\"post\");\n                 processor.route();\n             } catch (ZuulException e) {\n                 assertEquals(e.getMessage(), \"test\");\n@@ -332,6 +340,7 @@ public void testRouteProcessException() {\n \n             try {\n                 when(processor.runFilters(\"route\")).thenThrow(new Throwable(\"test\"));\n+                when(filter.filterType()).thenReturn(\"post\");\n                 processor.route();\n             } catch (ZuulException e) {\n                 assertEquals(e.getMessage(), \"test\");\n@@ -354,6 +363,7 @@ public void testPreProcessException() {\n \n             try {\n                 when(processor.runFilters(\"pre\")).thenThrow(new Throwable(\"test\"));\n+                when(filter.filterType()).thenReturn(\"post\");\n                 processor.preRoute();\n             } catch (ZuulException e) {\n                 assertEquals(e.getMessage(), \"test\");\n@@ -375,6 +385,7 @@ public void testPreProcessHttpException() {\n             processor = spy(processor);\n             try {\n                 when(processor.runFilters(\"pre\")).thenThrow(new ZuulException(\"test\", 400, \"test\"));\n+                when(filter.filterType()).thenReturn(\"post\");\n                 processor.preRoute();\n             } catch (ZuulException e) {\n                 assertEquals(e.getMessage(), \"test\");\n@@ -400,6 +411,7 @@ public void testPostProcessException() {\n \n             try {\n                 when(processor.runFilters(\"post\")).thenThrow(new Throwable(\"test\"));\n+                when(filter.filterType()).thenReturn(\"post\");\n                 processor.postRoute();\n             } catch (ZuulException e) {\n                 assertEquals(e.getMessage(), \"test\");\n@@ -421,6 +433,7 @@ public void testPostProcessHttpException() {\n             processor = spy(processor);\n             try {\n                 when(processor.runFilters(\"post\")).thenThrow(new ZuulException(\"test\", 400, \"test\"));\n+                when(filter.filterType()).thenReturn(\"post\");\n                 processor.postRoute();\n             } catch (ZuulException e) {\n                 assertEquals(e.getMessage(), \"test\");\n@@ -441,6 +454,7 @@ public void testErrorException() {\n \n             try {\n                 when(processor.runFilters(\"error\")).thenThrow(new Exception(\"test\"));\n+                when(filter.filterType()).thenReturn(\"post\");\n                 processor.error();\n                 assertTrue(true);\n             } catch (Throwable e) {\n@@ -460,6 +474,7 @@ public void testErrorHttpException() {\n             processor = spy(processor);\n             try {\n                 when(processor.runFilters(\"error\")).thenThrow(new ZuulException(\"test\", 400, \"test\"));\n+                when(filter.filterType()).thenReturn(\"post\");\n                 processor.error();\n                 assertTrue(true);\n             } catch (Throwable e) {",
      "parent_sha": "e5bf1ace456e3058020792e9e55ac95e2eb6e29f"
    }
  },
  {
    "oid": "3b246ff3e9a43f2d258751340cadf70bc9bc820c",
    "message": "Rename the interface to isCold()",
    "date": "2017-09-26T18:22:19Z",
    "url": "https://github.com/Netflix/zuul/commit/3b246ff3e9a43f2d258751340cadf70bc9bc820c",
    "details": {
      "sha": "77986d72a09479f4e90c884b984b29f5eec7999e",
      "filename": "zuul-core/src/main/java/com/netflix/zuul/origins/Origin.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/zuul/blob/3b246ff3e9a43f2d258751340cadf70bc9bc820c/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Forigins%2FOrigin.java",
      "raw_url": "https://github.com/Netflix/zuul/raw/3b246ff3e9a43f2d258751340cadf70bc9bc820c/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Forigins%2FOrigin.java",
      "contents_url": "https://api.github.com/repos/Netflix/zuul/contents/zuul-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fzuul%2Forigins%2FOrigin.java?ref=3b246ff3e9a43f2d258751340cadf70bc9bc820c",
      "patch": "@@ -27,6 +27,6 @@\n public interface Origin {\n     String getName();\n     boolean isAvailable();\n-    boolean isWarmServerAvailable();\n+    boolean isCold();\n     Observable<HttpResponseMessage> request(HttpRequestMessage requestMsg);\n }",
      "parent_sha": "acc78f6e28142984cde9cd4862d76db9459da1ba"
    }
  }
]