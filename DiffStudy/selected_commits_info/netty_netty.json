[
  {
    "oid": "a743b74bfbbe3cd3fd0c1050e793df011060a61d",
    "message": "Remove not needed null check (#11303)\n\nMotivation:\r\n\r\nthrow exception if there is no method, it never is null, condition is always true\r\n\r\nModification:\r\n\r\nremove unnecessary condition\r\n\r\nResult:\r\n\r\ncleanup",
    "date": "2021-05-26T13:11:27Z",
    "url": "https://github.com/netty/netty/commit/a743b74bfbbe3cd3fd0c1050e793df011060a61d",
    "details": {
      "sha": "837adec29e01905cbf311d2c37dca0caeaaf3a1b",
      "filename": "transport/src/main/java/io/netty/channel/ChannelHandlerMask.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/a743b74bfbbe3cd3fd0c1050e793df011060a61d/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FChannelHandlerMask.java",
      "raw_url": "https://github.com/netty/netty/raw/a743b74bfbbe3cd3fd0c1050e793df011060a61d/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FChannelHandlerMask.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FChannelHandlerMask.java?ref=a743b74bfbbe3cd3fd0c1050e793df011060a61d",
      "patch": "@@ -179,7 +179,7 @@ public Boolean run() throws Exception {\n                     }\n                     return false;\n                 }\n-                return m != null && m.isAnnotationPresent(Skip.class);\n+                return m.isAnnotationPresent(Skip.class);\n             }\n         });\n     }",
      "parent_sha": "5e71336ffbea4f0c7573b84ef5b1e81ea779381c"
    }
  },
  {
    "oid": "79c17cf1fdb70476e32affa2c0a9bed6a88ff7c6",
    "message": "ByteBufUtil use IndexOfProcessor to find occurrence.\n\nMotivation:\nThe way of firstIndexOf and lastIndexOf iterating the ByteBuf is similar to forEachByte and forEachByteDesc, but have many range checks.\nModifications:\nUse forEachByte and a IndexOfProcessor to find occurrence.\nResult:\neliminate range checks",
    "date": "2015-05-07T07:36:47Z",
    "url": "https://github.com/netty/netty/commit/79c17cf1fdb70476e32affa2c0a9bed6a88ff7c6",
    "details": {
      "sha": "74c52985ca4845b6177d9f4992eed4b14a8d02d8",
      "filename": "buffer/src/main/java/io/netty/buffer/ByteBufUtil.java",
      "status": "modified",
      "additions": 4,
      "deletions": 14,
      "changes": 18,
      "blob_url": "https://github.com/netty/netty/blob/79c17cf1fdb70476e32affa2c0a9bed6a88ff7c6/buffer%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fbuffer%2FByteBufUtil.java",
      "raw_url": "https://github.com/netty/netty/raw/79c17cf1fdb70476e32affa2c0a9bed6a88ff7c6/buffer%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fbuffer%2FByteBufUtil.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/buffer%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fbuffer%2FByteBufUtil.java?ref=79c17cf1fdb70476e32affa2c0a9bed6a88ff7c6",
      "patch": "@@ -16,6 +16,8 @@\n package io.netty.buffer;\n \n import static io.netty.util.internal.ObjectUtil.checkNotNull;\n+\n+import io.netty.util.ByteProcessor;\n import io.netty.util.ByteString;\n import io.netty.util.CharsetUtil;\n import io.netty.util.Recycler;\n@@ -365,13 +367,7 @@ private static int firstIndexOf(ByteBuf buffer, int fromIndex, int toIndex, byte\n             return -1;\n         }\n \n-        for (int i = fromIndex; i < toIndex; i ++) {\n-            if (buffer.getByte(i) == value) {\n-                return i;\n-            }\n-        }\n-\n-        return -1;\n+        return buffer.forEachByte(fromIndex, toIndex - fromIndex, new ByteProcessor.IndexOfProcessor(value));\n     }\n \n     private static int lastIndexOf(ByteBuf buffer, int fromIndex, int toIndex, byte value) {\n@@ -380,13 +376,7 @@ private static int lastIndexOf(ByteBuf buffer, int fromIndex, int toIndex, byte\n             return -1;\n         }\n \n-        for (int i = fromIndex - 1; i >= toIndex; i --) {\n-            if (buffer.getByte(i) == value) {\n-                return i;\n-            }\n-        }\n-\n-        return -1;\n+        return buffer.forEachByteDesc(toIndex, fromIndex - toIndex, new ByteProcessor.IndexOfProcessor(value));\n     }\n \n     /**",
      "parent_sha": "97d871a7553a01384b43df855dccdda5205ae77a"
    }
  },
  {
    "oid": "3d7dba373fff33270a897a7de86f7311952301a2",
    "message": "Eliminate unnessary copy of ByteBuf on ByteToMessageDecoder removal (#9662)\n\nMotivation:\r\n\r\nAt the moment we do a ByteBuf.readBytes(...) on removal of the ByteToMessageDecoder if there are any bytes left and forward the returned ByteBuf to the next handler in the pipeline. This is not really needed as we can just forward the cumulation buffer directly and so eliminate the extra memory copy\r\n\r\nModifications:\r\n\r\nJust forward the cumulation buffer directly on removal of the ByteToMessageDecoder\r\n\r\nResult:\r\n\r\nLess memory copies",
    "date": "2019-10-16T13:47:59Z",
    "url": "https://github.com/netty/netty/commit/3d7dba373fff33270a897a7de86f7311952301a2",
    "details": {
      "sha": "948a71d9a4e0f3952b0dec7aea735827a2acf40a",
      "filename": "codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/netty/netty/blob/3d7dba373fff33270a897a7de86f7311952301a2/codec%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2FByteToMessageDecoder.java",
      "raw_url": "https://github.com/netty/netty/raw/3d7dba373fff33270a897a7de86f7311952301a2/codec%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2FByteToMessageDecoder.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2FByteToMessageDecoder.java?ref=3d7dba373fff33270a897a7de86f7311952301a2",
      "patch": "@@ -251,9 +251,7 @@ public final void handlerRemoved(ChannelHandlerContext ctx) throws Exception {\n             numReads = 0;\n             int readable = buf.readableBytes();\n             if (readable > 0) {\n-                ByteBuf bytes = buf.readBytes(readable);\n-                buf.release();\n-                ctx.fireChannelRead(bytes);\n+                ctx.fireChannelRead(buf);\n                 ctx.fireChannelReadComplete();\n             } else {\n                 buf.release();",
      "parent_sha": "2e5dd288008d4e674f53beaf8d323595813062fb"
    }
  },
  {
    "oid": "333f45ccd5f65bf64aa6e52dfa0ed080cfd17486",
    "message": "Made sure events are propagated somehow.",
    "date": "2008-11-16T15:02:01Z",
    "url": "https://github.com/netty/netty/commit/333f45ccd5f65bf64aa6e52dfa0ed080cfd17486",
    "details": {
      "sha": "97426e903e2a23da06d81c2f42901051343fcc25",
      "filename": "src/main/java/org/jboss/netty/handler/execution/MemoryAwareThreadPoolExecutor.java",
      "status": "modified",
      "additions": 22,
      "deletions": 3,
      "changes": 25,
      "blob_url": "https://github.com/netty/netty/blob/333f45ccd5f65bf64aa6e52dfa0ed080cfd17486/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Fexecution%2FMemoryAwareThreadPoolExecutor.java",
      "raw_url": "https://github.com/netty/netty/raw/333f45ccd5f65bf64aa6e52dfa0ed080cfd17486/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Fexecution%2FMemoryAwareThreadPoolExecutor.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Fexecution%2FMemoryAwareThreadPoolExecutor.java?ref=333f45ccd5f65bf64aa6e52dfa0ed080cfd17486",
      "patch": "@@ -27,6 +27,8 @@\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.Executor;\n import java.util.concurrent.Executors;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.RejectedExecutionHandler;\n import java.util.concurrent.Semaphore;\n import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.ThreadPoolExecutor;\n@@ -83,9 +85,9 @@\n  */\n public class MemoryAwareThreadPoolExecutor extends ThreadPoolExecutor {\n \n-    private static final InternalLogger logger = \n+    private static final InternalLogger logger =\n         InternalLoggerFactory.getInstance(MemoryAwareThreadPoolExecutor.class);\n-    \n+\n     private volatile Settings settings = new Settings(0, 0);\n \n     // XXX Can be changed in runtime now.  Make it mutable in 3.1.\n@@ -167,7 +169,8 @@ public MemoryAwareThreadPoolExecutor(\n             long keepAliveTime, TimeUnit unit, ObjectSizeEstimator objectSizeEstimator,\n             ThreadFactory threadFactory) {\n \n-        super(corePoolSize, corePoolSize, keepAliveTime, unit, new LinkedTransferQueue<Runnable>(), threadFactory);\n+        super(corePoolSize, corePoolSize, keepAliveTime, unit,\n+              new LinkedTransferQueue<Runnable>(), threadFactory, new NewThreadRunsPolicy());\n \n         if (objectSizeEstimator == null) {\n             throw new NullPointerException(\"objectSizeEstimator\");\n@@ -403,4 +406,20 @@ private static class Settings {\n             this.maxTotalMemorySize = maxTotalMemorySize;\n         }\n     }\n+\n+    private static class NewThreadRunsPolicy implements RejectedExecutionHandler {\n+        NewThreadRunsPolicy() {\n+            super();\n+        }\n+\n+        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n+            try {\n+                final Thread t = new Thread(r, \"Temporary task executor\");\n+                t.start();\n+            } catch (Throwable e) {\n+                throw new RejectedExecutionException(\n+                        \"Failed to start a new thread\", e);\n+            }\n+        }\n+    }\n }",
      "parent_sha": "72ab3f04b05b56b710623327908d1ca53de9c620"
    }
  },
  {
    "oid": "5cb2e4f19718464cde92cd78ea12b514cabc3bc8",
    "message": "Descriptive message for errors related to unknown http2 streams (#13691)\n\nMotivation:\r\n\r\nWhen unknown http2 stream error occurs, It is hard to analyze root cause\r\nsince only streamId is provided in message.\r\n\r\nModification:\r\n\r\nAdd frame type, endOfStream flag (where applicable) to error message.\r\n\r\nResult:\r\n\r\nMore descriptive error messages.",
    "date": "2023-11-08T09:36:59Z",
    "url": "https://github.com/netty/netty/commit/5cb2e4f19718464cde92cd78ea12b514cabc3bc8",
    "details": {
      "sha": "41ec08b0eefe2df66d6b5e80de382558ffee0d3c",
      "filename": "codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java",
      "status": "modified",
      "additions": 13,
      "deletions": 10,
      "changes": 23,
      "blob_url": "https://github.com/netty/netty/blob/5cb2e4f19718464cde92cd78ea12b514cabc3bc8/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FDefaultHttp2ConnectionDecoder.java",
      "raw_url": "https://github.com/netty/netty/raw/5cb2e4f19718464cde92cd78ea12b514cabc3bc8/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FDefaultHttp2ConnectionDecoder.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FDefaultHttp2ConnectionDecoder.java?ref=5cb2e4f19718464cde92cd78ea12b514cabc3bc8",
      "patch": "@@ -265,7 +265,7 @@ public int onDataRead(final ChannelHandlerContext ctx, int streamId, ByteBuf dat\n \n             final boolean shouldIgnore;\n             try {\n-                shouldIgnore = shouldIgnoreHeadersOrDataFrame(ctx, streamId, stream, \"DATA\");\n+                shouldIgnore = shouldIgnoreHeadersOrDataFrame(ctx, streamId, stream, endOfStream, \"DATA\");\n             } catch (Http2Exception e) {\n                 // Ignoring this frame. We still need to count the frame towards the connection flow control\n                 // window, but we immediately mark all bytes as consumed.\n@@ -283,7 +283,7 @@ public int onDataRead(final ChannelHandlerContext ctx, int streamId, ByteBuf dat\n                 flowController.consumeBytes(stream, bytesToReturn);\n \n                 // Verify that the stream may have existed after we apply flow control.\n-                verifyStreamMayHaveExisted(streamId);\n+                verifyStreamMayHaveExisted(streamId, endOfStream, \"DATA\");\n \n                 // All bytes have been consumed.\n                 return bytesToReturn;\n@@ -366,7 +366,7 @@ public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers\n                 isTrailers = stream.isHeadersReceived();\n             }\n \n-            if (shouldIgnoreHeadersOrDataFrame(ctx, streamId, stream, \"HEADERS\")) {\n+            if (shouldIgnoreHeadersOrDataFrame(ctx, streamId, stream, endOfStream, \"HEADERS\")) {\n                 return;\n             }\n \n@@ -452,7 +452,7 @@ public void onPriorityRead(ChannelHandlerContext ctx, int streamId, int streamDe\n         public void onRstStreamRead(ChannelHandlerContext ctx, int streamId, long errorCode) throws Http2Exception {\n             Http2Stream stream = connection.stream(streamId);\n             if (stream == null) {\n-                verifyStreamMayHaveExisted(streamId);\n+                verifyStreamMayHaveExisted(streamId, false, \"RST_STREAM\");\n                 return;\n             }\n \n@@ -565,7 +565,7 @@ public void onPushPromiseRead(ChannelHandlerContext ctx, int streamId, int promi\n \n             Http2Stream parentStream = connection.stream(streamId);\n \n-            if (shouldIgnoreHeadersOrDataFrame(ctx, streamId, parentStream, \"PUSH_PROMISE\")) {\n+            if (shouldIgnoreHeadersOrDataFrame(ctx, streamId, parentStream, false, \"PUSH_PROMISE\")) {\n                 return;\n             }\n \n@@ -615,7 +615,7 @@ public void onWindowUpdateRead(ChannelHandlerContext ctx, int streamId, int wind\n             Http2Stream stream = connection.stream(streamId);\n             if (stream == null || stream.state() == CLOSED || streamCreatedAfterGoAwaySent(streamId)) {\n                 // Ignore this frame.\n-                verifyStreamMayHaveExisted(streamId);\n+                verifyStreamMayHaveExisted(streamId, false, \"WINDOW_UPDATE\");\n                 return;\n             }\n \n@@ -636,7 +636,7 @@ public void onUnknownFrame(ChannelHandlerContext ctx, byte frameType, int stream\n          * {@code stream} (which may be {@code null}) associated with {@code streamId}.\n          */\n         private boolean shouldIgnoreHeadersOrDataFrame(ChannelHandlerContext ctx, int streamId, Http2Stream stream,\n-                String frameName) throws Http2Exception {\n+                boolean endOfStream, String frameName) throws Http2Exception {\n             if (stream == null) {\n                 if (streamCreatedAfterGoAwaySent(streamId)) {\n                     logger.info(\"{} ignoring {} frame for stream {}. Stream sent after GOAWAY sent\",\n@@ -646,7 +646,7 @@ private boolean shouldIgnoreHeadersOrDataFrame(ChannelHandlerContext ctx, int st\n \n                 // Make sure it's not an out-of-order frame, like a rogue DATA frame, for a stream that could\n                 // never have existed.\n-                verifyStreamMayHaveExisted(streamId);\n+                verifyStreamMayHaveExisted(streamId, endOfStream, frameName);\n \n                 // Its possible that this frame would result in stream ID out of order creation (PROTOCOL ERROR) and its\n                 // also possible that this frame is received on a CLOSED stream (STREAM_CLOSED after a RST_STREAM is\n@@ -690,9 +690,12 @@ private boolean streamCreatedAfterGoAwaySent(int streamId) {\n                     streamId > remote.lastStreamKnownByPeer();\n         }\n \n-        private void verifyStreamMayHaveExisted(int streamId) throws Http2Exception {\n+        private void verifyStreamMayHaveExisted(int streamId, boolean endOfStream, String frameName)\n+                throws Http2Exception {\n             if (!connection.streamMayHaveExisted(streamId)) {\n-                throw connectionError(PROTOCOL_ERROR, \"Stream %d does not exist\", streamId);\n+                throw connectionError(PROTOCOL_ERROR,\n+                        \"Stream %d does not exist for inbound frame %s, endOfStream = %b\",\n+                        streamId, frameName, endOfStream);\n             }\n         }\n     }",
      "parent_sha": "7e18e8344819428a5560064ac15a2f035b4728fd"
    }
  },
  {
    "oid": "6bd810210dcd12344325331361758723479e1ea1",
    "message": "Servers should not send duplicate intermediate certificates.\n\nMotivation:\nServers sometimes send duplicate intermediate certificates.\n\nModifications:\nOpenSslKeyMaterialManager.setKeyMaterial() dedups aliases before calling SSL.setCertificateChainBio().\n\nResult:\nServers no longer send duplicate itermediate certificates.",
    "date": "2016-08-01T08:52:46Z",
    "url": "https://github.com/netty/netty/commit/6bd810210dcd12344325331361758723479e1ea1",
    "details": {
      "sha": "e5f5fbe1ded5b76574bb370721346d7784589956",
      "filename": "handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialManager.java",
      "status": "modified",
      "additions": 8,
      "deletions": 2,
      "changes": 10,
      "blob_url": "https://github.com/netty/netty/blob/6bd810210dcd12344325331361758723479e1ea1/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2FOpenSslKeyMaterialManager.java",
      "raw_url": "https://github.com/netty/netty/raw/6bd810210dcd12344325331361758723479e1ea1/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2FOpenSslKeyMaterialManager.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2FOpenSslKeyMaterialManager.java?ref=6bd810210dcd12344325331361758723479e1ea1",
      "patch": "@@ -23,7 +23,9 @@\n import java.security.PrivateKey;\n import java.security.cert.X509Certificate;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Set;\n \n /**\n  * Manages key material for {@link OpenSslEngine}s and so set the right {@link PrivateKey}s and\n@@ -66,10 +68,14 @@ class OpenSslKeyMaterialManager {\n     void setKeyMaterial(OpenSslEngine engine) throws SSLException {\n         long ssl = engine.sslPointer();\n         String[] authMethods = SSL.authenticationMethods(ssl);\n+        Set<String> aliases = new HashSet<String>(authMethods.length);\n         for (String authMethod : authMethods) {\n             String type = KEY_TYPES.get(authMethod);\n             if (type != null) {\n-                setKeyMaterial(ssl, chooseServerAlias(engine, type));\n+                String alias = chooseServerAlias(engine, type);\n+                if (alias != null && aliases.add(alias)) {\n+                    setKeyMaterial(ssl, alias);\n+                }\n             }\n         }\n     }\n@@ -87,7 +93,7 @@ private void setKeyMaterial(long ssl, String alias) throws SSLException {\n             X509Certificate[] certificates = keyManager.getCertificateChain(alias);\n \n             if (certificates != null && certificates.length != 0) {\n-                keyCertChainBio = OpenSslContext.toBIO(keyManager.getCertificateChain(alias));\n+                keyCertChainBio = OpenSslContext.toBIO(certificates);\n                 if (key != null) {\n                     keyBio = OpenSslContext.toBIO(key);\n                 }",
      "parent_sha": "b2f1ef57c8ad0fd9f4cc2b42f5518487d6771b98"
    }
  },
  {
    "oid": "bab227213ef30a414f3ec3db41c1a28646120a6c",
    "message": "Increase the default maxMessagesPerRead of  AbstractNioByteChannel to 16\n\n - Related: #2079",
    "date": "2013-12-21T11:08:42Z",
    "url": "https://github.com/netty/netty/commit/bab227213ef30a414f3ec3db41c1a28646120a6c",
    "details": {
      "sha": "2623183d1d3feea0f76ca62df9f0f1950157f3f5",
      "filename": "transport/src/main/java/io/netty/channel/DefaultChannelConfig.java",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/netty/netty/blob/bab227213ef30a414f3ec3db41c1a28646120a6c/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FDefaultChannelConfig.java",
      "raw_url": "https://github.com/netty/netty/raw/bab227213ef30a414f3ec3db41c1a28646120a6c/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FDefaultChannelConfig.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FDefaultChannelConfig.java?ref=bab227213ef30a414f3ec3db41c1a28646120a6c",
      "patch": "@@ -17,6 +17,7 @@\n \n import io.netty.buffer.ByteBufAllocator;\n import io.netty.buffer.UnpooledByteBufAllocator;\n+import io.netty.channel.nio.AbstractNioByteChannel;\n import io.netty.channel.socket.SocketChannelConfig;\n \n import java.util.IdentityHashMap;\n@@ -56,8 +57,11 @@ public DefaultChannelConfig(Channel channel) {\n         }\n         this.channel = channel;\n \n-        if (channel instanceof ServerChannel) {\n-            // Accept as many incoming connections as possible.\n+        if (channel instanceof ServerChannel || channel instanceof AbstractNioByteChannel) {\n+            // Server channels: Accept as many incoming connections as possible.\n+            // NIO byte channels: Implemented to reduce unnecessary system calls even if it's > 1.\n+            //                    See https://github.com/netty/netty/issues/2079\n+            // TODO: Add some property to ChannelMetadata so we can remove the ugly instanceof\n             maxMessagesPerRead = 16;\n         } else {\n             maxMessagesPerRead = 1;",
      "parent_sha": "1fcd19a28fbab687eb2be65ad3535d1564d656cc"
    }
  },
  {
    "oid": "ed9527ba41bca660d96b62a6a42470efab50b5a5",
    "message": "[#1639] Fix bug where SpdyOrHttpChooser may not buffer data correctly during protocol detection",
    "date": "2013-07-23T07:05:10Z",
    "url": "https://github.com/netty/netty/commit/ed9527ba41bca660d96b62a6a42470efab50b5a5",
    "details": {
      "sha": "c14a0d669bb22dee10fbacd6bac30fbe4c8752f3",
      "filename": "codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/netty/netty/blob/ed9527ba41bca660d96b62a6a42470efab50b5a5/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fspdy%2FSpdyOrHttpChooser.java",
      "raw_url": "https://github.com/netty/netty/raw/ed9527ba41bca660d96b62a6a42470efab50b5a5/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fspdy%2FSpdyOrHttpChooser.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fspdy%2FSpdyOrHttpChooser.java?ref=ed9527ba41bca660d96b62a6a42470efab50b5a5",
      "patch": "@@ -15,24 +15,26 @@\n  */\n package io.netty.handler.codec.spdy;\n \n+import io.netty.buffer.ByteBuf;\n import io.netty.channel.ChannelHandler;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.ChannelInboundHandler;\n-import io.netty.channel.ChannelInboundHandlerAdapter;\n import io.netty.channel.ChannelPipeline;\n+import io.netty.handler.codec.ByteToMessageDecoder;\n import io.netty.handler.codec.http.HttpObjectAggregator;\n import io.netty.handler.codec.http.HttpRequestDecoder;\n import io.netty.handler.codec.http.HttpResponseEncoder;\n import io.netty.handler.ssl.SslHandler;\n \n import javax.net.ssl.SSLEngine;\n+import java.util.List;\n \n /**\n  * {@link ChannelInboundHandler} which is responsible to setup the {@link ChannelPipeline} either for\n  * HTTP or SPDY. This offers an easy way for users to support both at the same time while not care to\n  * much about the low-level details.\n  */\n-public abstract class SpdyOrHttpChooser extends ChannelInboundHandlerAdapter {\n+public abstract class SpdyOrHttpChooser extends ByteToMessageDecoder {\n \n     // TODO: Replace with generic NPN handler\n \n@@ -60,13 +62,11 @@ protected SpdyOrHttpChooser(int maxSpdyContentLength, int maxHttpContentLength)\n     protected abstract SelectedProtocol getProtocol(SSLEngine engine);\n \n     @Override\n-    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n         if (initPipeline(ctx)) {\n             // When we reached here we can remove this handler as its now clear what protocol we want to use\n-            // from this point on.\n+            // from this point on. This will also take care of forward all messages.\n             ctx.pipeline().remove(this);\n-\n-            ctx.fireChannelRead(msg);\n         }\n     }\n \n@@ -136,7 +136,7 @@ protected void addHttpHandlers(ChannelHandlerContext ctx) {\n      * when the {@link SelectedProtocol} was {@link SelectedProtocol#SPDY_2} or\n      * {@link SelectedProtocol#SPDY_3}.\n      *\n-     * Bye default this getMethod will just delecate to {@link #createHttpRequestHandlerForHttp()}, but\n+     * By default this getMethod will just delecate to {@link #createHttpRequestHandlerForHttp()}, but\n      * sub-classes may override this to change the behaviour.\n      */\n     protected ChannelInboundHandler createHttpRequestHandlerForSpdy() {",
      "parent_sha": "0b175867315f63154a734dcb8520166f4e9b9702"
    }
  },
  {
    "oid": "8b3abf3b49d20def418f634bd2634811ebc3e53d",
    "message": "Fix a javadoc mistake. (#10364)\n\nMotivation:\r\n\r\nThere exists a `javadoc` mistake in `HttpHeaderValues.java`.\r\n\r\nModification:\r\n\r\nJust correct this `javadoc` mistake...",
    "date": "2020-06-23T07:23:59Z",
    "url": "https://github.com/netty/netty/commit/8b3abf3b49d20def418f634bd2634811ebc3e53d",
    "details": {
      "sha": "8c968977f52814a14e2bd88f5632b0366d6caf0d",
      "filename": "codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderValues.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/8b3abf3b49d20def418f634bd2634811ebc3e53d/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2FHttpHeaderValues.java",
      "raw_url": "https://github.com/netty/netty/raw/8b3abf3b49d20def418f634bd2634811ebc3e53d/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2FHttpHeaderValues.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2FHttpHeaderValues.java?ref=8b3abf3b49d20def418f634bd2634811ebc3e53d",
      "patch": "@@ -229,7 +229,7 @@ public final class HttpHeaderValues {\n      */\n     public static final AsciiString WEBSOCKET = AsciiString.cached(\"websocket\");\n     /**\n-     * {@code \"websocket\"}\n+     * {@code \"XmlHttpRequest\"}\n      */\n     public static final AsciiString XML_HTTP_REQUEST = AsciiString.cached(\"XmlHttpRequest\");\n ",
      "parent_sha": "48938e2d99d51c8226f60b045b9a7a4520ed65da"
    }
  },
  {
    "oid": "7971075bbe9f5509c8b20c0e702ec2affb37d76e",
    "message": "Fix FlowControlHandler's autoreading breakage. (#12467)\n\n \r\nMotivation:\r\n\r\nFlowControlHandler breaks auto-reading (i.e. the channel does not auto-read even though its config has auto-read set to true). This happens when auto-read is turned on when the queue is not empty. The reason is that FlowControlHandler.read() does not pass the call to the ChannelHandlerContext if at least one message has been dequeued. This is a problem when FlowControlHandler.read() has been called as a result of auto-read having been turned on (DefaultChannelConfig.setAutoRead() calling read() in case of autoRead && !oldAutoRead).\r\n \r\nModifications:\r\n\r\nAlways pass the call to read() down the pipeline.\r\n \r\nResult:\r\n\r\nAuto-reading works, regardless of the handler's queue state in the moment it is turned on.\r\nFixes #12445",
    "date": "2022-10-13T08:24:26Z",
    "url": "https://github.com/netty/netty/commit/7971075bbe9f5509c8b20c0e702ec2affb37d76e",
    "details": {
      "sha": "f316907a7e5c62c757c5464199c8fede167919f0",
      "filename": "handler/src/main/java/io/netty/handler/flow/FlowControlHandler.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/7971075bbe9f5509c8b20c0e702ec2affb37d76e/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fflow%2FFlowControlHandler.java",
      "raw_url": "https://github.com/netty/netty/raw/7971075bbe9f5509c8b20c0e702ec2affb37d76e/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fflow%2FFlowControlHandler.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fflow%2FFlowControlHandler.java?ref=7971075bbe9f5509c8b20c0e702ec2affb37d76e",
      "patch": "@@ -141,8 +141,8 @@ public void read(ChannelHandlerContext ctx) throws Exception {\n             // messages from upstream and once one arrives it need to be\n             // relayed to downstream to keep the flow going.\n             shouldConsume = true;\n-            ctx.read();\n         }\n+        ctx.read();\n     }\n \n     @Override",
      "parent_sha": "7c05db4ce6ba5c832a6ee778808f4e5e95814281"
    }
  },
  {
    "oid": "0140f42a4f2aecf5925d1ae834a462b4c21a6c25",
    "message": "IoUring: Make static methods of IoUringIoOps package-private (#14551)\n\nMotivation:\r\n\r\nLet's limit the public API for now as normal users never will need to\r\nuse any of these methods. At worse people can create the right\r\nIoUringIoOps by themselves via the public constructor.\r\n\r\nModifications:\r\n\r\n- Change visibility to package-private\r\n\r\nResult:\r\n\r\nLess public API to maintain",
    "date": "2024-12-09T10:16:14Z",
    "url": "https://github.com/netty/netty/commit/0140f42a4f2aecf5925d1ae834a462b4c21a6c25",
    "details": {
      "sha": "fd6b7ddbcd40eb144ce75021a0fc3f8e1a399fcf",
      "filename": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringIoOps.java",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/netty/netty/blob/0140f42a4f2aecf5925d1ae834a462b4c21a6c25/transport-classes-io_uring%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Furing%2FIoUringIoOps.java",
      "raw_url": "https://github.com/netty/netty/raw/0140f42a4f2aecf5925d1ae834a462b4c21a6c25/transport-classes-io_uring%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Furing%2FIoUringIoOps.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/transport-classes-io_uring%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Furing%2FIoUringIoOps.java?ref=0140f42a4f2aecf5925d1ae834a462b4c21a6c25",
      "patch": "@@ -229,7 +229,7 @@ public String toString() {\n      * @param data      the data\n      * @return          ops.\n      */\n-    public static IoUringIoOps newAsyncCancel(int fd, byte flags, long userData, short data) {\n+    static IoUringIoOps newAsyncCancel(int fd, byte flags, long userData, short data) {\n         // Best effort to cancel the\n         return new IoUringIoOps(Native.IORING_OP_ASYNC_CANCEL, flags, (short) 0, fd, 0, userData, 0, 0,\n                 data, (short) 0, (short) 0, 0, 0);\n@@ -243,7 +243,7 @@ public static IoUringIoOps newAsyncCancel(int fd, byte flags, long userData, sho\n      * @param data      the data\n      * @return          ops.\n      */\n-    public static IoUringIoOps newClose(int fd, byte flags, short data) {\n+    static IoUringIoOps newClose(int fd, byte flags, short data) {\n         return new IoUringIoOps(Native.IORING_OP_CLOSE, flags, (short) 0, fd, 0L, 0L, 0, 0, data,\n                 (short) 0, (short) 0, 0, 0);\n     }\n@@ -257,7 +257,7 @@ public static IoUringIoOps newClose(int fd, byte flags, short data) {\n      * @param data      the data\n      * @return          ops.\n      */\n-    public static IoUringIoOps newPollAdd(int fd, byte flags, int mask, short data) {\n+    static IoUringIoOps newPollAdd(int fd, byte flags, int mask, short data) {\n         return new IoUringIoOps(Native.IORING_OP_POLL_ADD, flags, (short) 0, fd, 0L, 0L, 0, mask, data,\n                 (short) 0, (short) 0, 0, 0);\n     }\n@@ -271,7 +271,7 @@ public static IoUringIoOps newPollAdd(int fd, byte flags, int mask, short data)\n      * @param data      the data\n      * @return          ops.\n      */\n-    public static IoUringIoOps newSendmsg(int fd, byte flags, int msgFlags, long address, short data) {\n+    static IoUringIoOps newSendmsg(int fd, byte flags, int msgFlags, long address, short data) {\n         return new IoUringIoOps(Native.IORING_OP_SENDMSG, flags, (short) 0, fd, 0L, address, 1, msgFlags, data,\n                 (short) 0, (short) 0, 0, 0);\n     }\n@@ -285,7 +285,7 @@ public static IoUringIoOps newSendmsg(int fd, byte flags, int msgFlags, long add\n      * @param data                  the data\n      * @return                      ops.\n      */\n-    public static IoUringIoOps newConnect(int fd, byte flags, long remoteMemoryAddress, short data) {\n+    static IoUringIoOps newConnect(int fd, byte flags, long remoteMemoryAddress, short data) {\n         return new IoUringIoOps(Native.IORING_OP_CONNECT, flags, (short) 0, fd, Native.SIZEOF_SOCKADDR_STORAGE,\n                 remoteMemoryAddress, 0, 0, data, (short) 0, (short) 0, 0, 0);\n     }\n@@ -300,7 +300,7 @@ public static IoUringIoOps newConnect(int fd, byte flags, long remoteMemoryAddre\n      * @param data      the data\n      * @return          ops.\n      */\n-    public static IoUringIoOps newPollRemove(int fd, byte flags, long userData, short data) {\n+    static IoUringIoOps newPollRemove(int fd, byte flags, long userData, short data) {\n         return new IoUringIoOps(Native.IORING_OP_POLL_REMOVE, flags, (short) 0, fd, 0, userData, 0, 0, data,\n                 (short) 0, (short) 0, 0, 0);\n     }\n@@ -316,7 +316,7 @@ public static IoUringIoOps newPollRemove(int fd, byte flags, long userData, shor\n      * @param data                                  the data\n      * @return                                      ops.\n      */\n-    public static IoUringIoOps newAccept(int fd, byte flags, int acceptFlags, long acceptedAddressMemoryAddress,\n+    static IoUringIoOps newAccept(int fd, byte flags, int acceptFlags, long acceptedAddressMemoryAddress,\n                                          long acceptedAddressLengthMemoryAddress, short data) {\n \n         return new IoUringIoOps(Native.IORING_OP_ACCEPT, flags, (short) 0, fd, acceptedAddressLengthMemoryAddress,\n@@ -334,7 +334,7 @@ public static IoUringIoOps newAccept(int fd, byte flags, int acceptFlags, long a\n      * @param data                                  the data\n      * @return                                      ops.\n      */\n-    public static IoUringIoOps newWritev(int fd, byte flags, int writevFlags, long memoryAddress,\n+    static IoUringIoOps newWritev(int fd, byte flags, int writevFlags, long memoryAddress,\n                                          int length, short data) {\n         return new IoUringIoOps(Native.IORING_OP_WRITEV, flags, (short) 0, fd,\n                 0, memoryAddress, length, writevFlags, data, (short) 0, (short) 0, 0, 0);\n@@ -351,7 +351,7 @@ public static IoUringIoOps newWritev(int fd, byte flags, int writevFlags, long m\n      * @param data                                  the data\n      * @return                                      ops.\n      */\n-    public static IoUringIoOps newWrite(\n+    static IoUringIoOps newWrite(\n             int fd, byte flags, int writeFlags, long memoryAddress, int length, short data) {\n         return new IoUringIoOps(Native.IORING_OP_WRITE, flags, (short) 0, fd,\n                 0, memoryAddress, length, writeFlags, data, (short) 0, (short) 0, 0, 0);\n@@ -368,7 +368,7 @@ public static IoUringIoOps newWrite(\n      * @param data                                  the data\n      * @return                                      ops.\n      */\n-    public static IoUringIoOps newRecv(\n+    static IoUringIoOps newRecv(\n             int fd, byte flags, int recvFlags, long memoryAddress, int length, short data) {\n         return new IoUringIoOps(Native.IORING_OP_RECV, flags, (short) 0, fd,\n                 0, memoryAddress, length, recvFlags, data, (short) 0, (short) 0, 0, 0);\n@@ -384,7 +384,7 @@ public static IoUringIoOps newRecv(\n      * @param data                                  the data\n      * @return                                      ops.\n      */\n-    public static IoUringIoOps newRecvmsg(int fd, byte flags, int msgFlags, long memoryAddress, short data) {\n+    static IoUringIoOps newRecvmsg(int fd, byte flags, int msgFlags, long memoryAddress, short data) {\n         return new IoUringIoOps(\n                 Native.IORING_OP_RECVMSG, flags, (short) 0, fd, 0L, memoryAddress, 1, msgFlags, data,\n                 (short) 0, (short) 0, 0, 0);\n@@ -401,7 +401,7 @@ public static IoUringIoOps newRecvmsg(int fd, byte flags, int msgFlags, long mem\n      * @param data                                  the data\n      * @return                                      ops.\n      */\n-    public static IoUringIoOps newSend(\n+    static IoUringIoOps newSend(\n             int fd, byte flags, int sendFlags, long memoryAddress, int length, short data) {\n         return new IoUringIoOps(Native.IORING_OP_SEND, flags, (short) 0, fd,\n                 memoryAddress, 0L, length, sendFlags, data, (short) 0, (short) 0, 0, 0);\n@@ -416,7 +416,7 @@ public static IoUringIoOps newSend(\n      * @param data                                  the data\n      * @return                                      ops.\n      */\n-    public static IoUringIoOps newShutdown(int fd, byte flags, int how, short data) {\n+    static IoUringIoOps newShutdown(int fd, byte flags, int how, short data) {\n         return new IoUringIoOps(Native.IORING_OP_SHUTDOWN, flags, (short) 0, fd, 0, 0, how, 0, data,\n                 (short) 0, (short) 0, 0, 0);\n     }\n@@ -434,7 +434,7 @@ public static IoUringIoOps newShutdown(int fd, byte flags, int how, short data)\n      * @param data                                      the data\n      * @return                                          ops.\n      */\n-    public static IoUringIoOps newSplice(int fd_in, long off_in,\n+    static IoUringIoOps newSplice(int fd_in, long off_in,\n                                          int fd_out, long off_out,\n                                          int nbytes,\n                                          int splice_flags,",
      "parent_sha": "cd98d5572522013362b551163008d9a73d137bd1"
    }
  },
  {
    "oid": "60529ac3ee31f72bd07f2a18f869666e42a26117",
    "message": "Fix checkstyle",
    "date": "2013-07-20T06:09:08Z",
    "url": "https://github.com/netty/netty/commit/60529ac3ee31f72bd07f2a18f869666e42a26117",
    "details": {
      "sha": "7daa5fb9fe0c9467195b11bc8efaeb9419a87f03",
      "filename": "transport/src/main/java/io/netty/channel/ChannelPropertyAccess.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/netty/netty/blob/60529ac3ee31f72bd07f2a18f869666e42a26117/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FChannelPropertyAccess.java",
      "raw_url": "https://github.com/netty/netty/raw/60529ac3ee31f72bd07f2a18f869666e42a26117/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FChannelPropertyAccess.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FChannelPropertyAccess.java?ref=60529ac3ee31f72bd07f2a18f869666e42a26117",
      "patch": "@@ -67,8 +67,8 @@ interface ChannelPropertyAccess {\n      * </p>\n      * <p>\n      * Be aware that the returned {@link ChannelPromise} will not support most operations and should only be used\n-     * if you want to save an object allocation for every write operation. You will not be able to detect if the operation\n-     * was complete, only if it failed as the implementation will call\n+     * if you want to save an object allocation for every write operation. You will not be able to detect if the\n+     * operation  was complete, only if it failed as the implementation will call\n      * {@link ChannelPipeline#fireExceptionCaught(Throwable)} in this case.\n      * </p>\n      * <strong>Be aware this is an expert feature and should be used with care!</strong>",
      "parent_sha": "674f4bce51047a19000ac1074bb934414511e9aa"
    }
  },
  {
    "oid": "2a9d392a31c0786e99a9189ddb9f66b0dd4921b2",
    "message": "Motivation:\n\nFix a spell mistake.\n\nModifications:\n\nChange 'treshold' to 'threshold'\n\nResult:\n\nThe spellchecker warnings of the IDE disappeared.",
    "date": "2016-02-01T11:03:06Z",
    "url": "https://github.com/netty/netty/commit/2a9d392a31c0786e99a9189ddb9f66b0dd4921b2",
    "details": {
      "sha": "8a794706f0bc42a8800d96d0629045afc6affd54",
      "filename": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/netty/netty/blob/2a9d392a31c0786e99a9189ddb9f66b0dd4921b2/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2Fwebsocketx%2FWebSocket08FrameEncoder.java",
      "raw_url": "https://github.com/netty/netty/raw/2a9d392a31c0786e99a9189ddb9f66b0dd4921b2/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2Fwebsocketx%2FWebSocket08FrameEncoder.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2Fwebsocketx%2FWebSocket08FrameEncoder.java?ref=2a9d392a31c0786e99a9189ddb9f66b0dd4921b2",
      "patch": "@@ -82,12 +82,12 @@ public class WebSocket08FrameEncoder extends MessageToMessageEncoder<WebSocketFr\n     private static final byte OPCODE_PONG = 0xA;\n \n     /**\n-     * The size treshold for gathering writes. Non-Masked messages bigger than this size will be be sent fragmented as\n+     * The size thsreshold for gathering writes. Non-Masked messages bigger than this size will be be sent fragmented as\n      * a header and a content ByteBuf whereas messages smaller than the size will be merged into a single buffer and\n      * sent at once.<br>\n      * Masked messages will always be sent at once.\n      */\n-    private static final int GATHERING_WRITE_TRESHOLD = 1024;\n+    private static final int GATHERING_WRITE_THRESHOLD = 1024;\n \n     private final boolean maskPayload;\n \n@@ -148,7 +148,7 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object\n             int maskLength = maskPayload ? 4 : 0;\n             if (length <= 125) {\n                 int size = 2 + maskLength;\n-                if (maskPayload || length <= GATHERING_WRITE_TRESHOLD) {\n+                if (maskPayload || length <= GATHERING_WRITE_THRESHOLD) {\n                     size += length;\n                 }\n                 buf = ctx.alloc().buffer(size);\n@@ -157,7 +157,7 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object\n                 buf.writeByte(b);\n             } else if (length <= 0xFFFF) {\n                 int size = 4 + maskLength;\n-                if (maskPayload || length <= GATHERING_WRITE_TRESHOLD) {\n+                if (maskPayload || length <= GATHERING_WRITE_THRESHOLD) {\n                     size += length;\n                 }\n                 buf = ctx.alloc().buffer(size);\n@@ -167,7 +167,7 @@ protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object\n                 buf.writeByte(length & 0xFF);\n             } else {\n                 int size = 10 + maskLength;\n-                if (maskPayload || length <= GATHERING_WRITE_TRESHOLD) {\n+                if (maskPayload || length <= GATHERING_WRITE_THRESHOLD) {\n                     size += length;\n                 }\n                 buf = ctx.alloc().buffer(size);",
      "parent_sha": "210ebe13541900807d43a8af1e4941cf40bbb9e5"
    }
  },
  {
    "oid": "2d96b32155dd56f8ffcbcc2a571652df812fb06b",
    "message": "Clean-up ChannelOutboundBufferTest\n\n- partial port of 136e1ebba8a3965dab888d21aaa292ce921c704d",
    "date": "2014-02-13T22:50:11Z",
    "url": "https://github.com/netty/netty/commit/2d96b32155dd56f8ffcbcc2a571652df812fb06b",
    "details": {
      "sha": "e4abbf6b102ca86b7b77dd1032efa0689c06df40",
      "filename": "transport/src/test/java/io/netty/channel/ChannelOutboundBufferTest.java",
      "status": "modified",
      "additions": 12,
      "deletions": 95,
      "changes": 107,
      "blob_url": "https://github.com/netty/netty/blob/2d96b32155dd56f8ffcbcc2a571652df812fb06b/transport%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fchannel%2FChannelOutboundBufferTest.java",
      "raw_url": "https://github.com/netty/netty/raw/2d96b32155dd56f8ffcbcc2a571652df812fb06b/transport%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fchannel%2FChannelOutboundBufferTest.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/transport%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fchannel%2FChannelOutboundBufferTest.java?ref=2d96b32155dd56f8ffcbcc2a571652df812fb06b",
      "patch": "@@ -17,10 +17,10 @@\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.CompositeByteBuf;\n+import io.netty.channel.embedded.EmbeddedChannel;\n import io.netty.util.CharsetUtil;\n import org.junit.Test;\n \n-import java.net.SocketAddress;\n import java.nio.ByteBuffer;\n \n import static io.netty.buffer.Unpooled.*;\n@@ -30,7 +30,7 @@ public class ChannelOutboundBufferTest {\n \n     @Test\n     public void testEmptyNioBuffers() {\n-        TestChannel channel = new TestChannel();\n+        AbstractChannel channel = new EmbeddedChannel();\n         ChannelOutboundBuffer buffer = ChannelOutboundBuffer.newInstance(channel);\n         assertEquals(0, buffer.nioBufferCount());\n         ByteBuffer[] buffers = buffer.nioBuffers();\n@@ -44,8 +44,7 @@ public void testEmptyNioBuffers() {\n \n     @Test\n     public void testNioBuffersSingleBacked() {\n-        TestChannel channel = new TestChannel();\n-\n+        AbstractChannel channel = new EmbeddedChannel();\n         ChannelOutboundBuffer buffer = ChannelOutboundBuffer.newInstance(channel);\n         assertEquals(0, buffer.nioBufferCount());\n         ByteBuffer[] buffers = buffer.nioBuffers();\n@@ -69,7 +68,7 @@ public void testNioBuffersSingleBacked() {\n         assertEquals(\"Should still be 0 as not flushed yet\", 1, buffer.nioBufferCount());\n         for (int i = 0;  i < buffers.length; i++) {\n             if (i == 0) {\n-                assertEquals(buffers[i], nioBuf);\n+                assertEquals(buffers[0], nioBuf);\n             } else {\n                 assertNull(buffers[i]);\n             }\n@@ -79,34 +78,32 @@ public void testNioBuffersSingleBacked() {\n \n     @Test\n     public void testNioBuffersExpand() {\n-        TestChannel channel = new TestChannel();\n-\n+        AbstractChannel channel = new EmbeddedChannel();\n         ChannelOutboundBuffer buffer = ChannelOutboundBuffer.newInstance(channel);\n \n         ByteBuf buf = directBuffer().writeBytes(\"buf1\".getBytes(CharsetUtil.US_ASCII));\n         for (int i = 0; i < 64; i++) {\n             buffer.addMessage(buf.copy(), channel.voidPromise());\n         }\n-        ByteBuffer[] buffers = buffer.nioBuffers();\n+        ByteBuffer[] nioBuffers = buffer.nioBuffers();\n         assertEquals(\"Should still be 0 as not flushed yet\", 0, buffer.nioBufferCount());\n-        for (ByteBuffer b: buffers) {\n+        for (ByteBuffer b: nioBuffers) {\n             assertNull(b);\n         }\n         buffer.addFlush();\n-        buffers = buffer.nioBuffers();\n-        assertEquals(64, buffers.length);\n+        nioBuffers = buffer.nioBuffers();\n+        assertEquals(64, nioBuffers.length);\n         assertEquals(64, buffer.nioBufferCount());\n-        for (int i = 0;  i < buffers.length; i++) {\n-            assertEquals(buffers[i], buf.internalNioBuffer(0, buf.readableBytes()));\n+        for (ByteBuffer nioBuf: nioBuffers) {\n+            assertEquals(nioBuf, buf.internalNioBuffer(0, buf.readableBytes()));\n         }\n         release(buffer);\n         buf.release();\n     }\n \n     @Test\n     public void testNioBuffersExpand2() {\n-        TestChannel channel = new TestChannel();\n-\n+        AbstractChannel channel = new EmbeddedChannel();\n         ChannelOutboundBuffer buffer = ChannelOutboundBuffer.newInstance(channel);\n \n         CompositeByteBuf comp = compositeBuffer(256);\n@@ -143,84 +140,4 @@ private static void release(ChannelOutboundBuffer buffer) {\n             }\n         }\n     }\n-\n-    private static final class TestChannel extends AbstractChannel {\n-        private final ChannelConfig config = new DefaultChannelConfig(this);\n-\n-        TestChannel() {\n-            super(null);\n-        }\n-\n-        @Override\n-        protected AbstractUnsafe newUnsafe() {\n-            return new TestUnsafe();\n-        }\n-\n-        @Override\n-        protected boolean isCompatible(EventLoop loop) {\n-            return false;\n-        }\n-\n-        @Override\n-        protected SocketAddress localAddress0() {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        protected SocketAddress remoteAddress0() {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        protected void doBind(SocketAddress localAddress) throws Exception {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        protected void doDisconnect() throws Exception {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        protected void doClose() throws Exception {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        protected void doBeginRead() throws Exception {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        protected void doWrite(ChannelOutboundBuffer in) throws Exception {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        public ChannelConfig config() {\n-            return config;\n-        }\n-\n-        @Override\n-        public boolean isOpen() {\n-            return true;\n-        }\n-\n-        @Override\n-        public boolean isActive() {\n-            return true;\n-        }\n-\n-        @Override\n-        public ChannelMetadata metadata() {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        final class TestUnsafe extends AbstractUnsafe {\n-            @Override\n-            public void connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {\n-                throw new UnsupportedOperationException();\n-            }\n-        }\n-    }\n }",
      "parent_sha": "a65f097d53f8d1827556d4d1b41d8432d3c664b5"
    }
  },
  {
    "oid": "daa1f5378f6330ae8ee19ad775e2fb63d7ec8eeb",
    "message": "Fix assertation of params (#602)\n\nMotivation:\r\n\r\nThe asseertation of the params was not correct and so could fail\r\nsometimes\r\n\r\nModifications:\r\n\r\nFix assert\r\n\r\nResult:\r\n\r\nTestsuite passes all the time again",
    "date": "2023-11-02T09:59:00Z",
    "url": "https://github.com/netty/netty/commit/daa1f5378f6330ae8ee19ad775e2fb63d7ec8eeb",
    "details": {
      "sha": "a3b8c25bddf43d3d1f6e91f2a4d928ce9834d898",
      "filename": "codec-native-quic/src/test/java/io/netty/incubator/codec/quic/QuicTransportParametersTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/daa1f5378f6330ae8ee19ad775e2fb63d7ec8eeb/codec-native-quic%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fincubator%2Fcodec%2Fquic%2FQuicTransportParametersTest.java",
      "raw_url": "https://github.com/netty/netty/raw/daa1f5378f6330ae8ee19ad775e2fb63d7ec8eeb/codec-native-quic%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fincubator%2Fcodec%2Fquic%2FQuicTransportParametersTest.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-native-quic%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fincubator%2Fcodec%2Fquic%2FQuicTransportParametersTest.java?ref=daa1f5378f6330ae8ee19ad775e2fb63d7ec8eeb",
      "patch": "@@ -89,6 +89,6 @@ private static void assertTransportParameters(QuicTransportParameters parameters\n         assertThat(parameters.maxAckDelay(), greaterThanOrEqualTo(1L));\n         assertFalse(parameters.disableActiveMigration());\n         assertThat(parameters.activeConnIdLimit(), greaterThanOrEqualTo(1L));\n-        assertThat(parameters.maxDatagramFrameSize(), greaterThanOrEqualTo(1L));\n+        assertThat(parameters.maxDatagramFrameSize(), greaterThanOrEqualTo(0L));\n     }\n }",
      "parent_sha": "b9e04c88b7ea166b870febec1df71d79dc883810"
    }
  },
  {
    "oid": "950da2eae1471c436424555f1d79bc08d3ba38c3",
    "message": "Allow MessageAggregator to disallow non-empty content\n\nMotivation:\n\nA user sometimes just want the aggregated message has no content at\nall. (e.g. A user only wants HTTP GET requests.)\n\nModifications:\n\n- Do not raise IllegalArgumentException even if a user specified\n  the maxContentLength of 0\n\nResult:\n\nA user can disallow a message with non-empty content.",
    "date": "2015-06-10T03:06:27Z",
    "url": "https://github.com/netty/netty/commit/950da2eae1471c436424555f1d79bc08d3ba38c3",
    "details": {
      "sha": "353d3144cd8ca4c3442c0b0ee8c962ed36d572b4",
      "filename": "codec/src/main/java/io/netty/handler/codec/MessageAggregator.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/netty/netty/blob/950da2eae1471c436424555f1d79bc08d3ba38c3/codec%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2FMessageAggregator.java",
      "raw_url": "https://github.com/netty/netty/raw/950da2eae1471c436424555f1d79bc08d3ba38c3/codec%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2FMessageAggregator.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2FMessageAggregator.java?ref=950da2eae1471c436424555f1d79bc08d3ba38c3",
      "patch": "@@ -79,8 +79,8 @@ protected MessageAggregator(int maxContentLength, Class<? extends I> inboundMess\n     }\n \n     private static void validateMaxContentLength(int maxContentLength) {\n-        if (maxContentLength <= 0) {\n-            throw new IllegalArgumentException(\"maxContentLength must be a positive integer: \" + maxContentLength);\n+        if (maxContentLength < 0) {\n+            throw new IllegalArgumentException(\"maxContentLength: \" + maxContentLength + \" (expected: >= 0)\");\n         }\n     }\n ",
      "parent_sha": "73d79a4b3baf0bad2f04bc8cc60573745befbb15"
    }
  },
  {
    "oid": "794f805a30ce02edd5c4701a36cd0d41f972928e",
    "message": "better explanation of what uptime example does",
    "date": "2009-09-10T05:43:14Z",
    "url": "https://github.com/netty/netty/commit/794f805a30ce02edd5c4701a36cd0d41f972928e",
    "details": {
      "sha": "ef2c1d27e557c486700558076d98b8218d9fd663",
      "filename": "src/main/java/org/jboss/netty/example/uptime/UptimeClient.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/netty/netty/blob/794f805a30ce02edd5c4701a36cd0d41f972928e/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fexample%2Fuptime%2FUptimeClient.java",
      "raw_url": "https://github.com/netty/netty/raw/794f805a30ce02edd5c4701a36cd0d41f972928e/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fexample%2Fuptime%2FUptimeClient.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fexample%2Fuptime%2FUptimeClient.java?ref=794f805a30ce02edd5c4701a36cd0d41f972928e",
      "patch": "@@ -26,7 +26,9 @@\n \n \n /**\n- * Connects to a server periodically to measure the uptime of the server.\n+ * Connects to a server periodically to measure and print the uptime of the\n+ * server.  This example demonstrates how to implement reliable reconnection\n+ * mechanism in Netty.\n  *\n  * @author The Netty Project (netty-dev@lists.jboss.org)\n  * @author Trustin Lee (tlee@redhat.com)",
      "parent_sha": "1b5a02a949ba5e1be607a8bec8540b1a0ac0eac0"
    }
  },
  {
    "oid": "3b0d843e599db95854e12d2d211405350f0c0399",
    "message": "Increased the default preallocation size for higher out of the box throughput",
    "date": "2010-02-18T02:47:09Z",
    "url": "https://github.com/netty/netty/commit/3b0d843e599db95854e12d2d211405350f0c0399",
    "details": {
      "sha": "f13866c569a4e0d16b95ea82f70e68ce66f34fdd",
      "filename": "src/main/java/org/jboss/netty/channel/socket/nio/DirectBufferPool.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/3b0d843e599db95854e12d2d211405350f0c0399/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fchannel%2Fsocket%2Fnio%2FDirectBufferPool.java",
      "raw_url": "https://github.com/netty/netty/raw/3b0d843e599db95854e12d2d211405350f0c0399/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fchannel%2Fsocket%2Fnio%2FDirectBufferPool.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fchannel%2Fsocket%2Fnio%2FDirectBufferPool.java?ref=3b0d843e599db95854e12d2d211405350f0c0399",
      "patch": "@@ -40,7 +40,7 @@ final class DirectBufferPool {\n                 0);\n \n         if (val <= 0) {\n-            val = 128 * 1024;\n+            val = 1048576;\n         } else {\n             logger.debug(\n                     \"Setting the preallocated buffer capacity to: \" + val);",
      "parent_sha": "3e21c7a7555a3173b2bdcd6b0de8ad07d007c72a"
    }
  },
  {
    "oid": "6c2eba79d70a532822a0e38092faa9783d90906b",
    "message": "[#452] CompactObjectInputStream fails to resolve interfaces",
    "date": "2012-07-13T04:02:09Z",
    "url": "https://github.com/netty/netty/commit/6c2eba79d70a532822a0e38092faa9783d90906b",
    "details": {
      "sha": "721a343ede7ae539feca59ee0ed74137e40ee28f",
      "filename": "codec/src/main/java/io/netty/handler/codec/serialization/CompactObjectOutputStream.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/netty/netty/blob/6c2eba79d70a532822a0e38092faa9783d90906b/codec%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fserialization%2FCompactObjectOutputStream.java",
      "raw_url": "https://github.com/netty/netty/raw/6c2eba79d70a532822a0e38092faa9783d90906b/codec%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fserialization%2FCompactObjectOutputStream.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fserialization%2FCompactObjectOutputStream.java?ref=6c2eba79d70a532822a0e38092faa9783d90906b",
      "patch": "@@ -37,7 +37,8 @@ protected void writeStreamHeader() throws IOException {\n     @Override\n     protected void writeClassDescriptor(ObjectStreamClass desc) throws IOException {\n         Class<?> clazz = desc.forClass();\n-        if (clazz.isPrimitive() || clazz.isArray() || desc.getSerialVersionUID() == 0) {\n+        if (clazz.isPrimitive() || clazz.isArray() || clazz.isInterface() ||\n+            desc.getSerialVersionUID() == 0) {\n             write(TYPE_FAT_DESCRIPTOR);\n             super.writeClassDescriptor(desc);\n         } else {",
      "parent_sha": "787f5b28b23651880a9385dbe4a3ffb648b3d47f"
    }
  },
  {
    "oid": "88838413c75a319ad76c9ebcb9b0deea262266e0",
    "message": "Javadocs and cleanup intellij warnings",
    "date": "2012-12-27T22:02:13Z",
    "url": "https://github.com/netty/netty/commit/88838413c75a319ad76c9ebcb9b0deea262266e0",
    "details": {
      "sha": "ca8da2a4b46d7382cf027720dbc188f93e9fa9e2",
      "filename": "transport/src/main/java/io/netty/channel/socket/oio/OioSctpChannel.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/netty/netty/blob/88838413c75a319ad76c9ebcb9b0deea262266e0/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Fsocket%2Foio%2FOioSctpChannel.java",
      "raw_url": "https://github.com/netty/netty/raw/88838413c75a319ad76c9ebcb9b0deea262266e0/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Fsocket%2Foio%2FOioSctpChannel.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Fsocket%2Foio%2FOioSctpChannel.java?ref=88838413c75a319ad76c9ebcb9b0deea262266e0",
      "patch": "@@ -163,7 +163,7 @@ protected int doReadMessages(MessageBuf<Object> buf) throws Exception {\n \n         Set<SelectionKey> reableKeys = readSelector.selectedKeys();\n         try {\n-            for (SelectionKey _ : reableKeys) {\n+            for (SelectionKey ignored : reableKeys) {\n                 ByteBuffer data = ByteBuffer.allocate(config().getReceiveBufferSize());\n                 MessageInfo messageInfo = ch.receive(data, null, notificationHandler);\n                 if (messageInfo == null) {\n@@ -194,7 +194,7 @@ protected void doWriteMessages(MessageBuf<Object> buf) throws Exception {\n         final int selectedKeys = writeSelector.select(SO_TIMEOUT);\n         if (selectedKeys > 0) {\n             final Set<SelectionKey> writableKeys = writeSelector.selectedKeys();\n-            for (SelectionKey _ : writableKeys) {\n+            for (SelectionKey ignored : writableKeys) {\n                 SctpMessage packet = (SctpMessage) buf.poll();\n                 if (packet == null) {\n                     return;\n@@ -339,7 +339,7 @@ protected void doClose() throws Exception {\n         ch.close();\n     }\n \n-    private void closeSelector(String selectorName, Selector selector) {\n+    private static void closeSelector(String selectorName, Selector selector) {\n         try {\n             selector.close();\n         } catch (IOException e) {",
      "parent_sha": "a20aba87ab37236f25f53957e4f75345697ededd"
    }
  },
  {
    "oid": "9008e72c2b6855d024db54f283cb627bb322fec7",
    "message": "Fix javadoc\n\nRemoves unmatched brace",
    "date": "2016-09-12T13:43:10Z",
    "url": "https://github.com/netty/netty/commit/9008e72c2b6855d024db54f283cb627bb322fec7",
    "details": {
      "sha": "cb0a0bdb05ed5ee62fa8083c5556793fed1dfb37",
      "filename": "transport/src/main/java/io/netty/channel/AbstractChannel.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/9008e72c2b6855d024db54f283cb627bb322fec7/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FAbstractChannel.java",
      "raw_url": "https://github.com/netty/netty/raw/9008e72c2b6855d024db54f283cb627bb322fec7/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FAbstractChannel.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FAbstractChannel.java?ref=9008e72c2b6855d024db54f283cb627bb322fec7",
      "patch": "@@ -364,7 +364,7 @@ public final int compareTo(Channel o) {\n \n     /**\n      * Returns the {@link String} representation of this channel.  The returned\n-     * string contains the {@linkplain #hashCode()} ID}, {@linkplain #localAddress() local address},\n+     * string contains the {@linkplain #hashCode() ID}, {@linkplain #localAddress() local address},\n      * and {@linkplain #remoteAddress() remote address} of this channel for\n      * easier identification.\n      */",
      "parent_sha": "245fb52c901a4de59d9444757fa5672a16bbbeec"
    }
  },
  {
    "oid": "fb46d46fc9be2de5fb42453c576e4d9b2abbddb3",
    "message": "Fix NPE when ensureAvailability() check in unit test fails (#468)\n\nMotivation:\r\n\r\nThere was a NPE thrown if ensureAvailability() did throw during tests.\r\n\r\nModifications:\r\n\r\nAdd missing null check\r\n\r\nResult:\r\n\r\nNo NPE",
    "date": "2023-01-20T22:08:09Z",
    "url": "https://github.com/netty/netty/commit/fb46d46fc9be2de5fb42453c576e4d9b2abbddb3",
    "details": {
      "sha": "aac5658963bbf080794ba11cf3bdf5b28ffca90f",
      "filename": "codec-native-quic/src/test/java/io/netty/incubator/codec/quic/AbstractQuicTest.java",
      "status": "modified",
      "additions": 6,
      "deletions": 3,
      "changes": 9,
      "blob_url": "https://github.com/netty/netty/blob/fb46d46fc9be2de5fb42453c576e4d9b2abbddb3/codec-native-quic%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fincubator%2Fcodec%2Fquic%2FAbstractQuicTest.java",
      "raw_url": "https://github.com/netty/netty/raw/fb46d46fc9be2de5fb42453c576e4d9b2abbddb3/codec-native-quic%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fincubator%2Fcodec%2Fquic%2FAbstractQuicTest.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-native-quic%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fincubator%2Fcodec%2Fquic%2FAbstractQuicTest.java?ref=fb46d46fc9be2de5fb42453c576e4d9b2abbddb3",
      "patch": "@@ -35,9 +35,12 @@ public static void ensureAvailability() {\n \n     @AfterAll\n     public static void shutdownExecutor() {\n-        for (Executor executor: executors) {\n-            if (executor instanceof ExecutorService) {\n-                ((ExecutorService) executor).shutdown();\n+        // Executors might be null if ensureAvailability() throws\n+        if (executors != null) {\n+            for (Executor executor : executors) {\n+                if (executor instanceof ExecutorService) {\n+                    ((ExecutorService) executor).shutdown();\n+                }\n             }\n         }\n     }",
      "parent_sha": "93836004d44a9aba8c0b2c706e8550de6c7b8ef7"
    }
  },
  {
    "oid": "49f548bc5df84a37b9f78334dca38c1815267ce2",
    "message": "Updated documentation",
    "date": "2010-02-17T08:24:25Z",
    "url": "https://github.com/netty/netty/commit/49f548bc5df84a37b9f78334dca38c1815267ce2",
    "details": {
      "sha": "d6305be865b26eea23d30eaa373bced33ad49501",
      "filename": "src/main/java/org/jboss/netty/channel/ChannelPipeline.java",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/netty/netty/blob/49f548bc5df84a37b9f78334dca38c1815267ce2/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fchannel%2FChannelPipeline.java",
      "raw_url": "https://github.com/netty/netty/raw/49f548bc5df84a37b9f78334dca38c1815267ce2/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fchannel%2FChannelPipeline.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fchannel%2FChannelPipeline.java?ref=49f548bc5df84a37b9f78334dca38c1815267ce2",
      "patch": "@@ -35,10 +35,11 @@\n  * and how the {@link ChannelHandler}s in the pipeline interact with each other.\n  *\n  * <h3>Creation of a pipeline</h3>\n- * <p>\n- * For each new channel, a new pipeline must be created.  If a new pipeline is\n- * attached to a channel, the coupling is permanent; the channel cannot attach\n- * another pipeline to it nor detach the current pipeline from it.\n+ *\n+ * For each new channel, a new pipeline must be created and attached to the\n+ * channel.  Once attached, the coupling between the channel and the pipeline\n+ * is permanent; the channel cannot attach another pipeline to it nor detach\n+ * the current pipeline from it.\n  * <p>\n  * The recommended way to create a new pipeline is to use the helper methods in\n  * {@link Channels} rather than calling an individual implementation's\n@@ -49,7 +50,7 @@\n  * </pre>\n  *\n  * <h3>How an event flows in a pipeline</h3>\n- * <p>\n+ *\n  * The following diagram describes how {@link ChannelEvent}s are processed by\n  * {@link ChannelHandler}s in a {@link ChannelPipeline} typically.\n  * A {@link ChannelEvent} can be handled by either a {@link ChannelUpstreamHandler}",
      "parent_sha": "8841f6897f6209d40b3d0379adf32f348ac1100e"
    }
  },
  {
    "oid": "b9bae2b5e4bf32f6db783664a02e1d22ba4159db",
    "message": "Disable the timeout of some tests in SocketEchoTest to find out why it is hanging in CI",
    "date": "2013-07-17T07:02:50Z",
    "url": "https://github.com/netty/netty/commit/b9bae2b5e4bf32f6db783664a02e1d22ba4159db",
    "details": {
      "sha": "c00fa24b9fc81478315288cd805e805878151400",
      "filename": "testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketEchoTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/netty/netty/blob/b9bae2b5e4bf32f6db783664a02e1d22ba4159db/testsuite%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Ftestsuite%2Ftransport%2Fsocket%2FSocketEchoTest.java",
      "raw_url": "https://github.com/netty/netty/raw/b9bae2b5e4bf32f6db783664a02e1d22ba4159db/testsuite%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Ftestsuite%2Ftransport%2Fsocket%2FSocketEchoTest.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/testsuite%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Ftestsuite%2Ftransport%2Fsocket%2FSocketEchoTest.java?ref=b9bae2b5e4bf32f6db783664a02e1d22ba4159db",
      "patch": "@@ -67,7 +67,7 @@ public void testSimpleEcho(ServerBootstrap sb, Bootstrap cb) throws Throwable {\n         testSimpleEcho0(sb, cb, false, false);\n     }\n \n-    @Test(timeout = 30000)\n+    @Test//(timeout = 30000)\n     public void testSimpleEchoWithAdditionalExecutor() throws Throwable {\n         run();\n     }\n@@ -76,7 +76,7 @@ public void testSimpleEchoWithAdditionalExecutor(ServerBootstrap sb, Bootstrap c\n         testSimpleEcho0(sb, cb, true, false);\n     }\n \n-    @Test(timeout = 30000)\n+    @Test//(timeout = 30000)\n     public void testSimpleEchoWithVoidPromise() throws Throwable {\n         run();\n     }",
      "parent_sha": "8e71186153d2d1c01de32684584bed6495347cd3"
    }
  },
  {
    "oid": "e50075508611e3cdabf60f37d9ba52f0be46c414",
    "message": "Remove double comparing of content out of the DefaultHttp2GoAwayFrame.equals()\n\nMotivation:\nIn `DefaultHttp2GoAwayFrame.equals()` a content compared twice: explicitly and in the `super` method.\n\nModifications:\nRemove explicit content comparision.\nMake `hashCode()` consistent with `equals()`.\n\nResult:\nA `DefaultHttp2GoAwayFrame.equals()` work faster.",
    "date": "2017-09-07T06:30:43Z",
    "url": "https://github.com/netty/netty/commit/e50075508611e3cdabf60f37d9ba52f0be46c414",
    "details": {
      "sha": "77207673303fd6097f957df0510bc9ed58ce0f57",
      "filename": "codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2GoAwayFrame.java",
      "status": "modified",
      "additions": 2,
      "deletions": 4,
      "changes": 6,
      "blob_url": "https://github.com/netty/netty/blob/e50075508611e3cdabf60f37d9ba52f0be46c414/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FDefaultHttp2GoAwayFrame.java",
      "raw_url": "https://github.com/netty/netty/raw/e50075508611e3cdabf60f37d9ba52f0be46c414/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FDefaultHttp2GoAwayFrame.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FDefaultHttp2GoAwayFrame.java?ref=e50075508611e3cdabf60f37d9ba52f0be46c414",
      "patch": "@@ -160,15 +160,13 @@ public boolean equals(Object o) {\n             return false;\n         }\n         DefaultHttp2GoAwayFrame other = (DefaultHttp2GoAwayFrame) o;\n-        return super.equals(o) && errorCode == other.errorCode && content().equals(other.content())\n-            && extraStreamIds == other.extraStreamIds;\n+        return errorCode == other.errorCode && extraStreamIds == other.extraStreamIds && super.equals(other);\n     }\n \n     @Override\n     public int hashCode() {\n-        int hash = 237395317;\n+        int hash = super.hashCode();\n         hash = hash * 31 + (int) (errorCode ^ (errorCode >>> 32));\n-        hash = hash * 31 + content().hashCode();\n         hash = hash * 31 + extraStreamIds;\n         return hash;\n     }",
      "parent_sha": "870b5f5e4b4eef8ea3baf650fa9c592533b2fda2"
    }
  },
  {
    "oid": "e8f3c3534c5ef009c8863cee7674df0aa604a913",
    "message": "Some warning message to confirm that certificate authentication really took place",
    "date": "2010-01-25T11:50:08Z",
    "url": "https://github.com/netty/netty/commit/e8f3c3534c5ef009c8863cee7674df0aa604a913",
    "details": {
      "sha": "adc7d9cec6f1f37f79220791bc2b3021d624a4c5",
      "filename": "src/main/java/org/jboss/netty/example/securechat/SecureChatTrustManagerFactory.java",
      "status": "modified",
      "additions": 7,
      "deletions": 2,
      "changes": 9,
      "blob_url": "https://github.com/netty/netty/blob/e8f3c3534c5ef009c8863cee7674df0aa604a913/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fexample%2Fsecurechat%2FSecureChatTrustManagerFactory.java",
      "raw_url": "https://github.com/netty/netty/raw/e8f3c3534c5ef009c8863cee7674df0aa604a913/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fexample%2Fsecurechat%2FSecureChatTrustManagerFactory.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fexample%2Fsecurechat%2FSecureChatTrustManagerFactory.java?ref=e8f3c3534c5ef009c8863cee7674df0aa604a913",
      "patch": "@@ -43,15 +43,20 @@ public X509Certificate[] getAcceptedIssuers() {\n         }\n \n         public void checkClientTrusted(\n-                X509Certificate[] arg0, String arg1) throws CertificateException {\n+                X509Certificate[] chain, String authType) throws CertificateException {\n             // Always trust - it is an example.\n             // You should do something in the real world.\n+            // You will reach here only if you enabled client certificate auth.\n+            System.err.println(\n+                    \"UNKNOWN CLIENT CERTIFICATE: \" + chain[0].getSubjectDN());\n         }\n \n         public void checkServerTrusted(\n-                X509Certificate[] arg0, String arg1) throws CertificateException {\n+                X509Certificate[] chain, String authType) throws CertificateException {\n             // Always trust - it is an example.\n             // You should do something in the real world.\n+            System.err.println(\n+                    \"UNKNOWN SERVER CERTIFICATE: \" + chain[0].getSubjectDN());\n         }\n     };\n ",
      "parent_sha": "a8eda60857b8ad118327db0687b4b95a38f8f9f5"
    }
  },
  {
    "oid": "a3e41ba6eb118dde7657af9a95d6ce34424f76da",
    "message": "HttpConversionUtils avoid intermediate collection allocation\n\nModifications:\nHttpConversionUtil#toLowercaseMap requires an intermediate List to be allocated. This can be avoided with the recently added value iterator methods.\n\nModifications:\n- Use HttpHeaders#valueCharSequenceIterator instead of getAll\n\nResult:\nLess intermediate object allocation and copying.",
    "date": "2017-11-20T22:05:03Z",
    "url": "https://github.com/netty/netty/commit/a3e41ba6eb118dde7657af9a95d6ce34424f76da",
    "details": {
      "sha": "6841265d88b608059d21f7bcf0af62a708111266",
      "filename": "codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/netty/netty/blob/a3e41ba6eb118dde7657af9a95d6ce34424f76da/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FHttpConversionUtil.java",
      "raw_url": "https://github.com/netty/netty/raw/a3e41ba6eb118dde7657af9a95d6ce34424f76da/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FHttpConversionUtil.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FHttpConversionUtil.java?ref=a3e41ba6eb118dde7657af9a95d6ce34424f76da",
      "patch": "@@ -38,7 +38,6 @@\n \n import java.net.URI;\n import java.util.Iterator;\n-import java.util.List;\n import java.util.Map.Entry;\n \n import static io.netty.handler.codec.http.HttpScheme.HTTP;\n@@ -413,14 +412,13 @@ public static Http2Headers toHttp2Headers(HttpHeaders inHeaders, boolean validat\n         return out;\n     }\n \n-    private static CharSequenceMap<AsciiString> toLowercaseMap(List<String> values) {\n+    private static CharSequenceMap<AsciiString> toLowercaseMap(Iterator<? extends CharSequence> valuesIter,\n+                                                               int arraySizeHint) {\n         UnsupportedValueConverter<AsciiString> valueConverter = UnsupportedValueConverter.<AsciiString>instance();\n-        CharSequenceMap<AsciiString> result =\n-            new CharSequenceMap<AsciiString>(true, valueConverter, values.size());\n+        CharSequenceMap<AsciiString> result = new CharSequenceMap<AsciiString>(true, valueConverter, arraySizeHint);\n \n-        // we iterate because the underlying list is probably a linked list\n-        for (CharSequence value : values) {\n-            AsciiString lowerCased = AsciiString.of(value).toLowerCase();\n+        while (valuesIter.hasNext()) {\n+            AsciiString lowerCased = AsciiString.of(valuesIter.next()).toLowerCase();\n             try {\n                 int index = lowerCased.forEachByte(FIND_COMMA);\n                 if (index != -1) {\n@@ -429,7 +427,7 @@ private static CharSequenceMap<AsciiString> toLowercaseMap(List<String> values)\n                         result.add(lowerCased.subSequence(start, index, false).trim(), EMPTY_STRING);\n                         start = index + 1;\n                     } while (start < lowerCased.length() &&\n-                             (index = lowerCased.forEachByte(start, value.length() - start, FIND_COMMA)) != -1);\n+                             (index = lowerCased.forEachByte(start, lowerCased.length() - start, FIND_COMMA)) != -1);\n                     result.add(lowerCased.subSequence(start, lowerCased.length(), false).trim(), EMPTY_STRING);\n                 } else {\n                     result.add(lowerCased.trim(), EMPTY_STRING);\n@@ -445,8 +443,10 @@ private static CharSequenceMap<AsciiString> toLowercaseMap(List<String> values)\n \n     public static void toHttp2Headers(HttpHeaders inHeaders, Http2Headers out) {\n         Iterator<Entry<CharSequence, CharSequence>> iter = inHeaders.iteratorCharSequence();\n+        // Choose 8 as a default size because it is unlikely we will see more than 4 Connection headers values, but\n+        // still allowing for \"enough\" space in the map to reduce the chance of hash code collision.\n         CharSequenceMap<AsciiString> connectionBlacklist =\n-            toLowercaseMap(inHeaders.getAll(HttpHeaderNames.CONNECTION));\n+            toLowercaseMap(inHeaders.valueCharSequenceIterator(HttpHeaderNames.CONNECTION), 8);\n         while (iter.hasNext()) {\n             Entry<CharSequence, CharSequence> entry = iter.next();\n             final AsciiString aName = AsciiString.of(entry.getKey()).toLowerCase();",
      "parent_sha": "907ed79069584b6c4641bfe4bf9f64eea2c23564"
    }
  },
  {
    "oid": "c0396818cafc4d3b6a5c8230b9f91b180e813645",
    "message": "Print out the actual cause when an assertion failure happens during DatagramUnicastTest.testSimpleSendWithConnect\n\nMotivation:\n\nWe recently saw an assertion failure when running DatagramUnicastTest.testSimpleSendWithConnect.\n\nModifications:\n\n- Adding more debug infos\n- Ensure we always correctly release the buffers.\n\nResult:\n\nMore informations when tests fail.",
    "date": "2017-09-07T14:37:46Z",
    "url": "https://github.com/netty/netty/commit/c0396818cafc4d3b6a5c8230b9f91b180e813645",
    "details": {
      "sha": "26743ba8c705ee1cc1c4f470caf9af7c0f42541e",
      "filename": "testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java",
      "status": "modified",
      "additions": 64,
      "deletions": 50,
      "changes": 114,
      "blob_url": "https://github.com/netty/netty/blob/c0396818cafc4d3b6a5c8230b9f91b180e813645/testsuite%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Ftestsuite%2Ftransport%2Fsocket%2FDatagramUnicastTest.java",
      "raw_url": "https://github.com/netty/netty/raw/c0396818cafc4d3b6a5c8230b9f91b180e813645/testsuite%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Ftestsuite%2Ftransport%2Fsocket%2FDatagramUnicastTest.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/testsuite%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Ftestsuite%2Ftransport%2Fsocket%2FDatagramUnicastTest.java?ref=c0396818cafc4d3b6a5c8230b9f91b180e813645",
      "patch": "@@ -146,57 +146,65 @@ public void testSimpleSendWithConnect(Bootstrap sb, Bootstrap cb) throws Throwab\n     private void testSimpleSend0(Bootstrap sb, Bootstrap cb, ByteBuf buf, boolean bindClient,\n                                 final byte[] bytes, int count, WrapType wrapType)\n             throws Throwable {\n-        cb.handler(new SimpleChannelInboundHandler<Object>() {\n-            @Override\n-            public void channelRead0(ChannelHandlerContext ctx, Object msgs) throws Exception {\n-                // Nothing will be sent.\n-            }\n-        });\n+        Channel sc = null;\n+        Channel cc = null;\n \n-        final CountDownLatch latch = new CountDownLatch(count);\n-        Channel sc = setupServerChannel(sb, bytes, latch);\n-\n-        Channel cc;\n-        if (bindClient) {\n-            cc = cb.bind(newSocketAddress()).sync().channel();\n-        } else {\n-            cb.option(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION, true);\n-            cc = cb.register().sync().channel();\n-        }\n-        InetSocketAddress addr = (InetSocketAddress) sc.localAddress();\n-        for (int i = 0; i < count; i++) {\n-            switch (wrapType) {\n-                case DUP:\n-                    cc.write(new DatagramPacket(buf.retainedDuplicate(), addr));\n-                    break;\n-                case SLICE:\n-                    cc.write(new DatagramPacket(buf.retainedSlice(), addr));\n-                    break;\n-                case READ_ONLY:\n-                    cc.write(new DatagramPacket(buf.retain().asReadOnly(), addr));\n-                    break;\n-                case NONE:\n-                    cc.write(new DatagramPacket(buf.retain(), addr));\n-                    break;\n-                default:\n-                    throw new Error(\"unknown wrap type: \" + wrapType);\n+        try {\n+            cb.handler(new SimpleChannelInboundHandler<Object>() {\n+                @Override\n+                public void channelRead0(ChannelHandlerContext ctx, Object msgs) throws Exception {\n+                    // Nothing will be sent.\n+                }\n+            });\n+\n+            final CountDownLatch latch = new CountDownLatch(count);\n+            sc = setupServerChannel(sb, bytes, latch);\n+            if (bindClient) {\n+                cc = cb.bind(newSocketAddress()).sync().channel();\n+            } else {\n+                cb.option(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION, true);\n+                cc = cb.register().sync().channel();\n             }\n-        }\n-        // release as we used buf.retain() before\n-        buf.release();\n-        cc.flush();\n-        assertTrue(latch.await(10, TimeUnit.SECONDS));\n+            InetSocketAddress addr = (InetSocketAddress) sc.localAddress();\n+            for (int i = 0; i < count; i++) {\n+                switch (wrapType) {\n+                    case DUP:\n+                        cc.write(new DatagramPacket(buf.retainedDuplicate(), addr));\n+                        break;\n+                    case SLICE:\n+                        cc.write(new DatagramPacket(buf.retainedSlice(), addr));\n+                        break;\n+                    case READ_ONLY:\n+                        cc.write(new DatagramPacket(buf.retain().asReadOnly(), addr));\n+                        break;\n+                    case NONE:\n+                        cc.write(new DatagramPacket(buf.retain(), addr));\n+                        break;\n+                    default:\n+                        throw new Error(\"unknown wrap type: \" + wrapType);\n+                }\n+            }\n+            // release as we used buf.retain() before\n+            cc.flush();\n+            assertTrue(latch.await(10, TimeUnit.SECONDS));\n+        } finally {\n+            // release as we used buf.retain() before\n+            buf.release();\n \n-        sc.close().sync();\n-        cc.close().sync();\n+            closeChannel(cc);\n+            closeChannel(sc);\n+        }\n     }\n \n     private void testSimpleSendWithConnect(Bootstrap sb, Bootstrap cb, ByteBuf buf, final byte[] bytes, int count)\n             throws Throwable {\n-        for (WrapType type: WrapType.values()) {\n-            testSimpleSendWithConnect0(sb, cb, buf.retain(), bytes, count, type);\n+        try {\n+            for (WrapType type : WrapType.values()) {\n+                testSimpleSendWithConnect0(sb, cb, buf.retain(), bytes, count, type);\n+            }\n+        } finally {\n+            assertTrue(buf.release());\n         }\n-        assertTrue(buf.release());\n     }\n \n     private void testSimpleSendWithConnect0(Bootstrap sb, Bootstrap cb, ByteBuf buf, final byte[] bytes, int count,\n@@ -208,10 +216,11 @@ public void channelRead0(ChannelHandlerContext ctx, Object msgs) throws Exceptio\n             }\n         });\n \n-        final CountDownLatch latch = new CountDownLatch(count);\n-        Channel sc = setupServerChannel(sb, bytes, latch);\n+        Channel sc = null;\n         DatagramChannel cc = null;\n         try {\n+            final CountDownLatch latch = new CountDownLatch(count);\n+            sc = setupServerChannel(sb, bytes, latch);\n             cc = (DatagramChannel) cb.connect(sc.localAddress()).sync().channel();\n \n             for (int i = 0; i < count; i++) {\n@@ -243,15 +252,14 @@ public void channelRead0(ChannelHandlerContext ctx, Object msgs) throws Exceptio\n \n             ChannelFuture future = cc.writeAndFlush(\n                     buf.retain().duplicate()).awaitUninterruptibly();\n-            assertTrue(future.cause() instanceof NotYetConnectedException);\n+            assertTrue(\"NotYetConnectedException expected, got: \" + future.cause(),\n+                    future.cause() instanceof NotYetConnectedException);\n         } finally {\n             // release as we used buf.retain() before\n             buf.release();\n \n-            sc.close().sync();\n-            if (cc != null) {\n-                cc.close().sync();\n-            }\n+            closeChannel(cc);\n+            closeChannel(sc);\n         }\n     }\n \n@@ -276,4 +284,10 @@ public void channelRead0(ChannelHandlerContext ctx, DatagramPacket msg) throws E\n         });\n         return sb.bind(newSocketAddress()).sync().channel();\n     }\n+\n+    private static void closeChannel(Channel channel) throws Exception {\n+        if (channel != null) {\n+            channel.close().sync();\n+        }\n+    }\n }",
      "parent_sha": "a739d89792dbc21ad2f1384e018e547dadff2763"
    }
  },
  {
    "oid": "e7b7b77efc6e3e8ba99cd7028a7f51ce938a87ae",
    "message": "[#5013] Fix typo in DefaultStompFrame.toString() method.\n\nMotivation:\n\nDefaultStompFrame.toString() implementations returned a String that contained DefaultFullStompFrame.\n\nModifications:\n\nReplace DefaultFullStompFrame with DefaultStompFrame.\n\nResult:\n\nLess confusing and more correct return value of toString()",
    "date": "2016-03-23T09:48:13Z",
    "url": "https://github.com/netty/netty/commit/e7b7b77efc6e3e8ba99cd7028a7f51ce938a87ae",
    "details": {
      "sha": "5332ced4715ee886779943d5a609ac70571d7bca",
      "filename": "codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompFrame.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/e7b7b77efc6e3e8ba99cd7028a7f51ce938a87ae/codec-stomp%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fstomp%2FDefaultStompFrame.java",
      "raw_url": "https://github.com/netty/netty/raw/e7b7b77efc6e3e8ba99cd7028a7f51ce938a87ae/codec-stomp%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fstomp%2FDefaultStompFrame.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-stomp%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fstomp%2FDefaultStompFrame.java?ref=e7b7b77efc6e3e8ba99cd7028a7f51ce938a87ae",
      "patch": "@@ -94,7 +94,7 @@ public boolean release(int decrement) {\n \n     @Override\n     public String toString() {\n-        return \"DefaultFullStompFrame{\" +\n+        return \"DefaultStompFrame{\" +\n             \"command=\" + command +\n             \", headers=\" + headers +\n             \", content=\" + content.toString(CharsetUtil.UTF_8) +",
      "parent_sha": "ee4d2c4b74eef3208cac0e4e13f5916d886655f1"
    }
  },
  {
    "oid": "4b83eee1338ab018b802c3e195317fa83f785154",
    "message": "Fixed ServerBootstrap#group(EventLoopGroup, EventLoopGroup) javadoc",
    "date": "2015-02-16T10:21:50Z",
    "url": "https://github.com/netty/netty/commit/4b83eee1338ab018b802c3e195317fa83f785154",
    "details": {
      "sha": "6a02ea6e5749f141450211aac240a6ba76956a46",
      "filename": "transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/4b83eee1338ab018b802c3e195317fa83f785154/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fbootstrap%2FServerBootstrap.java",
      "raw_url": "https://github.com/netty/netty/raw/4b83eee1338ab018b802c3e195317fa83f785154/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fbootstrap%2FServerBootstrap.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fbootstrap%2FServerBootstrap.java?ref=4b83eee1338ab018b802c3e195317fa83f785154",
      "patch": "@@ -75,7 +75,7 @@ public ServerBootstrap group(EventLoopGroup group) {\n \n     /**\n      * Set the {@link EventLoopGroup} for the parent (acceptor) and the child (client). These\n-     * {@link EventLoopGroup}'s are used to handle all the events and IO for {@link SocketChannel} and\n+     * {@link EventLoopGroup}'s are used to handle all the events and IO for {@link ServerChannel} and\n      * {@link Channel}'s.\n      */\n     public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) {",
      "parent_sha": "b8d26d1da3f203033e1f5814d9b72582376cb0b5"
    }
  },
  {
    "oid": "c9d01b2fb59c6ef7905ed0209962a34e3b4ba853",
    "message": "[#1461] Correctly handle DefaultChannelGroup.write(..) of ByteBuf and ByteBufHolder",
    "date": "2013-06-25T02:07:14Z",
    "url": "https://github.com/netty/netty/commit/c9d01b2fb59c6ef7905ed0209962a34e3b4ba853",
    "details": {
      "sha": "8e83e8bca4a1dd8260b5bc88268fe772c389c0a9",
      "filename": "transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java",
      "status": "modified",
      "additions": 21,
      "deletions": 4,
      "changes": 25,
      "blob_url": "https://github.com/netty/netty/blob/c9d01b2fb59c6ef7905ed0209962a34e3b4ba853/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Fgroup%2FDefaultChannelGroup.java",
      "raw_url": "https://github.com/netty/netty/raw/c9d01b2fb59c6ef7905ed0209962a34e3b4ba853/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Fgroup%2FDefaultChannelGroup.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Fgroup%2FDefaultChannelGroup.java?ref=c9d01b2fb59c6ef7905ed0209962a34e3b4ba853",
      "patch": "@@ -15,6 +15,8 @@\n  */\n package io.netty.channel.group;\n \n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufHolder;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelFuture;\n import io.netty.channel.ChannelFutureListener;\n@@ -216,8 +218,7 @@ public ChannelGroupFuture write(Object message) {\n \n         Map<Integer, ChannelFuture> futures = new LinkedHashMap<Integer, ChannelFuture>(size());\n         for (Channel c: nonServerChannels.values()) {\n-            ReferenceCountUtil.retain(message);\n-            futures.put(c.id(), c.write(message));\n+            futures.put(c.id(), c.write(safeDuplicate(message)));\n         }\n \n         ReferenceCountUtil.release(message);\n@@ -232,14 +233,30 @@ public ChannelGroupFuture write(MessageList<Object> messages) {\n \n         Map<Integer, ChannelFuture> futures = new LinkedHashMap<Integer, ChannelFuture>(size());\n         for (Channel c: nonServerChannels.values()) {\n-            MessageList<Object> messagesCopy = messages.retainAll().copy();\n-            futures.put(c.id(), c.write(messagesCopy));\n+            int size = messages.size();\n+            MessageList<Object> messageCopy = MessageList.newInstance(size);\n+            for (int i = 0 ; i < size; i++) {\n+                messageCopy.add(safeDuplicate(messages.get(i)));\n+            }\n+            futures.put(c.id(), c.write(messageCopy));\n         }\n \n         messages.releaseAllAndRecycle();\n         return new DefaultChannelGroupFuture(this, futures, executor);\n     }\n \n+    // Create a safe duplicate of the message to write it to a channel but not affect other writes.\n+    // See https://github.com/netty/netty/issues/1461\n+    private static Object safeDuplicate(Object message) {\n+        if (message instanceof ByteBuf) {\n+            return ((ByteBuf) message).duplicate().retain();\n+        } else if (message instanceof ByteBufHolder) {\n+            return ((ByteBufHolder) message).copy();\n+        } else {\n+            return ReferenceCountUtil.retain(message);\n+        }\n+    }\n+\n     @Override\n     public ChannelGroupFuture deregister() {\n         Map<Integer, ChannelFuture> futures =",
      "parent_sha": "e06fcdbc6a162f085b77e25bed1f847026cfd3ea"
    }
  },
  {
    "oid": "80f92f90cbc9a8267cad3f338641982b53478e8a",
    "message": "netty-1616: Adding a 'last' check to SpdyHttpEncoder.",
    "date": "2013-07-20T06:11:53Z",
    "url": "https://github.com/netty/netty/commit/80f92f90cbc9a8267cad3f338641982b53478e8a",
    "details": {
      "sha": "a8e3eefd262471a01aa6c3fd0612d062595d5e65",
      "filename": "codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java",
      "status": "modified",
      "additions": 25,
      "deletions": 2,
      "changes": 27,
      "blob_url": "https://github.com/netty/netty/blob/80f92f90cbc9a8267cad3f338641982b53478e8a/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fspdy%2FSpdyHttpEncoder.java",
      "raw_url": "https://github.com/netty/netty/raw/80f92f90cbc9a8267cad3f338641982b53478e8a/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fspdy%2FSpdyHttpEncoder.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fspdy%2FSpdyHttpEncoder.java?ref=80f92f90cbc9a8267cad3f338641982b53478e8a",
      "patch": "@@ -18,6 +18,7 @@\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToMessageEncoder;\n import io.netty.handler.codec.UnsupportedMessageTypeException;\n+import io.netty.handler.codec.http.FullHttpMessage;\n import io.netty.handler.codec.http.FullHttpRequest;\n import io.netty.handler.codec.http.HttpContent;\n import io.netty.handler.codec.http.HttpHeaders;\n@@ -141,29 +142,33 @@ public SpdyHttpEncoder(int version) {\n     protected void encode(ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception {\n \n         boolean valid = false;\n+        boolean last = false;\n \n         if (msg instanceof HttpRequest) {\n \n             HttpRequest httpRequest = (HttpRequest) msg;\n             SpdySynStreamFrame spdySynStreamFrame = createSynStreamFrame(httpRequest);\n             out.add(spdySynStreamFrame);\n \n+            last = spdySynStreamFrame.isLast();\n             valid = true;\n         }\n         if (msg instanceof HttpResponse) {\n \n             HttpResponse httpResponse = (HttpResponse) msg;\n             if (httpResponse.headers().contains(SpdyHttpHeaders.Names.ASSOCIATED_TO_STREAM_ID)) {\n                 SpdySynStreamFrame spdySynStreamFrame = createSynStreamFrame(httpResponse);\n+                last = spdySynStreamFrame.isLast();\n                 out.add(spdySynStreamFrame);\n             } else {\n                 SpdySynReplyFrame spdySynReplyFrame = createSynReplyFrame(httpResponse);\n+                last = spdySynReplyFrame.isLast();\n                 out.add(spdySynReplyFrame);\n             }\n \n             valid = true;\n         }\n-        if (msg instanceof HttpContent) {\n+        if (msg instanceof HttpContent && !last) {\n \n             HttpContent chunk = (HttpContent) msg;\n \n@@ -255,6 +260,7 @@ private SpdySynStreamFrame createSynStreamFrame(HttpMessage httpMessage)\n             spdySynStreamFrame.headers().add(entry.getKey(), entry.getValue());\n         }\n         currentStreamId = spdySynStreamFrame.getStreamId();\n+        spdySynStreamFrame.setLast(isLast(httpMessage));\n \n         return spdySynStreamFrame;\n     }\n@@ -284,8 +290,25 @@ private SpdySynReplyFrame createSynReplyFrame(HttpResponse httpResponse)\n         }\n \n         currentStreamId = streamID;\n-        spdySynReplyFrame.setLast(false);\n+        spdySynReplyFrame.setLast(isLast(httpResponse));\n \n         return spdySynReplyFrame;\n     }\n+\n+    /**\n+     * Checks if the given HTTP message should be considered as a last SPDY frame.\n+     *\n+     * @param httpMessage check this HTTP message\n+     * @return whether the given HTTP message should generate a <em>last</em> SPDY frame.\n+     */\n+    private static boolean isLast(HttpMessage httpMessage) {\n+        if (httpMessage instanceof FullHttpMessage) {\n+            FullHttpMessage fullMessage = (FullHttpMessage) httpMessage;\n+            if (fullMessage.trailingHeaders().isEmpty() && !fullMessage.content().isReadable()) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n }",
      "parent_sha": "60529ac3ee31f72bd07f2a18f869666e42a26117"
    }
  },
  {
    "oid": "262fd48e28ab8001cc0bbdc316dcc460e0b562bd",
    "message": "Typo",
    "date": "2009-06-17T05:01:09Z",
    "url": "https://github.com/netty/netty/commit/262fd48e28ab8001cc0bbdc316dcc460e0b562bd",
    "details": {
      "sha": "a9601cf84779da7b95ce6ddb005e7533a03bc7b2",
      "filename": "src/main/java/org/jboss/netty/bootstrap/Bootstrap.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/262fd48e28ab8001cc0bbdc316dcc460e0b562bd/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fbootstrap%2FBootstrap.java",
      "raw_url": "https://github.com/netty/netty/raw/262fd48e28ab8001cc0bbdc316dcc460e0b562bd/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fbootstrap%2FBootstrap.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fbootstrap%2FBootstrap.java?ref=262fd48e28ab8001cc0bbdc316dcc460e0b562bd",
      "patch": "@@ -41,7 +41,7 @@\n /**\n  * A helper class which initializes a {@link Channel}.  This class provides\n  * the common data structure for its subclasses which actually initialize\n- * {@link Channel}s and their child {@link Channel}s. using the common data\n+ * {@link Channel}s and their child {@link Channel}s using the common data\n  * structure.  Please refer to {@link ClientBootstrap}, {@link ServerBootstrap},\n  * and {@link ConnectionlessBootstrap} for client side, server-side, and\n  * connectionless (e.g. UDP) channel initialization respectively.",
      "parent_sha": "10a110c564aab4e383e18f8e65916389988e2d47"
    }
  },
  {
    "oid": "08e828c4fbaa5ada30aea35ee9f284e2ba10bc6e",
    "message": "More links to ChannelEvent and ChannelHandler in ChannelPipeline JavaDoc",
    "date": "2008-09-01T15:56:45Z",
    "url": "https://github.com/netty/netty/commit/08e828c4fbaa5ada30aea35ee9f284e2ba10bc6e",
    "details": {
      "sha": "82994be32cab14767b505b468aab89e36be61c51",
      "filename": "src/main/java/org/jboss/netty/channel/ChannelPipeline.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/netty/netty/blob/08e828c4fbaa5ada30aea35ee9f284e2ba10bc6e/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fchannel%2FChannelPipeline.java",
      "raw_url": "https://github.com/netty/netty/raw/08e828c4fbaa5ada30aea35ee9f284e2ba10bc6e/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fchannel%2FChannelPipeline.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fchannel%2FChannelPipeline.java?ref=08e828c4fbaa5ada30aea35ee9f284e2ba10bc6e",
      "patch": "@@ -66,8 +66,8 @@\n  *\n  * <h3>How an event flows in a pipeline</h3>\n  * <p>\n- * The following diagram describes how events flow upstream and downstream in\n- * a {@link ChannelPipeline} typically:\n+ * The following diagram describes how {@link ChannelEvent}s are processed by\n+ * {@link ChannelHandler}s in a {@link ChannelPipeline} typically:\n  *\n  * <pre>\n  *                                      I/O Request",
      "parent_sha": "9cc8c284918b0cb801c391acedcb44c9f7ab4c17"
    }
  },
  {
    "oid": "af98b621500cb8f4ee9c3f35fce917f3e803c59c",
    "message": "Log deprecation info message when using 'io.netty.handler.ssl.openssl.useKeyManagerFactory' and ignore it when using BoringSSL (#9162)\n\nMotivation:\r\n\r\nWhen we added support for KeyManagerFactory we also allowed to disable it to make the change less risky. This was done years ago and so there is really no need to use the property anyway.\r\nUnfortunally due a change in netty-tcnative it is even not supported anymore when using BoringSSL.\r\n\r\nModifications:\r\n\r\n- Log an info message to tell users that 'io.netty.handler.ssl.openssl.useKeyManagerFactory' is deprecated when it is used\r\n- Ignore 'io.netty.handler.ssl.openssl.useKeyManagerFactory' when BoringSSL is used.\r\n\r\nResult:\r\n\r\nFixes https://github.com/netty/netty/issues/9147.",
    "date": "2019-05-22T06:40:19Z",
    "url": "https://github.com/netty/netty/commit/af98b621500cb8f4ee9c3f35fce917f3e803c59c",
    "details": {
      "sha": "ebe333414d633c1186024af34f8cf17e892fd882",
      "filename": "handler/src/main/java/io/netty/handler/ssl/OpenSsl.java",
      "status": "modified",
      "additions": 17,
      "deletions": 6,
      "changes": 23,
      "blob_url": "https://github.com/netty/netty/blob/af98b621500cb8f4ee9c3f35fce917f3e803c59c/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2FOpenSsl.java",
      "raw_url": "https://github.com/netty/netty/raw/af98b621500cb8f4ee9c3f35fce917f3e803c59c/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2FOpenSsl.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2FOpenSsl.java?ref=af98b621500cb8f4ee9c3f35fce917f3e803c59c",
      "patch": "@@ -246,13 +246,24 @@ public final class OpenSsl {\n                             SSL.setKeyMaterial(ssl, cert, key);\n                             supportsKeyManagerFactory = true;\n                             try {\n-                                useKeyManagerFactory = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n-                                    @Override\n-                                    public Boolean run() {\n-                                        return SystemPropertyUtil.getBoolean(\n-                                                \"io.netty.handler.ssl.openssl.useKeyManagerFactory\", true);\n+                                boolean propertySet = SystemPropertyUtil.contains(\n+                                        \"io.netty.handler.ssl.openssl.useKeyManagerFactory\");\n+                                if (!IS_BORINGSSL) {\n+                                    useKeyManagerFactory = SystemPropertyUtil.getBoolean(\n+                                            \"io.netty.handler.ssl.openssl.useKeyManagerFactory\", true);\n+\n+                                    if (propertySet) {\n+                                        logger.info(\"System property \" +\n+                                                \"'io.netty.handler.ssl.openssl.useKeyManagerFactory'\" +\n+                                                \" is deprecated and so will be ignored in the future\");\n                                     }\n-                                });\n+                                } else {\n+                                    if (propertySet) {\n+                                        logger.info(\"System property \" +\n+                                                \"'io.netty.handler.ssl.openssl.useKeyManagerFactory'\" +\n+                                                \" is deprecated and will be ignored when using BoringSSL\");\n+                                    }\n+                                }\n                             } catch (Throwable ignore) {\n                                 logger.debug(\"Failed to get useKeyManagerFactory system property.\");\n                             }",
      "parent_sha": "2dc686ded17d8123118921ac6d36aea30cdce267"
    }
  },
  {
    "oid": "a1b668bb2f3f43ddcb37e1e7a448e5a02e4a78c5",
    "message": "Fix checkstyle. See #535",
    "date": "2012-08-29T06:12:19Z",
    "url": "https://github.com/netty/netty/commit/a1b668bb2f3f43ddcb37e1e7a448e5a02e4a78c5",
    "details": {
      "sha": "b8dd00cbc1d302a0222427b2de182447556d4339",
      "filename": "transport/src/main/java/io/netty/channel/socket/nio/NioEventLoop.java",
      "status": "modified",
      "additions": 7,
      "deletions": 2,
      "changes": 9,
      "blob_url": "https://github.com/netty/netty/blob/a1b668bb2f3f43ddcb37e1e7a448e5a02e4a78c5/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Fsocket%2Fnio%2FNioEventLoop.java",
      "raw_url": "https://github.com/netty/netty/raw/a1b668bb2f3f43ddcb37e1e7a448e5a02e4a78c5/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Fsocket%2Fnio%2FNioEventLoop.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Fsocket%2Fnio%2FNioEventLoop.java?ref=a1b668bb2f3f43ddcb37e1e7a448e5a02e4a78c5",
      "patch": "@@ -24,7 +24,11 @@\n import io.netty.logging.InternalLoggerFactory;\n \n import java.io.IOException;\n-import java.nio.channels.*;\n+import java.nio.channels.CancelledKeyException;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.SelectableChannel;\n import java.nio.channels.spi.SelectorProvider;\n import java.util.ArrayList;\n import java.util.Collection;\n@@ -56,7 +60,7 @@ final class NioEventLoop extends SingleThreadEventLoop {\n     protected Selector selector;\n \n     protected final SelectorProvider provider;\n-    \n+\n     /**\n      * Boolean that controls determines if a blocked Selector.select should\n      * break out of its selection process. In our case we use a timeone for\n@@ -127,6 +131,7 @@ private Selector recreateSelector() {\n         logger.warn(\"Recreated Selector because of possible jdk epoll(..) bug\");\n         return newSelector;\n     }\n+\n     @Override\n     protected void run() {\n         Selector selector = this.selector;",
      "parent_sha": "3d44aeca50682a33747d3c6e41fdfccf93c597f7"
    }
  },
  {
    "oid": "0f91ad841d572c5b9db72802e5c460e85fafe2da",
    "message": "Fix possible testfailure due not waiting on Channel.close() (introduced by e220c568232fe9b479e3ac7a5b66f5a97dcc2c39)",
    "date": "2016-02-05T11:28:11Z",
    "url": "https://github.com/netty/netty/commit/0f91ad841d572c5b9db72802e5c460e85fafe2da",
    "details": {
      "sha": "32fd97ddcb2186696ca4ba7801eaf1ed87dff676",
      "filename": "handler/src/test/java/io/netty/handler/ssl/SniClientTest.java",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/netty/netty/blob/0f91ad841d572c5b9db72802e5c460e85fafe2da/handler%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2FSniClientTest.java",
      "raw_url": "https://github.com/netty/netty/raw/0f91ad841d572c5b9db72802e5c460e85fafe2da/handler%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2FSniClientTest.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/handler%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2FSniClientTest.java?ref=0f91ad841d572c5b9db72802e5c460e85fafe2da",
      "patch": "@@ -35,24 +35,24 @@\n \n public class SniClientTest {\n \n-    @Test\n+    @Test(timeout = 5000)\n     public void testSniClientJdkSslServerJdkSsl() throws Exception {\n         testSniClient(SslProvider.JDK, SslProvider.JDK);\n     }\n \n-    @Test\n+    @Test(timeout = 5000)\n     public void testSniClientOpenSslServerOpenSsl() throws Exception {\n         Assume.assumeTrue(OpenSsl.isAvailable());\n         testSniClient(SslProvider.OPENSSL, SslProvider.OPENSSL);\n     }\n \n-    @Test\n+    @Test(timeout = 5000)\n     public void testSniClientJdkSslServerOpenSsl() throws Exception {\n         Assume.assumeTrue(OpenSsl.isAvailable());\n         testSniClient(SslProvider.JDK, SslProvider.OPENSSL);\n     }\n \n-    @Test\n+    @Test(timeout = 5000)\n     public void testSniClientOpenSslServerJdkSsl() throws Exception {\n         Assume.assumeTrue(OpenSsl.isAvailable());\n         testSniClient(SslProvider.OPENSSL, SslProvider.JDK);\n@@ -93,10 +93,10 @@ public SslContext map(String input) {\n             Assert.assertEquals(sniHost, promise.syncUninterruptibly().getNow());\n         } finally {\n             if (cc != null) {\n-                cc.close();\n+                cc.close().syncUninterruptibly();\n             }\n             if (sc != null) {\n-                sc.close();\n+                sc.close().syncUninterruptibly();\n             }\n             group.shutdownGracefully();\n         }",
      "parent_sha": "0f3d47199b95098b04ee774eb2730c2812bf4dd0"
    }
  },
  {
    "oid": "b592a18cd1a963c99dfefabbb56222016fadceb5",
    "message": "Fix buffer leaks in BinaryMemcacheDecoderTest",
    "date": "2014-02-14T01:05:19Z",
    "url": "https://github.com/netty/netty/commit/b592a18cd1a963c99dfefabbb56222016fadceb5",
    "details": {
      "sha": "37a915e3f6ea5d709b26bb07097bcc765d055cef",
      "filename": "codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java",
      "status": "modified",
      "additions": 29,
      "deletions": 3,
      "changes": 32,
      "blob_url": "https://github.com/netty/netty/blob/b592a18cd1a963c99dfefabbb56222016fadceb5/codec-memcache%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fmemcache%2Fbinary%2FBinaryMemcacheDecoderTest.java",
      "raw_url": "https://github.com/netty/netty/raw/b592a18cd1a963c99dfefabbb56222016fadceb5/codec-memcache%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fmemcache%2Fbinary%2FBinaryMemcacheDecoderTest.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-memcache%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fmemcache%2Fbinary%2FBinaryMemcacheDecoderTest.java?ref=b592a18cd1a963c99dfefabbb56222016fadceb5",
      "patch": "@@ -21,6 +21,8 @@\n import io.netty.handler.codec.memcache.LastMemcacheContent;\n import io.netty.handler.codec.memcache.MemcacheContent;\n import io.netty.util.CharsetUtil;\n+import io.netty.util.ReferenceCounted;\n+import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n \n@@ -71,6 +73,11 @@ public void setup() throws Exception {\n         channel = new EmbeddedChannel(new BinaryMemcacheRequestDecoder());\n     }\n \n+    @After\n+    public void teardown() throws Exception {\n+        channel.finish();\n+    }\n+\n     /**\n      * This tests a simple GET request with a key as the value.\n      */\n@@ -151,6 +158,8 @@ public void shouldHandleNonUniformNetworkBatches() {\n         assertThat(request.getKey(), notNullValue());\n         assertThat(request.getExtras(), nullValue());\n \n+        request.release();\n+\n         MemcacheContent content1 = (MemcacheContent) channel.readInbound();\n         MemcacheContent content2 = (MemcacheContent) channel.readInbound();\n \n@@ -159,6 +168,9 @@ public void shouldHandleNonUniformNetworkBatches() {\n \n         assertThat(content1.content().readableBytes(), is(3));\n         assertThat(content2.content().readableBytes(), is(5));\n+\n+        content1.release();\n+        content2.release();\n     }\n \n     /**\n@@ -172,12 +184,20 @@ public void shouldHandleTwoMessagesInOneBatch() {\n         BinaryMemcacheRequest request = (BinaryMemcacheRequest) channel.readInbound();\n         assertThat(request, instanceOf(BinaryMemcacheRequest.class));\n         assertThat(request, notNullValue());\n-        assertThat(channel.readInbound(), instanceOf(LastMemcacheContent.class));\n+        request.release();\n+\n+        Object lastContent = channel.readInbound();\n+        assertThat(lastContent, instanceOf(LastMemcacheContent.class));\n+        ((ReferenceCounted) lastContent).release();\n \n         request = (BinaryMemcacheRequest) channel.readInbound();\n         assertThat(request, instanceOf(BinaryMemcacheRequest.class));\n         assertThat(request, notNullValue());\n-        assertThat(channel.readInbound(), instanceOf(LastMemcacheContent.class));\n+        request.release();\n+\n+        lastContent = channel.readInbound();\n+        assertThat(lastContent, instanceOf(LastMemcacheContent.class));\n+        ((ReferenceCounted) lastContent).release();\n     }\n \n     @Test\n@@ -192,36 +212,42 @@ public void shouldDecodeSeparatedValues() {\n         BinaryMemcacheResponse response = (BinaryMemcacheResponse) channel.readInbound();\n         assertThat(response.getHeader().getStatus(), is(BinaryMemcacheResponseStatus.KEY_ENOENT));\n         assertThat(response.getHeader().getTotalBodyLength(), is(msgBody.length()));\n+        response.release();\n \n         // First message first content chunk\n         MemcacheContent content = (MemcacheContent) channel.readInbound();\n         assertThat(content, instanceOf(LastMemcacheContent.class));\n         assertThat(content.content().toString(CharsetUtil.UTF_8), is(msgBody));\n+        content.release();\n \n         // Second message\n         response = (BinaryMemcacheResponse) channel.readInbound();\n         assertThat(response.getHeader().getStatus(), is(BinaryMemcacheResponseStatus.KEY_ENOENT));\n         assertThat(response.getHeader().getTotalBodyLength(), is(msgBody.length()));\n+        response.release();\n \n         // Second message first content chunk\n         content = (MemcacheContent) channel.readInbound();\n         assertThat(content, instanceOf(MemcacheContent.class));\n         assertThat(content.content().toString(CharsetUtil.UTF_8), is(msgBody.substring(0, 7)));\n+        content.release();\n \n         // Second message second content chunk\n         content = (MemcacheContent) channel.readInbound();\n         assertThat(content, instanceOf(LastMemcacheContent.class));\n         assertThat(content.content().toString(CharsetUtil.UTF_8), is(msgBody.substring(7, 9)));\n+        content.release();\n \n         // Third message\n         response = (BinaryMemcacheResponse) channel.readInbound();\n         assertThat(response.getHeader().getStatus(), is(BinaryMemcacheResponseStatus.KEY_ENOENT));\n         assertThat(response.getHeader().getTotalBodyLength(), is(msgBody.length()));\n+        response.release();\n \n         // Third message first content chunk\n         content = (MemcacheContent) channel.readInbound();\n         assertThat(content, instanceOf(LastMemcacheContent.class));\n         assertThat(content.content().toString(CharsetUtil.UTF_8), is(msgBody));\n+        content.release();\n     }\n-\n }",
      "parent_sha": "ccd231b8f42a717964ec52876037333dfa90e200"
    }
  },
  {
    "oid": "b83ffcc4471ce5cc68b39fc3545853ac5e2a5f1b",
    "message": "Add timeout to PooledByteBufAllocatorTest\n\nMotivation:\n\nSome tests in PooledByteBufAllocatorTest are blocking on a CountDownLatch. We should use a timeout on these tests so these will not block forever on a failure.\n\nModifications:\n\nAdd timeout param to @Test annotation\n\nResult:\n\nHave sane timeouts on tests.",
    "date": "2016-05-20T19:52:53Z",
    "url": "https://github.com/netty/netty/commit/b83ffcc4471ce5cc68b39fc3545853ac5e2a5f1b",
    "details": {
      "sha": "77b99f351cb279e357ced71b286b1e5bd59e2dcb",
      "filename": "buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/netty/netty/blob/b83ffcc4471ce5cc68b39fc3545853ac5e2a5f1b/buffer%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fbuffer%2FPooledByteBufAllocatorTest.java",
      "raw_url": "https://github.com/netty/netty/raw/b83ffcc4471ce5cc68b39fc3545853ac5e2a5f1b/buffer%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fbuffer%2FPooledByteBufAllocatorTest.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/buffer%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fbuffer%2FPooledByteBufAllocatorTest.java?ref=b83ffcc4471ce5cc68b39fc3545853ac5e2a5f1b",
      "patch": "@@ -125,7 +125,7 @@ public void run() {\n         assertTrue(threadCachesCreated.get());\n     }\n \n-    @Test\n+    @Test(timeout = 3000)\n     public void testNumThreadCachesWithNoDirectArenas() throws InterruptedException {\n         int numHeapArenas = 1;\n         final PooledByteBufAllocator allocator =\n@@ -144,7 +144,7 @@ public void testNumThreadCachesWithNoDirectArenas() throws InterruptedException\n         assertEquals(0, allocator.numThreadLocalCaches());\n     }\n \n-    @Test\n+    @Test(timeout = 3000)\n     public void testThreadCacheToArenaMappings() throws InterruptedException {\n         int numArenas = 2;\n         final PooledByteBufAllocator allocator =",
      "parent_sha": "43e91c2476e19f58744edb1263a79e8d3e67bc47"
    }
  },
  {
    "oid": "a96de7590bdf8e1dba970e29934d12e52eb306ea",
    "message": "Updated the package description",
    "date": "2009-04-03T08:14:57Z",
    "url": "https://github.com/netty/netty/commit/a96de7590bdf8e1dba970e29934d12e52eb306ea",
    "details": {
      "sha": "131187bfd01fa579efb3914cd38c460e15aff53a",
      "filename": "src/main/java/org/jboss/netty/util/package-info.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/a96de7590bdf8e1dba970e29934d12e52eb306ea/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Futil%2Fpackage-info.java",
      "raw_url": "https://github.com/netty/netty/raw/a96de7590bdf8e1dba970e29934d12e52eb306ea/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Futil%2Fpackage-info.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Futil%2Fpackage-info.java?ref=a96de7590bdf8e1dba970e29934d12e52eb306ea",
      "patch": "@@ -22,7 +22,7 @@\n  */\n \n /**\n- * Miscellaneous utility types.\n+ * Utility classes used across multiple packages.\n  *\n  * @apiviz.exclude\n  */",
      "parent_sha": "db6725dcbd32e45e7945c9eb73de2cc0c5a5b3b9"
    }
  },
  {
    "oid": "9c70dc8ba580731cb9c5a031185975384764183b",
    "message": "Replaced obsolete cryptographic primitive with a modern/secure one. (#8450)\n\nMotivation:\r\n\r\nSHA1 is a broken hash function and shouldn't be used anymore (see: https://shattered.io/).\r\nSecurity scanning tools will raise this as an issue and it will reflect badly on netty and I, therefore, recommend to use a SHA2 hash function which is secure and won't be flagged by such tools.\r\n\r\nModifications:\r\n\r\nReplaced insecure SHA1 based signing scheme with SHA2.\r\n\r\nResult:\r\n\r\nModern and thus secure cryptographic primitives will be in use and won't be flagged by security scanning tools.",
    "date": "2018-11-02T06:20:54Z",
    "url": "https://github.com/netty/netty/commit/9c70dc8ba580731cb9c5a031185975384764183b",
    "details": {
      "sha": "30d74e27054073ce54385f67c44410b57815b4e0",
      "filename": "handler/src/main/java/io/netty/handler/ssl/util/OpenJdkSelfSignedCertGenerator.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/netty/netty/blob/9c70dc8ba580731cb9c5a031185975384764183b/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2Futil%2FOpenJdkSelfSignedCertGenerator.java",
      "raw_url": "https://github.com/netty/netty/raw/9c70dc8ba580731cb9c5a031185975384764183b/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2Futil%2FOpenJdkSelfSignedCertGenerator.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2Futil%2FOpenJdkSelfSignedCertGenerator.java?ref=9c70dc8ba580731cb9c5a031185975384764183b",
      "patch": "@@ -64,16 +64,16 @@ static String[] generate(String fqdn, KeyPair keypair, SecureRandom random, Date\n         info.set(X509CertInfo.VALIDITY, new CertificateValidity(notBefore, notAfter));\n         info.set(X509CertInfo.KEY, new CertificateX509Key(keypair.getPublic()));\n         info.set(X509CertInfo.ALGORITHM_ID,\n-                new CertificateAlgorithmId(new AlgorithmId(AlgorithmId.sha1WithRSAEncryption_oid)));\n+                new CertificateAlgorithmId(new AlgorithmId(AlgorithmId.sha256WithRSAEncryption_oid)));\n \n         // Sign the cert to identify the algorithm that's used.\n         X509CertImpl cert = new X509CertImpl(info);\n-        cert.sign(key, \"SHA1withRSA\");\n+        cert.sign(key, \"SHA256withRSA\");\n \n         // Update the algorithm and sign again.\n         info.set(CertificateAlgorithmId.NAME + '.' + CertificateAlgorithmId.ALGORITHM, cert.get(X509CertImpl.SIG_ALG));\n         cert = new X509CertImpl(info);\n-        cert.sign(key, \"SHA1withRSA\");\n+        cert.sign(key, \"SHA256withRSA\");\n         cert.verify(keypair.getPublic());\n \n         return newSelfSignedCertificate(fqdn, key, cert);",
      "parent_sha": "d533befa9617843f7b3e375e0ee4c4c89a35e16b"
    }
  },
  {
    "oid": "a8216e7ce011a595bc5eaf12ecabb0f4526eda6f",
    "message": "Fix possible NPE",
    "date": "2013-02-13T08:52:07Z",
    "url": "https://github.com/netty/netty/commit/a8216e7ce011a595bc5eaf12ecabb0f4526eda6f",
    "details": {
      "sha": "a6081bb7e1543b43be9a257b4e18fcc22b54c9f6",
      "filename": "buffer/src/main/java/io/netty/buffer/DefaultMessageBuf.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/a8216e7ce011a595bc5eaf12ecabb0f4526eda6f/buffer%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fbuffer%2FDefaultMessageBuf.java",
      "raw_url": "https://github.com/netty/netty/raw/a8216e7ce011a595bc5eaf12ecabb0f4526eda6f/buffer%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fbuffer%2FDefaultMessageBuf.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/buffer%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fbuffer%2FDefaultMessageBuf.java?ref=a8216e7ce011a595bc5eaf12ecabb0f4526eda6f",
      "patch": "@@ -90,7 +90,7 @@ protected void deallocate() {\n             } while (i != tail);\n         }\n \n-        elements = null;\n+        elements =  cast(new Object[2]);\n         this.head = 0;\n         this.tail = 0;\n     }",
      "parent_sha": "7cf7d7455d17c7a30266edef6bc6b21b9b86cf03"
    }
  },
  {
    "oid": "44f85bba5f47df885dbbe5243d008220bfbab5ca",
    "message": "Ensure we don't leak the ClassLoader in the backtrace of TrackRecord.BOTTOM (#10839)\n\nMotivation:\r\n\r\nWe need to ensure we override fillInStacktrace() when we store exceptions in static fields to not leak the Classloader in the backtrace.\r\n\r\nCame up in https://github.com/netty/netty/pull/10691#issuecomment-738331186. Thanks to @amir-shalem for notice this one.\r\n\r\nModifications:\r\n\r\n- Add overrides of fillInStracktrace in TrackRecord.BOTTOM\r\n\r\nResult:\r\n\r\nRelated fix to https://github.com/netty/netty/pull/10686",
    "date": "2020-12-05T06:01:03Z",
    "url": "https://github.com/netty/netty/commit/44f85bba5f47df885dbbe5243d008220bfbab5ca",
    "details": {
      "sha": "be6845683d93f5c50392b929c2ac8bea5a59f640",
      "filename": "common/src/main/java/io/netty/util/ResourceLeakDetector.java",
      "status": "modified",
      "additions": 12,
      "deletions": 3,
      "changes": 15,
      "blob_url": "https://github.com/netty/netty/blob/44f85bba5f47df885dbbe5243d008220bfbab5ca/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2FResourceLeakDetector.java",
      "raw_url": "https://github.com/netty/netty/raw/44f85bba5f47df885dbbe5243d008220bfbab5ca/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2FResourceLeakDetector.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2FResourceLeakDetector.java?ref=44f85bba5f47df885dbbe5243d008220bfbab5ca",
      "patch": "@@ -31,7 +31,6 @@\n import java.util.HashSet;\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n import java.util.concurrent.atomic.AtomicReference;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n@@ -588,10 +587,20 @@ public static void addExclusions(Class clz, String ... methodNames) {\n         } while (!excludedMethods.compareAndSet(oldMethods, newMethods));\n     }\n \n-    private static final class TraceRecord extends Throwable {\n+    private static class TraceRecord extends Throwable {\n         private static final long serialVersionUID = 6065153674892850720L;\n \n-        private static final TraceRecord BOTTOM = new TraceRecord();\n+        private static final TraceRecord BOTTOM = new TraceRecord() {\n+            private static final long serialVersionUID = 7396077602074694571L;\n+\n+            // Override fillInStackTrace() so we not populate the backtrace via a native call and so leak the\n+            // Classloader.\n+            // See https://github.com/netty/netty/pull/10691\n+            @Override\n+            public Throwable fillInStackTrace() {\n+                return this;\n+            }\n+        };\n \n         private final String hintString;\n         private final TraceRecord next;",
      "parent_sha": "37267f95ce6a7ec486b69bd04ebdac83e114f9d9"
    }
  },
  {
    "oid": "39631f54fa6701a96f7b724a330c1d0dc9c042fc",
    "message": "Disable sun.misc.Unsafe by default on Java 24+ (#14943) (#14975)\n\nMotivation:\nJava 24 has started to print warnings when `sub.misc.Unsafe` is used to\naccess memory. See JEP 498: https://openjdk.org/jeps/498\n\nPeople tend to be sensitive to new warnings and errors printed by the\nJVM, so we should avoid enabling `Unsafe` by default on Java 24 onwards.\n\nModification:\nEffectively change the default value of the `io.netty.noUnsafe` system\nproperty for Java 24 onwards, but in a way where we can tell if it was\nexplicitly set to a given value or if it follows the default.\n\nAny sort of explicit settings, be it `-Dio.netty.noUnsafe=false` or\n`--sun-misc-unsafe-memory-access=allow`, will continue to work as\nbefore.\n\nManually verified that the changes work as intended on Java 24.\n\nResult:\nNo more warnings printed to the console on Java 24+.\n\nFixes https://github.com/netty/netty/issues/14942\n\nCo-authored-by: Chris Vest <christianvest_hansen@apple.com>",
    "date": "2025-03-29T14:44:02Z",
    "url": "https://github.com/netty/netty/commit/39631f54fa6701a96f7b724a330c1d0dc9c042fc",
    "details": {
      "sha": "d8ee3ed005d183521ec4662022ebca9f10d2a53f",
      "filename": "common/src/main/java/io/netty/util/internal/PlatformDependent0.java",
      "status": "modified",
      "additions": 13,
      "deletions": 5,
      "changes": 18,
      "blob_url": "https://github.com/netty/netty/blob/39631f54fa6701a96f7b724a330c1d0dc9c042fc/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2Finternal%2FPlatformDependent0.java",
      "raw_url": "https://github.com/netty/netty/raw/39631f54fa6701a96f7b724a330c1d0dc9c042fc/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2Finternal%2FPlatformDependent0.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2Finternal%2FPlatformDependent0.java?ref=39631f54fa6701a96f7b724a330c1d0dc9c042fc",
      "patch": "@@ -546,19 +546,27 @@ static boolean isExplicitNoUnsafe() {\n     }\n \n     private static Throwable explicitNoUnsafeCause0() {\n+        boolean explicitProperty = SystemPropertyUtil.contains(\"io.netty.noUnsafe\");\n         boolean noUnsafe = SystemPropertyUtil.getBoolean(\"io.netty.noUnsafe\", false);\n         logger.debug(\"-Dio.netty.noUnsafe: {}\", noUnsafe);\n \n         // See JDK 23 JEP 471 https://openjdk.org/jeps/471 and sun.misc.Unsafe.beforeMemoryAccess() on JDK 23+.\n-        String unsafeMemoryAccess = SystemPropertyUtil.get(\"sun.misc.unsafe.memory.access\", \"<unspecified>\");\n-        if (!(\"allow\".equals(unsafeMemoryAccess) || \"<unspecified>\".equals(unsafeMemoryAccess))) {\n-            logger.debug(\"--sun-misc-unsafe-memory-access={}\", unsafeMemoryAccess);\n+        // And JDK 24 JEP 498 https://openjdk.org/jeps/498, that enable warnings by default.\n+        String reason = \"io.netty.noUnsafe\";\n+        String unspecified = \"<unspecified>\";\n+        String unsafeMemoryAccess = SystemPropertyUtil.get(\"sun.misc.unsafe.memory.access\", unspecified);\n+        if (!explicitProperty && unspecified.equals(unsafeMemoryAccess) && javaVersion() >= 24) {\n+            reason = \"io.netty.noUnsafe=true by default on Java 24+\";\n+            noUnsafe = true;\n+        } else if (!(\"allow\".equals(unsafeMemoryAccess) || unspecified.equals(unsafeMemoryAccess))) {\n+            reason = \"--sun-misc-unsafe-memory-access=\" + unsafeMemoryAccess;\n             noUnsafe = true;\n         }\n \n         if (noUnsafe) {\n-            logger.debug(\"sun.misc.Unsafe: unavailable (io.netty.noUnsafe)\");\n-            return new UnsupportedOperationException(\"sun.misc.Unsafe: unavailable (io.netty.noUnsafe)\");\n+            String msg = \"sun.misc.Unsafe: unavailable (\" + reason + ')';\n+            logger.debug(msg);\n+            return new UnsupportedOperationException(msg);\n         }\n \n         // Legacy properties",
      "parent_sha": "46ce70a9ff303a1049cef097bb5cde5ad3536419"
    }
  },
  {
    "oid": "a75ac747f06483060070b2a303bf8917a6d7847c",
    "message": "Remove io.netty.packagePrefix system property\n\nMotivation:\nNow that the NativeLibraryLoader implicitly detects the shaded package prefix we no longer need the io.netty.packagePrefix system property.\n\nModifications:\n- Remove io.netty.packagePrefix processing from NativeLibraryLoader\n\nResult:\nCode is cleaner.",
    "date": "2017-08-04T08:53:29Z",
    "url": "https://github.com/netty/netty/commit/a75ac747f06483060070b2a303bf8917a6d7847c",
    "details": {
      "sha": "da8054a560c1c6e220b6399aacb46f90c7a298fe",
      "filename": "common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java",
      "status": "modified",
      "additions": 1,
      "deletions": 4,
      "changes": 5,
      "blob_url": "https://github.com/netty/netty/blob/a75ac747f06483060070b2a303bf8917a6d7847c/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2Finternal%2FNativeLibraryLoader.java",
      "raw_url": "https://github.com/netty/netty/raw/a75ac747f06483060070b2a303bf8917a6d7847c/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2Finternal%2FNativeLibraryLoader.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2Finternal%2FNativeLibraryLoader.java?ref=a75ac747f06483060070b2a303bf8917a6d7847c",
      "patch": "@@ -202,10 +202,7 @@ private static String calculatePackagePrefix() {\n      */\n     public static void load(String originalName, ClassLoader loader) {\n         // Adjust expected name to support shading of native libraries.\n-        String implicitPackagePrefix = calculatePackagePrefix();\n-        // The system property should not be necessary; it can be removed in the future.\n-        String packagePrefix = SystemPropertyUtil.get(\"io.netty.packagePrefix\", implicitPackagePrefix);\n-        String name = packagePrefix.replace('.', '-') + originalName;\n+        String name = calculatePackagePrefix().replace('.', '-') + originalName;\n \n         String libname = System.mapLibraryName(name);\n         String path = NATIVE_RESOURCE_HOME + libname;",
      "parent_sha": "32f497760f4fc18b797d53ed26b690f268f2ee2b"
    }
  },
  {
    "oid": "854859ba69f88c115a82a1a84228e2a860a1a873",
    "message": "Change AggregatedFullHttpMessage to contain a content ByteBuf\n\nMotivation:\n\nOther implementations of FullHttpMessage allow .toString to be called after the Message has been released\nThis brings AggregatedFullHttpMessage into line with those impls.\n\nModifications:\n\n- Changed AggregatedFullHttpMessage to no longer be a sub-class of DefaultByteBufHolder\n- Changes AggregatedFullHttpMessage to implement ByteBufHolder\n- Hold the content buffer internally to AggregatedFullHttpMessage\n- Implement the required content() and release() methods that were missing\n- Do not check refcnt when accessing content() (similar to DefaultFullHttpMessage)\n\nResult:\n\nA released AggregatedFullHttpMessage can have .toString called without throwing an exception",
    "date": "2015-04-16T12:43:50Z",
    "url": "https://github.com/netty/netty/commit/854859ba69f88c115a82a1a84228e2a860a1a873",
    "details": {
      "sha": "801ff7fa95530263c28aced6640406af35cf1a0b",
      "filename": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java",
      "status": "modified",
      "additions": 30,
      "deletions": 9,
      "changes": 39,
      "blob_url": "https://github.com/netty/netty/blob/854859ba69f88c115a82a1a84228e2a860a1a873/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2FHttpObjectAggregator.java",
      "raw_url": "https://github.com/netty/netty/raw/854859ba69f88c115a82a1a84228e2a860a1a873/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2FHttpObjectAggregator.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2FHttpObjectAggregator.java?ref=854859ba69f88c115a82a1a84228e2a860a1a873",
      "patch": "@@ -16,7 +16,7 @@\n package io.netty.handler.codec.http;\n \n import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.DefaultByteBufHolder;\n+import io.netty.buffer.ByteBufHolder;\n import io.netty.buffer.Unpooled;\n import io.netty.channel.ChannelFuture;\n import io.netty.channel.ChannelFutureListener;\n@@ -188,13 +188,14 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         }\n     }\n \n-    private abstract static class AggregatedFullHttpMessage extends DefaultByteBufHolder implements FullHttpMessage {\n+    private abstract static class AggregatedFullHttpMessage implements ByteBufHolder, FullHttpMessage {\n         protected final HttpMessage message;\n+        private final ByteBuf content;\n         private HttpHeaders trailingHeaders;\n \n         AggregatedFullHttpMessage(HttpMessage message, ByteBuf content, HttpHeaders trailingHeaders) {\n-            super(content);\n             this.message = message;\n+            this.content = content;\n             this.trailingHeaders = trailingHeaders;\n         }\n \n@@ -249,29 +250,49 @@ public void setDecoderResult(DecoderResult result) {\n         }\n \n         @Override\n-        public FullHttpMessage retain(int increment) {\n-            super.retain(increment);\n-            return this;\n+        public ByteBuf content() {\n+            return content;\n+        }\n+\n+        @Override\n+        public int refCnt() {\n+            return content.refCnt();\n         }\n \n         @Override\n         public FullHttpMessage retain() {\n-            super.retain();\n+            content.retain();\n+            return this;\n+        }\n+\n+        @Override\n+        public FullHttpMessage retain(int increment) {\n+            content.retain(increment);\n             return this;\n         }\n \n         @Override\n         public FullHttpMessage touch(Object hint) {\n-            super.touch(hint);\n+            content.touch(hint);\n             return this;\n         }\n \n         @Override\n         public FullHttpMessage touch() {\n-            super.touch();\n+            content.touch();\n             return this;\n         }\n \n+        @Override\n+        public boolean release() {\n+            return content.release();\n+        }\n+\n+        @Override\n+        public boolean release(int decrement) {\n+            return content.release(decrement);\n+        }\n+\n         @Override\n         public abstract FullHttpMessage copy();\n ",
      "parent_sha": "970529e1a80850b30262917b4a1e134f1c2e5aee"
    }
  },
  {
    "oid": "005fd55b8805ee2d510355395c199bc6a7912cc9",
    "message": "#7285 Improved \"Discarded inbound message\" warning for embedded channel (#9414)\n\nMotivation:\r\n\r\nLook like `EmbeddedChannelPipeline` should also override `onUnhandledInboundMessage(ChannelHandlerContext ctx, Object msg)` in order to do not print \"Discarded message pipeline\" because in case of `EmbeddedChannelPipeline` discarding actually not happens.\r\n\r\nThis fixes next warning in the latest netty version with websocket and `WebSocketServerCompressionHandler`:\r\n\r\n```\r\n13:36:36.231 DEBUG- Decoding WebSocket Frame opCode=2\r\n13:36:36.231 DEBUG- Decoding WebSocket Frame length=5\r\n13:36:36.231 DEBUG- Discarded message pipeline : [JdkZlibDecoder#0, DefaultChannelPipeline$TailContext#0]. Channel : [id: 0xembedded, L:embedded - R:embedded].\r\n```\r\n\r\nModification:\r\n\r\nOverride correct method\r\n\r\nResult:\r\nFollow up fix after https://github.com/netty/netty/pull/9286",
    "date": "2019-08-03T10:20:41Z",
    "url": "https://github.com/netty/netty/commit/005fd55b8805ee2d510355395c199bc6a7912cc9",
    "details": {
      "sha": "976d0b0fbbe4f5dfd27a9312a0ede1a9321b1f13",
      "filename": "transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/netty/netty/blob/005fd55b8805ee2d510355395c199bc6a7912cc9/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Fembedded%2FEmbeddedChannel.java",
      "raw_url": "https://github.com/netty/netty/raw/005fd55b8805ee2d510355395c199bc6a7912cc9/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Fembedded%2FEmbeddedChannel.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Fembedded%2FEmbeddedChannel.java?ref=005fd55b8805ee2d510355395c199bc6a7912cc9",
      "patch": "@@ -26,6 +26,7 @@\n import io.netty.channel.ChannelFuture;\n import io.netty.channel.ChannelFutureListener;\n import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.ChannelId;\n import io.netty.channel.ChannelInitializer;\n import io.netty.channel.ChannelMetadata;\n@@ -873,8 +874,8 @@ protected void onUnhandledInboundException(Throwable cause) {\n         }\n \n         @Override\n-        protected void onUnhandledInboundMessage(Object msg) {\n-          handleInboundMessage(msg);\n+        protected void onUnhandledInboundMessage(ChannelHandlerContext ctx, Object msg) {\n+            handleInboundMessage(msg);\n         }\n     }\n }",
      "parent_sha": "1194577bd053a8906823cf39ecfbb15fa1d9b08e"
    }
  },
  {
    "oid": "c5c3fbcb20eeeefd3e44edc93f3d8696cbb07f84",
    "message": "Updated Javadoc",
    "date": "2009-05-22T06:39:48Z",
    "url": "https://github.com/netty/netty/commit/c5c3fbcb20eeeefd3e44edc93f3d8696cbb07f84",
    "details": {
      "sha": "fe0e82c47b310a01cf82a4349249b189937c1d4f",
      "filename": "src/main/java/org/jboss/netty/handler/logging/LoggingHandler.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/netty/netty/blob/c5c3fbcb20eeeefd3e44edc93f3d8696cbb07f84/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Flogging%2FLoggingHandler.java",
      "raw_url": "https://github.com/netty/netty/raw/c5c3fbcb20eeeefd3e44edc93f3d8696cbb07f84/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Flogging%2FLoggingHandler.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Flogging%2FLoggingHandler.java?ref=c5c3fbcb20eeeefd3e44edc93f3d8696cbb07f84",
      "patch": "@@ -126,7 +126,9 @@ public InternalLogger getLogger() {\n \n     /**\n      * Logs the specified event to the {@link InternalLogger} returned by\n-     * {@link #getLogger()}.\n+     * {@link #getLogger()}. If hex dump has been enabled for this handler,\n+     * the hex dump of the {@link ChannelBuffer} in a {@link MessageEvent} will\n+     * be logged together.\n      */\n     public void log(ChannelEvent e) {\n         if (getLogger().isDebugEnabled()) {",
      "parent_sha": "1116ae4733d10ffd791851841b02fdd970087503"
    }
  },
  {
    "oid": "214448af034663f9cf9a542670f6047f1bfeaae8",
    "message": "Fix typo in AbstractSearchProcessorFactory.java (#11562)\n\nMotivation:\r\n\r\nFixed typo.\r\n\r\noccurences -> occurrences",
    "date": "2021-08-09T16:28:40Z",
    "url": "https://github.com/netty/netty/commit/214448af034663f9cf9a542670f6047f1bfeaae8",
    "details": {
      "sha": "f76b2d3e53e5e2b0895a8b5b9f391fc1fa2c3b6b",
      "filename": "buffer/src/main/java/io/netty/buffer/search/AbstractSearchProcessorFactory.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/214448af034663f9cf9a542670f6047f1bfeaae8/buffer%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fbuffer%2Fsearch%2FAbstractSearchProcessorFactory.java",
      "raw_url": "https://github.com/netty/netty/raw/214448af034663f9cf9a542670f6047f1bfeaae8/buffer%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fbuffer%2Fsearch%2FAbstractSearchProcessorFactory.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/buffer%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fbuffer%2Fsearch%2FAbstractSearchProcessorFactory.java?ref=214448af034663f9cf9a542670f6047f1bfeaae8",
      "patch": "@@ -39,7 +39,7 @@\n  * {@link io.netty.buffer.ByteBuf}s). A new instance should be created with {@link AbstractSearchProcessorFactory} for\n  * every search session. However, a {@link SearchProcessor} can (and should) be reused within the search session,\n  * eg. when searching for all occurrences of the {@code needle} within the same {@code haystack}. That way, it can\n- * also detect overlapping occurrences of the {@code needle} (eg. a string \"ABABAB\" contains two occurences of \"BAB\"\n+ * also detect overlapping occurrences of the {@code needle} (eg. a string \"ABABAB\" contains two occurrences of \"BAB\"\n  * that overlap by one character \"B\"). For this to work correctly, after an occurrence of the {@code needle} is\n  * found ending at index {@code idx}, the search should continue starting from the index {@code idx + 1}.\n  * <br>",
      "parent_sha": "1e6a34affd20eb31c623eeaac77508169d780d6f"
    }
  },
  {
    "oid": "02a2738cd21038af7e437e67bb4aa1410b3ad43d",
    "message": "Do not try to use cleaner if no unsafe\n\nMotivation:\n\nIf unsafe is unavailable, we can not use the cleaner anyway. If we try\nto set it up, we get an annoying log message about unsafe being\nunavailable (when debug logging is enabled). We know this will fail, so\nwe should not even bother and avoid the log message.\n\nModifications:\n\nThis commit adds a guard against setting up the cleaner if it is not\ngoing to be available because unsafe is unavailable.\n\nResult:\n\nWe do not try to set up the cleaner if unsafe is unavailable, and we do\nnot get an annoying log message.",
    "date": "2017-05-03T20:36:00Z",
    "url": "https://github.com/netty/netty/commit/02a2738cd21038af7e437e67bb4aa1410b3ad43d",
    "details": {
      "sha": "fcc1c20f136d35bb5eb33ba7d604a04a37433485",
      "filename": "common/src/main/java/io/netty/util/internal/PlatformDependent.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/02a2738cd21038af7e437e67bb4aa1410b3ad43d/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2Finternal%2FPlatformDependent.java",
      "raw_url": "https://github.com/netty/netty/raw/02a2738cd21038af7e437e67bb4aa1410b3ad43d/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2Finternal%2FPlatformDependent.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2Finternal%2FPlatformDependent.java?ref=02a2738cd21038af7e437e67bb4aa1410b3ad43d",
      "patch": "@@ -175,7 +175,7 @@ public Random current() {\n \n         MAYBE_SUPER_USER = maybeSuperUser0();\n \n-        if (!isAndroid()) {\n+        if (!isAndroid() && hasUnsafe()) {\n             // only direct to method if we are not running on android.\n             // See https://github.com/netty/netty/issues/2604\n             if (javaVersion() >= 9) {",
      "parent_sha": "9a0fd3a7b892438fccff3d63946756160a8647fe"
    }
  },
  {
    "oid": "959e72a6b04aef3818fbb37e629a3c51a40c9277",
    "message": "Removed unnecessary SuppressWarnings annotations",
    "date": "2009-06-30T01:16:54Z",
    "url": "https://github.com/netty/netty/commit/959e72a6b04aef3818fbb37e629a3c51a40c9277",
    "details": {
      "sha": "df24acd2f46eaaba16643fcbac741d34ff413b83",
      "filename": "src/main/java/org/jboss/netty/channel/Channels.java",
      "status": "modified",
      "additions": 11,
      "deletions": 22,
      "changes": 33,
      "blob_url": "https://github.com/netty/netty/blob/959e72a6b04aef3818fbb37e629a3c51a40c9277/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fchannel%2FChannels.java",
      "raw_url": "https://github.com/netty/netty/raw/959e72a6b04aef3818fbb37e629a3c51a40c9277/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fchannel%2FChannels.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fchannel%2FChannels.java?ref=959e72a6b04aef3818fbb37e629a3c51a40c9277",
      "patch": "@@ -449,8 +449,7 @@ public static void fireChannelInterestChanged(Channel channel) {\n      * @param interestOps the new interestOps\n      */\n     @Deprecated\n-    public static void fireChannelInterestChanged(\n-            Channel channel, @SuppressWarnings(\"unused\") int interestOps) {\n+    public static void fireChannelInterestChanged(Channel channel, int interestOps) {\n         fireChannelInterestChanged(channel);\n     }\n \n@@ -474,13 +473,12 @@ public static void fireChannelInterestChanged(\n      * {@link ChannelUpstreamHandler} in the {@link ChannelPipeline} where\n      * the specified {@link ChannelHandlerContext} belongs.\n      *\n+     * @param channel     the {@link Channel}\n      * @param interestOps the new interestOps\n      */\n     @Deprecated\n     public static void fireChannelInterestChanged(\n-            ChannelHandlerContext ctx,\n-            @SuppressWarnings(\"unused\") Channel channel,\n-            @SuppressWarnings(\"unused\") int interestOps) {\n+            ChannelHandlerContext ctx, Channel channel, int interestOps) {\n \n         fireChannelInterestChanged(ctx);\n     }\n@@ -691,8 +689,7 @@ public static void bind(\n      */\n     @Deprecated\n     public static void bind(\n-            ChannelHandlerContext ctx,\n-            @SuppressWarnings(\"unused\") Channel channel,\n+            ChannelHandlerContext ctx, Channel channel,\n             ChannelFuture future, SocketAddress localAddress) {\n         bind(ctx, future, localAddress);\n     }\n@@ -725,9 +722,7 @@ public static void unbind(ChannelHandlerContext ctx, ChannelFuture future) {\n      */\n     @Deprecated\n     public static void unbind(\n-            ChannelHandlerContext ctx,\n-            @SuppressWarnings(\"unused\") Channel channel,\n-            ChannelFuture future) {\n+            ChannelHandlerContext ctx, Channel channel, ChannelFuture future) {\n         unbind(ctx, future);\n     }\n \n@@ -803,8 +798,7 @@ public static void connect(\n      */\n     @Deprecated\n     public static void connect(\n-            ChannelHandlerContext ctx,\n-            @SuppressWarnings(\"unused\") Channel channel,\n+            ChannelHandlerContext ctx, Channel channel,\n             ChannelFuture future, SocketAddress remoteAddress) {\n         connect(ctx, future, remoteAddress);\n     }\n@@ -852,8 +846,7 @@ public static void write(\n      */\n     @Deprecated\n     public static void write(\n-            ChannelHandlerContext ctx,\n-            @SuppressWarnings(\"unused\") Channel channel,\n+            ChannelHandlerContext ctx, Channel channel,\n             ChannelFuture future, Object message) {\n         write(ctx, future, message, null);\n     }\n@@ -914,8 +907,7 @@ public static void write(\n      */\n     @Deprecated\n     public static void write(\n-            ChannelHandlerContext ctx,\n-            @SuppressWarnings(\"unused\") Channel channel,\n+            ChannelHandlerContext ctx, Channel channel,\n             ChannelFuture future, Object message, SocketAddress remoteAddress) {\n         write(ctx, future, message, remoteAddress);\n     }\n@@ -975,8 +967,7 @@ public static void setInterestOps(\n      */\n     @Deprecated\n     public static void setInterestOps(\n-            ChannelHandlerContext ctx,\n-            @SuppressWarnings(\"unused\") Channel channel,\n+            ChannelHandlerContext ctx, Channel channel,\n             ChannelFuture future, int interestOps) {\n         setInterestOps(ctx, future, interestOps);\n     }\n@@ -1024,8 +1015,7 @@ public static void disconnect(\n      */\n     @Deprecated\n     public static void disconnect(\n-            ChannelHandlerContext ctx,\n-            @SuppressWarnings(\"unused\") Channel channel, ChannelFuture future) {\n+            ChannelHandlerContext ctx, Channel channel, ChannelFuture future) {\n         disconnect(ctx, future);\n     }\n \n@@ -1072,8 +1062,7 @@ public static void close(\n      */\n     @Deprecated\n     public static void close(\n-            ChannelHandlerContext ctx,\n-            @SuppressWarnings(\"unused\") Channel channel, ChannelFuture future) {\n+            ChannelHandlerContext ctx, Channel channel, ChannelFuture future) {\n         close(ctx, future);\n     }\n ",
      "parent_sha": "e9d2c503f3bedad1affa49e9533bab610a806ef9"
    }
  },
  {
    "oid": "90c0481ecf6c69aa1d7368e4d3918e1616159059",
    "message": "[#712] Fix parsing dates in the past bug in CookieDecoder",
    "date": "2012-11-08T08:38:32Z",
    "url": "https://github.com/netty/netty/commit/90c0481ecf6c69aa1d7368e4d3918e1616159059",
    "details": {
      "sha": "5cdaa2523cfef377d25eb2b4f03f23ae2aa842e6",
      "filename": "codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java",
      "status": "modified",
      "additions": 3,
      "deletions": 5,
      "changes": 8,
      "blob_url": "https://github.com/netty/netty/blob/90c0481ecf6c69aa1d7368e4d3918e1616159059/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2FCookieDecoder.java",
      "raw_url": "https://github.com/netty/netty/raw/90c0481ecf6c69aa1d7368e4d3918e1616159059/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2FCookieDecoder.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2FCookieDecoder.java?ref=90c0481ecf6c69aa1d7368e4d3918e1616159059",
      "patch": "@@ -120,11 +120,9 @@ public static Set<Cookie> decode(String header) {\n                         long maxAgeMillis =\n                             new HttpHeaderDateFormat().parse(value).getTime() -\n                             System.currentTimeMillis();\n-                        if (maxAgeMillis <= 0) {\n-                            maxAge = 0;\n-                        } else {\n-                            maxAge = maxAgeMillis / 1000 + (maxAgeMillis % 1000 != 0? 1 : 0);\n-                        }\n+\n+                        maxAge = maxAgeMillis / 1000 + (maxAgeMillis % 1000 != 0? 1 : 0);\n+\n                     } catch (ParseException e) {\n                         // Ignore.\n                     }",
      "parent_sha": "1a7e7a1bff51e4f4a6c76d4cb17478900dd56cb0"
    }
  },
  {
    "oid": "a2f1f216122eb40c849ffa31431c93a8988de124",
    "message": "Synchronized between 4.1 and master\n\nMotivation:\n\n4 and 5 were diverged long time ago and we recently reverted some of the\nearly commits in master.  We must make sure 4.1 and master are not very\ndifferent now.\n\nModification:\n\nSmall adjustments to match up branches\n\nResult:\n\n4.1 and master got closer.",
    "date": "2014-04-24T19:04:20Z",
    "url": "https://github.com/netty/netty/commit/a2f1f216122eb40c849ffa31431c93a8988de124",
    "details": {
      "sha": "1443425ed7acbe9f16cd7cd64b5939051aae5280",
      "filename": "transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java",
      "status": "modified",
      "additions": 5,
      "deletions": 21,
      "changes": 26,
      "blob_url": "https://github.com/netty/netty/blob/a2f1f216122eb40c849ffa31431c93a8988de124/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FDefaultChannelPipeline.java",
      "raw_url": "https://github.com/netty/netty/raw/a2f1f216122eb40c849ffa31431c93a8988de124/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FDefaultChannelPipeline.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FDefaultChannelPipeline.java?ref=a2f1f216122eb40c849ffa31431c93a8988de124",
      "patch": "@@ -537,7 +537,7 @@ private static void checkMultiplicity(ChannelHandlerContext ctx) {\n         }\n     }\n \n-    private void callHandlerAdded(final ChannelHandlerContext ctx) {\n+    private void callHandlerAdded(final DefaultChannelHandlerContext ctx) {\n         if (ctx.channel().isRegistered() && !ctx.executor().inEventLoop()) {\n             ctx.executor().execute(new Runnable() {\n                 @Override\n@@ -550,13 +550,13 @@ public void run() {\n         callHandlerAdded0(ctx);\n     }\n \n-    private void callHandlerAdded0(final ChannelHandlerContext ctx) {\n+    private void callHandlerAdded0(final DefaultChannelHandlerContext ctx) {\n         try {\n             ctx.handler().handlerAdded(ctx);\n         } catch (Throwable t) {\n             boolean removed = false;\n             try {\n-                remove((DefaultChannelHandlerContext) ctx);\n+                remove(ctx);\n                 removed = true;\n             } catch (Throwable t2) {\n                 if (logger.isWarnEnabled()) {\n@@ -934,7 +934,7 @@ public ChannelFuture close(ChannelPromise promise) {\n     }\n \n     @Override\n-    public ChannelFuture deregister(final ChannelPromise promise) {\n+    public ChannelFuture deregister(ChannelPromise promise) {\n         return tail.deregister(promise);\n     }\n \n@@ -1046,24 +1046,14 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception\n         public void channelReadComplete(ChannelHandlerContext ctx) throws Exception { }\n     }\n \n-    static final class HeadHandler implements ChannelOutboundHandler {\n+    static final class HeadHandler extends ChannelOutboundHandlerAdapter {\n \n         private final Unsafe unsafe;\n \n         HeadHandler(Unsafe unsafe) {\n             this.unsafe = unsafe;\n         }\n \n-        @Override\n-        public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n-            // NOOP\n-        }\n-\n-        @Override\n-        public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {\n-            // NOOP\n-        }\n-\n         @Override\n         public void bind(\n                 ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)\n@@ -1090,7 +1080,6 @@ public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exce\n         }\n \n         @Override\n-        @Deprecated\n         public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n             unsafe.deregister(promise);\n         }\n@@ -1109,10 +1098,5 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n         public void flush(ChannelHandlerContext ctx) throws Exception {\n             unsafe.flush();\n         }\n-\n-        @Override\n-        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n-            ctx.fireExceptionCaught(cause);\n-        }\n     }\n }",
      "parent_sha": "db3709e652dfc42514fd61698a4114941916ff7e"
    }
  },
  {
    "oid": "efe7fd953987fba670c6e7c7c2d213512e5ed5a5",
    "message": "Uncomment logging in EchoServer",
    "date": "2012-05-11T23:31:55Z",
    "url": "https://github.com/netty/netty/commit/efe7fd953987fba670c6e7c7c2d213512e5ed5a5",
    "details": {
      "sha": "fa4788d4349a18cc880fb4110195d9d2bec5a91c",
      "filename": "example/src/main/java/io/netty/example/echo/EchoServer.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/efe7fd953987fba670c6e7c7c2d213512e5ed5a5/example%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fexample%2Fecho%2FEchoServer.java",
      "raw_url": "https://github.com/netty/netty/raw/efe7fd953987fba670c6e7c7c2d213512e5ed5a5/example%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fexample%2Fecho%2FEchoServer.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/example%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fexample%2Fecho%2FEchoServer.java?ref=efe7fd953987fba670c6e7c7c2d213512e5ed5a5",
      "patch": "@@ -72,7 +72,7 @@ public void inboundBufferUpdated(\n                         break;\n                     }\n                     s.config().setTcpNoDelay(true);\n-                    //s.pipeline().addLast(\"logger\", new LoggingHandler(InternalLogLevel.INFO));\n+                    s.pipeline().addLast(\"logger\", new LoggingHandler(InternalLogLevel.INFO));\n                     s.pipeline().addLast(\"echoer\", new ChannelInboundHandlerAdapter<Byte>() {\n                         @Override\n                         public ChannelBufferHolder<Byte> newInboundBuffer(ChannelInboundHandlerContext<Byte> ctx) {",
      "parent_sha": "7a5f4721b9f6e5c9e9194167955d767c4e8655f4"
    }
  },
  {
    "oid": "b843b602bad43f4bf321eb4983c2dd51af1e923d",
    "message": "Only schedule timeouts when send outgoing packets\n\nMotivation:\n\nWe only need to schedule timeouts when sending outgoing packets.\n\nModifications:\n\nOnly schedule timeouts when sending outgoing packets\n\nResult:\n\nCorrect timeout management",
    "date": "2020-11-07T16:38:15Z",
    "url": "https://github.com/netty/netty/commit/b843b602bad43f4bf321eb4983c2dd51af1e923d",
    "details": {
      "sha": "4be48a0f2aa00913332b77e64c95f169f34daee9",
      "filename": "src/main/java/io/netty/incubator/codec/quic/QuicheQuicChannel.java",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/netty/netty/blob/b843b602bad43f4bf321eb4983c2dd51af1e923d/src%2Fmain%2Fjava%2Fio%2Fnetty%2Fincubator%2Fcodec%2Fquic%2FQuicheQuicChannel.java",
      "raw_url": "https://github.com/netty/netty/raw/b843b602bad43f4bf321eb4983c2dd51af1e923d/src%2Fmain%2Fjava%2Fio%2Fnetty%2Fincubator%2Fcodec%2Fquic%2FQuicheQuicChannel.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/src%2Fmain%2Fjava%2Fio%2Fnetty%2Fincubator%2Fcodec%2Fquic%2FQuicheQuicChannel.java?ref=b843b602bad43f4bf321eb4983c2dd51af1e923d",
      "patch": "@@ -238,6 +238,7 @@ boolean flushEgress() {\n         }\n         if (writeDone) {\n             // Schedule timeout.\n+            // See https://docs.rs/quiche/0.6.0/quiche/#generating-outgoing-packets\n             scheduleTimeout();\n         }\n         return writeDone;\n@@ -280,9 +281,6 @@ boolean recvForConnection(ByteBuf buffer) {\n                 return fireChannelRead;\n             } finally {\n                 buffer.skipBytes((int) (memoryAddress - buffer.memoryAddress()));\n-\n-                // Schedule timeout.\n-                scheduleTimeout();\n             }\n         }\n ",
      "parent_sha": "a1a2be724a3b5b51d03a686e0daaf9d7e77f8aa1"
    }
  },
  {
    "oid": "16b40d8a37937fd6e73858db2f05bd1e778a1d6f",
    "message": "SslHandler consolidate state to save memory (#11160)\n\nMotivation:\r\nSslHandler has many independent boolean member variables. They can be\r\ncollapsed into a single variable to save memory.\r\n\r\nModifications:\r\n- SslHandler boolean state consolidated into a single short variable.\r\n\r\nResult:\r\nSavings of 8 bytes per SslHandler (which is per connection) observed on\r\nOpenJDK.",
    "date": "2021-04-15T15:18:54Z",
    "url": "https://github.com/netty/netty/commit/16b40d8a37937fd6e73858db2f05bd1e778a1d6f",
    "details": {
      "sha": "6ecd20d8171d2a20d4cc26844933fd082588eb1b",
      "filename": "handler/src/main/java/io/netty/handler/ssl/SslHandler.java",
      "status": "modified",
      "additions": 70,
      "deletions": 61,
      "changes": 131,
      "blob_url": "https://github.com/netty/netty/blob/16b40d8a37937fd6e73858db2f05bd1e778a1d6f/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2FSslHandler.java",
      "raw_url": "https://github.com/netty/netty/raw/16b40d8a37937fd6e73858db2f05bd1e778a1d6f/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2FSslHandler.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2FSslHandler.java?ref=16b40d8a37937fd6e73858db2f05bd1e778a1d6f",
      "patch": "@@ -167,14 +167,29 @@\n  * <a href=\"https://github.com/netty/netty/issues/832\">#832</a> in our issue tracker.\n  */\n public class SslHandler extends ByteToMessageDecoder implements ChannelOutboundHandler {\n-\n     private static final InternalLogger logger =\n             InternalLoggerFactory.getInstance(SslHandler.class);\n-\n     private static final Pattern IGNORABLE_CLASS_IN_STACK = Pattern.compile(\n             \"^.*(?:Socket|Datagram|Sctp|Udt)Channel.*$\");\n     private static final Pattern IGNORABLE_ERROR_MESSAGE = Pattern.compile(\n             \"^.*(?:connection.*(?:reset|closed|abort|broken)|broken.*pipe).*$\", Pattern.CASE_INSENSITIVE);\n+    private static final int STATE_SENT_FIRST_MESSAGE = 1;\n+    private static final int STATE_FLUSHED_BEFORE_HANDSHAKE = 1 << 1;\n+    private static final int STATE_READ_DURING_HANDSHAKE = 1 << 2;\n+    private static final int STATE_HANDSHAKE_STARTED = 1 << 3;\n+    /**\n+     * Set by wrap*() methods when something is produced.\n+     * {@link #channelReadComplete(ChannelHandlerContext)} will check this flag, clear it, and call ctx.flush().\n+     */\n+    private static final int STATE_NEEDS_FLUSH = 1 << 4;\n+    private static final int STATE_OUTBOUND_CLOSED = 1 << 5;\n+    private static final int STATE_CLOSE_NOTIFY = 1 << 6;\n+    private static final int STATE_PROCESS_TASK = 1 << 7;\n+    /**\n+     * This flag is used to determine if we need to call {@link ChannelHandlerContext#read()} to consume more data\n+     * when {@link ChannelConfig#isAutoRead()} is {@code false}.\n+     */\n+    private static final int STATE_FIRE_CHANNEL_READ = 1 << 8;\n \n     /**\n      * <a href=\"https://tools.ietf.org/html/rfc5246#section-6.2\">2^14</a> which is the maximum sized plaintext chunk\n@@ -380,32 +395,13 @@ abstract ByteBuf allocateWrapBuffer(SslHandler handler, ByteBufAllocator allocat\n     private final ByteBuffer[] singleBuffer = new ByteBuffer[1];\n \n     private final boolean startTls;\n-    private boolean sentFirstMessage;\n-    private boolean flushedBeforeHandshake;\n-    private boolean readDuringHandshake;\n-    private boolean handshakeStarted;\n \n     private SslHandlerCoalescingBufferQueue pendingUnencryptedWrites;\n     private Promise<Channel> handshakePromise = new LazyChannelPromise();\n     private final LazyChannelPromise sslClosePromise = new LazyChannelPromise();\n \n-    /**\n-     * Set by wrap*() methods when something is produced.\n-     * {@link #channelReadComplete(ChannelHandlerContext)} will check this flag, clear it, and call ctx.flush().\n-     */\n-    private boolean needsFlush;\n-\n-    private boolean outboundClosed;\n-    private boolean closeNotify;\n-    private boolean processTask;\n-\n     private int packetLength;\n-\n-    /**\n-     * This flag is used to determine if we need to call {@link ChannelHandlerContext#read()} to consume more data\n-     * when {@link ChannelConfig#isAutoRead()} is {@code false}.\n-     */\n-    private boolean firedChannelRead;\n+    private short state;\n \n     private volatile long handshakeTimeoutMillis = 10000;\n     private volatile long closeNotifyFlushTimeoutMillis = 3000;\n@@ -664,7 +660,7 @@ public void run() {\n     }\n \n     private void closeOutbound0(ChannelPromise promise) {\n-        outboundClosed = true;\n+        setState(STATE_OUTBOUND_CLOSED);\n         engine.closeOutbound();\n         try {\n             flush(ctx, promise);\n@@ -748,7 +744,7 @@ public void close(final ChannelHandlerContext ctx,\n     @Override\n     public void read(ChannelHandlerContext ctx) throws Exception {\n         if (!handshakePromise.isDone()) {\n-            readDuringHandshake = true;\n+            setState(STATE_READ_DURING_HANDSHAKE);\n         }\n \n         ctx.read();\n@@ -776,8 +772,8 @@ public void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise pr\n     public void flush(ChannelHandlerContext ctx) throws Exception {\n         // Do not encrypt the first write request if this handler is\n         // created with startTLS flag turned on.\n-        if (startTls && !sentFirstMessage) {\n-            sentFirstMessage = true;\n+        if (startTls && !isStateSet(STATE_SENT_FIRST_MESSAGE)) {\n+            setState(STATE_SENT_FIRST_MESSAGE);\n             pendingUnencryptedWrites.writeAndRemoveAll(ctx);\n             forceFlush(ctx);\n             // Explicit start handshake processing once we send the first message. This will also ensure\n@@ -786,7 +782,7 @@ public void flush(ChannelHandlerContext ctx) throws Exception {\n             return;\n         }\n \n-        if (processTask) {\n+        if (isStateSet(STATE_PROCESS_TASK)) {\n             return;\n         }\n \n@@ -807,7 +803,7 @@ private void wrapAndFlush(ChannelHandlerContext ctx) throws SSLException {\n             pendingUnencryptedWrites.add(Unpooled.EMPTY_BUFFER, ctx.newPromise());\n         }\n         if (!handshakePromise.isDone()) {\n-            flushedBeforeHandshake = true;\n+            setState(STATE_FLUSHED_BEFORE_HANDSHAKE);\n         }\n         try {\n             wrap(ctx, false);\n@@ -917,7 +913,7 @@ private void wrap(ChannelHandlerContext ctx, boolean inUnwrap) throws SSLExcepti\n                 out.release();\n             }\n             if (inUnwrap) {\n-                needsFlush = true;\n+                setState(STATE_NEEDS_FLUSH);\n             }\n         }\n     }\n@@ -953,7 +949,7 @@ public void operationComplete(ChannelFuture future) {\n                         }\n                     });\n                     if (inUnwrap) {\n-                        needsFlush = true;\n+                        setState(STATE_NEEDS_FLUSH);\n                     }\n                     out = null;\n                 }\n@@ -1083,7 +1079,8 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n         ClosedChannelException exception = new ClosedChannelException();\n         // Make sure to release SSLEngine,\n         // and notify the handshake future if the connection has been closed during handshake.\n-        setHandshakeFailure(ctx, exception, !outboundClosed, handshakeStarted, false);\n+        setHandshakeFailure(ctx, exception, !isStateSet(STATE_OUTBOUND_CLOSED), isStateSet(STATE_HANDSHAKE_STARTED),\n+                false);\n \n         // Ensure we always notify the sslClosePromise as well\n         notifyClosePromise(exception);\n@@ -1293,7 +1290,7 @@ private void handleUnwrapThrowable(ChannelHandlerContext ctx, Throwable cause) {\n \n     @Override\n     protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws SSLException {\n-        if (processTask) {\n+        if (isStateSet(STATE_PROCESS_TASK)) {\n             return;\n         }\n         if (jdkCompatibilityMode) {\n@@ -1315,21 +1312,22 @@ private void channelReadComplete0(ChannelHandlerContext ctx) {\n         flushIfNeeded(ctx);\n         readIfNeeded(ctx);\n \n-        firedChannelRead = false;\n+        clearState(STATE_FIRE_CHANNEL_READ);\n         ctx.fireChannelReadComplete();\n     }\n \n     private void readIfNeeded(ChannelHandlerContext ctx) {\n         // If handshake is not finished yet, we need more data.\n-        if (!ctx.channel().config().isAutoRead() && (!firedChannelRead || !handshakePromise.isDone())) {\n+        if (!ctx.channel().config().isAutoRead() &&\n+                (!isStateSet(STATE_FIRE_CHANNEL_READ) || !handshakePromise.isDone())) {\n             // No auto-read used and no message passed through the ChannelPipeline or the handshake was not complete\n             // yet, which means we need to trigger the read to ensure we not encounter any stalls.\n             ctx.read();\n         }\n     }\n \n     private void flushIfNeeded(ChannelHandlerContext ctx) {\n-        if (needsFlush) {\n+        if (isStateSet(STATE_NEEDS_FLUSH)) {\n             forceFlush(ctx);\n         }\n     }\n@@ -1372,7 +1370,7 @@ private int unwrap(\n                     overflowReadableBytes = readableBytes;\n                     int bufferSize = engine.getSession().getApplicationBufferSize() - readableBytes;\n                     if (readableBytes > 0) {\n-                        firedChannelRead = true;\n+                        setState(STATE_FIRE_CHANNEL_READ);\n                         ctx.fireChannelRead(decodeOut);\n \n                         // This buffer was handled, null it out.\n@@ -1480,12 +1478,12 @@ private int unwrap(\n                 }\n             }\n \n-            if (flushedBeforeHandshake && handshakePromise.isDone()) {\n+            if (isStateSet(STATE_FLUSHED_BEFORE_HANDSHAKE) && handshakePromise.isDone()) {\n                 // We need to call wrap(...) in case there was a flush done before the handshake completed to ensure\n                 // we do not stale.\n                 //\n                 // See https://github.com/netty/netty/pull/2437\n-                flushedBeforeHandshake = false;\n+                clearState(STATE_FLUSHED_BEFORE_HANDSHAKE);\n                 wrapLater = true;\n             }\n \n@@ -1495,7 +1493,7 @@ private int unwrap(\n         } finally {\n             if (decodeOut != null) {\n                 if (decodeOut.isReadable()) {\n-                    firedChannelRead = true;\n+                    setState(STATE_FIRE_CHANNEL_READ);\n \n                     ctx.fireChannelRead(decodeOut);\n                 } else {\n@@ -1548,11 +1546,11 @@ private boolean runDelegatedTasks(boolean inUnwrap) {\n     }\n \n     private void executeDelegatedTasks(boolean inUnwrap) {\n-        processTask = true;\n+        setState(STATE_PROCESS_TASK);\n         try {\n             delegatedTaskExecutor.execute(new SslTasksRunner(inUnwrap));\n         } catch (RejectedExecutionException e) {\n-            processTask = false;\n+            clearState(STATE_PROCESS_TASK);\n             throw e;\n         }\n     }\n@@ -1624,9 +1622,7 @@ private void tryDecodeAgain() {\n          */\n         private void resumeOnEventExecutor() {\n             assert ctx.executor().inEventLoop();\n-\n-            processTask = false;\n-\n+            clearState(STATE_PROCESS_TASK);\n             try {\n                 HandshakeStatus status = engine.getHandshakeStatus();\n                 switch (status) {\n@@ -1731,19 +1727,19 @@ public void run() {\n \n         private void handleException(final Throwable cause) {\n             if (ctx.executor().inEventLoop()) {\n-                processTask = false;\n+                clearState(STATE_PROCESS_TASK);\n                 safeExceptionCaught(cause);\n             } else {\n                 try {\n                     ctx.executor().execute(new Runnable() {\n                         @Override\n                         public void run() {\n-                            processTask = false;\n+                            clearState(STATE_PROCESS_TASK);\n                             safeExceptionCaught(cause);\n                         }\n                     });\n                 } catch (RejectedExecutionException ignore) {\n-                    processTask = false;\n+                    clearState(STATE_PROCESS_TASK);\n                     // the context itself will handle the rejected exception when try to schedule the operation so\n                     // ignore the RejectedExecutionException\n                     ctx.fireExceptionCaught(cause);\n@@ -1769,8 +1765,8 @@ private boolean setHandshakeSuccessIfStillHandshaking() {\n      * was fired. {@code false} otherwise.\n      */\n     private boolean setHandshakeSuccess() {\n-        if (readDuringHandshake && !ctx.channel().config().isAutoRead()) {\n-            readDuringHandshake = false;\n+        if (isStateSet(STATE_READ_DURING_HANDSHAKE) && !ctx.channel().config().isAutoRead()) {\n+            clearState(STATE_READ_DURING_HANDSHAKE);\n             ctx.read();\n         }\n         // Our control flow may invoke this method multiple times for a single FINISHED event. For example\n@@ -1805,9 +1801,8 @@ private void setHandshakeFailure(ChannelHandlerContext ctx, Throwable cause) {\n     private void setHandshakeFailure(ChannelHandlerContext ctx, Throwable cause, boolean closeInbound,\n                                      boolean notify, boolean alwaysFlushAndClose) {\n         try {\n-            // Release all resources such as internal buffers that SSLEngine\n-            // is managing.\n-            outboundClosed = true;\n+            // Release all resources such as internal buffers that SSLEngine is managing.\n+            setState(STATE_OUTBOUND_CLOSED);\n             engine.closeOutbound();\n \n             if (closeInbound) {\n@@ -1871,7 +1866,7 @@ private void notifyClosePromise(Throwable cause) {\n \n     private void closeOutboundAndChannel(\n             final ChannelHandlerContext ctx, final ChannelPromise promise, boolean disconnect) throws Exception {\n-        outboundClosed = true;\n+        setState(STATE_OUTBOUND_CLOSED);\n         engine.closeOutbound();\n \n         if (!ctx.channel().isActive()) {\n@@ -1887,8 +1882,8 @@ private void closeOutboundAndChannel(\n         try {\n             flush(ctx, closeNotifyPromise);\n         } finally {\n-            if (!closeNotify) {\n-                closeNotify = true;\n+            if (!isStateSet(STATE_CLOSE_NOTIFY)) {\n+                setState(STATE_CLOSE_NOTIFY);\n                 // It's important that we do not pass the original ChannelPromise to safeClose(...) as when flush(....)\n                 // throws an Exception it will be propagated to the AbstractChannelHandlerContext which will try\n                 // to fail the promise because of this. This will then fail as it was already completed by\n@@ -1936,22 +1931,24 @@ public void handlerAdded(final ChannelHandlerContext ctx) throws Exception {\n             // If we weren't able to include client_hello in the TCP SYN (e.g. no token, disabled at the OS) we have to\n             // flush pending data in the outbound buffer later in channelActive().\n             final ChannelOutboundBuffer outboundBuffer;\n-            needsFlush |= fastOpen && ((outboundBuffer = channel.unsafe().outboundBuffer()) == null ||\n-                    outboundBuffer.totalPendingWriteBytes() > 0);\n+            if (fastOpen && ((outboundBuffer = channel.unsafe().outboundBuffer()) == null ||\n+                    outboundBuffer.totalPendingWriteBytes() > 0)) {\n+                setState(STATE_NEEDS_FLUSH);\n+            }\n         }\n     }\n \n     private void startHandshakeProcessing(boolean flushAtEnd) {\n-        if (!handshakeStarted) {\n-            handshakeStarted = true;\n+        if (!isStateSet(STATE_HANDSHAKE_STARTED)) {\n+            setState(STATE_HANDSHAKE_STARTED);\n             if (engine.getUseClientMode()) {\n                 // Begin the initial handshake.\n                 // channelActive() event has been fired already, which means this.channelActive() will\n                 // not be invoked. We have to initialize here instead.\n                 handshake(flushAtEnd);\n             }\n             applyHandshakeTimeout();\n-        } else if (needsFlush) {\n+        } else if (isStateSet(STATE_NEEDS_FLUSH)) {\n             forceFlush(ctx);\n         }\n     }\n@@ -2079,7 +2076,7 @@ public void operationComplete(Future<Channel> f) throws Exception {\n     }\n \n     private void forceFlush(ChannelHandlerContext ctx) {\n-        needsFlush = false;\n+        clearState(STATE_NEEDS_FLUSH);\n         ctx.flush();\n     }\n \n@@ -2205,6 +2202,18 @@ private ByteBuf allocateOutNetBuf(ChannelHandlerContext ctx, int pendingBytes, i\n         return engineType.allocateWrapBuffer(this, ctx.alloc(), pendingBytes, numComponents);\n     }\n \n+    private boolean isStateSet(int bit) {\n+        return (state & bit) == bit;\n+    }\n+\n+    private void setState(int bit) {\n+        state |= bit;\n+    }\n+\n+    private void clearState(int bit) {\n+        state &= ~bit;\n+    }\n+\n     /**\n      * Each call to SSL_write will introduce about ~100 bytes of overhead. This coalescing queue attempts to increase\n      * goodput by aggregating the plaintext in chunks of {@link #wrapDataSize}. If many small chunks are written",
      "parent_sha": "c93419ba57a97f86b5fbc2196c19a9efd0ed51ba"
    }
  },
  {
    "oid": "2e3b8f13ea902b6c1e56ad36473c400ef1012daa",
    "message": "Revert \"Let ProtobufEncoder extend MessageToByteEncoder which makes more sense. Related to [#1222]\"\n\nThis reverts commit 6a9d055f578bc85eb7780dcc5484aa11e9da50f6.",
    "date": "2013-04-02T05:56:49Z",
    "url": "https://github.com/netty/netty/commit/2e3b8f13ea902b6c1e56ad36473c400ef1012daa",
    "details": {
      "sha": "70d8a8719e472f24054f54a6e338636eddca980d",
      "filename": "codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufEncoder.java",
      "status": "modified",
      "additions": 8,
      "deletions": 6,
      "changes": 14,
      "blob_url": "https://github.com/netty/netty/blob/2e3b8f13ea902b6c1e56ad36473c400ef1012daa/codec%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fprotobuf%2FProtobufEncoder.java",
      "raw_url": "https://github.com/netty/netty/raw/2e3b8f13ea902b6c1e56ad36473c400ef1012daa/codec%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fprotobuf%2FProtobufEncoder.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fprotobuf%2FProtobufEncoder.java?ref=2e3b8f13ea902b6c1e56ad36473c400ef1012daa",
      "patch": "@@ -24,7 +24,9 @@\n import io.netty.channel.ChannelPipeline;\n import io.netty.handler.codec.LengthFieldBasedFrameDecoder;\n import io.netty.handler.codec.LengthFieldPrepender;\n-import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.MessageToMessageEncoder;\n+\n+import static io.netty.buffer.Unpooled.*;\n \n /**\n  * Encodes the requested <a href=\"http://code.google.com/p/protobuf/\">Google\n@@ -54,16 +56,16 @@\n  * </pre>\n  */\n @Sharable\n-public class ProtobufEncoder extends MessageToByteEncoder<MessageLiteOrBuilder> {\n+public class ProtobufEncoder extends MessageToMessageEncoder<MessageLiteOrBuilder> {\n \n     @Override\n-    protected void encode(ChannelHandlerContext ctx, MessageLiteOrBuilder msg, ByteBuf out) throws Exception {\n+    protected Object encode(ChannelHandlerContext ctx, MessageLiteOrBuilder msg) throws Exception {\n         if (msg instanceof MessageLite) {\n-            out.writeBytes(((MessageLite) msg).toByteArray());\n-            return;\n+            return wrappedBuffer(((MessageLite) msg).toByteArray());\n         }\n         if (msg instanceof MessageLite.Builder) {\n-            out.writeBytes(((MessageLite.Builder) msg).build().toByteArray());\n+            return wrappedBuffer(((MessageLite.Builder) msg).build().toByteArray());\n         }\n+        return null;\n     }\n }",
      "parent_sha": "d9ac6638f4853180a2e46cd504b6483b7381ea87"
    }
  },
  {
    "oid": "0b0de76adc4e564607964535c2078940969967d8",
    "message": "Fix typo in error message\n\nMotivation:\n\nFix typo in error message.\n\nModification:\n\ncould not fine -> could not find",
    "date": "2017-08-28T07:05:08Z",
    "url": "https://github.com/netty/netty/commit/0b0de76adc4e564607964535c2078940969967d8",
    "details": {
      "sha": "016d215c2f836bc3a46ed213c726f11752f4f511",
      "filename": "handler/src/main/java/io/netty/handler/ssl/PemReader.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/0b0de76adc4e564607964535c2078940969967d8/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2FPemReader.java",
      "raw_url": "https://github.com/netty/netty/raw/0b0de76adc4e564607964535c2078940969967d8/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2FPemReader.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2FPemReader.java?ref=0b0de76adc4e564607964535c2078940969967d8",
      "patch": "@@ -111,7 +111,7 @@ static ByteBuf readPrivateKey(File file) throws KeyException {\n                 safeClose(in);\n             }\n         } catch (FileNotFoundException e) {\n-            throw new KeyException(\"could not fine key file: \" + file);\n+            throw new KeyException(\"could not find key file: \" + file);\n         }\n     }\n ",
      "parent_sha": "89ecb4b4a4ead78f6362e05b2128771d629c593c"
    }
  },
  {
    "oid": "065218fd10b3b69882f5ac02c6d7216459b00d62",
    "message": "Forgot to mark one more volatile member transient",
    "date": "2009-02-13T11:53:05Z",
    "url": "https://github.com/netty/netty/commit/065218fd10b3b69882f5ac02c6d7216459b00d62",
    "details": {
      "sha": "10d335411f09d9e19431c9310db451837be35ffd",
      "filename": "src/main/java/org/jboss/netty/util/ConcurrentIdentityWeakKeyHashMap.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/065218fd10b3b69882f5ac02c6d7216459b00d62/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Futil%2FConcurrentIdentityWeakKeyHashMap.java",
      "raw_url": "https://github.com/netty/netty/raw/065218fd10b3b69882f5ac02c6d7216459b00d62/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Futil%2FConcurrentIdentityWeakKeyHashMap.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Futil%2FConcurrentIdentityWeakKeyHashMap.java?ref=065218fd10b3b69882f5ac02c6d7216459b00d62",
      "patch": "@@ -318,7 +318,7 @@ static final class Segment<K, V> extends ReentrantLock {\n          * The collected weak-key reference queue for this segment. This should\n          * be (re)initialized whenever table is assigned,\n          */\n-        volatile ReferenceQueue<Object> refQueue;\n+        transient volatile ReferenceQueue<Object> refQueue;\n \n         Segment(int initialCapacity, float lf) {\n             loadFactor = lf;",
      "parent_sha": "06d5f5264ee315e573148cf92daf158fcf13aba7"
    }
  },
  {
    "oid": "bb898265b9fc3b0883dd9d4eec90d5c1769a3d90",
    "message": "Fixed incorrent time unit conversion",
    "date": "2009-02-09T11:29:17Z",
    "url": "https://github.com/netty/netty/commit/bb898265b9fc3b0883dd9d4eec90d5c1769a3d90",
    "details": {
      "sha": "0148c3a6c1969586fa37a51254ad1ee3e51ec6c1",
      "filename": "src/main/java/org/jboss/netty/handler/timeout/HashedWheelTimer.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/netty/netty/blob/bb898265b9fc3b0883dd9d4eec90d5c1769a3d90/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Ftimeout%2FHashedWheelTimer.java",
      "raw_url": "https://github.com/netty/netty/raw/bb898265b9fc3b0883dd9d4eec90d5c1769a3d90/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Ftimeout%2FHashedWheelTimer.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Ftimeout%2FHashedWheelTimer.java?ref=bb898265b9fc3b0883dd9d4eec90d5c1769a3d90",
      "patch": "@@ -318,7 +318,7 @@ private void waitForNextTick() {\n                 }\n \n                 try {\n-                    Thread.sleep(sleepTime / 1000000, (int) (sleepTime % 1000000));\n+                    Thread.sleep(sleepTime);\n                 } catch (InterruptedException e) {\n                     if (shutdown.get()) {\n                         return;\n@@ -401,10 +401,10 @@ public String toString() {\n \n             buf.append(\"deadline: \");\n             if (remaining > 0) {\n-                buf.append(remaining / 1000000);\n+                buf.append(remaining);\n                 buf.append(\" ms later, \");\n             } else if (remaining < 0) {\n-                buf.append(-remaining / 1000000);\n+                buf.append(-remaining);\n                 buf.append(\" ms ago, \");\n             } else {\n                 buf.append(\"now, \");",
      "parent_sha": "6d917ca7ebd0329f0ac8e2f38d18884d4c128079"
    }
  },
  {
    "oid": "45d20d5c9faf51a506d4d2a9fdb04b9cfd876876",
    "message": "[#1516] Fix resource leakage which was caused by the AbstractDiskHttpData which did not release the buffer after copy to disk",
    "date": "2013-07-04T08:41:49Z",
    "url": "https://github.com/netty/netty/commit/45d20d5c9faf51a506d4d2a9fdb04b9cfd876876",
    "details": {
      "sha": "216c67b7d6df2b5e53b0655b713bf655f13aef3a",
      "filename": "codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java",
      "status": "modified",
      "additions": 53,
      "deletions": 41,
      "changes": 94,
      "blob_url": "https://github.com/netty/netty/blob/45d20d5c9faf51a506d4d2a9fdb04b9cfd876876/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2Fmultipart%2FAbstractDiskHttpData.java",
      "raw_url": "https://github.com/netty/netty/raw/45d20d5c9faf51a506d4d2a9fdb04b9cfd876876/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2Fmultipart%2FAbstractDiskHttpData.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2Fmultipart%2FAbstractDiskHttpData.java?ref=45d20d5c9faf51a506d4d2a9fdb04b9cfd876876",
      "patch": "@@ -99,55 +99,67 @@ public void setContent(ByteBuf buffer) throws IOException {\n         if (buffer == null) {\n             throw new NullPointerException(\"buffer\");\n         }\n-        size = buffer.readableBytes();\n-        if (definedSize > 0 && definedSize < size) {\n-            throw new IOException(\"Out of size: \" + size + \" > \" + definedSize);\n-        }\n-        if (file == null) {\n-            file = tempFile();\n-        }\n-        if (buffer.readableBytes() == 0) {\n-            // empty file\n-            file.createNewFile();\n-            return;\n-        }\n-        FileOutputStream outputStream = new FileOutputStream(file);\n-        FileChannel localfileChannel = outputStream.getChannel();\n-        ByteBuffer byteBuffer = buffer.nioBuffer();\n-        int written = 0;\n-        while (written < size) {\n-            written += localfileChannel.write(byteBuffer);\n+        try {\n+            size = buffer.readableBytes();\n+            if (definedSize > 0 && definedSize < size) {\n+                throw new IOException(\"Out of size: \" + size + \" > \" + definedSize);\n+            }\n+            if (file == null) {\n+                file = tempFile();\n+            }\n+            if (buffer.readableBytes() == 0) {\n+                // empty file\n+                file.createNewFile();\n+                return;\n+            }\n+            FileOutputStream outputStream = new FileOutputStream(file);\n+            FileChannel localfileChannel = outputStream.getChannel();\n+            ByteBuffer byteBuffer = buffer.nioBuffer();\n+            int written = 0;\n+            while (written < size) {\n+                written += localfileChannel.write(byteBuffer);\n+            }\n+            buffer.readerIndex(buffer.readerIndex() + written);\n+            localfileChannel.force(false);\n+            localfileChannel.close();\n+            outputStream.close();\n+            completed = true;\n+        } finally {\n+            // Release the buffer as it was retained before and we not need a reference to it at all\n+            // See https://github.com/netty/netty/issues/1516\n+            buffer.release();\n         }\n-        buffer.readerIndex(buffer.readerIndex() + written);\n-        localfileChannel.force(false);\n-        localfileChannel.close();\n-        outputStream.close();\n-        completed = true;\n     }\n \n     @Override\n     public void addContent(ByteBuf buffer, boolean last)\n             throws IOException {\n         if (buffer != null) {\n-            int localsize = buffer.readableBytes();\n-            if (definedSize > 0 && definedSize < size + localsize) {\n-                throw new IOException(\"Out of size: \" + (size + localsize) +\n-                        \" > \" + definedSize);\n-            }\n-            ByteBuffer byteBuffer = buffer.nioBufferCount() == 1 ? buffer.nioBuffer() : buffer.copy().nioBuffer();\n-            int written = 0;\n-            if (file == null) {\n-                file = tempFile();\n-            }\n-            if (fileChannel == null) {\n-                FileOutputStream outputStream = new FileOutputStream(file);\n-                fileChannel = outputStream.getChannel();\n-            }\n-            while (written < localsize) {\n-                written += fileChannel.write(byteBuffer);\n+            try {\n+                int localsize = buffer.readableBytes();\n+                if (definedSize > 0 && definedSize < size + localsize) {\n+                    throw new IOException(\"Out of size: \" + (size + localsize) +\n+                            \" > \" + definedSize);\n+                }\n+                ByteBuffer byteBuffer = buffer.nioBufferCount() == 1 ? buffer.nioBuffer() : buffer.copy().nioBuffer();\n+                int written = 0;\n+                if (file == null) {\n+                    file = tempFile();\n+                }\n+                if (fileChannel == null) {\n+                    FileOutputStream outputStream = new FileOutputStream(file);\n+                    fileChannel = outputStream.getChannel();\n+                }\n+                while (written < localsize) {\n+                    written += fileChannel.write(byteBuffer);\n+                }\n+                size += localsize;\n+                buffer.readerIndex(buffer.readerIndex() + written);\n+            } finally {\n+                // Release the buffer as it was retained before and we not need a reference to it at all\n+                // See https://github.com/netty/netty/issues/1516\n+                buffer.release();\n             }\n-            size += localsize;\n-            buffer.readerIndex(buffer.readerIndex() + written);\n         }\n         if (last) {\n             if (file == null) {",
      "parent_sha": "08b75e594cbe4f16ec73c3840a3981af7871066f"
    }
  },
  {
    "oid": "1b810c4be6f77ff0a271bc51f483e11cd6841a76",
    "message": "Rename to the correct method name",
    "date": "2012-08-29T03:04:56Z",
    "url": "https://github.com/netty/netty/commit/1b810c4be6f77ff0a271bc51f483e11cd6841a76",
    "details": {
      "sha": "218b096f7555d07f2ac1dd554dde09cc0f01c254",
      "filename": "transport/src/main/java/io/netty/channel/socket/aio/UnsafeAioChannelFinder.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/netty/netty/blob/1b810c4be6f77ff0a271bc51f483e11cd6841a76/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Fsocket%2Faio%2FUnsafeAioChannelFinder.java",
      "raw_url": "https://github.com/netty/netty/raw/1b810c4be6f77ff0a271bc51f483e11cd6841a76/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Fsocket%2Faio%2FUnsafeAioChannelFinder.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Fsocket%2Faio%2FUnsafeAioChannelFinder.java?ref=1b810c4be6f77ff0a271bc51f483e11cd6841a76",
      "patch": "@@ -31,7 +31,7 @@ final class UnsafeAioChannelFinder implements AioChannelFinder {\n     public AbstractAioChannel findChannel(Runnable command) throws Exception {\n         Long offset;\n         for (;;) {\n-            offset = findField(command);\n+            offset = findFieldOffset(command);\n             if (offset == null) {\n                 return null;\n             }\n@@ -43,7 +43,7 @@ public AbstractAioChannel findChannel(Runnable command) throws Exception {\n         }\n     }\n \n-    private static Long findField(Object command) throws Exception {\n+    private static Long findFieldOffset(Object command) throws Exception {\n         Map<Class<?>, Long> offsetCache = UnsafeAioChannelFinder.offsetCache;\n         Class<?> commandType = command.getClass();\n         Long res = offsetCache.get(commandType);",
      "parent_sha": "9a177d99bffbded5082a6600e4a65d018d9f2966"
    }
  },
  {
    "oid": "d0c2f6e8b3c91dcc018d2029d2cab8e21460fb09",
    "message": "Clarify exception message when ALPN is not supported (#10155)\n\nMotivation:\r\n\r\nWe should provide more informations when ALPN is not supported and a user tries to use it.\r\n\r\nModifications:\r\n\r\n- Use UnsupportedOperationException\r\n\r\nResult:\r\n\r\nEasier to debug ALPN problems",
    "date": "2020-04-22T06:07:27Z",
    "url": "https://github.com/netty/netty/commit/d0c2f6e8b3c91dcc018d2029d2cab8e21460fb09",
    "details": {
      "sha": "c4ca7b9b8c014eac8afa10662baf37c6ff0135f1",
      "filename": "handler/src/main/java/io/netty/handler/ssl/JdkAlpnApplicationProtocolNegotiator.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/netty/netty/blob/d0c2f6e8b3c91dcc018d2029d2cab8e21460fb09/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2FJdkAlpnApplicationProtocolNegotiator.java",
      "raw_url": "https://github.com/netty/netty/raw/d0c2f6e8b3c91dcc018d2029d2cab8e21460fb09/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2FJdkAlpnApplicationProtocolNegotiator.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2FJdkAlpnApplicationProtocolNegotiator.java?ref=d0c2f6e8b3c91dcc018d2029d2cab8e21460fb09",
      "patch": "@@ -144,7 +144,8 @@ public SSLEngine wrapSslEngine(SSLEngine engine, ByteBufAllocator alloc,\n                 return isServer ? JettyAlpnSslEngine.newServerEngine(engine, applicationNegotiator)\n                         : JettyAlpnSslEngine.newClientEngine(engine, applicationNegotiator);\n             }\n-            throw new RuntimeException(\"Unable to wrap SSLEngine of type \" + engine.getClass().getName());\n+            throw new UnsupportedOperationException(\"ALPN not supported. Unable to wrap SSLEngine of type '\"\n+                    + engine.getClass().getName() + \"')\");\n         }\n     }\n ",
      "parent_sha": "5cd00d22d98db89313ccc592307cb5e5759db4c8"
    }
  },
  {
    "oid": "3298f5efee8e9bec0cc8df19fb2de22c4f864376",
    "message": "Use ObjectUtil#checkPositive and Add missing JavaDoc In InboundHttp2ToHttpAdapter (#10637)\n\nMotivation:\r\nWe can use ObjectUtil#checkPositive instead of manually checking maxContentLength. Also, there was a missing JavaDoc for Http2Exception,\r\n\r\nModification:\r\nUsed ObjectUtil#checkPositive for checking maxContentLength.\r\nAdded missing JavaDoc.\r\n\r\nResult:\r\nMore readable code.",
    "date": "2020-10-07T09:12:00Z",
    "url": "https://github.com/netty/netty/commit/3298f5efee8e9bec0cc8df19fb2de22c4f864376",
    "details": {
      "sha": "c17c3afc89bea69710c425930e29c106f94d8bdf",
      "filename": "codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapter.java",
      "status": "modified",
      "additions": 15,
      "deletions": 16,
      "changes": 31,
      "blob_url": "https://github.com/netty/netty/blob/3298f5efee8e9bec0cc8df19fb2de22c4f864376/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FInboundHttp2ToHttpAdapter.java",
      "raw_url": "https://github.com/netty/netty/raw/3298f5efee8e9bec0cc8df19fb2de22c4f864376/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FInboundHttp2ToHttpAdapter.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FInboundHttp2ToHttpAdapter.java?ref=3298f5efee8e9bec0cc8df19fb2de22c4f864376",
      "patch": "@@ -30,6 +30,7 @@\n import static io.netty.handler.codec.http2.Http2Exception.connectionError;\n import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n import static io.netty.util.internal.ObjectUtil.checkNotNull;\n+import static io.netty.util.internal.ObjectUtil.checkPositive;\n \n /**\n  * This adapter provides just header/data events from the HTTP message flow defined\n@@ -71,12 +72,8 @@ public FullHttpMessage copyIfNeeded(ByteBufAllocator allocator, FullHttpMessage\n \n     protected InboundHttp2ToHttpAdapter(Http2Connection connection, int maxContentLength,\n                                         boolean validateHttpHeaders, boolean propagateSettings) {\n-\n-        if (maxContentLength <= 0) {\n-            throw new IllegalArgumentException(\"maxContentLength: \" + maxContentLength + \" (expected: > 0)\");\n-        }\n         this.connection = checkNotNull(connection, \"connection\");\n-        this.maxContentLength = maxContentLength;\n+        this.maxContentLength = checkPositive(maxContentLength, \"maxContentLength\");\n         this.validateHttpHeaders = validateHttpHeaders;\n         this.propagateSettings = propagateSettings;\n         sendDetector = DEFAULT_SEND_DETECTOR;\n@@ -147,14 +144,14 @@ protected void fireChannelRead(ChannelHandlerContext ctx, FullHttpMessage msg, b\n      * <li>{@code false} not to validate HTTP headers in the http-codec</li>\n      * </ul>\n      * @param alloc The {@link ByteBufAllocator} to use to generate the content of the message\n-     * @throws Http2Exception\n+     * @throws Http2Exception If there is an error when creating {@link FullHttpMessage} from\n+     *                        {@link Http2Stream} and {@link Http2Headers}\n      */\n     protected FullHttpMessage newMessage(Http2Stream stream, Http2Headers headers, boolean validateHttpHeaders,\n-                                         ByteBufAllocator alloc)\n-            throws Http2Exception {\n+                                         ByteBufAllocator alloc) throws Http2Exception {\n         return connection.isServer() ? HttpConversionUtil.toFullHttpRequest(stream.id(), headers, alloc,\n                 validateHttpHeaders) : HttpConversionUtil.toFullHttpResponse(stream.id(), headers, alloc,\n-                                                                         validateHttpHeaders);\n+                validateHttpHeaders);\n     }\n \n     /**\n@@ -182,7 +179,8 @@ protected FullHttpMessage newMessage(Http2Stream stream, Http2Headers headers, b\n      * @throws Http2Exception If the stream id is not in the correct state to process the headers request\n      */\n     protected FullHttpMessage processHeadersBegin(ChannelHandlerContext ctx, Http2Stream stream, Http2Headers headers,\n-                boolean endOfStream, boolean allowAppend, boolean appendToTrailer) throws Http2Exception {\n+                                                  boolean endOfStream, boolean allowAppend, boolean appendToTrailer)\n+            throws Http2Exception {\n         FullHttpMessage msg = getMessage(stream);\n         boolean release = true;\n         if (msg == null) {\n@@ -227,7 +225,7 @@ private void processHeadersEnd(ChannelHandlerContext ctx, Http2Stream stream, Fu\n \n     @Override\n     public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding, boolean endOfStream)\n-                    throws Http2Exception {\n+            throws Http2Exception {\n         Http2Stream stream = connection.stream(streamId);\n         FullHttpMessage msg = getMessage(stream);\n         if (msg == null) {\n@@ -238,7 +236,7 @@ public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int\n         final int dataReadableBytes = data.readableBytes();\n         if (content.readableBytes() > maxContentLength - dataReadableBytes) {\n             throw connectionError(INTERNAL_ERROR,\n-                            \"Content length exceeded max of %d for stream id %d\", maxContentLength, streamId);\n+                    \"Content length exceeded max of %d for stream id %d\", maxContentLength, streamId);\n         }\n \n         content.writeBytes(data, data.readerIndex(), dataReadableBytes);\n@@ -253,7 +251,7 @@ public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int\n \n     @Override\n     public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int padding,\n-                    boolean endOfStream) throws Http2Exception {\n+                              boolean endOfStream) throws Http2Exception {\n         Http2Stream stream = connection.stream(streamId);\n         FullHttpMessage msg = processHeadersBegin(ctx, stream, headers, endOfStream, true, true);\n         if (msg != null) {\n@@ -263,7 +261,8 @@ public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers\n \n     @Override\n     public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int streamDependency,\n-                    short weight, boolean exclusive, int padding, boolean endOfStream) throws Http2Exception {\n+                              short weight, boolean exclusive, int padding, boolean endOfStream)\n+            throws Http2Exception {\n         Http2Stream stream = connection.stream(streamId);\n         FullHttpMessage msg = processHeadersBegin(ctx, stream, headers, endOfStream, true, true);\n         if (msg != null) {\n@@ -292,7 +291,7 @@ public void onRstStreamRead(ChannelHandlerContext ctx, int streamId, long errorC\n \n     @Override\n     public void onPushPromiseRead(ChannelHandlerContext ctx, int streamId, int promisedStreamId,\n-            Http2Headers headers, int padding) throws Http2Exception {\n+                                  Http2Headers headers, int padding) throws Http2Exception {\n         // A push promise should not be allowed to add headers to an existing stream\n         Http2Stream promisedStream = connection.stream(promisedStreamId);\n         if (headers.status() == null) {\n@@ -306,7 +305,7 @@ public void onPushPromiseRead(ChannelHandlerContext ctx, int streamId, int promi\n         FullHttpMessage msg = processHeadersBegin(ctx, promisedStream, headers, false, false, false);\n         if (msg == null) {\n             throw connectionError(PROTOCOL_ERROR, \"Push Promise Frame received for pre-existing stream id %d\",\n-                            promisedStreamId);\n+                    promisedStreamId);\n         }\n \n         msg.headers().setInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_PROMISE_ID.text(), streamId);",
      "parent_sha": "69b44c6d06d4449920b6b8990b0f6e0473f3532b"
    }
  },
  {
    "oid": "5a7f049fe2bca201d76edef987a3ec36580c410b",
    "message": "[#1202] Fix javadoc",
    "date": "2013-03-28T09:01:26Z",
    "url": "https://github.com/netty/netty/commit/5a7f049fe2bca201d76edef987a3ec36580c410b",
    "details": {
      "sha": "1ab78a4435baa29a7971dcf228d7011284cc49bc",
      "filename": "buffer/src/main/java/io/netty/buffer/ByteBuf.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/5a7f049fe2bca201d76edef987a3ec36580c410b/buffer%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fbuffer%2FByteBuf.java",
      "raw_url": "https://github.com/netty/netty/raw/5a7f049fe2bca201d76edef987a3ec36580c410b/buffer%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fbuffer%2FByteBuf.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/buffer%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fbuffer%2FByteBuf.java?ref=5a7f049fe2bca201d76edef987a3ec36580c410b",
      "patch": "@@ -214,7 +214,7 @@\n  *\n  * If a {@link ByteBuf} can be converted into an NIO {@link ByteBuffer} which shares its\n  * content (i.e. view buffer), you can get it via the {@link #nioBuffer()} method.  To determine\n- * if a buffer can be converted into an NIO buffer, use {@link #nioBuffer()}.\n+ * if a buffer can be converted into an NIO buffer, use {@link #nioBufferCount()}.\n  *\n  * <h4>Strings</h4>\n  *",
      "parent_sha": "14a47075bea2c38540bd5b0429335b97614f0eb0"
    }
  },
  {
    "oid": "584fbac6ed7a0b58068bd0acf8ac784a572274ad",
    "message": "[#3419] Only use SecureRandom to generate initialSeed if requested\n\nMotivation:\n\nWe tried to always use SecureRandom to generate the initialSeed for our ThreadLocalRandom, this can sometimes give warnings under normal usage. We should better not use SecureRandom as default (just as the implementation in jsr166y does) and only try if the user specified -Djava.util.secureRandomSeed=true .\n\nModifications:\n\nOnly try to use SecureRandom when -Djava.util.secureRandomSeed=true is used.\n\nResult:\n\nLess likely to see entropy warnings.",
    "date": "2016-06-06T07:09:29Z",
    "url": "https://github.com/netty/netty/commit/584fbac6ed7a0b58068bd0acf8ac784a572274ad",
    "details": {
      "sha": "fb1594bcaec07e04de19f4fb734a92b3b0a812a0",
      "filename": "common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java",
      "status": "modified",
      "additions": 53,
      "deletions": 29,
      "changes": 82,
      "blob_url": "https://github.com/netty/netty/blob/584fbac6ed7a0b58068bd0acf8ac784a572274ad/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2Finternal%2FThreadLocalRandom.java",
      "raw_url": "https://github.com/netty/netty/raw/584fbac6ed7a0b58068bd0acf8ac784a572274ad/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2Finternal%2FThreadLocalRandom.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2Finternal%2FThreadLocalRandom.java?ref=584fbac6ed7a0b58068bd0acf8ac784a572274ad",
      "patch": "@@ -26,6 +26,8 @@\n import io.netty.util.internal.logging.InternalLoggerFactory;\n \n import java.lang.Thread.UncaughtExceptionHandler;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n import java.security.SecureRandom;\n import java.util.Random;\n import java.util.concurrent.BlockingQueue;\n@@ -68,34 +70,56 @@ public final class ThreadLocalRandom extends Random {\n             SystemPropertyUtil.getLong(\"io.netty.initialSeedUniquifier\", 0);\n \n     private static final Thread seedGeneratorThread;\n-    private static final BlockingQueue<byte[]> seedQueue;\n+    private static final BlockingQueue<Long> seedQueue;\n     private static final long seedGeneratorStartTime;\n     private static volatile long seedGeneratorEndTime;\n \n     static {\n         if (initialSeedUniquifier == 0) {\n-            // Try to generate a real random number from /dev/random.\n-            // Get from a different thread to avoid blocking indefinitely on a machine without much entropy.\n-            seedGeneratorThread = new Thread(\"initialSeedUniquifierGenerator\") {\n+            boolean secureRandom = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n                 @Override\n-                public void run() {\n-                    final SecureRandom random = new SecureRandom(); // Get the real random seed from /dev/random\n-                    final byte[] seed = random.generateSeed(8);\n-                    seedGeneratorEndTime = System.nanoTime();\n-                    seedQueue.add(seed);\n-                }\n-            };\n-            seedGeneratorThread.setDaemon(true);\n-            seedGeneratorThread.setUncaughtExceptionHandler(new UncaughtExceptionHandler() {\n-                @Override\n-                public void uncaughtException(Thread t, Throwable e) {\n-                    logger.debug(\"An exception has been raised by {}\", t.getName(), e);\n+                public Boolean run() {\n+                    return SystemPropertyUtil.getBoolean(\"java.util.secureRandomSeed\", false);\n                 }\n             });\n \n-            seedQueue = new LinkedBlockingQueue<byte[]>();\n-            seedGeneratorStartTime = System.nanoTime();\n-            seedGeneratorThread.start();\n+            if (secureRandom) {\n+                seedQueue = new LinkedBlockingQueue<Long>();\n+                seedGeneratorStartTime = System.nanoTime();\n+\n+                // Try to generate a real random number from /dev/random.\n+                // Get from a different thread to avoid blocking indefinitely on a machine without much entropy.\n+                seedGeneratorThread = new Thread(\"initialSeedUniquifierGenerator\") {\n+                    @Override\n+                    public void run() {\n+                        final SecureRandom random = new SecureRandom(); // Get the real random seed from /dev/random\n+                        final byte[] seed = random.generateSeed(8);\n+                        seedGeneratorEndTime = System.nanoTime();\n+                        long s = ((long) seed[0] & 0xff) << 56 |\n+                                 ((long) seed[1] & 0xff) << 48 |\n+                                 ((long) seed[2] & 0xff) << 40 |\n+                                 ((long) seed[3] & 0xff) << 32 |\n+                                 ((long) seed[4] & 0xff) << 24 |\n+                                 ((long) seed[5] & 0xff) << 16 |\n+                                 ((long) seed[6] & 0xff) <<  8 |\n+                                 (long) seed[7] & 0xff;\n+                        seedQueue.add(s);\n+                    }\n+                };\n+                seedGeneratorThread.setDaemon(true);\n+                seedGeneratorThread.setUncaughtExceptionHandler(new UncaughtExceptionHandler() {\n+                    @Override\n+                    public void uncaughtException(Thread t, Throwable e) {\n+                        logger.debug(\"An exception has been raised by {}\", t.getName(), e);\n+                    }\n+                });\n+                seedGeneratorThread.start();\n+            } else {\n+                initialSeedUniquifier = mix64(System.currentTimeMillis()) ^ mix64(System.nanoTime());\n+                seedGeneratorThread = null;\n+                seedQueue = null;\n+                seedGeneratorStartTime = 0L;\n+            }\n         } else {\n             seedGeneratorThread = null;\n             seedQueue = null;\n@@ -127,23 +151,15 @@ public static long getInitialSeedUniquifier() {\n             for (;;) {\n                 final long waitTime = deadLine - System.nanoTime();\n                 try {\n-                    final byte[] seed;\n+                    final Long seed;\n                     if (waitTime <= 0) {\n                         seed = seedQueue.poll();\n                     } else {\n                         seed = seedQueue.poll(waitTime, TimeUnit.NANOSECONDS);\n                     }\n \n                     if (seed != null) {\n-                        initialSeedUniquifier =\n-                                ((long) seed[0] & 0xff) << 56 |\n-                                ((long) seed[1] & 0xff) << 48 |\n-                                ((long) seed[2] & 0xff) << 40 |\n-                                ((long) seed[3] & 0xff) << 32 |\n-                                ((long) seed[4] & 0xff) << 24 |\n-                                ((long) seed[5] & 0xff) << 16 |\n-                                ((long) seed[6] & 0xff) <<  8 |\n-                                (long) seed[7] & 0xff;\n+                        initialSeedUniquifier = seed;\n                         break;\n                     }\n                 } catch (InterruptedException e) {\n@@ -209,6 +225,14 @@ private static long newSeed() {\n         }\n     }\n \n+    // Borrowed from\n+    // http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ThreadLocalRandom.java\n+    private static long mix64(long z) {\n+        z = (z ^ (z >>> 33)) * 0xff51afd7ed558ccdL;\n+        z = (z ^ (z >>> 33)) * 0xc4ceb9fe1a85ec53L;\n+        return z ^ (z >>> 33);\n+    }\n+\n     // same constants as Random, but must be redeclared because private\n     private static final long multiplier = 0x5DEECE66DL;\n     private static final long addend = 0xBL;",
      "parent_sha": "3a7dcde32099fad6e600d2eebfda9250006d587e"
    }
  },
  {
    "oid": "9b9819c17804fa83155cc6cdf11eb2e64feb2d1a",
    "message": "Rewrite misleading Note in FingerprintTrustManagerFactory javadoc\n\nMotivation:\n\nThe current note reads as if this class is dangerous and advises the reader to \"understand what this class does\".\n\nModifications:\n\nRewrite the Javadoc note to describe what fingerprint checks are and what problems remain.\n\nResult:\n\nClearer description which no longer causes the impression this class is dangerous.",
    "date": "2016-05-03T05:39:39Z",
    "url": "https://github.com/netty/netty/commit/9b9819c17804fa83155cc6cdf11eb2e64feb2d1a",
    "details": {
      "sha": "79e434655a9883260f8e3ac9478fbc1e9364fe98",
      "filename": "handler/src/main/java/io/netty/handler/ssl/util/FingerprintTrustManagerFactory.java",
      "status": "modified",
      "additions": 11,
      "deletions": 3,
      "changes": 14,
      "blob_url": "https://github.com/netty/netty/blob/9b9819c17804fa83155cc6cdf11eb2e64feb2d1a/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2Futil%2FFingerprintTrustManagerFactory.java",
      "raw_url": "https://github.com/netty/netty/raw/9b9819c17804fa83155cc6cdf11eb2e64feb2d1a/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2Futil%2FFingerprintTrustManagerFactory.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/handler%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2Futil%2FFingerprintTrustManagerFactory.java?ref=9b9819c17804fa83155cc6cdf11eb2e64feb2d1a",
      "patch": "@@ -39,11 +39,19 @@\n /**\n  * An {@link TrustManagerFactory} that trusts an X.509 certificate whose SHA1 checksum matches.\n  * <p>\n- * <strong>NOTE:</strong>\n- * Never use this {@link TrustManagerFactory} in production unless you are sure exactly what you are doing with it.\n- * </p><p>\n+ * <strong>NOTE:</strong> It is recommended to verify certificates and their chain to prevent\n+ * <a href=\"https://en.wikipedia.org/wiki/Man-in-the-middle_attack\">Man-in-the-middle attacks</a>.\n+ * This {@link TrustManagerFactory} will <strong>only</strong> verify that the fingerprint of certificates match one\n+ * of the given fingerprints. This procedure is called\n+ * <a href=\"https://en.wikipedia.org/wiki/Transport_Layer_Security#Certificate_pinning\">certificate pinning</a> and\n+ * is an effective protection. For maximum security one should verify that the whole certificate chain is as expected.\n+ * It is worth mentioning that certain firewalls, proxies or other appliances found in corporate environments,\n+ * actually perform Man-in-the-middle attacks and thus present a different certificate fingerprint.\n+ * </p>\n+ * <p>\n  * The SHA1 checksum of an X.509 certificate is calculated from its DER encoded format.  You can get the fingerprint of\n  * an X.509 certificate using the {@code openssl} command.  For example:\n+ *\n  * <pre>\n  * $ openssl x509 -fingerprint -sha1 -in my_certificate.crt\n  * SHA1 Fingerprint=4E:85:10:55:BC:7B:12:08:D1:EA:0A:12:C9:72:EE:F3:AA:B2:C7:CB",
      "parent_sha": "9ed2f01853d82940b42c795eb541046872c3086b"
    }
  },
  {
    "oid": "58a038d398f85235683ccb01cfd7fb97c35ddece",
    "message": "Fix ChannelOutboundHandlerAdapter javadoc\n\nMotivation:\n\nChannelOutboundHandlerAdapter's javadoc has some minor issues.\n\nModifications:\n\nFix the minor javadoc issues and resolves #4752.\n\nResult:\n\nChannelOutboundHandlerAdapter's javadoc issues are fixed.",
    "date": "2016-01-26T09:13:16Z",
    "url": "https://github.com/netty/netty/commit/58a038d398f85235683ccb01cfd7fb97c35ddece",
    "details": {
      "sha": "fa968925de94ba7aa584037d1d8b3722bf9f957d",
      "filename": "transport/src/main/java/io/netty/channel/ChannelOutboundHandlerAdapter.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/netty/netty/blob/58a038d398f85235683ccb01cfd7fb97c35ddece/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FChannelOutboundHandlerAdapter.java",
      "raw_url": "https://github.com/netty/netty/raw/58a038d398f85235683ccb01cfd7fb97c35ddece/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FChannelOutboundHandlerAdapter.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FChannelOutboundHandlerAdapter.java?ref=58a038d398f85235683ccb01cfd7fb97c35ddece",
      "patch": "@@ -18,7 +18,7 @@\n import java.net.SocketAddress;\n \n /**\n- * Skelton implementation of a {@link ChannelOutboundHandler}. This implementation just forwards each method call via\n+ * Skeleton implementation of a {@link ChannelOutboundHandler}. This implementation just forwards each method call via\n  * the {@link ChannelHandlerContext}.\n  */\n public class ChannelOutboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelOutboundHandler {\n@@ -72,7 +72,7 @@ public void close(ChannelHandlerContext ctx, ChannelPromise promise)\n     }\n \n     /**\n-     * Calls {@link ChannelHandlerContext#close(ChannelPromise)} to forward\n+     * Calls {@link ChannelHandlerContext#deregister(ChannelPromise)} to forward\n      * to the next {@link ChannelOutboundHandler} in the {@link ChannelPipeline}.\n      *\n      * Sub-classes may override this method to change behavior.\n@@ -94,7 +94,7 @@ public void read(ChannelHandlerContext ctx) throws Exception {\n     }\n \n     /**\n-     * Calls {@link ChannelHandlerContext#write(Object)} to forward\n+     * Calls {@link ChannelHandlerContext#write(Object, ChannelPromise)} to forward\n      * to the next {@link ChannelOutboundHandler} in the {@link ChannelPipeline}.\n      *\n      * Sub-classes may override this method to change behavior.",
      "parent_sha": "1c417e5f8264271f785c18972a55d9e216d1b20b"
    }
  },
  {
    "oid": "181355665be56f8c52e871ff0561de770abaa9e8",
    "message": "Fixed formatting.",
    "date": "2011-11-28T23:12:42Z",
    "url": "https://github.com/netty/netty/commit/181355665be56f8c52e871ff0561de770abaa9e8",
    "details": {
      "sha": "76d0988b8d4fea307689f0491121781ec1fe2c11",
      "filename": "src/main/java/org/jboss/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java",
      "status": "modified",
      "additions": 321,
      "deletions": 321,
      "changes": 642,
      "blob_url": "https://github.com/netty/netty/blob/181355665be56f8c52e871ff0561de770abaa9e8/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2Fwebsocketx%2FWebSocket08FrameDecoder.java",
      "raw_url": "https://github.com/netty/netty/raw/181355665be56f8c52e871ff0561de770abaa9e8/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2Fwebsocketx%2FWebSocket08FrameDecoder.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2Fwebsocketx%2FWebSocket08FrameDecoder.java?ref=181355665be56f8c52e871ff0561de770abaa9e8",
      "patch": "@@ -59,325 +59,325 @@\n  */\n public class WebSocket08FrameDecoder extends ReplayingDecoder<WebSocket08FrameDecoder.State> {\n \n-\tprivate static final InternalLogger logger = InternalLoggerFactory.getInstance(WebSocket08FrameDecoder.class);\n-\n-\tprivate static final byte OPCODE_CONT = 0x0;\n-\tprivate static final byte OPCODE_TEXT = 0x1;\n-\tprivate static final byte OPCODE_BINARY = 0x2;\n-\tprivate static final byte OPCODE_CLOSE = 0x8;\n-\tprivate static final byte OPCODE_PING = 0x9;\n-\tprivate static final byte OPCODE_PONG = 0xA;\n-\n-\tprivate UTF8Output fragmentedFramesText = null;\n-\tprivate int fragmentedFramesCount = 0;\n-\n-\tprivate boolean frameFinalFlag;\n-\tprivate int frameRsv;\n-\tprivate int frameOpcode;\n-\tprivate long framePayloadLength;\n-\tprivate ChannelBuffer framePayload = null;\n-\tprivate int framePayloadBytesRead = 0;\n-\tprivate ChannelBuffer maskingKey;\n-\n-\tprivate boolean allowExtensions = false;\n-\tprivate boolean maskedPayload = false;\n-\tprivate boolean receivedClosingHandshake = false;\n-\n-\tpublic enum State {\n-\t\tFRAME_START, MASKING_KEY, PAYLOAD, CORRUPT\n-\t}\n-\n-\t/**\n-\t * Constructor\n-\t * \n-\t * @param maskedPayload\n-\t *            Web socket servers must set this to true processed incoming\n-\t *            masked payload. Client implementations must set this to false.\n-\t * @param allowExtensions\n-\t *            Flag to allow reserved extension bits to be used or not\n-\t */\n-\tpublic WebSocket08FrameDecoder(boolean maskedPayload, boolean allowExtensions) {\n-\t\tsuper(State.FRAME_START);\n-\t\tthis.maskedPayload = maskedPayload;\n-\t\tthis.allowExtensions = allowExtensions;\n-\t}\n-\n-\t@Override\n-\tprotected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer, State state)\n-\t\t\tthrows Exception {\n-\n-\t\t// Discard all data received if closing handshake was received before.\n-\t\tif (receivedClosingHandshake) {\n-\t\t\tbuffer.skipBytes(actualReadableBytes());\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tswitch (state) {\n-\t\tcase FRAME_START:\n-\t\t\tframePayloadBytesRead = 0;\n-\t\t\tframePayloadLength = -1;\n-\t\t\tframePayload = null;\n-\n-\t\t\t// FIN, RSV, OPCODE\n-\t\t\tbyte b = buffer.readByte();\n-\t\t\tframeFinalFlag = (b & 0x80) != 0;\n-\t\t\tframeRsv = (b & 0x70) >> 4;\n-\t\t\tframeOpcode = (b & 0x0F);\n-\n-\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\tlogger.debug(\"Decoding WebSocket Frame opCode=\" + frameOpcode);\n-\t\t\t}\n-\n-\t\t\t// MASK, PAYLOAD LEN 1\n-\t\t\tb = buffer.readByte();\n-\t\t\tboolean frameMasked = (b & 0x80) != 0;\n-\t\t\tint framePayloadLen1 = (b & 0x7F);\n-\n-\t\t\tif (frameRsv != 0 && !this.allowExtensions) {\n-\t\t\t\tprotocolViolation(channel, \"RSV != 0 and no extension negotiated, RSV:\" + frameRsv);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\n-\t\t\tif (this.maskedPayload && !frameMasked) {\n-\t\t\t\tprotocolViolation(channel, \"unmasked client to server frame\");\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t\tif (frameOpcode > 7) { // control frame (have MSB in opcode set)\n-\n-\t\t\t\t// control frames MUST NOT be fragmented\n-\t\t\t\tif (!frameFinalFlag) {\n-\t\t\t\t\tprotocolViolation(channel, \"fragmented control frame\");\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\n-\t\t\t\t// control frames MUST have payload 125 octets or less\n-\t\t\t\tif (framePayloadLen1 > 125) {\n-\t\t\t\t\tprotocolViolation(channel, \"control frame with payload length > 125 octets\");\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\n-\t\t\t\t// check for reserved control frame opcodes\n-\t\t\t\tif (!(frameOpcode == OPCODE_CLOSE || frameOpcode == OPCODE_PING || frameOpcode == OPCODE_PONG)) {\n-\t\t\t\t\tprotocolViolation(channel, \"control frame using reserved opcode \" + frameOpcode);\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\n-\t\t\t\t// close frame : if there is a body, the first two bytes of the\n-\t\t\t\t// body MUST be a 2-byte unsigned integer (in network byte\n-\t\t\t\t// order) representing a status code\n-\t\t\t\tif (frameOpcode == 8 && framePayloadLen1 == 1) {\n-\t\t\t\t\tprotocolViolation(channel, \"received close control frame with payload len 1\");\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\t\t\t} else { // data frame\n-\t\t\t\t// check for reserved data frame opcodes\n-\t\t\t\tif (!(frameOpcode == OPCODE_CONT || frameOpcode == OPCODE_TEXT || frameOpcode == OPCODE_BINARY)) {\n-\t\t\t\t\tprotocolViolation(channel, \"data frame using reserved opcode \" + frameOpcode);\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\n-\t\t\t\t// check opcode vs message fragmentation state 1/2\n-\t\t\t\tif (fragmentedFramesCount == 0 && frameOpcode == OPCODE_CONT) {\n-\t\t\t\t\tprotocolViolation(channel, \"received continuation data frame outside fragmented message\");\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\n-\t\t\t\t// check opcode vs message fragmentation state 2/2\n-\t\t\t\tif (fragmentedFramesCount != 0 && frameOpcode != OPCODE_CONT && frameOpcode != OPCODE_PING) {\n-\t\t\t\t\tprotocolViolation(channel, \"received non-continuation data frame while inside fragmented message\");\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// Read frame payload length\n-\t\t\tif (framePayloadLen1 == 126) {\n-\t\t\t\tframePayloadLength = buffer.readUnsignedShort();\n-\t\t\t\tif (framePayloadLength < 126) {\n-\t\t\t\t\tprotocolViolation(channel, \"invalid data frame length (not using minimal length encoding)\");\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\t\t\t} else if (framePayloadLen1 == 127) {\n-\t\t\t\tframePayloadLength = buffer.readLong();\n-\t\t\t\t// TODO: check if it's bigger than 0x7FFFFFFFFFFFFFFF, Maybe\n-\t\t\t\t// just check if it's negative?\n-\n-\t\t\t\tif (framePayloadLength < 65536) {\n-\t\t\t\t\tprotocolViolation(channel, \"invalid data frame length (not using minimal length encoding)\");\n-\t\t\t\t\treturn null;\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tframePayloadLength = framePayloadLen1;\n-\t\t\t}\n-\n-\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\tlogger.debug(\"Decoding WebSocket Frame length=\" + framePayloadLength);\n-\t\t\t}\n-\n-\t\t\tcheckpoint(State.MASKING_KEY);\n-\t\tcase MASKING_KEY:\n-\t\t\tif (this.maskedPayload) {\n-\t\t\t\tmaskingKey = buffer.readBytes(4);\n-\t\t\t}\n-\t\t\tcheckpoint(State.PAYLOAD);\n-\t\tcase PAYLOAD:\n-\t\t\t// Sometimes, the payload may not be delivered in 1 nice packet\n-\t\t\t// We need to accumulate the data until we have it all\n-\t\t\tint rbytes = actualReadableBytes();\n-\t\t\tChannelBuffer payloadBuffer = null;\n-\n-\t\t\tint willHaveReadByteCount = framePayloadBytesRead + rbytes;\n-\t\t\t// logger.debug(\"Frame rbytes=\" + rbytes + \" willHaveReadByteCount=\"\n-\t\t\t// + willHaveReadByteCount + \" framePayloadLength=\" +\n-\t\t\t// framePayloadLength);\n-\t\t\tif (willHaveReadByteCount == framePayloadLength) {\n-\t\t\t\t// We have all our content so proceed to process\n-\t\t\t\tpayloadBuffer = buffer.readBytes(rbytes);\n-\t\t\t} else if (willHaveReadByteCount < framePayloadLength) {\n-\t\t\t\t// We don't have all our content so accumulate payload.\n-\t\t\t\t// Returning null means we will get called back\n-\t\t\t\tpayloadBuffer = buffer.readBytes(rbytes);\n-\t\t\t\tif (framePayload == null) {\n-\t\t\t\t\tframePayload = channel.getConfig().getBufferFactory().getBuffer(toFrameLength(framePayloadLength));\n-\t\t\t\t}\n-\t\t\t\tframePayload.writeBytes(payloadBuffer);\n-\t\t\t\tframePayloadBytesRead = framePayloadBytesRead + rbytes;\n-\n-\t\t\t\t// Return null to wait for more bytes to arrive\n-\t\t\t\treturn null;\n-\t\t\t} else if (willHaveReadByteCount > framePayloadLength) {\n-\t\t\t\t// We have more than what we need so read up to the end of frame\n-\t\t\t\t// Leave the remainder in the buffer for next frame\n-\t\t\t\tpayloadBuffer = buffer.readBytes(toFrameLength(framePayloadLength - framePayloadBytesRead));\n-\t\t\t}\n-\n-\t\t\t// Now we have all the data, the next checkpoint must be the next\n-\t\t\t// frame\n-\t\t\tcheckpoint(State.FRAME_START);\n-\n-\t\t\t// Take the data that we have in this packet\n-\t\t\tif (framePayload == null) {\n-\t\t\t\tframePayload = payloadBuffer;\n-\t\t\t} else {\n-\t\t\t\tframePayload.writeBytes(payloadBuffer);\n-\t\t\t}\n-\n-\t\t\t// Unmask data if needed\n-\t\t\tif (this.maskedPayload) {\n-\t\t\t\tunmask(framePayload);\n-\t\t\t}\n-\n-\t\t\t// Processing ping/pong/close frames because they cannot be\n-\t\t\t// fragmented\n-\t\t\tif (frameOpcode == OPCODE_PING) {\n-\t\t\t\treturn new PingWebSocketFrame(frameFinalFlag, frameRsv, framePayload);\n-\t\t\t} else if (frameOpcode == OPCODE_PONG) {\n-\t\t\t\treturn new PongWebSocketFrame(frameFinalFlag, frameRsv, framePayload);\n-\t\t\t} else if (frameOpcode == OPCODE_CLOSE) {\n-\t\t\t\tthis.receivedClosingHandshake = true;\n-\t\t\t\treturn new CloseWebSocketFrame(frameFinalFlag, frameRsv);\n-\t\t\t}\n-\n-\t\t\t// Processing for possible fragmented messages for text and binary\n-\t\t\t// frames\n-\t\t\tString aggregatedText = null;\n-\t\t\tif (frameFinalFlag) {\n-\t\t\t\t// Final frame of the sequence. Apparently ping frames are\n-\t\t\t\t// allowed in the middle of a fragmented message\n-\t\t\t\tif (frameOpcode != OPCODE_PING) {\n-\t\t\t\t\tfragmentedFramesCount = 0;\n-\n-\t\t\t\t\t// Check text for UTF8 correctness\n-\t\t\t\t\tif (frameOpcode == OPCODE_TEXT || fragmentedFramesText != null) {\n-\t\t\t\t\t\t// Check UTF-8 correctness for this payload\n-\t\t\t\t\t\tcheckUTF8String(channel, framePayload.array());\n-\n-\t\t\t\t\t\t// This does a second check to make sure UTF-8\n-\t\t\t\t\t\t// correctness for entire text message\n-\t\t\t\t\t\taggregatedText = fragmentedFramesText.toString();\n-\n-\t\t\t\t\t\tfragmentedFramesText = null;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t// Not final frame so we can expect more frames in the\n-\t\t\t\t// fragmented sequence\n-\t\t\t\tif (fragmentedFramesCount == 0) {\n-\t\t\t\t\t// First text or binary frame for a fragmented set\n-\t\t\t\t\tfragmentedFramesText = null;\n-\t\t\t\t\tif (frameOpcode == OPCODE_TEXT) {\n-\t\t\t\t\t\tcheckUTF8String(channel, framePayload.array());\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\t// Subsequent frames - only check if init frame is text\n-\t\t\t\t\tif (fragmentedFramesText != null) {\n-\t\t\t\t\t\tcheckUTF8String(channel, framePayload.array());\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t// Increment counter\n-\t\t\t\tfragmentedFramesCount++;\n-\t\t\t}\n-\n-\t\t\t// Return the frame\n-\t\t\tif (frameOpcode == OPCODE_TEXT) {\n-\t\t\t\treturn new TextWebSocketFrame(frameFinalFlag, frameRsv, framePayload);\n-\t\t\t} else if (frameOpcode == OPCODE_BINARY) {\n-\t\t\t\treturn new BinaryWebSocketFrame(frameFinalFlag, frameRsv, framePayload);\n-\t\t\t} else if (frameOpcode == OPCODE_CONT) {\n-\t\t\t\treturn new ContinuationWebSocketFrame(frameFinalFlag, frameRsv, framePayload, aggregatedText);\n-\t\t\t} else {\n-\t\t\t\tthrow new UnsupportedOperationException(\"Cannot decode web socket frame with opcode: \" + frameOpcode);\n-\t\t\t}\n-\t\tcase CORRUPT:\n-\t\t\t// If we don't keep reading Netty will throw an exception saying\n-\t\t\t// we can't return null if no bytes read and state not changed.\n-\t\t\tbuffer.readByte();\n-\t\t\treturn null;\n-\t\tdefault:\n-\t\t\tthrow new Error(\"Shouldn't reach here.\");\n-\t\t}\n-\t}\n-\n-\tprivate void unmask(ChannelBuffer frame) {\n-\t\tbyte[] bytes = frame.array();\n-\t\tfor (int i = 0; i < bytes.length; i++) {\n-\t\t\tframe.setByte(i, frame.getByte(i) ^ maskingKey.getByte(i % 4));\n-\t\t}\n-\t}\n-\n-\tprivate void protocolViolation(Channel channel, String reason) throws CorruptedFrameException {\n-\t\tcheckpoint(State.CORRUPT);\n-\t\tif (channel.isConnected()) {\n-\t\t\tchannel.write(ChannelBuffers.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);\n-\t\t\tchannel.close().awaitUninterruptibly();\n-\t\t}\n-\t\tthrow new CorruptedFrameException(reason);\n-\t}\n-\n-\tprivate int toFrameLength(long l) throws TooLongFrameException {\n-\t\tif (l > Integer.MAX_VALUE) {\n-\t\t\tthrow new TooLongFrameException(\"Length:\" + l);\n-\t\t} else {\n-\t\t\treturn (int) l;\n-\t\t}\n-\t}\n-\n-\tprivate void checkUTF8String(Channel channel, byte[] bytes) throws CorruptedFrameException {\n-\t\ttry {\n-\t\t\t// StringBuilder sb = new StringBuilder(\"UTF8 \" + bytes.length +\n-\t\t\t// \" bytes: \");\n-\t\t\t// for (byte b : bytes) {\n-\t\t\t// sb.append(Integer.toHexString(b)).append(\" \");\n-\t\t\t// }\n-\t\t\t// logger.debug(sb.toString());\n-\n-\t\t\tif (fragmentedFramesText == null) {\n-\t\t\t\tfragmentedFramesText = new UTF8Output(bytes);\n-\t\t\t} else {\n-\t\t\t\tfragmentedFramesText.write(bytes);\n-\t\t\t}\n-\t\t} catch (UTF8Exception ex) {\n-\t\t\tprotocolViolation(channel, \"invalid UTF-8 bytes\");\n-\t\t}\n-\t}\n+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(WebSocket08FrameDecoder.class);\n+\n+    private static final byte OPCODE_CONT = 0x0;\n+    private static final byte OPCODE_TEXT = 0x1;\n+    private static final byte OPCODE_BINARY = 0x2;\n+    private static final byte OPCODE_CLOSE = 0x8;\n+    private static final byte OPCODE_PING = 0x9;\n+    private static final byte OPCODE_PONG = 0xA;\n+\n+    private UTF8Output fragmentedFramesText = null;\n+    private int fragmentedFramesCount = 0;\n+\n+    private boolean frameFinalFlag;\n+    private int frameRsv;\n+    private int frameOpcode;\n+    private long framePayloadLength;\n+    private ChannelBuffer framePayload = null;\n+    private int framePayloadBytesRead = 0;\n+    private ChannelBuffer maskingKey;\n+\n+    private boolean allowExtensions = false;\n+    private boolean maskedPayload = false;\n+    private boolean receivedClosingHandshake = false;\n+\n+    public enum State {\n+        FRAME_START, MASKING_KEY, PAYLOAD, CORRUPT\n+    }\n+\n+    /**\n+     * Constructor\n+     * \n+     * @param maskedPayload\n+     *            Web socket servers must set this to true processed incoming\n+     *            masked payload. Client implementations must set this to false.\n+     * @param allowExtensions\n+     *            Flag to allow reserved extension bits to be used or not\n+     */\n+    public WebSocket08FrameDecoder(boolean maskedPayload, boolean allowExtensions) {\n+        super(State.FRAME_START);\n+        this.maskedPayload = maskedPayload;\n+        this.allowExtensions = allowExtensions;\n+    }\n+\n+    @Override\n+    protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer, State state)\n+            throws Exception {\n+\n+        // Discard all data received if closing handshake was received before.\n+        if (receivedClosingHandshake) {\n+            buffer.skipBytes(actualReadableBytes());\n+            return null;\n+        }\n+\n+        switch (state) {\n+        case FRAME_START:\n+            framePayloadBytesRead = 0;\n+            framePayloadLength = -1;\n+            framePayload = null;\n+\n+            // FIN, RSV, OPCODE\n+            byte b = buffer.readByte();\n+            frameFinalFlag = (b & 0x80) != 0;\n+            frameRsv = (b & 0x70) >> 4;\n+            frameOpcode = (b & 0x0F);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Decoding WebSocket Frame opCode=\" + frameOpcode);\n+            }\n+\n+            // MASK, PAYLOAD LEN 1\n+            b = buffer.readByte();\n+            boolean frameMasked = (b & 0x80) != 0;\n+            int framePayloadLen1 = (b & 0x7F);\n+\n+            if (frameRsv != 0 && !this.allowExtensions) {\n+                protocolViolation(channel, \"RSV != 0 and no extension negotiated, RSV:\" + frameRsv);\n+                return null;\n+            }\n+\n+            if (this.maskedPayload && !frameMasked) {\n+                protocolViolation(channel, \"unmasked client to server frame\");\n+                return null;\n+            }\n+            if (frameOpcode > 7) { // control frame (have MSB in opcode set)\n+\n+                // control frames MUST NOT be fragmented\n+                if (!frameFinalFlag) {\n+                    protocolViolation(channel, \"fragmented control frame\");\n+                    return null;\n+                }\n+\n+                // control frames MUST have payload 125 octets or less\n+                if (framePayloadLen1 > 125) {\n+                    protocolViolation(channel, \"control frame with payload length > 125 octets\");\n+                    return null;\n+                }\n+\n+                // check for reserved control frame opcodes\n+                if (!(frameOpcode == OPCODE_CLOSE || frameOpcode == OPCODE_PING || frameOpcode == OPCODE_PONG)) {\n+                    protocolViolation(channel, \"control frame using reserved opcode \" + frameOpcode);\n+                    return null;\n+                }\n+\n+                // close frame : if there is a body, the first two bytes of the\n+                // body MUST be a 2-byte unsigned integer (in network byte\n+                // order) representing a status code\n+                if (frameOpcode == 8 && framePayloadLen1 == 1) {\n+                    protocolViolation(channel, \"received close control frame with payload len 1\");\n+                    return null;\n+                }\n+            } else { // data frame\n+                // check for reserved data frame opcodes\n+                if (!(frameOpcode == OPCODE_CONT || frameOpcode == OPCODE_TEXT || frameOpcode == OPCODE_BINARY)) {\n+                    protocolViolation(channel, \"data frame using reserved opcode \" + frameOpcode);\n+                    return null;\n+                }\n+\n+                // check opcode vs message fragmentation state 1/2\n+                if (fragmentedFramesCount == 0 && frameOpcode == OPCODE_CONT) {\n+                    protocolViolation(channel, \"received continuation data frame outside fragmented message\");\n+                    return null;\n+                }\n+\n+                // check opcode vs message fragmentation state 2/2\n+                if (fragmentedFramesCount != 0 && frameOpcode != OPCODE_CONT && frameOpcode != OPCODE_PING) {\n+                    protocolViolation(channel, \"received non-continuation data frame while inside fragmented message\");\n+                    return null;\n+                }\n+            }\n+\n+            // Read frame payload length\n+            if (framePayloadLen1 == 126) {\n+                framePayloadLength = buffer.readUnsignedShort();\n+                if (framePayloadLength < 126) {\n+                    protocolViolation(channel, \"invalid data frame length (not using minimal length encoding)\");\n+                    return null;\n+                }\n+            } else if (framePayloadLen1 == 127) {\n+                framePayloadLength = buffer.readLong();\n+                // TODO: check if it's bigger than 0x7FFFFFFFFFFFFFFF, Maybe\n+                // just check if it's negative?\n+\n+                if (framePayloadLength < 65536) {\n+                    protocolViolation(channel, \"invalid data frame length (not using minimal length encoding)\");\n+                    return null;\n+                }\n+            } else {\n+                framePayloadLength = framePayloadLen1;\n+            }\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Decoding WebSocket Frame length=\" + framePayloadLength);\n+            }\n+\n+            checkpoint(State.MASKING_KEY);\n+        case MASKING_KEY:\n+            if (this.maskedPayload) {\n+                maskingKey = buffer.readBytes(4);\n+            }\n+            checkpoint(State.PAYLOAD);\n+        case PAYLOAD:\n+            // Sometimes, the payload may not be delivered in 1 nice packet\n+            // We need to accumulate the data until we have it all\n+            int rbytes = actualReadableBytes();\n+            ChannelBuffer payloadBuffer = null;\n+\n+            int willHaveReadByteCount = framePayloadBytesRead + rbytes;\n+            // logger.debug(\"Frame rbytes=\" + rbytes + \" willHaveReadByteCount=\"\n+            // + willHaveReadByteCount + \" framePayloadLength=\" +\n+            // framePayloadLength);\n+            if (willHaveReadByteCount == framePayloadLength) {\n+                // We have all our content so proceed to process\n+                payloadBuffer = buffer.readBytes(rbytes);\n+            } else if (willHaveReadByteCount < framePayloadLength) {\n+                // We don't have all our content so accumulate payload.\n+                // Returning null means we will get called back\n+                payloadBuffer = buffer.readBytes(rbytes);\n+                if (framePayload == null) {\n+                    framePayload = channel.getConfig().getBufferFactory().getBuffer(toFrameLength(framePayloadLength));\n+                }\n+                framePayload.writeBytes(payloadBuffer);\n+                framePayloadBytesRead = framePayloadBytesRead + rbytes;\n+\n+                // Return null to wait for more bytes to arrive\n+                return null;\n+            } else if (willHaveReadByteCount > framePayloadLength) {\n+                // We have more than what we need so read up to the end of frame\n+                // Leave the remainder in the buffer for next frame\n+                payloadBuffer = buffer.readBytes(toFrameLength(framePayloadLength - framePayloadBytesRead));\n+            }\n+\n+            // Now we have all the data, the next checkpoint must be the next\n+            // frame\n+            checkpoint(State.FRAME_START);\n+\n+            // Take the data that we have in this packet\n+            if (framePayload == null) {\n+                framePayload = payloadBuffer;\n+            } else {\n+                framePayload.writeBytes(payloadBuffer);\n+            }\n+\n+            // Unmask data if needed\n+            if (this.maskedPayload) {\n+                unmask(framePayload);\n+            }\n+\n+            // Processing ping/pong/close frames because they cannot be\n+            // fragmented\n+            if (frameOpcode == OPCODE_PING) {\n+                return new PingWebSocketFrame(frameFinalFlag, frameRsv, framePayload);\n+            } else if (frameOpcode == OPCODE_PONG) {\n+                return new PongWebSocketFrame(frameFinalFlag, frameRsv, framePayload);\n+            } else if (frameOpcode == OPCODE_CLOSE) {\n+                this.receivedClosingHandshake = true;\n+                return new CloseWebSocketFrame(frameFinalFlag, frameRsv);\n+            }\n+\n+            // Processing for possible fragmented messages for text and binary\n+            // frames\n+            String aggregatedText = null;\n+            if (frameFinalFlag) {\n+                // Final frame of the sequence. Apparently ping frames are\n+                // allowed in the middle of a fragmented message\n+                if (frameOpcode != OPCODE_PING) {\n+                    fragmentedFramesCount = 0;\n+\n+                    // Check text for UTF8 correctness\n+                    if (frameOpcode == OPCODE_TEXT || fragmentedFramesText != null) {\n+                        // Check UTF-8 correctness for this payload\n+                        checkUTF8String(channel, framePayload.array());\n+\n+                        // This does a second check to make sure UTF-8\n+                        // correctness for entire text message\n+                        aggregatedText = fragmentedFramesText.toString();\n+\n+                        fragmentedFramesText = null;\n+                    }\n+                }\n+            } else {\n+                // Not final frame so we can expect more frames in the\n+                // fragmented sequence\n+                if (fragmentedFramesCount == 0) {\n+                    // First text or binary frame for a fragmented set\n+                    fragmentedFramesText = null;\n+                    if (frameOpcode == OPCODE_TEXT) {\n+                        checkUTF8String(channel, framePayload.array());\n+                    }\n+                } else {\n+                    // Subsequent frames - only check if init frame is text\n+                    if (fragmentedFramesText != null) {\n+                        checkUTF8String(channel, framePayload.array());\n+                    }\n+                }\n+\n+                // Increment counter\n+                fragmentedFramesCount++;\n+            }\n+\n+            // Return the frame\n+            if (frameOpcode == OPCODE_TEXT) {\n+                return new TextWebSocketFrame(frameFinalFlag, frameRsv, framePayload);\n+            } else if (frameOpcode == OPCODE_BINARY) {\n+                return new BinaryWebSocketFrame(frameFinalFlag, frameRsv, framePayload);\n+            } else if (frameOpcode == OPCODE_CONT) {\n+                return new ContinuationWebSocketFrame(frameFinalFlag, frameRsv, framePayload, aggregatedText);\n+            } else {\n+                throw new UnsupportedOperationException(\"Cannot decode web socket frame with opcode: \" + frameOpcode);\n+            }\n+        case CORRUPT:\n+            // If we don't keep reading Netty will throw an exception saying\n+            // we can't return null if no bytes read and state not changed.\n+            buffer.readByte();\n+            return null;\n+        default:\n+            throw new Error(\"Shouldn't reach here.\");\n+        }\n+    }\n+\n+    private void unmask(ChannelBuffer frame) {\n+        byte[] bytes = frame.array();\n+        for (int i = 0; i < bytes.length; i++) {\n+            frame.setByte(i, frame.getByte(i) ^ maskingKey.getByte(i % 4));\n+        }\n+    }\n+\n+    private void protocolViolation(Channel channel, String reason) throws CorruptedFrameException {\n+        checkpoint(State.CORRUPT);\n+        if (channel.isConnected()) {\n+            channel.write(ChannelBuffers.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);\n+            channel.close().awaitUninterruptibly();\n+        }\n+        throw new CorruptedFrameException(reason);\n+    }\n+\n+    private int toFrameLength(long l) throws TooLongFrameException {\n+        if (l > Integer.MAX_VALUE) {\n+            throw new TooLongFrameException(\"Length:\" + l);\n+        } else {\n+            return (int) l;\n+        }\n+    }\n+\n+    private void checkUTF8String(Channel channel, byte[] bytes) throws CorruptedFrameException {\n+        try {\n+            // StringBuilder sb = new StringBuilder(\"UTF8 \" + bytes.length +\n+            // \" bytes: \");\n+            // for (byte b : bytes) {\n+            // sb.append(Integer.toHexString(b)).append(\" \");\n+            // }\n+            // logger.debug(sb.toString());\n+\n+            if (fragmentedFramesText == null) {\n+                fragmentedFramesText = new UTF8Output(bytes);\n+            } else {\n+                fragmentedFramesText.write(bytes);\n+            }\n+        } catch (UTF8Exception ex) {\n+            protocolViolation(channel, \"invalid UTF-8 bytes\");\n+        }\n+    }\n }",
      "parent_sha": "48addae927fa38fe6fb13392be95545b8488a0f2"
    }
  },
  {
    "oid": "24678e2d00e8bd3a6a411da147eabfaf488769fe",
    "message": "update docs on running autobahn tests",
    "date": "2012-10-29T10:59:54Z",
    "url": "https://github.com/netty/netty/commit/24678e2d00e8bd3a6a411da147eabfaf488769fe",
    "details": {
      "sha": "dec7ef4f1ef3e9e6d30a61e0b83429dceb4a1157",
      "filename": "example/src/main/java/io/netty/example/http/websocketx/autobahn/package-info.java",
      "status": "modified",
      "additions": 31,
      "deletions": 28,
      "changes": 59,
      "blob_url": "https://github.com/netty/netty/blob/24678e2d00e8bd3a6a411da147eabfaf488769fe/example%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fexample%2Fhttp%2Fwebsocketx%2Fautobahn%2Fpackage-info.java",
      "raw_url": "https://github.com/netty/netty/raw/24678e2d00e8bd3a6a411da147eabfaf488769fe/example%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fexample%2Fhttp%2Fwebsocketx%2Fautobahn%2Fpackage-info.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/example%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fexample%2Fhttp%2Fwebsocketx%2Fautobahn%2Fpackage-info.java?ref=24678e2d00e8bd3a6a411da147eabfaf488769fe",
      "patch": "@@ -17,45 +17,48 @@\n /**\n  * This package is intended for use with testing against the Python\n  * <a href=\"http://www.tavendo.de/autobahn/testsuite.html\">AutoBahn test suite</a>.\n+ * \n+ * Autobahn installation documentation can be found <a href=\"http://autobahn.ws/testsuite/installation\">here</a>.\n+ * \n+ * <h3>How to run the tests on Ubuntu.</h3>\n  *\n- * <h3>How to run the tests on Ubuntu</h3>\n+ * <p>01. Install <a href=\"http://python.org/\">python</a> (if not already installed).\n+ * \n+ * <p>02. Install <a href=\"http://pypi.python.org/pypi/setuptools\">Python Setup Tools</a> if not already \n+ * installed. <tt>sudo apt-get install python-setuptools</tt>\n+ * \n+ * <p>03. Add <tt>ppa:twisted-dev/ppa</tt> to your system's Software Sources\n  *\n- * <p>01. Add <tt>ppa:twisted-dev/ppa</tt> to your system's Software Sources\n+ * <p>04. Install Twisted: <tt>sudo apt-get install python-twisted</tt>\n  *\n- * <p>02. Install Twisted V11: <tt>sudo apt-get install python-twisted</tt>\n+ * <p>05. Install AutoBahn: <tt>sudo easy_install autobahntestsuite</tt>.  Test using <tt>wstest --help<tt>.\n  *\n- * <p>03. Intall Python Setup Tools: <tt>sudo apt-get install python-setuptools</tt>\n+ * <p>06. Create a directory for test configuration and results: <tt>mkdir autobahn</tt> <tt>cd autobahn</tt>.\n  *\n- * <p>04. Install AutoBahn: <tt>sudo easy_install Autobahn</tt>. If you already have Autobahn installed, you may need\n- * to upgrade it: <tt>sudo easy_install --upgrade Autobahn</tt>. Make suer v0.4.10 is installed.\n- *\n- * <p>05. Get AutoBahn testsuite source code: <tt>git clone git@github.com:tavendo/AutobahnPython.git</tt>\n- *\n- * <p>06. Go to AutoBahn directory: <tt>cd AutobahnPython</tt>\n- *\n- * <p>07. Checkout stable version: <tt>git checkout v0.4.10</tt>\n- *\n- * <p>08. Go to test suite directory: <tt>cd testsuite/websockets</tt>\n- *\n- * <p>09. Edit <tt>fuzzing_clinet_spec.json</tt> and set the hybi specification version to 10 or 17 (RFC 6455).\n+ * <p>07. Create <tt>fuzzing_clinet_spec.json</tt> in the above directory\n  * <code>\n- *    {\n- *       \"options\": {\"failByDrop\": false},\n- *       \"servers\": [{\"agent\": \"Netty\", \"url\": \"ws://localhost:9000\", \"options\": {\"version\": 17}}],\n- *       \"cases\": [\"*\"],\n- *       \"exclude-cases\": [],\n- *       \"exclude-agent-cases\": {\"FoobarServer*\": [\"4.*\", \"1.1.3\"]}\n- *    }\n+ * {\n+ *    \"options\": {\"failByDrop\": false},\n+ *    \"outdir\": \"./reports/servers\",\n+ *  \n+ *    \"servers\": [\n+ *                 {\"agent\": \"Netty4\",\n+ *                  \"url\": \"ws://localhost:9000\",\n+ *                  \"options\": {\"version\": 18}}\n+ *               ],\n+ *  \n+ *    \"cases\": [\"*\"],\n+ *    \"exclude-cases\": [],\n+ *    \"exclude-agent-cases\": {}\n+ * }\n  * </code>\n  *\n- * <p>10. Run our <tt>AutobahnServer</tt> located in this package. If you are in Eclipse IDE, right click on\n+ * <p>08. Run the <tt>AutobahnServer</tt> located in this package. If you are in Eclipse IDE, right click on\n  * <tt>AutobahnServer.java</tt> and select Run As > Java Application.\n  *\n- * <p>11. Run the Autobahn test <tt>python fuzzing_client.py</tt>. Note that the actual test case python code is\n- * located with the easy_install package (e.g. in <tt>/usr/local/lib/python2.7/dist-packages/\n- * autobahn-0.4.10-py2.7.egg/autobahn/cases</tt>) and not in the checked out git repository.\n+ * <p>09. Run the Autobahn test <tt>wstest -m fuzzingclient -s fuzzingclient.json</tt>.\n  *\n- * <p>12. See the results in <tt>reports/servers/index.html</tt>\n+ * <p>10. See the results in <tt>./reports/servers/index.html</tt>\n  */\n package io.netty.example.http.websocketx.autobahn;\n ",
      "parent_sha": "122051ba44b2ab87b6481c00683aa79b33e1ab0f"
    }
  },
  {
    "oid": "c9a24729bdde00e2bbd0bed5e307af16db71e1c3",
    "message": "Fix #72",
    "date": "2011-11-22T19:14:10Z",
    "url": "https://github.com/netty/netty/commit/c9a24729bdde00e2bbd0bed5e307af16db71e1c3",
    "details": {
      "sha": "94d2715923a168b507748cb8c6af57e63663a90c",
      "filename": "src/main/java/org/jboss/netty/handler/codec/http/QueryStringDecoder.java",
      "status": "modified",
      "additions": 7,
      "deletions": 3,
      "changes": 10,
      "blob_url": "https://github.com/netty/netty/blob/c9a24729bdde00e2bbd0bed5e307af16db71e1c3/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2FQueryStringDecoder.java",
      "raw_url": "https://github.com/netty/netty/raw/c9a24729bdde00e2bbd0bed5e307af16db71e1c3/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2FQueryStringDecoder.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2FQueryStringDecoder.java?ref=c9a24729bdde00e2bbd0bed5e307af16db71e1c3",
      "patch": "@@ -30,9 +30,11 @@\n  * Splits an HTTP query string into a path string and key-value parameter pairs.\n  * This decoder is for one time use only.  Create a new instance for each URI:\n  * <pre>\n- * {@link QueryStringDecoder} decoder = new {@link QueryStringDecoder}(\"/hello?recipient=world\");\n+ * {@link QueryStringDecoder} decoder = new {@link QueryStringDecoder}(\"/hello?recipient=world&x=1;y=2\");\n  * assert decoder.getPath().equals(\"/hello\");\n  * assert decoder.getParameters().get(\"recipient\").equals(\"world\");\n+ * assert decoder.getParameters().get(\"x\").equals(\"1\");\n+ * assert decoder.getParameters().get(\"y\").equals(\"2\");\n  * </pre>\n  *\n  * @author <a href=\"http://www.jboss.org/netty/\">The Netty Project</a>\n@@ -73,7 +75,8 @@ public QueryStringDecoder(String uri, Charset charset) {\n             throw new NullPointerException(\"charset\");\n         }\n \n-        this.uri = uri;\n+        // http://en.wikipedia.org/wiki/Query_string\n+        this.uri = uri.replace(';', '&');\n         this.charset = charset;\n     }\n \n@@ -97,7 +100,8 @@ public QueryStringDecoder(URI uri, Charset charset){\n             throw new NullPointerException(\"charset\");\n         }\n \n-        this.uri = uri.toASCIIString();\n+        // http://en.wikipedia.org/wiki/Query_string\n+        this.uri = uri.toASCIIString().replace(';', '&');\n         this.charset = charset;\n     }\n ",
      "parent_sha": "3ecb93eadeaaf4df065862709dc4b456bd5a7f66"
    }
  },
  {
    "oid": "336cee9b1f431b5b3d5539984a391409ff2d9917",
    "message": "HpackDecoder#addHeader has an unused parameter\n\nMotivation:\nHpackDecoder#addHeader takes in the streamId as a parameter but no longer uses it.\n\nModifications:\n- Remove the streamId parameter from HpackDecoder#addHeader\n\nResult:\nLess unused parameters in HpackDecoder.",
    "date": "2017-12-22T06:17:24Z",
    "url": "https://github.com/netty/netty/commit/336cee9b1f431b5b3d5539984a391409ff2d9917",
    "details": {
      "sha": "a34bd3eb7976d9d4e847bfc770e988ac0c131e8f",
      "filename": "codec-http2/src/main/java/io/netty/handler/codec/http2/HpackDecoder.java",
      "status": "modified",
      "additions": 11,
      "deletions": 12,
      "changes": 23,
      "blob_url": "https://github.com/netty/netty/blob/336cee9b1f431b5b3d5539984a391409ff2d9917/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FHpackDecoder.java",
      "raw_url": "https://github.com/netty/netty/raw/336cee9b1f431b5b3d5539984a391409ff2d9917/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FHpackDecoder.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FHpackDecoder.java?ref=336cee9b1f431b5b3d5539984a391409ff2d9917",
      "patch": "@@ -146,7 +146,7 @@ public void decode(int streamId, ByteBuf in, Http2Headers headers) throws Http2E\n                                 state = READ_INDEXED_HEADER;\n                                 break;\n                             default:\n-                                headersLength = indexHeader(streamId, index, headers, headersLength);\n+                                headersLength = indexHeader(index, headers, headersLength);\n                         }\n                     } else if ((b & 0x40) == 0x40) {\n                         // Literal Header Field with Incremental Indexing\n@@ -200,7 +200,7 @@ public void decode(int streamId, ByteBuf in, Http2Headers headers) throws Http2E\n                     break;\n \n                 case READ_INDEXED_HEADER:\n-                    headersLength = indexHeader(streamId, decodeULE128(in, index), headers, headersLength);\n+                    headersLength = indexHeader(decodeULE128(in, index), headers, headersLength);\n                     state = READ_HEADER_REPRESENTATION;\n                     break;\n \n@@ -256,8 +256,7 @@ public void decode(int streamId, ByteBuf in, Http2Headers headers) throws Http2E\n                             state = READ_LITERAL_HEADER_VALUE_LENGTH;\n                             break;\n                         case 0:\n-                            headersLength = insertHeader(streamId, headers, name, EMPTY_STRING, indexType,\n-                                                         headersLength);\n+                            headersLength = insertHeader(headers, name, EMPTY_STRING, indexType, headersLength);\n                             state = READ_HEADER_REPRESENTATION;\n                             break;\n                         default:\n@@ -289,7 +288,7 @@ public void decode(int streamId, ByteBuf in, Http2Headers headers) throws Http2E\n                     }\n \n                     CharSequence value = readStringLiteral(in, valueLength, huffmanEncoded);\n-                    headersLength = insertHeader(streamId, headers, name, value, indexType, headersLength);\n+                    headersLength = insertHeader(headers, name, value, indexType, headersLength);\n                     state = READ_HEADER_REPRESENTATION;\n                     break;\n \n@@ -395,21 +394,21 @@ private CharSequence readName(int index) throws Http2Exception {\n         throw READ_NAME_ILLEGAL_INDEX_VALUE;\n     }\n \n-    private long indexHeader(int streamId, int index, Http2Headers headers, long headersLength) throws Http2Exception {\n+    private long indexHeader(int index, Http2Headers headers, long headersLength) throws Http2Exception {\n         if (index <= HpackStaticTable.length) {\n             HpackHeaderField hpackHeaderField = HpackStaticTable.getEntry(index);\n-            return addHeader(streamId, headers, hpackHeaderField.name, hpackHeaderField.value, headersLength);\n+            return addHeader(headers, hpackHeaderField.name, hpackHeaderField.value, headersLength);\n         }\n         if (index - HpackStaticTable.length <= hpackDynamicTable.length()) {\n             HpackHeaderField hpackHeaderField = hpackDynamicTable.getEntry(index - HpackStaticTable.length);\n-            return addHeader(streamId, headers, hpackHeaderField.name, hpackHeaderField.value, headersLength);\n+            return addHeader(headers, hpackHeaderField.name, hpackHeaderField.value, headersLength);\n         }\n         throw INDEX_HEADER_ILLEGAL_INDEX_VALUE;\n     }\n \n-    private long insertHeader(int streamId, Http2Headers headers, CharSequence name, CharSequence value,\n+    private long insertHeader(Http2Headers headers, CharSequence name, CharSequence value,\n                               IndexType indexType, long headerSize) throws Http2Exception {\n-        headerSize = addHeader(streamId, headers, name, value, headerSize);\n+        headerSize = addHeader(headers, name, value, headerSize);\n \n         switch (indexType) {\n             case NONE:\n@@ -427,8 +426,8 @@ private long insertHeader(int streamId, Http2Headers headers, CharSequence name,\n         return headerSize;\n     }\n \n-    private long addHeader(int streamId, Http2Headers headers, CharSequence name, CharSequence value,\n-                           long headersLength) throws Http2Exception {\n+    private long addHeader(Http2Headers headers, CharSequence name, CharSequence value, long headersLength)\n+            throws Http2Exception {\n         headersLength += HpackHeaderField.sizeOf(name, value);\n         if (headersLength > maxHeaderListSizeGoAway) {\n             headerListSizeExceeded(maxHeaderListSizeGoAway);",
      "parent_sha": "e004b4a354402707953e22a47912629cbd0538e4"
    }
  },
  {
    "oid": "86bbf242b4775183de1012645103ddf8e83bdcaa",
    "message": "[#5874] [#5971] Ensure SniHandlerTest.testServerNameParsing not fails with SslProvider.JDK\n\nMotivation:\n\nThe SniHandlerTest.testServerNameParsing did fail when SslProvider.JDK was used as it the JDK SSLEngineImpl does not send an alert.\n\nModifications:\n\nEnsure tests pass with JDK and OPENSSL ssl implementations.\n\nResult:\n\nSniHandlerTest will run with all SslProvider and not fail when SslProvider.JDK is used.",
    "date": "2016-11-16T06:59:30Z",
    "url": "https://github.com/netty/netty/commit/86bbf242b4775183de1012645103ddf8e83bdcaa",
    "details": {
      "sha": "53e265a895690e23f09c4c6612ccc8916463143a",
      "filename": "handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java",
      "status": "modified",
      "additions": 309,
      "deletions": 230,
      "changes": 539,
      "blob_url": "https://github.com/netty/netty/blob/86bbf242b4775183de1012645103ddf8e83bdcaa/handler%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2FSniHandlerTest.java",
      "raw_url": "https://github.com/netty/netty/raw/86bbf242b4775183de1012645103ddf8e83bdcaa/handler%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2FSniHandlerTest.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/handler%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fhandler%2Fssl%2FSniHandlerTest.java?ref=86bbf242b4775183de1012645103ddf8e83bdcaa",
      "patch": "@@ -26,6 +26,8 @@\n \n import java.io.File;\n import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n \n@@ -62,7 +64,10 @@\n import io.netty.util.ReferenceCounted;\n import io.netty.util.concurrent.Promise;\n import io.netty.util.internal.ObjectUtil;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n \n+@RunWith(Parameterized.class)\n public class SniHandlerTest {\n \n     private static ApplicationProtocolConfig newApnConfig() {\n@@ -75,292 +80,360 @@ private static ApplicationProtocolConfig newApnConfig() {\n                 \"myprotocol\");\n     }\n \n-    private static SslContext makeSslContext() throws Exception {\n-        return makeSslContext(null);\n+    private static void assumeApnSupported(SslProvider provider) {\n+        switch (provider) {\n+            case OPENSSL:\n+            case OPENSSL_REFCNT:\n+                assumeTrue(OpenSsl.isAlpnSupported());\n+                break;\n+            case JDK:\n+                assumeTrue(JdkAlpnSslEngine.isAvailable());\n+                break;\n+            default:\n+                throw new Error();\n+        }\n     }\n \n-    private static SslContext makeSslContext(SslProvider provider) throws Exception {\n+    private static SslContext makeSslContext(SslProvider provider, boolean apn) throws Exception {\n+        if (apn) {\n+            assumeApnSupported(provider);\n+        }\n+\n         File keyFile = new File(SniHandlerTest.class.getResource(\"test_encrypted.pem\").getFile());\n         File crtFile = new File(SniHandlerTest.class.getResource(\"test.crt\").getFile());\n \n-        return SslContextBuilder.forServer(crtFile, keyFile, \"12345\")\n-                .sslProvider(provider)\n-                .applicationProtocolConfig(newApnConfig()).build();\n+        SslContextBuilder sslCtxBuilder = SslContextBuilder.forServer(crtFile, keyFile, \"12345\")\n+                .sslProvider(provider);\n+        if (apn) {\n+            sslCtxBuilder.applicationProtocolConfig(newApnConfig());\n+        }\n+        return sslCtxBuilder.build();\n     }\n \n-    private static SslContext makeSslClientContext() throws Exception {\n+    private static SslContext makeSslClientContext(SslProvider provider, boolean apn) throws Exception {\n+        if (apn) {\n+            assumeApnSupported(provider);\n+        }\n+\n         File crtFile = new File(SniHandlerTest.class.getResource(\"test.crt\").getFile());\n \n-        return SslContextBuilder.forClient().trustManager(crtFile).applicationProtocolConfig(newApnConfig()).build();\n+        SslContextBuilder sslCtxBuilder = SslContextBuilder.forClient().trustManager(crtFile).sslProvider(provider);\n+        if (apn) {\n+            sslCtxBuilder.applicationProtocolConfig(newApnConfig());\n+        }\n+        return sslCtxBuilder.build();\n+    }\n+\n+    @Parameterized.Parameters(name = \"{index}: sslProvider={0}\")\n+    public static Iterable<? extends Object> data() {\n+        List<SslProvider> params = new ArrayList<SslProvider>(3);\n+        if (OpenSsl.isAvailable()) {\n+            params.add(SslProvider.OPENSSL);\n+            params.add(SslProvider.OPENSSL_REFCNT);\n+        }\n+        params.add(SslProvider.JDK);\n+        return params;\n+    }\n+\n+    private final SslProvider provider;\n+\n+    public SniHandlerTest(SslProvider provider) {\n+        this.provider = provider;\n     }\n \n     @Test\n     public void testServerNameParsing() throws Exception {\n-        SslContext nettyContext = makeSslContext();\n-        SslContext leanContext = makeSslContext();\n-        SslContext leanContext2 = makeSslContext();\n-\n-        DomainNameMapping<SslContext> mapping = new DomainNameMappingBuilder<SslContext>(nettyContext)\n-                .add(\"*.netty.io\", nettyContext)\n-                // input with custom cases\n-                .add(\"*.LEANCLOUD.CN\", leanContext)\n-                // a hostname conflict with previous one, since we are using order-sensitive config, the engine won't\n-                // be used with the handler.\n-                .add(\"chat4.leancloud.cn\", leanContext2)\n-                .build();\n-\n-        SniHandler handler = new SniHandler(mapping);\n-        EmbeddedChannel ch = new EmbeddedChannel(handler);\n-\n-        // hex dump of a client hello packet, which contains hostname \"CHAT4\u3002LEANCLOUD\u3002CN\"\n-        String tlsHandshakeMessageHex1 = \"16030100\";\n-        // part 2\n-        String tlsHandshakeMessageHex = \"bd010000b90303a74225676d1814ba57faff3b366\" +\n-                \"3656ed05ee9dbb2a4dbb1bb1c32d2ea5fc39e0000000100008c0000001700150000164348\" +\n-                \"415434E380824C45414E434C4F5544E38082434E000b000403000102000a00340032000e0\" +\n-                \"00d0019000b000c00180009000a0016001700080006000700140015000400050012001300\" +\n-                \"0100020003000f0010001100230000000d0020001e0601060206030501050205030401040\" +\n-                \"20403030103020303020102020203000f00010133740000\";\n+        SslContext nettyContext = makeSslContext(provider, false);\n+        SslContext leanContext = makeSslContext(provider, false);\n+        SslContext leanContext2 = makeSslContext(provider, false);\n \n         try {\n-            // Push the handshake message.\n-            // Decode should fail because SNI error\n-            ch.writeInbound(Unpooled.wrappedBuffer(DatatypeConverter.parseHexBinary(tlsHandshakeMessageHex1)));\n-            ch.writeInbound(Unpooled.wrappedBuffer(DatatypeConverter.parseHexBinary(tlsHandshakeMessageHex)));\n-            fail();\n-        } catch (DecoderException e) {\n-            // expected\n-        }\n+            DomainNameMapping<SslContext> mapping = new DomainNameMappingBuilder<SslContext>(nettyContext)\n+                    .add(\"*.netty.io\", nettyContext)\n+                    // input with custom cases\n+                    .add(\"*.LEANCLOUD.CN\", leanContext)\n+                    // a hostname conflict with previous one, since we are using order-sensitive config,\n+                    // the engine won't be used with the handler.\n+                    .add(\"chat4.leancloud.cn\", leanContext2)\n+                    .build();\n \n-        assertThat(ch.finish(), is(true));\n-        assertThat(handler.hostname(), is(\"chat4.leancloud.cn\"));\n-        assertThat(handler.sslContext(), is(leanContext));\n+            SniHandler handler = new SniHandler(mapping);\n+            EmbeddedChannel ch = new EmbeddedChannel(handler);\n+\n+            // hex dump of a client hello packet, which contains hostname \"CHAT4\u3002LEANCLOUD\u3002CN\"\n+            String tlsHandshakeMessageHex1 = \"16030100\";\n+            // part 2\n+            String tlsHandshakeMessageHex = \"bd010000b90303a74225676d1814ba57faff3b366\" +\n+                    \"3656ed05ee9dbb2a4dbb1bb1c32d2ea5fc39e0000000100008c0000001700150000164348\" +\n+                    \"415434E380824C45414E434C4F5544E38082434E000b000403000102000a00340032000e0\" +\n+                    \"00d0019000b000c00180009000a0016001700080006000700140015000400050012001300\" +\n+                    \"0100020003000f0010001100230000000d0020001e0601060206030501050205030401040\" +\n+                    \"20403030103020303020102020203000f00010133740000\";\n+\n+            try {\n+                // Push the handshake message.\n+                // Decode should fail because SNI error\n+                ch.writeInbound(Unpooled.wrappedBuffer(DatatypeConverter.parseHexBinary(tlsHandshakeMessageHex1)));\n+                ch.writeInbound(Unpooled.wrappedBuffer(DatatypeConverter.parseHexBinary(tlsHandshakeMessageHex)));\n+                fail();\n+            } catch (DecoderException e) {\n+                // expected\n+            }\n \n-        for (;;) {\n-            Object msg = ch.readOutbound();\n-            if (msg == null) {\n-                break;\n+            // Just call finish and not assert the return value. This is because OpenSSL correct produces an alert\n+            // while the JDK SSLEngineImpl does not atm.\n+            // See https://github.com/netty/netty/issues/5874\n+            ch.finish();\n+\n+            assertThat(handler.hostname(), is(\"chat4.leancloud.cn\"));\n+            assertThat(handler.sslContext(), is(leanContext));\n+\n+            for (;;) {\n+                Object msg = ch.readOutbound();\n+                if (msg == null) {\n+                    break;\n+                }\n+                ReferenceCountUtil.release(msg);\n             }\n-            ReferenceCountUtil.release(msg);\n+        } finally {\n+            releaseAll(leanContext, leanContext2, nettyContext);\n         }\n     }\n \n     @Test\n     public void testFallbackToDefaultContext() throws Exception {\n-        SslContext nettyContext = makeSslContext();\n-        SslContext leanContext = makeSslContext();\n-        SslContext leanContext2 = makeSslContext();\n+        SslContext nettyContext = makeSslContext(provider, false);\n+        SslContext leanContext = makeSslContext(provider, false);\n+        SslContext leanContext2 = makeSslContext(provider, false);\n \n-        DomainNameMapping<SslContext> mapping = new DomainNameMappingBuilder<SslContext>(nettyContext)\n-                .add(\"*.netty.io\", nettyContext)\n-                // input with custom cases\n-                .add(\"*.LEANCLOUD.CN\", leanContext)\n-                // a hostname conflict with previous one, since we are using order-sensitive config, the engine won't\n-                // be used with the handler.\n-                .add(\"chat4.leancloud.cn\", leanContext2)\n-                .build();\n+        try {\n+            DomainNameMapping<SslContext> mapping = new DomainNameMappingBuilder<SslContext>(nettyContext)\n+                    .add(\"*.netty.io\", nettyContext)\n+                    // input with custom cases\n+                    .add(\"*.LEANCLOUD.CN\", leanContext)\n+                    // a hostname conflict with previous one, since we are using order-sensitive config,\n+                    // the engine won't be used with the handler.\n+                    .add(\"chat4.leancloud.cn\", leanContext2)\n+                    .build();\n \n-        SniHandler handler = new SniHandler(mapping);\n-        EmbeddedChannel ch = new EmbeddedChannel(handler);\n+            SniHandler handler = new SniHandler(mapping);\n+            EmbeddedChannel ch = new EmbeddedChannel(handler);\n \n-        // invalid\n-        byte[] message = { 22, 3, 1, 0, 0 };\n+            // invalid\n+            byte[] message = {22, 3, 1, 0, 0};\n \n-        try {\n-            // Push the handshake message.\n-            ch.writeInbound(Unpooled.wrappedBuffer(message));\n-        } catch (Exception e) {\n-            // expected\n-        }\n+            try {\n+                // Push the handshake message.\n+                ch.writeInbound(Unpooled.wrappedBuffer(message));\n+            } catch (Exception e) {\n+                // expected\n+            }\n \n-        assertThat(ch.finish(), is(false));\n-        assertThat(handler.hostname(), nullValue());\n-        assertThat(handler.sslContext(), is(nettyContext));\n+            assertThat(ch.finish(), is(false));\n+            assertThat(handler.hostname(), nullValue());\n+            assertThat(handler.sslContext(), is(nettyContext));\n+        } finally {\n+            releaseAll(leanContext, leanContext2, nettyContext);\n+        }\n     }\n \n     @Test\n     public void testSniWithApnHandler() throws Exception {\n-        SslContext nettyContext = makeSslContext();\n-        SslContext sniContext = makeSslContext();\n-        final SslContext clientContext = makeSslClientContext();\n-        final CountDownLatch serverApnDoneLatch = new CountDownLatch(1);\n-        final CountDownLatch clientApnDoneLatch = new CountDownLatch(1);\n-\n-        final DomainNameMapping<SslContext> mapping = new DomainNameMappingBuilder<SslContext>(nettyContext)\n-                                                         .add(\"*.netty.io\", nettyContext)\n-                                                         .add(\"sni.fake.site\", sniContext).build();\n-        final SniHandler handler = new SniHandler(mapping);\n-        EventLoopGroup group = new NioEventLoopGroup(2);\n-        Channel serverChannel = null;\n-        Channel clientChannel = null;\n+        SslContext nettyContext = makeSslContext(provider, true);\n+        SslContext sniContext = makeSslContext(provider, true);\n+        final SslContext clientContext = makeSslClientContext(provider, true);\n         try {\n-            ServerBootstrap sb = new ServerBootstrap();\n-            sb.group(group);\n-            sb.channel(NioServerSocketChannel.class);\n-            sb.childHandler(new ChannelInitializer<Channel>() {\n-                @Override\n-                protected void initChannel(Channel ch) throws Exception {\n-                    ChannelPipeline p = ch.pipeline();\n-                    // Server side SNI.\n-                    p.addLast(handler);\n-                    // Catch the notification event that APN has completed successfully.\n-                    p.addLast(new ApplicationProtocolNegotiationHandler(\"foo\") {\n-                        @Override\n-                        protected void configurePipeline(ChannelHandlerContext ctx, String protocol) throws Exception {\n-                            serverApnDoneLatch.countDown();\n-                        }\n-                    });\n-                }\n-            });\n-\n-            Bootstrap cb = new Bootstrap();\n-            cb.group(group);\n-            cb.channel(NioSocketChannel.class);\n-            cb.handler(new ChannelInitializer<Channel>() {\n-                @Override\n-                protected void initChannel(Channel ch) throws Exception {\n-                    ch.pipeline().addLast(new SslHandler(clientContext.newEngine(\n-                            ch.alloc(), \"sni.fake.site\", -1)));\n-                    // Catch the notification event that APN has completed successfully.\n-                    ch.pipeline().addLast(new ApplicationProtocolNegotiationHandler(\"foo\") {\n-                        @Override\n-                        protected void configurePipeline(ChannelHandlerContext ctx, String protocol) throws Exception {\n-                            clientApnDoneLatch.countDown();\n-                        }\n-                    });\n-                }\n-            });\n+            final CountDownLatch serverApnDoneLatch = new CountDownLatch(1);\n+            final CountDownLatch clientApnDoneLatch = new CountDownLatch(1);\n+\n+            final DomainNameMapping<SslContext> mapping = new DomainNameMappingBuilder<SslContext>(nettyContext)\n+                    .add(\"*.netty.io\", nettyContext)\n+                    .add(\"sni.fake.site\", sniContext).build();\n+            final SniHandler handler = new SniHandler(mapping);\n+            EventLoopGroup group = new NioEventLoopGroup(2);\n+            Channel serverChannel = null;\n+            Channel clientChannel = null;\n+            try {\n+                ServerBootstrap sb = new ServerBootstrap();\n+                sb.group(group);\n+                sb.channel(NioServerSocketChannel.class);\n+                sb.childHandler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(Channel ch) throws Exception {\n+                        ChannelPipeline p = ch.pipeline();\n+                        // Server side SNI.\n+                        p.addLast(handler);\n+                        // Catch the notification event that APN has completed successfully.\n+                        p.addLast(new ApplicationProtocolNegotiationHandler(\"foo\") {\n+                            @Override\n+                            protected void configurePipeline(ChannelHandlerContext ctx, String protocol) {\n+                                serverApnDoneLatch.countDown();\n+                            }\n+                        });\n+                    }\n+                });\n+\n+                Bootstrap cb = new Bootstrap();\n+                cb.group(group);\n+                cb.channel(NioSocketChannel.class);\n+                cb.handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(Channel ch) throws Exception {\n+                        ch.pipeline().addLast(new SslHandler(clientContext.newEngine(\n+                                ch.alloc(), \"sni.fake.site\", -1)));\n+                        // Catch the notification event that APN has completed successfully.\n+                        ch.pipeline().addLast(new ApplicationProtocolNegotiationHandler(\"foo\") {\n+                            @Override\n+                            protected void configurePipeline(ChannelHandlerContext ctx, String protocol) {\n+                                clientApnDoneLatch.countDown();\n+                            }\n+                        });\n+                    }\n+                });\n \n-            serverChannel = sb.bind(new InetSocketAddress(0)).sync().channel();\n+                serverChannel = sb.bind(new InetSocketAddress(0)).sync().channel();\n \n-            ChannelFuture ccf = cb.connect(serverChannel.localAddress());\n-            assertTrue(ccf.awaitUninterruptibly().isSuccess());\n-            clientChannel = ccf.channel();\n+                ChannelFuture ccf = cb.connect(serverChannel.localAddress());\n+                assertTrue(ccf.awaitUninterruptibly().isSuccess());\n+                clientChannel = ccf.channel();\n \n-            assertTrue(serverApnDoneLatch.await(5, TimeUnit.SECONDS));\n-            assertTrue(clientApnDoneLatch.await(5, TimeUnit.SECONDS));\n-            assertThat(handler.hostname(), is(\"sni.fake.site\"));\n-            assertThat(handler.sslContext(), is(sniContext));\n-        } finally {\n-            if (serverChannel != null) {\n-                serverChannel.close().sync();\n-            }\n-            if (clientChannel != null) {\n-                clientChannel.close().sync();\n+                assertTrue(serverApnDoneLatch.await(5, TimeUnit.SECONDS));\n+                assertTrue(clientApnDoneLatch.await(5, TimeUnit.SECONDS));\n+                assertThat(handler.hostname(), is(\"sni.fake.site\"));\n+                assertThat(handler.sslContext(), is(sniContext));\n+            } finally {\n+                if (serverChannel != null) {\n+                    serverChannel.close().sync();\n+                }\n+                if (clientChannel != null) {\n+                    clientChannel.close().sync();\n+                }\n+                group.shutdownGracefully(0, 0, TimeUnit.MICROSECONDS);\n             }\n-            group.shutdownGracefully(0, 0, TimeUnit.MICROSECONDS);\n+        } finally {\n+            releaseAll(clientContext, nettyContext, sniContext);\n         }\n     }\n \n     @Test(timeout = 10L * 1000L)\n     public void testReplaceHandler() throws Exception {\n+        switch (provider) {\n+            case OPENSSL:\n+            case OPENSSL_REFCNT:\n+                final String sniHost = \"sni.netty.io\";\n+                LocalAddress address = new LocalAddress(\"testReplaceHandler-\" + Math.random());\n+                EventLoopGroup group = new DefaultEventLoopGroup(1);\n+                Channel sc = null;\n+                Channel cc = null;\n+                SslContext sslContext = null;\n+\n+                SelfSignedCertificate cert = new SelfSignedCertificate();\n+\n+                try {\n+                    final SslContext sslServerContext = SslContextBuilder\n+                            .forServer(cert.key(), cert.cert())\n+                            .sslProvider(provider)\n+                            .build();\n+\n+                    final Mapping<String, SslContext> mapping = new Mapping<String, SslContext>() {\n+                        @Override\n+                        public SslContext map(String input) {\n+                            return sslServerContext;\n+                        }\n+                    };\n \n-        assumeTrue(OpenSsl.isAvailable());\n-\n-        final String sniHost = \"sni.netty.io\";\n-        LocalAddress address = new LocalAddress(\"testReplaceHandler-\" + Math.random());\n-        EventLoopGroup group = new DefaultEventLoopGroup(1);\n-        Channel sc = null;\n-        Channel cc = null;\n-\n-        SelfSignedCertificate cert = new SelfSignedCertificate();\n-\n-        try {\n-            final SslContext sslServerContext = SslContextBuilder\n-                    .forServer(cert.key(), cert.cert())\n-                    .sslProvider(SslProvider.OPENSSL)\n-                    .build();\n+                    final Promise<Void> releasePromise = group.next().newPromise();\n \n-            final Mapping<String, SslContext> mapping = new Mapping<String, SslContext>() {\n-                @Override\n-                public SslContext map(String input) {\n-                    return sslServerContext;\n-                }\n-            };\n-\n-            final Promise<Void> releasePromise = group.next().newPromise();\n-\n-            final SniHandler handler = new SniHandler(mapping) {\n-                @Override\n-                protected void replaceHandler(ChannelHandlerContext ctx,\n-                        String hostname, final SslContext sslContext)\n-                        throws Exception {\n-\n-                    boolean success = false;\n-                    try {\n-                        // The SniHandler's replaceHandler() method allows us to implement custom behavior.\n-                        // As an example, we want to release() the SslContext upon channelInactive() or rather\n-                        // when the SslHandler closes it's SslEngine. If you take a close look at SslHandler\n-                        // you'll see that it's doing it in the #handlerRemoved0() method.\n-\n-                        SSLEngine sslEngine = sslContext.newEngine(ctx.alloc());\n-                        try {\n-                            SslHandler customSslHandler = new CustomSslHandler(sslContext, sslEngine) {\n-                                @Override\n-                                public void handlerRemoved0(ChannelHandlerContext ctx) throws Exception {\n-                                    try {\n-                                        super.handlerRemoved0(ctx);\n-                                    } finally {\n-                                        releasePromise.trySuccess(null);\n+                    final SniHandler handler = new SniHandler(mapping) {\n+                        @Override\n+                        protected void replaceHandler(ChannelHandlerContext ctx,\n+                                                      String hostname, final SslContext sslContext)\n+                                throws Exception {\n+\n+                            boolean success = false;\n+                            try {\n+                                // The SniHandler's replaceHandler() method allows us to implement custom behavior.\n+                                // As an example, we want to release() the SslContext upon channelInactive() or rather\n+                                // when the SslHandler closes it's SslEngine. If you take a close look at SslHandler\n+                                // you'll see that it's doing it in the #handlerRemoved0() method.\n+\n+                                SSLEngine sslEngine = sslContext.newEngine(ctx.alloc());\n+                                try {\n+                                    SslHandler customSslHandler = new CustomSslHandler(sslContext, sslEngine) {\n+                                        @Override\n+                                        public void handlerRemoved0(ChannelHandlerContext ctx) throws Exception {\n+                                            try {\n+                                                super.handlerRemoved0(ctx);\n+                                            } finally {\n+                                                releasePromise.trySuccess(null);\n+                                            }\n+                                        }\n+                                    };\n+                                    ctx.pipeline().replace(this, CustomSslHandler.class.getName(), customSslHandler);\n+                                    success = true;\n+                                } finally {\n+                                    if (!success) {\n+                                        ReferenceCountUtil.safeRelease(sslEngine);\n                                     }\n                                 }\n-                            };\n-                            ctx.pipeline().replace(this, CustomSslHandler.class.getName(), customSslHandler);\n-                            success = true;\n-                        } finally {\n-                            if (!success) {\n-                                ReferenceCountUtil.safeRelease(sslEngine);\n+                            } finally {\n+                                if (!success) {\n+                                    ReferenceCountUtil.safeRelease(sslContext);\n+                                    releasePromise.cancel(true);\n+                                }\n                             }\n                         }\n-                    } finally {\n-                        if (!success) {\n-                            ReferenceCountUtil.safeRelease(sslContext);\n-                            releasePromise.cancel(true);\n-                        }\n-                    }\n-                }\n-            };\n+                    };\n \n-            ServerBootstrap sb = new ServerBootstrap();\n-            sc = sb.group(group).channel(LocalServerChannel.class).childHandler(new ChannelInitializer<Channel>() {\n-                @Override\n-                protected void initChannel(Channel ch) throws Exception {\n-                    ch.pipeline().addFirst(handler);\n-                }\n-            }).bind(address).syncUninterruptibly().channel();\n+                    ServerBootstrap sb = new ServerBootstrap();\n+                    sc = sb.group(group).channel(LocalServerChannel.class)\n+                            .childHandler(new ChannelInitializer<Channel>() {\n+                        @Override\n+                        protected void initChannel(Channel ch) throws Exception {\n+                            ch.pipeline().addFirst(handler);\n+                        }\n+                    }).bind(address).syncUninterruptibly().channel();\n \n-            SslContext sslContext = SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE)\n-                    .build();\n+                    sslContext = SslContextBuilder.forClient().sslProvider(provider)\n+                            .trustManager(InsecureTrustManagerFactory.INSTANCE).build();\n \n-            Bootstrap cb = new Bootstrap();\n-            cc = cb.group(group).channel(LocalChannel.class).handler(new SslHandler(\n-                    sslContext.newEngine(ByteBufAllocator.DEFAULT, sniHost, -1)))\n-                    .connect(address).syncUninterruptibly().channel();\n+                    Bootstrap cb = new Bootstrap();\n+                    cc = cb.group(group).channel(LocalChannel.class).handler(new SslHandler(\n+                            sslContext.newEngine(ByteBufAllocator.DEFAULT, sniHost, -1)))\n+                            .connect(address).syncUninterruptibly().channel();\n \n-            cc.writeAndFlush(Unpooled.wrappedBuffer(\"Hello, World!\".getBytes()))\n-                .syncUninterruptibly();\n+                    cc.writeAndFlush(Unpooled.wrappedBuffer(\"Hello, World!\".getBytes()))\n+                            .syncUninterruptibly();\n \n-            // Notice how the server's SslContext refCnt is 1\n-            assertEquals(1, ((ReferenceCounted) sslServerContext).refCnt());\n+                    // Notice how the server's SslContext refCnt is 1\n+                    assertEquals(1, ((ReferenceCounted) sslServerContext).refCnt());\n \n-            // The client disconnects\n-            cc.close().syncUninterruptibly();\n-            if (!releasePromise.awaitUninterruptibly(10L, TimeUnit.SECONDS)) {\n-                throw new IllegalStateException(\"It doesn't seem #replaceHandler() got called.\");\n-            }\n+                    // The client disconnects\n+                    cc.close().syncUninterruptibly();\n+                    if (!releasePromise.awaitUninterruptibly(10L, TimeUnit.SECONDS)) {\n+                        throw new IllegalStateException(\"It doesn't seem #replaceHandler() got called.\");\n+                    }\n \n-            // We should have successfully release() the SslContext\n-            assertEquals(0, ((ReferenceCounted) sslServerContext).refCnt());\n-        } finally {\n-            if (cc != null) {\n-                cc.close().syncUninterruptibly();\n-            }\n-            if (sc != null) {\n-                sc.close().syncUninterruptibly();\n-            }\n-            group.shutdownGracefully();\n+                    // We should have successfully release() the SslContext\n+                    assertEquals(0, ((ReferenceCounted) sslServerContext).refCnt());\n+                } finally {\n+                    if (cc != null) {\n+                        cc.close().syncUninterruptibly();\n+                    }\n+                    if (sc != null) {\n+                        sc.close().syncUninterruptibly();\n+                    }\n+                    if (sslContext != null) {\n+                        ReferenceCountUtil.release(sslContext);\n+                    }\n+                    group.shutdownGracefully();\n \n-            cert.delete();\n+                    cert.delete();\n+                }\n+            case JDK:\n+                return;\n+            default:\n+                throw new Error();\n         }\n     }\n \n@@ -384,4 +457,10 @@ public void handlerRemoved0(ChannelHandlerContext ctx) throws Exception {\n             ReferenceCountUtil.release(sslContext);\n         }\n     }\n+\n+    private static void releaseAll(SslContext... contexts) {\n+        for (SslContext ctx: contexts) {\n+            ReferenceCountUtil.release(ctx);\n+        }\n+    }\n }",
      "parent_sha": "2c78902ebc7a81caa0ee6e3892438455f06dec9c"
    }
  },
  {
    "oid": "3ca17a96cf84cbcb08776d3731b222b82814ead7",
    "message": "IoUring: Also log kernel version when loading io_uring transport (#14967)\n\nMotivation:\n\nWe should also log the detected kernel version to make debugging easier\nwhen trying to load the io_uring transport.\n\nModifications:\n\nInclude kernel version in log message.\n\nResult:\n\nMore details in logging message.",
    "date": "2025-03-26T18:14:52Z",
    "url": "https://github.com/netty/netty/commit/3ca17a96cf84cbcb08776d3731b222b82814ead7",
    "details": {
      "sha": "5ab57ec5a5ba93288be8668f4e2197173fd21e04",
      "filename": "transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUring.java",
      "status": "modified",
      "additions": 9,
      "deletions": 7,
      "changes": 16,
      "blob_url": "https://github.com/netty/netty/blob/3ca17a96cf84cbcb08776d3731b222b82814ead7/transport-classes-io_uring%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Furing%2FIoUring.java",
      "raw_url": "https://github.com/netty/netty/raw/3ca17a96cf84cbcb08776d3731b222b82814ead7/transport-classes-io_uring%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Furing%2FIoUring.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/transport-classes-io_uring%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Furing%2FIoUring.java?ref=3ca17a96cf84cbcb08776d3731b222b82814ead7",
      "patch": "@@ -63,12 +63,13 @@ public final class IoUring {\n         boolean registerBufferRingSupported = false;\n         boolean registerBufferRingIncSupported = false;\n \n+        String kernelVersion = \"[unknown]\";\n         try {\n             if (SystemPropertyUtil.getBoolean(\"io.netty.transport.noNative\", false)) {\n                 cause = new UnsupportedOperationException(\n                         \"Native transport was explicit disabled with -Dio.netty.transport.noNative=true\");\n             } else {\n-                String kernelVersion = Native.kernelVersion();\n+                kernelVersion = Native.kernelVersion();\n                 Native.checkKernelVersion(kernelVersion);\n                 Throwable unsafeCause = PlatformDependent.getUnsafeUnavailabilityCause();\n                 if (unsafeCause == null) {\n@@ -113,13 +114,13 @@ public final class IoUring {\n         }\n         if (cause != null) {\n             if (logger.isTraceEnabled()) {\n-                logger.debug(\"IoUring support is not available\", cause);\n+                logger.debug(\"IoUring support is not available using kernel {}\", kernelVersion, cause);\n             } else if (logger.isDebugEnabled()) {\n-                logger.debug(\"IoUring support is not available: {}\", cause.getMessage());\n+                logger.debug(\"IoUring support is not available using kernel {}: {}\", kernelVersion, cause.getMessage());\n             }\n         } else {\n             if (logger.isDebugEnabled()) {\n-                logger.debug(\"IoUring support is available (\" +\n+                logger.debug(\"IoUring support is available using kernel {} (\" +\n                         \"CQE_F_SOCK_NONEMPTY_SUPPORTED={}, \" +\n                         \"SPLICE_SUPPORTED={}, \" +\n                         \"ACCEPT_NO_WAIT_SUPPORTED={}, \" +\n@@ -133,9 +134,10 @@ public final class IoUring {\n                         \"SETUP_DEFER_TASKRUN_SUPPORTED={}, \" +\n                         \"REGISTER_BUFFER_RING_SUPPORTED={}, \" +\n                         \"REGISTER_BUFFER_RING_INC_SUPPORTED={}\" +\n-                        \")\", socketNonEmptySupported, spliceSupported, acceptSupportNoWait, acceptMultishotSupported,\n-                        pollAddMultishotSupported, recvMultishotSupported, recvsendBundleSupported,\n-                        registerIowqWorkersSupported, submitAllSupported, singleIssuerSupported, deferTaskrunSupported,\n+                        \")\", kernelVersion, socketNonEmptySupported, spliceSupported, acceptSupportNoWait,\n+                        acceptMultishotSupported, pollAddMultishotSupported, recvMultishotSupported,\n+                        recvsendBundleSupported, registerIowqWorkersSupported, submitAllSupported,\n+                        singleIssuerSupported, deferTaskrunSupported,\n                         registerBufferRingSupported, registerBufferRingIncSupported);\n             }\n         }",
      "parent_sha": "2b43b4db538c13eba3cf13edf559a0cda00bd83d"
    }
  },
  {
    "oid": "b82258b72fdf4c733d9c4a641c6b8725b036485f",
    "message": "Introduce `needReport` for `ResourceLeakDetector`. (#9910)\n\nMotivation:\r\n\r\nWe can extend `ResourceLeakDetector` through `ResourceLeakDetectorFactory`, and then report the leaked information by covering `reportTracedLeak` and `reportUntracedLeak`. However, the behavior of `reportTracedLeak` and `reportUntracedLeak` is controlled by `logger.isErrorEnabled()`, which is not reasonable. In the case of extending `ResourceLeakDetector`, we sometimes need `needReport` to always return true instead of relying on `logger.isErrorEnabled ()`.\r\n\r\nModification:\r\n\r\nintroduce `needReport` method and let it be `protected`\r\n\r\nResult:\r\n\r\nWe can control the report leak behavior.",
    "date": "2020-01-10T04:21:24Z",
    "url": "https://github.com/netty/netty/commit/b82258b72fdf4c733d9c4a641c6b8725b036485f",
    "details": {
      "sha": "5b9dd161d46532fc70153eef073251489a7fc8e7",
      "filename": "common/src/main/java/io/netty/util/ResourceLeakDetector.java",
      "status": "modified",
      "additions": 11,
      "deletions": 1,
      "changes": 12,
      "blob_url": "https://github.com/netty/netty/blob/b82258b72fdf4c733d9c4a641c6b8725b036485f/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2FResourceLeakDetector.java",
      "raw_url": "https://github.com/netty/netty/raw/b82258b72fdf4c733d9c4a641c6b8725b036485f/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2FResourceLeakDetector.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2FResourceLeakDetector.java?ref=b82258b72fdf4c733d9c4a641c6b8725b036485f",
      "patch": "@@ -274,8 +274,18 @@ private void clearRefQueue() {\n         }\n     }\n \n+    /**\n+     * When the return value is {@code true}, {@link #reportTracedLeak} and {@link #reportUntracedLeak}\n+     * will be called once a leak is detected, otherwise not.\n+     *\n+     * @return {@code true} to enable leak reporting.\n+     */\n+    protected boolean needReport() {\n+        return logger.isErrorEnabled();\n+    }\n+\n     private void reportLeak() {\n-        if (!logger.isErrorEnabled()) {\n+        if (!needReport()) {\n             clearRefQueue();\n             return;\n         }",
      "parent_sha": "76fb4c894af15cd1e30495a91074b2d95940e451"
    }
  },
  {
    "oid": "1314db9c0ad4b36863eb9ffac0fac64875ccd197",
    "message": "Fix a NPE in a testcase when running via ubuntu",
    "date": "2012-04-10T06:12:10Z",
    "url": "https://github.com/netty/netty/commit/1314db9c0ad4b36863eb9ffac0fac64875ccd197",
    "details": {
      "sha": "15c5095f6e34dec4cd9f2c9984cb56637c611892",
      "filename": "testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/netty/netty/blob/1314db9c0ad4b36863eb9ffac0fac64875ccd197/testsuite%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Ftestsuite%2Ftransport%2Fsocket%2FAbstractDatagramMulticastTest.java",
      "raw_url": "https://github.com/netty/netty/raw/1314db9c0ad4b36863eb9ffac0fac64875ccd197/testsuite%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Ftestsuite%2Ftransport%2Fsocket%2FAbstractDatagramMulticastTest.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/testsuite%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Ftestsuite%2Ftransport%2Fsocket%2FAbstractDatagramMulticastTest.java?ref=1314db9c0ad4b36863eb9ffac0fac64875ccd197",
      "patch": "@@ -28,7 +28,6 @@\n import io.netty.testsuite.util.TestUtils;\n import io.netty.util.internal.ExecutorUtil;\n \n-import java.net.InetAddress;\n import java.net.InetSocketAddress;\n import java.net.NetworkInterface;\n import java.util.concurrent.CountDownLatch;\n@@ -73,7 +72,7 @@ public void testMulticast() throws Throwable {\n \n         int port = TestUtils.getFreePort();\n         \n-        NetworkInterface iface = NetworkInterface.getByInetAddress(InetAddress.getLocalHost());\n+        NetworkInterface iface = NetworkInterface.getNetworkInterfaces().nextElement();\n         sb.setOption(\"networkInterface\", iface);\n         sb.setOption(\"reuseAddress\", true);\n         ",
      "parent_sha": "16bbd313300799acf516df4abe145cacf5cbae28"
    }
  },
  {
    "oid": "5170838e795e008330966030b584a9b2b12d5c62",
    "message": "Added direct buffer support (disabled by default and can't be enabled without recompilation for now - should be fixed in 3.1.)",
    "date": "2008-09-28T12:51:50Z",
    "url": "https://github.com/netty/netty/commit/5170838e795e008330966030b584a9b2b12d5c62",
    "details": {
      "sha": "383b09c8adbaf56b7b128f395a17056b55a44ba2",
      "filename": "src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java",
      "status": "modified",
      "additions": 71,
      "deletions": 4,
      "changes": 75,
      "blob_url": "https://github.com/netty/netty/blob/5170838e795e008330966030b584a9b2b12d5c62/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fchannel%2Fsocket%2Fnio%2FNioWorker.java",
      "raw_url": "https://github.com/netty/netty/raw/5170838e795e008330966030b584a9b2b12d5c62/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fchannel%2Fsocket%2Fnio%2FNioWorker.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fchannel%2Fsocket%2Fnio%2FNioWorker.java?ref=5170838e795e008330966030b584a9b2b12d5c62",
      "patch": "@@ -32,6 +32,7 @@\n import java.nio.channels.SelectionKey;\n import java.nio.channels.Selector;\n import java.util.Iterator;\n+import java.util.Queue;\n import java.util.Set;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.Executor;\n@@ -65,6 +66,7 @@ class NioWorker implements Runnable {\n         InternalLoggerFactory.getInstance(NioWorker.class);\n \n     private static final int CONSTRAINT_LEVEL = NioProviderMetadata.CONSTRAINT_LEVEL;\n+    private static final boolean USE_DIRECT_BUFFER = false;  // Hard-coded for now\n \n     private final int bossId;\n     private final int id;\n@@ -74,8 +76,7 @@ class NioWorker implements Runnable {\n     volatile Selector selector;\n     final AtomicBoolean wakenUp = new AtomicBoolean();\n     final ReadWriteLock selectorGuard = new ReentrantReadWriteLock();\n-    final ConcurrentLinkedQueue<Runnable> taskQueue = new ConcurrentLinkedQueue<Runnable>();\n-    //final ConcurrentFastQueue<Runnable> taskQueue = new ConcurrentFastQueue<Runnable>();\n+    final Queue<Runnable> taskQueue = new ConcurrentLinkedQueue<Runnable>();\n \n     NioWorker(int bossId, int id, Executor executor) {\n         this.bossId = bossId;\n@@ -254,7 +255,16 @@ private static void processSelectedKeys(Set<SelectionKey> selectedKeys) {\n             }\n \n             if (k.isReadable()) {\n-                read(k);\n+\n+                // TODO Replace ReceiveBufferSizePredictor with\n+                //      ChannelBufferAllocator and let user specify it per\n+                //      Channel. (Netty 3.1)\n+\n+                if (USE_DIRECT_BUFFER) {\n+                    readIntoDirectBuffer(k);\n+                } else {\n+                    readIntoHeapBuffer(k);\n+                }\n             }\n \n             if (!k.isValid()) {\n@@ -268,12 +278,13 @@ private static void processSelectedKeys(Set<SelectionKey> selectedKeys) {\n         }\n     }\n \n-    private static void read(SelectionKey k) {\n+    private static void readIntoHeapBuffer(SelectionKey k) {\n         ScatteringByteChannel ch = (ScatteringByteChannel) k.channel();\n         NioSocketChannel channel = (NioSocketChannel) k.attachment();\n \n         ReceiveBufferSizePredictor predictor =\n             channel.getConfig().getReceiveBufferSizePredictor();\n+\n         ChannelBuffer buf = ChannelBuffers.buffer(predictor.nextReceiveBufferSize());\n \n         int ret = 0;\n@@ -306,6 +317,62 @@ private static void read(SelectionKey k) {\n         }\n     }\n \n+    private ChannelBuffer preallocatedDirectBuffer;\n+\n+    private static void readIntoDirectBuffer(SelectionKey k) {\n+        ScatteringByteChannel ch = (ScatteringByteChannel) k.channel();\n+        NioSocketChannel channel = (NioSocketChannel) k.attachment();\n+\n+        ReceiveBufferSizePredictor predictor =\n+            channel.getConfig().getReceiveBufferSizePredictor();\n+\n+        ChannelBuffer preallocatedDirectBuffer = channel.getWorker().preallocatedDirectBuffer;\n+        NioWorker worker = channel.getWorker();\n+        worker.preallocatedDirectBuffer = null;\n+\n+        if (preallocatedDirectBuffer == null) {\n+            preallocatedDirectBuffer = ChannelBuffers.directBuffer(1048576);\n+        }\n+\n+        int ret = 0;\n+        int readBytes = 0;\n+        boolean failure = true;\n+        try {\n+            while ((ret = preallocatedDirectBuffer.writeBytes(ch, preallocatedDirectBuffer.writableBytes())) > 0) {\n+                readBytes += ret;\n+                if (!preallocatedDirectBuffer.writable()) {\n+                    break;\n+                }\n+            }\n+            failure = false;\n+        } catch (AsynchronousCloseException e) {\n+            // Can happen, and doesn't need a user attention.\n+        } catch (Throwable t) {\n+            fireExceptionCaught(channel, t);\n+        }\n+\n+        if (readBytes > 0) {\n+            // Update the predictor.\n+            predictor.previousReceiveBufferSize(readBytes);\n+\n+            // Fire the event.\n+            ChannelBuffer slice = preallocatedDirectBuffer.slice(\n+                    preallocatedDirectBuffer.readerIndex(),\n+                    preallocatedDirectBuffer.readableBytes());\n+            preallocatedDirectBuffer.readerIndex(preallocatedDirectBuffer.writerIndex());\n+            if (preallocatedDirectBuffer.writable()) {\n+                worker.preallocatedDirectBuffer = preallocatedDirectBuffer;\n+            }\n+            fireMessageReceived(channel, slice);\n+        } else if (readBytes == 0) {\n+            worker.preallocatedDirectBuffer = preallocatedDirectBuffer;\n+        }\n+\n+        if (ret < 0 || failure) {\n+            close(k);\n+        }\n+    }\n+\n     private static void write(SelectionKey k) {\n         NioSocketChannel ch = (NioSocketChannel) k.attachment();\n         write(ch, false);",
      "parent_sha": "b64124efd6aaadb7bea478d8dcb74af26cf9ebea"
    }
  },
  {
    "oid": "623d9d7202019a56457ffd02524c70ebc86958f2",
    "message": "Fix typo in warning message.",
    "date": "2015-07-29T16:38:33Z",
    "url": "https://github.com/netty/netty/commit/623d9d7202019a56457ffd02524c70ebc86958f2",
    "details": {
      "sha": "886ef4cd791bc872f01b30e6937008a6c352047a",
      "filename": "common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/netty/netty/blob/623d9d7202019a56457ffd02524c70ebc86958f2/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2Finternal%2FThreadLocalRandom.java",
      "raw_url": "https://github.com/netty/netty/raw/623d9d7202019a56457ffd02524c70ebc86958f2/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2Finternal%2FThreadLocalRandom.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2Finternal%2FThreadLocalRandom.java?ref=623d9d7202019a56457ffd02524c70ebc86958f2",
      "patch": "@@ -75,7 +75,7 @@ public final class ThreadLocalRandom extends Random {\n     static {\n         if (initialSeedUniquifier == 0) {\n             // Try to generate a real random number from /dev/random.\n-            // Get from a different thread to avoid blocking indefinitely on a machine without much entrophy.\n+            // Get from a different thread to avoid blocking indefinitely on a machine without much entropy.\n             seedGeneratorThread = new Thread(\"initialSeedUniquifierGenerator\") {\n                 @Override\n                 public void run() {\n@@ -156,7 +156,7 @@ public static long getInitialSeedUniquifier() {\n                     seedGeneratorThread.interrupt();\n                     logger.warn(\n                             \"Failed to generate a seed from SecureRandom within {} seconds. \" +\n-                            \"Not enough entrophy?\", timeoutSeconds\n+                            \"Not enough entropy?\", timeoutSeconds\n                     );\n                     break;\n                 }",
      "parent_sha": "94f65ed7ff214de3fc9680d80a5ec2d2fe2aaf48"
    }
  },
  {
    "oid": "f77891cc1786806630f6c4408d5d37abb1891e7b",
    "message": "We should prefer direct buffers if we can access the cleaner even if sun.misc.Unsafe is not present. (#8233)\n\nMotivation:\r\n\r\nWe should prefer direct buffers whenever we can use the cleaner even if sun.misc.Unsafe is not present.\r\n\r\nModifications:\r\n\r\nCorrectly prefer direct buffers in all cases.\r\n\r\nResult:\r\n\r\nMore correct code.",
    "date": "2018-08-29T06:21:07Z",
    "url": "https://github.com/netty/netty/commit/f77891cc1786806630f6c4408d5d37abb1891e7b",
    "details": {
      "sha": "6a534bcff0af65903029f7aac822469aaaff8f27",
      "filename": "common/src/main/java/io/netty/util/internal/PlatformDependent.java",
      "status": "modified",
      "additions": 8,
      "deletions": 5,
      "changes": 13,
      "blob_url": "https://github.com/netty/netty/blob/f77891cc1786806630f6c4408d5d37abb1891e7b/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2Finternal%2FPlatformDependent.java",
      "raw_url": "https://github.com/netty/netty/raw/f77891cc1786806630f6c4408d5d37abb1891e7b/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2Finternal%2FPlatformDependent.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2Finternal%2FPlatformDependent.java?ref=f77891cc1786806630f6c4408d5d37abb1891e7b",
      "patch": "@@ -79,8 +79,7 @@ public final class PlatformDependent {\n     private static final boolean CAN_ENABLE_TCP_NODELAY_BY_DEFAULT = !isAndroid();\n \n     private static final Throwable UNSAFE_UNAVAILABILITY_CAUSE = unsafeUnavailabilityCause0();\n-    private static final boolean DIRECT_BUFFER_PREFERRED =\n-            UNSAFE_UNAVAILABILITY_CAUSE == null && !SystemPropertyUtil.getBoolean(\"io.netty.noPreferDirect\", false);\n+    private static final boolean DIRECT_BUFFER_PREFERRED;\n     private static final long MAX_DIRECT_MEMORY = maxDirectMemory0();\n \n     private static final int MPSC_CHUNK_SIZE =  1024;\n@@ -128,9 +127,6 @@ public Random current() {\n                 }\n             };\n         }\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"-Dio.netty.noPreferDirect: {}\", !DIRECT_BUFFER_PREFERRED);\n-        }\n \n         /*\n          * We do not want to log this message if unsafe is explicitly disabled. Do not remove the explicit no unsafe\n@@ -190,6 +186,13 @@ public Random current() {\n         } else {\n             CLEANER = NOOP;\n         }\n+\n+        // We should always prefer direct buffers by default if we can use a Cleaner to release direct buffers.\n+        DIRECT_BUFFER_PREFERRED = CLEANER != NOOP\n+                                  && !SystemPropertyUtil.getBoolean(\"io.netty.noPreferDirect\", false);\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"-Dio.netty.noPreferDirect: {}\", !DIRECT_BUFFER_PREFERRED);\n+        }\n     }\n \n     public static boolean hasDirectBufferNoCleanerConstructor() {",
      "parent_sha": "8679c5ef43d285b22ae603965bb8254164f1570e"
    }
  },
  {
    "oid": "334b6c3129934570ddc375d2160a523a0679aaa6",
    "message": "Reduce the memory footprint of DefaultChannelPromise even more (part 2)\n\n- Rewirte DefaultChannelFutureListeners - this saves another int field when there are more then one listener.",
    "date": "2013-02-26T22:43:12Z",
    "url": "https://github.com/netty/netty/commit/334b6c3129934570ddc375d2160a523a0679aaa6",
    "details": {
      "sha": "d320fe63ddaf9a79317d8c222f43b55b77a8c9e9",
      "filename": "transport/src/main/java/io/netty/channel/DefaultChannelPromise.java",
      "status": "modified",
      "additions": 50,
      "deletions": 12,
      "changes": 62,
      "blob_url": "https://github.com/netty/netty/blob/334b6c3129934570ddc375d2160a523a0679aaa6/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FDefaultChannelPromise.java",
      "raw_url": "https://github.com/netty/netty/raw/334b6c3129934570ddc375d2160a523a0679aaa6/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FDefaultChannelPromise.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FDefaultChannelPromise.java?ref=334b6c3129934570ddc375d2160a523a0679aaa6",
      "patch": "@@ -20,7 +20,7 @@\n import io.netty.util.internal.InternalLogger;\n import io.netty.util.internal.InternalLoggerFactory;\n \n-import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.concurrent.TimeUnit;\n \n import static java.util.concurrent.TimeUnit.*;\n@@ -416,9 +416,7 @@ private void notifyListeners() {\n \n         if (channel().eventLoop().inEventLoop()) {\n             if (listeners instanceof DefaultChannelPromiseListeners) {\n-                for (ChannelFutureListener l : (DefaultChannelPromiseListeners) listeners) {\n-                    notifyListener0(this, l);\n-                }\n+                notifyListeners0(this, (DefaultChannelPromiseListeners) listeners);\n             } else {\n                 notifyListener0(this, (ChannelFutureListener) listeners);\n             }\n@@ -430,9 +428,7 @@ private void notifyListeners() {\n                 @Override\n                 public void run() {\n                     if (listeners instanceof DefaultChannelPromiseListeners) {\n-                        for (ChannelFutureListener l : (DefaultChannelPromiseListeners) listeners) {\n-                            notifyListener0(DefaultChannelPromise.this, l);\n-                        }\n+                        notifyListeners0(DefaultChannelPromise.this, (DefaultChannelPromiseListeners) listeners);\n                     } else {\n                         notifyListener0(DefaultChannelPromise.this, (ChannelFutureListener) listeners);\n                     }\n@@ -441,6 +437,14 @@ public void run() {\n         }\n     }\n \n+    private static void notifyListeners0(ChannelFuture f, DefaultChannelPromiseListeners listeners) {\n+        final ChannelFutureListener[] a = listeners.listeners();\n+        final int size = listeners.size();\n+        for (int i = 0; i < size; i ++) {\n+            notifyListener0(f, a[i]);\n+        }\n+    }\n+\n     static void notifyListener(final ChannelFuture f, final ChannelFutureListener l) {\n         EventLoop loop = f.channel().eventLoop();\n         if (loop.inEventLoop()) {\n@@ -514,13 +518,47 @@ ChannelPromise future() {\n         return this;\n     }\n \n-    private static final class DefaultChannelPromiseListeners extends ArrayList<ChannelFutureListener> {\n-        private static final long serialVersionUID = 7414281537694651180L;\n+    private static final class DefaultChannelPromiseListeners {\n+        private ChannelFutureListener[] listeners;\n+        private int size;\n \n         DefaultChannelPromiseListeners(ChannelFutureListener firstListener, ChannelFutureListener secondListener) {\n-            super(2);\n-            add(firstListener);\n-            add(secondListener);\n+            listeners = new ChannelFutureListener[] { firstListener, secondListener };\n+            size = 2;\n+        }\n+\n+        void add(ChannelFutureListener l) {\n+            ChannelFutureListener[] listeners = this.listeners;\n+            final int size = this.size;\n+            if (size == listeners.length) {\n+                this.listeners = listeners = Arrays.copyOf(listeners, size << 1);\n+            }\n+            listeners[size] = l;\n+            this.size = size + 1;\n+        }\n+\n+        void remove(ChannelFutureListener l) {\n+            final ChannelFutureListener[] listeners = this.listeners;\n+            int size = this.size;\n+            for (int i = 0; i < size; i ++) {\n+                if (listeners[i] == l) {\n+                    int listenersToMove = size - i - 1;\n+                    if (listenersToMove > 0) {\n+                        System.arraycopy(listeners, i + 1, listeners, i, listenersToMove);\n+                    }\n+                    listeners[-- size] = null;\n+                    this.size = size;\n+                    return;\n+                }\n+            }\n+        }\n+\n+        ChannelFutureListener[] listeners() {\n+            return listeners;\n+        }\n+\n+        int size() {\n+            return size;\n         }\n     }\n }",
      "parent_sha": "d8f55212100b6482bb3c760e1c5fb094a49990d3"
    }
  },
  {
    "oid": "d363f73fd831be950a2ba2e39b7f51df1cee0fea",
    "message": "Only increment the counter if the encode did not fail. See #256",
    "date": "2012-04-12T08:55:18Z",
    "url": "https://github.com/netty/netty/commit/d363f73fd831be950a2ba2e39b7f51df1cee0fea",
    "details": {
      "sha": "10404e8c16e0d11e09f53433d758e1f8dd34d0f5",
      "filename": "codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java",
      "status": "modified",
      "additions": 12,
      "deletions": 11,
      "changes": 23,
      "blob_url": "https://github.com/netty/netty/blob/d363f73fd831be950a2ba2e39b7f51df1cee0fea/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2FHttpClientCodec.java",
      "raw_url": "https://github.com/netty/netty/raw/d363f73fd831be950a2ba2e39b7f51df1cee0fea/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2FHttpClientCodec.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2FHttpClientCodec.java?ref=d363f73fd831be950a2ba2e39b7f51df1cee0fea",
      "patch": "@@ -95,21 +95,22 @@ private final class Encoder extends HttpRequestEncoder {\n         @Override\n         protected Object encode(ChannelHandlerContext ctx, Channel channel,\n                 Object msg) throws Exception {\n-            if (msg instanceof HttpRequest) {\n-                if (!done) {\n-                    queue.offer(((HttpRequest) msg).getMethod());\n-                }\n-                \n-                // check if the request is chunked if so do not increment\n-                if (!((HttpRequest) msg).isChunked()) {\n-                    requestResponseCounter.incrementAndGet();\n-                }\n+            if (msg instanceof HttpRequest && !done) {\n+                queue.offer(((HttpRequest) msg).getMethod());\n+            }\n+\n+            Object obj =  super.encode(ctx, channel, msg);\n+            \n+            // check if the request is chunked if so do not increment\n+            if (msg instanceof HttpRequest && !((HttpRequest) msg).isChunked()) {\n+                requestResponseCounter.incrementAndGet();\n             } else if (msg instanceof HttpChunk && ((HttpChunk) msg).isLast()) {\n                 // increment as its the last chunk\n                 requestResponseCounter.incrementAndGet();\n-                \n             }\n-            return super.encode(ctx, channel, msg);\n+            \n+            return obj;\n+        \n         }\n     }\n ",
      "parent_sha": "5ed04c3ada397d90f8d750175ed1d63ddc5bb86d"
    }
  },
  {
    "oid": "32c982b478229b888df03175ae6a48fb640a4511",
    "message": "Fix NPE in OioChildEventLoop",
    "date": "2012-05-31T08:19:54Z",
    "url": "https://github.com/netty/netty/commit/32c982b478229b888df03175ae6a48fb640a4511",
    "details": {
      "sha": "c3e3c07a007ab62363312ca89bbd13e1411844d9",
      "filename": "transport/src/main/java/io/netty/channel/socket/oio/OioChildEventLoop.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/netty/netty/blob/32c982b478229b888df03175ae6a48fb640a4511/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Fsocket%2Foio%2FOioChildEventLoop.java",
      "raw_url": "https://github.com/netty/netty/raw/32c982b478229b888df03175ae6a48fb640a4511/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Fsocket%2Foio%2FOioChildEventLoop.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2Fsocket%2Foio%2FOioChildEventLoop.java?ref=32c982b478229b888df03175ae6a48fb640a4511",
      "patch": "@@ -54,7 +54,9 @@ protected void run() {\n             }\n \n             if (isShutdown()) {\n-                ch.unsafe().close(ch.unsafe().voidFuture());\n+                if (ch != null) {\n+                    ch.unsafe().close(ch.unsafe().voidFuture());\n+                }\n                 if (peekTask() == null) {\n                     break;\n                 }",
      "parent_sha": "131eef2c5126be68030701cd9416ccbc14a9a2e6"
    }
  },
  {
    "oid": "8b2ed77042b5a3023974d7a6d2f22fc0d3edef34",
    "message": "Fix comment typo DelegatingDecompressorFrameListener (#10789)\n\nMotivation:\r\n`DelegatingDecompressorFrameListener#initDecompressor` has multiple dots `.` in comments. However, it should not have that.\r\n\r\nModification:\r\nRemoved multiple dots.\r\n\r\nResult:\r\nClean comment",
    "date": "2020-11-16T08:03:37Z",
    "url": "https://github.com/netty/netty/commit/8b2ed77042b5a3023974d7a6d2f22fc0d3edef34",
    "details": {
      "sha": "278b3afa02adcdcc73e5eedd622d545ea0265424",
      "filename": "codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/8b2ed77042b5a3023974d7a6d2f22fc0d3edef34/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FDelegatingDecompressorFrameListener.java",
      "raw_url": "https://github.com/netty/netty/raw/8b2ed77042b5a3023974d7a6d2f22fc0d3edef34/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FDelegatingDecompressorFrameListener.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FDelegatingDecompressorFrameListener.java?ref=8b2ed77042b5a3023974d7a6d2f22fc0d3edef34",
      "patch": "@@ -234,7 +234,7 @@ private void initDecompressor(ChannelHandlerContext ctx, int streamId, Http2Head\n         if (decompressor != null) {\n             // The content length will be for the compressed data. Since we will decompress the data\n             // this content-length will not be correct. Instead of queuing messages or delaying sending\n-            // header frames...just remove the content-length header\n+            // header frames just remove the content-length header.\n             headers.remove(CONTENT_LENGTH);\n \n             // The first time that we initialize a decompressor, decorate the local flow controller to",
      "parent_sha": "c717d4b97aa164a500098c6fb7b834535d13bf53"
    }
  },
  {
    "oid": "44add3c5255479eb0a6bdd266e53f50d11c76684",
    "message": "Log correct value for useCacheForAllThreads\n\nMotivation:\n\nLog about \"-Dio.netty.allocator.useCacheForAllThreads\" is missing log placeholder, and so can't output correct value.\n\nModification:\n\n- Add placeholder\n\nResult:\n\nFixes #6265 .",
    "date": "2017-01-25T07:01:23Z",
    "url": "https://github.com/netty/netty/commit/44add3c5255479eb0a6bdd266e53f50d11c76684",
    "details": {
      "sha": "8fd3491fe006476a847d894ebca5f906e962c9dc",
      "filename": "buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/44add3c5255479eb0a6bdd266e53f50d11c76684/buffer%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fbuffer%2FPooledByteBufAllocator.java",
      "raw_url": "https://github.com/netty/netty/raw/44add3c5255479eb0a6bdd266e53f50d11c76684/buffer%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fbuffer%2FPooledByteBufAllocator.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/buffer%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fbuffer%2FPooledByteBufAllocator.java?ref=44add3c5255479eb0a6bdd266e53f50d11c76684",
      "patch": "@@ -127,7 +127,7 @@ public class PooledByteBufAllocator extends AbstractByteBufAllocator {\n             logger.debug(\"-Dio.netty.allocator.normalCacheSize: {}\", DEFAULT_NORMAL_CACHE_SIZE);\n             logger.debug(\"-Dio.netty.allocator.maxCachedBufferCapacity: {}\", DEFAULT_MAX_CACHED_BUFFER_CAPACITY);\n             logger.debug(\"-Dio.netty.allocator.cacheTrimInterval: {}\", DEFAULT_CACHE_TRIM_INTERVAL);\n-            logger.debug(\"-Dio.netty.allocator.useCacheForAllThreads\", DEFAULT_USE_CACHE_FOR_ALL_THREADS);\n+            logger.debug(\"-Dio.netty.allocator.useCacheForAllThreads: {}\", DEFAULT_USE_CACHE_FOR_ALL_THREADS);\n         }\n     }\n ",
      "parent_sha": "9bec25a6eb491a3aa2b680d098113581bbc29bf1"
    }
  },
  {
    "oid": "dcd93e3be026a312939b5c895bcb484d25776f78",
    "message": "Remove volatile where not needed.\n\nMotivation:\n\nWe can remove the volatile keyword from the cached Runnables as at worse these will just be re-created.\n\nModifications:\n\nRemove volatile.\n\nResult:\n\nLess overhead.",
    "date": "2016-05-30T05:32:45Z",
    "url": "https://github.com/netty/netty/commit/dcd93e3be026a312939b5c895bcb484d25776f78",
    "details": {
      "sha": "c20331a55b97f69212230c1eb1536bd1931bc128",
      "filename": "transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java",
      "status": "modified",
      "additions": 5,
      "deletions": 6,
      "changes": 11,
      "blob_url": "https://github.com/netty/netty/blob/dcd93e3be026a312939b5c895bcb484d25776f78/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FAbstractChannelHandlerContext.java",
      "raw_url": "https://github.com/netty/netty/raw/dcd93e3be026a312939b5c895bcb484d25776f78/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FAbstractChannelHandlerContext.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/transport%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fchannel%2FAbstractChannelHandlerContext.java?ref=dcd93e3be026a312939b5c895bcb484d25776f78",
      "patch": "@@ -66,12 +66,11 @@ abstract class AbstractChannelHandlerContext extends DefaultAttributeMap\n     private int handlerState = INIT;\n \n     // Lazily instantiated tasks used to trigger events to a handler with different executor.\n-    // These needs to be volatile as otherwise an other Thread may see an half initialized instance.\n-    // See the JMM for more details\n-    private volatile Runnable invokeChannelReadCompleteTask;\n-    private volatile Runnable invokeReadTask;\n-    private volatile Runnable invokeChannelWritableStateChangedTask;\n-    private volatile Runnable invokeFlushTask;\n+    // There is no need to make this volatile as at worse it will just create a few more instances then needed.\n+    private Runnable invokeChannelReadCompleteTask;\n+    private Runnable invokeReadTask;\n+    private Runnable invokeChannelWritableStateChangedTask;\n+    private Runnable invokeFlushTask;\n \n     AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name,\n                                   boolean inbound, boolean outbound) {",
      "parent_sha": "528b83e27738af887955665a0ba82e081c7d8729"
    }
  },
  {
    "oid": "beb56878e415daa73132726662ec17381e1759ed",
    "message": "WIP. AutoBahn tests 6 working. Needed to check if final string is UTF-8 compliant.",
    "date": "2011-10-17T02:48:42Z",
    "url": "https://github.com/netty/netty/commit/beb56878e415daa73132726662ec17381e1759ed",
    "details": {
      "sha": "ba2c6fd4f64f7e547fa819814b7c9c27d7ea4c17",
      "filename": "src/main/java/org/jboss/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/netty/netty/blob/beb56878e415daa73132726662ec17381e1759ed/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2Fwebsocketx%2FWebSocket08FrameDecoder.java",
      "raw_url": "https://github.com/netty/netty/raw/beb56878e415daa73132726662ec17381e1759ed/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2Fwebsocketx%2FWebSocket08FrameDecoder.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2Fwebsocketx%2FWebSocket08FrameDecoder.java?ref=beb56878e415daa73132726662ec17381e1759ed",
      "patch": "@@ -205,7 +205,7 @@ protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffe\n \t\t\t} else {\n \t\t\t\tframePayloadLength = framePayloadLen1;\n \t\t\t}\n-\t\t\t\n+\n \t\t\tlogger.debug(\"Frame length =\" + framePayloadLength);\n \t\t\tcheckpoint(State.MASKING_KEY);\n \t\tcase MASKING_KEY:\n@@ -265,13 +265,13 @@ protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffe\n \n \t\t\t\t\t// Check text for UTF8 correctness\n \t\t\t\t\tif (frameOpcode == OPCODE_TEXT || fragmentedFramesText != null) {\n+\t\t\t\t\t\t// Check UTF-8 correctness for this payload\n \t\t\t\t\t\tcheckUTF8String(channel, framePayload.array());\n-\t\t\t\t\t}\n \n-\t\t\t\t\t// If final frame in a fragmented message, then set\n-\t\t\t\t\t// aggregated text so it can be returned\n-\t\t\t\t\tif (fragmentedFramesText != null) {\n+\t\t\t\t\t\t// This does a second check to make sure UTF-8\n+\t\t\t\t\t\t// correctness for entire text message\n \t\t\t\t\t\taggregatedText = fragmentedFramesText.toString();\n+\n \t\t\t\t\t\tfragmentedFramesText = null;\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -348,13 +348,13 @@ private int toFrameLength(long l) throws TooLongFrameException {\n \n \tprivate void checkUTF8String(Channel channel, byte[] bytes) throws CorruptedFrameException {\n \t\ttry {\n-\t\t\t\n+\n \t\t\tStringBuilder sb = new StringBuilder(\"UTF8 \" + bytes.length + \" bytes: \");\n \t\t\tfor (byte b : bytes) {\n \t\t\t\tsb.append(Integer.toHexString(b)).append(\" \");\n \t\t\t}\n \t\t\tlogger.debug(sb.toString());\n-\t\t\t\n+\n \t\t\tif (fragmentedFramesText == null) {\n \t\t\t\tfragmentedFramesText = new UTF8Output(bytes);\n \t\t\t} else {",
      "parent_sha": "234952a516636af734a40180423cce352df903ec"
    }
  },
  {
    "oid": "00fbf2a2f34469884597c8eee6e8a94edb930f2a",
    "message": "Resource should be released in HttpClient example",
    "date": "2008-11-27T01:11:53Z",
    "url": "https://github.com/netty/netty/commit/00fbf2a2f34469884597c8eee6e8a94edb930f2a",
    "details": {
      "sha": "b551e5360dea72139d9082781e4a4077027f2fa8",
      "filename": "src/main/java/org/jboss/netty/example/http/HttpClient.java",
      "status": "modified",
      "additions": 7,
      "deletions": 2,
      "changes": 9,
      "blob_url": "https://github.com/netty/netty/blob/00fbf2a2f34469884597c8eee6e8a94edb930f2a/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fexample%2Fhttp%2FHttpClient.java",
      "raw_url": "https://github.com/netty/netty/raw/00fbf2a2f34469884597c8eee6e8a94edb930f2a/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fexample%2Fhttp%2FHttpClient.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fexample%2Fhttp%2FHttpClient.java?ref=00fbf2a2f34469884597c8eee6e8a94edb930f2a",
      "patch": "@@ -87,7 +87,12 @@ public static void main(String[] args) throws Exception {\n         // Send the HTTP request.\n         HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_0, HttpMethod.GET, uri);\n         request.addHeader(HttpHeaders.HOST, host);\n-        ChannelFuture lastWriteFuture = channel.write(request);\n-        lastWriteFuture.awaitUninterruptibly();\n+        channel.write(request);\n+\n+        // Wait for the server to close the connection.\n+        channel.getCloseFuture().awaitUninterruptibly();\n+\n+        // Shut down executor threads to exit.\n+        factory.getExternalResource().release();\n     }\n }\n\\ No newline at end of file",
      "parent_sha": "7a8754302089c3996b8d43dbfbe01d1f5bf29ac8"
    }
  },
  {
    "oid": "8df9dd7dda2d04a3478d414f34a694aec7515dde",
    "message": "Work around the system configuration issue that causes NioSocketChannelTest to fail\n\nMotivation:\n\nOn some ill-configured systems, InetAddress.getLocalHost() fails.  NioSocketChannelTest calls java.net.Socket.connect() and it internally invoked InetAddress.getLocalHost(), which causes the test failures in NioSocketChannelTes on such an ill-configured system.\n\nModifications:\n\nUse NetUtil.LOCALHOST explicitly.\n\nResult:\n\nNioSocketChannelTest should not fail anymore.",
    "date": "2014-05-28T00:40:49Z",
    "url": "https://github.com/netty/netty/commit/8df9dd7dda2d04a3478d414f34a694aec7515dde",
    "details": {
      "sha": "3d5b47dfd4a9f2c40e014a6e0ad484e98c12f2a9",
      "filename": "transport/src/test/java/io/netty/channel/nio/NioSocketChannelTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/netty/netty/blob/8df9dd7dda2d04a3478d414f34a694aec7515dde/transport%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fchannel%2Fnio%2FNioSocketChannelTest.java",
      "raw_url": "https://github.com/netty/netty/raw/8df9dd7dda2d04a3478d414f34a694aec7515dde/transport%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fchannel%2Fnio%2FNioSocketChannelTest.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/transport%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Fchannel%2Fnio%2FNioSocketChannelTest.java?ref=8df9dd7dda2d04a3478d414f34a694aec7515dde",
      "patch": "@@ -24,11 +24,13 @@\n import io.netty.channel.ChannelOption;\n import io.netty.channel.socket.nio.NioServerSocketChannel;\n import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n import org.junit.Test;\n \n import java.io.DataInput;\n import java.io.DataInputStream;\n import java.io.InputStream;\n+import java.net.InetSocketAddress;\n import java.net.Socket;\n import java.net.SocketAddress;\n import java.nio.channels.ClosedChannelException;\n@@ -68,8 +70,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {\n \n             SocketAddress address = sb.bind(0).sync().channel().localAddress();\n \n-            Socket s = new Socket();\n-            s.connect(address);\n+            Socket s = new Socket(NetUtil.LOCALHOST, ((InetSocketAddress) address).getPort());\n \n             InputStream in = s.getInputStream();\n             byte[] buf = new byte[8192];\n@@ -127,8 +128,7 @@ public void operationComplete(ChannelFuture future) throws Exception {\n \n             SocketAddress address = sb.bind(0).sync().channel().localAddress();\n \n-            Socket s = new Socket();\n-            s.connect(address);\n+            Socket s = new Socket(NetUtil.LOCALHOST, ((InetSocketAddress) address).getPort());\n \n             DataInput in = new DataInputStream(s.getInputStream());\n             byte[] buf = new byte[3];",
      "parent_sha": "c5112ed55210afcbb263397b37c0031983b883db"
    }
  },
  {
    "oid": "5ebdee8537a3c953582351212b0b53c16f40b613",
    "message": "Always log Http2UnknownStreamError at `DEBUG` level (#11643)\n\nMotivation:\r\n\r\nException logged by `onHttp2UnknownStreamError` is propagated to the\r\nupper layers anyway. Receiver of the exception is responsible for\r\ncorrect handling. Inside netty, it's enough to log at `DEBUG` level.\r\n\r\nModifications:\r\n\r\n- `Http2FrameCodec#onHttp2UnknownStreamError` always logs at `DEBUG`\r\nlevel;\r\n\r\nResult:\r\n\r\nLess noise in logs when `Http2UnknownStreamError` is properly handled by\r\nupper layers.\r\n\r\nCo-authored-by: Norman Maurer <norman_maurer@apple.com>\r\nCo-authored-by: Chris Vest <mr.chrisvest@gmail.com>",
    "date": "2021-09-02T17:11:46Z",
    "url": "https://github.com/netty/netty/commit/5ebdee8537a3c953582351212b0b53c16f40b613",
    "details": {
      "sha": "302ff08208697abd89b39592886fcbcb5fc1b5cf",
      "filename": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/netty/netty/blob/5ebdee8537a3c953582351212b0b53c16f40b613/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FHttp2FrameCodec.java",
      "raw_url": "https://github.com/netty/netty/raw/5ebdee8537a3c953582351212b0b53c16f40b613/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FHttp2FrameCodec.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FHttp2FrameCodec.java?ref=5ebdee8537a3c953582351212b0b53c16f40b613",
      "patch": "@@ -33,14 +33,14 @@\n import io.netty.util.collection.IntObjectHashMap;\n import io.netty.util.collection.IntObjectMap;\n import io.netty.util.internal.UnstableApi;\n-import io.netty.util.internal.logging.InternalLogLevel;\n import io.netty.util.internal.logging.InternalLogger;\n import io.netty.util.internal.logging.InternalLoggerFactory;\n \n import static io.netty.buffer.ByteBufUtil.writeAscii;\n import static io.netty.handler.codec.http2.Http2CodecUtil.HTTP_UPGRADE_STREAM_ID;\n import static io.netty.handler.codec.http2.Http2CodecUtil.isStreamIdValid;\n import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;\n+import static io.netty.util.internal.logging.InternalLogLevel.DEBUG;\n \n /**\n  * <p><em>This API is very immature.</em> The Http2Connection-based API is currently preferred over this API.\n@@ -569,14 +569,14 @@ protected final void onStreamError(ChannelHandlerContext ctx, boolean outbound,\n         }\n     }\n \n-    private void onHttp2UnknownStreamError(@SuppressWarnings(\"unused\") ChannelHandlerContext ctx, Throwable cause,\n-                                           Http2Exception.StreamException streamException) {\n-        // It is normal to hit a race condition where we still receive frames for a stream that this\n-        // peer has deemed closed, such as if this peer sends a RST(CANCEL) to discard the request.\n-        // Since this is likely to be normal we log at DEBUG level.\n-        InternalLogLevel level =\n-                streamException.error() == Http2Error.STREAM_CLOSED ? InternalLogLevel.DEBUG : InternalLogLevel.WARN;\n-        LOG.log(level, \"Stream exception thrown for unknown stream {}.\", streamException.streamId(), cause);\n+    private static void onHttp2UnknownStreamError(@SuppressWarnings(\"unused\") ChannelHandlerContext ctx,\n+            Throwable cause, Http2Exception.StreamException streamException) {\n+        // We log here for debugging purposes. This exception will be propagated to the upper layers through other ways:\n+        // - fireExceptionCaught\n+        // - fireUserEventTriggered(Http2ResetFrame), see Http2MultiplexHandler#channelRead(...)\n+        // - by failing write promise\n+        // Receiver of the error is responsible for correct handling of this exception.\n+        LOG.log(DEBUG, \"Stream exception thrown for unknown stream {}.\", streamException.streamId(), cause);\n     }\n \n     @Override",
      "parent_sha": "c8c45cfa4c9632578a772ebcad1edfae431b1011"
    }
  },
  {
    "oid": "445be963ae861e5e2474422ff54db4272fb39a3e",
    "message": "Oops.  Silly mistake when creating a new string builder",
    "date": "2009-03-10T07:57:36Z",
    "url": "https://github.com/netty/netty/commit/445be963ae861e5e2474422ff54db4272fb39a3e",
    "details": {
      "sha": "2af85340b1aa6fa3ee61d6323d07debbdbf72024",
      "filename": "src/main/java/org/jboss/netty/handler/codec/http/HttpResponseStatus.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/445be963ae861e5e2474422ff54db4272fb39a3e/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2FHttpResponseStatus.java",
      "raw_url": "https://github.com/netty/netty/raw/445be963ae861e5e2474422ff54db4272fb39a3e/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2FHttpResponseStatus.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/src%2Fmain%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2FHttpResponseStatus.java?ref=445be963ae861e5e2474422ff54db4272fb39a3e",
      "patch": "@@ -152,7 +152,7 @@ public int compareTo(HttpResponseStatus o) {\n \n     @Override\n     public String toString() {\n-        StringBuilder buf = new StringBuilder(reasonPhrase + 5);\n+        StringBuilder buf = new StringBuilder(reasonPhrase.length() + 5);\n         buf.append(code);\n         buf.append(' ');\n         buf.append(reasonPhrase);",
      "parent_sha": "3235c154a31ad7e682a48ad575f6c14c8aa38689"
    }
  },
  {
    "oid": "c1d0fd2dbf7907a99ab702795e35d9de8068c1cb",
    "message": "Make /etc/resolv.conf reading more robust (#13951)\n\nMotivation:\r\nIt is possible that /etc/resolv.conf is missing or cannot be read, in\r\nwhich case `ResolvConf.system()` will throw an exception. We need to\r\nhandle that exception in `DefaultDnsServerAddressStreamProvider`, since\r\nexceptions thrown from a static initializer can become\r\n`NoClassDefFoundError`.\r\n\r\nModification:\r\nCatch the exception that `ResolvConf.system()` might throw, an fall back\r\nto JNDI in that case.\r\n\r\nResult:\r\nNo more `NoClassDefFoundError` being thrown when `/etc/resolv.conf`\r\ncannot be read for any reason.\r\n\r\nFixes #13949",
    "date": "2024-04-05T15:41:51Z",
    "url": "https://github.com/netty/netty/commit/c1d0fd2dbf7907a99ab702795e35d9de8068c1cb",
    "details": {
      "sha": "4b374d103bea0a573db819df61eae712faaaa0f9",
      "filename": "resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java",
      "status": "modified",
      "additions": 14,
      "deletions": 3,
      "changes": 17,
      "blob_url": "https://github.com/netty/netty/blob/c1d0fd2dbf7907a99ab702795e35d9de8068c1cb/resolver-dns%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fresolver%2Fdns%2FDefaultDnsServerAddressStreamProvider.java",
      "raw_url": "https://github.com/netty/netty/raw/c1d0fd2dbf7907a99ab702795e35d9de8068c1cb/resolver-dns%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fresolver%2Fdns%2FDefaultDnsServerAddressStreamProvider.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/resolver-dns%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fresolver%2Fdns%2FDefaultDnsServerAddressStreamProvider.java?ref=c1d0fd2dbf7907a99ab702795e35d9de8068c1cb",
      "patch": "@@ -50,11 +50,22 @@ public final class DefaultDnsServerAddressStreamProvider implements DnsServerAdd\n     static {\n         final List<InetSocketAddress> defaultNameServers = new ArrayList<InetSocketAddress>(2);\n         if (!PlatformDependent.isAndroid()) {\n-            // Only try to use when not on Android as the classes not exists there:\n+            // Skip this on Android; it has neither /etc/resolv.conf nor JNDI classes.\n             // See https://github.com/netty/netty/issues/8654\n             if (!PlatformDependent.isWindows()) {\n-                // /etc/resolv.conf exists on Linux + macOS, but not on Android\n-                defaultNameServers.addAll(ResolvConf.system().getNameservers());\n+                // Try reading /etc/resolv.conf. It's usually found on Linux or macOS, but can also be missing.\n+                try {\n+                    defaultNameServers.addAll(ResolvConf.system().getNameservers());\n+                } catch (IllegalStateException e) {\n+                    String fallbackMessage = \"Failed to get name servers from /etc/resolv.conf; will fall back to JNDI\";\n+                    if (logger.isDebugEnabled()) {\n+                        // Always log at INFO, but only include stack trace if DEBUG is enabled.\n+                        logger.info(fallbackMessage, e);\n+                    } else {\n+                        logger.info(fallbackMessage);\n+                    }\n+                    DirContextUtils.addNameServers(defaultNameServers, DNS_PORT);\n+                }\n             } else {\n                 DirContextUtils.addNameServers(defaultNameServers, DNS_PORT);\n             }",
      "parent_sha": "b0e43847a8c78325ea7dd8bb02934ed6c690cb9c"
    }
  },
  {
    "oid": "4f172c13bb25323894e45e3716e049809da14905",
    "message": "Add deprecation to Http2StreamChannelBootstrap.open0(...) as it was marked as public by mistake (#9372)\n\nMotivation:\r\n\r\nMark Http2StreamChannelBootstrap.open0(...) as deprecated as the user should not use it. It was marked as public by mistake.\r\n\r\nModifications:\r\n\r\nAdd deprecation warning.\r\n\r\nResult:\r\n\r\nUser will be aware the method should not be used directly.",
    "date": "2019-07-16T11:08:09Z",
    "url": "https://github.com/netty/netty/commit/4f172c13bb25323894e45e3716e049809da14905",
    "details": {
      "sha": "a8f185524a6129786fb9e08f83482affbf10eba7",
      "filename": "codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamChannelBootstrap.java",
      "status": "modified",
      "additions": 17,
      "deletions": 5,
      "changes": 22,
      "blob_url": "https://github.com/netty/netty/blob/4f172c13bb25323894e45e3716e049809da14905/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FHttp2StreamChannelBootstrap.java",
      "raw_url": "https://github.com/netty/netty/raw/4f172c13bb25323894e45e3716e049809da14905/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FHttp2StreamChannelBootstrap.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FHttp2StreamChannelBootstrap.java?ref=4f172c13bb25323894e45e3716e049809da14905",
      "patch": "@@ -94,16 +94,24 @@ public <T> Http2StreamChannelBootstrap attr(AttributeKey<T> key, T value) {\n     /**\n      * the {@link ChannelHandler} to use for serving the requests.\n      */\n-    @SuppressWarnings(\"unchecked\")\n     public Http2StreamChannelBootstrap handler(ChannelHandler handler) {\n         this.handler = ObjectUtil.checkNotNull(handler, \"handler\");\n         return this;\n     }\n \n+    /**\n+     * Open a new {@link Http2StreamChannel} to use.\n+     * @return the {@link Future} that will be notified once the channel was opened successfully or it failed.\n+     */\n     public Future<Http2StreamChannel> open() {\n         return open(channel.eventLoop().<Http2StreamChannel>newPromise());\n     }\n \n+    /**\n+     * Open a new {@link Http2StreamChannel} to use and notifies the given {@link Promise}.\n+     * @return the {@link Future} that will be notified once the channel was opened successfully or it failed.\n+     */\n+    @SuppressWarnings(\"deprecation\")\n     public Future<Http2StreamChannel> open(final Promise<Http2StreamChannel> promise) {\n         ChannelHandlerContext ctx = channel.pipeline().context(Http2MultiplexCodec.class);\n         if (ctx == null) {\n@@ -133,6 +141,10 @@ public void run() {\n         return promise;\n     }\n \n+    /**\n+     * @deprecated should not be used directly. Use {@link #open()} or {@link #open(Promise)}\n+      */\n+    @Deprecated\n     public void open0(ChannelHandlerContext ctx, final Promise<Http2StreamChannel> promise) {\n         assert ctx.executor().inEventLoop();\n         final Http2StreamChannel streamChannel;\n@@ -178,7 +190,7 @@ private void init(Channel channel) throws Exception {\n             p.addLast(handler);\n         }\n         synchronized (options) {\n-            setChannelOptions(channel, options, logger);\n+            setChannelOptions(channel, options);\n         }\n \n         synchronized (attrs) {\n@@ -189,15 +201,15 @@ private void init(Channel channel) throws Exception {\n     }\n \n     private static void setChannelOptions(\n-            Channel channel, Map<ChannelOption<?>, Object> options, InternalLogger logger) {\n+            Channel channel, Map<ChannelOption<?>, Object> options) {\n         for (Map.Entry<ChannelOption<?>, Object> e: options.entrySet()) {\n-            setChannelOption(channel, e.getKey(), e.getValue(), logger);\n+            setChannelOption(channel, e.getKey(), e.getValue());\n         }\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     private static void setChannelOption(\n-            Channel channel, ChannelOption<?> option, Object value, InternalLogger logger) {\n+            Channel channel, ChannelOption<?> option, Object value) {\n         try {\n             if (!channel.config().setOption((ChannelOption<Object>) option, value)) {\n                 logger.warn(\"Unknown channel option '{}' for channel '{}'\", option, channel);",
      "parent_sha": "906fc02b3f62c1217405699b42c559803edafe82"
    }
  },
  {
    "oid": "e53738f38c8e23cae301c6b0b72f931e812ebaa6",
    "message": "Less confusing leak warning message",
    "date": "2013-07-17T12:29:03Z",
    "url": "https://github.com/netty/netty/commit/e53738f38c8e23cae301c6b0b72f931e812ebaa6",
    "details": {
      "sha": "cc4df09f709623e78ef036eec7a1a97d5caf15e2",
      "filename": "common/src/main/java/io/netty/util/ResourceLeakDetector.java",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/netty/netty/blob/e53738f38c8e23cae301c6b0b72f931e812ebaa6/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2FResourceLeakDetector.java",
      "raw_url": "https://github.com/netty/netty/raw/e53738f38c8e23cae301c6b0b72f931e812ebaa6/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2FResourceLeakDetector.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2FResourceLeakDetector.java?ref=e53738f38c8e23cae301c6b0b72f931e812ebaa6",
      "patch": "@@ -139,7 +139,10 @@ private void reportLeak() {\n             }\n \n             if (reportedLeaks.putIfAbsent(ref.exception, Boolean.TRUE) == null) {\n-                logger.warn(\"LEAK: \" + resourceType + \" was GC'd before being released correctly.\", ref.exception);\n+                logger.warn(\n+                        \"LEAK: \" + resourceType + \" was GC'd before being released correctly.  \" +\n+                        \"The following stack trace shows where the leaked object was created, \" +\n+                        \"rather than who failed to release it where.\", ref.exception);\n             }\n         }\n     }",
      "parent_sha": "88cbdb50d2e77c5e1f1f900b85af32d3216925b5"
    }
  },
  {
    "oid": "dc61906620068c5b49f417b5beba5ce35c2386a9",
    "message": "Fixed test failures",
    "date": "2009-03-13T15:53:52Z",
    "url": "https://github.com/netty/netty/commit/dc61906620068c5b49f417b5beba5ce35c2386a9",
    "details": {
      "sha": "d40886340a59f876ce6b364fe03634fd4f83fd1c",
      "filename": "src/test/java/org/jboss/netty/handler/codec/http/CookieEncoderTest.java",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/netty/netty/blob/dc61906620068c5b49f417b5beba5ce35c2386a9/src%2Ftest%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2FCookieEncoderTest.java",
      "raw_url": "https://github.com/netty/netty/raw/dc61906620068c5b49f417b5beba5ce35c2386a9/src%2Ftest%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2FCookieEncoderTest.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/src%2Ftest%2Fjava%2Forg%2Fjboss%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2FCookieEncoderTest.java?ref=dc61906620068c5b49f417b5beba5ce35c2386a9",
      "patch": "@@ -37,11 +37,11 @@\n public class CookieEncoderTest {\n     @Test\n     public void testEncodingSingleCookieV0() {\n-        String result = \"myCookie=myValue;expires=XXX;path=/apathsomewhere;domain=.adomainsomewhere;secure\";\n+        String result = \"myCookie=myValue;Expires=XXX;Path=/apathsomewhere;Domain=.adomainsomewhere;Secure\";\n         Cookie cookie = new DefaultCookie(\"myCookie\", \"myValue\");\n         CookieEncoder encoder = new CookieEncoder(true);\n         encoder.addCookie(cookie);\n-        cookie.setComment(\"this is a comment\");\n+        cookie.setComment(\"this is a Comment\");\n         cookie.setCommentUrl(\"http://aurl.com\");\n         cookie.setDomain(\".adomainsomewhere\");\n         cookie.setDiscard(true);\n@@ -55,12 +55,12 @@ public void testEncodingSingleCookieV0() {\n     }\n     @Test\n     public void testEncodingSingleCookieV1() {\n-        String result = \"myCookie=myValue;max-age=50;path=/apathsomewhere;domain=.adomainsomewhere;secure;comment=this is a comment;version=1\";\n+        String result = \"myCookie=myValue;Max-Age=50;Path=/apathsomewhere;Domain=.adomainsomewhere;Secure;Comment=this is a Comment;Version=1\";\n         Cookie cookie = new DefaultCookie(\"myCookie\", \"myValue\");\n         CookieEncoder encoder = new CookieEncoder(true);\n         encoder.addCookie(cookie);\n         cookie.setVersion(1);\n-        cookie.setComment(\"this is a comment\");\n+        cookie.setComment(\"this is a Comment\");\n         cookie.setDomain(\".adomainsomewhere\");\n         cookie.setMaxAge(50);\n         cookie.setPath(\"/apathsomewhere\");\n@@ -70,12 +70,12 @@ public void testEncodingSingleCookieV1() {\n     }\n     @Test\n     public void testEncodingSingleCookieV2() {\n-        String result = \"myCookie=myValue;max-age=50;path=/apathsomewhere;domain=.adomainsomewhere;secure;comment=this is a comment;version=1;commentURL=\\\"http://aurl.com\\\";port=\\\"80,8080\\\";discard\";\n+        String result = \"myCookie=myValue;Max-Age=50;Path=/apathsomewhere;Domain=.adomainsomewhere;Secure;Comment=this is a Comment;Version=1;CommentURL=\\\"http://aurl.com\\\";Port=\\\"80,8080\\\";Discard\";\n         Cookie cookie = new DefaultCookie(\"myCookie\", \"myValue\");\n         CookieEncoder encoder = new CookieEncoder(true);\n         encoder.addCookie(cookie);\n         cookie.setVersion(1);\n-        cookie.setComment(\"this is a comment\");\n+        cookie.setComment(\"this is a Comment\");\n         cookie.setCommentUrl(\"http://aurl.com\");\n         cookie.setDomain(\".adomainsomewhere\");\n         cookie.setDiscard(true);\n@@ -89,13 +89,13 @@ public void testEncodingSingleCookieV2() {\n \n     @Test\n     public void testEncodingMultipleCookies() {\n-        String c1 = \"myCookie=myValue;max-age=50;path=/apathsomewhere;domain=.adomainsomewhere;secure;comment=this is a comment;version=1;commentURL=\\\"http://aurl.com\\\";port=\\\"80,8080\\\";discard;\";\n-        String c2 = \"myCookie2=myValue2;path=/anotherpathsomewhere;domain=.anotherdomainsomewhere;comment=this is another comment;version=1;commentURL=\\\"http://anotherurl.com\\\";\";\n-        String c3 = \"myCookie3=myValue3;version=1\";\n+        String c1 = \"myCookie=myValue;Max-Age=50;Path=/apathsomewhere;Domain=.adomainsomewhere;Secure;Comment=this is a Comment;Version=1;CommentURL=\\\"http://aurl.com\\\";Port=\\\"80,8080\\\";Discard;\";\n+        String c2 = \"myCookie2=myValue2;Path=/anotherpathsomewhere;Domain=.anotherdomainsomewhere;Comment=this is another Comment;Version=1;CommentURL=\\\"http://anotherurl.com\\\";\";\n+        String c3 = \"myCookie3=myValue3;Version=1\";\n         CookieEncoder encoder = new CookieEncoder(true);\n         Cookie cookie = new DefaultCookie(\"myCookie\", \"myValue\");\n         cookie.setVersion(1);\n-        cookie.setComment(\"this is a comment\");\n+        cookie.setComment(\"this is a Comment\");\n         cookie.setCommentUrl(\"http://aurl.com\");\n         cookie.setDomain(\".adomainsomewhere\");\n         cookie.setDiscard(true);\n@@ -106,7 +106,7 @@ public void testEncodingMultipleCookies() {\n         encoder.addCookie(cookie);\n         Cookie cookie2 = new DefaultCookie(\"myCookie2\", \"myValue2\");\n         cookie2.setVersion(1);\n-        cookie2.setComment(\"this is another comment\");\n+        cookie2.setComment(\"this is another Comment\");\n         cookie2.setCommentUrl(\"http://anotherurl.com\");\n         cookie2.setDomain(\".anotherdomainsomewhere\");\n         cookie2.setDiscard(false);",
      "parent_sha": "bbf32cae515ec8845f4fa24f467e11194f638d08"
    }
  },
  {
    "oid": "11fdec3c4a740a84796f2b78ac302c87044a4080",
    "message": "Log the time taken for generating the initialSeedUniquifier\n\n- Sometimes useful to know it how long it takes from the log, to make\n  sure it's not something else that is blocking.",
    "date": "2014-07-04T04:26:58Z",
    "url": "https://github.com/netty/netty/commit/11fdec3c4a740a84796f2b78ac302c87044a4080",
    "details": {
      "sha": "7fa15aa62739f71895bb216f9a1ff57366a658b0",
      "filename": "common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/netty/netty/blob/11fdec3c4a740a84796f2b78ac302c87044a4080/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2Finternal%2FThreadLocalRandom.java",
      "raw_url": "https://github.com/netty/netty/raw/11fdec3c4a740a84796f2b78ac302c87044a4080/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2Finternal%2FThreadLocalRandom.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/common%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Futil%2Finternal%2FThreadLocalRandom.java?ref=11fdec3c4a740a84796f2b78ac302c87044a4080",
      "patch": "@@ -156,6 +156,7 @@ public void uncaughtException(Thread t, Throwable e) {\n     }\n \n     private static long newSeed() {\n+        final long startTime = System.nanoTime();\n         for (;;) {\n             final long current = seedUniquifier.get();\n             final long actualCurrent = current != 0? current : getInitialSeedUniquifier();\n@@ -165,7 +166,9 @@ private static long newSeed() {\n \n             if (seedUniquifier.compareAndSet(current, next)) {\n                 if (current == 0 && logger.isDebugEnabled()) {\n-                    logger.debug(String.format(\"-Dio.netty.initialSeedUniquifier: 0x%016x\", actualCurrent));\n+                    logger.debug(String.format(\n+                            \"-Dio.netty.initialSeedUniquifier: 0x%016x (took %d ms)\",\n+                            actualCurrent, TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)));\n                 }\n                 return next ^ System.nanoTime();\n             }",
      "parent_sha": "cde7157c3998cf6e7d773c861cd0d6b2a406da32"
    }
  },
  {
    "oid": "b09962f4c26c5231523584f82fc6cf86fb687970",
    "message": "forgot 1 more change",
    "date": "2012-05-12T11:22:33Z",
    "url": "https://github.com/netty/netty/commit/b09962f4c26c5231523584f82fc6cf86fb687970",
    "details": {
      "sha": "2dfd44b670f80aa148e81ee8fee4e348aea60ace",
      "filename": "codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/b09962f4c26c5231523584f82fc6cf86fb687970/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2Fwebsocketx%2FWebSocketClientHandshaker.java",
      "raw_url": "https://github.com/netty/netty/raw/b09962f4c26c5231523584f82fc6cf86fb687970/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2Fwebsocketx%2FWebSocketClientHandshaker.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-http%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp%2Fwebsocketx%2FWebSocketClientHandshaker.java?ref=b09962f4c26c5231523584f82fc6cf86fb687970",
      "patch": "@@ -35,7 +35,7 @@ public abstract class WebSocketClientHandshaker {\n \n     private final String expectedSubprotocol;\n \n-    private String actualSubprotocol;\n+    private String actualSubprotocol = null;\n \n     protected final Map<String, String> customHeaders;\n ",
      "parent_sha": "abd10d9089bb40dc75b067bdfe90a9befbfbe694"
    }
  },
  {
    "oid": "b1436e80ef2b39049c0fcb1a963b6541bac7a5a9",
    "message": "Cleanup DefaultHttp2FrameReader about verifyUnknownFrame\n\nMotivation:\n\nIn previous PR about handling unknwon frame in the middle of header\nblock, I didn't notice and re-use about checking is processing header\n. And I added a redundant method for same functionality.\nI think that the redundant method would lead to some misleading\nsituation.\n\nModifications:\n\nRemoved redundant code on DefaultHttp2FrameReader\n\nResult:\n\nThe code is more readable",
    "date": "2017-02-21T06:12:20Z",
    "url": "https://github.com/netty/netty/commit/b1436e80ef2b39049c0fcb1a963b6541bac7a5a9",
    "details": {
      "sha": "48de2f35a958e2bb1bdd0228dd1d83b8d6cdf371",
      "filename": "codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/netty/netty/blob/b1436e80ef2b39049c0fcb1a963b6541bac7a5a9/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FDefaultHttp2FrameReader.java",
      "raw_url": "https://github.com/netty/netty/raw/b1436e80ef2b39049c0fcb1a963b6541bac7a5a9/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FDefaultHttp2FrameReader.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/codec-http2%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fhandler%2Fcodec%2Fhttp2%2FDefaultHttp2FrameReader.java?ref=b1436e80ef2b39049c0fcb1a963b6541bac7a5a9",
      "patch": "@@ -227,6 +227,7 @@ private void processHeaderState(ByteBuf in) throws Http2Exception {\n                 break;\n             default:\n                 // Unknown frame type, could be an extension.\n+                verifyUnknownFrame();\n                 break;\n         }\n     }\n@@ -404,12 +405,7 @@ private void verifyContinuationFrame() throws Http2Exception {\n     }\n \n     private void verifyUnknownFrame() throws Http2Exception {\n-        if (headersContinuation != null) {\n-            int streamId = headersContinuation.getStreamId();\n-            closeHeadersContinuation();\n-            throw connectionError(PROTOCOL_ERROR, \"Extension frames must not be in the middle of headers \"\n-                    + \"on stream %d\", streamId);\n-        }\n+        verifyNotProcessingHeaders();\n     }\n \n     private void readDataFrame(ChannelHandlerContext ctx, ByteBuf payload,\n@@ -617,7 +613,6 @@ private void readContinuationFrame(ByteBuf payload, Http2FrameListener listener)\n \n     private void readUnknownFrame(ChannelHandlerContext ctx, ByteBuf payload, Http2FrameListener listener)\n             throws Http2Exception {\n-        verifyUnknownFrame();\n         payload = payload.readSlice(payload.readableBytes());\n         listener.onUnknownFrame(ctx, frameType, streamId, flags, payload);\n     }\n@@ -768,9 +763,14 @@ void close() {\n         }\n     }\n \n+    /**\n+     * Verify that current state is not processing on header block\n+     * @throws Http2Exception thrown if {@link #headersContinuation} is not null\n+     */\n     private void verifyNotProcessingHeaders() throws Http2Exception {\n         if (headersContinuation != null) {\n-            throw connectionError(PROTOCOL_ERROR, \"Received frame of type %s while processing headers.\", frameType);\n+            throw connectionError(PROTOCOL_ERROR, \"Received frame of type %s while processing headers on stream %d.\",\n+                                  frameType, headersContinuation.getStreamId());\n         }\n     }\n ",
      "parent_sha": "e08a3b1f3570c930592540e6391bb52f2f2da7f2"
    }
  },
  {
    "oid": "c6d61f9b43d89dc280b6089dee674daa8c180146",
    "message": "Fix merge issue introduced by 04c0d77\n\nMotiviation:\nInterface changes between master and 4.1 branch resulted in a compile failure.\n\nModifications:\n- change messageReceived to channelRead0\n\nResult:\nNo more compile error.",
    "date": "2015-05-18T15:44:08Z",
    "url": "https://github.com/netty/netty/commit/c6d61f9b43d89dc280b6089dee674daa8c180146",
    "details": {
      "sha": "abe5edb594c8d606eefbd5beae4f829e444a5e4a",
      "filename": "example/src/main/java/io/netty/example/http2/server/Http2ServerInitializer.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/netty/netty/blob/c6d61f9b43d89dc280b6089dee674daa8c180146/example%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fexample%2Fhttp2%2Fserver%2FHttp2ServerInitializer.java",
      "raw_url": "https://github.com/netty/netty/raw/c6d61f9b43d89dc280b6089dee674daa8c180146/example%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fexample%2Fhttp2%2Fserver%2FHttp2ServerInitializer.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/example%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fexample%2Fhttp2%2Fserver%2FHttp2ServerInitializer.java?ref=c6d61f9b43d89dc280b6089dee674daa8c180146",
      "patch": "@@ -70,7 +70,7 @@ private static void configureClearText(SocketChannel ch) {\n         ch.pipeline().addLast(upgradeHandler);\n         ch.pipeline().addLast(new SimpleChannelInboundHandler<HttpMessage>() {\n             @Override\n-            protected void messageReceived(ChannelHandlerContext ctx, HttpMessage msg) throws Exception {\n+            protected void channelRead0(ChannelHandlerContext ctx, HttpMessage msg) throws Exception {\n                 // If this handler is hit then no upgrade has been attempted and the client is just talking HTTP.\n                 System.err.println(\"Directly talking: \" + msg.protocolVersion() + \" (no upgrade was attempted)\");\n                 ctx.pipeline().replace(this, \"http-hello-world\",",
      "parent_sha": "04c0d77287d861940d3cd5ae8b672e93ad49e97a"
    }
  },
  {
    "oid": "c87db9b17ac258f398d69a40832b2f45439e7f99",
    "message": "Reduce SO_TIMEOUT of testsuite so it finishes sooner\n\nMotivation:\n\nTesting the OIO transport takes longer time than other transports because it has to wait for SO_TIMEOUT if there is nothing to read.  In production, it's not a good idea to decrease this value (1000ms) because it will result in so many SocketTimeoutExceptions internally, but doing so in the testsuite should be fine.\n\nModifications:\n\nReduce the default SO_TIMEOUT of OIO channels to 10 ms.\n\nResult:\n\nOur testsuite finishes sooner.",
    "date": "2014-03-17T01:54:07Z",
    "url": "https://github.com/netty/netty/commit/c87db9b17ac258f398d69a40832b2f45439e7f99",
    "details": {
      "sha": "740c69753d47974aafe3a96419e4e76ab4404505",
      "filename": "testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java",
      "status": "modified",
      "additions": 7,
      "deletions": 2,
      "changes": 9,
      "blob_url": "https://github.com/netty/netty/blob/c87db9b17ac258f398d69a40832b2f45439e7f99/testsuite%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Ftestsuite%2Ftransport%2Fsocket%2FSocketTestPermutation.java",
      "raw_url": "https://github.com/netty/netty/raw/c87db9b17ac258f398d69a40832b2f45439e7f99/testsuite%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Ftestsuite%2Ftransport%2Fsocket%2FSocketTestPermutation.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/testsuite%2Fsrc%2Ftest%2Fjava%2Fio%2Fnetty%2Ftestsuite%2Ftransport%2Fsocket%2FSocketTestPermutation.java?ref=c87db9b17ac258f398d69a40832b2f45439e7f99",
      "patch": "@@ -20,6 +20,7 @@\n import io.netty.bootstrap.ChannelFactory;\n import io.netty.bootstrap.ServerBootstrap;\n import io.netty.channel.Channel;\n+import io.netty.channel.ChannelOption;\n import io.netty.channel.EventLoopGroup;\n import io.netty.channel.nio.NioEventLoopGroup;\n import io.netty.channel.oio.OioEventLoopGroup;\n@@ -45,6 +46,8 @@ public class SocketTestPermutation {\n     protected static final int BOSSES = 2;\n     protected static final int WORKERS = 3;\n \n+    protected static final int OIO_SO_TIMEOUT = 10;  // Use short timeout for faster runs.\n+\n     protected final EventLoopGroup nioBossGroup =\n             new NioEventLoopGroup(BOSSES, new DefaultThreadFactory(\"testsuite-nio-boss\", true));\n     protected final EventLoopGroup nioWorkerGroup =\n@@ -141,7 +144,8 @@ public ServerBootstrap newInstance() {\n                     @Override\n                     public ServerBootstrap newInstance() {\n                         return new ServerBootstrap().group(oioBossGroup, oioWorkerGroup)\n-                                .channel(OioServerSocketChannel.class);\n+                                .channel(OioServerSocketChannel.class)\n+                                .option(ChannelOption.SO_TIMEOUT, OIO_SO_TIMEOUT);\n                     }\n                 }\n         );\n@@ -158,7 +162,8 @@ public Bootstrap newInstance() {\n                 new BootstrapFactory<Bootstrap>() {\n                     @Override\n                     public Bootstrap newInstance() {\n-                        return new Bootstrap().group(oioWorkerGroup).channel(OioSocketChannel.class);\n+                        return new Bootstrap().group(oioWorkerGroup).channel(OioSocketChannel.class)\n+                                .option(ChannelOption.SO_TIMEOUT, OIO_SO_TIMEOUT);\n                     }\n                 }\n         );",
      "parent_sha": "bd9ad4b532c3e8686be1c423eda099a0887199fc"
    }
  },
  {
    "oid": "cd275ba67e2d206519bde4b9074371feefa7978d",
    "message": "No need to use an unreleasable buffer - just wrap an array",
    "date": "2013-09-14T09:59:51Z",
    "url": "https://github.com/netty/netty/commit/cd275ba67e2d206519bde4b9074371feefa7978d",
    "details": {
      "sha": "162cb439f020e067d0864d7a3fe05fb390dd6fd7",
      "filename": "example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerHandler.java",
      "status": "modified",
      "additions": 2,
      "deletions": 5,
      "changes": 7,
      "blob_url": "https://github.com/netty/netty/blob/cd275ba67e2d206519bde4b9074371feefa7978d/example%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fexample%2Fhttp%2Fhelloworld%2FHttpHelloWorldServerHandler.java",
      "raw_url": "https://github.com/netty/netty/raw/cd275ba67e2d206519bde4b9074371feefa7978d/example%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fexample%2Fhttp%2Fhelloworld%2FHttpHelloWorldServerHandler.java",
      "contents_url": "https://api.github.com/repos/netty/netty/contents/example%2Fsrc%2Fmain%2Fjava%2Fio%2Fnetty%2Fexample%2Fhttp%2Fhelloworld%2FHttpHelloWorldServerHandler.java?ref=cd275ba67e2d206519bde4b9074371feefa7978d",
      "patch": "@@ -15,24 +15,21 @@\n  */\n package io.netty.example.http.helloworld;\n \n-import io.netty.buffer.ByteBuf;\n import io.netty.buffer.Unpooled;\n import io.netty.channel.ChannelFutureListener;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.ChannelInboundHandlerAdapter;\n import io.netty.handler.codec.http.DefaultFullHttpResponse;\n import io.netty.handler.codec.http.FullHttpResponse;\n import io.netty.handler.codec.http.HttpRequest;\n-import io.netty.util.CharsetUtil;\n \n import static io.netty.handler.codec.http.HttpHeaders.Names.*;\n import static io.netty.handler.codec.http.HttpHeaders.*;\n import static io.netty.handler.codec.http.HttpResponseStatus.*;\n import static io.netty.handler.codec.http.HttpVersion.*;\n \n public class HttpHelloWorldServerHandler extends ChannelInboundHandlerAdapter {\n-    private static final ByteBuf CONTENT =\n-            Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(\"Hello World\", CharsetUtil.US_ASCII));\n+    private static final byte[] CONTENT = { 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd' };\n \n     @Override\n     public void channelReadComplete(ChannelHandlerContext ctx) {\n@@ -48,7 +45,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception\n                 ctx.write(new DefaultFullHttpResponse(HTTP_1_1, CONTINUE));\n             }\n             boolean keepAlive = isKeepAlive(req);\n-            FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK, CONTENT.duplicate());\n+            FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK, Unpooled.wrappedBuffer(CONTENT));\n             response.headers().set(CONTENT_TYPE, \"text/plain\");\n             response.headers().set(CONTENT_LENGTH, response.content().readableBytes());\n ",
      "parent_sha": "357677d8fac857aae4e4b4b92d79dd37be81bb26"
    }
  }
]