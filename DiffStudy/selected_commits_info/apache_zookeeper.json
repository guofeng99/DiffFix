[
  {
    "oid": "d13d2f08c730a81d73d58f64a0ae448639dede2b",
    "message": "ZOOKEEPER-2692: Fix race condition in testWatchAutoResetWithPending\n\nWe occasionally run into an issue with testWatchAutoResetWithPending where we get flaky test behavior due to not being able to reliably predict when the client has received notification from each watch that may be fired (perhaps due to resource contention on the box running the tests). This patch works around that by waiting for a one second quiet period, after which we can more safely assume all watches that will be fired have been fired.\n\nHere is an example of the test failure: https://builds.apache.org/job/ZooKeeper-trunk-jdk8/935/\n\nAuthor: Abraham Fine <abefine@cloudera.com>\n\nReviewers: Michael Han <hanm@apache.org>\n\nCloses #171 from afine/ZOOKEEPER-2692\n\n(cherry picked from commit 1912fa8d63e6bbfdb5bb96bec85efa7c94e131e9)\nSigned-off-by: Michael Han <hanm@apache.org>",
    "date": "2017-02-16T00:17:02Z",
    "url": "https://github.com/apache/zookeeper/commit/d13d2f08c730a81d73d58f64a0ae448639dede2b",
    "details": {
      "sha": "0419125ecab56e8275dbd1729c4d8123a1a02acf",
      "filename": "src/java/test/org/apache/zookeeper/test/WatcherTest.java",
      "status": "modified",
      "additions": 16,
      "deletions": 2,
      "changes": 18,
      "blob_url": "https://github.com/apache/zookeeper/blob/d13d2f08c730a81d73d58f64a0ae448639dede2b/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Ftest%2FWatcherTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/d13d2f08c730a81d73d58f64a0ae448639dede2b/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Ftest%2FWatcherTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Ftest%2FWatcherTest.java?ref=d13d2f08c730a81d73d58f64a0ae448639dede2b",
      "patch": "@@ -44,6 +44,8 @@\n public class WatcherTest extends ClientBase {\n     protected static final Logger LOG = LoggerFactory.getLogger(WatcherTest.class);\n \n+    private long timeOfLastWatcherInvocation;\n+\n     private final static class MyStatCallback implements StatCallback {\n         int rc;\n         public void processResult(int rc, String path, Object ctx, Stat stat) {\n@@ -59,6 +61,7 @@ private class MyWatcher extends CountdownWatcher {\n         public void process(WatchedEvent event) {\n             super.process(event);\n             if (event.getType() != Event.EventType.None) {\n+                timeOfLastWatcherInvocation = System.currentTimeMillis();\n                 try {\n                     events.put(event);\n                 } catch (InterruptedException e) {\n@@ -172,7 +175,6 @@ public void testWatcherCount()\n     }\n \n     final static int COUNT = 100;\n-    boolean hasSeenDelete = true;\n     /**\n      * This test checks that watches for pending requests do not get triggered,\n      * but watches set by previous requests do.\n@@ -206,7 +208,7 @@ public void testWatchAutoResetWithPending() throws Exception {\n        startServer();\n        watches[COUNT/2-1].waitForConnected(60000);\n        Assert.assertEquals(null, zk.exists(\"/test\", false));\n-       Thread.sleep(10);\n+       waitForAllWatchers();\n        for(int i = 0; i < COUNT/2; i++) {\n            Assert.assertEquals(\"For \" + i, 1, watches[i].events.size());\n        }\n@@ -221,6 +223,18 @@ public void testWatchAutoResetWithPending() throws Exception {\n        zk.close();\n     }\n \n+    /**\n+     * Wait until no watcher has been fired in the last second to ensure that all watches\n+     * that are waiting to be fired have been fired\n+     * @throws Exception\n+     */\n+    private void waitForAllWatchers() throws Exception {\n+      timeOfLastWatcherInvocation = System.currentTimeMillis();\n+      while (System.currentTimeMillis() - timeOfLastWatcherInvocation < 1000) {\n+        Thread.sleep(1000);\n+      }\n+    }\n+\n     final int TIMEOUT = 5000;\n \n     @Test",
      "parent_sha": "fd211a5275b6231e668268fb9df2820e07f5f33c"
    }
  },
  {
    "oid": "3913303677935a60f05aa0cfc0787d5809961c3b",
    "message": "ZOOKEEPER-4791: Improve logging when the connection to a remote serve\u2026 (#2114)",
    "date": "2024-01-30T18:09:08Z",
    "url": "https://github.com/apache/zookeeper/commit/3913303677935a60f05aa0cfc0787d5809961c3b",
    "details": {
      "sha": "45d5484096b40a458b263f8edaf9a663af528d40",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxn.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/apache/zookeeper/blob/3913303677935a60f05aa0cfc0787d5809961c3b/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNettyServerCnxn.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/3913303677935a60f05aa0cfc0787d5809961c3b/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNettyServerCnxn.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNettyServerCnxn.java?ref=3913303677935a60f05aa0cfc0787d5809961c3b",
      "patch": "@@ -527,8 +527,8 @@ private void receiveMessage(ByteBuf message) {\n                         }\n                         ZooKeeperServer zks = this.zkServer;\n                         if (zks == null || !zks.isRunning()) {\n-                            LOG.info(\"Closing connection to {} because the server is not ready\",\n-                                    getRemoteSocketAddress());\n+                            LOG.info(\"Closing connection to {} because the server is not ready (server state is: {})\",\n+                                getRemoteSocketAddress(), zks == null ? \"unknown\" : zks.getState());\n                             close(DisconnectReason.IO_EXCEPTION);\n                             return;\n                         }",
      "parent_sha": "315abde35eb827652f91aed06a4de3dacf9a0f07"
    }
  },
  {
    "oid": "b01624e6f0caa19f610b110902cf7c8fb911ebfb",
    "message": "Need to publicize States to fix a build error.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/zookeeper/trunk@670907 13f79535-47bb-0310-9956-ffa450edef68",
    "date": "2008-03-24T20:29:43Z",
    "url": "https://github.com/apache/zookeeper/commit/b01624e6f0caa19f610b110902cf7c8fb911ebfb",
    "details": {
      "sha": "7a473f24f0273e9d401c898c3b325a7cee9c3442",
      "filename": "zookeeper/java/src/com/yahoo/zookeeper/ZooKeeper.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/b01624e6f0caa19f610b110902cf7c8fb911ebfb/zookeeper%2Fjava%2Fsrc%2Fcom%2Fyahoo%2Fzookeeper%2FZooKeeper.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/b01624e6f0caa19f610b110902cf7c8fb911ebfb/zookeeper%2Fjava%2Fsrc%2Fcom%2Fyahoo%2Fzookeeper%2FZooKeeper.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper%2Fjava%2Fsrc%2Fcom%2Fyahoo%2Fzookeeper%2FZooKeeper.java?ref=b01624e6f0caa19f610b110902cf7c8fb911ebfb",
      "patch": "@@ -105,7 +105,7 @@\n public class ZooKeeper {\n     Watcher watcher;\n \n-    enum States {\n+    public enum States {\n         CONNECTING, ASSOCIATING, CONNECTED, CLOSED, AUTH_FAILED;\n \n         public boolean isAlive() {",
      "parent_sha": "4895120841fcfa8c7d45cadabb4d6468020ed41b"
    }
  },
  {
    "oid": "f626ff622ef2f4ab91023a83a530eb00596e6e1d",
    "message": "Take 4\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/zookeeper/trunk@670897 13f79535-47bb-0310-9956-ffa450edef68",
    "date": "2008-02-17T01:54:37Z",
    "url": "https://github.com/apache/zookeeper/commit/f626ff622ef2f4ab91023a83a530eb00596e6e1d",
    "details": {
      "sha": "6805d6bd11ccfb8e61f0940aaa00304212a8e348",
      "filename": "zookeeper/java/src/com/yahoo/zookeeper/Version.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/f626ff622ef2f4ab91023a83a530eb00596e6e1d/zookeeper%2Fjava%2Fsrc%2Fcom%2Fyahoo%2Fzookeeper%2FVersion.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/f626ff622ef2f4ab91023a83a530eb00596e6e1d/zookeeper%2Fjava%2Fsrc%2Fcom%2Fyahoo%2Fzookeeper%2FVersion.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper%2Fjava%2Fsrc%2Fcom%2Fyahoo%2Fzookeeper%2FVersion.java?ref=f626ff622ef2f4ab91023a83a530eb00596e6e1d",
      "patch": "@@ -1,6 +1,6 @@\n package com.yahoo.zookeeper;\r\n \r\n public class Version {\r\n-\tpublic static final String id=\"$Id$\";\r\n+\tpublic static final String revisionDate=\"$Date$\";\r\n \tpublic static final String revision=\"$Revision$\";\t\r\n }\r",
      "parent_sha": "4b0cc456e9c1b5ffe4bf0c666545c74ffc9664d3"
    }
  },
  {
    "oid": "4b1b33e72ca819258b8675948b9a80dd6290edb0",
    "message": "ZOOKEEPER-4327: Fix flaky RequestThrottlerTest.testLargeRequestThrottling\n\nThis test failed following assertions in ci:\n1. `RequestThrottlerTest.testRequestThrottler:206 expected: <5> but was: <4>`\n\n   This is caused by no happens-before relationship between\n   `connectionLossCount` and `disconnected.await`. Places\n   `disconnected.countDown()` after `connectionLossCount++` to solve\n   this.\n\n2. `RequestThrottlerTest.testLargeRequestThrottling:297 expected: <2> but was: <0>`\n\n   Large request throttling is handled in io thread, while\n   `prep_processor_request_queued` metric is updated in processor\n   thread. Places metric assertion after `finished.await` to solve this.\n\nAdditionally, I find one more potential flaky case. After connection\nclosed due to throttling third request, reconnecting could fail this\ntest in slow sending environment. It is easy to reproduce by adding\n`Thread.sleep(i * 100)` in sending loop.\n\nAuthor: Kezhu Wang <kezhuw@gmail.com>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>, Mate Szalay-Beko <symat@apache.org>\n\nCloses #1821 from kezhuw/ZOOKEEPER-4327-flaky-RequestThrottlerTest.testLargeRequestThrottling and squashes the following commits:\n\ne21c2f8f7 [Kezhu Wang] ZOOKEEPER-4327: Fix flaky RequestThrottlerTest.testDropStaleRequests\n3df34b827 [Kezhu Wang] ZOOKEEPER-4327: Fix flaky RequestThrottlerTest.testLargeRequestThrottling",
    "date": "2022-05-24T07:31:52Z",
    "url": "https://github.com/apache/zookeeper/commit/4b1b33e72ca819258b8675948b9a80dd6290edb0",
    "details": {
      "sha": "ed22399902f597db307000283f1c61d84bdea98b",
      "filename": "zookeeper-server/src/test/java/org/apache/zookeeper/server/RequestThrottlerTest.java",
      "status": "modified",
      "additions": 34,
      "deletions": 26,
      "changes": 60,
      "blob_url": "https://github.com/apache/zookeeper/blob/4b1b33e72ca819258b8675948b9a80dd6290edb0/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FRequestThrottlerTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/4b1b33e72ca819258b8675948b9a80dd6290edb0/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FRequestThrottlerTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FRequestThrottlerTest.java?ref=4b1b33e72ca819258b8675948b9a80dd6290edb0",
      "patch": "@@ -229,12 +229,7 @@ public void testDropStaleRequests() throws Exception {\n         }\n \n         // make sure the server received all 5 requests\n-        submitted.await(5, TimeUnit.SECONDS);\n-        Map<String, Object> metrics = MetricsUtils.currentServerMetrics();\n-\n-        // but only two requests can get into the pipeline because of the throttler\n-        assertEquals(2L, (long) metrics.get(\"prep_processor_request_queued\"));\n-        assertEquals(1L, (long) metrics.get(\"request_throttle_wait_count\"));\n+        assertTrue(submitted.await(5, TimeUnit.SECONDS));\n \n         for (ServerCnxn cnxn : f.cnxns) {\n             cnxn.setStale();\n@@ -248,10 +243,16 @@ public void testDropStaleRequests() throws Exception {\n             Thread.sleep(50);\n         }\n \n+        // assert after all requests processed to avoid concurrent issues as metrics are\n+        // counted in different threads.\n+        Map<String, Object> metrics = MetricsUtils.currentServerMetrics();\n+\n+        // only two requests can get into the pipeline because of the throttler\n+        assertEquals(2L, (long) metrics.get(\"prep_processor_request_queued\"));\n+\n         // the rest of the 3 requests will be dropped\n         // but only the first one for a connection will be counted\n-        metrics = MetricsUtils.currentServerMetrics();\n-        assertEquals(2L, (long) metrics.get(\"prep_processor_request_queued\"));\n+        assertEquals(1L, (long) metrics.get(\"request_throttle_wait_count\"));\n         assertEquals(1, (long) metrics.get(\"stale_requests_dropped\"));\n     }\n \n@@ -261,13 +262,22 @@ public void testLargeRequestThrottling() throws Exception {\n \n         AsyncCallback.StringCallback createCallback = (rc, path, ctx, name) -> {\n             if (KeeperException.Code.get(rc) == KeeperException.Code.CONNECTIONLOSS) {\n-                disconnected.countDown();\n                 connectionLossCount++;\n+                disconnected.countDown();\n             }\n         };\n \n-        // we allow five requests in the pipeline\n-        RequestThrottler.setMaxRequests(5);\n+        // the total length of the request is about 170-180 bytes, so only two requests are allowed\n+        byte[] data = new byte[100];\n+        // the third request will incur throttle. We don't send more requests to avoid reconnecting\n+        // due to unstable test environment(e.g. slow sending).\n+        int number_requests = 3;\n+\n+        // we allow more requests in the pipeline\n+        RequestThrottler.setMaxRequests(number_requests + 2);\n+\n+        // request could become stale in processor threads due to throttle in io thread\n+        RequestThrottler.setDropStaleRequests(false);\n \n         // enable large request throttling\n         zks.setLargeRequestThreshold(150);\n@@ -277,34 +287,32 @@ public void testLargeRequestThrottling() throws Exception {\n         resumeProcess = new CountDownLatch(1);\n         // the connection will be close when large requests exceed the limit\n         // we can't use the submitted latch because requests after close won't be submitted\n-        disconnected = new CountDownLatch(TOTAL_REQUESTS);\n-\n-        // the total length of the request is about 170-180 bytes, so only two requests are allowed\n-        byte[] data = new byte[100];\n+        disconnected = new CountDownLatch(number_requests);\n \n-        // send 5 requests asynchronously\n-        for (int i = 0; i < TOTAL_REQUESTS; i++) {\n+        // send requests asynchronously\n+        for (int i = 0; i < number_requests; i++) {\n             zk.create(\"/request_throttle_test- \" + i , data,\n                     ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, createCallback, null);\n         }\n \n-        // make sure the server received all 5 requests\n-        disconnected.await(30, TimeUnit.SECONDS);\n+        // make sure the server received all requests\n+        assertTrue(disconnected.await(30, TimeUnit.SECONDS));\n+\n+        finished = new CountDownLatch(2);\n+        // let the requests go through the pipeline\n+        resumeProcess.countDown();\n+        assertTrue(finished.await(5, TimeUnit.SECONDS));\n+\n+        // assert metrics after finished so metrics in no io threads are set also.\n         Map<String, Object> metrics = MetricsUtils.currentServerMetrics();\n \n         // but only two requests can get into the pipeline because they are large requests\n         // the connection will be closed\n         assertEquals(2L, (long) metrics.get(\"prep_processor_request_queued\"));\n         assertEquals(1L, (long) metrics.get(\"large_requests_rejected\"));\n-        assertEquals(5, connectionLossCount);\n-\n-        finished = new CountDownLatch(2);\n-        // let the requests go through the pipeline\n-        resumeProcess.countDown();\n-        finished.await(5, TimeUnit.SECONDS);\n+        assertEquals(number_requests, connectionLossCount);\n \n         // when the two requests finish, they are stale because the connection is closed already\n-        metrics = MetricsUtils.currentServerMetrics();\n         assertEquals(2, (long) metrics.get(\"stale_replies\"));\n     }\n ",
      "parent_sha": "f770467d3b1a3b088208601b14dfc3f375a4dcc0"
    }
  },
  {
    "oid": "ef8b751c491bbc57b628ea9685a774fe40ba43dc",
    "message": "ZOOKEEPER-2581: Not handled NullPointerException while creating key manager and trustManager\n\n- when **zookeeper.ssl.keyStore.password**    is null,**keyStorePasswordProp** is **null** ,then **keyStorePassword.toCharArray()** is called,it will throw a NPE. we should handle this NPE gracefully\n- I just follow an example from [createSSLContext](https://github.com/apache/zookeeper/blob/master/src/java/main/org/apache/zookeeper/common/X509Util.java#L87)\n\nAuthor: maoling <maoling199210191@sina.com>\n\nReviewers: Enrico Olivelli <eolivelli@gmail.com>, Michael Han <hanm@apache.org>\n\nCloses #339 from maoling/ZOOKEEPER-2581",
    "date": "2017-09-11T20:56:46Z",
    "url": "https://github.com/apache/zookeeper/commit/ef8b751c491bbc57b628ea9685a774fe40ba43dc",
    "details": {
      "sha": "93bc8fcd3905af80becf4e11bd433b49e10dcd38",
      "filename": "src/java/main/org/apache/zookeeper/server/auth/X509AuthenticationProvider.java",
      "status": "modified",
      "additions": 33,
      "deletions": 13,
      "changes": 46,
      "blob_url": "https://github.com/apache/zookeeper/blob/ef8b751c491bbc57b628ea9685a774fe40ba43dc/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fauth%2FX509AuthenticationProvider.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/ef8b751c491bbc57b628ea9685a774fe40ba43dc/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fauth%2FX509AuthenticationProvider.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fauth%2FX509AuthenticationProvider.java?ref=ef8b751c491bbc57b628ea9685a774fe40ba43dc",
      "patch": "@@ -27,6 +27,7 @@\n \n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.common.ZKConfig;\n+import org.apache.zookeeper.common.X509Exception;\n import org.apache.zookeeper.common.X509Exception.KeyManagerException;\n import org.apache.zookeeper.common.X509Exception.TrustManagerException;\n import org.apache.zookeeper.common.X509Util;\n@@ -64,33 +65,52 @@ public class X509AuthenticationProvider implements AuthenticationProvider {\n      * <br/><code>zookeeper.ssl.keyStore.password</code>\n      * <br/><code>zookeeper.ssl.trustStore.password</code>\n      */\n-    public X509AuthenticationProvider() {\n+    public X509AuthenticationProvider() throws X509Exception {\n         String keyStoreLocationProp = System.getProperty(\n                 ZKConfig.SSL_KEYSTORE_LOCATION);\n         String keyStorePasswordProp = System.getProperty(\n                 ZKConfig.SSL_KEYSTORE_PASSWD);\n \n         X509KeyManager km = null;\n         X509TrustManager tm = null;\n-        try {\n-            km = X509Util.createKeyManager(\n-                    keyStoreLocationProp, keyStorePasswordProp);\n-        } catch (KeyManagerException e) {\n-            LOG.error(\"Failed to create key manager\", e);\n+        if (keyStoreLocationProp == null && keyStorePasswordProp == null) {\n+            LOG.warn(\"keystore not specified for client connection\");\n+        } else {\n+            if (keyStoreLocationProp == null) {\n+                throw new X509Exception(\"keystore location not specified for client connection\");\n+            }\n+            if (keyStorePasswordProp == null) {\n+                throw new X509Exception(\"keystore password not specified for client connection\");\n+            }\n+            try {\n+                km = X509Util.createKeyManager(\n+                        keyStoreLocationProp, keyStorePasswordProp);\n+            } catch (KeyManagerException e) {\n+                LOG.error(\"Failed to create key manager\", e);\n+            }\n         }\n-\n+        \n         String trustStoreLocationProp = System.getProperty(\n                 ZKConfig.SSL_TRUSTSTORE_LOCATION);\n         String trustStorePasswordProp = System.getProperty(\n                 ZKConfig.SSL_TRUSTSTORE_PASSWD);\n \n-        try {\n-            tm = X509Util.createTrustManager(\n-                    trustStoreLocationProp, trustStorePasswordProp);\n-        } catch (TrustManagerException e) {\n-            LOG.error(\"Failed to create trust manager\", e);\n+        if (trustStoreLocationProp == null && trustStorePasswordProp == null) {\n+            LOG.warn(\"Truststore not specified for client connection\");\n+        } else {\n+            if (trustStoreLocationProp == null) {\n+                throw new X509Exception(\"Truststore location not specified for client connection\");\n+            }\n+            if (trustStorePasswordProp == null) {\n+                throw new X509Exception(\"Truststore password not specified for client connection\");\n+            }\n+            try {\n+                tm = X509Util.createTrustManager(\n+                        trustStoreLocationProp, trustStorePasswordProp);\n+            } catch (TrustManagerException e) {\n+                LOG.error(\"Failed to create trust manager\", e);\n+            }\n         }\n-\n         this.keyManager = km;\n         this.trustManager = tm;\n     }",
      "parent_sha": "563f892da0e03e23715bddf236b10582bd51e429"
    }
  },
  {
    "oid": "a5cc7ba8b6739698f81f7d50bdac8f610f60d5b8",
    "message": "changed the tests to be compatible with old junit\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/zookeeper/trunk@670912 13f79535-47bb-0310-9956-ffa450edef68",
    "date": "2008-04-01T22:30:29Z",
    "url": "https://github.com/apache/zookeeper/commit/a5cc7ba8b6739698f81f7d50bdac8f610f60d5b8",
    "details": {
      "sha": "40cf8f4ed0965f43e2f228da8ed9dc7387dec5c1",
      "filename": "zookeeper/test/com/yahoo/zookeeper/test/DataTreeTest.java",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/apache/zookeeper/blob/a5cc7ba8b6739698f81f7d50bdac8f610f60d5b8/zookeeper%2Ftest%2Fcom%2Fyahoo%2Fzookeeper%2Ftest%2FDataTreeTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/a5cc7ba8b6739698f81f7d50bdac8f610f60d5b8/zookeeper%2Ftest%2Fcom%2Fyahoo%2Fzookeeper%2Ftest%2FDataTreeTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper%2Ftest%2Fcom%2Fyahoo%2Fzookeeper%2Ftest%2FDataTreeTest.java?ref=a5cc7ba8b6739698f81f7d50bdac8f610f60d5b8",
      "patch": "@@ -25,21 +25,20 @@\n import com.yahoo.zookeeper.data.Stat;\n import com.yahoo.zookeeper.proto.WatcherEvent;\n import com.yahoo.zookeeper.server.DataTree;\n+import junit.framework.TestCase;\n \n-public class DataTreeTest {\n+public class DataTreeTest extends TestCase {\n     DataTree dt;\n     \n-    @Before\n     public void setUp() throws Exception {\n         dt=new DataTree();\n     }\n \n-    @After\n     public void tearDown() throws Exception {\n         dt=null;\n     }\n \n-    @Test\n+   \n     public void testRootWatchTriggered() throws Exception {\n         class MyWatcher implements Watcher{\n             boolean fired=false;",
      "parent_sha": "7f7a4a80beac658d2f1557b21499d596a2fe4929"
    }
  },
  {
    "oid": "9598a30a6620cc336f860cee56916022f7985890",
    "message": "ZOOKEEPER-786. Reverting a bad line of this checkin\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/trunk@1176903 13f79535-47bb-0310-9956-ffa450edef68",
    "date": "2011-09-28T14:46:15Z",
    "url": "https://github.com/apache/zookeeper/commit/9598a30a6620cc336f860cee56916022f7985890",
    "details": {
      "sha": "9cb2a2673e252514971ccc675fb806b4824d8c1c",
      "filename": "src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/apache/zookeeper/blob/9598a30a6620cc336f860cee56916022f7985890/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FClientCnxnSocketNIO.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/9598a30a6620cc336f860cee56916022f7985890/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FClientCnxnSocketNIO.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FClientCnxnSocketNIO.java?ref=9598a30a6620cc336f860cee56916022f7985890",
      "patch": "@@ -190,7 +190,9 @@ void connect(InetSocketAddress addr) throws IOException {\n         sock.socket().setSoLinger(false, -1);\n         sock.socket().setTcpNoDelay(true);\n         sockKey = sock.register(selector, SelectionKey.OP_CONNECT);\n-        sock.connect(addr);\n+        if (sock.connect(addr)) {\n+            sendThread.primeConnection();\n+        }\n         initialized = false;\n \n         /*",
      "parent_sha": "6ac2b1c478346922ddd95aad0931ab5db833d5a7"
    }
  },
  {
    "oid": "085a7ab4efe04e566e952af1123e98eda609bd1b",
    "message": "ZOOKEEPER-2656: Fix ServerConfigTest#testValidArguments test case fai\u2026\n\n\u2026lures\n\nAuthor: Rakesh Radhakrishnan <rakeshr@apache.org>\n\nReviewers: Michael Han <hanm@apache.org>\n\nCloses #134 from rakeshadr/ZK-2656",
    "date": "2016-12-23T05:58:23Z",
    "url": "https://github.com/apache/zookeeper/commit/085a7ab4efe04e566e952af1123e98eda609bd1b",
    "details": {
      "sha": "e2d0da8307c5c8696ed9a8796e01c68015cc41a0",
      "filename": "src/java/test/org/apache/zookeeper/ServerConfigTest.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/apache/zookeeper/blob/085a7ab4efe04e566e952af1123e98eda609bd1b/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2FServerConfigTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/085a7ab4efe04e566e952af1123e98eda609bd1b/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2FServerConfigTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2FServerConfigTest.java?ref=085a7ab4efe04e566e952af1123e98eda609bd1b",
      "patch": "@@ -24,6 +24,8 @@\n \n import static org.junit.Assert.assertEquals;\n \n+import java.io.File;\n+\n public class ServerConfigTest {\n \n     private ServerConfig serverConfig;\n@@ -45,7 +47,7 @@ public void testValidArguments() {\n         serverConfig.parse(args);\n \n         assertEquals(2181, serverConfig.getClientPortAddress().getPort());\n-        assertEquals(\"/data/dir\", serverConfig.getDataDir());\n+        assertEquals(new File(\"/data/dir\"), serverConfig.getDataDir());\n         assertEquals(60000, serverConfig.getTickTime());\n         assertEquals(10000, serverConfig.getMaxClientCnxns());\n     }",
      "parent_sha": "f588e1982f382a586fea53a1fbb11914d48560de"
    }
  },
  {
    "oid": "2edb73a943928e0716b91e8a1d06a9c226fa393c",
    "message": "ZOOKEEPER-4715: Verify file size and position in testGetCurrentLogSize (#2025)",
    "date": "2023-07-05T13:46:05Z",
    "url": "https://github.com/apache/zookeeper/commit/2edb73a943928e0716b91e8a1d06a9c226fa393c",
    "details": {
      "sha": "5c35618b73041924bbb5aafcc08daa63e8a4e8a9",
      "filename": "zookeeper-server/src/test/java/org/apache/zookeeper/server/persistence/FileTxnLogTest.java",
      "status": "modified",
      "additions": 36,
      "deletions": 4,
      "changes": 40,
      "blob_url": "https://github.com/apache/zookeeper/blob/2edb73a943928e0716b91e8a1d06a9c226fa393c/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fpersistence%2FFileTxnLogTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/2edb73a943928e0716b91e8a1d06a9c226fa393c/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fpersistence%2FFileTxnLogTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fpersistence%2FFileTxnLogTest.java?ref=2edb73a943928e0716b91e8a1d06a9c226fa393c",
      "patch": "@@ -30,6 +30,7 @@\n import java.util.Arrays;\n import java.util.HashSet;\n import java.util.Random;\n+import org.apache.jute.Record;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.DummyWatcher;\n import org.apache.zookeeper.PortAssignment;\n@@ -171,20 +172,43 @@ public void testGetCurrentLogSize() throws Exception {\n         FileTxnLog log = new FileTxnLog(tmpDir);\n         FileTxnLog.setPreallocSize(PREALLOCATE);\n         CreateRequest record = new CreateRequest(null, new byte[NODE_SIZE], ZooDefs.Ids.OPEN_ACL_UNSAFE, 0);\n+        long logSize = 0;\n+        long position = 0;\n+        int fileHeaderSize = 16;\n         int zxid = 1;\n         for (int i = 0; i < 4; i++) {\n+            if (i == 0) {\n+                logSize += fileHeaderSize;\n+                position += fileHeaderSize;\n+            }\n             log.append(new TxnHeader(0, 0, zxid++, 0, 0), record);\n-            LOG.debug(\"Current log size: {}\", log.getCurrentLogSize());\n+            logSize += PREALLOCATE;\n+            assertEquals(logSize, log.getCurrentLogSize());\n+            assertEquals(position, log.fos.getChannel().position());\n         }\n         log.commit();\n-        LOG.info(\"Current log size: {}\", log.getCurrentLogSize());\n+        TxnHeader mockHeader = new TxnHeader(0, 0, 0, 0, 0);\n+        int totalSize =  fileHeaderSize + calculateSingleRecordLength(mockHeader, record) * 4;\n+        assertEquals(totalSize, log.getCurrentLogSize());\n+        assertEquals(totalSize, log.fos.getChannel().position());\n         assertTrue(log.getCurrentLogSize() > (zxid - 1) * NODE_SIZE);\n+        logSize = FilePadding.calculateFileSizeWithPadding(log.fos.getChannel().position(), PREALLOCATE * 4, PREALLOCATE);\n+        position = totalSize;\n+        boolean recalculate = true;\n         for (int i = 0; i < 4; i++) {\n             log.append(new TxnHeader(0, 0, zxid++, 0, 0), record);\n-            LOG.debug(\"Current log size: {}\", log.getCurrentLogSize());\n+            if (recalculate) {\n+                recalculate = false;\n+            } else {\n+                logSize += PREALLOCATE;\n+            }\n+            assertEquals(logSize, log.getCurrentLogSize());\n+            assertEquals(position, log.fos.getChannel().position());\n         }\n         log.commit();\n-        LOG.info(\"Current log size: \" + log.getCurrentLogSize());\n+        totalSize += calculateSingleRecordLength(mockHeader, record) * 4;\n+        assertEquals(totalSize, log.getCurrentLogSize());\n+        assertEquals(totalSize, log.fos.getChannel().position());\n         assertTrue(log.getCurrentLogSize() > (zxid - 1) * NODE_SIZE);\n     }\n \n@@ -263,4 +287,12 @@ public void testLogSizeLimit() throws Exception {\n         }\n     }\n \n+    private int calculateSingleRecordLength(TxnHeader txnHeader, Record record) throws IOException {\n+        int crcLength = 8;\n+        int dataLength = 4;\n+        int recordLength = Util.marshallTxnEntry(txnHeader, record).length;\n+        int endFlagLength = 1;\n+        return crcLength + dataLength + recordLength + endFlagLength;\n+    }\n+\n }",
      "parent_sha": "4a794276d3d371071c31f86c14da824fdd2e53c0"
    }
  },
  {
    "oid": "31e3f1cde33472e5bf54a7a79e3acf066cc53fba",
    "message": "ZOOKEEPER-4687. Improve SuppressWarnings in KeeperException (#1994)\n\nSigned-off-by: tison <wander4096@gmail.com>",
    "date": "2023-04-12T16:22:02Z",
    "url": "https://github.com/apache/zookeeper/commit/31e3f1cde33472e5bf54a7a79e3acf066cc53fba",
    "details": {
      "sha": "06826a672ede9796b8190a992d63969d823f2bc4",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/KeeperException.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/31e3f1cde33472e5bf54a7a79e3acf066cc53fba/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2FKeeperException.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/31e3f1cde33472e5bf54a7a79e3acf066cc53fba/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2FKeeperException.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2FKeeperException.java?ref=31e3f1cde33472e5bf54a7a79e3acf066cc53fba",
      "patch": "@@ -25,7 +25,6 @@\n import java.util.Map;\n import org.apache.yetus.audience.InterfaceAudience;\n \n-@SuppressWarnings(\"serial\")\n @InterfaceAudience.Public\n public abstract class KeeperException extends Exception {\n \n@@ -182,6 +181,7 @@ public void setCode(int code) {\n      * interface should be private, but it's declared public to enable\n      * javadoc to include in the user API spec.\n      */\n+    @SuppressWarnings(\"DeprecatedIsStillUsed\") // still used in Code - kept until 4.0\n     @Deprecated\n     @InterfaceAudience.Public\n     public interface CodeDeprecated {",
      "parent_sha": "3eda8a3a00ef3230d6c16f6ddf9201a3c0f5ca07"
    }
  },
  {
    "oid": "a109b8b5034a160c3ad0f4d2b790df962ff4dc47",
    "message": "ZOOKEEPER-3194: Quorum TLS - fix copy/paste bug in ZKTrustManager\n\nFix an obvious copy/paste bug. Tested by making sure ZKTrustManagerTest still passes.\n\nAuthor: Ilya Maykov <ilyam@fb.com>\n\nReviewers: andor@apache.org\n\nCloses #709 from ivmaykov/ZOOKEEPER-3194",
    "date": "2018-11-27T20:04:31Z",
    "url": "https://github.com/apache/zookeeper/commit/a109b8b5034a160c3ad0f4d2b790df962ff4dc47",
    "details": {
      "sha": "aa02145b213eb2bd8c2a3ce0d535a5d3fc7952c0",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/common/ZKTrustManager.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/a109b8b5034a160c3ad0f4d2b790df962ff4dc47/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fcommon%2FZKTrustManager.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/a109b8b5034a160c3ad0f4d2b790df962ff4dc47/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fcommon%2FZKTrustManager.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fcommon%2FZKTrustManager.java?ref=a109b8b5034a160c3ad0f4d2b790df962ff4dc47",
      "patch": "@@ -85,7 +85,7 @@ public void checkServerTrusted(X509Certificate[] chain, String authType, Socket\n \n     @Override\n     public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException {\n-        x509ExtendedTrustManager.checkServerTrusted(chain, authType, engine);\n+        x509ExtendedTrustManager.checkClientTrusted(chain, authType, engine);\n         if (clientHostnameVerificationEnabled) {\n             try {\n                 performHostVerification(InetAddress.getByName(engine.getPeerHost()), chain[0]);",
      "parent_sha": "64104eaeaa6508f052edfd39c24243a8e26039dc"
    }
  },
  {
    "oid": "0b65e3d4cbb7647ea692bfea59c02e5b24bf821c",
    "message": "ZOOKEEPER-3090: continue can be replaced with break\n\nchange continue  to break\n\nAuthor: zhangbo <zhangbo01@dafy.com>\n\nReviewers: hanm, nkalmar, maoling\n\nCloses #573 from a470577391/master",
    "date": "2018-09-05T23:11:01Z",
    "url": "https://github.com/apache/zookeeper/commit/0b65e3d4cbb7647ea692bfea59c02e5b24bf821c",
    "details": {
      "sha": "84b29c34412ee3716b70775290725e59abd8c24e",
      "filename": "src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/0b65e3d4cbb7647ea692bfea59c02e5b24bf821c/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fpersistence%2FFileTxnLog.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/0b65e3d4cbb7647ea692bfea59c02e5b24bf821c/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fpersistence%2FFileTxnLog.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fpersistence%2FFileTxnLog.java?ref=0b65e3d4cbb7647ea692bfea59c02e5b24bf821c",
      "patch": "@@ -257,7 +257,7 @@ public static File[] getLogFiles(File[] logDirList,long snapshotZxid) {\n         for (File f : files) {\n             long fzxid = Util.getZxidFromName(f.getName(), LOG_FILE_PREFIX);\n             if (fzxid > snapshotZxid) {\n-                continue;\n+                break;\n             }\n             // the files\n             // are sorted with zxid's",
      "parent_sha": "e501d9cc67fbaa6e825292fd838711259b6c9789"
    }
  },
  {
    "oid": "a160981e37d2907717284ec9f6eab5e17e8aecfa",
    "message": "ZOOKEEPER-4494: Fix error message format\n\ncc maoling eolivelli\n\nAuthor: tison <wander4096@gmail.com>\n\nReviewers: maoling <maoling@apache.org>\n\nCloses #1838 from tisonkun/patch-2",
    "date": "2022-03-28T02:34:06Z",
    "url": "https://github.com/apache/zookeeper/commit/a160981e37d2907717284ec9f6eab5e17e8aecfa",
    "details": {
      "sha": "464621e6afec589d0a422d7fde749687aeba5e97",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/util/SerializeUtils.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/a160981e37d2907717284ec9f6eab5e17e8aecfa/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Futil%2FSerializeUtils.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/a160981e37d2907717284ec9f6eab5e17e8aecfa/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Futil%2FSerializeUtils.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Futil%2FSerializeUtils.java?ref=a160981e37d2907717284ec9f6eab5e17e8aecfa",
      "patch": "@@ -101,7 +101,7 @@ public static TxnLogEntry deserializeTxn(byte[] txnBytes) throws IOException {\n             txn = new MultiTxn();\n             break;\n         default:\n-            throw new IOException(\"Unsupported Txn with type=%d\" + hdr.getType());\n+            throw new IOException(\"Unsupported Txn with type=\" + hdr.getType());\n         }\n         if (txn != null) {\n             try {",
      "parent_sha": "7c864336d221d7f76f18f62ab84c3e98f0a77104"
    }
  },
  {
    "oid": "54c7f6b472ed7bb10fd86cb3c28262fa4f7351d9",
    "message": "This PR adds support for TTL nodes to the CLI\n\nAuthor: randgalt <jordan@jordanzimmerman.com>\n\nReviewers: Michael Han <hanm@apache.org>, Camille Fournier <camille@apache.org>\n\nCloses #193 from Randgalt/ZOOKEEPER-2608 and squashes the following commits:\n\nbd57197 [randgalt] fixed spacing nits\nf241102 [randgalt] Merge branch 'master' into ZOOKEEPER-2608\n72fdda9 [randgalt] Added ttl option to CLI create command\n02fd557 [randgalt] Removed bogus import\n9cb973c [randgalt] This patch takes advantage of 3.5's container support. Most of the work needed to support TTLs is there already. In order not to break on-disk and protocol compatibility the ephemeralOwner is yet-again overloaded to have special meaning. New opcodes and transaction records had to be added in a similar manner to Containers",
    "date": "2017-03-23T17:46:42Z",
    "url": "https://github.com/apache/zookeeper/commit/54c7f6b472ed7bb10fd86cb3c28262fa4f7351d9",
    "details": {
      "sha": "ee6f58a4edbfcb979da5720a846a38331b39173d",
      "filename": "src/java/main/org/apache/zookeeper/cli/CreateCommand.java",
      "status": "modified",
      "additions": 32,
      "deletions": 5,
      "changes": 37,
      "blob_url": "https://github.com/apache/zookeeper/blob/54c7f6b472ed7bb10fd86cb3c28262fa4f7351d9/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fcli%2FCreateCommand.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/54c7f6b472ed7bb10fd86cb3c28262fa4f7351d9/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fcli%2FCreateCommand.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fcli%2FCreateCommand.java?ref=54c7f6b472ed7bb10fd86cb3c28262fa4f7351d9",
      "patch": "@@ -23,6 +23,8 @@\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.apache.zookeeper.server.EphemeralType;\n \n /**\n  * create command for cli\n@@ -33,14 +35,15 @@ public class CreateCommand extends CliCommand {\n     private String[] args;\n     private CommandLine cl;\n \n-    {\n+    static {\n         options.addOption(new Option(\"e\", false, \"ephemeral\"));\n         options.addOption(new Option(\"s\", false, \"sequential\"));\n         options.addOption(new Option(\"c\", false, \"container\"));\n+        options.addOption(new Option(\"t\", true, \"ttl\"));\n     }\n \n     public CreateCommand() {\n-        super(\"create\", \"[-s] [-e] [-c] path [data] [acl]\");\n+        super(\"create\", \"[-s] [-e] [-c] [-t ttl] path [data] [acl]\");\n     }\n \n \n@@ -62,23 +65,47 @@ public CliCommand parse(String[] cmdArgs) throws CliParseException {\n \n     @Override\n     public boolean exec() throws CliException {\n-        CreateMode flags = CreateMode.PERSISTENT;\n         boolean hasE = cl.hasOption(\"e\");\n         boolean hasS = cl.hasOption(\"s\");\n         boolean hasC = cl.hasOption(\"c\");\n+        boolean hasT = cl.hasOption(\"t\");\n         if (hasC && (hasE || hasS)) {\n             throw new MalformedCommandException(\"-c cannot be combined with -s or -e. Containers cannot be ephemeral or sequential.\");\n         }\n+        long ttl;\n+        try {\n+            ttl = hasT ? Long.parseLong(cl.getOptionValue(\"t\")) : 0;\n+        } catch (NumberFormatException e) {\n+            throw new MalformedCommandException(\"-t argument must be a long value\");\n+        }\n \n+        if (hasT && hasE) {\n+            throw new MalformedCommandException(\"TTLs cannot be used with Ephemeral znodes\");\n+        }\n+        if (hasT && hasC) {\n+            throw new MalformedCommandException(\"TTLs cannot be used with Container znodes\");\n+        }\n+\n+        CreateMode flags;\n         if(hasE && hasS) {\n             flags = CreateMode.EPHEMERAL_SEQUENTIAL;\n         } else if (hasE) {\n             flags = CreateMode.EPHEMERAL;\n         } else if (hasS) {\n-            flags = CreateMode.PERSISTENT_SEQUENTIAL;\n+            flags = hasT ? CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL : CreateMode.PERSISTENT_SEQUENTIAL;\n         } else if (hasC) {\n             flags = CreateMode.CONTAINER;\n+        } else {\n+            flags = hasT ? CreateMode.PERSISTENT_WITH_TTL : CreateMode.PERSISTENT;\n+        }\n+        if (hasT) {\n+            try {\n+                EphemeralType.ttlToEphemeralOwner(ttl);\n+            } catch (IllegalArgumentException e) {\n+                throw new MalformedCommandException(e.getMessage());\n+            }\n         }\n+\n         String path = args[1];\n         byte[] data = null;\n         if (args.length > 2) {\n@@ -89,7 +116,7 @@ public boolean exec() throws CliException {\n             acl = AclParser.parse(args[3]);\n         }\n         try {\n-            String newPath = zk.create(path, data, acl, flags);\n+            String newPath = hasT ? zk.create(path, data, acl, flags, new Stat(), ttl) : zk.create(path, data, acl, flags);\n             err.println(\"Created \" + newPath);\n         } catch(KeeperException.EphemeralOnLocalSessionException e) {\n             err.println(\"Unable to create ephemeral node on a local session\");",
      "parent_sha": "fb7ddacfc42acb01275ca8d69ae219d6413832b4"
    }
  },
  {
    "oid": "2a3800f00f4c14dde97c42a54806ba3485f27183",
    "message": "ZOOKEEPER-3228: [TLS] Fix key usage extension in test certs\n\nKey usage extension is wrong in test certs created by X509TestHelpers. This works with Java SSL stack because it allows sloppy certs, but breaks with Netty's OpenSSL stack. My Netty OpenSSL code is not ready for upstream yet, but fixing the test cert extensions is a prerequisite and can go in separately.\n\nAuthor: Ilya Maykov <ilyam@fb.com>\n\nReviewers: fangmin@apache.org, andor@apache.org\n\nCloses #743 from ivmaykov/ZOOKEEPER-3228",
    "date": "2019-01-02T12:41:06Z",
    "url": "https://github.com/apache/zookeeper/commit/2a3800f00f4c14dde97c42a54806ba3485f27183",
    "details": {
      "sha": "2ca250da8ac4254d701281ac37f4b0d57bb23f3a",
      "filename": "zookeeper-server/src/test/java/org/apache/zookeeper/common/X509TestHelpers.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/2a3800f00f4c14dde97c42a54806ba3485f27183/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fcommon%2FX509TestHelpers.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/2a3800f00f4c14dde97c42a54806ba3485f27183/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fcommon%2FX509TestHelpers.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fcommon%2FX509TestHelpers.java?ref=2a3800f00f4c14dde97c42a54806ba3485f27183",
      "patch": "@@ -152,7 +152,7 @@ public static X509Certificate newCert(\n                 certPublicKey);\n         builder.addExtension(Extension.basicConstraints, true, new BasicConstraints(false)); // not a CA\n         builder.addExtension(\n-                Extension.keyUsage, true, new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyAgreement));\n+                Extension.keyUsage, true, new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyEncipherment));\n         builder.addExtension(\n                 Extension.extendedKeyUsage,\n                 true,",
      "parent_sha": "4212a5a4db4b46ad6da8ded59aa3533f852d1aad"
    }
  },
  {
    "oid": "300d7e9575496d10c92e7f0edca2bbc3746cb08d",
    "message": "ZOOKEEPER-4000: use the computeIfAbsent to simplify the Leader#processSync method\n\n```\npublic synchronized void processSync(LearnerSyncRequest r) {\n    if (outstandingProposals.isEmpty()) {\n        sendSync(r);\n    } else {\n        List<LearnerSyncRequest> l = pendingSyncs.get(lastProposed);\n        if (l == null) {\n            l = new ArrayList<LearnerSyncRequest>();\n        }\n        l.add(r);\n        pendingSyncs.put(lastProposed, l);\n    }\n}\n```\nwe can use the computeIfAbsent to make the code more clean and elegant\n\nAuthor: Matteo Minardi <matteo.minardi@diennea.com>\n\nReviewers: maoling <maoling199210191@sina.com>, Christopher Tubbs <ctubbsii@apache.org>, Andor Molnar <anmolnar@apache.org>, Damien Diederen <ddiederen@apache.org>\n\nCloses #1538 from mino181295/fix/ZOOKEEPER-4000/process-sync-code",
    "date": "2020-11-17T17:37:31Z",
    "url": "https://github.com/apache/zookeeper/commit/300d7e9575496d10c92e7f0edca2bbc3746cb08d",
    "details": {
      "sha": "2de2ceeb8b0a6ecd65b099320d8375e4affccce4",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Leader.java",
      "status": "modified",
      "additions": 1,
      "deletions": 6,
      "changes": 7,
      "blob_url": "https://github.com/apache/zookeeper/blob/300d7e9575496d10c92e7f0edca2bbc3746cb08d/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLeader.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/300d7e9575496d10c92e7f0edca2bbc3746cb08d/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLeader.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLeader.java?ref=300d7e9575496d10c92e7f0edca2bbc3746cb08d",
      "patch": "@@ -1266,12 +1266,7 @@ public synchronized void processSync(LearnerSyncRequest r) {\n         if (outstandingProposals.isEmpty()) {\n             sendSync(r);\n         } else {\n-            List<LearnerSyncRequest> l = pendingSyncs.get(lastProposed);\n-            if (l == null) {\n-                l = new ArrayList<LearnerSyncRequest>();\n-            }\n-            l.add(r);\n-            pendingSyncs.put(lastProposed, l);\n+            pendingSyncs.computeIfAbsent(lastProposed, k -> new ArrayList<>()).add(r);\n         }\n     }\n ",
      "parent_sha": "6dfdf14a637d853bd77236dfbdd347912808074f"
    }
  },
  {
    "oid": "1d38d30cfd1aa47f22451f4df53ae2363ea20a82",
    "message": "ZOOKEEPER-2656: Fix ServerConfigTest#testValidArguments test case.\n\nServerConfig.getDataDir returns type String in branch-3.4 but return type File in branch-3.5 and master. So we need to deal with this difference accordingly in our test.\n\nThis PR is intended to be merged in master, branch-3.5, and branch-3.4.\n\nrakeshadr PTAL\n\nAuthor: Michael Han <hanm@apache.org>\n\nReviewers: Edward Ribeiro <edward.ribeiro@gmail.com>, Rakesh Radhakrishnan <rakeshr@apache.org>\n\nCloses #140 from hanm/ZOOKEEPER-2565",
    "date": "2017-01-06T12:11:31Z",
    "url": "https://github.com/apache/zookeeper/commit/1d38d30cfd1aa47f22451f4df53ae2363ea20a82",
    "details": {
      "sha": "27faa745b6f3b6a800d2856e6f8a263adc4b9c43",
      "filename": "src/java/test/org/apache/zookeeper/ServerConfigTest.java",
      "status": "modified",
      "additions": 16,
      "deletions": 2,
      "changes": 18,
      "blob_url": "https://github.com/apache/zookeeper/blob/1d38d30cfd1aa47f22451f4df53ae2363ea20a82/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2FServerConfigTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/1d38d30cfd1aa47f22451f4df53ae2363ea20a82/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2FServerConfigTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2FServerConfigTest.java?ref=1d38d30cfd1aa47f22451f4df53ae2363ea20a82",
      "patch": "@@ -23,6 +23,8 @@\n import org.junit.Test;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n \n import java.io.File;\n \n@@ -47,7 +49,7 @@ public void testValidArguments() {\n         serverConfig.parse(args);\n \n         assertEquals(2181, serverConfig.getClientPortAddress().getPort());\n-        assertEquals(new File(\"/data/dir\"), serverConfig.getDataDir());\n+        assertTrue(checkEquality(\"/data/dir\", serverConfig.getDataDir()));\n         assertEquals(60000, serverConfig.getTickTime());\n         assertEquals(10000, serverConfig.getMaxClientCnxns());\n     }\n@@ -57,4 +59,16 @@ public void testTooManyArguments() {\n         String[] args = {\"2181\", \"/data/dir\", \"60000\", \"10000\", \"9999\"};\n         serverConfig.parse(args);\n     }\n-}\n+\n+    boolean checkEquality(String a, String b) {\n+        assertNotNull(a);\n+        assertNotNull(b);\n+        return a.equals(b);\n+    }\n+\n+    boolean checkEquality(String a, File b) {\n+        assertNotNull(a);\n+        assertNotNull(b);\n+        return new File(a).equals(b);\n+    }\n+}\n\\ No newline at end of file",
      "parent_sha": "0753f4cdceaa2e5386072d129d897417da47d959"
    }
  },
  {
    "oid": "391cb4aa6b54e19a028215e1340232a114c23ed3",
    "message": "ZOOKEEPER-3813: FileChangeWatcherTest is broken on Mac\n\nThis patch will increase the FS wait timeout to give Mac OSX longer time to detect file modifications.\n\nAuthor: Andor Molnar <andor@apache.org>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>, Christopher Tubbs, Mate Szalay-Beko\n\nCloses #1345 from anmolnar/ZOOKEEPER-3813",
    "date": "2020-05-04T12:17:33Z",
    "url": "https://github.com/apache/zookeeper/commit/391cb4aa6b54e19a028215e1340232a114c23ed3",
    "details": {
      "sha": "619ab1d9767b0be52a64f643f712396c5e8ff947",
      "filename": "zookeeper-server/src/test/java/org/apache/zookeeper/common/FileChangeWatcherTest.java",
      "status": "modified",
      "additions": 8,
      "deletions": 6,
      "changes": 14,
      "blob_url": "https://github.com/apache/zookeeper/blob/391cb4aa6b54e19a028215e1340232a114c23ed3/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fcommon%2FFileChangeWatcherTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/391cb4aa6b54e19a028215e1340232a114c23ed3/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fcommon%2FFileChangeWatcherTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fcommon%2FFileChangeWatcherTest.java?ref=391cb4aa6b54e19a028215e1340232a114c23ed3",
      "patch": "@@ -45,6 +45,8 @@ public class FileChangeWatcherTest extends ZKTestCase {\n \n     private static final Logger LOG = LoggerFactory.getLogger(FileChangeWatcherTest.class);\n \n+    private static final long FS_TIMEOUT = 30000L;\n+\n     @BeforeClass\n     public static void createTempFile() throws IOException {\n         tempDir = ClientBase.createEmptyTestDir();\n@@ -87,7 +89,7 @@ public void testCallbackWorksOnFileChanges() throws IOException, InterruptedExce\n                 FileUtils.writeStringToFile(tempFile, \"Hello world \" + i + \"\\n\", StandardCharsets.UTF_8, true);\n                 synchronized (events) {\n                     if (events.size() < i + 1) {\n-                        events.wait(3000L);\n+                        events.wait(FS_TIMEOUT);\n                     }\n                     assertEquals(\"Wrong number of events\", i + 1, events.size());\n                     WatchEvent<?> event = events.get(i);\n@@ -128,7 +130,7 @@ public void testCallbackWorksOnFileTouched() throws IOException, InterruptedExce\n             FileUtils.touch(tempFile);\n             synchronized (events) {\n                 if (events.isEmpty()) {\n-                    events.wait(3000L);\n+                    events.wait(FS_TIMEOUT);\n                 }\n                 assertFalse(events.isEmpty());\n                 WatchEvent<?> event = events.get(0);\n@@ -162,7 +164,7 @@ public void testCallbackWorksOnFileAdded() throws IOException, InterruptedExcept\n             tempFile2.deleteOnExit();\n             synchronized (events) {\n                 if (events.isEmpty()) {\n-                    events.wait(3000L);\n+                    events.wait(FS_TIMEOUT);\n                 }\n                 assertFalse(events.isEmpty());\n                 WatchEvent<?> event = events.get(0);\n@@ -201,7 +203,7 @@ public void testCallbackWorksOnFileDeleted() throws IOException, InterruptedExce\n             tempFile.delete();\n             synchronized (events) {\n                 if (events.isEmpty()) {\n-                    events.wait(3000L);\n+                    events.wait(FS_TIMEOUT);\n                 }\n                 assertFalse(events.isEmpty());\n                 WatchEvent<?> event = events.get(0);\n@@ -239,14 +241,14 @@ public void testCallbackErrorDoesNotCrashWatcherThread() throws IOException, Int\n             FileUtils.writeStringToFile(tempFile, \"Hello world\\n\", StandardCharsets.UTF_8, true);\n             synchronized (callCount) {\n                 while (callCount.get() == 0) {\n-                    callCount.wait(3000L);\n+                    callCount.wait(FS_TIMEOUT);\n                 }\n             }\n             LOG.info(\"Modifying file again\");\n             FileUtils.writeStringToFile(tempFile, \"Hello world again\\n\", StandardCharsets.UTF_8, true);\n             synchronized (callCount) {\n                 if (callCount.get() == 1) {\n-                    callCount.wait(3000L);\n+                    callCount.wait(FS_TIMEOUT);\n                 }\n             }\n             // The value of callCount can exceed 1 only if the callback thread",
      "parent_sha": "f6b54a6cd227ac37f28803f45d7287c7fd3a8142"
    }
  },
  {
    "oid": "18a282789c4723e3c2a41960174ea55594e43d7a",
    "message": "Fixed NullPointerException when authInfo was used\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/zookeeper/trunk@670804 13f79535-47bb-0310-9956-ffa450edef68",
    "date": "2007-11-12T17:50:53Z",
    "url": "https://github.com/apache/zookeeper/commit/18a282789c4723e3c2a41960174ea55594e43d7a",
    "details": {
      "sha": "5bc083cef8acaf2f103c731fd6cdfe6d3d96df15",
      "filename": "zookeeper/java/src/com/yahoo/zookeeper/server/quorum/FollowerHandler.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/18a282789c4723e3c2a41960174ea55594e43d7a/zookeeper%2Fjava%2Fsrc%2Fcom%2Fyahoo%2Fzookeeper%2Fserver%2Fquorum%2FFollowerHandler.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/18a282789c4723e3c2a41960174ea55594e43d7a/zookeeper%2Fjava%2Fsrc%2Fcom%2Fyahoo%2Fzookeeper%2Fserver%2Fquorum%2FFollowerHandler.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper%2Fjava%2Fsrc%2Fcom%2Fyahoo%2Fzookeeper%2Fserver%2Fquorum%2FFollowerHandler.java?ref=18a282789c4723e3c2a41960174ea55594e43d7a",
      "patch": "@@ -264,7 +264,7 @@ public void run() {\n                     int type = bb.getInt();\n                     bb = bb.slice();\n                     leader.zk.submitRequest(null, sessionId, type, cxid, bb,\n-                            null);\n+                            qp.getAuthinfo());\n                     break;\n                 default:\n                 }",
      "parent_sha": "a1c481ceca909e32ec49ff9738b5355eb1c367a7"
    }
  },
  {
    "oid": "5d86165250aeed6c109bd74f66814711b88ba015",
    "message": "ZOOKEEPER-2638: ZooKeeper should log which serverCnxnFactory is used during startup\n\nAuthor: Abraham Fine <afine@apache.org>\n\nReviewers: Michael Han <hanm@apache.org>, Edward Ribeiro <edward.ribeiro@gmail.com>\n\nCloses #216 from afine/ZOOKEEPER-2638\n\n(cherry picked from commit 01f0c059c912fde07960238812e6051e1fa5e65d)\nSigned-off-by: Michael Han <hanm@apache.org>",
    "date": "2017-04-18T23:19:29Z",
    "url": "https://github.com/apache/zookeeper/commit/5d86165250aeed6c109bd74f66814711b88ba015",
    "details": {
      "sha": "1d2b04441aa11f2bd4fee37529004b2c8853088e",
      "filename": "src/java/main/org/apache/zookeeper/server/ServerCnxnFactory.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/apache/zookeeper/blob/5d86165250aeed6c109bd74f66814711b88ba015/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FServerCnxnFactory.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/5d86165250aeed6c109bd74f66814711b88ba015/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FServerCnxnFactory.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FServerCnxnFactory.java?ref=5d86165250aeed6c109bd74f66814711b88ba015",
      "patch": "@@ -130,8 +130,9 @@ static public ServerCnxnFactory createFactory() throws IOException {\n             serverCnxnFactoryName = NIOServerCnxnFactory.class.getName();\n         }\n         try {\n-            return (ServerCnxnFactory) Class.forName(serverCnxnFactoryName)\n-                                                .newInstance();\n+            ServerCnxnFactory serverCnxnFactory = (ServerCnxnFactory) Class.forName(serverCnxnFactoryName).newInstance();\n+            LOG.info(\"Using {} as server connection factory\", serverCnxnFactoryName);\n+            return serverCnxnFactory;\n         } catch (Exception e) {\n             IOException ioe = new IOException(\"Couldn't instantiate \"\n                     + serverCnxnFactoryName);",
      "parent_sha": "a43b98268bfe5aadfa8036b49dc8b1b8f0a4d67a"
    }
  },
  {
    "oid": "016ffd9a3ec2cb669071e881d677441314aa8bfd",
    "message": "ZOOKEEPER-4300: Simplify assignment statements of boolean\n\nAuthor: lan <liaonan@souche.com>\n\nReviewers: maoling <maoling@apache.org>\n\nCloses #1700 from lanicc/ZOOKEEPER-4300",
    "date": "2021-05-28T07:55:03Z",
    "url": "https://github.com/apache/zookeeper/commit/016ffd9a3ec2cb669071e881d677441314aa8bfd",
    "details": {
      "sha": "6a424178f03d7258558420709706193cfb06aa7b",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/apache/zookeeper/blob/016ffd9a3ec2cb669071e881d677441314aa8bfd/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperServer.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/016ffd9a3ec2cb669071e881d677441314aa8bfd/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperServer.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperServer.java?ref=016ffd9a3ec2cb669071e881d677441314aa8bfd",
      "patch": "@@ -2112,7 +2112,7 @@ private void checkQuota(String lastPrefix, long bytesDiff, long countDiff)\n         //check the Count Quota\n         if (checkCountQuota) {\n             long newCount = currentStats.getCount() + countDiff;\n-            boolean isCountHardLimit = limitStats.getCountHardLimit() > -1 ? true : false;\n+            boolean isCountHardLimit = limitStats.getCountHardLimit() > -1;\n             long countLimit = isCountHardLimit ? limitStats.getCountHardLimit() : limitStats.getCount();\n \n             if (newCount > countLimit) {\n@@ -2127,7 +2127,7 @@ private void checkQuota(String lastPrefix, long bytesDiff, long countDiff)\n         //check the Byte Quota\n         if (checkByteQuota) {\n             long newBytes = currentStats.getBytes() + bytesDiff;\n-            boolean isByteHardLimit = limitStats.getByteHardLimit() > -1 ? true : false;\n+            boolean isByteHardLimit = limitStats.getByteHardLimit() > -1;\n             long byteLimit = isByteHardLimit ? limitStats.getByteHardLimit() : limitStats.getBytes();\n             if (newBytes > byteLimit) {\n                 String msg = \"Quota exceeded: \" + lastPrefix + \" [current bytes=\" + newBytes + \", \" + (isByteHardLimit ? \"hard\" : \"soft\") + \"ByteLimit=\" + byteLimit + \"]\";",
      "parent_sha": "c499202a2c470e2e365ef109c8e49784cb043367"
    }
  },
  {
    "oid": "a43b9ef0cb2147d6a27f9285f9db02de54a0174f",
    "message": "ZOOKEEPER-4435: fix a tiny typo\n\nSmall typo in the log message.\n\nAuthor: epugh@opensourceconnections.com <>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>, maoling <maoling@apache.org>\n\nCloses #1792 from epugh/ZOOKEEPER-4435 and squashes the following commits:\n\nba3d78153 [epugh@opensourceconnections.com] ZOOKEEPER-4435: typo\n392b16bae [epugh@opensourceconnections.com] Revert \"typo\"\n52db6bad4 [epugh@opensourceconnections.com] typo",
    "date": "2022-01-08T07:42:31Z",
    "url": "https://github.com/apache/zookeeper/commit/a43b9ef0cb2147d6a27f9285f9db02de54a0174f",
    "details": {
      "sha": "62eded3ae4eb7c9e4ae2af62ee4acdd16b4e681b",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/ServerCnxnFactory.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/a43b9ef0cb2147d6a27f9285f9db02de54a0174f/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FServerCnxnFactory.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/a43b9ef0cb2147d6a27f9285f9db02de54a0174f/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FServerCnxnFactory.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FServerCnxnFactory.java?ref=a43b9ef0cb2147d6a27f9285f9db02de54a0174f",
      "patch": "@@ -303,7 +303,7 @@ protected void initMaxCnxns() {\n         maxCnxns = Integer.getInteger(ZOOKEEPER_MAX_CONNECTION, ZOOKEEPER_MAX_CONNECTION_DEFAULT);\n         if (maxCnxns < 0) {\n             maxCnxns = ZOOKEEPER_MAX_CONNECTION_DEFAULT;\n-            LOG.warn(\"maxCnxns should be greater than or equal to 0, using default vlaue {}.\",\n+            LOG.warn(\"maxCnxns should be greater than or equal to 0, using default value {}.\",\n                     ZOOKEEPER_MAX_CONNECTION_DEFAULT);\n         } else if (maxCnxns == ZOOKEEPER_MAX_CONNECTION_DEFAULT) {\n             LOG.warn(\"maxCnxns is not configured, using default value {}.\",",
      "parent_sha": "be3c3954e6bd940baf4b8d21b4b6a87a71f76ee6"
    }
  },
  {
    "oid": "692ea8bd681d741845c77040c1d991e34d2e91fe",
    "message": "ZOOKEEPER-3124: Add the correct comment to show why we need the special logic to handle cversion and pzxid\n\nThere is special logic in the DataTree.processTxn to handle the NODEEXISTS when createNode, which is used to handle the cversion and pzxid not being updated due to fuzzy snapshot:\n\nhttps://github.com/apache/zookeeper/blob/master/src/java/main/org/apache/zookeeper/server/DataTree.java#L962-L994.\n\nBut seems this is not a real issue, in the current code, when serializing a parent node, we'll lock on it, and take a children snapshot at that time. If the child added after the parent is serialized to disk, then it won't be written out, so we shouldn't hit the issue where the child is in the snapshot but parent cversion and pzxid is not changed.\n\nBut maybe I'm missing something, there is not much discussion in the Jira, so create a PR to have more attention.\n\nAuthor: Fangmin Lyu <allenlyu@fb.com>\n\nReviewers: Norbert Kalmar <nkalmar@apache.org>\n\nCloses #610 from lvfangmin/ZOOKEEPER-3124",
    "date": "2019-09-10T07:53:43Z",
    "url": "https://github.com/apache/zookeeper/commit/692ea8bd681d741845c77040c1d991e34d2e91fe",
    "details": {
      "sha": "0c4f2232ce1556b64e5e1e32845adff5221003eb",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java",
      "status": "modified",
      "additions": 12,
      "deletions": 8,
      "changes": 20,
      "blob_url": "https://github.com/apache/zookeeper/blob/692ea8bd681d741845c77040c1d991e34d2e91fe/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FDataTree.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/692ea8bd681d741845c77040c1d991e34d2e91fe/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FDataTree.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FDataTree.java?ref=692ea8bd681d741845c77040c1d991e34d2e91fe",
      "patch": "@@ -1027,15 +1027,19 @@ record = new ErrorTxn(ec);\n         }\n \n         /*\n-         * Snapshots are taken lazily. It can happen that the child\n-         * znodes of a parent are created after the parent\n-         * is serialized. Therefore, while replaying logs during restore, a\n-         * create might fail because the node was already\n-         * created.\n+         * Snapshots are taken lazily. When serializing a node, it's data\n+         * and children copied in a synchronization block on that node,\n+         * which means newly created node won't be in the snapshot, so\n+         * we won't have mismatched cversion and pzxid when replaying the\n+         * createNode txn.\n          *\n-         * After seeing this failure, we should increment\n-         * the cversion of the parent znode since the parent was serialized\n-         * before its children.\n+         * But there is a tricky scenario that if the child is deleted due\n+         * to session close and re-created in a different global session\n+         * after that the parent is serialized, then when replay the txn\n+         * because the node is belonging to a different session, replay the\n+         * closeSession txn won't delete it anymore, and we'll get NODEEXISTS\n+         * error when replay the createNode txn. In this case, we need to\n+         * update the cversion and pzxid to the new value.\n          *\n          * Note, such failures on DT should be seen only during\n          * restore.",
      "parent_sha": "dd96bec98db2b747958f9bcd0ea9f64d43eac17e"
    }
  },
  {
    "oid": "7d47a1792170099276c28456eea523d4d1067a6c",
    "message": "ZOOKEEPER-3688: Use StandardCharsets UTF-8 in Jute toString\n\nAuthor: David Mollitor <dmollitor@apache.org>\n\nReviewers: Christopher Tubbs <ctubbsii@apache.org>, Enrico Olivelli <eolivelli@apache.org>, maoling <maoling199210191@sina.com>, Damien Diederen <ddiederen@apache.org>\n\nCloses #1216 from belugabehr/ZOOKEEPER-3688",
    "date": "2020-11-04T07:43:20Z",
    "url": "https://github.com/apache/zookeeper/commit/7d47a1792170099276c28456eea523d4d1067a6c",
    "details": {
      "sha": "13cb1ed29c597aa27335887ce19404c50368b460",
      "filename": "zookeeper-jute/src/main/java/org/apache/jute/compiler/JRecord.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/7d47a1792170099276c28456eea523d4d1067a6c/zookeeper-jute%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fjute%2Fcompiler%2FJRecord.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/7d47a1792170099276c28456eea523d4d1067a6c/zookeeper-jute%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fjute%2Fcompiler%2FJRecord.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-jute%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fjute%2Fcompiler%2FJRecord.java?ref=7d47a1792170099276c28456eea523d4d1067a6c",
      "patch": "@@ -498,7 +498,7 @@ public void genJavaCode(File outputDirectory) throws IOException {\n                 jj.write(jf.genJavaWriteMethodName());\n             }\n             jj.write(\"      a_.endRecord(this,\\\"\\\");\\n\");\n-            jj.write(\"      return new String(s.toByteArray(), \\\"UTF-8\\\");\\n\");\n+            jj.write(\"      return new String(s.toByteArray(), java.nio.charset.StandardCharsets.UTF_8);\\n\");\n             jj.write(\"    } catch (Throwable ex) {\\n\");\n             jj.write(\"      ex.printStackTrace();\\n\");\n             jj.write(\"    }\\n\");",
      "parent_sha": "5b034a4362e41a62da43979ad0fb6c97477c1624"
    }
  },
  {
    "oid": "ce4c3d52e0dfb59ee758b77450ae13b196488c95",
    "message": "ZOOKEEPER-4350: improve the method: QuorumOracleMaj#overrideQuorumDecision\n\nZOOKEEPER-4350 - improve the method: QuorumOracleMaj#overrideQuorumDecision\n\nAuthor: gopalbala <balasubramaniangopalakrishnan@gmail.com>\n\nReviewers: maoling <maoling@apache.org>\n\nCloses #1750 from gopalbala/ZOOKEEPER-4350",
    "date": "2021-09-11T05:34:36Z",
    "url": "https://github.com/apache/zookeeper/commit/ce4c3d52e0dfb59ee758b77450ae13b196488c95",
    "details": {
      "sha": "01f3a8240be953c4701100e308b1c97555971ff3",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/flexible/QuorumOracleMaj.java",
      "status": "modified",
      "additions": 1,
      "deletions": 5,
      "changes": 6,
      "blob_url": "https://github.com/apache/zookeeper/blob/ce4c3d52e0dfb59ee758b77450ae13b196488c95/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fflexible%2FQuorumOracleMaj.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/ce4c3d52e0dfb59ee758b77450ae13b196488c95/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fflexible%2FQuorumOracleMaj.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fflexible%2FQuorumOracleMaj.java?ref=ce4c3d52e0dfb59ee758b77450ae13b196488c95",
      "patch": "@@ -115,11 +115,7 @@ public String getOraclePath() {\n \n     @Override\n     public boolean overrideQuorumDecision(List<LearnerHandler> forwardingFollowers) {\n-        if (updateNeedOracle(forwardingFollowers) && askOracle()) {\n-            return true;\n-        } else {\n-            return false;\n-        }\n+        return updateNeedOracle(forwardingFollowers) && askOracle();\n     }\n \n     @Override",
      "parent_sha": "d9d20aa1db311424336a564ae55367b4e20c4c9d"
    }
  },
  {
    "oid": "876aaf42ea721776b82633bb769f8813e881a444",
    "message": "ZOOKEEPER-3020: Review of SyncRequestProcessor\n\n1. Use ArrayDeque instead of LinkedList\n2. Use ThreadLocalRandom instead of Random\n3. Remove the 'running' flag - use the Thread#join facility to detect if the thread has stopped running. Using a flag can cause race condition issues and is superfluous.\n4. Make static final variable names in all caps\n5. General cleanup\n\n> This class is likely to be faster than Stack when used as a stack, and faster than LinkedList when used as a queue.\n\nhttps://docs.oracle.com/javase/7/docs/api/java/util/ArrayDeque.html\n\nAuthor: Beluga Behr <dam6923@gmail.com>\n\nReviewers: andor@apache.org\n\nCloses #876 from BELUGABEHR/ZOOKEEPER-3020-2 and squashes the following commits:\n\n8f1df370a [Beluga Behr] General cleanup\n83cab7382 [Beluga Behr] Simplify and streamline access pattern of queuedRequests\n5e0b801c8 [Beluga Behr] Use a semaphore to track status of snapshot thread\nd119ef740 [Beluga Behr] No need to keep a flag which states if the thread is alive\ne2059cf6e [Beluga Behr] Replace LinkedList with ArrayDeque\n57a044902 [Beluga Behr] Replace Random with ThreadLocalRandom\n17bd1fa18 [Beluga Behr] Require that the request not be 'null'\nb28ff9479 [Beluga Behr] Refactor flush method",
    "date": "2019-04-30T16:08:06Z",
    "url": "https://github.com/apache/zookeeper/commit/876aaf42ea721776b82633bb769f8813e881a444",
    "details": {
      "sha": "9d661c46781c4c0f8a49edd0b744817ac60dcfd5",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/SyncRequestProcessor.java",
      "status": "modified",
      "additions": 92,
      "deletions": 93,
      "changes": 185,
      "blob_url": "https://github.com/apache/zookeeper/blob/876aaf42ea721776b82633bb769f8813e881a444/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FSyncRequestProcessor.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/876aaf42ea721776b82633bb769f8813e881a444/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FSyncRequestProcessor.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FSyncRequestProcessor.java?ref=876aaf42ea721776b82633bb769f8813e881a444",
      "patch": "@@ -20,9 +20,13 @@\n \n import java.io.Flushable;\n import java.io.IOException;\n-import java.util.LinkedList;\n-import java.util.Random;\n+import java.util.ArrayDeque;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.ThreadLocalRandom;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -46,36 +50,38 @@\n  */\n public class SyncRequestProcessor extends ZooKeeperCriticalThread implements\n         RequestProcessor {\n+\n     private static final Logger LOG = LoggerFactory.getLogger(SyncRequestProcessor.class);\n-    private final ZooKeeperServer zks;\n-    private final LinkedBlockingQueue<Request> queuedRequests =\n+\n+    private static final int FLUSH_SIZE = 1000;\n+\n+    private static final Request REQUEST_OF_DEATH = Request.requestOfDeath;\n+\n+    /** The number of log entries to log before starting a snapshot */\n+    private static int snapCount = ZooKeeperServer.getSnapCount();\n+\n+    private final BlockingQueue<Request> queuedRequests =\n         new LinkedBlockingQueue<Request>();\n-    private final RequestProcessor nextProcessor;\n \n-    private Thread snapInProcess = null;\n-    volatile private boolean running;\n+    private final Semaphore snapThreadMutex = new Semaphore(1);\n+\n+    private final ZooKeeperServer zks;\n+\n+    private final RequestProcessor nextProcessor;\n \n     /**\n      * Transactions that have been written and are waiting to be flushed to\n      * disk. Basically this is the list of SyncItems whose callbacks will be\n      * invoked after flush returns successfully.\n      */\n-    private final LinkedList<Request> toFlush = new LinkedList<Request>();\n-    private final Random r = new Random();\n-    /**\n-     * The number of log entries to log before starting a snapshot\n-     */\n-    private static int snapCount = ZooKeeperServer.getSnapCount();\n-\n-    private final Request requestOfDeath = Request.requestOfDeath;\n+    private final Queue<Request> toFlush = new ArrayDeque<>(FLUSH_SIZE);\n \n     public SyncRequestProcessor(ZooKeeperServer zks,\n             RequestProcessor nextProcessor) {\n         super(\"SyncThread:\" + zks.getServerId(), zks\n                 .getZooKeeperServerListener());\n         this.zks = zks;\n         this.nextProcessor = nextProcessor;\n-        running = true;\n     }\n \n     /**\n@@ -102,103 +108,96 @@ public void run() {\n \n             // we do this in an attempt to ensure that not all of the servers\n             // in the ensemble take a snapshot at the same time\n-            int randRoll = r.nextInt(snapCount/2);\n+            int randRoll = ThreadLocalRandom.current().nextInt(snapCount / 2, snapCount);\n             while (true) {\n-                Request si = null;\n-                if (toFlush.isEmpty()) {\n+                Request si = queuedRequests.poll();\n+                if (si == null) {\n+                    flush();\n                     si = queuedRequests.take();\n-                } else {\n-                    si = queuedRequests.poll();\n-                    if (si == null) {\n-                        flush(toFlush);\n-                        continue;\n-                    }\n                 }\n-                if (si == requestOfDeath) {\n+  \n+                if (si == REQUEST_OF_DEATH) {\n                     break;\n                 }\n-                if (si != null) {\n-                    // track the number of records written to the log\n-                    if (zks.getZKDatabase().append(si)) {\n-                        logCount++;\n-                        if (logCount > (snapCount / 2 + randRoll)) {\n-                            randRoll = r.nextInt(snapCount/2);\n-                            // roll the log\n-                            zks.getZKDatabase().rollLog();\n-                            // take a snapshot\n-                            if (snapInProcess != null && snapInProcess.isAlive()) {\n-                                LOG.warn(\"Too busy to snap, skipping\");\n-                            } else {\n-                                snapInProcess = new ZooKeeperThread(\"Snapshot Thread\") {\n-                                        public void run() {\n-                                            try {\n-                                                zks.takeSnapshot();\n-                                            } catch(Exception e) {\n-                                                LOG.warn(\"Unexpected exception\", e);\n-                                            }\n-                                        }\n-                                    };\n-                                snapInProcess.start();\n-                            }\n-                            logCount = 0;\n-                        }\n-                    } else if (toFlush.isEmpty()) {\n-                        // optimization for read heavy workloads\n-                        // iff this is a read, and there are no pending\n-                        // flushes (writes), then just pass this to the next\n-                        // processor\n-                        if (nextProcessor != null) {\n-                            nextProcessor.processRequest(si);\n-                            if (nextProcessor instanceof Flushable) {\n-                                ((Flushable)nextProcessor).flush();\n-                            }\n+\n+                // track the number of records written to the log\n+                if (zks.getZKDatabase().append(si)) {\n+                    logCount++;\n+                    if (logCount > randRoll) {\n+                        randRoll = ThreadLocalRandom.current().nextInt(snapCount / 2, snapCount);\n+                        // roll the log\n+                        zks.getZKDatabase().rollLog();\n+                        // take a snapshot\n+                        if (!snapThreadMutex.tryAcquire()) {\n+                            LOG.warn(\"Too busy to snap, skipping\");\n+                        } else {\n+                            new ZooKeeperThread(\"Snapshot Thread\") {\n+                                public void run() {\n+                                    try {\n+                                        zks.takeSnapshot();\n+                                    } catch (Exception e) {\n+                                        LOG.warn(\"Unexpected exception\", e);\n+                                    } finally {\n+                                      snapThreadMutex.release();\n+                                    }\n+                                }\n+                            }.start();\n                         }\n-                        continue;\n+                        logCount = 0;\n                     }\n-                    toFlush.add(si);\n-                    if (toFlush.size() > 1000) {\n-                        flush(toFlush);\n+                } else if (toFlush.isEmpty()) {\n+                    // optimization for read heavy workloads\n+                    // iff this is a read, and there are no pending\n+                    // flushes (writes), then just pass this to the next\n+                    // processor\n+                    if (nextProcessor != null) {\n+                        nextProcessor.processRequest(si);\n+                        if (nextProcessor instanceof Flushable) {\n+                            ((Flushable)nextProcessor).flush();\n+                        }\n                     }\n+                    continue;\n+                }\n+                toFlush.add(si);\n+                if (toFlush.size() == FLUSH_SIZE) {\n+                    flush();\n                 }\n             }\n         } catch (Throwable t) {\n             handleException(this.getName(), t);\n-        } finally{\n-            running = false;\n         }\n         LOG.info(\"SyncRequestProcessor exited!\");\n     }\n \n-    private void flush(LinkedList<Request> toFlush)\n-        throws IOException, RequestProcessorException\n-    {\n-        if (toFlush.isEmpty())\n-            return;\n-\n-        zks.getZKDatabase().commit();\n-        while (!toFlush.isEmpty()) {\n-            Request i = toFlush.remove();\n-            if (nextProcessor != null) {\n-                nextProcessor.processRequest(i);\n-            }\n-        }\n-        if (nextProcessor != null && nextProcessor instanceof Flushable) {\n-            ((Flushable)nextProcessor).flush();\n-        }\n+    private void flush() throws IOException, RequestProcessorException {\n+      if (this.toFlush.isEmpty()) {\n+          return;\n+      }\n+\n+      zks.getZKDatabase().commit();\n+\n+      if (this.nextProcessor == null) {\n+        this.toFlush.clear();\n+      } else {\n+          while (!this.toFlush.isEmpty()) {\n+              final Request i = this.toFlush.remove();\n+              this.nextProcessor.processRequest(i);\n+          }\n+          if (this.nextProcessor instanceof Flushable) {\n+              ((Flushable)this.nextProcessor).flush();\n+          } \n+      }\n     }\n \n     public void shutdown() {\n         LOG.info(\"Shutting down\");\n-        queuedRequests.add(requestOfDeath);\n+        queuedRequests.add(REQUEST_OF_DEATH);\n         try {\n-            if(running){\n-                this.join();\n-            }\n-            if (!toFlush.isEmpty()) {\n-                flush(toFlush);\n-            }\n-        } catch(InterruptedException e) {\n+            this.join();\n+            this.flush();\n+        } catch (InterruptedException e) {\n             LOG.warn(\"Interrupted while wating for \" + this + \" to finish\");\n+            Thread.currentThread().interrupt();\n         } catch (IOException e) {\n             LOG.warn(\"Got IO exception during shutdown\");\n         } catch (RequestProcessorException e) {\n@@ -209,8 +208,8 @@ public void shutdown() {\n         }\n     }\n \n-    public void processRequest(Request request) {\n-        // request.addRQRec(\">sync\");\n+    public void processRequest(final Request request) {\n+        Objects.requireNonNull(request, \"Request cannot be null\");\n         queuedRequests.add(request);\n     }\n ",
      "parent_sha": "46b2018dbe008e010462e0dc06ddb73981d19d2a"
    }
  },
  {
    "oid": "f8ebf1a25281b2c7f48e08011918c72643313209",
    "message": "ZOOKEEPER-3889: Add volatile for variable finished in ReadOnlyRequestProcessor\n\nAuthor: dk.technoboy <guo.jiwei@immomo.com>\n\nReviewers: Michael Han <hanm@apache.org>, Christopher Tubbs <ctubbsii@apache.org>, maoling <maoling@apache.org>\n\nCloses #1402 from Technoboy-/dev",
    "date": "2021-04-25T05:12:20Z",
    "url": "https://github.com/apache/zookeeper/commit/f8ebf1a25281b2c7f48e08011918c72643313209",
    "details": {
      "sha": "0e29ccfdf6f5de4794b145ca13525a347370850b",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/ReadOnlyRequestProcessor.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/f8ebf1a25281b2c7f48e08011918c72643313209/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FReadOnlyRequestProcessor.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/f8ebf1a25281b2c7f48e08011918c72643313209/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FReadOnlyRequestProcessor.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FReadOnlyRequestProcessor.java?ref=f8ebf1a25281b2c7f48e08011918c72643313209",
      "patch": "@@ -43,7 +43,7 @@ public class ReadOnlyRequestProcessor extends ZooKeeperCriticalThread implements\n \n     private final LinkedBlockingQueue<Request> queuedRequests = new LinkedBlockingQueue<Request>();\n \n-    private boolean finished = false;\n+    private volatile boolean finished = false;\n \n     private final RequestProcessor nextProcessor;\n ",
      "parent_sha": "1590a424cb7a8768b0ae01f2957856b1834dd68d"
    }
  },
  {
    "oid": "52aff3eca439bba70f2b4d175ce331754dcd03db",
    "message": "ZOOKEEPER-2836: fix SocketTimeoutException\n\nAuthor: bitgaoshu <bitgaoshu@gmail.com>\n\nReviewers: camille camille@apache.org\n\nCloses #336 from bitgaoshu/ZOOKEEPER-2836",
    "date": "2017-08-23T00:16:27Z",
    "url": "https://github.com/apache/zookeeper/commit/52aff3eca439bba70f2b4d175ce331754dcd03db",
    "details": {
      "sha": "c8f73a3b31e0f2c1710a4cb7bad9e3578eb248a3",
      "filename": "src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java",
      "status": "modified",
      "additions": 13,
      "deletions": 6,
      "changes": 19,
      "blob_url": "https://github.com/apache/zookeeper/blob/52aff3eca439bba70f2b4d175ce331754dcd03db/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumCnxManager.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/52aff3eca439bba70f2b4d175ce331754dcd03db/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumCnxManager.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumCnxManager.java?ref=52aff3eca439bba70f2b4d175ce331754dcd03db",
      "patch": "@@ -26,6 +26,7 @@\n import java.net.ServerSocket;\n import java.net.Socket;\n import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n import java.nio.BufferUnderflowException;\n import java.nio.ByteBuffer;\n import java.nio.channels.UnresolvedAddressException;\n@@ -639,12 +640,18 @@ public void run() {\n                     setName(addr.toString());\n                     ss.bind(addr);\n                     while (!shutdown) {\n-                        client = ss.accept();\n-                        setSockOpts(client);\n-                        LOG.info(\"Received connection request \"\n-                                + client.getRemoteSocketAddress());\n-                        receiveConnection(client);\n-                        numRetries = 0;\n+                        try {\n+                            client = ss.accept();\n+                            setSockOpts(client);\n+                            LOG.info(\"Received connection request \"\n+                                     + client.getRemoteSocketAddress());\n+                            receiveConnection(client);\n+                            numRetries = 0;\n+                        } catch (SocketTimeoutException e) {\n+                            LOG.warn(\"The socket is listening for the election accepted \"\n+                                     + \"and it timed out unexpectedly, but will retry.\"\n+                                     + \"see ZOOKEEPER-2836\");\n+                        }\n                     }\n                 } catch (IOException e) {\n                     if (shutdown) {",
      "parent_sha": "b64d50441792587d75b9a32a1e2014578d132d31"
    }
  },
  {
    "oid": "dec6ac782b12a80169fbff9093949e477e5075f0",
    "message": "Remove an invalid non ASCII encoded char from comment of LearnerSyncThrottler.\n\nThe char is non ASCII encoded (so potentially it could break builds where encoding was not set as UTF8), and it is clearly redudant (as semantically\nthere should be no chars between 'or' and 'from', in this case.\n\nRemove the char fixes both.",
    "date": "2019-08-21T20:03:12Z",
    "url": "https://github.com/apache/zookeeper/commit/dec6ac782b12a80169fbff9093949e477e5075f0",
    "details": {
      "sha": "8b5de6a99e336f7beb8e24d041f6ba4ed8138137",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LearnerSyncThrottler.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/dec6ac782b12a80169fbff9093949e477e5075f0/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerSyncThrottler.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/dec6ac782b12a80169fbff9093949e477e5075f0/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerSyncThrottler.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerSyncThrottler.java?ref=dec6ac782b12a80169fbff9093949e477e5075f0",
      "patch": "@@ -23,7 +23,7 @@\n \n /**\n  * Utility class to limit the number of concurrent syncs from a leader to\n- * observers and followers or\u00df from a follower to observers.  {@link LearnerHandler}\n+ * observers and followers or from a follower to observers.  {@link LearnerHandler}\n  * objects should call {@link #beginSync(boolean)} before sending a sync and\n  * {@link #endSync()} after finishing, successfully or not.\n  *",
      "parent_sha": "fe940cdd8fb23ba09684cefb73233d570f4a20fa"
    }
  },
  {
    "oid": "1f5e4fe258707f9b82448a5f97c931c392d011ca",
    "message": "ZOOKEEPER-4327: RequestThrottlerTest: Flakiness remediations\n\n  * `testGlobalOutstandingRequestThrottlingWithRequestThrottlerDisabled`: Only resume after looking at metrics\n\n    Resuming the pipeline before looking at the metrics triggers a race between the test and other server threads, causing us to sometimes observe a larger `prep_processor_request_queued` than expected.\n\n    The corresponding failures look like this:\n\n        RequestThrottlerTest.testGlobalOutstandingRequestThrottlingWithRequestThrottlerDisabled:340 expected: <3> but was: <7>\n\n    The metric we look at is updated at the front of the pipeline, before the portion blocked by `resumeProcess`; we don't have to wait for the latter to observe the effect of the global outstanding limit.\n\n  * `testLargeRequestThrottling`: Allow more time for request ingestion\n\n    The 5s timeout used before this patch was sometimes not sufficient for the server to process the five requests of interest. The corresponding failures look like this:\n\n        RequestThrottlerTest.testLargeRequestThrottling:297 expected: <2> but was: <0>\n\n    or this:\n\n        RequestThrottlerTest.testLargeRequestThrottling:299 expected: <5> but was: <4>\n\n    We can use a higher timeout value as the `await` normally quickly terminates with the countdown reaching zero (as opposed to timing out); the increase in duration is only paid on loaded (and slow) executors.\n\nAuthor: Damien Diederen <ddiederen@apache.org>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>, Norbert Kalmar <nkalmar@apache.org>\n\nCloses #1739 from ztzg/ZOOKEEPER-4327-flaky-request-throttler-test",
    "date": "2021-08-27T08:48:40Z",
    "url": "https://github.com/apache/zookeeper/commit/1f5e4fe258707f9b82448a5f97c931c392d011ca",
    "details": {
      "sha": "62d371dd4fbba70fe0d621269054bf6a0bacb132",
      "filename": "zookeeper-server/src/test/java/org/apache/zookeeper/server/RequestThrottlerTest.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/apache/zookeeper/blob/1f5e4fe258707f9b82448a5f97c931c392d011ca/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FRequestThrottlerTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/1f5e4fe258707f9b82448a5f97c931c392d011ca/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FRequestThrottlerTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FRequestThrottlerTest.java?ref=1f5e4fe258707f9b82448a5f97c931c392d011ca",
      "patch": "@@ -289,7 +289,7 @@ public void testLargeRequestThrottling() throws Exception {\n         }\n \n         // make sure the server received all 5 requests\n-        disconnected.await(5, TimeUnit.SECONDS);\n+        disconnected.await(30, TimeUnit.SECONDS);\n         Map<String, Object> metrics = MetricsUtils.currentServerMetrics();\n \n         // but only two requests can get into the pipeline because they are large requests\n@@ -329,8 +329,6 @@ public void testGlobalOutstandingRequestThrottlingWithRequestThrottlerDisabled()\n \n             submitted.await(5, TimeUnit.SECONDS);\n \n-            resumeProcess.countDown();\n-\n             // We should start throttling instead of queuing more requests.\n             //\n             // We always allow up to GLOBAL_OUTSTANDING_LIMIT + 1 number of requests coming in request processing pipeline\n@@ -339,6 +337,8 @@ public void testGlobalOutstandingRequestThrottlingWithRequestThrottlerDisabled()\n             // be GLOBAL_OUTSTANDING_LIMIT + 2.\n             assertEquals(Integer.parseInt(GLOBAL_OUTSTANDING_LIMIT) + 2,\n                     (long) MetricsUtils.currentServerMetrics().get(\"prep_processor_request_queued\"));\n+\n+            resumeProcess.countDown();\n         } catch (Exception e) {\n             throw e;\n         } finally {",
      "parent_sha": "06467dc8c20e6c7357c19904f6214bb406262ba2"
    }
  },
  {
    "oid": "1f5dfb0bb6cd8c13d9308393825bea90ccf4e72c",
    "message": "getting rid of unused vars in leader election\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/zookeeper/trunk@670947 13f79535-47bb-0310-9956-ffa450edef68",
    "date": "2008-05-08T18:49:06Z",
    "url": "https://github.com/apache/zookeeper/commit/1f5dfb0bb6cd8c13d9308393825bea90ccf4e72c",
    "details": {
      "sha": "ff0233b45c5a45cda924c87d44746c29935a4909",
      "filename": "zookeeper/java/src/com/yahoo/zookeeper/server/quorum/FastLeaderElection.java",
      "status": "modified",
      "additions": 2,
      "deletions": 19,
      "changes": 21,
      "blob_url": "https://github.com/apache/zookeeper/blob/1f5dfb0bb6cd8c13d9308393825bea90ccf4e72c/zookeeper%2Fjava%2Fsrc%2Fcom%2Fyahoo%2Fzookeeper%2Fserver%2Fquorum%2FFastLeaderElection.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/1f5dfb0bb6cd8c13d9308393825bea90ccf4e72c/zookeeper%2Fjava%2Fsrc%2Fcom%2Fyahoo%2Fzookeeper%2Fserver%2Fquorum%2FFastLeaderElection.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper%2Fjava%2Fsrc%2Fcom%2Fyahoo%2Fzookeeper%2Fserver%2Fquorum%2FFastLeaderElection.java?ref=1f5dfb0bb6cd8c13d9308393825bea90ccf4e72c",
      "patch": "@@ -22,13 +22,11 @@\n import java.nio.ByteBuffer;\n import java.util.Collection;\n import java.util.HashMap;\n-import java.util.Random;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.TimeUnit;\n \n import org.apache.log4j.Logger;\n \n-import com.yahoo.zookeeper.server.ZooLog;\n import com.yahoo.zookeeper.server.quorum.QuorumCnxManager.Message;\n import com.yahoo.zookeeper.server.quorum.QuorumPeer.QuorumServer;\n import com.yahoo.zookeeper.server.quorum.QuorumPeer.ServerState;\n@@ -64,11 +62,6 @@ public class FastLeaderElection implements Election {\n \t\n \tstatic int challengeCounter = 0;\n \t\n-\t/*\n-\t * Flag to determine whether to authenticate or not\n-\t */\n-    \n-\tprivate boolean authEnabled = false;\n     \n \t/*\n \t * Connection manager\n@@ -154,19 +147,16 @@ static enum mType {crequest, challenge, notification, ack};\n \n     private class Messenger {\n     \t\n-        DatagramSocket mySocket;\n         long lastProposedLeader;\n         long lastProposedZxid;\n         long lastEpoch;\n         \n         class WorkerReceiver implements Runnable {\n \n         \tQuorumCnxManager manager;\n-            Messenger msg;\n \n-            WorkerReceiver(QuorumCnxManager manager, Messenger msg) {\n+            WorkerReceiver(QuorumCnxManager manager) {\n                 this.manager = manager;\n-                this.msg = msg;\n             }\n \n             public void run() {\n@@ -252,14 +242,9 @@ public void run() {\n \n         class WorkerSender implements Runnable {\n         \t\n-            Random rand;\n             QuorumCnxManager manager;\n-            boolean processing;\n-            int ackWait = finalizeWait / 6;\n \n-            \n             WorkerSender(QuorumCnxManager manager){ \n-                rand = new Random(java.lang.Thread.currentThread().getId() + System.currentTimeMillis());\n                 this.manager = manager;\n             }\n             \n@@ -276,7 +261,6 @@ public void run() {\n             }\n \n             private void process(ToSend m) {\n-                int attempts = 0;\n                 byte requestBytes[] = new byte[28];\n                 ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);  \n                 \n@@ -309,7 +293,7 @@ public boolean queueEmpty() {\n             t.setDaemon(true);\n             t.start();\n \n-            t = new Thread(new WorkerReceiver(manager, this),\n+            t = new Thread(new WorkerReceiver(manager),\n                     \t\t\t\t\"WorkerReceiver Thread\");\n             t.setDaemon(true);\n             t.start();\n@@ -321,7 +305,6 @@ public boolean queueEmpty() {\n     int port;\n     long logicalclock; /* Election instance */\n     Messenger messenger;\n-    DatagramSocket mySocket;\n     long proposedLeader;\n     long proposedZxid;\n ",
      "parent_sha": "3c67b6c6ddbee6d710714938f33697cf7912f00f"
    }
  },
  {
    "oid": "0fe7a09ab57c73c3a5c91e68a889f600c0739136",
    "message": "ZOOKEEPER-2923: The comment of the variable matchSyncs in class CommitProcessor has a mistake.\n\nAuthor: Jiafu Jiang <jiangjiafu1989@gmail.com>\n\nReviewers: phunt@apache.org\n\nCloses #408 from JiangJiafu/ZOOKEEPER-2923\n\nChange-Id: Iaf5076b38aa950467b2664684ba98743ab131a5b\n(cherry picked from commit 8be14c4d4743bebfd3e2b1759503d640480d4218)\nSigned-off-by: Patrick Hunt <phunt@apache.org>\n(cherry picked from commit c98d44a7af8e7883eb7e37d165b3ececb1f5cd7d)",
    "date": "2017-11-15T21:44:29Z",
    "url": "https://github.com/apache/zookeeper/commit/0fe7a09ab57c73c3a5c91e68a889f600c0739136",
    "details": {
      "sha": "1eb7faca5638dfa284d299dacc309bce109e8541",
      "filename": "src/java/main/org/apache/zookeeper/server/quorum/CommitProcessor.java",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/apache/zookeeper/blob/0fe7a09ab57c73c3a5c91e68a889f600c0739136/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FCommitProcessor.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/0fe7a09ab57c73c3a5c91e68a889f600c0739136/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FCommitProcessor.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FCommitProcessor.java?ref=0fe7a09ab57c73c3a5c91e68a889f600c0739136",
      "patch": "@@ -112,10 +112,9 @@ public class CommitProcessor extends ZooKeeperCriticalThread implements\n     private Object emptyPoolSync = new Object();\n \n     /**\n-     * This flag indicates whether we need to wait for a response to come back\n-     * from the leader or we just let the sync operation flow through like a\n-     * read. The flag will be true if the CommitProcessor is in a Leader\n-     * pipeline.\n+     * This flag indicates whether we need to wait for a response to come back from the\n+     * leader or we just let the sync operation flow through like a read. The flag will\n+     * be false if the CommitProcessor is in a Leader pipeline.\n      */\n     boolean matchSyncs;\n ",
      "parent_sha": "efeebd0a1ba7f6be3b4ffe262ab4045656bb1eb3"
    }
  },
  {
    "oid": "5c4e44332e55bbf21ca59583f3e8ca97fc4bb266",
    "message": "ZOOKEEPER-2853: Update lastZxidSeen in FileTxnLog\n\nAuthor: Fangmin Lyu <allenlyu@fb.com>\n\nReviewers: Michael Han <hanm@apache.org>, maoling <maoling199210191@sina.com>\n\nCloses #322 from lvfangmin/ZOOKEEPER-2853",
    "date": "2017-08-03T18:41:30Z",
    "url": "https://github.com/apache/zookeeper/commit/5c4e44332e55bbf21ca59583f3e8ca97fc4bb266",
    "details": {
      "sha": "72bb583fbe5f88dfcadb6cc2dc29ed96240399fb",
      "filename": "src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java",
      "status": "modified",
      "additions": 63,
      "deletions": 61,
      "changes": 124,
      "blob_url": "https://github.com/apache/zookeeper/blob/5c4e44332e55bbf21ca59583f3e8ca97fc4bb266/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fpersistence%2FFileTxnLog.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/5c4e44332e55bbf21ca59583f3e8ca97fc4bb266/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fpersistence%2FFileTxnLog.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fpersistence%2FFileTxnLog.java?ref=5c4e44332e55bbf21ca59583f3e8ca97fc4bb266",
      "patch": "@@ -53,39 +53,39 @@\n  * <blockquote><pre>\n  * LogFile:\n  *     FileHeader TxnList ZeroPad\n- * \n+ *\n  * FileHeader: {\n  *     magic 4bytes (ZKLG)\n  *     version 4bytes\n  *     dbid 8bytes\n  *   }\n- * \n+ *\n  * TxnList:\n  *     Txn || Txn TxnList\n- *     \n+ *\n  * Txn:\n  *     checksum Txnlen TxnHeader Record 0x42\n- * \n+ *\n  * checksum: 8bytes Adler32 is currently used\n  *   calculated across payload -- Txnlen, TxnHeader, Record and 0x42\n- * \n+ *\n  * Txnlen:\n  *     len 4bytes\n- * \n+ *\n  * TxnHeader: {\n  *     sessionid 8bytes\n  *     cxid 4bytes\n  *     zxid 8bytes\n  *     time 8bytes\n  *     type 4bytes\n  *   }\n- *     \n+ *\n  * Record:\n  *     See Jute definition file for details on the various record types\n- *      \n+ *\n  * ZeroPad:\n  *     0 padded to EOF (filled during preallocation stage)\n- * </pre></blockquote> \n+ * </pre></blockquote>\n  */\n public class FileTxnLog implements TxnLog {\n     private static final Logger LOG;\n@@ -175,7 +175,7 @@ public synchronized void rollLog() throws IOException {\n     /**\n      * close all the open file handles\n      * @throws IOException\n-     */\n+      */\n     public synchronized void close() throws IOException {\n         if (logStream != null) {\n             logStream.close();\n@@ -184,54 +184,56 @@ public synchronized void close() throws IOException {\n             log.close();\n         }\n     }\n-    \n+\n     /**\n      * append an entry to the transaction log\n      * @param hdr the header of the transaction\n      * @param txn the transaction part of the entry\n-     * returns true iff something appended, otw false \n+     * returns true iff something appended, otw false\n      */\n     public synchronized boolean append(TxnHeader hdr, Record txn)\n         throws IOException\n     {\n-        if (hdr != null) {\n-            if (hdr.getZxid() <= lastZxidSeen) {\n-                LOG.warn(\"Current zxid \" + hdr.getZxid()\n-                        + \" is <= \" + lastZxidSeen + \" for \"\n-                        + hdr.getType());\n-            }\n-            if (logStream==null) {\n-               if(LOG.isInfoEnabled()){\n-                    LOG.info(\"Creating new log file: log.\" +  \n-                            Long.toHexString(hdr.getZxid()));\n-               }\n-               \n-               logFileWrite = new File(logDir, (\"log.\" + \n-                       Long.toHexString(hdr.getZxid())));\n-               fos = new FileOutputStream(logFileWrite);\n-               logStream=new BufferedOutputStream(fos);\n-               oa = BinaryOutputArchive.getArchive(logStream);\n-               FileHeader fhdr = new FileHeader(TXNLOG_MAGIC,VERSION, dbId);\n-               fhdr.serialize(oa, \"fileheader\");\n-               // Make sure that the magic number is written before padding.\n-               logStream.flush();\n-               currentSize = fos.getChannel().position();\n-               streamsToFlush.add(fos);\n-            }\n-            padFile(fos);\n-            byte[] buf = Util.marshallTxnEntry(hdr, txn);\n-            if (buf == null || buf.length == 0) {\n-                throw new IOException(\"Faulty serialization for header \" +\n-                        \"and txn\");\n-            }\n-            Checksum crc = makeChecksumAlgorithm();\n-            crc.update(buf, 0, buf.length);\n-            oa.writeLong(crc.getValue(), \"txnEntryCRC\");\n-            Util.writeTxnBytes(oa, buf);\n-            \n-            return true;\n+        if (hdr == null) {\n+            return false;\n         }\n-        return false;\n+        if (hdr.getZxid() <= lastZxidSeen) {\n+            LOG.warn(\"Current zxid \" + hdr.getZxid()\n+                    + \" is <= \" + lastZxidSeen + \" for \"\n+                    + hdr.getType());\n+        } else {\n+            lastZxidSeen = hdr.getZxid();\n+        }\n+        if (logStream==null) {\n+           if(LOG.isInfoEnabled()){\n+                LOG.info(\"Creating new log file: log.\" +\n+                        Long.toHexString(hdr.getZxid()));\n+           }\n+\n+           logFileWrite = new File(logDir, (\"log.\" +\n+                   Long.toHexString(hdr.getZxid())));\n+           fos = new FileOutputStream(logFileWrite);\n+           logStream=new BufferedOutputStream(fos);\n+           oa = BinaryOutputArchive.getArchive(logStream);\n+           FileHeader fhdr = new FileHeader(TXNLOG_MAGIC,VERSION, dbId);\n+           fhdr.serialize(oa, \"fileheader\");\n+           // Make sure that the magic number is written before padding.\n+           logStream.flush();\n+           currentSize = fos.getChannel().position();\n+           streamsToFlush.add(fos);\n+        }\n+        padFile(fos);\n+        byte[] buf = Util.marshallTxnEntry(hdr, txn);\n+        if (buf == null || buf.length == 0) {\n+            throw new IOException(\"Faulty serialization for header \" +\n+                    \"and txn\");\n+        }\n+        Checksum crc = makeChecksumAlgorithm();\n+        crc.update(buf, 0, buf.length);\n+        oa.writeLong(crc.getValue(), \"txnEntryCRC\");\n+        Util.writeTxnBytes(oa, buf);\n+\n+        return true;\n     }\n \n     /**\n@@ -456,10 +458,10 @@ public boolean isForceSync() {\n     }\n \n     /**\n-     * a class that keeps track of the position \n+     * a class that keeps track of the position\n      * in the input stream. The position points to offset\n-     * that has been consumed by the applications. It can \n-     * wrap buffered input streams to provide the right offset \n+     * that has been consumed by the applications. It can\n+     * wrap buffered input streams to provide the right offset\n      * for the application.\n      */\n     static class PositionInputStream extends FilterInputStream {\n@@ -468,7 +470,7 @@ protected PositionInputStream(InputStream in) {\n             super(in);\n             position = 0;\n         }\n-        \n+\n         @Override\n         public int read() throws IOException {\n             int rc = super.read();\n@@ -483,9 +485,9 @@ public int read(byte[] b) throws IOException {\n             if (rc > 0) {\n                 position += rc;\n             }\n-            return rc;            \n+            return rc;\n         }\n-        \n+\n         @Override\n         public int read(byte[] b, int off, int len) throws IOException {\n             int rc = super.read(b, off, len);\n@@ -494,7 +496,7 @@ public int read(byte[] b, int off, int len) throws IOException {\n             }\n             return rc;\n         }\n-        \n+\n         @Override\n         public long skip(long n) throws IOException {\n             long rc = super.skip(n);\n@@ -522,7 +524,7 @@ public void reset() {\n             throw new UnsupportedOperationException(\"reset\");\n         }\n     }\n-    \n+\n     /**\n      * this class implements the txnlog iterator interface\n      * which is used for reading the transaction logs\n@@ -535,7 +537,7 @@ public static class FileTxnIterator implements TxnLog.TxnIterator {\n         File logFile;\n         InputArchive ia;\n         static final String CRC_ERROR=\"CRC check failed\";\n-       \n+\n         PositionInputStream inputStream=null;\n         //stored files is the list of files greater than\n         //the zxid we are looking for.\n@@ -564,7 +566,7 @@ public FileTxnIterator(File logDir, long zxid, boolean fastForward)\n                 }\n             }\n         }\n-        \n+\n         /**\n          * create an iterator over a transaction database directory\n          * @param logDir the transaction database directory\n@@ -596,7 +598,7 @@ else if (Util.getZxidFromName(f.getName(), \"log\") < zxid) {\n             goToNextLog();\n             next();\n         }\n-        \n+\n         /**\n          * Return total storage size of txnlog that will return by this iterator.\n          */\n@@ -634,7 +636,7 @@ protected void inStreamCreated(InputArchive ia, InputStream is)\n             FileHeader header= new FileHeader();\n             header.deserialize(ia, \"fileheader\");\n             if (header.getMagic() != FileTxnLog.TXNLOG_MAGIC) {\n-                throw new IOException(\"Transaction log: \" + this.logFile + \" has invalid magic number \" \n+                throw new IOException(\"Transaction log: \" + this.logFile + \" has invalid magic number \"\n                         + header.getMagic()\n                         + \" != \" + FileTxnLog.TXNLOG_MAGIC);\n             }",
      "parent_sha": "69c8cbea1dcc95bb1b4eb01cbfd667a1bfba1f5d"
    }
  },
  {
    "oid": "118dee4b8a4a69699eb00e12bef2907cbbece160",
    "message": "ZOOKEEPER-3740: fix flaky PurgeTxnTest.testPurgeWhenLogRollingInProgress\n\nThis test is always passing for me when I execute only the PurgeTxnTest test\nclass locally, but when I execute all the tests (with multiple parallel threads,\nusing `mvn clean install`), then it always fails. It is failing frequently on\nthe `zookeeper-master-maven` Jenkins job as well.\n\nThe test starts three threads, performing 1000 ZNode creation in each thread\nand timeouts if the threads are not finished in 90 seconds. Currently it is\nnot easy to tell based on the logs if the timeout happens because the\noperations are still in progress or if one of the threads terminated due\nto an unexpected exception.\n\nIn this patch I:\n- increased the timeout from 90 to 120 seconds\n- added an extra logic to actually fail because of the Exception on the\nthreads, if any happen during the execution\n- I decreased the number of ZNode creations to 750 (from the original 1000)\n\nApplying this patch locally fixed my issues, I hope it will be enough\nto fix the test on Jenkins as well.\n\nAuthor: Mate Szalay-Beko <szalay.beko.mate@gmail.com>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>, Norbert Kalmar <nkalmar@apache.org>\n\nCloses #1274 from symat/ZOOKEEPER-3740",
    "date": "2020-03-03T09:53:43Z",
    "url": "https://github.com/apache/zookeeper/commit/118dee4b8a4a69699eb00e12bef2907cbbece160",
    "details": {
      "sha": "804e23726eeb4b2e621ed08ce5b1fea8db529787",
      "filename": "zookeeper-server/src/test/java/org/apache/zookeeper/server/PurgeTxnTest.java",
      "status": "modified",
      "additions": 23,
      "deletions": 17,
      "changes": 40,
      "blob_url": "https://github.com/apache/zookeeper/blob/118dee4b8a4a69699eb00e12bef2907cbbece160/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FPurgeTxnTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/118dee4b8a4a69699eb00e12bef2907cbbece160/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FPurgeTxnTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FPurgeTxnTest.java?ref=118dee4b8a4a69699eb00e12bef2907cbbece160",
      "patch": "@@ -33,6 +33,7 @@\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n import java.util.zip.CheckedOutputStream;\n import org.apache.jute.BinaryOutputArchive;\n import org.apache.jute.OutputArchive;\n@@ -59,7 +60,7 @@ public class PurgeTxnTest extends ZKTestCase {\n     private static final Logger LOG = LoggerFactory.getLogger(PurgeTxnTest.class);\n     private static String HOSTPORT = \"127.0.0.1:\" + PortAssignment.unique();\n     private static final int CONNECTION_TIMEOUT = 3000;\n-    private static final long OP_TIMEOUT_IN_MILLIS = 90000;\n+    private static final long OP_TIMEOUT_IN_MILLIS = 120000;\n     private File tmpDir;\n \n     @Before\n@@ -561,33 +562,38 @@ private List<String> manyClientOps(final ZooKeeper zk, final CountDownLatch doPu\n         Thread[] ths = new Thread[thCount];\n         final List<String> znodes = Collections.synchronizedList(new ArrayList<String>());\n         final CountDownLatch finished = new CountDownLatch(thCount);\n+        final AtomicReference<Exception> exception = new AtomicReference<>();\n         for (int indx = 0; indx < thCount; indx++) {\n             final String myprefix = prefix + \"-\" + indx;\n-            Thread th = new Thread() {\n-                public void run() {\n-                    for (int i = 0; i < 1000; i++) {\n-                        try {\n-                            String mynode = myprefix + \"-\" + i;\n-                            znodes.add(mynode);\n-                            zk.create(mynode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n-                        } catch (Exception e) {\n-                            LOG.error(\"Unexpected exception\", e);\n-                        }\n-                        if (i == 200) {\n-                            doPurge.countDown();\n-                        }\n+            Thread th = new Thread(() -> {\n+                for (int i = 0; i < 750; i++) {\n+                    try {\n+                        String mynode = myprefix + \"-\" + i;\n+                        znodes.add(mynode);\n+                        zk.create(mynode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+                    } catch (Exception e) {\n+                        LOG.error(\"Unexpected exception during ZkClient ops\", e);\n+                        exception.set(e);\n+                    }\n+                    if (i == 200) {\n+                        doPurge.countDown();\n                     }\n-                    finished.countDown();\n                 }\n-            };\n+                finished.countDown();\n+            });\n             ths[indx] = th;\n         }\n \n         for (Thread thread : ths) {\n             thread.start();\n         }\n         try {\n-            assertTrue(\"ZkClient ops is not finished!\", finished.await(OP_TIMEOUT_IN_MILLIS, TimeUnit.MILLISECONDS));\n+            boolean operationsFinishedSuccessfully = finished.await(OP_TIMEOUT_IN_MILLIS, TimeUnit.MILLISECONDS);\n+            if (exception.get() != null) {\n+                LOG.error(\"unexpected exception during running ZkClient ops:\", exception.get());\n+                fail(\"unexpected exception during running ZkClient ops, see in the logs above\");\n+            }\n+            assertTrue(\"ZkClient ops not finished in time!\", operationsFinishedSuccessfully);\n         } catch (InterruptedException ie) {\n             LOG.error(\"Unexpected exception\", ie);\n             fail(\"Unexpected exception occurred!\");",
      "parent_sha": "d3e72c659d20e109b2ba60c1fe277e5d14ba8e6b"
    }
  },
  {
    "oid": "66554218a557cbc86924354bdb20e20b20ff934f",
    "message": "ZOOKEEPER-2949: using hostname and port to create SSLEngine\n\nIf the server has more than one host name, and serve each host name with different certificates. then the ssl client must provide the server name in the ssl Hello packet, to tell the server which certificate to use.\nThis is especially important when the client connect to a load balancer with different backend services.\n\nhttps://en.wikipedia.org/wiki/Server_Name_Indication\n\nAuthor: f00231050 <shaobao.feng@huawei.com>\n\nReviewers: Andor Moln\u00e1r <andor@cloudera.com>, Abraham Fine <afine@apache.org>\n\nCloses #423 from abel-von/ZOOKEEPER-2949",
    "date": "2018-01-30T20:56:37Z",
    "url": "https://github.com/apache/zookeeper/commit/66554218a557cbc86924354bdb20e20b20ff934f",
    "details": {
      "sha": "ec789cb09b840af5b5ef9f443909635f230f7863",
      "filename": "src/java/main/org/apache/zookeeper/ClientCnxnSocketNetty.java",
      "status": "modified",
      "additions": 10,
      "deletions": 2,
      "changes": 12,
      "blob_url": "https://github.com/apache/zookeeper/blob/66554218a557cbc86924354bdb20e20b20ff934f/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FClientCnxnSocketNetty.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/66554218a557cbc86924354bdb20e20b20ff934f/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FClientCnxnSocketNetty.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FClientCnxnSocketNetty.java?ref=66554218a557cbc86924354bdb20e20b20ff934f",
      "patch": "@@ -112,7 +112,7 @@ void connect(InetSocketAddress addr) throws IOException {\n \n         ClientBootstrap bootstrap = new ClientBootstrap(channelFactory);\n \n-        bootstrap.setPipelineFactory(new ZKClientPipelineFactory());\n+        bootstrap.setPipelineFactory(new ZKClientPipelineFactory(addr.getHostString(), addr.getPort()));\n         bootstrap.setOption(\"soLinger\", -1);\n         bootstrap.setOption(\"tcpNoDelay\", true);\n \n@@ -340,13 +340,21 @@ public static Packet getInstance() {\n             return instance;\n         }\n     }\n+\n     /**\n      * ZKClientPipelineFactory is the netty pipeline factory for this netty\n      * connection implementation.\n      */\n     private class ZKClientPipelineFactory implements ChannelPipelineFactory {\n         private SSLContext sslContext = null;\n         private SSLEngine sslEngine = null;\n+        private String host;\n+        private int port;\n+\n+        public ZKClientPipelineFactory(String host, int port) {\n+            this.host = host;\n+            this.port = port;\n+        }\n \n         @Override\n         public ChannelPipeline getPipeline() throws Exception {\n@@ -363,7 +371,7 @@ public ChannelPipeline getPipeline() throws Exception {\n         private synchronized void initSSL(ChannelPipeline pipeline) throws SSLContextException {\n             if (sslContext == null || sslEngine == null) {\n                 sslContext = X509Util.createSSLContext(clientConfig);\n-                sslEngine = sslContext.createSSLEngine();\n+                sslEngine = sslContext.createSSLEngine(host,port);\n                 sslEngine.setUseClientMode(true);\n             }\n             pipeline.addLast(\"ssl\", new SslHandler(sslEngine));",
      "parent_sha": "d1b07d588e445085eff4abeb42cf730cc7c57e83"
    }
  },
  {
    "oid": "a1c481ceca909e32ec49ff9738b5355eb1c367a7",
    "message": "removed Create Hammer Test from ant test and added TestHammer which will not be a part of ant test\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/zookeeper/trunk@670803 13f79535-47bb-0310-9956-ffa450edef68",
    "date": "2007-11-09T19:47:39Z",
    "url": "https://github.com/apache/zookeeper/commit/a1c481ceca909e32ec49ff9738b5355eb1c367a7",
    "details": {
      "sha": "0661870b5a56680adacd4a42d1a40c7887e59fe3",
      "filename": "zookeeper/test/com/yahoo/zookeeper/test/TestHammer.java",
      "status": "renamed",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/apache/zookeeper/blob/a1c481ceca909e32ec49ff9738b5355eb1c367a7/zookeeper%2Ftest%2Fcom%2Fyahoo%2Fzookeeper%2Ftest%2FTestHammer.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/a1c481ceca909e32ec49ff9738b5355eb1c367a7/zookeeper%2Ftest%2Fcom%2Fyahoo%2Fzookeeper%2Ftest%2FTestHammer.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper%2Ftest%2Fcom%2Fyahoo%2Fzookeeper%2Ftest%2FTestHammer.java?ref=a1c481ceca909e32ec49ff9738b5355eb1c367a7",
      "patch": "@@ -1,4 +1,3 @@\n-package com.yahoo.zookeeper.test;\n \n import java.io.IOException;\n \n@@ -8,7 +7,7 @@\n import com.yahoo.zookeeper.ZooDefs.CreateFlags;\n import com.yahoo.zookeeper.ZooDefs.Ids;\n \n-public class CreateHammerTest implements VoidCallback {\n+public class TestHammer implements VoidCallback {\n \n     /**\n      * @param args\n@@ -30,7 +29,7 @@ public static void main(String[] args) {\n                 try {\n                     String name = zk.create(\"/testFile-\", new byte[16], Ids.OPEN_ACL_UNSAFE,\n                         CreateFlags.EPHEMERAL|CreateFlags.SEQUENCE);\n-                    zk.delete(name, -1, new CreateHammerTest(), null);\n+                    zk.delete(name, -1, new TestHammer(), null);\n                 } catch(Exception e) {\n                     i--;\n                     e.printStackTrace();",
      "previous_filename": "zookeeper/test/com/yahoo/zookeeper/test/CreateHammerTest.java",
      "parent_sha": "fce72e5323cccbacd9f1a0dadc7dbd58a2899771"
    }
  },
  {
    "oid": "70f70d821c2c5225edeb54a8af0bd1911a51fc89",
    "message": "ZOOKEEPER-4318: Only report the follower sync time metrics if sync is completed\n\nMotivation\n\n- Currently we report the follower sync time regardless whether sync is completed.  This will give us some noisy data such as 0 sync time in cases where sync immediately failed.\n\nChange\n\n- Only report the sync time if the sync is completed.\n\nAuthor: liwang <liwang@apple.com>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>, Michael Han <hanm@apache.org>, Damien Diederen <ddiederen@apache.org>\n\nCloses #1712 from li4wang/ZOOKEEPER-4318",
    "date": "2021-06-30T06:59:22Z",
    "url": "https://github.com/apache/zookeeper/commit/70f70d821c2c5225edeb54a8af0bd1911a51fc89",
    "details": {
      "sha": "0eff9d24837197f403e3474e22e96dfc19824773",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Follower.java",
      "status": "modified",
      "additions": 7,
      "deletions": 10,
      "changes": 17,
      "blob_url": "https://github.com/apache/zookeeper/blob/70f70d821c2c5225edeb54a8af0bd1911a51fc89/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFollower.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/70f70d821c2c5225edeb54a8af0bd1911a51fc89/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFollower.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFollower.java?ref=70f70d821c2c5225edeb54a8af0bd1911a51fc89",
      "patch": "@@ -103,16 +103,13 @@ void followLeader() throws InterruptedException {\n                     throw new IOException(\"Error: Epoch of leader is lower\");\n                 }\n                 long startTime = Time.currentElapsedTime();\n-                try {\n-                    self.setLeaderAddressAndId(leaderServer.addr, leaderServer.getId());\n-                    self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);\n-                    syncWithLeader(newEpochZxid);\n-                    self.setZabState(QuorumPeer.ZabState.BROADCAST);\n-                    completedSync = true;\n-                } finally {\n-                    long syncTime = Time.currentElapsedTime() - startTime;\n-                    ServerMetrics.getMetrics().FOLLOWER_SYNC_TIME.add(syncTime);\n-                }\n+                self.setLeaderAddressAndId(leaderServer.addr, leaderServer.getId());\n+                self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);\n+                syncWithLeader(newEpochZxid);\n+                self.setZabState(QuorumPeer.ZabState.BROADCAST);\n+                completedSync = true;\n+                long syncTime = Time.currentElapsedTime() - startTime;\n+                ServerMetrics.getMetrics().FOLLOWER_SYNC_TIME.add(syncTime);\n                 if (self.getObserverMasterPort() > 0) {\n                     LOG.info(\"Starting ObserverMaster\");\n ",
      "parent_sha": "2d3065606a444c0b711c1809ce296db2ba56cb0c"
    }
  },
  {
    "oid": "8b68d78491052fc44bb5ef51ad866ce48d078725",
    "message": "[ 1953737 ] Millisecond timing in the trace file\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/zookeeper/trunk@670931 13f79535-47bb-0310-9956-ffa450edef68",
    "date": "2008-04-29T22:36:42Z",
    "url": "https://github.com/apache/zookeeper/commit/8b68d78491052fc44bb5ef51ad866ce48d078725",
    "details": {
      "sha": "7e93a9ff2f0766c0c7cc76d866ad393113dd86e9",
      "filename": "zookeeper/java/src/com/yahoo/zookeeper/server/ZooLog.java",
      "status": "modified",
      "additions": 10,
      "deletions": 9,
      "changes": 19,
      "blob_url": "https://github.com/apache/zookeeper/blob/8b68d78491052fc44bb5ef51ad866ce48d078725/zookeeper%2Fjava%2Fsrc%2Fcom%2Fyahoo%2Fzookeeper%2Fserver%2FZooLog.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/8b68d78491052fc44bb5ef51ad866ce48d078725/zookeeper%2Fjava%2Fsrc%2Fcom%2Fyahoo%2Fzookeeper%2Fserver%2FZooLog.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper%2Fjava%2Fsrc%2Fcom%2Fyahoo%2Fzookeeper%2Fserver%2FZooLog.java?ref=8b68d78491052fc44bb5ef51ad866ce48d078725",
      "patch": "@@ -21,6 +21,7 @@\n import java.nio.ByteBuffer;\n import java.nio.channels.FileChannel;\n import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n import java.util.Calendar;\n import java.util.Date;\n import java.util.GregorianCalendar;\n@@ -103,14 +104,15 @@ static private void write(FileChannel os, String msg) throws IOException {\n         os.write(ByteBuffer.wrap(msg.getBytes()));\n     }\n \n+    private static final SimpleDateFormat DATELOGFMT =\n+        new SimpleDateFormat(\"MM/dd/yy HH:mm:ss,SSS\");\n+    \n     static private void writeText(FileChannel os, char rp, Request request,\n             String header, String location) throws IOException {\n         StringBuffer sb = new StringBuffer();\n         long time = System.currentTimeMillis();\n-        sb.append(\n-                DateFormat.getDateTimeInstance(DateFormat.SHORT,\n-                        DateFormat.LONG).format(new Date(time))).append(\" \")\n-                .append(location).append(\" \");\n+        sb.append(DATELOGFMT.format(new Date(time)));\n+        sb.append(\" \").append(location).append(\" \");\n         sb.append(header).append(\":\").append(rp);\n         sb.append(request.toString());\n         write(os, sb.toString());\n@@ -121,10 +123,8 @@ static private void writeText(FileChannel os, String message,\n             String location) throws IOException {\n         StringBuffer sb = new StringBuffer();\n         long time = System.currentTimeMillis();\n-        sb.append(\n-                DateFormat.getDateTimeInstance(DateFormat.SHORT,\n-                        DateFormat.LONG).format(new Date(time))).append(\" \")\n-                .append(location).append(\" \");\n+        sb.append(DATELOGFMT.format(new Date(time)));\n+        sb.append(\" \").append(location).append(\" \");\n         sb.append(message);\n         write(os, sb.toString());\n         write(textTos, \"\\n\");\n@@ -254,6 +254,7 @@ static synchronized private void logRequestText(char rp, Request request,\n         }\n     }\n \n+    /*\n     public void logRequestBinary(char rp, Request request, long traceMask) {\n         if (!doLog(traceMask)) {\n             return;\n@@ -290,7 +291,7 @@ public void logRequestBinary(char rp, Request request, long traceMask) {\n             }\n         }\n     }\n-\n+    */\n     /*\n     static private void formatLine(PrintStream ps, String mess, String location) {\n         DateFormat dateFormat = DateFormat.getDateTimeInstance(",
      "parent_sha": "888e0c5fc576415a7949a938bf1aad4be74984eb"
    }
  },
  {
    "oid": "5b034a4362e41a62da43979ad0fb6c97477c1624",
    "message": "ZOOKEEPER-3662: Remove NPE Possibility in Follower Class\n\nAuthor: David Mollitor <dmollitor@apache.org>\n\nReviewers: Allan Lyu <fangmin@apache.org>, Enrico Olivelli <eolivelli@apache.org>, Norbert Kalmar <nkalmar@apache.org>\n\nCloses #1192 from belugabehr/ZOOKEEPER-3662",
    "date": "2020-11-03T16:01:59Z",
    "url": "https://github.com/apache/zookeeper/commit/5b034a4362e41a62da43979ad0fb6c97477c1624",
    "details": {
      "sha": "971710c91abfa34aff2f5dd0f19ae6831a68d223",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/Follower.java",
      "status": "modified",
      "additions": 6,
      "deletions": 10,
      "changes": 16,
      "blob_url": "https://github.com/apache/zookeeper/blob/5b034a4362e41a62da43979ad0fb6c97477c1624/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFollower.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/5b034a4362e41a62da43979ad0fb6c97477c1624/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFollower.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFollower.java?ref=5b034a4362e41a62da43979ad0fb6c97477c1624",
      "patch": "@@ -23,6 +23,7 @@\n import java.nio.ByteBuffer;\n import java.util.Collections;\n import java.util.Map;\n+import java.util.Objects;\n import org.apache.jute.Record;\n import org.apache.zookeeper.ZooDefs.OpCode;\n import org.apache.zookeeper.common.Time;\n@@ -48,10 +49,10 @@ public class Follower extends Learner {\n \n     ObserverMaster om;\n \n-    Follower(QuorumPeer self, FollowerZooKeeperServer zk) {\n-        this.self = self;\n+    Follower(final QuorumPeer self, final FollowerZooKeeperServer zk) {\n+        this.self = Objects.requireNonNull(self);\n+        this.fzk = Objects.requireNonNull(zk);\n         this.zk = zk;\n-        this.fzk = zk;\n     }\n \n     @Override\n@@ -253,14 +254,9 @@ protected void processPacket(QuorumPacket qp) throws Exception {\n      * @return zxid\n      */\n     public long getZxid() {\n-        try {\n-            synchronized (fzk) {\n-                return fzk.getZxid();\n-            }\n-        } catch (NullPointerException e) {\n-            LOG.warn(\"error getting zxid\", e);\n+        synchronized (fzk) {\n+            return fzk.getZxid();\n         }\n-        return -1;\n     }\n \n     /**",
      "parent_sha": "392846c534c51a57aa678691d411ad7d8d68e29a"
    }
  },
  {
    "oid": "b3ef40bffe49c1e42aee23a600a775194f36bca0",
    "message": "ZOOKEEPER-2743: Netty connection leaks JMX connection bean.\n\nSee https://issues.apache.org/jira/browse/ZOOKEEPER-2743 for details on the symptom and diagnostic.\n\nThere are many ways of fixing this. For example we can enforce certain ordering of the close operations to eliminate the race condition however that would incur non trivial performance penalty as a result of synchronization. I think the solution in this patch is simple and effective as it observes that the bean unregister call is idempotent and the call itself is trivial so we just always unregister connection upon close the connection, to ensure the bean is unregistered regardless of the races.\n\nI've also stress tested this solution on internal Jenkins which indicates no failures of https://issues.apache.org/jira/browse/ZOOKEEPER-2707 for the past two days.\n\nA side note is NIO connection in theory would suffer the same problem however I am unable to reproduce the same racing with existing unit test. So I just leave NIO as it is, for now.\n\nAuthor: Michael Han <hanm@apache.org>\n\nReviewers: Rakesh Radhakrishnan <rakeshr@apache.org>\n\nCloses #211 from hanm/ZOOKEEPER-2743",
    "date": "2017-04-10T17:19:34Z",
    "url": "https://github.com/apache/zookeeper/commit/b3ef40bffe49c1e42aee23a600a775194f36bca0",
    "details": {
      "sha": "142e9162499cb3587a2947b25798ce0e0c06f9b4",
      "filename": "src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/apache/zookeeper/blob/b3ef40bffe49c1e42aee23a600a775194f36bca0/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNettyServerCnxn.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/b3ef40bffe49c1e42aee23a600a775194f36bca0/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNettyServerCnxn.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNettyServerCnxn.java?ref=b3ef40bffe49c1e42aee23a600a775194f36bca0",
      "patch": "@@ -87,6 +87,12 @@ public void close() {\n             LOG.debug(\"close called for sessionid:0x\"\n                     + Long.toHexString(sessionId));\n         }\n+\n+        // ZOOKEEPER-2743:\n+        // Always unregister connection upon close to prevent\n+        // connection bean leak under certain race conditions.\n+        factory.unregisterConnection(this);\n+\n         synchronized(factory.cnxns){\n             // if this is not in cnxns then it's already closed\n             if (!factory.cnxns.remove(this)) {\n@@ -111,7 +117,6 @@ public void close() {\n         if (channel.isOpen()) {\n             channel.close();\n         }\n-        factory.unregisterConnection(this);\n     }\n \n     @Override",
      "parent_sha": "d061f1b5a5eca108e566a68e6f7aa07913c90ac3"
    }
  },
  {
    "oid": "061e76123e91db4b9c28ab77e58df1b723df00d9",
    "message": "ZOOKEEPER-3183: Interrupting the WatcherCleaner thread during shutdown\n\n\u2026are waiting list to add watchers during the shutdown  and avoid adding the dead watchers when shut down is initiated\n\nAuthor: vtumati <vtumati@paypal.com>\n\nReviewers: fangmin@apache.org, andor@apache.org\n\nCloses #689 from tumativ/ZOOKEEPER-3183",
    "date": "2018-11-28T22:43:41Z",
    "url": "https://github.com/apache/zookeeper/commit/061e76123e91db4b9c28ab77e58df1b723df00d9",
    "details": {
      "sha": "9648848c619c72a4bc08a9afb3d454664ff969e1",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/watch/WatcherCleaner.java",
      "status": "modified",
      "additions": 11,
      "deletions": 5,
      "changes": 16,
      "blob_url": "https://github.com/apache/zookeeper/blob/061e76123e91db4b9c28ab77e58df1b723df00d9/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fwatch%2FWatcherCleaner.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/061e76123e91db4b9c28ab77e58df1b723df00d9/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fwatch%2FWatcherCleaner.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fwatch%2FWatcherCleaner.java?ref=061e76123e91db4b9c28ab77e58df1b723df00d9",
      "patch": "@@ -50,6 +50,7 @@ public class WatcherCleaner extends Thread {\n \n     private volatile boolean stopped = false;\n     private final Object cleanEvent = new Object();\n+    private final Object processingCompletedEvent = new Object();\n     private final Random r = new Random(System.nanoTime());\n     private final WorkerService cleaners;\n \n@@ -102,12 +103,13 @@ public void addDeadWatcher(int watcherBit) {\n                 totalDeadWatchers.get() >= maxInProcessingDeadWatchers) {\n             try {\n                 RATE_LOGGER.rateLimitLog(\"Waiting for dead watchers cleaning\");\n-                synchronized(totalDeadWatchers) {\n-                    totalDeadWatchers.wait(100);\n+                synchronized(processingCompletedEvent) {\n+                    processingCompletedEvent.wait(100);\n                 }\n             } catch (InterruptedException e) {\n                 LOG.info(\"Got interrupted while waiting for dead watches \" +\n                         \"queue size\");\n+                break;\n             }\n         }\n         synchronized (this) {\n@@ -129,7 +131,7 @@ public void run() {\n                 try {\n                     // add some jitter to avoid cleaning dead watchers at the\n                     // same time in the quorum\n-                    if (deadWatchers.size() < watcherCleanThreshold) {\n+                    if (!stopped && deadWatchers.size() < watcherCleanThreshold) {\n                         int maxWaitMs = (watcherCleanIntervalInSeconds +\n                             r.nextInt(watcherCleanIntervalInSeconds / 2 + 1)) * 1000;\n                         cleanEvent.wait(maxWaitMs);\n@@ -163,8 +165,8 @@ public void doWork() throws Exception {\n                         long latency = Time.currentElapsedTime() - startTime;\n                         LOG.info(\"Takes {} to process {} watches\", latency, total);\n                         totalDeadWatchers.addAndGet(-total);\n-                        synchronized(totalDeadWatchers) {\n-                            totalDeadWatchers.notifyAll();\n+                        synchronized(processingCompletedEvent) {\n+                            processingCompletedEvent.notifyAll();\n                         }\n                     }\n                 });\n@@ -177,6 +179,10 @@ public void shutdown() {\n         stopped = true;\n         deadWatchers.clear();\n         cleaners.stop();\n+        this.interrupt();\n+        if (LOG.isInfoEnabled()) {\n+            LOG.info(\"WatcherCleaner thread shutdown is initiated\");\n+        }\n     }\n \n }",
      "parent_sha": "a109b8b5034a160c3ad0f4d2b790df962ff4dc47"
    }
  },
  {
    "oid": "bb39b83e125bb40597346aa4412e21851d1e871e",
    "message": "ZOOKEEPER-3046: wait for clients to reconnect after restarting server\n\nComment from ZOOKEEPER-3046, explaining what failure signature motivated this change:\n\nStill seeing test failures; basically a variant of ZOOKEEPER-2508. (After stopping/starting the server, we have to wait for all clients to reconnect before continuing the test.)\n\n```\n422005     [junit] 2018-11-25 21:25:50,228 [myid:127.0.0.1:16611] - INFO  [Time-limited test-SendThread(127.0.0.1:16611):ClientCnxn$SendThread1390] - Session establishment complete on serve       r localhost/127.0.0.1:16611, sessionid = 0x100007077c50001, negotiated timeout = 30000\n422006     [junit] 2018-11-25 21:25:50,286 [myid:] - INFO  [Time-limited test:JUnit4ZKTestRunner$LoggedInvokeMethod98] - TEST METHOD FAILED testManyChildWatchersAutoReset\n422007     [junit] org.apache.zookeeper.KeeperException$ConnectionLossException: KeeperErrorCode = ConnectionLoss for /long-path-000000000-111111111-222222222-333333333-444444444-555555555-6       66666666-777777777-888888888-999999999/ch-0000000000/ch\n422008     [junit]     at org.apache.zookeeper.KeeperException.create(KeeperException.java:102)\n422009     [junit]     at org.apache.zookeeper.KeeperException.create(KeeperException.java:54)\n422010     [junit]     at org.apache.zookeeper.ZooKeeper.create(ZooKeeper.java:1459)\n422011     [junit]     at org.apache.zookeeper.test.DisconnectedWatcherTest.testManyChildWatchersAutoReset(DisconnectedWatcherTest.java:229)\n```\n\nAuthor: Michael Edwards <Michael Edwards>\n\nReviewers: andor@apache.org\n\nCloses #721 from mkedwards/ZOOKEEPER-3046 and squashes the following commits:\n\n20fd64c71 [Michael Edwards] ZOOKEEPER-3046: call setUp/tearDown from ClientBase in the setUp/tearDown of the subclass\n3965ae81e [Michael Edwards] ZOOKEEPER-3046: factor common setup in DisconnectedWatcherTest tests to a setUp() method\n62e6bca24 [Michael Edwards] ZOOKEEPER-3046: wait for clients to reconnect after restarting server",
    "date": "2019-03-11T20:56:36Z",
    "url": "https://github.com/apache/zookeeper/commit/bb39b83e125bb40597346aa4412e21851d1e871e",
    "details": {
      "sha": "f459919edf30bb20f528958d432f9c0d9a88f6fe",
      "filename": "zookeeper-server/src/test/java/org/apache/zookeeper/test/DisconnectedWatcherTest.java",
      "status": "modified",
      "additions": 46,
      "deletions": 28,
      "changes": 74,
      "blob_url": "https://github.com/apache/zookeeper/blob/bb39b83e125bb40597346aa4412e21851d1e871e/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Ftest%2FDisconnectedWatcherTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/bb39b83e125bb40597346aa4412e21851d1e871e/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Ftest%2FDisconnectedWatcherTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Ftest%2FDisconnectedWatcherTest.java?ref=bb39b83e125bb40597346aa4412e21851d1e871e",
      "patch": "@@ -28,7 +28,9 @@\n import org.apache.zookeeper.ZooKeeper;\n import org.apache.zookeeper.Watcher.Event.EventType;\n import org.apache.zookeeper.ZooDefs.Ids;\n+import org.junit.After;\n import org.junit.Assert;\n+import org.junit.Before;\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -53,17 +55,38 @@ public void process(WatchedEvent event) {\n         }\n     }\n \n+    private CountdownWatcher watcher1;\n+    private ZooKeeper zk1;\n+    private MyWatcher watcher2;\n+    private ZooKeeper zk2;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        watcher1 = new CountdownWatcher();\n+        zk1 = createClient(watcher1);\n+        watcher2 = new MyWatcher();\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        if (zk2 != null) {\n+            zk2.close();\n+        }\n+        if (zk1 != null) {\n+            zk1.close();\n+        }\n+        super.tearDown();\n+    }\n+\n     // @see jira issue ZOOKEEPER-961\n     \n     @Test\n     public void testChildWatcherAutoResetWithChroot() throws Exception {\n-        ZooKeeper zk1 = createClient();\n-\n         zk1.create(\"/ch1\", null, Ids.OPEN_ACL_UNSAFE,\n                     CreateMode.PERSISTENT);\n \n-        MyWatcher watcher = new MyWatcher();\n-        ZooKeeper zk2 = createClient(watcher, hostPort + \"/ch1\");\n+        zk2 = createClient(watcher2, hostPort + \"/ch1\");\n         zk2.getChildren(\"/\", true );\n \n         // this call shouldn't trigger any error or watch\n@@ -73,7 +96,7 @@ public void testChildWatcherAutoResetWithChroot() throws Exception {\n         // this should trigger the watch\n         zk1.create(\"/ch1/youshouldmatter1\", null, Ids.OPEN_ACL_UNSAFE,\n                 CreateMode.PERSISTENT);\n-        WatchedEvent e = watcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n+        WatchedEvent e = watcher2.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n         Assert.assertNotNull(e);\n         Assert.assertEquals(EventType.NodeChildrenChanged, e.getType());\n         Assert.assertEquals(\"/\", e.getPath());\n@@ -82,9 +105,10 @@ public void testChildWatcherAutoResetWithChroot() throws Exception {\n         zk2.getChildren(\"/\", childWatcher);\n         \n         stopServer();\n-        watcher.waitForDisconnected(3000);\n+        watcher2.waitForDisconnected(3000);\n         startServer();\n-        watcher.waitForConnected(3000);\n+        watcher2.waitForConnected(3000);\n+        watcher1.waitForConnected(3000);\n \n         // this should trigger the watch\n         zk1.create(\"/ch1/youshouldmatter2\", null, Ids.OPEN_ACL_UNSAFE,\n@@ -97,13 +121,10 @@ public void testChildWatcherAutoResetWithChroot() throws Exception {\n     \n     @Test\n     public void testDefaultWatcherAutoResetWithChroot() throws Exception {\n-        ZooKeeper zk1 = createClient();\n-\n         zk1.create(\"/ch1\", null, Ids.OPEN_ACL_UNSAFE,\n                     CreateMode.PERSISTENT);\n \n-        MyWatcher watcher = new MyWatcher();\n-        ZooKeeper zk2 = createClient(watcher, hostPort + \"/ch1\");\n+        zk2 = createClient(watcher2, hostPort + \"/ch1\");\n         zk2.getChildren(\"/\", true );\n \n         // this call shouldn't trigger any error or watch\n@@ -113,31 +134,30 @@ public void testDefaultWatcherAutoResetWithChroot() throws Exception {\n         // this should trigger the watch\n         zk1.create(\"/ch1/youshouldmatter1\", null, Ids.OPEN_ACL_UNSAFE,\n                 CreateMode.PERSISTENT);\n-        WatchedEvent e = watcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n+        WatchedEvent e = watcher2.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n         Assert.assertNotNull(e);\n         Assert.assertEquals(EventType.NodeChildrenChanged, e.getType());\n         Assert.assertEquals(\"/\", e.getPath());\n \n         zk2.getChildren(\"/\", true );\n \n         stopServer();\n-        watcher.waitForDisconnected(3000);\n+        watcher2.waitForDisconnected(3000);\n         startServer();\n-        watcher.waitForConnected(3000);\n+        watcher2.waitForConnected(3000);\n+        watcher1.waitForConnected(3000);\n \n         // this should trigger the watch\n         zk1.create(\"/ch1/youshouldmatter2\", null, Ids.OPEN_ACL_UNSAFE,\n                 CreateMode.PERSISTENT);\n-        e = watcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n+        e = watcher2.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n         Assert.assertNotNull(e);\n         Assert.assertEquals(EventType.NodeChildrenChanged, e.getType());\n         Assert.assertEquals(\"/\", e.getPath());\n     }\n     \n     @Test\n     public void testDeepChildWatcherAutoResetWithChroot() throws Exception {\n-        ZooKeeper zk1 = createClient();\n-\n         zk1.create(\"/ch1\", null, Ids.OPEN_ACL_UNSAFE,\n                 CreateMode.PERSISTENT);\n         zk1.create(\"/ch1/here\", null, Ids.OPEN_ACL_UNSAFE,\n@@ -147,14 +167,13 @@ public void testDeepChildWatcherAutoResetWithChroot() throws Exception {\n         zk1.create(\"/ch1/here/we/are\", null, Ids.OPEN_ACL_UNSAFE,\n                 CreateMode.PERSISTENT);\n \n-        MyWatcher watcher = new MyWatcher();\n-        ZooKeeper zk2 = createClient(watcher, hostPort + \"/ch1/here/we\");\n+        zk2 = createClient(watcher2, hostPort + \"/ch1/here/we\");\n         zk2.getChildren(\"/are\", true );\n \n         // this should trigger the watch\n         zk1.create(\"/ch1/here/we/are/now\", null, Ids.OPEN_ACL_UNSAFE,\n                 CreateMode.PERSISTENT);\n-        WatchedEvent e = watcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n+        WatchedEvent e = watcher2.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);\n         Assert.assertNotNull(e);\n         Assert.assertEquals(EventType.NodeChildrenChanged, e.getType());\n         Assert.assertEquals(\"/are\", e.getPath());\n@@ -163,9 +182,10 @@ public void testDeepChildWatcherAutoResetWithChroot() throws Exception {\n         zk2.getChildren(\"/are\", childWatcher);\n         \n         stopServer();\n-        watcher.waitForDisconnected(3000);\n+        watcher2.waitForDisconnected(3000);\n         startServer();\n-        watcher.waitForConnected(3000);\n+        watcher2.waitForConnected(3000);\n+        watcher1.waitForConnected(3000);\n \n         // this should trigger the watch\n         zk1.create(\"/ch1/here/we/are/again\", null, Ids.OPEN_ACL_UNSAFE,\n@@ -180,10 +200,7 @@ public void testDeepChildWatcherAutoResetWithChroot() throws Exception {\n     // watches which require multiple SetWatches calls.\n     @Test(timeout = 840000)\n     public void testManyChildWatchersAutoReset() throws Exception {\n-        ZooKeeper zk1 = createClient();\n-\n-        MyWatcher watcher = new MyWatcher();\n-        ZooKeeper zk2 = createClient(watcher);\n+        zk2 = createClient(watcher2);\n \n         // 110 character base path\n         String pathBase = \"/long-path-000000000-111111111-222222222-333333333-444444444-\"\n@@ -218,9 +235,10 @@ public void testManyChildWatchersAutoReset() throws Exception {\n         }\n \n         stopServer();\n-        watcher.waitForDisconnected(30000);\n+        watcher2.waitForDisconnected(30000);\n         startServer();\n-        watcher.waitForConnected(30000);\n+        watcher2.waitForConnected(30000);\n+        watcher1.waitForConnected(30000);\n \n         // Trigger the watches and ensure they properly propagate to the client\n         i = 0;",
      "parent_sha": "ad8cfd07ff0ccd77aa97ebb0c247a2fe7e067527"
    }
  },
  {
    "oid": "6022e03177b21606575152ac323205af3fbbe9d8",
    "message": "ZOOKEEPER-4220: Potential redundant connection attempts during leader election\n\nWe have a logic in the server code, that would try to connect to an other quorum member, based\non its server ID. We identify the address assigned to this ID first based on the last committed\nquorum configuration. If the connection attempt fails (or the server is not known in the\ncommitted configuration) then we try to find the address based on the last proposed quorum\nconfiguration. But we should do the second connection attempt, only if the address in the\nlast proposed configuration differs from the address in the last committed configuration.\nOtherwise we would just retry to connect to the same address that failed just right before.\n\nIn the current code we have a bug, because we compare the address object references (use \"!=\")\ninstead of comparing the objects themselves (using \"not equals\"). In certain edge cases (e.g.\nwhen the last proposed and last committed addresses are the same, but the address is unreachable)\nthis bug can lead to unnecessary retry of connection attempts. The normal behaviour would be to\nmark this connection attempt to be failed and wait for e.g. the next election round or wait for\nthe other server to come online and initiate a connection to us.\n\nAuthor: Mate Szalay-Beko <symat@apache.org>\n\nReviewers: Andor Molnar <anmolnar@apache.org>, Damien Diederen <ddiederen@apache.org>\n\nCloses #1615 from symat/ZOOKEEPER-4220",
    "date": "2021-03-06T20:52:24Z",
    "url": "https://github.com/apache/zookeeper/commit/6022e03177b21606575152ac323205af3fbbe9d8",
    "details": {
      "sha": "2f240e9bf95e4379f413b63ff5133a7495c474e6",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/6022e03177b21606575152ac323205af3fbbe9d8/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumCnxManager.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/6022e03177b21606575152ac323205af3fbbe9d8/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumCnxManager.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumCnxManager.java?ref=6022e03177b21606575152ac323205af3fbbe9d8",
      "patch": "@@ -768,7 +768,7 @@ synchronized void connectOne(long sid) {\n             if (lastSeenQV != null\n                 && lastProposedView.containsKey(sid)\n                 && (!knownId\n-                    || (lastProposedView.get(sid).electionAddr != lastCommittedView.get(sid).electionAddr))) {\n+                    || !lastProposedView.get(sid).electionAddr.equals(lastCommittedView.get(sid).electionAddr))) {\n                 knownId = true;\n                 LOG.debug(\"Server {} knows {} already, it is in the lastProposedView\", self.getId(), sid);\n ",
      "parent_sha": "1214d3bf611d153ae8c3987523da01d3d6c82686"
    }
  },
  {
    "oid": "2581f71dd97cfda2cf6768c3457b81c7a93b9ef7",
    "message": "ZOOKEEPER-3760: remove a useless throwing CliException\n\nhttps://issues.apache.org/jira/browse/ZOOKEEPER-3760\n\nWhen I upgrade zookeeper from 3.4.13 to 3.5.7 in my application, I find the function processCmd in ZooKeeperMain.java throws a CliException which has been caught in the function. So I think it can be removed\n\nAuthor: lingjinjiang <lingjinjiang@gmail.com>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>, Norbert Kalmar <nkalmar@apache.org>\n\nCloses #1286 from lingjinjiang/master",
    "date": "2020-03-26T17:41:57Z",
    "url": "https://github.com/apache/zookeeper/commit/2581f71dd97cfda2cf6768c3457b81c7a93b9ef7",
    "details": {
      "sha": "8d8a419401fbdd6d80584d7090511524815b6c36",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/ZooKeeperMain.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/apache/zookeeper/blob/2581f71dd97cfda2cf6768c3457b81c7a93b9ef7/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2FZooKeeperMain.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/2581f71dd97cfda2cf6768c3457b81c7a93b9ef7/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2FZooKeeperMain.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2FZooKeeperMain.java?ref=2581f71dd97cfda2cf6768c3457b81c7a93b9ef7",
      "patch": "@@ -289,7 +289,7 @@ protected void connectToZK(String newHost) throws InterruptedException, IOExcept\n         zk = new ZooKeeperAdmin(host, Integer.parseInt(cl.getOption(\"timeout\")), new MyWatcher(), readOnly);\n     }\n \n-    public static void main(String[] args) throws CliException, IOException, InterruptedException {\n+    public static void main(String[] args) throws IOException, InterruptedException {\n         ZooKeeperMain main = new ZooKeeperMain(args);\n         main.run();\n     }\n@@ -304,7 +304,7 @@ public ZooKeeperMain(ZooKeeper zk) {\n         this.zk = zk;\n     }\n \n-    void run() throws CliException, IOException, InterruptedException {\n+    void run() throws IOException, InterruptedException {\n         if (cl.getCommand() == null) {\n             System.out.println(\"Welcome to ZooKeeper!\");\n \n@@ -353,7 +353,7 @@ void run() throws CliException, IOException, InterruptedException {\n         ServiceUtils.requestSystemExit(exitCode);\n     }\n \n-    public void executeLine(String line) throws CliException, InterruptedException, IOException {\n+    public void executeLine(String line) throws InterruptedException, IOException {\n         if (!line.equals(\"\")) {\n             cl.parseCommand(line);\n             addToHistory(commandCount, line);\n@@ -362,7 +362,7 @@ public void executeLine(String line) throws CliException, InterruptedException,\n         }\n     }\n \n-    protected boolean processCmd(MyCommandOptions co) throws CliException, IOException, InterruptedException {\n+    protected boolean processCmd(MyCommandOptions co) throws IOException, InterruptedException {\n         boolean watch = false;\n         try {\n             watch = processZKCmd(co);",
      "parent_sha": "64863119bf92893f3c72350fd37005083b587327"
    }
  },
  {
    "oid": "b51b1ee6291ecfb578dcf7ec6bbbc83e900ffd15",
    "message": "ZOOKEEPER-3831: Added testBasicUsageOfApisAndRecipesInCluster()\n\nWe should test Curator's `TestingCluster` too\n\nAuthor: Jordan Zimmerman <jordan@jordanzimmerman.com>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>, Micheal Han <hanm@apache.org>\n\nCloses #1375 from Randgalt/ZOOKEEPER-3831-add-compatibility-test-module-pt2",
    "date": "2020-10-02T16:05:38Z",
    "url": "https://github.com/apache/zookeeper/commit/b51b1ee6291ecfb578dcf7ec6bbbc83e900ffd15",
    "details": {
      "sha": "fbb387601bdb1292fefafdfdedfce3f3ddd1b4bc",
      "filename": "zookeeper-compatibility-tests/zookeeper-compatibility-tests-curator/src/test/java/org/apache/zookeeper/compatibility/TestApacheCuratorCompatibility.java",
      "status": "modified",
      "additions": 30,
      "deletions": 17,
      "changes": 47,
      "blob_url": "https://github.com/apache/zookeeper/blob/b51b1ee6291ecfb578dcf7ec6bbbc83e900ffd15/zookeeper-compatibility-tests%2Fzookeeper-compatibility-tests-curator%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fcompatibility%2FTestApacheCuratorCompatibility.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/b51b1ee6291ecfb578dcf7ec6bbbc83e900ffd15/zookeeper-compatibility-tests%2Fzookeeper-compatibility-tests-curator%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fcompatibility%2FTestApacheCuratorCompatibility.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-compatibility-tests%2Fzookeeper-compatibility-tests-curator%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fcompatibility%2FTestApacheCuratorCompatibility.java?ref=b51b1ee6291ecfb578dcf7ec6bbbc83e900ffd15",
      "patch": "@@ -27,6 +27,7 @@\n import org.apache.curator.framework.CuratorFrameworkFactory;\n import org.apache.curator.framework.recipes.cache.CuratorCache;\n import org.apache.curator.retry.RetryOneTime;\n+import org.apache.curator.test.TestingCluster;\n import org.apache.curator.test.TestingServer;\n import org.junit.jupiter.api.Test;\n \n@@ -40,26 +41,38 @@ public class TestApacheCuratorCompatibility {\n     @Test\n     public void testBasicUsageOfApisAndRecipes() throws Exception {\n         try (TestingServer server = new TestingServer()) {\n-            RetryOneTime retryPolicy = new RetryOneTime(1);\n-            try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), retryPolicy)) {\n-                try (CuratorCache cache = CuratorCache.build(client, \"/base/path\")) {\n-                    client.start();\n-                    cache.start();\n+            doTest(server.getConnectString());\n+        }\n+    }\n+\n+    @Test\n+    public void testBasicUsageOfApisAndRecipesInCluster() throws Exception {\n+        try (TestingCluster cluster = new TestingCluster(3)) {\n+            cluster.start();\n+            doTest(cluster.getConnectString());\n+        }\n+    }\n+\n+    private void doTest(String connectionString) throws Exception {\n+        RetryOneTime retryPolicy = new RetryOneTime(1);\n+        try (CuratorFramework client = CuratorFrameworkFactory.newClient(connectionString, retryPolicy)) {\n+            try (CuratorCache cache = CuratorCache.build(client, \"/base/path\")) {\n+                client.start();\n+                cache.start();\n \n-                    BlockingQueue<String> paths = new LinkedBlockingQueue<>();\n-                    cache.listenable().addListener((dummy1, dummy2, data) -> paths.add(data.getPath()));\n+                BlockingQueue<String> paths = new LinkedBlockingQueue<>();\n+                cache.listenable().addListener((dummy1, dummy2, data) -> paths.add(data.getPath()));\n \n-                    client.create().creatingParentsIfNeeded().forPath(\"/base/path/1\");\n-                    client.create().creatingParentsIfNeeded().forPath(\"/base/path/2\");\n-                    client.create().creatingParentsIfNeeded().forPath(\"/base/path/1/a\");\n-                    client.create().creatingParentsIfNeeded().forPath(\"/base/path/2/a\");\n+                client.create().creatingParentsIfNeeded().forPath(\"/base/path/1\");\n+                client.create().creatingParentsIfNeeded().forPath(\"/base/path/2\");\n+                client.create().creatingParentsIfNeeded().forPath(\"/base/path/1/a\");\n+                client.create().creatingParentsIfNeeded().forPath(\"/base/path/2/a\");\n \n-                    assertEquals(\"/base/path\", poll(paths));\n-                    assertEquals(\"/base/path/1\", poll(paths));\n-                    assertEquals(\"/base/path/2\", poll(paths));\n-                    assertEquals(\"/base/path/1/a\", poll(paths));\n-                    assertEquals(\"/base/path/2/a\", poll(paths));\n-                }\n+                assertEquals(\"/base/path\", poll(paths));\n+                assertEquals(\"/base/path/1\", poll(paths));\n+                assertEquals(\"/base/path/2\", poll(paths));\n+                assertEquals(\"/base/path/1/a\", poll(paths));\n+                assertEquals(\"/base/path/2/a\", poll(paths));\n             }\n         }\n     }",
      "parent_sha": "495906063078a477e26f4e99e14dfe8f89007625"
    }
  },
  {
    "oid": "a9517d88605ed61fed8f3dfdc2f5a04dfbcee1f8",
    "message": "[ZOOKEEPER-4677] Cleanup code in the DataTree class  (#1968)\n\nSigned-off-by: tison <wander4096@gmail.com>",
    "date": "2023-02-27T06:28:59Z",
    "url": "https://github.com/apache/zookeeper/commit/a9517d88605ed61fed8f3dfdc2f5a04dfbcee1f8",
    "details": {
      "sha": "a6f605390895e5b6b0c1d6949adae4dfe6ab54e9",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/DataTree.java",
      "status": "modified",
      "additions": 122,
      "deletions": 151,
      "changes": 273,
      "blob_url": "https://github.com/apache/zookeeper/blob/a9517d88605ed61fed8f3dfdc2f5a04dfbcee1f8/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FDataTree.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/a9517d88605ed61fed8f3dfdc2f5a04dfbcee1f8/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FDataTree.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FDataTree.java?ref=a9517d88605ed61fed8f3dfdc2f5a04dfbcee1f8",
      "patch": "@@ -86,10 +86,9 @@\n \n /**\n  * This class maintains the tree data structure. It doesn't have any networking\n- * or client connection code in it so that it can be tested in a stand alone\n- * way.\n- * <p>\n- * The tree maintains two parallel data structures: a hashtable that maps from\n+ * or client connection code in it so that it can be tested in a standalone way.\n+ *\n+ * <p>The tree maintains two parallel data structures: a hashtable that maps from\n  * full paths to DataNodes and a tree of DataNodes. All accesses to a path is\n  * through the hashtable. The tree is traversed only when serializing to disk.\n  */\n@@ -100,7 +99,7 @@ public class DataTree {\n     private final RateLogger RATE_LOGGER = new RateLogger(LOG, 15 * 60 * 1000);\n \n     /**\n-     * This map provides a fast lookup to the datanodes. The tree is the\n+     * This map provides a fast lookup to the data nodes. The tree is the\n      * source of truth and is where all the locking occurs\n      */\n     private final NodeHashMap nodes;\n@@ -118,7 +117,7 @@ public class DataTree {\n     /** the zookeeper nodes that acts as the management and status node **/\n     private static final String procZookeeper = Quotas.procZookeeper;\n \n-    /** this will be the string thats stored as a child of root */\n+    /** this will be the string that's stored as a child of root */\n     private static final String procChildZookeeper = procZookeeper.substring(1);\n \n     /**\n@@ -127,7 +126,7 @@ public class DataTree {\n      */\n     private static final String quotaZookeeper = Quotas.quotaZookeeper;\n \n-    /** this will be the string thats stored as a child of /zookeeper */\n+    /** this will be the string that's stored as a child of /zookeeper */\n     private static final String quotaChildZookeeper = quotaZookeeper.substring(procZookeeper.length() + 1);\n \n     /**\n@@ -136,7 +135,7 @@ public class DataTree {\n      */\n     private static final String configZookeeper = ZooDefs.CONFIG_NODE;\n \n-    /** this will be the string thats stored as a child of /zookeeper */\n+    /** this will be the string that's stored as a child of /zookeeper */\n     private static final String configChildZookeeper = configZookeeper.substring(procZookeeper.length() + 1);\n \n     /**\n@@ -145,7 +144,7 @@ public class DataTree {\n     private final PathTrie pTrie = new PathTrie();\n \n     /**\n-     * over-the-wire size of znode's stat. Counting the fields of Stat class\n+     * over-the-wire size of znode stat. Counting the fields of Stat class\n      */\n     public static final int STAT_OVERHEAD_BYTES = (6 * 8) + (5 * 4);\n \n@@ -186,21 +185,19 @@ public class DataTree {\n     private final List<DigestWatcher> digestWatchers = new ArrayList<>();\n \n     // The historical digests list.\n-    private LinkedList<ZxidDigest> digestLog = new LinkedList<>();\n+    private final LinkedList<ZxidDigest> digestLog = new LinkedList<>();\n \n     private final DigestCalculator digestCalculator;\n \n     @SuppressWarnings(\"unchecked\")\n     public Set<String> getEphemerals(long sessionId) {\n-        HashSet<String> retv = ephemerals.get(sessionId);\n-        if (retv == null) {\n+        HashSet<String> ret = ephemerals.get(sessionId);\n+        if (ret == null) {\n             return new HashSet<>();\n         }\n-        Set<String> cloned = null;\n-        synchronized (retv) {\n-            cloned = (HashSet<String>) retv.clone();\n+        synchronized (ret) {\n+            return (HashSet<String>) ret.clone();\n         }\n-        return cloned;\n     }\n \n     public Set<String> getContainers() {\n@@ -287,11 +284,11 @@ public DataTree() {\n         this.digestCalculator = digestCalculator;\n         nodes = new NodeHashMapImpl(digestCalculator);\n \n-        /* Rather than fight it, let root have an alias */\n+        // rather than fight it, let root have an alias\n         nodes.put(\"\", root);\n         nodes.putWithoutDigest(rootZookeeper, root);\n \n-        /** add the proc node and quota node */\n+        // add the proc node and quota node\n         root.addChild(procChildZookeeper);\n         nodes.put(procZookeeper, procDataNode);\n \n@@ -326,7 +323,7 @@ public void addConfigNode() {\n         try {\n             // Reconfig node is access controlled by default (ZOOKEEPER-2014).\n             setACL(configZookeeper, ZooDefs.Ids.READ_ACL_UNSAFE, -1);\n-        } catch (KeeperException.NoNodeException e) {\n+        } catch (NoNodeException e) {\n             assert false : \"There's no \" + configZookeeper + \" znode - this should never happen.\";\n         }\n     }\n@@ -382,21 +379,19 @@ public static void copyStat(Stat from, Stat to) {\n      *            the diff to be added to the count\n      */\n     public void updateQuotaStat(String lastPrefix, long bytesDiff, int countDiff) {\n-\n         String statNodePath = Quotas.statPath(lastPrefix);\n         DataNode statNode = nodes.get(statNodePath);\n \n-        StatsTrack updatedStat;\n         if (statNode == null) {\n             // should not happen\n             LOG.error(\"Missing node for stat {}\", statNodePath);\n             return;\n         }\n+\n         synchronized (statNode) {\n-            updatedStat = new StatsTrack(statNode.data);\n+            StatsTrack updatedStat = new StatsTrack(statNode.data);\n             updatedStat.setCount(updatedStat.getCount() + countDiff);\n             updatedStat.setBytes(updatedStat.getBytes() + bytesDiff);\n-\n             statNode.data = updatedStat.getStatsBytes();\n         }\n     }\n@@ -441,32 +436,32 @@ public void createNode(final String path, byte[] data, List<ACL> acl, long ephem\n      * @throws NodeExistsException\n      * @throws NoNodeException\n      */\n-    public void createNode(final String path, byte[] data, List<ACL> acl, long ephemeralOwner, int parentCVersion, long zxid, long time, Stat outputStat) throws KeeperException.NoNodeException, KeeperException.NodeExistsException {\n+    public void createNode(final String path, byte[] data, List<ACL> acl, long ephemeralOwner, int parentCVersion, long zxid, long time, Stat outputStat) throws NoNodeException, NodeExistsException {\n         int lastSlash = path.lastIndexOf('/');\n         String parentName = path.substring(0, lastSlash);\n         String childName = path.substring(lastSlash + 1);\n         StatPersisted stat = createStat(zxid, time, ephemeralOwner);\n         DataNode parent = nodes.get(parentName);\n         if (parent == null) {\n-            throw new KeeperException.NoNodeException();\n+            throw new NoNodeException();\n         }\n         synchronized (parent) {\n             // Add the ACL to ACL cache first, to avoid the ACL not being\n             // created race condition during fuzzy snapshot sync.\n             //\n             // This is the simplest fix, which may add ACL reference count\n-            // again if it's already counted in in the ACL map of fuzzy\n+            // again if it's already counted in the ACL map of fuzzy\n             // snapshot, which might also happen for deleteNode txn, but\n             // at least it won't cause the ACL not exist issue.\n             //\n             // Later we can audit and delete all non-referenced ACLs from\n             // ACL map when loading the snapshot/txns from disk, like what\n             // we did for the global sessions.\n-            Long longval = aclCache.convertAcls(acl);\n+            Long acls = aclCache.convertAcls(acl);\n \n             Set<String> children = parent.getChildren();\n             if (children.contains(childName)) {\n-                throw new KeeperException.NodeExistsException();\n+                throw new NodeExistsException();\n             }\n \n             nodes.preChange(parentName, parent);\n@@ -483,7 +478,7 @@ public void createNode(final String path, byte[] data, List<ACL> acl, long ephem\n                 parent.stat.setCversion(parentCVersion);\n                 parent.stat.setPzxid(zxid);\n             }\n-            DataNode child = new DataNode(data, longval, stat);\n+            DataNode child = new DataNode(data, acls, stat);\n             parent.addChild(childName);\n             nodes.postChange(parentName, parent);\n             nodeDataSize.addAndGet(getNodeSize(path, child.data));\n@@ -494,11 +489,7 @@ public void createNode(final String path, byte[] data, List<ACL> acl, long ephem\n             } else if (ephemeralType == EphemeralType.TTL) {\n                 ttls.add(path);\n             } else if (ephemeralOwner != 0) {\n-                HashSet<String> list = ephemerals.get(ephemeralOwner);\n-                if (list == null) {\n-                    list = new HashSet<>();\n-                    ephemerals.put(ephemeralOwner, list);\n-                }\n+                HashSet<String> list = ephemerals.computeIfAbsent(ephemeralOwner, k -> new HashSet<>());\n                 synchronized (list) {\n                     list.add(path);\n                 }\n@@ -509,7 +500,7 @@ public void createNode(final String path, byte[] data, List<ACL> acl, long ephem\n         }\n         // now check if its one of the zookeeper node child\n         if (parentName.startsWith(quotaZookeeper)) {\n-            // now check if its the limit node\n+            // now check if it's the limit node\n             if (Quotas.limitNode.equals(childName)) {\n                 // this is the limit node\n                 // get the parent and add it to the trie\n@@ -538,9 +529,9 @@ public void createNode(final String path, byte[] data, List<ACL> acl, long ephem\n      *            the path to of the node to be deleted\n      * @param zxid\n      *            the current zxid\n-     * @throws KeeperException.NoNodeException\n+     * @throws NoNodeException\n      */\n-    public void deleteNode(String path, long zxid) throws KeeperException.NoNodeException {\n+    public void deleteNode(String path, long zxid) throws NoNodeException {\n         int lastSlash = path.lastIndexOf('/');\n         String parentName = path.substring(0, lastSlash);\n         String childName = path.substring(lastSlash + 1);\n@@ -550,14 +541,14 @@ public void deleteNode(String path, long zxid) throws KeeperException.NoNodeExce\n         // for no such child\n         DataNode parent = nodes.get(parentName);\n         if (parent == null) {\n-            throw new KeeperException.NoNodeException();\n+            throw new NoNodeException();\n         }\n         synchronized (parent) {\n             nodes.preChange(parentName, parent);\n             parent.removeChild(childName);\n             // Only update pzxid when the zxid is larger than the current pzxid,\n-            // otherwise we might override some higher pzxid set by a create\n-            // Txn, which could cause the cversion and pzxid inconsistent\n+            // otherwise we might override some higher pzxid set by a CreateTxn,\n+            // which could cause the cversion and pzxid inconsistent\n             if (zxid > parent.stat.getPzxid()) {\n                 parent.stat.setPzxid(zxid);\n             }\n@@ -566,7 +557,7 @@ public void deleteNode(String path, long zxid) throws KeeperException.NoNodeExce\n \n         DataNode node = nodes.get(path);\n         if (node == null) {\n-            throw new KeeperException.NoNodeException();\n+            throw new NoNodeException();\n         }\n         nodes.remove(path);\n         synchronized (node) {\n@@ -578,14 +569,14 @@ public void deleteNode(String path, long zxid) throws KeeperException.NoNodeExce\n         // only need to sync on containers and ttls, will update it in a\n         // separate patch.\n         synchronized (parent) {\n-            long eowner = node.stat.getEphemeralOwner();\n-            EphemeralType ephemeralType = EphemeralType.get(eowner);\n+            long owner = node.stat.getEphemeralOwner();\n+            EphemeralType ephemeralType = EphemeralType.get(owner);\n             if (ephemeralType == EphemeralType.CONTAINER) {\n                 containers.remove(path);\n             } else if (ephemeralType == EphemeralType.TTL) {\n                 ttls.remove(path);\n-            } else if (eowner != 0) {\n-                Set<String> nodes = ephemerals.get(eowner);\n+            } else if (owner != 0) {\n+                Set<String> nodes = ephemerals.get(owner);\n                 if (nodes != null) {\n                     synchronized (nodes) {\n                         nodes.remove(path);\n@@ -604,7 +595,7 @@ public void deleteNode(String path, long zxid) throws KeeperException.NoNodeExce\n         String lastPrefix = getMaxPrefixWithQuota(path);\n         if (lastPrefix != null) {\n             // ok we have some match and need to update\n-            long bytes = 0;\n+            long bytes;\n             synchronized (node) {\n                 bytes = (node.data == null ? 0 : -(node.data.length));\n             }\n@@ -629,15 +620,15 @@ public void deleteNode(String path, long zxid) throws KeeperException.NoNodeExce\n         childWatches.triggerWatch(\"\".equals(parentName) ? \"/\" : parentName, EventType.NodeChildrenChanged);\n     }\n \n-    public Stat setData(String path, byte[] data, int version, long zxid, long time) throws KeeperException.NoNodeException {\n+    public Stat setData(String path, byte[] data, int version, long zxid, long time) throws NoNodeException {\n         Stat s = new Stat();\n         DataNode n = nodes.get(path);\n         if (n == null) {\n-            throw new KeeperException.NoNodeException();\n+            throw new NoNodeException();\n         }\n-        byte[] lastdata = null;\n+        byte[] lastData;\n         synchronized (n) {\n-            lastdata = n.data;\n+            lastData = n.data;\n             nodes.preChange(path, n);\n             n.data = data;\n             n.stat.setMtime(time);\n@@ -649,13 +640,13 @@ public Stat setData(String path, byte[] data, int version, long zxid, long time)\n \n         // first do a quota check if the path is in a quota subtree.\n         String lastPrefix = getMaxPrefixWithQuota(path);\n-        long bytesDiff = (data == null ? 0 : data.length) - (lastdata == null ? 0 : lastdata.length);\n+        long bytesDiff = (data == null ? 0 : data.length) - (lastData == null ? 0 : lastData.length);\n         // now update if the path is in a quota subtree.\n         long dataBytes = data == null ? 0 : data.length;\n         if (lastPrefix != null) {\n             updateQuotaStat(lastPrefix, bytesDiff, 0);\n         }\n-        nodeDataSize.addAndGet(getNodeSize(path, data) - getNodeSize(path, lastdata));\n+        nodeDataSize.addAndGet(getNodeSize(path, data) - getNodeSize(path, lastData));\n \n         updateWriteStat(path, dataBytes);\n         dataWatches.triggerWatch(path, EventType.NodeDataChanged);\n@@ -687,12 +678,12 @@ public void addWatch(String basePath, Watcher watcher, int mode) {\n         childWatches.addWatch(basePath, watcher, watcherMode);\n     }\n \n-    public byte[] getData(String path, Stat stat, Watcher watcher) throws KeeperException.NoNodeException {\n+    public byte[] getData(String path, Stat stat, Watcher watcher) throws NoNodeException {\n         DataNode n = nodes.get(path);\n-        byte[] data = null;\n         if (n == null) {\n-            throw new KeeperException.NoNodeException();\n+            throw new NoNodeException();\n         }\n+        byte[] data;\n         synchronized (n) {\n             n.copyStat(stat);\n             if (watcher != null) {\n@@ -704,26 +695,26 @@ public byte[] getData(String path, Stat stat, Watcher watcher) throws KeeperExce\n         return data;\n     }\n \n-    public Stat statNode(String path, Watcher watcher) throws KeeperException.NoNodeException {\n-        Stat stat = new Stat();\n-        DataNode n = nodes.get(path);\n+    public Stat statNode(String path, Watcher watcher) throws NoNodeException {\n         if (watcher != null) {\n             dataWatches.addWatch(path, watcher);\n         }\n+        DataNode n = nodes.get(path);\n         if (n == null) {\n-            throw new KeeperException.NoNodeException();\n+            throw new NoNodeException();\n         }\n+        Stat stat = new Stat();\n         synchronized (n) {\n             n.copyStat(stat);\n         }\n         updateReadStat(path, 0L);\n         return stat;\n     }\n \n-    public List<String> getChildren(String path, Stat stat, Watcher watcher) throws KeeperException.NoNodeException {\n+    public List<String> getChildren(String path, Stat stat, Watcher watcher) throws NoNodeException {\n         DataNode n = nodes.get(path);\n         if (n == null) {\n-            throw new KeeperException.NoNodeException();\n+            throw new NoNodeException();\n         }\n         List<String> children;\n         synchronized (n) {\n@@ -747,21 +738,21 @@ public List<String> getChildren(String path, Stat stat, Watcher watcher) throws\n     }\n \n     public int getAllChildrenNumber(String path) {\n-        //cull out these two keys:\"\", \"/\"\n+        // cull out these two keys:\"\", \"/\"\n         if (\"/\".equals(path)) {\n             return nodes.size() - 2;\n         }\n \n         return (int) nodes.entrySet().parallelStream().filter(entry -> entry.getKey().startsWith(path + \"/\")).count();\n     }\n \n-    public Stat setACL(String path, List<ACL> acl, int version) throws KeeperException.NoNodeException {\n-        Stat stat = new Stat();\n+    public Stat setACL(String path, List<ACL> acl, int version) throws NoNodeException {\n         DataNode n = nodes.get(path);\n         if (n == null) {\n-            throw new KeeperException.NoNodeException();\n+            throw new NoNodeException();\n         }\n         synchronized (n) {\n+            Stat stat = new Stat();\n             aclCache.removeUsage(n.acl);\n             nodes.preChange(path, n);\n             n.stat.setAversion(version);\n@@ -772,10 +763,10 @@ public Stat setACL(String path, List<ACL> acl, int version) throws KeeperExcepti\n         }\n     }\n \n-    public List<ACL> getACL(String path, Stat stat) throws KeeperException.NoNodeException {\n+    public List<ACL> getACL(String path, Stat stat) throws NoNodeException {\n         DataNode n = nodes.get(path);\n         if (n == null) {\n-            throw new KeeperException.NoNodeException();\n+            throw new NoNodeException();\n         }\n         synchronized (n) {\n             if (stat != null) {\n@@ -829,7 +820,7 @@ public boolean equals(Object o) {\n         }\n \n         /**\n-         * See equals() to find the rational for how this hashcode is generated.\n+         * See equals() to find the rationale for how this hashcode is generated.\n          *\n          * @see ProcessTxnResult#equals(Object)\n          * @see java.lang.Object#hashCode()\n@@ -977,7 +968,7 @@ public ProcessTxnResult processTxn(TxnHeader header, Record txn, boolean isSubTx\n                 boolean post_failed = false;\n                 for (Txn subtxn : txns) {\n                     ByteBuffer bb = ByteBuffer.wrap(subtxn.getData());\n-                    Record record = null;\n+                    Record record;\n                     switch (subtxn.getType()) {\n                     case OpCode.create:\n                         record = new CreateTxn();\n@@ -1005,7 +996,8 @@ record = new CheckVersionTxn();\n                     default:\n                         throw new IOException(\"Invalid type of op: \" + subtxn.getType());\n                     }\n-                    assert (record != null);\n+\n+                    assert record != null;\n \n                     ByteBufferInputStream.byteBuffer2Record(bb, record);\n \n@@ -1049,7 +1041,7 @@ record = new ErrorTxn(ec);\n          * But there is a tricky scenario that if the child is deleted due\n          * to session close and re-created in a different global session\n          * after that the parent is serialized, then when replay the txn\n-         * because the node is belonging to a different session, replay the\n+         * because the node belongs to a different session, replay the\n          * closeSession txn won't delete it anymore, and we'll get NODEEXISTS\n          * error when replay the createNode txn. In this case, we need to\n          * update the cversion and pzxid to the new value.\n@@ -1064,7 +1056,7 @@ record = new ErrorTxn(ec);\n             CreateTxn cTxn = (CreateTxn) txn;\n             try {\n                 setCversionPzxid(parentName, cTxn.getParentCVersion(), header.getZxid());\n-            } catch (KeeperException.NoNodeException e) {\n+            } catch (NoNodeException e) {\n                 LOG.error(\"Failed to set parent cversion for: {}\", parentName, e);\n                 rc.err = e.code().intValue();\n             }\n@@ -1118,7 +1110,7 @@ record = new ErrorTxn(ec);\n     }\n \n     void killSession(long session, long zxid) {\n-        // the list is already removed from the ephemerals\n+        // The list is already removed from the ephemerals,\n         // so we do not have to worry about synchronizing on\n         // the list. This is only called from FinalRequestProcessor\n         // so there is no need for synchronization. The list is not\n@@ -1182,33 +1174,28 @@ void deleteNodes(long session, long zxid, Iterable<String> paths2Delete) {\n     }\n \n     /**\n-     * a encapsultaing class for return value\n+     * An encapsulation class for return value\n      */\n     private static class Counts {\n-\n         long bytes;\n         int count;\n-\n     }\n \n     /**\n      * this method gets the count of nodes and the bytes under a subtree\n      *\n-     * @param path\n-     *            the path to be used\n-     * @param counts\n-     *            the int count\n+     * @param path the path to be used\n+     * @param counts the int count\n      */\n     private void getCounts(String path, Counts counts) {\n         DataNode node = getNode(path);\n         if (node == null) {\n             return;\n         }\n-        String[] children = null;\n-        int len = 0;\n+        String[] children;\n+        int len;\n         synchronized (node) {\n-            Set<String> childs = node.getChildren();\n-            children = childs.toArray(new String[childs.size()]);\n+            children = node.getChildren().toArray(new String[0]);\n             len = (node.data == null ? 0 : node.data.length);\n         }\n         // add itself\n@@ -1222,15 +1209,14 @@ private void getCounts(String path, Counts counts) {\n     /**\n      * update the quota for the given path\n      *\n-     * @param path\n-     *            the path to be used\n+     * @param path the path to be used\n      */\n     private void updateQuotaForPath(String path) {\n         Counts c = new Counts();\n         getCounts(path, c);\n-        StatsTrack strack = new StatsTrack();\n-        strack.setBytes(c.bytes);\n-        strack.setCount(c.count);\n+        StatsTrack statsTrack = new StatsTrack();\n+        statsTrack.setBytes(c.bytes);\n+        statsTrack.setCount(c.count);\n         String statPath = Quotas.statPath(path);\n         DataNode node = getNode(statPath);\n         // it should exist\n@@ -1240,27 +1226,26 @@ private void updateQuotaForPath(String path) {\n         }\n         synchronized (node) {\n             nodes.preChange(statPath, node);\n-            node.data = strack.getStatsBytes();\n+            node.data = statsTrack.getStatsBytes();\n             nodes.postChange(statPath, node);\n         }\n     }\n \n     /**\n      * this method traverses the quota path and update the path trie and sets\n      *\n-     * @param path\n+     * @param path the path to be used\n      */\n     private void traverseNode(String path) {\n         DataNode node = getNode(path);\n-        String[] children = null;\n+        String[] children;\n         synchronized (node) {\n-            Set<String> childs = node.getChildren();\n-            children = childs.toArray(new String[childs.size()]);\n+            children = node.getChildren().toArray(new String[0]);\n         }\n         if (children.length == 0) {\n             // this node does not have a child\n             // is the leaf node\n-            // check if its the leaf node\n+            // check if it's the leaf node\n             String endString = \"/\" + Quotas.limitNode;\n             if (path.endsWith(endString)) {\n                 // ok this is the limit node\n@@ -1293,10 +1278,8 @@ private void setupQuota() {\n      * this method uses a stringbuilder to create a new path for children. This\n      * is faster than string appends ( str1 + str2).\n      *\n-     * @param oa\n-     *            OutputArchive to write to.\n-     * @param path\n-     *            a string builder.\n+     * @param oa OutputArchive to write to.\n+     * @param path a string builder.\n      * @throws IOException\n      */\n     void serializeNode(OutputArchive oa, StringBuilder path) throws IOException {\n@@ -1305,31 +1288,28 @@ void serializeNode(OutputArchive oa, StringBuilder path) throws IOException {\n         if (node == null) {\n             return;\n         }\n-        String[] children = null;\n+        String[] children;\n         DataNode nodeCopy;\n         synchronized (node) {\n             StatPersisted statCopy = new StatPersisted();\n             copyStatPersisted(node.stat, statCopy);\n             //we do not need to make a copy of node.data because the contents\n             //are never changed\n             nodeCopy = new DataNode(node.data, node.acl, statCopy);\n-            Set<String> childs = node.getChildren();\n-            children = childs.toArray(new String[childs.size()]);\n+            children = node.getChildren().toArray(new String[0]);\n         }\n         serializeNodeData(oa, pathString, nodeCopy);\n         path.append('/');\n         int off = path.length();\n         for (String child : children) {\n-            // since this is single buffer being resused\n-            // we need\n-            // to truncate the previous bytes of string.\n+            // Since this is single buffer being reused, we need to truncate the previous bytes of string.\n             path.delete(off, Integer.MAX_VALUE);\n             path.append(child);\n             serializeNode(oa, path);\n         }\n     }\n \n-    // visiable for test\n+    // visible for test\n     public void serializeNodeData(OutputArchive oa, String path, DataNode node) throws IOException {\n         oa.writeString(path, \"path\");\n         oa.writeRecord(node, \"node\");\n@@ -1373,25 +1353,18 @@ public void deserialize(InputArchive ia, String tag) throws IOException {\n                 String parentPath = path.substring(0, lastSlash);\n                 DataNode parent = nodes.get(parentPath);\n                 if (parent == null) {\n-                    throw new IOException(\"Invalid Datatree, unable to find \"\n-                                          + \"parent \"\n-                                          + parentPath\n-                                          + \" of path \"\n-                                          + path);\n+                    throw new IOException(\n+                            \"Invalid Datatree, unable to find parent \" + parentPath + \" of path \" + path);\n                 }\n                 parent.addChild(path.substring(lastSlash + 1));\n-                long eowner = node.stat.getEphemeralOwner();\n-                EphemeralType ephemeralType = EphemeralType.get(eowner);\n+                long owner = node.stat.getEphemeralOwner();\n+                EphemeralType ephemeralType = EphemeralType.get(owner);\n                 if (ephemeralType == EphemeralType.CONTAINER) {\n                     containers.add(path);\n                 } else if (ephemeralType == EphemeralType.TTL) {\n                     ttls.add(path);\n-                } else if (eowner != 0) {\n-                    HashSet<String> list = ephemerals.get(eowner);\n-                    if (list == null) {\n-                        list = new HashSet<>();\n-                        ephemerals.put(eowner, list);\n-                    }\n+                } else if (owner != 0) {\n+                    HashSet<String> list = ephemerals.computeIfAbsent(owner, k -> new HashSet<>());\n                     list.add(path);\n                 }\n             }\n@@ -1403,8 +1376,7 @@ public void deserialize(InputArchive ia, String tag) throws IOException {\n \n         nodeDataSize.set(approximateDataSize());\n \n-        // we are done with deserializing the\n-        // the datatree\n+        // we are done with deserializing the datatree\n         // update the quotas - create path trie\n         // and also update the stat nodes\n         setupQuota();\n@@ -1414,19 +1386,19 @@ public void deserialize(InputArchive ia, String tag) throws IOException {\n \n     /**\n      * Summary of the watches on the datatree.\n-     * @param pwriter the output to write to\n+     * @param writer the output to write to\n      */\n-    public synchronized void dumpWatchesSummary(PrintWriter pwriter) {\n-        pwriter.print(dataWatches.toString());\n+    public synchronized void dumpWatchesSummary(PrintWriter writer) {\n+        writer.print(dataWatches.toString());\n     }\n \n     /**\n      * Write a text dump of all the watches on the datatree.\n      * Warning, this is expensive, use sparingly!\n-     * @param pwriter the output to write to\n+     * @param writer the output to write to\n      */\n-    public synchronized void dumpWatches(PrintWriter pwriter, boolean byPath) {\n-        dataWatches.dumpWatches(pwriter, byPath);\n+    public synchronized void dumpWatches(PrintWriter writer, boolean byPath) {\n+        dataWatches.dumpWatches(writer, byPath);\n     }\n \n     /**\n@@ -1461,18 +1433,18 @@ public synchronized WatchesSummary getWatchesSummary() {\n \n     /**\n      * Write a text dump of all the ephemerals in the datatree.\n-     * @param pwriter the output to write to\n+     * @param writer the output to write to\n      */\n-    public void dumpEphemerals(PrintWriter pwriter) {\n-        pwriter.println(\"Sessions with Ephemerals (\" + ephemerals.keySet().size() + \"):\");\n+    public void dumpEphemerals(PrintWriter writer) {\n+        writer.println(\"Sessions with Ephemerals (\" + ephemerals.keySet().size() + \"):\");\n         for (Entry<Long, HashSet<String>> entry : ephemerals.entrySet()) {\n-            pwriter.print(\"0x\" + Long.toHexString(entry.getKey()));\n-            pwriter.println(\":\");\n+            writer.print(\"0x\" + Long.toHexString(entry.getKey()));\n+            writer.println(\":\");\n             Set<String> tmp = entry.getValue();\n             if (tmp != null) {\n                 synchronized (tmp) {\n                     for (String path : tmp) {\n-                        pwriter.println(\"\\t\" + path);\n+                        writer.println(\"\\t\" + path);\n                     }\n                 }\n             }\n@@ -1508,7 +1480,6 @@ public void setWatches(long relativeZxid, List<String> dataWatches, List<String>\n                            List<String> persistentWatches, List<String> persistentRecursiveWatches, Watcher watcher) {\n         for (String path : dataWatches) {\n             DataNode node = getNode(path);\n-            WatchedEvent e = null;\n             if (node == null) {\n                 watcher.process(new WatchedEvent(EventType.NodeDeleted, KeeperState.SyncConnected, path));\n             } else if (node.stat.getMzxid() > relativeZxid) {\n@@ -1558,16 +1529,16 @@ public void setWatches(long relativeZxid, List<String> dataWatches, List<String>\n      *     Value to be assigned to Cversion\n      * @param zxid\n      *     Value to be assigned to Pzxid\n-     * @throws KeeperException.NoNodeException\n+     * @throws NoNodeException\n      *     If znode not found.\n      **/\n-    public void setCversionPzxid(String path, int newCversion, long zxid) throws KeeperException.NoNodeException {\n+    public void setCversionPzxid(String path, int newCversion, long zxid) throws NoNodeException {\n         if (path.endsWith(\"/\")) {\n             path = path.substring(0, path.length() - 1);\n         }\n         DataNode node = nodes.get(path);\n         if (node == null) {\n-            throw new KeeperException.NoNodeException(path);\n+            throw new NoNodeException(path);\n         }\n         synchronized (node) {\n             if (newCversion == -1) {\n@@ -1664,7 +1635,7 @@ private void logZxidDigest(long zxid, long digest) {\n \n     /**\n      * Serializing the digest to snapshot, this is done after the data tree\n-     * is being serialized, so when we replay the txns and it hits this zxid\n+     * is being serialized, so when we replay the txns, and it hits this zxid\n      * we know we should be in a non-fuzzy state, and have the same digest.\n      *\n      * @param oa the output stream to write to\n@@ -1721,12 +1692,12 @@ public boolean deserializeZxidDigest(InputArchive ia, long startZxidOfSnapshot)\n             // epoch + 0, which is not mapping to any txn, and it uses\n             // this to take snapshot, which is possible if we don't\n             // clean database before switching to LOOKING. In this case\n-            // the currentZxidDigest will be the zxid of last epoch and\n+            // the currentZxidDigest will be the zxid of last epoch, and\n             // it's smaller than the zxid of the snapshot file.\n             //\n             // It's safe to reset the targetZxidDigest to null and start\n             // to compare digest when replaying the first txn, since it's\n-            // a non fuzzy snapshot.\n+            // a non-fuzzy snapshot.\n             if (digestFromLoadedSnapshot != null && digestFromLoadedSnapshot.zxid < startZxidOfSnapshot) {\n                 LOG.info(\"The zxid of snapshot digest 0x{} is smaller \"\n                         + \"than the known snapshot highest zxid, the snapshot \"\n@@ -1782,7 +1753,7 @@ public boolean deserializeLastProcessedZxid(final InputArchive ia)  throws IOExc\n \n     /**\n      * Compares the actual tree's digest with that in the snapshot.\n-     * Resets digestFromLoadedSnapshot after comparision.\n+     * Resets digestFromLoadedSnapshot after comparison.\n      *\n      * @param zxid zxid\n      */\n@@ -1801,8 +1772,9 @@ public void compareSnapshotDigests(long zxid) {\n             }\n             digestFromLoadedSnapshot = null;\n         } else if (digestFromLoadedSnapshot.zxid != 0 && zxid > digestFromLoadedSnapshot.zxid) {\n-            RATE_LOGGER.rateLimitLog(\"The txn 0x{} of snapshot digest does not \"\n-                    + \"exist.\", Long.toHexString(digestFromLoadedSnapshot.zxid));\n+            RATE_LOGGER.rateLimitLog(\n+                    \"The txn 0x{} of snapshot digest does not exist.\",\n+                    Long.toHexString(digestFromLoadedSnapshot.zxid));\n         }\n     }\n \n@@ -1814,8 +1786,7 @@ public void compareSnapshotDigests(long zxid) {\n      * @param txn    transaction\n      * @param digest transaction digest\n      *\n-     * @return false if digest in the txn doesn't match what we have now in\n-     *               the data tree\n+     * @return false if digest in the txn doesn't match what we have now in the data tree\n      */\n     public boolean compareDigest(TxnHeader header, Record txn, TxnDigest digest) {\n         long zxid = header.getZxid();\n@@ -1829,8 +1800,7 @@ public boolean compareDigest(TxnHeader header, Record txn, TxnDigest digest) {\n         }\n         // do not compare digest if there is digest version change\n         if (digestCalculator.getDigestVersion() != digest.getVersion()) {\n-            RATE_LOGGER.rateLimitLog(\"Digest version not the same on zxid.\",\n-                    String.valueOf(zxid));\n+            RATE_LOGGER.rateLimitLog(\"Digest version not the same on zxid.\", String.valueOf(zxid));\n             return true;\n         }\n \n@@ -1840,16 +1810,17 @@ public boolean compareDigest(TxnHeader header, Record txn, TxnDigest digest) {\n             reportDigestMismatch(zxid);\n             LOG.debug(\"Digest in log: {}, actual tree: {}\", logDigest, actualDigest);\n             if (firstMismatchTxn) {\n-                LOG.error(\"First digest mismatch on txn: {}, {}, \"\n-                        + \"expected digest is {}, actual digest is {}, \",\n+                LOG.error(\n+                        \"First digest mismatch on txn: {}, {}, expected digest is {}, actual digest is {}, \",\n                         header, txn, digest, actualDigest);\n                 firstMismatchTxn = false;\n             }\n             return false;\n         } else {\n             RATE_LOGGER.flush();\n-            LOG.debug(\"Digests are matching for Zxid: {}, Digest in log \"\n-                    + \"and actual tree: {}\", Long.toHexString(zxid), logDigest);\n+            LOG.debug(\n+                    \"Digests are matching for Zxid: {}, Digest in log and actual tree: {}\",\n+                    Long.toHexString(zxid), logDigest);\n             return true;\n         }\n     }",
      "parent_sha": "ee8014adc748901b642e66c5734082d50b077a84"
    }
  },
  {
    "oid": "b8c8937029ca7e15116e91c6a6c436368ac0f9bb",
    "message": "ZOOKEEPER-3219: Fix flaky FileChangeWatcherTest\n\nMade some changes to handle the random ENTRY_CREATE events that occasionally fire even though the watcher is created after the file is already written to disk. Should make the test more stable.\n\nAuthor: Ilya Maykov <ilyam@fb.com>\n\nCloses #739 from ivmaykov/ZOOKEEPER-3219",
    "date": "2018-12-20T14:07:14Z",
    "url": "https://github.com/apache/zookeeper/commit/b8c8937029ca7e15116e91c6a6c436368ac0f9bb",
    "details": {
      "sha": "2ef6a8625b82edf85800d15896e554d7b4e1d2ed",
      "filename": "zookeeper-server/src/test/java/org/apache/zookeeper/common/FileChangeWatcherTest.java",
      "status": "modified",
      "additions": 30,
      "deletions": 16,
      "changes": 46,
      "blob_url": "https://github.com/apache/zookeeper/blob/b8c8937029ca7e15116e91c6a6c436368ac0f9bb/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fcommon%2FFileChangeWatcherTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/b8c8937029ca7e15116e91c6a6c436368ac0f9bb/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fcommon%2FFileChangeWatcherTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fcommon%2FFileChangeWatcherTest.java?ref=b8c8937029ca7e15116e91c6a6c436368ac0f9bb",
      "patch": "@@ -38,6 +38,7 @@\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n \n public class FileChangeWatcherTest extends ZKTestCase {\n     private static File tempDir;\n@@ -70,6 +71,12 @@ public void testCallbackWorksOnFileChanges() throws IOException, InterruptedExce\n                     tempDir.toPath(),\n                     event -> {\n                         LOG.info(\"Got an update: \" + event.kind() + \" \" + event.context());\n+                        // Filter out the extra ENTRY_CREATE events that are\n+                        // sometimes seen at the start. Even though we create the watcher\n+                        // after the file exists, sometimes we still get a create event.\n+                        if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {\n+                            return;\n+                        }\n                         synchronized (events) {\n                             events.add(event);\n                             events.notifyAll();\n@@ -112,6 +119,12 @@ public void testCallbackWorksOnFileTouched() throws IOException, InterruptedExce\n                     tempDir.toPath(),\n                     event -> {\n                         LOG.info(\"Got an update: \" + event.kind() + \" \" + event.context());\n+                        // Filter out the extra ENTRY_CREATE events that are\n+                        // sometimes seen at the start. Even though we create the watcher\n+                        // after the file exists, sometimes we still get a create event.\n+                        if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {\n+                            return;\n+                        }\n                         synchronized (events) {\n                             events.add(event);\n                             events.notifyAll();\n@@ -184,6 +197,12 @@ public void testCallbackWorksOnFileDeleted() throws IOException, InterruptedExce\n                     tempDir.toPath(),\n                     event -> {\n                         LOG.info(\"Got an update: \" + event.kind() + \" \" + event.context());\n+                        // Filter out the extra ENTRY_CREATE events that are\n+                        // sometimes seen at the start. Even though we create the watcher\n+                        // after the file exists, sometimes we still get a create event.\n+                        if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {\n+                            return;\n+                        }\n                         synchronized (events) {\n                             events.add(event);\n                             events.notifyAll();\n@@ -214,21 +233,18 @@ public void testCallbackWorksOnFileDeleted() throws IOException, InterruptedExce\n     public void testCallbackErrorDoesNotCrashWatcherThread() throws IOException, InterruptedException {\n         FileChangeWatcher watcher = null;\n         try {\n-            final List<WatchEvent<?>> events = new ArrayList<>();\n             final AtomicInteger callCount = new AtomicInteger(0);\n             watcher = new FileChangeWatcher(\n                     tempDir.toPath(),\n                     event -> {\n                         LOG.info(\"Got an update: \" + event.kind() + \" \" + event.context());\n+                        int oldValue;\n                         synchronized (callCount) {\n-                            if (callCount.getAndIncrement() == 0) {\n-                                callCount.notifyAll();\n-                                throw new RuntimeException(\"This error should not crash the watcher thread\");\n-                            }\n+                            oldValue = callCount.getAndIncrement();\n+                            callCount.notifyAll();\n                         }\n-                        synchronized (events) {\n-                            events.add(event);\n-                            events.notifyAll();\n+                        if (oldValue == 0) {\n+                            throw new RuntimeException(\"This error should not crash the watcher thread\");\n                         }\n                     });\n             watcher.start();\n@@ -243,16 +259,14 @@ public void testCallbackErrorDoesNotCrashWatcherThread() throws IOException, Int\n             }\n             LOG.info(\"Modifying file again\");\n             FileUtils.writeStringToFile(tempFile, \"Hello world again\\n\", StandardCharsets.UTF_8, true);\n-            synchronized (events) {\n-                if (events.isEmpty()) {\n-                    events.wait(3000L);\n+            synchronized (callCount) {\n+                if (callCount.get() == 1) {\n+                    callCount.wait(3000L);\n                 }\n-                assertEquals(2, callCount.get());\n-                assertFalse(events.isEmpty());\n-                WatchEvent<?> event = events.get(0);\n-                assertEquals(StandardWatchEventKinds.ENTRY_MODIFY, event.kind());\n-                assertEquals(tempFile.getName(), event.context().toString());\n             }\n+            // The value of callCount can exceed 1 only if the callback thread\n+            // survives the exception thrown by the first callback.\n+            assertTrue(callCount.get() > 1);\n         } finally {\n             if (watcher != null) {\n                 watcher.stop();",
      "parent_sha": "05b774a1b05374618300f657c9c91b0d5c6ddf71"
    }
  },
  {
    "oid": "061438e83e61692fc9e06e057a739db5327d42b9",
    "message": "ZOOKEEPER-3961: Improve error message for zookeeper.intBufferStartingSizeBytes config\n\n\u2026 verification.\n\nAuthor: Ghatage <ghatageanup@gmail.com>\n\nReviewers: Damien Diederen <ddiederen@apache.org>, Andor Molnar <andor@apache.org>,Enrico Olivelli <eolivelli@apache.org>, Mate Szalay-Beko <symat@apache.org>, maoling <maoling@apache.org>\n\nCloses #1495 from Ghatage/ZOOKEEPER-3961",
    "date": "2021-04-04T06:39:26Z",
    "url": "https://github.com/apache/zookeeper/commit/061438e83e61692fc9e06e057a739db5327d42b9",
    "details": {
      "sha": "72e55779cfe3edc8b3f963ed520764953ed45f41",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/061438e83e61692fc9e06e057a739db5327d42b9/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperServer.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/061438e83e61692fc9e06e057a739db5327d42b9/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperServer.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperServer.java?ref=061438e83e61692fc9e06e057a739db5327d42b9",
      "patch": "@@ -251,7 +251,7 @@ protected enum State {\n         intBufferStartingSizeBytes = Integer.getInteger(INT_BUFFER_STARTING_SIZE_BYTES, DEFAULT_STARTING_BUFFER_SIZE);\n \n         if (intBufferStartingSizeBytes < 32) {\n-            String msg = \"Buffer starting size must be greater than 0.\"\n+            String msg = \"Buffer starting size must be greater than or equal to 32.\"\n                          + \"Configure with \\\"-Dzookeeper.intBufferStartingSizeBytes=<size>\\\" \";\n             LOG.error(msg);\n             throw new IllegalArgumentException(msg);",
      "parent_sha": "ad5513b8dd15637c6c95585603a4e055dabad56d"
    }
  },
  {
    "oid": "6e5a25670346ddf5e4bc3b1598f8ec5e52699c09",
    "message": "ZOOKEEPER-1560 Zookeeper client hangs on creation of large nodes (Skye Wanderman-Milne via phunt)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/trunk@1404260 13f79535-47bb-0310-9956-ffa450edef68",
    "date": "2012-10-31T17:24:54Z",
    "url": "https://github.com/apache/zookeeper/commit/6e5a25670346ddf5e4bc3b1598f8ec5e52699c09",
    "details": {
      "sha": "fbb0284813fad4594b8089b75683d20fb2f87aaa",
      "filename": "src/java/main/org/apache/zookeeper/ClientCnxnSocketNIO.java",
      "status": "modified",
      "additions": 53,
      "deletions": 51,
      "changes": 104,
      "blob_url": "https://github.com/apache/zookeeper/blob/6e5a25670346ddf5e4bc3b1598f8ec5e52699c09/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FClientCnxnSocketNIO.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/6e5a25670346ddf5e4bc3b1598f8ec5e52699c09/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FClientCnxnSocketNIO.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FClientCnxnSocketNIO.java?ref=6e5a25670346ddf5e4bc3b1598f8ec5e52699c09",
      "patch": "@@ -26,16 +26,16 @@\n import java.nio.channels.SelectionKey;\n import java.nio.channels.Selector;\n import java.nio.channels.SocketChannel;\n-import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n+import java.util.ListIterator;\n import java.util.Set;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.apache.zookeeper.ClientCnxn.EndOfStreamException;\n import org.apache.zookeeper.ClientCnxn.Packet;\n import org.apache.zookeeper.ZooDefs.OpCode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n public class ClientCnxnSocketNIO extends ClientCnxnSocket {\n     private static final Logger LOG = LoggerFactory\n@@ -104,83 +104,85 @@ void doIO(List<Packet> pendingQueue, LinkedList<Packet> outgoingQueue, ClientCnx\n             }\n         }\n         if (sockKey.isWritable()) {\n-            LinkedList<Packet> pending = new LinkedList<Packet>();\n-            Packet p = null;\n             synchronized(outgoingQueue) {\n-                p = findSendablePacket(outgoingQueue,\n+                Packet p = findSendablePacket(outgoingQueue,\n                         cnxn.sendThread.clientTunneledAuthenticationInProgress());\n \n                 if (p != null) {\n-                    outgoingQueue.removeFirstOccurrence(p);\n                     updateLastSend();\n-                    if ((p.requestHeader != null) &&\n-                            (p.requestHeader.getType() != OpCode.ping) &&\n-                            (p.requestHeader.getType() != OpCode.auth)) {\n-                        p.requestHeader.setXid(cnxn.getXid());\n+                    // If we already started writing p, p.bb will already exist\n+                    if (p.bb == null) {\n+                        if ((p.requestHeader != null) &&\n+                                (p.requestHeader.getType() != OpCode.ping) &&\n+                                (p.requestHeader.getType() != OpCode.auth)) {\n+                            p.requestHeader.setXid(cnxn.getXid());\n+                        }\n+                        p.createBB();\n                     }\n-                    p.createBB();\n-                    ByteBuffer pbb = p.bb;\n-                    sock.write(pbb);\n-                    if (!pbb.hasRemaining()) {\n+                    sock.write(p.bb);\n+                    if (!p.bb.hasRemaining()) {\n                         sentCount++;\n+                        outgoingQueue.removeFirstOccurrence(p);\n                         if (p.requestHeader != null\n                                 && p.requestHeader.getType() != OpCode.ping\n                                 && p.requestHeader.getType() != OpCode.auth) {\n-                            pending.add(p);\n+                            synchronized (pendingQueue) {\n+                                pendingQueue.add(p);\n+                            }\n                         }\n                     }\n-                } else {\n-                    // No suitable packet to send: turn off write interest flag.\n+                }\n+                if (outgoingQueue.isEmpty()) {\n+                    // No more packets to send: turn off write interest flag.\n                     // Will be turned on later by a later call to enableWrite(),\n                     // from within ZooKeeperSaslClient (if client is configured\n                     // to attempt SASL authentication), or in either doIO() or\n                     // in doTransport() if not.\n                     disableWrite();\n+                } else {\n+                    // Just in case\n+                    enableWrite();\n                 }\n             }\n-            synchronized(pendingQueue) {\n-                pendingQueue.addAll(pending);\n-            }\n-\n         }\n     }\n \n     private Packet findSendablePacket(LinkedList<Packet> outgoingQueue,\n                                       boolean clientTunneledAuthenticationInProgress) {\n         synchronized (outgoingQueue) {\n-            if (!outgoingQueue.isEmpty()) {\n-                if (clientTunneledAuthenticationInProgress) {\n-                    Packet p = null;\n-                    // Since client's authentication with server is in progress,\n-                    // send only the null-header packet queued by primeConnection().\n-                    // This packet must be sent so that the SASL authentication process\n-                    // can proceed, but all other packets should wait until\n-                    // SASL authentication completes.\n-                    Iterator<Packet> iter = outgoingQueue.listIterator();\n-                    while(iter.hasNext()) {\n-                        p = iter.next();\n-                        if (p.requestHeader == null) {\n-                            // We've found the priming-packet.\n-                            return p;\n-                        } else {\n-                            // Non-priming packet: defer it until later, leaving it in the queue\n-                            // until authentication completes.\n-                            if (LOG.isDebugEnabled()) {\n-                                LOG.debug(\"deferring non-priming packet: \" + p +\n-                                        \"until SASL authentication completes.\");\n-                            }\n-                        }\n-                    }\n-                    // no sendable packet found.\n-                    return null;\n+            if (outgoingQueue.isEmpty()) {\n+                return null;\n+            }\n+            if (outgoingQueue.getFirst().bb != null // If we've already starting sending the first packet, we better finish\n+                || !clientTunneledAuthenticationInProgress) {\n+                return outgoingQueue.getFirst();\n+            }\n+\n+            // Since client's authentication with server is in progress,\n+            // send only the null-header packet queued by primeConnection().\n+            // This packet must be sent so that the SASL authentication process\n+            // can proceed, but all other packets should wait until\n+            // SASL authentication completes.\n+            ListIterator<Packet> iter = outgoingQueue.listIterator();\n+            while (iter.hasNext()) {\n+                Packet p = iter.next();\n+                if (p.requestHeader == null) {\n+                    // We've found the priming-packet. Move it to the beginning of the queue.\n+                    iter.remove();\n+                    outgoingQueue.add(0, p);\n+                    return p;\n                 } else {\n-                    // Tunnelled authentication is not in progress: just\n-                    // send the first packet in the queue.\n-                    return outgoingQueue.getFirst();\n+                    // Non-priming packet: defer it until later, leaving it in the queue\n+                    // until authentication completes.\n+                    if (LOG.isDebugEnabled()) {\n+                        LOG.debug(\"deferring non-priming packet: \" + p +\n+                                \"until SASL authentication completes.\");\n+                    }\n                 }\n             }\n+            // no sendable packet found.\n+            return null;\n         }\n-        return null;\n     }\n \n     @Override",
      "parent_sha": "8c6155afb6df604ff59fa4e4148a809c0740d3b6"
    }
  },
  {
    "oid": "71b7515926bccf00209fc373e43794d13e90c300",
    "message": "ZOOKEEPER-4764: Tune the log info of refusing session request\n\nReviewers: tisonkun, maoling\nAuthor: horizonzy\nCloses #2083 from horizonzy/tune-log-info",
    "date": "2024-02-07T03:21:25Z",
    "url": "https://github.com/apache/zookeeper/commit/71b7515926bccf00209fc373e43794d13e90c300",
    "details": {
      "sha": "0a730f26ec6f142b6114442b0d4e9f8309c756eb",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/apache/zookeeper/blob/71b7515926bccf00209fc373e43794d13e90c300/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperServer.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/71b7515926bccf00209fc373e43794d13e90c300/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperServer.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperServer.java?ref=71b7515926bccf00209fc373e43794d13e90c300",
      "patch": "@@ -1513,7 +1513,9 @@ public void processConnectRequest(ServerCnxn cnxn, ConnectRequest request) throw\n             throw new CloseRequestException(msg, ServerCnxn.DisconnectReason.NOT_READ_ONLY_CLIENT);\n         }\n         if (request.getLastZxidSeen() > zkDb.dataTree.lastProcessedZxid) {\n-            String msg = \"Refusing session request for client \"\n+            String msg = \"Refusing session(0x\"\n+                         + Long.toHexString(sessionId)\n+                         + \") request for client \"\n                          + cnxn.getRemoteSocketAddress()\n                          + \" as it has seen zxid 0x\"\n                          + Long.toHexString(request.getLastZxidSeen())",
      "parent_sha": "5f66da130118869a3b73b19dada8c5de628ad189"
    }
  },
  {
    "oid": "f52918abd066d85a423d38917e58fc950d4e9d09",
    "message": "ZOOKEEPER-4227: X509AuthFailureTest is failing consistently\n\nAuthor: Mohammad Arshad <arshad@apache.org>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>\n\nCloses #1616 from arshadmohammad/ZOOKEEPER-4227",
    "date": "2021-03-10T11:52:24Z",
    "url": "https://github.com/apache/zookeeper/commit/f52918abd066d85a423d38917e58fc950d4e9d09",
    "details": {
      "sha": "dc3394d1754a2f8a4fb4913c4ca4beacbe855ade",
      "filename": "zookeeper-server/src/test/java/org/apache/zookeeper/server/X509AuthFailureTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/apache/zookeeper/blob/f52918abd066d85a423d38917e58fc950d4e9d09/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FX509AuthFailureTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/f52918abd066d85a423d38917e58fc950d4e9d09/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FX509AuthFailureTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FX509AuthFailureTest.java?ref=f52918abd066d85a423d38917e58fc950d4e9d09",
      "patch": "@@ -20,6 +20,7 @@\n import static org.junit.jupiter.api.Assertions.assertTrue;\n import static org.junit.jupiter.api.Assertions.fail;\n import org.apache.zookeeper.PortAssignment;\n+import org.apache.zookeeper.ZKTestCase;\n import org.apache.zookeeper.ZooKeeper;\n import org.apache.zookeeper.client.ZKClientConfig;\n import org.apache.zookeeper.common.ClientX509Util;\n@@ -30,7 +31,7 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class X509AuthFailureTest {\n+public class X509AuthFailureTest extends ZKTestCase {\n     protected static final Logger LOG = LoggerFactory.getLogger(X509AuthFailureTest.class);\n \n     private static ClientX509Util clientX509Util;\n@@ -71,6 +72,8 @@ public void testSecureStandaloneServerAuthNFailure() throws Exception {\n \n         ZooKeeperServerMainTest.MainThread mt = new ZooKeeperServerMainTest.MainThread(CLIENT_PORT, SECURE_CLIENT_PORT, true, null);\n         mt.start();\n+        assertTrue(\n+            ClientBase.waitForServerUp(\"127.0.0.1:\" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));\n \n         try {\n             ZooKeeper zk = createZKClnt(\"127.0.0.1:\" + SECURE_CLIENT_PORT);",
      "parent_sha": "2f98b8feb297ca0b44f6686870078f2ce8d3d303"
    }
  },
  {
    "oid": "e129e7a0b64d6555460d240be2d79e53aaa1bef9",
    "message": "ZOOKEEPER-2893: very poor choice of logging if client fails to connect to server\n\n'addr' variable is used to identify which server to connect to.\nI've made this available for error handling code in order to let it fallback to this address if the remote socket hasn't been initialised yet. This will give us better error messages if the client is unable to connect to server for some reason.\n\nAuthor: Andor Molnar <andor@cloudera.com>\n\nReviewers: phunt@apache.org\n\nCloses #430 from anmolnar/ZOOKEEPER-2893 and squashes the following commits:\n\naa735540 [Andor Molnar] ZOOKEEPER-2893. Use log4j message templates\n47a8cf4c [Andor Molnar] ZOOKEEPER-2893. Make serverAddress local variable of run(). Separate SocketExceptions from generic ex handler and log at info level.\n6ea4cb21 [Andor Molnar] ZOOKEEPER-2893. Renamed addr to serverAddress, use serverAddress in log message, it's always populated with the correct remote endpoint\nfbe4ccde [Andor Molnar] ZOOKEEPER-2893. Make 'addr' variable available for error handling code to give a chance to fallback if the socket hasn't been initialized yet\n\nChange-Id: I22becf9c1f923a28c82f263b604239fde9bc0ce4",
    "date": "2017-12-19T18:27:25Z",
    "url": "https://github.com/apache/zookeeper/commit/e129e7a0b64d6555460d240be2d79e53aaa1bef9",
    "details": {
      "sha": "1a7a7833736844474a2f2132fd8ab52e25c3c8b1",
      "filename": "src/java/main/org/apache/zookeeper/ClientCnxn.java",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "blob_url": "https://github.com/apache/zookeeper/blob/e129e7a0b64d6555460d240be2d79e53aaa1bef9/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FClientCnxn.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/e129e7a0b64d6555460d240be2d79e53aaa1bef9/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FClientCnxn.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FClientCnxn.java?ref=e129e7a0b64d6555460d240be2d79e53aaa1bef9",
      "patch": "@@ -26,6 +26,7 @@\n import java.net.InetSocketAddress;\n import java.net.Socket;\n import java.net.SocketAddress;\n+import java.net.SocketException;\n import java.nio.ByteBuffer;\n import java.util.HashSet;\n import java.util.ArrayList;\n@@ -1051,7 +1052,7 @@ private void sendPing() {\n         // throws a LoginException: see startConnect() below.\n         private boolean saslLoginFailed = false;\n \n-        private void startConnect() throws IOException {\n+        private void startConnect(InetSocketAddress addr) throws IOException {\n             // initializing it for new connection\n             saslLoginFailed = false;\n             if(!isFirstConnect){\n@@ -1063,14 +1064,6 @@ private void startConnect() throws IOException {\n             }\n             state = States.CONNECTING;\n \n-            InetSocketAddress addr;\n-            if (rwServerAddress != null) {\n-                addr = rwServerAddress;\n-                rwServerAddress = null;\n-            } else {\n-                addr = hostProvider.next(1000);\n-            }\n-\n             String hostPort = addr.getHostString() + \":\" + addr.getPort();\n             MDC.put(\"myid\", hostPort);\n             setName(getName().replaceAll(\"\\\\(.*\\\\)\", \"(\" + hostPort + \")\"));\n@@ -1123,14 +1116,21 @@ public void run() {\n             int to;\n             long lastPingRwServer = Time.currentElapsedTime();\n             final int MAX_SEND_PING_INTERVAL = 10000; //10 seconds\n+            InetSocketAddress serverAddress = null;\n             while (state.isAlive()) {\n                 try {\n                     if (!clientCnxnSocket.isConnected()) {\n                         // don't re-establish connection if we are closing\n                         if (closing) {\n                             break;\n                         }\n-                        startConnect();\n+                        if (rwServerAddress != null) {\n+                            serverAddress = rwServerAddress;\n+                            rwServerAddress = null;\n+                        } else {\n+                            serverAddress = hostProvider.next(1000);\n+                        }\n+                        startConnect(serverAddress);\n                         clientCnxnSocket.updateLastSendAndHeard();\n                     }\n \n@@ -1231,14 +1231,14 @@ public void run() {\n                             LOG.info(e.getMessage() + RETRY_CONN_MSG);\n                         } else if (e instanceof RWServerFoundException) {\n                             LOG.info(e.getMessage());\n+                        } else if (e instanceof SocketException) {\n+                            LOG.info(\"Socket error occurred: {}: {}\", serverAddress, e.getMessage());\n                         } else {\n-                            LOG.warn(\n-                                    \"Session 0x\"\n-                                            + Long.toHexString(getSessionId())\n-                                            + \" for server \"\n-                                            + clientCnxnSocket.getRemoteSocketAddress()\n-                                            + \", unexpected error\"\n-                                            + RETRY_CONN_MSG, e);\n+                            LOG.warn(\"Session 0x{} for server {}, unexpected error{}\",\n+                                            Long.toHexString(getSessionId()),\n+                                            serverAddress,\n+                                            RETRY_CONN_MSG,\n+                                            e);\n                         }\n                         // At this point, there might still be new packets appended to outgoingQueue.\n                         // they will be handled in next connection or cleared up if closed.",
      "parent_sha": "f2cbcc7e0d7adff08bd73a27f2193b1198e4c7f7"
    }
  },
  {
    "oid": "226af6e29bc00fe4a33269351f20ddf5b6658fd2",
    "message": "ZOOKEEPER-3277: Add trace listener in NettyServerCnxnFactory only if trace logging is enabled\n\nBased on the code review discussion in #819\n\nAuthor: Ilya Maykov <ilyam@fb.com>\n\nReviewers: andor@apache.org\n\nCloses #820 from ivmaykov/ZOOKEEPER-3277",
    "date": "2019-02-15T14:36:55Z",
    "url": "https://github.com/apache/zookeeper/commit/226af6e29bc00fe4a33269351f20ddf5b6658fd2",
    "details": {
      "sha": "06de7fd42dd543958d75d154f57c08e9c2e24fde",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxnFactory.java",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/apache/zookeeper/blob/226af6e29bc00fe4a33269351f20ddf5b6658fd2/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNettyServerCnxnFactory.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/226af6e29bc00fe4a33269351f20ddf5b6658fd2/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNettyServerCnxnFactory.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNettyServerCnxnFactory.java?ref=226af6e29bc00fe4a33269351f20ddf5b6658fd2",
      "patch": "@@ -205,15 +205,17 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception\n         }\n \n         // Use a single listener instance to reduce GC\n-        private final GenericFutureListener<Future<Void>> onWriteCompletedListener = (f) -> {\n-            if (LOG.isTraceEnabled()) {\n-                LOG.trace(\"write {}\", f.isSuccess() ? \"complete\" : \"failed\");\n-            }\n+        // Note: this listener is only added when LOG.isTraceEnabled() is true,\n+        // so it should not do any work other than trace logging.\n+        private final GenericFutureListener<Future<Void>> onWriteCompletedTracer = (f) -> {\n+            LOG.trace(\"write {}\", f.isSuccess() ? \"complete\" : \"failed\");\n         };\n \n         @Override\n         public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n-            promise.addListener(onWriteCompletedListener);\n+            if (LOG.isTraceEnabled()) {\n+                promise.addListener(onWriteCompletedTracer);\n+            }\n             super.write(ctx, msg, promise);\n         }\n ",
      "parent_sha": "a7b00ed47784f101cbd38efaecb89192ae9d3344"
    }
  },
  {
    "oid": "5577d41da48feb8db3595d88a63096594c20fbb9",
    "message": "ZOOKEEPER-3385: fix build break.\n\nPR https://github.com/apache/zookeeper/pull/939 that merged in master caused build break due to\ntwo missing imports. Fix the build break by adding the missing imports.\n\nAuthor: Michael Han <lhan@twitter.com>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>, Norbert Kalmar <nkalmar@apache.org>\n\nCloses #967 from hanm/ZOOKEEPER-3385",
    "date": "2019-06-05T10:14:51Z",
    "url": "https://github.com/apache/zookeeper/commit/5577d41da48feb8db3595d88a63096594c20fbb9",
    "details": {
      "sha": "1c381bfbfbe77496e1a0ea7df9c45c06b9130ce8",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/admin/Commands.java",
      "status": "modified",
      "additions": 2,
      "deletions": 4,
      "changes": 6,
      "blob_url": "https://github.com/apache/zookeeper/blob/5577d41da48feb8db3595d88a63096594c20fbb9/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fadmin%2FCommands.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/5577d41da48feb8db3595d88a63096594c20fbb9/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fadmin%2FCommands.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fadmin%2FCommands.java?ref=5577d41da48feb8db3595d88a63096594c20fbb9",
      "patch": "@@ -35,15 +35,13 @@\n import org.apache.zookeeper.server.DataTree;\n import org.apache.zookeeper.server.ServerCnxnFactory;\n import org.apache.zookeeper.server.ServerMetrics;\n-import org.apache.zookeeper.server.ServerStats;\n import org.apache.zookeeper.server.ZooKeeperServer;\n import org.apache.zookeeper.server.ZooTrace;\n import org.apache.zookeeper.server.persistence.SnapshotInfo;\n-import org.apache.zookeeper.server.quorum.Follower;\n-import org.apache.zookeeper.server.quorum.FollowerZooKeeperServer;\n import org.apache.zookeeper.server.quorum.Leader;\n import org.apache.zookeeper.server.quorum.LeaderZooKeeperServer;\n-import org.apache.zookeeper.server.quorum.ObserverZooKeeperServer;\n+import org.apache.zookeeper.server.quorum.QuorumPeer;\n+import org.apache.zookeeper.server.quorum.QuorumZooKeeperServer;\n import org.apache.zookeeper.server.quorum.ReadOnlyZooKeeperServer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;",
      "parent_sha": "5cb10bb5c0e341d65471b70572654756ba088a1d"
    }
  },
  {
    "oid": "7f7a4a80beac658d2f1557b21499d596a2fe4929",
    "message": "Fixed isStandalone() to return true for quorum sizes <= 1\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/zookeeper/trunk@670911 13f79535-47bb-0310-9956-ffa450edef68",
    "date": "2008-03-27T00:10:32Z",
    "url": "https://github.com/apache/zookeeper/commit/7f7a4a80beac658d2f1557b21499d596a2fe4929",
    "details": {
      "sha": "60ba0c41e637e7a6405d6308db05f848cb3f23ab",
      "filename": "zookeeper/java/src/com/yahoo/zookeeper/server/quorum/QuorumPeerConfig.java",
      "status": "modified",
      "additions": 207,
      "deletions": 191,
      "changes": 398,
      "blob_url": "https://github.com/apache/zookeeper/blob/7f7a4a80beac658d2f1557b21499d596a2fe4929/zookeeper%2Fjava%2Fsrc%2Fcom%2Fyahoo%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerConfig.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/7f7a4a80beac658d2f1557b21499d596a2fe4929/zookeeper%2Fjava%2Fsrc%2Fcom%2Fyahoo%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerConfig.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper%2Fjava%2Fsrc%2Fcom%2Fyahoo%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerConfig.java?ref=7f7a4a80beac658d2f1557b21499d596a2fe4929",
      "patch": "@@ -1,191 +1,207 @@\n-package com.yahoo.zookeeper.server.quorum;\r\n-\r\n-import java.io.BufferedReader;\r\n-import java.io.File;\r\n-import java.io.FileInputStream;\r\n-import java.io.FileReader;\r\n-import java.net.InetSocketAddress;\r\n-import java.util.ArrayList;\r\n-import java.util.Properties;\r\n-import java.util.Map.Entry;\r\n-\r\n-import com.yahoo.zookeeper.server.ServerConfig;\r\n-import com.yahoo.zookeeper.server.ZooLog;\r\n-import com.yahoo.zookeeper.server.quorum.QuorumPeer.QuorumServer;\r\n-\r\n-public class QuorumPeerConfig extends ServerConfig {\r\n-\tprivate int tickTime;\r\n-\tprivate int initLimit;\r\n-\tprivate int syncLimit;\r\n-\tprivate int electionAlg;\r\n-\tprivate int electionPort;\r\n-\tprivate ArrayList<QuorumServer> servers = null;\r\n-\tprivate long serverId;\r\n-\r\n-\tprivate QuorumPeerConfig(int port, String dataDir, String dataLogDir) {\r\n-\t\tsuper(port, dataDir, dataLogDir);\r\n-\t}\r\n-\r\n-\tpublic static void parse(String[] args) {\r\n-\t\tif(instance!=null)\r\n-\t\t\treturn;\r\n-\t\t\r\n-\t\ttry {\r\n-\t\t\tif (args.length != 1) {\r\n-\t\t\t\tSystem.err.println(\"USAGE: configFile\");\r\n-\t\t\t\tSystem.exit(2);\r\n-\t\t\t}\r\n-\t\t\tFile zooCfgFile = new File(args[0]);\r\n-\t\t\tif (!zooCfgFile.exists()) {\r\n-\t\t\t\tZooLog.logError(zooCfgFile.toString() + \" file is missing\");\r\n-\t\t\t\tSystem.exit(2);\r\n-\t\t\t}\r\n-\t\t\tProperties cfg = new Properties();\r\n-\t\t\tcfg.load(new FileInputStream(zooCfgFile));\r\n-\t\t\tArrayList<QuorumServer> servers = new ArrayList<QuorumServer>();\r\n-\t\t\tString dataDir = null;\r\n-\t\t\tString dataLogDir = null;\r\n-\t\t\tint clientPort = 0;\r\n-\t\t\tint tickTime = 0;\r\n-\t\t\tint initLimit = 0;\r\n-\t\t\tint syncLimit = 0;\r\n-\t\t\tint electionAlg = 0;\r\n-\t\t\tint electionPort = 0;\r\n-\t\t\tfor (Entry<Object, Object> entry : cfg.entrySet()) {\r\n-\t\t\t\tString key = entry.getKey().toString();\r\n-\t\t\t\tString value = entry.getValue().toString();\r\n-\t\t\t\tif (key.equals(\"dataDir\")) {\r\n-\t\t\t\t\tdataDir = value;\r\n-\t\t\t\t} else if (key.equals(\"dataLogDir\")) {\r\n-\t\t\t\t\tdataLogDir = value;\r\n-\t\t\t\t} else if (key.equals(\"traceFile\")) {\r\n-\t\t\t\t\tSystem.setProperty(\"requestTraceFile\", value);\r\n-\t\t\t\t} else if (key.equals(\"clientPort\")) {\r\n-\t\t\t\t\tclientPort = Integer.parseInt(value);\r\n-\t\t\t\t} else if (key.equals(\"tickTime\")) {\r\n-\t\t\t\t\ttickTime = Integer.parseInt(value);\r\n-\t\t\t\t} else if (key.equals(\"initLimit\")) {\r\n-\t\t\t\t\tinitLimit = Integer.parseInt(value);\r\n-\t\t\t\t} else if (key.equals(\"syncLimit\")) {\r\n-\t\t\t\t\tsyncLimit = Integer.parseInt(value);\r\n-\t\t\t\t} else if (key.equals(\"electionAlg\")) {\r\n-\t\t\t\t\telectionAlg = Integer.parseInt(value);\r\n-\t\t\t\t} else if (key.equals(\"electionPort\")) {\r\n-\t\t\t\t\telectionPort = Integer.parseInt(value);\r\n-\t\t\t\t} else if (key.startsWith(\"server.\")) {\r\n-\t\t\t\t\tint dot = key.indexOf('.');\r\n-\t\t\t\t\tlong sid = Long.parseLong(key.substring(dot + 1));\r\n-\t\t\t\t\tString parts[] = value.split(\":\");\r\n-\t\t\t\t\tif (parts.length != 2) {\r\n-\t\t\t\t\t\tZooLog.logError(value\r\n-\t\t\t\t\t\t\t\t+ \" does not have the form host:port\");\r\n-\t\t\t\t\t}\r\n-\t\t\t\t\tInetSocketAddress addr = new InetSocketAddress(parts[0],\r\n-\t\t\t\t\t\t\tInteger.parseInt(parts[1]));\r\n-\t\t\t\t\tservers.add(new QuorumServer(sid, addr));\r\n-\t\t\t\t} else {\r\n-\t\t\t\t\tSystem.setProperty(\"zookeeper.\" + key, value);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\tif (dataDir == null) {\r\n-\t\t\t\tZooLog.logError(\"dataDir is not set\");\r\n-\t\t\t\tSystem.exit(2);\r\n-\t\t\t}\r\n-\t\t\tif (dataLogDir == null) {\r\n-\t\t\t\tdataLogDir = dataDir;\r\n-\t\t\t} else {\r\n-\t\t\t\tif (!new File(dataLogDir).isDirectory()) {\r\n-\t\t\t\t\tZooLog.logError(\"dataLogDir \" + dataLogDir+ \" is missing.\");\r\n-\t\t\t\t\tSystem.exit(2);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\tif (clientPort == 0) {\r\n-\t\t\t\tZooLog.logError(\"clientPort is not set\");\r\n-\t\t\t\tSystem.exit(2);\r\n-\t\t\t}\r\n-\t\t\tif (tickTime == 0) {\r\n-\t\t\t\tZooLog.logError(\"tickTime is not set\");\r\n-\t\t\t\tSystem.exit(2);\r\n-\t\t\t}\r\n-\t\t\tif (servers.size() > 1 && initLimit == 0) {\r\n-\t\t\t\tZooLog.logError(\"initLimit is not set\");\r\n-\t\t\t\tSystem.exit(2);\r\n-\t\t\t}\r\n-\t\t\tif (servers.size() > 1 && syncLimit == 0) {\r\n-\t\t\t\tZooLog.logError(\"syncLimit is not set\");\r\n-\t\t\t\tSystem.exit(2);\r\n-\t\t\t}\r\n-\t\t\tQuorumPeerConfig conf = new QuorumPeerConfig(clientPort, dataDir,\r\n-\t\t\t\t\tdataLogDir);\r\n-\t\t\tconf.tickTime = tickTime;\r\n-\t\t\tconf.initLimit = initLimit;\r\n-\t\t\tconf.syncLimit = syncLimit;\r\n-\t\t\tconf.electionAlg = electionAlg;\r\n-\t\t\tconf.electionPort = electionPort;\r\n-\t\t\tconf.servers = servers;\r\n-\t\t\tif (servers.size() > 1) {\r\n-\t\t\t\tFile myIdFile = new File(dataDir, \"myid\");\r\n-\t\t\t\tif (!myIdFile.exists()) {\r\n-\t\t\t\t\tZooLog.logError(myIdFile.toString() + \" file is missing\");\r\n-\t\t\t\t\tSystem.exit(2);\r\n-\t\t\t\t}\r\n-\t\t\t\tBufferedReader br = new BufferedReader(new FileReader(myIdFile));\r\n-\t\t\t\tString myIdString = br.readLine();\r\n-\t\t\t\ttry {\r\n-\t\t\t\t\tconf.serverId = Long.parseLong(myIdString);\r\n-\t\t\t\t} catch (NumberFormatException e) {\r\n-\t\t\t\t\tZooLog.logError(myIdString + \" is not a number\");\r\n-\t\t\t\t\tSystem.exit(2);\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t\tinstance=conf;\r\n-\t\t} catch (Exception e) {\r\n-\t\t\tZooLog.logException(e);\r\n-\t\t\tSystem.exit(2);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tprotected boolean isStandaloneServer(){\r\n-\t\treturn QuorumPeerConfig.getServers().size() == 1;\r\n-\t}\r\n-\r\n-\tpublic static int getTickTime() {\r\n-\t\tassert instance instanceof QuorumPeerConfig;\r\n-\t\treturn ((QuorumPeerConfig)instance).tickTime;\r\n-\t}\r\n-\r\n-\tpublic static int getInitLimit() {\r\n-\t\tassert instance instanceof QuorumPeerConfig;\r\n-\t\treturn ((QuorumPeerConfig)instance).initLimit;\r\n-\t}\r\n-\r\n-\tpublic static int getSyncLimit() {\r\n-\t\tassert instance instanceof QuorumPeerConfig;\r\n-\t\treturn ((QuorumPeerConfig)instance).syncLimit;\r\n-\t}\r\n-\r\n-\tpublic static int getElectionAlg() {\r\n-\t\tassert instance instanceof QuorumPeerConfig;\r\n-\t\treturn ((QuorumPeerConfig)instance).electionAlg;\r\n-\t}\r\n-\r\n-\tpublic static int getElectionPort() {\r\n-\t\tassert instance instanceof QuorumPeerConfig;\r\n-\t\treturn ((QuorumPeerConfig)instance).electionPort;\r\n-\t}\r\n-\t\r\n-\tpublic static ArrayList<QuorumServer> getServers() {\r\n-\t\tassert instance instanceof QuorumPeerConfig;\r\n-\t\treturn ((QuorumPeerConfig)instance).servers;\r\n-\t}\r\n-\r\n-\tpublic static int getQuorumSize(){\r\n-\t\tassert instance instanceof QuorumPeerConfig;\r\n-\t\treturn ((QuorumPeerConfig)instance).servers.size();\t\t\r\n-\t}\r\n-\t\r\n-\tpublic static long getServerId() {\r\n-\t\tassert instance instanceof QuorumPeerConfig;\r\n-\t\treturn ((QuorumPeerConfig)instance).serverId;\r\n-\t}\r\n-}\r\n+/*\r\n+ * Copyright 2008, Yahoo! Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.yahoo.zookeeper.server.quorum;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.net.InetSocketAddress;\n+import java.util.ArrayList;\n+import java.util.Properties;\n+import java.util.Map.Entry;\n+\n+import com.yahoo.zookeeper.server.ServerConfig;\n+import com.yahoo.zookeeper.server.ZooLog;\n+import com.yahoo.zookeeper.server.quorum.QuorumPeer.QuorumServer;\n+\n+public class QuorumPeerConfig extends ServerConfig {\n+    private int tickTime;\n+    private int initLimit;\n+    private int syncLimit;\n+    private int electionAlg;\n+    private int electionPort;\n+    private ArrayList<QuorumServer> servers = null;\n+    private long serverId;\n+\n+    private QuorumPeerConfig(int port, String dataDir, String dataLogDir) {\n+        super(port, dataDir, dataLogDir);\n+    }\n+\n+    public static void parse(String[] args) {\n+        if(instance!=null)\n+            return;\n+        \n+        try {\n+            if (args.length != 1) {\n+                System.err.println(\"USAGE: configFile\");\n+                System.exit(2);\n+            }\n+            File zooCfgFile = new File(args[0]);\n+            if (!zooCfgFile.exists()) {\n+                ZooLog.logError(zooCfgFile.toString() + \" file is missing\");\n+                System.exit(2);\n+            }\n+            Properties cfg = new Properties();\n+            cfg.load(new FileInputStream(zooCfgFile));\n+            ArrayList<QuorumServer> servers = new ArrayList<QuorumServer>();\n+            String dataDir = null;\n+            String dataLogDir = null;\n+            int clientPort = 0;\n+            int tickTime = 0;\n+            int initLimit = 0;\n+            int syncLimit = 0;\n+            int electionAlg = 0;\n+            int electionPort = 0;\n+            for (Entry<Object, Object> entry : cfg.entrySet()) {\n+                String key = entry.getKey().toString();\n+                String value = entry.getValue().toString();\n+                if (key.equals(\"dataDir\")) {\n+                    dataDir = value;\n+                } else if (key.equals(\"dataLogDir\")) {\n+                    dataLogDir = value;\n+                } else if (key.equals(\"traceFile\")) {\n+                    System.setProperty(\"requestTraceFile\", value);\n+                } else if (key.equals(\"clientPort\")) {\n+                    clientPort = Integer.parseInt(value);\n+                } else if (key.equals(\"tickTime\")) {\n+                    tickTime = Integer.parseInt(value);\n+                } else if (key.equals(\"initLimit\")) {\n+                    initLimit = Integer.parseInt(value);\n+                } else if (key.equals(\"syncLimit\")) {\n+                    syncLimit = Integer.parseInt(value);\n+                } else if (key.equals(\"electionAlg\")) {\n+                    electionAlg = Integer.parseInt(value);\n+                } else if (key.equals(\"electionPort\")) {\n+                    electionPort = Integer.parseInt(value);\n+                } else if (key.startsWith(\"server.\")) {\n+                    int dot = key.indexOf('.');\n+                    long sid = Long.parseLong(key.substring(dot + 1));\n+                    String parts[] = value.split(\":\");\n+                    if (parts.length != 2) {\n+                        ZooLog.logError(value\n+                                + \" does not have the form host:port\");\n+                    }\n+                    InetSocketAddress addr = new InetSocketAddress(parts[0],\n+                            Integer.parseInt(parts[1]));\n+                    servers.add(new QuorumServer(sid, addr));\n+                } else {\n+                    System.setProperty(\"zookeeper.\" + key, value);\n+                }\n+            }\n+            if (dataDir == null) {\n+                ZooLog.logError(\"dataDir is not set\");\n+                System.exit(2);\n+            }\n+            if (dataLogDir == null) {\n+                dataLogDir = dataDir;\n+            } else {\n+                if (!new File(dataLogDir).isDirectory()) {\n+                    ZooLog.logError(\"dataLogDir \" + dataLogDir+ \" is missing.\");\n+                    System.exit(2);\n+                }\n+            }\n+            if (clientPort == 0) {\n+                ZooLog.logError(\"clientPort is not set\");\n+                System.exit(2);\n+            }\n+            if (tickTime == 0) {\n+                ZooLog.logError(\"tickTime is not set\");\n+                System.exit(2);\n+            }\n+            if (servers.size() > 1 && initLimit == 0) {\n+                ZooLog.logError(\"initLimit is not set\");\n+                System.exit(2);\n+            }\n+            if (servers.size() > 1 && syncLimit == 0) {\n+                ZooLog.logError(\"syncLimit is not set\");\n+                System.exit(2);\n+            }\n+            QuorumPeerConfig conf = new QuorumPeerConfig(clientPort, dataDir,\n+                    dataLogDir);\n+            conf.tickTime = tickTime;\n+            conf.initLimit = initLimit;\n+            conf.syncLimit = syncLimit;\n+            conf.electionAlg = electionAlg;\n+            conf.electionPort = electionPort;\n+            conf.servers = servers;\n+            if (servers.size() > 1) {\n+                File myIdFile = new File(dataDir, \"myid\");\n+                if (!myIdFile.exists()) {\n+                    ZooLog.logError(myIdFile.toString() + \" file is missing\");\n+                    System.exit(2);\n+                }\n+                BufferedReader br = new BufferedReader(new FileReader(myIdFile));\n+                String myIdString = br.readLine();\n+                try {\n+                    conf.serverId = Long.parseLong(myIdString);\n+                } catch (NumberFormatException e) {\n+                    ZooLog.logError(myIdString + \" is not a number\");\n+                    System.exit(2);\n+                }\n+            }\n+            instance=conf;\n+        } catch (Exception e) {\n+            ZooLog.logException(e);\n+            System.exit(2);\n+        }\n+    }\n+\n+    protected boolean isStandaloneServer(){\n+        return QuorumPeerConfig.getServers().size() <= 1;\n+    }\n+\n+    public static int getTickTime() {\n+        assert instance instanceof QuorumPeerConfig;\n+        return ((QuorumPeerConfig)instance).tickTime;\n+    }\n+\n+    public static int getInitLimit() {\n+        assert instance instanceof QuorumPeerConfig;\n+        return ((QuorumPeerConfig)instance).initLimit;\n+    }\n+\n+    public static int getSyncLimit() {\n+        assert instance instanceof QuorumPeerConfig;\n+        return ((QuorumPeerConfig)instance).syncLimit;\n+    }\n+\n+    public static int getElectionAlg() {\n+        assert instance instanceof QuorumPeerConfig;\n+        return ((QuorumPeerConfig)instance).electionAlg;\n+    }\n+\n+    public static int getElectionPort() {\n+        assert instance instanceof QuorumPeerConfig;\n+        return ((QuorumPeerConfig)instance).electionPort;\n+    }\n+    \n+    public static ArrayList<QuorumServer> getServers() {\n+        assert instance instanceof QuorumPeerConfig;\n+        return ((QuorumPeerConfig)instance).servers;\n+    }\n+\n+    public static int getQuorumSize(){\n+        assert instance instanceof QuorumPeerConfig;\n+        return ((QuorumPeerConfig)instance).servers.size();        \n+    }\n+    \n+    public static long getServerId() {\n+        assert instance instanceof QuorumPeerConfig;\n+        return ((QuorumPeerConfig)instance).serverId;\n+    }\n+}",
      "parent_sha": "bf1880ecb1385d570461213c352ff80b6ec9fb2f"
    }
  },
  {
    "oid": "0da7e6a3a699284df263484496fa16ca0f67e32a",
    "message": "ZOOKEEPER-68. Fix command line parsing for zookeeper barebone java client for acls. (Jakob Homan via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/zookeeper/trunk@674665 13f79535-47bb-0310-9956-ffa450edef68",
    "date": "2008-07-07T23:02:21Z",
    "url": "https://github.com/apache/zookeeper/commit/0da7e6a3a699284df263484496fa16ca0f67e32a",
    "details": {
      "sha": "f272119c582001882bcac732ee3eabc1698a4306",
      "filename": "src/java/main/org/apache/zookeeper/ZooKeeper.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/0da7e6a3a699284df263484496fa16ca0f67e32a/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FZooKeeper.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/0da7e6a3a699284df263484496fa16ca0f67e32a/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FZooKeeper.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FZooKeeper.java?ref=0da7e6a3a699284df263484496fa16ca0f67e32a",
      "patch": "@@ -1103,7 +1103,7 @@ private static List<ACL> parseACLs(String aclString) {\n         acl = new ArrayList<ACL>();\n         for (String a : acls) {\n             int firstColon = a.indexOf(':');\n-            int lastColon = a.indexOf(':');\n+            int lastColon = a.lastIndexOf(':');\n             if (firstColon == -1 || lastColon == -1 || firstColon == lastColon) {\n                 System.err\n                         .println(a + \" does not have the form scheme:id:perm\");",
      "parent_sha": "33e143dd200dd67984d6a83fb58e0eebca4c3c97"
    }
  },
  {
    "oid": "c0051fd8368dffdcb82b5a43ff6751f136a05016",
    "message": "ZOOKEEPER-1629. testTransactionLogCorruption occasionally fails. (shralex via camille)\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/trunk@1503101 13f79535-47bb-0310-9956-ffa450edef68",
    "date": "2013-07-15T01:28:42Z",
    "url": "https://github.com/apache/zookeeper/commit/c0051fd8368dffdcb82b5a43ff6751f136a05016",
    "details": {
      "sha": "acbad809d1f26adfb8589f2b8cf184227d63acf0",
      "filename": "src/java/test/org/apache/zookeeper/server/util/PortForwarder.java",
      "status": "modified",
      "additions": 11,
      "deletions": 9,
      "changes": 20,
      "blob_url": "https://github.com/apache/zookeeper/blob/c0051fd8368dffdcb82b5a43ff6751f136a05016/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Futil%2FPortForwarder.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/c0051fd8368dffdcb82b5a43ff6751f136a05016/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Futil%2FPortForwarder.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Futil%2FPortForwarder.java?ref=c0051fd8368dffdcb82b5a43ff6751f136a05016",
      "patch": "@@ -211,24 +211,26 @@ public void run() {\n                             sock.getInputStream(), target.getOutputStream()));\n                     this.workers.execute(new PortForwardWorker(target, sock,\n                             target.getInputStream(), sock.getOutputStream()));\n-                } catch (SocketTimeoutException e) {\n-                    LOG.warn(\"socket timed out local:\" + sock.getLocalPort()\n-                            + \" from:\" + sock.getPort()\n+                } catch (SocketTimeoutException e) {               \t\n+                    LOG.warn(\"socket timed out local:\" \n+                            + (sock != null ? sock.getLocalPort(): \"\")\n+                            + \" from:\" + (sock != null ? sock.getPort(): \"\")\n                             + \" to:\" + to, e);\n                 } catch (ConnectException e) {\n-                    LOG.warn(\"connection exception local:\" + sock.getLocalPort()\n-                            + \" from:\" + sock.getPort()\n+                    LOG.warn(\"connection exception local:\"\n+                            + (sock != null ? sock.getLocalPort(): \"\")\n+                            + \" from:\" + (sock != null ? sock.getPort(): \"\")\n                             + \" to:\" + to, e);\n                     sock.close();\n                 } catch (IOException e) {\n                     if (!\"Socket closed\".equals(e.getMessage())) {\n-                        LOG.warn(\"unexpected exception local:\" + sock.getLocalPort()\n-                            + \" from:\" + sock.getPort()\n-                            + \" to:\" + to, e);\n+                        LOG.warn(\"unexpected exception local:\" \n+                        \t\t+ (sock != null ? sock.getLocalPort(): \"\")\n+                                + \" from:\" + (sock != null ? sock.getPort(): \"\")\n+                                + \" to:\" + to, e);\n                         throw e;\n                     }\n                 }\n-\n             }\n         } catch (IOException e) {\n             LOG.error(\"Unexpected exception to:\" + to, e);",
      "parent_sha": "baa95e16a9d52fe95f347e242458d0debd14dd13"
    }
  },
  {
    "oid": "36b8711ebfd7ea749d547a52ddcd7d8853931728",
    "message": "ZOOKEEPER-3197: Improve documentation in ZooKeeperServer.superSecret\n\nAuthor: Colm O hEigeartaigh <coheigea@apache.org>\n\nReviewers: andor@apache.org\n\nCloses #752 from coheigea/ZOOKEEPER-3197",
    "date": "2019-01-07T14:34:02Z",
    "url": "https://github.com/apache/zookeeper/commit/36b8711ebfd7ea749d547a52ddcd7d8853931728",
    "details": {
      "sha": "20ab023ec5ae2c3cb02acb1f912a3e241aba9b80",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/apache/zookeeper/blob/36b8711ebfd7ea749d547a52ddcd7d8853931728/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperServer.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/36b8711ebfd7ea749d547a52ddcd7d8853931728/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperServer.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperServer.java?ref=36b8711ebfd7ea749d547a52ddcd7d8853931728",
      "patch": "@@ -116,8 +116,10 @@ protected enum State {\n     }\n \n     /**\n-     * This is the secret that we use to generate passwords, for the moment it\n-     * is more of a sanity check.\n+     * This is the secret that we use to generate passwords. For the moment,\n+     * it's more of a checksum that's used in reconnection, which carries no\n+     * security weight, and is treated internally as if it carries no\n+     * security weight.\n      */\n     static final private long superSecret = 0XB3415C00L;\n ",
      "parent_sha": "9e309557c02315344d6b39012ff4c9633b54c3d3"
    }
  },
  {
    "oid": "5040b7eb0e5f2917789a2119da0e3cdbc30bd8c1",
    "message": "ZOOKEEPER-1220 - minor fixup (formatting) to the previously applied 1220 patch\n\ngit-svn-id: https://svn.apache.org/repos/asf/zookeeper/trunk@1214528 13f79535-47bb-0310-9956-ffa450edef68",
    "date": "2011-12-14T22:58:16Z",
    "url": "https://github.com/apache/zookeeper/commit/5040b7eb0e5f2917789a2119da0e3cdbc30bd8c1",
    "details": {
      "sha": "a4c08266f56c8c7e6246c4075ac610290da438c8",
      "filename": "src/java/test/org/apache/zookeeper/ZooKeeperTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/apache/zookeeper/blob/5040b7eb0e5f2917789a2119da0e3cdbc30bd8c1/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2FZooKeeperTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/5040b7eb0e5f2917789a2119da0e3cdbc30bd8c1/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2FZooKeeperTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2FZooKeeperTest.java?ref=5040b7eb0e5f2917789a2119da0e3cdbc30bd8c1",
      "patch": "@@ -210,8 +210,8 @@ public void testCreateNodeWithoutData() throws Exception {\n         try {\n             Assert.assertTrue(\"Created node with wrong option\", zkMain\n                     .processZKCmd(zkMain.cl));\n-            Assert\n-                    .fail(\"Created the node with wrong option should throw Exception.\");\n+            Assert.fail(\"Created the node with wrong option should \"\n+                    + \"throw Exception.\");\n         } catch (IllegalArgumentException e) {\n             Assert.assertEquals(\"Path must start with / character\", e\n                     .getMessage());",
      "parent_sha": "e44601d1249ea70b5bfa514082c714640c6217dd"
    }
  },
  {
    "oid": "bccc654e09d9e85fe3495487b9619173a2c54151",
    "message": "ZOOKEEPER-4808: Fix the log statement in FastLeaderElection\n\nReviewers: maoling\nAuthor: li4wang\nCloses #2136 from li4wang/ZOOKEEPER-4808",
    "date": "2024-06-15T09:43:24Z",
    "url": "https://github.com/apache/zookeeper/commit/bccc654e09d9e85fe3495487b9619173a2c54151",
    "details": {
      "sha": "5a6b18fd19a913fb2a616c80b64ab014728cf994",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FastLeaderElection.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/bccc654e09d9e85fe3495487b9619173a2c54151/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFastLeaderElection.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/bccc654e09d9e85fe3495487b9619173a2c54151/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFastLeaderElection.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFastLeaderElection.java?ref=bccc654e09d9e85fe3495487b9619173a2c54151",
      "patch": "@@ -702,7 +702,7 @@ private void sendNotifications() {\n                 qv.toString().getBytes(UTF_8));\n \n             LOG.debug(\n-                \"Sending Notification: {} (n.leader), 0x{} (n.peerEpoch), 0x{} (n.zxid), 0x{} (n.round), {} (recipient),\"\n+                \"Sending Notification: {} (n.leader), 0x{} (n.zxid), 0x{} (n.peerEpoch), 0x{} (n.round), {} (recipient),\"\n                     + \" {} (myid) \",\n                 proposedLeader,\n                 Long.toHexString(proposedZxid),",
      "parent_sha": "66202cb764c203f64b954a917e421be57d2ae67a"
    }
  },
  {
    "oid": "39973dc5fddf778733e4f0370980629c07a16d67",
    "message": "ZOOKEEPER-4807: Add sid in the leader goodbyte log.\n\nReviewers: maoling\nAuthor: horizonzy\nCloses #2131 from horizonzy/tune-leader-goodbye-follower-log",
    "date": "2024-06-15T09:49:40Z",
    "url": "https://github.com/apache/zookeeper/commit/39973dc5fddf778733e4f0370980629c07a16d67",
    "details": {
      "sha": "57947daa86c0c838ed837b61b0b4edd6d091ca16",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LearnerHandler.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/39973dc5fddf778733e4f0370980629c07a16d67/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerHandler.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/39973dc5fddf778733e4f0370980629c07a16d67/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerHandler.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerHandler.java?ref=39973dc5fddf778733e4f0370980629c07a16d67",
      "patch": "@@ -733,7 +733,7 @@ public void run() {\n                 syncThrottler = null;\n             }\n             String remoteAddr = getRemoteAddress();\n-            LOG.warn(\"******* GOODBYE {} ********\", remoteAddr);\n+            LOG.warn(\"******* GOODBYE sid:{} {} ********\", getSid(), remoteAddr);\n             messageTracker.dumpToLog(remoteAddr);\n             shutdown();\n         }",
      "parent_sha": "bccc654e09d9e85fe3495487b9619173a2c54151"
    }
  },
  {
    "oid": "e08cc2a782982964a57651f179a468b19e2e6010",
    "message": "ZOOKEEPER-4718: Removing unnecessary heap memory allocation in serialization to help reduce GC pressure (#2031)",
    "date": "2023-07-07T01:55:30Z",
    "url": "https://github.com/apache/zookeeper/commit/e08cc2a782982964a57651f179a468b19e2e6010",
    "details": {
      "sha": "e38772f009e71f9b81e96ca74066a7010ba37b8f",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/util/SerializeUtils.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/apache/zookeeper/blob/e08cc2a782982964a57651f179a468b19e2e6010/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Futil%2FSerializeUtils.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/e08cc2a782982964a57651f179a468b19e2e6010/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Futil%2FSerializeUtils.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Futil%2FSerializeUtils.java?ref=e08cc2a782982964a57651f179a468b19e2e6010",
      "patch": "@@ -175,11 +175,12 @@ public static byte[] serializeRequest(Request request) {\n         if (request == null || request.getHdr() == null) {\n             return null;\n         }\n-        byte[] data = new byte[32];\n+        byte[] data;\n         try {\n             data = Util.marshallTxnEntry(request.getHdr(), request.getTxn(), request.getTxnDigest());\n         } catch (IOException e) {\n             LOG.error(\"This really should be impossible\", e);\n+            data = new byte[32];\n         }\n         return data;\n     }",
      "parent_sha": "2edb73a943928e0716b91e8a1d06a9c226fa393c"
    }
  },
  {
    "oid": "726587ef50339f071960d153cc4599882aa71ac7",
    "message": "ZOOKEEPER-3061: add more details to 'Unhandled scenario for peer' log.warn message\n\nAuthor: Christine Poerschke <cpoerschke@bloomberg.net>\nAuthor: Christine Poerschke <cpoerschke@apache.org>\n\nReviewers: Allan Lyu <fangmin@apache.org>, Benjamin Reed <breed@apache.org>, Norbert Kalmar <nkalmar@yahoo.com>\n\nCloses #555 from cpoerschke/master-ZOOKEEPER-3061 and squashes the following commits:\n\n139968228 [Christine Poerschke] Merge remote-tracking branch 'origin/master' into master-ZOOKEEPER-3061\n1840c2bb6 [Christine Poerschke] Merge remote-tracking branch 'origin/master' into master-ZOOKEEPER-3061\n1d3e7bc0b [Christine Poerschke] ZOOKEEPER-3061: add more details to 'Unhandled scenario for peer' log.warn message",
    "date": "2018-07-28T02:30:06Z",
    "url": "https://github.com/apache/zookeeper/commit/726587ef50339f071960d153cc4599882aa71ac7",
    "details": {
      "sha": "023d6a63ca2de49c2bb2f2055d4cff65271db763",
      "filename": "src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/apache/zookeeper/blob/726587ef50339f071960d153cc4599882aa71ac7/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerHandler.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/726587ef50339f071960d153cc4599882aa71ac7/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerHandler.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerHandler.java?ref=726587ef50339f071960d153cc4599882aa71ac7",
      "patch": "@@ -792,7 +792,14 @@ public boolean syncFollower(long peerLastZxid, ZKDatabase db, Leader leader) {\n                     txnProposalItr.close();\n                 }\n             } else {\n-                LOG.warn(\"Unhandled scenario for peer sid: \" +  getSid());\n+                LOG.warn(\"Unhandled scenario for peer sid: {} maxCommittedLog=0x{}\"\n+                        + \" minCommittedLog=0x{} lastProcessedZxid=0x{}\"\n+                        + \" peerLastZxid=0x{} txnLogSyncEnabled={}\", getSid(),\n+                        Long.toHexString(maxCommittedLog),\n+                        Long.toHexString(minCommittedLog),\n+                        Long.toHexString(lastProcessedZxid),\n+                        Long.toHexString(peerLastZxid),\n+                        txnLogSyncEnabled);\n             }\n             LOG.debug(\"Start forwarding 0x\" + Long.toHexString(currentZxid) +\n                       \" for peer sid: \" +  getSid());",
      "parent_sha": "01132edbd4df3df4472a2f8d3077fe585035cce1"
    }
  },
  {
    "oid": "ebcb21f448d92c19e025279f3c27bbdb2fc75af5",
    "message": "making the tests to compile since e thsignatrue for QuorumPeer changes.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/zookeeper/trunk@670904 13f79535-47bb-0310-9956-ffa450edef68",
    "date": "2008-03-11T18:30:02Z",
    "url": "https://github.com/apache/zookeeper/commit/ebcb21f448d92c19e025279f3c27bbdb2fc75af5",
    "details": {
      "sha": "6a5dd06a4aff654aef72bf31164dc2ac0487df04",
      "filename": "zookeeper/test/com/yahoo/zookeeper/test/QuorumTest.java",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/apache/zookeeper/blob/ebcb21f448d92c19e025279f3c27bbdb2fc75af5/zookeeper%2Ftest%2Fcom%2Fyahoo%2Fzookeeper%2Ftest%2FQuorumTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/ebcb21f448d92c19e025279f3c27bbdb2fc75af5/zookeeper%2Ftest%2Fcom%2Fyahoo%2Fzookeeper%2Ftest%2FQuorumTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper%2Ftest%2Fcom%2Fyahoo%2Fzookeeper%2Ftest%2FQuorumTest.java?ref=ebcb21f448d92c19e025279f3c27bbdb2fc75af5",
      "patch": "@@ -50,15 +50,15 @@ void startServers() throws IOException, InterruptedException {\n         peers.add(new QuorumServer(4, new InetSocketAddress(\"127.0.0.1\", 3184)));\n         peers.add(new QuorumServer(5, new InetSocketAddress(\"127.0.0.1\", 3185)));\n         ZooLog.logWarn(\"creating QuorumPeer 1\");\n-        s1 = new QuorumPeer(peers, s1dir, s1dir, 2181, 0,  1, tickTime, initLimit, syncLimit);\n+        s1 = new QuorumPeer(peers, s1dir, s1dir, 2181, 0,  1181, 1, tickTime, initLimit, syncLimit);\n         ZooLog.logWarn(\"creating QuorumPeer 2\");\n-        s2 = new QuorumPeer(peers, s2dir, s2dir, 2182, 0,  2, tickTime, initLimit, syncLimit);\n+        s2 = new QuorumPeer(peers, s2dir, s2dir, 2182, 0, 1182, 2, tickTime, initLimit, syncLimit);\n         ZooLog.logWarn(\"creating QuorumPeer 3\");\n-        s3 = new QuorumPeer(peers, s3dir, s3dir, 2183, 0, 3, tickTime, initLimit, syncLimit);\n+        s3 = new QuorumPeer(peers, s3dir, s3dir, 2183, 0, 1183, 3, tickTime, initLimit, syncLimit);\n         ZooLog.logWarn(\"creating QuorumPeer 4\");\n-        s4 = new QuorumPeer(peers, s4dir, s4dir, 2184, 0, 4, tickTime, initLimit, syncLimit);\n+        s4 = new QuorumPeer(peers, s4dir, s4dir, 2184, 0, 1184, 4, tickTime, initLimit, syncLimit);\n         ZooLog.logWarn(\"creating QuorumPeer 5\");\n-        s5 = new QuorumPeer(peers, s5dir, s5dir, 2185, 0, 5, tickTime, initLimit, syncLimit);\n+        s5 = new QuorumPeer(peers, s5dir, s5dir, 2185, 0, 1185, 5, tickTime, initLimit, syncLimit);\n         ZooLog.logWarn(\"start QuorumPeer 1\");\n         s1.start();\n         ZooLog.logWarn(\"start QuorumPeer 2\");",
      "parent_sha": "cf6e81cb24dc8f0f7cd3f52bab48e2781f8c463d"
    }
  },
  {
    "oid": "069c3e4fccbd56307b19b57864fbf6312ace2219",
    "message": "ZOOKEEPER-2824: `FileChannel#size` info should be added to `FileTxnLog#commit` to solve the confuse that reason is too large log or too busy disk I/O\n\n`FileChannel#size` info should be added to `FileTxnLog#commit` to solve the confuse that reason is too large log or too busy disk I/O\n\n------\nExample from jenkins [log](https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/830/console):\n```java\n2017-06-28 10:25:16,645 [myid:] - WARN  [SyncThread:0:FileTxnLog341] - fsync-ing the write ahead log (1945616 bytes) in SyncThread:0 took 2240ms which will adversely effect operation latency. See the ZooKeeper troubleshooting guide\n```\n\nAuthor: asdf2014 <benedictjin2016@gmail.com>\nAuthor: asdf2014 <1571805553@qq.com>\n\nReviewers: Patrick Hunt <phunt@apache.org>, Andor Moln\u00e1r <andor@cloudera.com>, Abraham Fine <afine@apache.org>\n\nCloses #296 from asdf2014/ZOOKEEPER-2824 and squashes the following commits:\n\n7cf4b6848 [asdf2014] Improve latency log description\ndd2268f2f [asdf2014] ZOOKEEPER-2824: `FileChannel#size` info should be added to `FileTxnLog#commit` to solve the confuse that reason is too large log or too busy disk I/O",
    "date": "2018-02-01T23:26:58Z",
    "url": "https://github.com/apache/zookeeper/commit/069c3e4fccbd56307b19b57864fbf6312ace2219",
    "details": {
      "sha": "9edc38e5095de0d2e2b7404933946e6a5ab7b94a",
      "filename": "src/java/main/org/apache/zookeeper/server/persistence/FileTxnLog.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/apache/zookeeper/blob/069c3e4fccbd56307b19b57864fbf6312ace2219/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fpersistence%2FFileTxnLog.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/069c3e4fccbd56307b19b57864fbf6312ace2219/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fpersistence%2FFileTxnLog.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fpersistence%2FFileTxnLog.java?ref=069c3e4fccbd56307b19b57864fbf6312ace2219",
      "patch": "@@ -370,14 +370,16 @@ public synchronized void commit() throws IOException {\n             if (forceSync) {\n                 long startSyncNS = System.nanoTime();\n \n-                log.getChannel().force(false);\n+                FileChannel channel = log.getChannel();\n+                channel.force(false);\n \n                 syncElapsedMS = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startSyncNS);\n                 if (syncElapsedMS > fsyncWarningThresholdMS) {\n                     LOG.warn(\"fsync-ing the write ahead log in \"\n                             + Thread.currentThread().getName()\n                             + \" took \" + syncElapsedMS\n                             + \"ms which will adversely effect operation latency. \"\n+                            + \"File size is \" + channel.size() + \" bytes. \"\n                             + \"See the ZooKeeper troubleshooting guide\");\n                 }\n             }",
      "parent_sha": "66554218a557cbc86924354bdb20e20b20ff934f"
    }
  },
  {
    "oid": "f0b67b6e49acec5f022bee25e08f82a29572c97a",
    "message": "ZOOKEEPER-2978: fix potential null pointer exception when deleting node\n\nAt line 518, 'existWatches.remove(clientPath)' is null because watches for clientPath is already removed.\n\nAuthor: 07c00h <07c00h@gmail.com>\n\nReviewers: Abraham Fine <afine@apache.org>\n\nCloses #461 from achimbab/master",
    "date": "2018-02-20T22:38:00Z",
    "url": "https://github.com/apache/zookeeper/commit/f0b67b6e49acec5f022bee25e08f82a29572c97a",
    "details": {
      "sha": "0967b0ac34115ee705f900091a012fd4ee5bbff5",
      "filename": "src/java/main/org/apache/zookeeper/ZooKeeper.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/f0b67b6e49acec5f022bee25e08f82a29572c97a/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FZooKeeper.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/f0b67b6e49acec5f022bee25e08f82a29572c97a/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FZooKeeper.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FZooKeeper.java?ref=f0b67b6e49acec5f022bee25e08f82a29572c97a",
      "patch": "@@ -515,7 +515,7 @@ public Set<Watcher> materialize(Watcher.Event.KeeperState state,\n                 synchronized (existWatches) {\n                     Set<Watcher> list = existWatches.remove(clientPath);\n                     if (list != null) {\n-                        addTo(existWatches.remove(clientPath), result);\n+                        addTo(list, result);\n                         LOG.warn(\"We are triggering an exists watch for delete! Shouldn't happen!\");\n                     }\n                 }",
      "parent_sha": "bebe4162bc915b15b4fd90df9446bdf9f83ef3a8"
    }
  },
  {
    "oid": "6dc61adbe41c712fbce930e598b3556da54e0667",
    "message": "ZOOKEEPER-3341: Remove Superfluous ByteBuffer Duplicate\n\nAuthor: Beluga Behr <dam6923@gmail.com>\n\nReviewers: andor@apache.org\n\nCloses #881 from BELUGABEHR/ZOOKEEPER-3341",
    "date": "2019-04-09T14:08:29Z",
    "url": "https://github.com/apache/zookeeper/commit/6dc61adbe41c712fbce930e598b3556da54e0667",
    "details": {
      "sha": "35f352901f1666b45c395ca50352f4af3d848b6b",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumCnxManager.java",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/apache/zookeeper/blob/6dc61adbe41c712fbce930e598b3556da54e0667/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumCnxManager.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/6dc61adbe41c712fbce930e598b3556da54e0667/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumCnxManager.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumCnxManager.java?ref=6dc61adbe41c712fbce930e598b3556da54e0667",
      "patch": "@@ -1192,10 +1192,9 @@ public void run() {\n                     /**\n                      * Allocates a new ByteBuffer to receive the message\n                      */\n-                    byte[] msgArray = new byte[length];\n+                    final byte[] msgArray = new byte[length];\n                     din.readFully(msgArray, 0, length);\n-                    ByteBuffer message = ByteBuffer.wrap(msgArray);\n-                    addToRecvQueue(new Message(message.duplicate(), sid));\n+                    addToRecvQueue(new Message(ByteBuffer.wrap(msgArray), sid));\n                 }\n             } catch (Exception e) {\n                 LOG.warn(\"Connection broken for id \" + sid + \", my id = \"",
      "parent_sha": "57e8318bc98dd3563085e08b0fcfcbc6a1c5fbcc"
    }
  },
  {
    "oid": "e7ac12c952b47921bfecbad52112be51f5b9ede5",
    "message": "ZOOKEEPER-2913: testEphemeralNodeDeletion is flaky\n\n- The test code is assuming the follower is up to date, which without a `sync` call.when regression,the follower could not catch up with the leader,so the `/e1` patch still exists\n- this issue is not very easy to reproduce,but we can change the codes in the `FollowerZooKeeperServer.commit() ` ,just like this:\n\n```\n       Request request = pendingTxns.remove();\n        if (request.getHdr().getType() == -11) {\n        \ttry {\n    \t\t\tThread.sleep(200);\n    \t\t} catch (InterruptedException e) {\n\n    \t\t}\n        }\n        commitProcessor.commit(request);\n```\nto slow down the commit to simulate the flaky test,then we can check the correctness of this patch\n- ----------------------------------------**appendix: zk.sync() doc\uff1a**------------------------------------------\n\n> ZooKeeper does not guarantee that at every instance in time, two different clients will have identical views of ZooKeeper data. Due to factors like network delays, one client may perform an update before another client gets notified of the change. Consider the scenario of two clients, A and B. If client A sets the value of a znode /a from 0 to 1, then tells client B to read /a, client B may read the old value of 0, depending on which server it is connected to. If it is important that Client A and Client B read the same value, Client B should should call the sync() method from the ZooKeeper API method before it performs its read.\n\n- more detais in [ZOOKEEPER-2913](https://issues.apache.org/jira/browse/ZOOKEEPER-2913)\n\nAuthor: maoling <maoling199210191@sina.com>\n\nReviewers: andor@apache.org\n\nCloses #608 from maoling/ZOOKEEPER-2913",
    "date": "2018-09-05T14:15:58Z",
    "url": "https://github.com/apache/zookeeper/commit/e7ac12c952b47921bfecbad52112be51f5b9ede5",
    "details": {
      "sha": "9546c25cc7969da31fe616cec5a8fb6f2ab0a361",
      "filename": "src/java/test/org/apache/zookeeper/server/quorum/EphemeralNodeDeletionTest.java",
      "status": "modified",
      "additions": 17,
      "deletions": 1,
      "changes": 18,
      "blob_url": "https://github.com/apache/zookeeper/blob/e7ac12c952b47921bfecbad52112be51f5b9ede5/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FEphemeralNodeDeletionTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/e7ac12c952b47921bfecbad52112be51f5b9ede5/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FEphemeralNodeDeletionTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FEphemeralNodeDeletionTest.java?ref=e7ac12c952b47921bfecbad52112be51f5b9ede5",
      "patch": "@@ -24,7 +24,10 @@\n \n import java.io.IOException;\n import java.net.SocketTimeoutException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n \n+import org.apache.zookeeper.AsyncCallback;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.PortAssignment;\n import org.apache.zookeeper.ZooDefs.Ids;\n@@ -147,7 +150,11 @@ public TestQPMain getTestQPMain() {\n \n         // close the session and newly created ephemeral node should be deleted\n         zk.close();\n-\n+        \n+        SyncCallback cb = new SyncCallback();\n+        followerZK.sync(nodePath, cb, null);\n+        cb.sync.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);\n+        \n         nodeAtFollower = followerZK.exists(nodePath, false);\n \n         // Problem 2: Before fix, after session close the ephemeral node\n@@ -225,4 +232,13 @@ protected QuorumPeer getQuorumPeer() throws SaslException {\n             return new CustomQuorumPeer();\n         }\n     }\n+    \n+    private static class SyncCallback implements AsyncCallback.VoidCallback {\n+        private final CountDownLatch sync = new CountDownLatch(1);\n+        \n+        @Override\n+        public void processResult(int rc, String path, Object ctx) {\n+        \tsync.countDown();\n+        }\n+    }\n }",
      "parent_sha": "687ea7e7cecf1449687e05819502be28cb49cb66"
    }
  },
  {
    "oid": "0c5b320060bdda854b530dc8a22993ba8cbbd655",
    "message": "ZOOKEEPER-2870: Improve the efficiency of AtomicFileOutputStream\n\nAuthor: Fangmin Lyu <allenlyu@fb.com>\n\nReviewers: Michael Han <hanm@apache.org>\n\nCloses #331 from lvfangmin/ZOOKEEPER-2870",
    "date": "2017-08-10T20:14:22Z",
    "url": "https://github.com/apache/zookeeper/commit/0c5b320060bdda854b530dc8a22993ba8cbbd655",
    "details": {
      "sha": "740ae8f6787776280c50413b9383bb7097af9933",
      "filename": "src/java/main/org/apache/zookeeper/common/AtomicFileOutputStream.java",
      "status": "modified",
      "additions": 13,
      "deletions": 2,
      "changes": 15,
      "blob_url": "https://github.com/apache/zookeeper/blob/0c5b320060bdda854b530dc8a22993ba8cbbd655/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fcommon%2FAtomicFileOutputStream.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/0c5b320060bdda854b530dc8a22993ba8cbbd655/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fcommon%2FAtomicFileOutputStream.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fcommon%2FAtomicFileOutputStream.java?ref=0c5b320060bdda854b530dc8a22993ba8cbbd655",
      "patch": "@@ -35,10 +35,10 @@\n  * A FileOutputStream that has the property that it will only show up at its\n  * destination once it has been entirely written and flushed to disk. While\n  * being written, it will use a .tmp suffix.\n- * \n+ *\n  * When the output stream is closed, it is flushed, fsynced, and will be moved\n  * into place, overwriting any file that already exists at that location.\n- * \n+ *\n  * <b>NOTE</b>: on Windows platforms, it will not atomically replace the target\n  * file - instead the target file is deleted before this one is moved into\n  * place.\n@@ -63,6 +63,17 @@ public AtomicFileOutputStream(File f) throws FileNotFoundException {\n                 .getAbsoluteFile();\n     }\n \n+    /**\n+     * The default write method in FilterOutputStream does not call the write\n+     * method of its underlying input stream with the same arguments. Instead\n+     * it writes the data byte by byte, override it here to make it more\n+     * efficient.\n+     */\n+    @Override\n+    public void write(byte b[], int off, int len) throws IOException {\n+        out.write(b, off, len);\n+    }\n+\n     @Override\n     public void close() throws IOException {\n         boolean triedToClose = false, success = false;",
      "parent_sha": "3408b62b5b18a02a4ef689137c8cb8e5ce083cf2"
    }
  },
  {
    "oid": "8853b33fa6abd132ab7d446296eca5f4445f9c2c",
    "message": "ZOOKEEPER-2649: Add more session and authentication information to SASL success and failure logs\n\n\u2026ASL success and failure logs.\n\nAnother one from the backlogs - created in 2016, no activity since 6 months.\n\nJIRA: https://issues.apache.org/jira/browse/ZOOKEEPER-2649\n\ncc eolivelli\n\nAuthor: Ghatage <ghatageanup@gmail.com>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>, Mate Szalay-Beko <symat@apache.org>, Damien Diederen <ddiederen@apache.org>\n\nCloses #1498 from Ghatage/ZOOKEEPER-2649",
    "date": "2020-10-28T15:27:44Z",
    "url": "https://github.com/apache/zookeeper/commit/8853b33fa6abd132ab7d446296eca5f4445f9c2c",
    "details": {
      "sha": "ab556f59954cd954b8bd571e7f9e76bb0df870af",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/ZooKeeperServer.java",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/apache/zookeeper/blob/8853b33fa6abd132ab7d446296eca5f4445f9c2c/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperServer.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/8853b33fa6abd132ab7d446296eca5f4445f9c2c/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperServer.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperServer.java?ref=8853b33fa6abd132ab7d446296eca5f4445f9c2c",
      "patch": "@@ -1601,8 +1601,9 @@ public void processPacket(ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOE\n                 }\n             }\n             if (authReturn == KeeperException.Code.OK) {\n-                LOG.debug(\"Authentication succeeded for scheme: {}\", scheme);\n-                LOG.info(\"auth success {}\", cnxn.getRemoteSocketAddress());\n+                LOG.info(\"Session 0x{}: auth success for scheme {} and address {}\",\n+                        Long.toHexString(cnxn.getSessionId()), scheme,\n+                        cnxn.getRemoteSocketAddress());\n                 ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.OK.intValue());\n                 cnxn.sendResponse(rh, null, null);\n             } else {\n@@ -1663,7 +1664,8 @@ private void processSasl(ByteBuffer incomingBuffer, ServerCnxn cnxn, RequestHead\n                 responseToken = saslServer.evaluateResponse(clientToken);\n                 if (saslServer.isComplete()) {\n                     String authorizationID = saslServer.getAuthorizationID();\n-                    LOG.info(\"adding SASL authorization for authorizationID: {}\", authorizationID);\n+                    LOG.info(\"Session 0x{}: adding SASL authorization for authorizationID: {}\",\n+                            Long.toHexString(cnxn.getSessionId()), authorizationID);\n                     cnxn.addAuthInfo(new Id(\"sasl\", authorizationID));\n                     if (System.getProperty(\"zookeeper.superUser\") != null\n                         && authorizationID.equals(System.getProperty(\"zookeeper.superUser\"))) {",
      "parent_sha": "b59bf6b40d9948e4a9034b6342b7f98a71d8d616"
    }
  },
  {
    "oid": "94d0c4d8558e1b201665bb9dffd33dacbc7ca945",
    "message": "ZOOKEEPER-4221: Improve the error message when message goes above jute.maxbufer size\n\nAuthor: Mathieu Marie <mmarie@salesforce.com>\n\nReviewers: Damien Diederen <dd@crosstwine.com>,\u00a0Mate Szalay-Beko <symat@apache.org>\n\nCloses #1614 from mariemat/ZOOKEEPER-4221",
    "date": "2021-02-26T09:35:02Z",
    "url": "https://github.com/apache/zookeeper/commit/94d0c4d8558e1b201665bb9dffd33dacbc7ca945",
    "details": {
      "sha": "02cde23a917e5d16bb3b6cf366861ee72293be75",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/NIOServerCnxn.java",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/apache/zookeeper/blob/94d0c4d8558e1b201665bb9dffd33dacbc7ca945/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNIOServerCnxn.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/94d0c4d8558e1b201665bb9dffd33dacbc7ca945/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNIOServerCnxn.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNIOServerCnxn.java?ref=94d0c4d8558e1b201665bb9dffd33dacbc7ca945",
      "patch": "@@ -545,7 +545,10 @@ private boolean readLength(SelectionKey k) throws IOException {\n             return false;\n         }\n         if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n-            throw new IOException(\"Len error \" + len);\n+            throw new IOException(\"Len error. \"\n+                    + \"A message from \" +  this.getRemoteSocketAddress() + \" with advertised length of \" + len\n+                    + \" is either a malformed message or too large to process\"\n+                    + \" (length is greater than jute.maxbuffer=\" + BinaryInputArchive.maxBuffer + \")\");\n         }\n         if (!isZKServerRunning()) {\n             throw new IOException(\"ZooKeeperServer not running\");",
      "parent_sha": "37eae03080b93d63a6ba9f624b37c764511ad2dc"
    }
  },
  {
    "oid": "e7de1cf04925b7e1d06f9add83d90760e5a7a241",
    "message": "ZOOKEEPER-4333: QuorumSSLTest - testOCSP fails on JDK17\n\nhttps://issues.apache.org/jira/browse/ZOOKEEPER-4333\n\nin JDK17 the OCSP request is sent in the URI and not inside the POST BODY\n\nAuthor: Enrico Olivelli <eolivelli@apache.org>\nAuthor: Enrico Olivelli <eolivelli@gmail.com>\n\nReviewers: Damien Diederen <ddiederen@apache.org>\n\nCloses #1724 from eolivelli/fix/jdk17",
    "date": "2021-07-28T13:15:22Z",
    "url": "https://github.com/apache/zookeeper/commit/e7de1cf04925b7e1d06f9add83d90760e5a7a241",
    "details": {
      "sha": "ec8465c7cf6063672fdc4c1a090a5b9dca91be35",
      "filename": "zookeeper-server/src/test/java/org/apache/zookeeper/server/quorum/QuorumSSLTest.java",
      "status": "modified",
      "additions": 23,
      "deletions": 3,
      "changes": 26,
      "blob_url": "https://github.com/apache/zookeeper/blob/e7de1cf04925b7e1d06f9add83d90760e5a7a241/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumSSLTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/e7de1cf04925b7e1d06f9add83d90760e5a7a241/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumSSLTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumSSLTest.java?ref=e7de1cf04925b7e1d06f9add83d90760e5a7a241",
      "patch": "@@ -34,6 +34,7 @@\n import java.io.OutputStream;\n import java.math.BigInteger;\n import java.net.InetSocketAddress;\n+import java.net.URLDecoder;\n import java.security.KeyPair;\n import java.security.KeyPairGenerator;\n import java.security.KeyStore;\n@@ -45,6 +46,8 @@\n import java.security.cert.CertificateEncodingException;\n import java.security.cert.X509Certificate;\n import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n import java.util.Calendar;\n import java.util.Date;\n import java.util.HashMap;\n@@ -224,12 +227,24 @@ public OCSPHandler(X509Certificate revokedCert) {\n         public void handle(com.sun.net.httpserver.HttpExchange httpExchange) throws IOException {\n             byte[] responseBytes;\n             try {\n+                String uri = httpExchange.getRequestURI().toString();\n+                LOG.info(\"OCSP request: {} {}\", httpExchange.getRequestMethod(), uri);\n+                httpExchange.getRequestHeaders().entrySet().forEach((e) -> {\n+                    LOG.info(\"OCSP request header: {} {}\", e.getKey(), e.getValue());\n+                });\n                 InputStream request = httpExchange.getRequestBody();\n                 byte[] requestBytes = new byte[10000];\n-                request.read(requestBytes);\n+                int len = request.read(requestBytes);\n+                LOG.info(\"OCSP request size {}\", len);\n \n+                if (len < 0) {\n+                    String removedUriEncoding = URLDecoder.decode(uri.substring(1), \"utf-8\");\n+                    LOG.info(\"OCSP request from URI no encoding {}\", removedUriEncoding);\n+                    requestBytes = Base64.getDecoder().decode(removedUriEncoding);\n+                }\n                 OCSPReq ocspRequest = new OCSPReq(requestBytes);\n                 Req[] requestList = ocspRequest.getRequestList();\n+                LOG.info(\"requestList {}\", Arrays.toString(requestList));\n \n                 DigestCalculator digestCalculator = new JcaDigestCalculatorProviderBuilder().build().get(CertificateID.HASH_SHA1);\n \n@@ -243,16 +258,21 @@ public void handle(com.sun.net.httpserver.HttpExchange httpExchange) throws IOEx\n                     } else {\n                         certificateStatus = CertificateStatus.GOOD;\n                     }\n-\n+                    LOG.info(\"addResponse {} {}\", certId, certificateStatus);\n                     responseBuilder.addResponse(certId, certificateStatus, null);\n                 }\n \n                 X509CertificateHolder[] chain = new X509CertificateHolder[]{new JcaX509CertificateHolder(rootCertificate)};\n                 ContentSigner signer = new JcaContentSignerBuilder(\"SHA1withRSA\").setProvider(\"BC\").build(rootKeyPair.getPrivate());\n                 BasicOCSPResp ocspResponse = responseBuilder.build(signer, chain, Calendar.getInstance().getTime());\n-\n+                LOG.info(\"response {}\", ocspResponse);\n                 responseBytes = new OCSPRespBuilder().build(OCSPRespBuilder.SUCCESSFUL, ocspResponse).getEncoded();\n+                LOG.error(\"OCSP server response OK\");\n             } catch (OperatorException | CertificateEncodingException | OCSPException exception) {\n+                LOG.error(\"Internal OCSP server error\", exception);\n+                responseBytes = new OCSPResp(new OCSPResponse(new OCSPResponseStatus(OCSPRespBuilder.INTERNAL_ERROR), null)).getEncoded();\n+            } catch (Throwable exception) {\n+                LOG.error(\"Internal OCSP server error\", exception);\n                 responseBytes = new OCSPResp(new OCSPResponse(new OCSPResponseStatus(OCSPRespBuilder.INTERNAL_ERROR), null)).getEncoded();\n             }\n ",
      "parent_sha": "a692cbab92e9bae53c9313241d9668d9de97ed8b"
    }
  },
  {
    "oid": "f530ab91f1986027223bff72f01f965a24d6fd53",
    "message": "ZOOKEEPER-3694: Use Map computeIfAbsent in AvgMinMaxCounterSet Class\n\nAuthor: David Mollitor <dmollitor@apache.org>\n\nReviewers: eolivelli@apache.org, maoling199210191@sina.com, fangmin@apache.org\n\nCloses #1218 from belugabehr/ZOOKEEPER-3694",
    "date": "2020-01-16T20:46:10Z",
    "url": "https://github.com/apache/zookeeper/commit/f530ab91f1986027223bff72f01f965a24d6fd53",
    "details": {
      "sha": "8696950ebfa7d70b059bc5c5330e943dedcc8bb5",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/metric/AvgMinMaxCounterSet.java",
      "status": "modified",
      "additions": 1,
      "deletions": 7,
      "changes": 8,
      "blob_url": "https://github.com/apache/zookeeper/blob/f530ab91f1986027223bff72f01f965a24d6fd53/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fmetric%2FAvgMinMaxCounterSet.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/f530ab91f1986027223bff72f01f965a24d6fd53/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fmetric%2FAvgMinMaxCounterSet.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fmetric%2FAvgMinMaxCounterSet.java?ref=f530ab91f1986027223bff72f01f965a24d6fd53",
      "patch": "@@ -39,13 +39,7 @@ public AvgMinMaxCounterSet(String name) {\n     }\n \n     private AvgMinMaxCounter getCounterForKey(String key) {\n-        AvgMinMaxCounter counter = counters.get(key);\n-        if (counter == null) {\n-            counters.putIfAbsent(key, new AvgMinMaxCounter(key + \"_\" + name));\n-            counter = counters.get(key);\n-        }\n-\n-        return counter;\n+        return counters.computeIfAbsent(key, k-> new AvgMinMaxCounter(k + \"_\" + name));\n     }\n \n     public void addDataPoint(String key, long value) {",
      "parent_sha": "1c5d135d74f16275876c024401dc2de92909b20a"
    }
  },
  {
    "oid": "d72f27279a13986ee0c011e1e5b34edf3a310da9",
    "message": "ZOOKEEPER-2636: Fix C client build break.\n\nJIRA: https://issues.apache.org/jira/browse/ZOOKEEPER-2636\n\nFix build break by reverting the changes made to JRecord.genCCode in ZOOKEEPER-2686, which prematurely closed the file writers that prevents zookeeper.jute.h and zookeeper.jute.c files from complete generation.\n\nAuthor: Michael Han <hanm@cloudera.com>\n\nReviewers: fpj <fpj@apache.org>\n\nCloses #115 from hanm/ZOOKEEPER-2636",
    "date": "2016-11-25T06:08:55Z",
    "url": "https://github.com/apache/zookeeper/commit/d72f27279a13986ee0c011e1e5b34edf3a310da9",
    "details": {
      "sha": "bc98d900ee59abd0d758113c55498066837fc265",
      "filename": "src/java/main/org/apache/jute/compiler/JRecord.java",
      "status": "modified",
      "additions": 99,
      "deletions": 106,
      "changes": 205,
      "blob_url": "https://github.com/apache/zookeeper/blob/d72f27279a13986ee0c011e1e5b34edf3a310da9/src%2Fjava%2Fmain%2Forg%2Fapache%2Fjute%2Fcompiler%2FJRecord.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/d72f27279a13986ee0c011e1e5b34edf3a310da9/src%2Fjava%2Fmain%2Forg%2Fapache%2Fjute%2Fcompiler%2FJRecord.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fjute%2Fcompiler%2FJRecord.java?ref=d72f27279a13986ee0c011e1e5b34edf3a310da9",
      "patch": "@@ -141,116 +141,109 @@ public String genCsharpWriteWrapper(String fname, String tag) {\n \n     static HashMap<String, String> vectorStructs = new HashMap<String, String>();\n     public void genCCode(FileWriter h, FileWriter c) throws IOException {\n-        try {\n-            for (JField f : mFields) {\n-                if (f.getType() instanceof JVector) {\n-                    JVector jv = (JVector) f.getType();\n-                    JType jvType = jv.getElementType();\n-                    String struct_name = JVector.extractVectorName(jvType);\n-                    if (vectorStructs.get(struct_name) == null) {\n-                        vectorStructs.put(struct_name, struct_name);\n-                        h.write(\"struct \" + struct_name + \" {\\n    int32_t count;\\n\" + jv.getElementType().genCDecl(\"*data\") + \"\\n};\\n\");\n-                        h.write(\"int serialize_\" + struct_name + \"(struct oarchive *out, const char *tag, struct \" + struct_name + \" *v);\\n\");\n-                        h.write(\"int deserialize_\" + struct_name + \"(struct iarchive *in, const char *tag, struct \" + struct_name + \" *v);\\n\");\n-                        h.write(\"int allocate_\" + struct_name + \"(struct \" + struct_name + \" *v, int32_t len);\\n\");\n-                        h.write(\"int deallocate_\" + struct_name + \"(struct \" + struct_name + \" *v);\\n\");\n-                        c.write(\"int allocate_\" + struct_name + \"(struct \" + struct_name + \" *v, int32_t len) {\\n\");\n-                        c.write(\"    if (!len) {\\n\");\n-                        c.write(\"        v->count = 0;\\n\");\n-                        c.write(\"        v->data = 0;\\n\");\n-                        c.write(\"    } else {\\n\");\n-                        c.write(\"        v->count = len;\\n\");\n-                        c.write(\"        v->data = calloc(sizeof(*v->data), len);\\n\");\n-                        c.write(\"    }\\n\");\n-                        c.write(\"    return 0;\\n\");\n-                        c.write(\"}\\n\");\n-                        c.write(\"int deallocate_\" + struct_name + \"(struct \" + struct_name + \" *v) {\\n\");\n-                        c.write(\"    if (v->data) {\\n\");\n-                        c.write(\"        int32_t i;\\n\");\n-                        c.write(\"        for(i=0;i<v->count; i++) {\\n\");\n-                        c.write(\"            deallocate_\" + JRecord.extractMethodSuffix(jvType) + \"(&v->data[i]);\\n\");\n-                        c.write(\"        }\\n\");\n-                        c.write(\"        free(v->data);\\n\");\n-                        c.write(\"        v->data = 0;\\n\");\n-                        c.write(\"    }\\n\");\n-                        c.write(\"    return 0;\\n\");\n-                        c.write(\"}\\n\");\n-                        c.write(\"int serialize_\" + struct_name + \"(struct oarchive *out, const char *tag, struct \" + struct_name + \" *v)\\n\");\n-                        c.write(\"{\\n\");\n-                        c.write(\"    int32_t count = v->count;\\n\");\n-                        c.write(\"    int rc = 0;\\n\");\n-                        c.write(\"    int32_t i;\\n\");\n-                        c.write(\"    rc = out->start_vector(out, tag, &count);\\n\");\n-                        c.write(\"    for(i=0;i<v->count;i++) {\\n\");\n-                        genSerialize(c, jvType, \"data\", \"data[i]\");\n-                        c.write(\"    }\\n\");\n-                        c.write(\"    rc = rc ? rc : out->end_vector(out, tag);\\n\");\n-                        c.write(\"    return rc;\\n\");\n-                        c.write(\"}\\n\");\n-                        c.write(\"int deserialize_\" + struct_name + \"(struct iarchive *in, const char *tag, struct \" + struct_name + \" *v)\\n\");\n-                        c.write(\"{\\n\");\n-                        c.write(\"    int rc = 0;\\n\");\n-                        c.write(\"    int32_t i;\\n\");\n-                        c.write(\"    rc = in->start_vector(in, tag, &v->count);\\n\");\n-                        c.write(\"    v->data = calloc(v->count, sizeof(*v->data));\\n\");\n-                        c.write(\"    for(i=0;i<v->count;i++) {\\n\");\n-                        genDeserialize(c, jvType, \"value\", \"data[i]\");\n-                        c.write(\"    }\\n\");\n-                        c.write(\"    rc = in->end_vector(in, tag);\\n\");\n-                        c.write(\"    return rc;\\n\");\n-                        c.write(\"}\\n\");\n-\n-                    }\n+        for (JField f : mFields) {\n+            if (f.getType() instanceof JVector) {\n+                JVector jv = (JVector) f.getType();\n+                JType jvType = jv.getElementType();\n+                String struct_name = JVector.extractVectorName(jvType);\n+                if (vectorStructs.get(struct_name) == null) {\n+                    vectorStructs.put(struct_name, struct_name);\n+                    h.write(\"struct \" + struct_name + \" {\\n    int32_t count;\\n\" + jv.getElementType().genCDecl(\"*data\") + \"\\n};\\n\");\n+                    h.write(\"int serialize_\" + struct_name + \"(struct oarchive *out, const char *tag, struct \" + struct_name + \" *v);\\n\");\n+                    h.write(\"int deserialize_\" + struct_name + \"(struct iarchive *in, const char *tag, struct \" + struct_name + \" *v);\\n\");\n+                    h.write(\"int allocate_\" + struct_name + \"(struct \" + struct_name + \" *v, int32_t len);\\n\");\n+                    h.write(\"int deallocate_\" + struct_name + \"(struct \" + struct_name + \" *v);\\n\");\n+                    c.write(\"int allocate_\" + struct_name + \"(struct \" + struct_name + \" *v, int32_t len) {\\n\");\n+                    c.write(\"    if (!len) {\\n\");\n+                    c.write(\"        v->count = 0;\\n\");\n+                    c.write(\"        v->data = 0;\\n\");\n+                    c.write(\"    } else {\\n\");\n+                    c.write(\"        v->count = len;\\n\");\n+                    c.write(\"        v->data = calloc(sizeof(*v->data), len);\\n\");\n+                    c.write(\"    }\\n\");\n+                    c.write(\"    return 0;\\n\");\n+                    c.write(\"}\\n\");\n+                    c.write(\"int deallocate_\" + struct_name + \"(struct \" + struct_name + \" *v) {\\n\");\n+                    c.write(\"    if (v->data) {\\n\");\n+                    c.write(\"        int32_t i;\\n\");\n+                    c.write(\"        for(i=0;i<v->count; i++) {\\n\");\n+                    c.write(\"            deallocate_\" + JRecord.extractMethodSuffix(jvType) + \"(&v->data[i]);\\n\");\n+                    c.write(\"        }\\n\");\n+                    c.write(\"        free(v->data);\\n\");\n+                    c.write(\"        v->data = 0;\\n\");\n+                    c.write(\"    }\\n\");\n+                    c.write(\"    return 0;\\n\");\n+                    c.write(\"}\\n\");\n+                    c.write(\"int serialize_\" + struct_name + \"(struct oarchive *out, const char *tag, struct \" + struct_name + \" *v)\\n\");\n+                    c.write(\"{\\n\");\n+                    c.write(\"    int32_t count = v->count;\\n\");\n+                    c.write(\"    int rc = 0;\\n\");\n+                    c.write(\"    int32_t i;\\n\");\n+                    c.write(\"    rc = out->start_vector(out, tag, &count);\\n\");\n+                    c.write(\"    for(i=0;i<v->count;i++) {\\n\");\n+                    genSerialize(c, jvType, \"data\", \"data[i]\");\n+                    c.write(\"    }\\n\");\n+                    c.write(\"    rc = rc ? rc : out->end_vector(out, tag);\\n\");\n+                    c.write(\"    return rc;\\n\");\n+                    c.write(\"}\\n\");\n+                    c.write(\"int deserialize_\" + struct_name + \"(struct iarchive *in, const char *tag, struct \" + struct_name + \" *v)\\n\");\n+                    c.write(\"{\\n\");\n+                    c.write(\"    int rc = 0;\\n\");\n+                    c.write(\"    int32_t i;\\n\");\n+                    c.write(\"    rc = in->start_vector(in, tag, &v->count);\\n\");\n+                    c.write(\"    v->data = calloc(v->count, sizeof(*v->data));\\n\");\n+                    c.write(\"    for(i=0;i<v->count;i++) {\\n\");\n+                    genDeserialize(c, jvType, \"value\", \"data[i]\");\n+                    c.write(\"    }\\n\");\n+                    c.write(\"    rc = in->end_vector(in, tag);\\n\");\n+                    c.write(\"    return rc;\\n\");\n+                    c.write(\"}\\n\");\n+\n                 }\n             }\n-            String rec_name = getName();\n-            h.write(\"struct \" + rec_name + \" {\\n\");\n-            for (JField f : mFields) {\n-                h.write(f.genCDecl());\n-            }\n-            h.write(\"};\\n\");\n-            h.write(\"int serialize_\" + rec_name + \"(struct oarchive *out, const char *tag, struct \" + rec_name + \" *v);\\n\");\n-            h.write(\"int deserialize_\" + rec_name + \"(struct iarchive *in, const char *tag, struct \" + rec_name + \"*v);\\n\");\n-            h.write(\"void deallocate_\" + rec_name + \"(struct \" + rec_name + \"*);\\n\");\n-            c.write(\"int serialize_\" + rec_name + \"(struct oarchive *out, const char *tag, struct \" + rec_name + \" *v)\");\n-            c.write(\"{\\n\");\n-            c.write(\"    int rc;\\n\");\n-            c.write(\"    rc = out->start_record(out, tag);\\n\");\n-            for (JField f : mFields) {\n-                genSerialize(c, f.getType(), f.getTag(), f.getName());\n-            }\n-            c.write(\"    rc = rc ? rc : out->end_record(out, tag);\\n\");\n-            c.write(\"    return rc;\\n\");\n-            c.write(\"}\\n\");\n-            c.write(\"int deserialize_\" + rec_name + \"(struct iarchive *in, const char *tag, struct \" + rec_name + \"*v)\");\n-            c.write(\"{\\n\");\n-            c.write(\"    int rc;\\n\");\n-            c.write(\"    rc = in->start_record(in, tag);\\n\");\n-            for (JField f : mFields) {\n-                genDeserialize(c, f.getType(), f.getTag(), f.getName());\n-            }\n-            c.write(\"    rc = rc ? rc : in->end_record(in, tag);\\n\");\n-            c.write(\"    return rc;\\n\");\n-            c.write(\"}\\n\");\n-            c.write(\"void deallocate_\" + rec_name + \"(struct \" + rec_name + \"*v)\");\n-            c.write(\"{\\n\");\n-            for (JField f : mFields) {\n-                if (f.getType() instanceof JRecord) {\n-                    c.write(\"    deallocate_\" + extractStructName(f.getType()) + \"(&v->\" + f.getName() + \");\\n\");\n-                } else if (f.getType() instanceof JVector) {\n-                    JVector vt = (JVector) f.getType();\n-                    c.write(\"    deallocate_\" + JVector.extractVectorName(vt.getElementType()) + \"(&v->\" + f.getName() + \");\\n\");\n-                } else if (f.getType() instanceof JCompType) {\n-                    c.write(\"    deallocate_\" + extractMethodSuffix(f.getType()) + \"(&v->\" + f.getName() + \");\\n\");\n-                }\n+        }\n+        String rec_name = getName();\n+        h.write(\"struct \" + rec_name + \" {\\n\");\n+        for (JField f : mFields) {\n+            h.write(f.genCDecl());\n+        }\n+        h.write(\"};\\n\");\n+        h.write(\"int serialize_\" + rec_name + \"(struct oarchive *out, const char *tag, struct \" + rec_name + \" *v);\\n\");\n+        h.write(\"int deserialize_\" + rec_name + \"(struct iarchive *in, const char *tag, struct \" + rec_name + \"*v);\\n\");\n+        h.write(\"void deallocate_\" + rec_name + \"(struct \" + rec_name + \"*);\\n\");\n+        c.write(\"int serialize_\" + rec_name + \"(struct oarchive *out, const char *tag, struct \" + rec_name + \" *v)\");\n+        c.write(\"{\\n\");\n+        c.write(\"    int rc;\\n\");\n+        c.write(\"    rc = out->start_record(out, tag);\\n\");\n+        for (JField f : mFields) {\n+            genSerialize(c, f.getType(), f.getTag(), f.getName());\n+        }\n+        c.write(\"    rc = rc ? rc : out->end_record(out, tag);\\n\");\n+        c.write(\"    return rc;\\n\");\n+        c.write(\"}\\n\");\n+        c.write(\"int deserialize_\" + rec_name + \"(struct iarchive *in, const char *tag, struct \" + rec_name + \"*v)\");\n+        c.write(\"{\\n\");\n+        c.write(\"    int rc;\\n\");\n+        c.write(\"    rc = in->start_record(in, tag);\\n\");\n+        for (JField f : mFields) {\n+            genDeserialize(c, f.getType(), f.getTag(), f.getName());\n+        }\n+        c.write(\"    rc = rc ? rc : in->end_record(in, tag);\\n\");\n+        c.write(\"    return rc;\\n\");\n+        c.write(\"}\\n\");\n+        c.write(\"void deallocate_\" + rec_name + \"(struct \" + rec_name + \"*v)\");\n+        c.write(\"{\\n\");\n+        for (JField f : mFields) {\n+            if (f.getType() instanceof JRecord) {\n+                c.write(\"    deallocate_\" + extractStructName(f.getType()) + \"(&v->\" + f.getName() + \");\\n\");\n+            } else if (f.getType() instanceof JVector) {\n+                JVector vt = (JVector) f.getType();\n+                c.write(\"    deallocate_\" + JVector.extractVectorName(vt.getElementType()) + \"(&v->\" + f.getName() + \");\\n\");\n+            } else if (f.getType() instanceof JCompType) {\n+                c.write(\"    deallocate_\" + extractMethodSuffix(f.getType()) + \"(&v->\" + f.getName() + \");\\n\");\n             }\n-            c.write(\"}\\n\");\n-        } catch (IOException e) {\n-            throw e;\n-        } finally {\n-            h.close();\n-            c.close();\n         }\n+        c.write(\"}\\n\");\n     }\n \n     private void genSerialize(FileWriter c, JType type, String tag, String name) throws IOException {",
      "parent_sha": "b9beabf5cfbb8e447f67a8050486ca2821132f61"
    }
  },
  {
    "oid": "bbc3fdc9973cf02256539a794b617c9b0da5b81f",
    "message": "Don't insist on parameters for standalone mode that are not used by standalone mode.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/zookeeper/trunk@670796 13f79535-47bb-0310-9956-ffa450edef68",
    "date": "2007-11-06T17:15:39Z",
    "url": "https://github.com/apache/zookeeper/commit/bbc3fdc9973cf02256539a794b617c9b0da5b81f",
    "details": {
      "sha": "cf242b5330e1ec37938c99da902f9a793112a3d5",
      "filename": "zookeeper/java/src/com/yahoo/zookeeper/server/quorum/QuorumPeer.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/apache/zookeeper/blob/bbc3fdc9973cf02256539a794b617c9b0da5b81f/zookeeper%2Fjava%2Fsrc%2Fcom%2Fyahoo%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeer.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/bbc3fdc9973cf02256539a794b617c9b0da5b81f/zookeeper%2Fjava%2Fsrc%2Fcom%2Fyahoo%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeer.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper%2Fjava%2Fsrc%2Fcom%2Fyahoo%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeer.java?ref=bbc3fdc9973cf02256539a794b617c9b0da5b81f",
      "patch": "@@ -474,11 +474,11 @@ public static void main(String args[]) {\n                 ZooLog.logError(\"tickTime is not set\");\n                 System.exit(2);\n             }\n-            if (initLimit == 0) {\n+            if (servers.size() > 1 && initLimit == 0) {\n                 ZooLog.logError(\"initLimit is not set\");\n                 System.exit(2);\n             }\n-            if (syncLimit == 0) {\n+            if (servers.size() > 1 && syncLimit == 0) {\n                 ZooLog.logError(\"syncLimit is not set\");\n                 System.exit(2);\n             }\n@@ -517,4 +517,4 @@ public static void main(String args[]) {\n         }\n         System.exit(2);\n     }\n-}\n\\ No newline at end of file\n+}",
      "parent_sha": "e048893ec04a250fcb50853d6b47594fa81b0ea2"
    }
  },
  {
    "oid": "dacd27568c0a20244d40f42ff8ee84b5f917128e",
    "message": "ZOOKEEPER-3041: Typo in error message, affects log analysis; charater --> character\n\nAuthor: Hugh O'Brien <hugh.obrien@jet.com>\n\nReviewers: phunt@apache.org\n\nCloses #498 from hughobrienjet/master\n\nChange-Id: I3f4145c5c3eb4052cd7f0859053bb3711dfdd64c",
    "date": "2018-05-16T17:30:31Z",
    "url": "https://github.com/apache/zookeeper/commit/dacd27568c0a20244d40f42ff8ee84b5f917128e",
    "details": {
      "sha": "d80feabae0875035b8303508f69a894cc66faba5",
      "filename": "src/java/main/org/apache/zookeeper/common/PathUtils.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/dacd27568c0a20244d40f42ff8ee84b5f917128e/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fcommon%2FPathUtils.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/dacd27568c0a20244d40f42ff8ee84b5f917128e/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fcommon%2FPathUtils.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fcommon%2FPathUtils.java?ref=dacd27568c0a20244d40f42ff8ee84b5f917128e",
      "patch": "@@ -90,7 +90,7 @@ public static void validatePath(String path) throws IllegalArgumentException {\n                     || c >= '\\u007f' && c <= '\\u009F'\n                     || c >= '\\ud800' && c <= '\\uf8ff'\n                     || c >= '\\ufff0' && c <= '\\uffff') {\n-                reason = \"invalid charater @\" + i;\n+                reason = \"invalid character @\" + i;\n                 break;\n             }\n         }",
      "parent_sha": "2fa315b7d0ed65828479fcdcc9e76ca8552fba4a"
    }
  },
  {
    "oid": "c0b19e0c5c2bbf1fb24e154466b6cc0fa6b5e74a",
    "message": "ZOOKEEPER-4380: Avoid NPE in RateLogger#rateLimitLog\n\nAuthor: ruanwenjun <wenjun@apache.org>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>, Damien Diederen <ddiederen@apache.org>\n\nCloses #1758 from ruanwenjun/dev_wenjun_patch-fixNPEInRateLogger",
    "date": "2021-09-22T15:22:12Z",
    "url": "https://github.com/apache/zookeeper/commit/c0b19e0c5c2bbf1fb24e154466b6cc0fa6b5e74a",
    "details": {
      "sha": "21e41b4fbbac3871da3ff49914ddefc937942278",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/RateLogger.java",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/apache/zookeeper/blob/c0b19e0c5c2bbf1fb24e154466b6cc0fa6b5e74a/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FRateLogger.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/c0b19e0c5c2bbf1fb24e154466b6cc0fa6b5e74a/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FRateLogger.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FRateLogger.java?ref=c0b19e0c5c2bbf1fb24e154466b6cc0fa6b5e74a",
      "patch": "@@ -18,6 +18,7 @@\n \n package org.apache.zookeeper.server;\n \n+import java.util.Objects;\n import org.apache.zookeeper.common.Time;\n import org.slf4j.Logger;\n \n@@ -67,21 +68,21 @@ public void rateLimitLog(String newMsg) {\n     /**\n      * In addition to the message, it also takes a value.\n      */\n-    public void rateLimitLog(String newMsg, String value) {\n+    public void rateLimitLog(String newMsg, String newValue) {\n         long now = Time.currentElapsedTime();\n-        if (newMsg.equals(msg)) {\n+        if (Objects.equals(newMsg, msg)) {\n             ++count;\n-            this.value = value;\n+            value = newValue;\n             if (now - timestamp >= LOG_INTERVAL) {\n                 flush();\n                 msg = newMsg;\n                 timestamp = now;\n-                this.value = value;\n+                value = newValue;\n             }\n         } else {\n             flush();\n             msg = newMsg;\n-            this.value = value;\n+            value = newValue;\n             timestamp = now;\n             LOG.warn(\"Message:{} Value:{}\", msg, value);\n         }",
      "parent_sha": "26001aacfeff519ccd6b0991b0cc38ab10ad6564"
    }
  },
  {
    "oid": "63f744b2f4aef1806adfd22823984c561156e243",
    "message": "ZOOKEEPER-3863: correct junit test timeout\n\nLiYvbo eolivelli\n\nAuthor: tison <wander4096@gmail.com>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>\n\nCloses #1459 from TisonKun/patch-2",
    "date": "2020-09-17T11:42:25Z",
    "url": "https://github.com/apache/zookeeper/commit/63f744b2f4aef1806adfd22823984c561156e243",
    "details": {
      "sha": "43bfb2ded38243d52e56fcc46dde2746cb38d495",
      "filename": "zookeeper-server/src/test/java/org/apache/zookeeper/test/ReadOnlyModeTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/apache/zookeeper/blob/63f744b2f4aef1806adfd22823984c561156e243/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Ftest%2FReadOnlyModeTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/63f744b2f4aef1806adfd22823984c561156e243/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Ftest%2FReadOnlyModeTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Ftest%2FReadOnlyModeTest.java?ref=63f744b2f4aef1806adfd22823984c561156e243",
      "patch": "@@ -245,7 +245,8 @@ public void testSessionEstablishment() throws Exception {\n         zk.close();\n     }\n \n-    @Test(timeout = 90000)\n+    @Test\n+    @Timeout(value = 90)\n     public void testGlobalSessionInRO() throws Exception {\n         qu.startQuorum();\n ",
      "parent_sha": "c47ef905e077184bc5b7f555a3e2dfeb6dc046e1"
    }
  },
  {
    "oid": "d8ff555339b054fbcf6ea6767357e8bf8c7af2c5",
    "message": "ZOOKEEPER-4200: Widen latency window in WatcherCleanerTest\n\n`WatcherCleanerTest` performs latency checks which fail when outside of a 20+Xms window.  Before this patch, X was 5ms\u2014whereas 30+ms is frequently seen on an i5 Mac Mini running macOS Catalina.\n\nThis \"dumb\" patch just widens the window to 20ms, which makes it \"work on my machine,\" but could obviously still fail in a loaded environment or VM.\n\nAuthor: Damien Diederen <dd@crosstwine.com>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>, Mate Szalay-Beko <symat@apache.org>\n\nCloses #1592 from ztzg/ZOOKEEPER-4200-widen-latency-window",
    "date": "2021-02-17T19:18:55Z",
    "url": "https://github.com/apache/zookeeper/commit/d8ff555339b054fbcf6ea6767357e8bf8c7af2c5",
    "details": {
      "sha": "9ed145aa38d4ca8ae02e9196dfbd341c8699c5ab",
      "filename": "zookeeper-server/src/test/java/org/apache/zookeeper/server/watch/WatcherCleanerTest.java",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/apache/zookeeper/blob/d8ff555339b054fbcf6ea6767357e8bf8c7af2c5/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fwatch%2FWatcherCleanerTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/d8ff555339b054fbcf6ea6767357e8bf8c7af2c5/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fwatch%2FWatcherCleanerTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fwatch%2FWatcherCleanerTest.java?ref=d8ff555339b054fbcf6ea6767357e8bf8c7af2c5",
      "patch": "@@ -162,13 +162,13 @@ public void testDeadWatcherMetrics() {\n \n         assertEquals(3L, values.get(\"cnt_dead_watchers_cleaner_latency\"));\n \n-        //Each latency should be a little over 20 ms, allow 5 ms deviation\n-        assertEquals(20D, (Double) values.get(\"avg_dead_watchers_cleaner_latency\"), 5);\n-        assertEquals(20D, ((Long) values.get(\"min_dead_watchers_cleaner_latency\")).doubleValue(), 5);\n-        assertEquals(20D, ((Long) values.get(\"max_dead_watchers_cleaner_latency\")).doubleValue(), 5);\n-        assertEquals(20D, ((Long) values.get(\"p50_dead_watchers_cleaner_latency\")).doubleValue(), 5);\n-        assertEquals(20D, ((Long) values.get(\"p95_dead_watchers_cleaner_latency\")).doubleValue(), 5);\n-        assertEquals(20D, ((Long) values.get(\"p99_dead_watchers_cleaner_latency\")).doubleValue(), 5);\n+        //Each latency should be a little over 20 ms, allow 20 ms deviation\n+        assertEquals(20D, (Double) values.get(\"avg_dead_watchers_cleaner_latency\"), 20);\n+        assertEquals(20D, ((Long) values.get(\"min_dead_watchers_cleaner_latency\")).doubleValue(), 20);\n+        assertEquals(20D, ((Long) values.get(\"max_dead_watchers_cleaner_latency\")).doubleValue(), 20);\n+        assertEquals(20D, ((Long) values.get(\"p50_dead_watchers_cleaner_latency\")).doubleValue(), 20);\n+        assertEquals(20D, ((Long) values.get(\"p95_dead_watchers_cleaner_latency\")).doubleValue(), 20);\n+        assertEquals(20D, ((Long) values.get(\"p99_dead_watchers_cleaner_latency\")).doubleValue(), 20);\n     }\n \n }",
      "parent_sha": "884fc38db166617e03d03f793ef917febcc131be"
    }
  },
  {
    "oid": "41eaa5741eb749f8a32a17c33c2828f422a551d3",
    "message": "fixed applying ZOOKEEPER-42 patch file\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/zookeeper/trunk@681503 13f79535-47bb-0310-9956-ffa450edef68",
    "date": "2008-07-31T21:22:33Z",
    "url": "https://github.com/apache/zookeeper/commit/41eaa5741eb749f8a32a17c33c2828f422a551d3",
    "details": {
      "sha": "e4dcc9b9e268821f376720734094191fe09a0e63",
      "filename": "src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/apache/zookeeper/blob/41eaa5741eb749f8a32a17c33c2828f422a551d3/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerConfig.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/41eaa5741eb749f8a32a17c33c2828f422a551d3/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerConfig.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerConfig.java?ref=41eaa5741eb749f8a32a17c33c2828f422a551d3",
      "patch": "@@ -70,8 +70,8 @@ public static void parse(String[] args) {\n             int tickTime = 0;\n             int initLimit = 0;\n             int syncLimit = 0;\n-            int electionAlg = 0;\n-            int electionPort = 0;\n+            int electionAlg = 3;\n+            int electionPort = 2182;\n             for (Entry<Object, Object> entry : cfg.entrySet()) {\n                 String key = entry.getKey().toString();\n                 String value = entry.getValue().toString();",
      "parent_sha": "3740b7c730e6e4ccccd78c35694689292bca4ddb"
    }
  },
  {
    "oid": "ea75e1f63572fc72fb8520ba8c793523047acb49",
    "message": "ZOOKEEPER-4247: NPE while processing message from restarted quorum member\n\nWhen a ZooKeeper server realizes that an other quorum peer was shut down (e.g. during a rolling upgrade or\nrolling restart), the ServerCnxn.zkServer variable is set to null by QuorumPear.close(). This is why in the code\nwe usually check the zkServer variable before using it. But this check was missing in one place thus causing\nNPE in NettyServerCnx.receiveMessage:\n\n```\n2021-02-08T12:42:08.229+0000 [myid:] - ERROR\n[nioEventLoopGroup-4-1:NettyServerCnxnFactory$CnxnChannelHandler329]- Unexpected exception in receive\n java.lang.NullPointerException: null ~[zookeeper-3.6.2.jar:3.6.2]\n at org.apache.zookeeper.server.NettyServerCnxn.receiveMessage(NettyServerCnxn.java:518)\n at org.apache.zookeeper.server.NettyServerCnxn.processMessage(NettyServerCnxn.java:368)\n at org.apache.zookeeper.server.NettyServerCnxnFactory\n        $CnxnChannelHandler.channelRead(NettyServerCnxnFactory.java:326)\n...\n```\n\nIn this commit we add the necessary check and (after throwing an IOException) we will basically ignore the\nprocessing of the received message when the remote ZooKeeper server is already down.\n\nAuthor: Mate Szalay-Beko <symat@apache.org>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>, Mohammad Arshad <arshad@apache.org>\n\nCloses #1681 from symat/ZOOKEEPER-4247 and squashes the following commits:\n\n7b140177d [Mate Szalay-Beko] ZOOKEEPER-4247: address PR comments\nb99ee986b [Mate Szalay-Beko] ZOOKEEPER-4247: address PR comments\n3c8478a40 [Mate Szalay-Beko] ZOOKEEPER-4247: fix NPE happens while processing messages during quorum member restart",
    "date": "2021-04-14T16:52:09Z",
    "url": "https://github.com/apache/zookeeper/commit/ea75e1f63572fc72fb8520ba8c793523047acb49",
    "details": {
      "sha": "269fcd942cc7bf7fcc3c3980ba9d776b0226af9c",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/NettyServerCnxn.java",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/apache/zookeeper/blob/ea75e1f63572fc72fb8520ba8c793523047acb49/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNettyServerCnxn.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/ea75e1f63572fc72fb8520ba8c793523047acb49/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNettyServerCnxn.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNettyServerCnxn.java?ref=ea75e1f63572fc72fb8520ba8c793523047acb49",
      "patch": "@@ -520,8 +520,12 @@ private void receiveMessage(ByteBuf message) {\n                         if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n                             throw new IOException(\"Len error \" + len);\n                         }\n+                        ZooKeeperServer zks = this.zkServer;\n+                        if (zks == null || !zks.isRunning()) {\n+                            throw new IOException(\"ZK down\");\n+                        }\n                         // checkRequestSize will throw IOException if request is rejected\n-                        zkServer.checkRequestSizeWhenReceivingMessage(len);\n+                        zks.checkRequestSizeWhenReceivingMessage(len);\n                         bb = ByteBuffer.allocate(len);\n                     }\n                 }",
      "parent_sha": "7fdadf7273f34dd0552db25a3771cf55b65e9208"
    }
  },
  {
    "oid": "16187c48a1d9b339866b81e69c522021b031c4c3",
    "message": "ZOOKEEPER-4319: Refactored AtomicFileWritingIdiomTest to use TempDir annotation\n\nThis is a test refactoring. No original assertion was changed nor the original code presented any failing steps.\n\n**Problem:**\nTests that manipulate external file resources need to guarantee resource integrity and availability. Test suite design and maintainability may suffer from the addition of assurance steps to guarantee parallel execution scenarios and resource leakage from failed previous executions.\n\n**Solution:**\nThe use of tempdir annotation assures a temporary directory being created and cleaned up for every test method execution, thus simplifying test maintenance steps.\n\nAuthor: Elvys Soares <eas5@cin.ufpe.br>\n\nReviewers: maoling <maoling@apache.org>\n\nCloses #1702 from eas5/test_improvement",
    "date": "2021-06-27T07:44:14Z",
    "url": "https://github.com/apache/zookeeper/commit/16187c48a1d9b339866b81e69c522021b031c4c3",
    "details": {
      "sha": "3126f005111f02fbe6cb58aeb58b0ec0353cedb5",
      "filename": "zookeeper-server/src/test/java/org/apache/zookeeper/common/AtomicFileWritingIdiomTest.java",
      "status": "modified",
      "additions": 13,
      "deletions": 31,
      "changes": 44,
      "blob_url": "https://github.com/apache/zookeeper/blob/16187c48a1d9b339866b81e69c522021b031c4c3/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fcommon%2FAtomicFileWritingIdiomTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/16187c48a1d9b339866b81e69c522021b031c4c3/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fcommon%2FAtomicFileWritingIdiomTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fcommon%2FAtomicFileWritingIdiomTest.java?ref=16187c48a1d9b339866b81e69c522021b031c4c3",
      "patch": "@@ -32,21 +32,13 @@\n import org.apache.zookeeper.ZKTestCase;\n import org.apache.zookeeper.common.AtomicFileWritingIdiom.OutputStreamStatement;\n import org.apache.zookeeper.common.AtomicFileWritingIdiom.WriterStatement;\n-import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n \n public class AtomicFileWritingIdiomTest extends ZKTestCase {\n \n-    private static File tmpdir;\n-\n-    @BeforeAll\n-    public static void createTmpDir() {\n-        tmpdir = new File(\"build/test/tmp\");\n-        tmpdir.mkdirs();\n-    }\n-\n     @Test\n-    public void testOutputStreamSuccess() throws IOException {\n+    public void testOutputStreamSuccess(@TempDir File tmpdir) throws IOException {\n         File target = new File(tmpdir, \"target.txt\");\n         final File tmp = new File(tmpdir, \"target.txt.tmp\");\n         createFile(target, \"before\");\n@@ -61,11 +53,10 @@ public void write(OutputStream os) throws IOException {\n         assertFalse(tmp.exists(), \"tmp file should have been deleted\");\n         // content changed\n         assertEquals(\"after\", getContent(target));\n-        target.delete();\n     }\n \n     @Test\n-    public void testWriterSuccess() throws IOException {\n+    public void testWriterSuccess(@TempDir File tmpdir) throws IOException {\n         File target = new File(tmpdir, \"target.txt\");\n         final File tmp = new File(tmpdir, \"target.txt.tmp\");\n         createFile(target, \"before\");\n@@ -80,11 +71,10 @@ public void write(Writer os) throws IOException {\n         assertFalse(tmp.exists(), \"tmp file should have been deleted\");\n         // content changed\n         assertEquals(\"after\", getContent(target));\n-        target.delete();\n     }\n \n     @Test\n-    public void testOutputStreamFailure() throws IOException {\n+    public void testOutputStreamFailure(@TempDir File tmpdir) throws IOException {\n         File target = new File(tmpdir, \"target.txt\");\n         final File tmp = new File(tmpdir, \"target.txt.tmp\");\n         createFile(target, \"before\");\n@@ -107,11 +97,10 @@ public void write(OutputStream os) throws IOException {\n         assertTrue(exception, \"should have raised an exception\");\n         // content preserved\n         assertEquals(\"before\", getContent(target));\n-        target.delete();\n     }\n \n     @Test\n-    public void testWriterFailure() throws IOException {\n+    public void testWriterFailure(@TempDir File tmpdir) throws IOException {\n         File target = new File(tmpdir, \"target.txt\");\n         final File tmp = new File(tmpdir, \"target.txt.tmp\");\n         createFile(target, \"before\");\n@@ -134,11 +123,10 @@ public void write(Writer os) throws IOException {\n         assertTrue(exception, \"should have raised an exception\");\n         // content preserved\n         assertEquals(\"before\", getContent(target));\n-        target.delete();\n     }\n \n     @Test\n-    public void testOutputStreamFailureIOException() throws IOException {\n+    public void testOutputStreamFailureIOException(@TempDir File tmpdir) throws IOException {\n         File target = new File(tmpdir, \"target.txt\");\n         final File tmp = new File(tmpdir, \"target.txt.tmp\");\n         createFile(target, \"before\");\n@@ -161,11 +149,10 @@ public void write(OutputStream os) throws IOException {\n         assertTrue(exception, \"should have raised an exception\");\n         // content preserved\n         assertEquals(\"before\", getContent(target));\n-        target.delete();\n     }\n \n     @Test\n-    public void testWriterFailureIOException() throws IOException {\n+    public void testWriterFailureIOException(@TempDir File tmpdir) throws IOException {\n         File target = new File(tmpdir, \"target.txt\");\n         final File tmp = new File(tmpdir, \"target.txt.tmp\");\n         createFile(target, \"before\");\n@@ -188,11 +175,10 @@ public void write(Writer os) throws IOException {\n         assertTrue(exception, \"should have raised an exception\");\n         // content preserved\n         assertEquals(\"before\", getContent(target));\n-        target.delete();\n     }\n \n     @Test\n-    public void testOutputStreamFailureError() throws IOException {\n+    public void testOutputStreamFailureError(@TempDir File tmpdir) throws IOException {\n         File target = new File(tmpdir, \"target.txt\");\n         final File tmp = new File(tmpdir, \"target.txt.tmp\");\n         createFile(target, \"before\");\n@@ -215,11 +201,10 @@ public void write(OutputStream os) throws IOException {\n         assertTrue(exception, \"should have raised an exception\");\n         // content preserved\n         assertEquals(\"before\", getContent(target));\n-        target.delete();\n     }\n \n     @Test\n-    public void testWriterFailureError() throws IOException {\n+    public void testWriterFailureError(@TempDir File tmpdir) throws IOException {\n         File target = new File(tmpdir, \"target.txt\");\n         final File tmp = new File(tmpdir, \"target.txt.tmp\");\n         createFile(target, \"before\");\n@@ -242,13 +227,12 @@ public void write(Writer os) throws IOException {\n         assertTrue(exception, \"should have raised an exception\");\n         // content preserved\n         assertEquals(\"before\", getContent(target));\n-        target.delete();\n     }\n \n     // ************** target file does not exist\n \n     @Test\n-    public void testOutputStreamSuccessNE() throws IOException {\n+    public void testOutputStreamSuccessNE(@TempDir File tmpdir) throws IOException {\n         File target = new File(tmpdir, \"target.txt\");\n         final File tmp = new File(tmpdir, \"target.txt.tmp\");\n         target.delete();\n@@ -262,11 +246,10 @@ public void write(OutputStream os) throws IOException {\n         });\n         // content changed\n         assertEquals(\"after\", getContent(target));\n-        target.delete();\n     }\n \n     @Test\n-    public void testWriterSuccessNE() throws IOException {\n+    public void testWriterSuccessNE(@TempDir File tmpdir) throws IOException {\n         File target = new File(tmpdir, \"target.txt\");\n         final File tmp = new File(tmpdir, \"target.txt.tmp\");\n         target.delete();\n@@ -281,11 +264,10 @@ public void write(Writer os) throws IOException {\n         assertFalse(tmp.exists(), \"tmp file should have been deleted\");\n         // content changed\n         assertEquals(\"after\", getContent(target));\n-        target.delete();\n     }\n \n     @Test\n-    public void testOutputStreamFailureNE() throws IOException {\n+    public void testOutputStreamFailureNE(@TempDir File tmpdir) throws IOException {\n         File target = new File(tmpdir, \"target.txt\");\n         final File tmp = new File(tmpdir, \"target.txt.tmp\");\n         target.delete();\n@@ -311,7 +293,7 @@ public void write(OutputStream os) throws IOException {\n     }\n \n     @Test\n-    public void testWriterFailureNE() throws IOException {\n+    public void testWriterFailureNE(@TempDir File tmpdir) throws IOException {\n         File target = new File(tmpdir, \"target.txt\");\n         final File tmp = new File(tmpdir, \"target.txt.tmp\");\n         target.delete();",
      "parent_sha": "9442ce23bade5286459ff78ade1af173f7b69c30"
    }
  },
  {
    "oid": "25035f10ec188a2f3d5c29dbda4b84391eee267d",
    "message": "ZOOKEEPER-3046: increased test timeout\n\n- bump up timeout to avoid too many build failures\n\nAuthor: Bogdan Kanivets <bkanivets@gmail.com>\n\nReviewers: phunt@apache.org\n\nCloses #576 from lavacat/test-timeouts-3.5\n\nChange-Id: If0b4b45c33e1909120ad15454f1c2f3f242237b6\n(cherry picked from commit b78e83b1d7101b9fe76dd0b1ed8e7af37f8a587e)\nSigned-off-by: Patrick Hunt <phunt@apache.org>",
    "date": "2018-07-19T16:58:49Z",
    "url": "https://github.com/apache/zookeeper/commit/25035f10ec188a2f3d5c29dbda4b84391eee267d",
    "details": {
      "sha": "aa65e219f6b61b56f8040b57dbb755bbe407c4ba",
      "filename": "src/java/test/org/apache/zookeeper/test/DisconnectedWatcherTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/25035f10ec188a2f3d5c29dbda4b84391eee267d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Ftest%2FDisconnectedWatcherTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/25035f10ec188a2f3d5c29dbda4b84391eee267d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Ftest%2FDisconnectedWatcherTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Ftest%2FDisconnectedWatcherTest.java?ref=25035f10ec188a2f3d5c29dbda4b84391eee267d",
      "patch": "@@ -178,7 +178,7 @@ public void testDeepChildWatcherAutoResetWithChroot() throws Exception {\n \n     // @see jira issue ZOOKEEPER-706. Test auto reset of a large number of\n     // watches which require multiple SetWatches calls.\n-    @Test(timeout = 600000)\n+    @Test(timeout = 840000)\n     public void testManyChildWatchersAutoReset() throws Exception {\n         ZooKeeper zk1 = createClient();\n ",
      "parent_sha": "f6bba09481dffc7db1d47be732d3cc8067603767"
    }
  },
  {
    "oid": "04471b2e117a0cbe08c42b0482f0adca93494e7c",
    "message": "ZOOKEEPER-4230: Use dynamic temp folder instead of static temp folder in RestMain\n\nAuthor: Mukti <muktikrishnan94@gmail.com>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>, Mohammad Arshad <arshad@apache.org>\n\nCloses #1633 from MuktiKrishnan/ZOOKEEPER-4230-master",
    "date": "2021-03-11T05:06:48Z",
    "url": "https://github.com/apache/zookeeper/commit/04471b2e117a0cbe08c42b0482f0adca93494e7c",
    "details": {
      "sha": "209207f6b14aebd5716238837312f7eb44aaede5",
      "filename": "zookeeper-contrib/zookeeper-contrib-rest/src/main/java/org/apache/zookeeper/server/jersey/RestMain.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/apache/zookeeper/blob/04471b2e117a0cbe08c42b0482f0adca93494e7c/zookeeper-contrib%2Fzookeeper-contrib-rest%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fjersey%2FRestMain.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/04471b2e117a0cbe08c42b0482f0adca93494e7c/zookeeper-contrib%2Fzookeeper-contrib-rest%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fjersey%2FRestMain.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-contrib%2Fzookeeper-contrib-rest%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fjersey%2FRestMain.java?ref=04471b2e117a0cbe08c42b0482f0adca93494e7c",
      "patch": "@@ -22,6 +22,7 @@\n import java.io.IOException;\n import java.net.URISyntaxException;\n import java.net.URL;\n+import java.nio.file.Files;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -53,7 +54,8 @@ public void start() throws IOException {\n        System.out.println(\"Starting grizzly ...\");\n \n        boolean useSSL = cfg.useSSL();\n-       gws = new GrizzlyWebServer(cfg.getPort(), \"/tmp/23cxv45345/2131xc2/\", useSSL);\n+       String zkRestResourcesTempPath = Files.createTempDirectory(\"zkRestResourcesTempPath\").toFile().getCanonicalPath();\n+       gws = new GrizzlyWebServer(cfg.getPort(), zkRestResourcesTempPath, useSSL);\n        // BUG: Grizzly needs a doc root if you are going to register multiple adapters\n \n        for (Endpoint e : cfg.getEndpoints()) {",
      "parent_sha": "f52918abd066d85a423d38917e58fc950d4e9d09"
    }
  },
  {
    "oid": "86438f9c6e65b2a95d709bf575cdcc2abc1c2e8b",
    "message": "ZOOKEEPER-2716: Flaky Test: org.apache.zookeeper.server.SessionTrackerTest.testAddSessionAfterSessionExpiry\n\nWe can't let the gate open until we increase the closed session count. Otherwise depends on timing, the test thread might see old session close count value between gate open and the session count actually gets increased.\n\nAuthor: Michael Han <hanm@apache.org>\n\nReviewers: Abraham Fine <afine@apache.org>, Rakesh Radhakrishnan <rakeshr@apache.org>\n\nCloses #187 from hanm/ZOOKEEPER-2716",
    "date": "2017-03-16T16:13:45Z",
    "url": "https://github.com/apache/zookeeper/commit/86438f9c6e65b2a95d709bf575cdcc2abc1c2e8b",
    "details": {
      "sha": "00e34faad543b6c9baeb42b775b2fe1738943754",
      "filename": "src/java/test/org/apache/zookeeper/server/SessionTrackerTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/86438f9c6e65b2a95d709bf575cdcc2abc1c2e8b/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2FSessionTrackerTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/86438f9c6e65b2a95d709bf575cdcc2abc1c2e8b/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2FSessionTrackerTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2FSessionTrackerTest.java?ref=86438f9c6e65b2a95d709bf575cdcc2abc1c2e8b",
      "patch": "@@ -143,8 +143,8 @@ public FirstProcessor(ZooKeeperServer zks,\n         public void processRequest(Request request) {\n             // check session close request\n             if (request.type == OpCode.closeSession) {\n-                latch.countDown();\n                 countOfCloseSessionReq++;\n+                latch.countDown();\n             }\n         }\n ",
      "parent_sha": "6949af062d5ad3cdb36c86afc3728ede78c8039d"
    }
  },
  {
    "oid": "05d4d437d808f6cdf4c9dc5419a6e8d635c2ba5d",
    "message": "ZOOKEEPER-2807: Fix flaky test org.apache.zookeeper.test.WatchEventWhenAutoResetTest.testNodeDataChanged\n\nMark the test as ignored.\nPlease see https://issues.apache.org/jira/browse/ZOOKEEPER-3182 for more details\n\nAuthor: Andor Molnar <andor@apache.org>\n\nReviewers: Fangmin Lyu <fangmin@apache.org>\n\nCloses #682 from anmolnar/ZOOKEEPER-2807",
    "date": "2018-11-05T07:45:40Z",
    "url": "https://github.com/apache/zookeeper/commit/05d4d437d808f6cdf4c9dc5419a6e8d635c2ba5d",
    "details": {
      "sha": "33e0f128c463ad63a0bddc1d805d26495bf06600",
      "filename": "zookeeper-server/src/test/java/org/apache/zookeeper/test/WatchEventWhenAutoResetTest.java",
      "status": "modified",
      "additions": 34,
      "deletions": 51,
      "changes": 85,
      "blob_url": "https://github.com/apache/zookeeper/blob/05d4d437d808f6cdf4c9dc5419a6e8d635c2ba5d/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Ftest%2FWatchEventWhenAutoResetTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/05d4d437d808f6cdf4c9dc5419a6e8d635c2ba5d/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Ftest%2FWatchEventWhenAutoResetTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Ftest%2FWatchEventWhenAutoResetTest.java?ref=05d4d437d808f6cdf4c9dc5419a6e8d635c2ba5d",
      "patch": "@@ -28,8 +28,10 @@\n import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.ZooKeeper;\n import org.apache.zookeeper.Watcher.Event.EventType;\n+import org.apache.zookeeper.data.Stat;\n import org.apache.zookeeper.test.ClientBase.CountdownWatcher;\n import org.apache.zookeeper.ZKTestCase;\n+import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n@@ -43,6 +45,9 @@ public class WatchEventWhenAutoResetTest extends ZKTestCase {\n \n     // waiting time for expected condition\n     private static final int TIMEOUT = 30000;\n+    private QuorumUtil qu;\n+    private EventsWatcher watcher;\n+    private ZooKeeper zk1, zk2;\n \n     static public class EventsWatcher extends CountdownWatcher {\n         private LinkedBlockingQueue<WatchedEvent> dataEvents = new LinkedBlockingQueue<WatchedEvent>();\n@@ -90,53 +95,51 @@ private ZooKeeper createClient(QuorumUtil qu, int id) throws IOException {\n     }\n \n     @Before\n-    public void setUp() {\n+    public void setUp() throws IOException {\n         System.setProperty(\"zookeeper.admin.enableServer\", \"false\");\n-    }\n \n-    @Test\n-    public void testNodeDataChanged() throws Exception {\n-        QuorumUtil qu = new QuorumUtil(1);\n+        qu = new QuorumUtil(1);\n         qu.startAll();\n \n-        EventsWatcher watcher = new EventsWatcher();\n-        ZooKeeper zk1 = createClient(qu, 1, watcher);\n-        ZooKeeper zk2 = createClient(qu, 2);\n+        watcher = new EventsWatcher();\n+        zk1 = createClient(qu, 1, watcher);\n+        zk2 = createClient(qu, 2);\n+    }\n \n-        String path = \"/test-changed\";\n+    @After\n+    public void tearDown() throws InterruptedException {\n+        if (zk1 != null) {\n+            zk1.close();\n+            zk1 = null;\n+        }\n+        if (zk2 != null) {\n+            zk2.close();\n+            zk2 = null;\n+        }\n+        if (watcher != null) {\n+            watcher = null;\n+        }\n+        if (qu != null) {\n+            qu.shutdownAll();\n+            qu = null;\n+        }\n+    }\n \n+    @Test\n+    public void testNodeDataChanged() throws Exception {\n+        String path = \"/test-changed\";\n         zk1.create(path, new byte[1], ZooDefs.Ids.OPEN_ACL_UNSAFE,\n                 CreateMode.PERSISTENT);\n-        zk1.getData(path, watcher, null);\n+        Stat stat1 = zk1.exists(path, watcher);\n         qu.shutdown(1);\n-        zk2.delete(path, -1);\n-        zk2.create(path, new byte[2], ZooDefs.Ids.OPEN_ACL_UNSAFE,\n-                CreateMode.PERSISTENT);\n+        zk2.setData(path, new byte[2], stat1.getVersion());\n         qu.start(1);\n         watcher.waitForConnected(TIMEOUT);\n         watcher.assertEvent(TIMEOUT, EventType.NodeDataChanged);\n-\n-        zk1.exists(path, watcher);\n-        qu.shutdown(1);\n-        zk2.delete(path, -1);\n-        zk2.create(path, new byte[2], ZooDefs.Ids.OPEN_ACL_UNSAFE,\n-                CreateMode.PERSISTENT);\n-        qu.start(1);\n-        watcher.waitForConnected(TIMEOUT * 1000L);\n-        watcher.assertEvent(TIMEOUT, EventType.NodeDataChanged);\n-\n-        qu.shutdownAll();\n     }\n \n     @Test\n     public void testNodeCreated() throws Exception {\n-        QuorumUtil qu = new QuorumUtil(1);\n-        qu.startAll();\n-\n-        EventsWatcher watcher = new EventsWatcher();\n-        ZooKeeper zk1 = createClient(qu, 1, watcher);\n-        ZooKeeper zk2 = createClient(qu, 2);\n-\n         String path = \"/test1-created\";\n \n         zk1.exists(path, watcher);\n@@ -146,19 +149,10 @@ public void testNodeCreated() throws Exception {\n         qu.start(1);\n         watcher.waitForConnected(TIMEOUT * 1000L);\n         watcher.assertEvent(TIMEOUT, EventType.NodeCreated);\n-\n-        qu.shutdownAll();\n     }\n \n     @Test\n     public void testNodeDeleted() throws Exception {\n-        QuorumUtil qu = new QuorumUtil(1);\n-        qu.startAll();\n-\n-        EventsWatcher watcher = new EventsWatcher();\n-        ZooKeeper zk1 = createClient(qu, 1, watcher);\n-        ZooKeeper zk2 = createClient(qu, 2);\n-\n         String path = \"/test-deleted\";\n \n         zk1.create(path, new byte[1], ZooDefs.Ids.OPEN_ACL_UNSAFE,\n@@ -187,19 +181,10 @@ public void testNodeDeleted() throws Exception {\n         qu.start(1);\n         watcher.waitForConnected(TIMEOUT * 1000L);\n         watcher.assertEvent(TIMEOUT, EventType.NodeDeleted);\n-\n-        qu.shutdownAll();\n     }\n \n     @Test\n     public void testNodeChildrenChanged() throws Exception {\n-        QuorumUtil qu = new QuorumUtil(1);\n-        qu.startAll();\n-\n-        EventsWatcher watcher = new EventsWatcher();\n-        ZooKeeper zk1 = createClient(qu, 1, watcher);\n-        ZooKeeper zk2 = createClient(qu, 2);\n-\n         String path = \"/test-children-changed\";\n \n         zk1.create(path, new byte[1], ZooDefs.Ids.OPEN_ACL_UNSAFE,\n@@ -211,8 +196,6 @@ public void testNodeChildrenChanged() throws Exception {\n         qu.start(1);\n         watcher.waitForConnected(TIMEOUT * 1000L);\n         watcher.assertEvent(TIMEOUT, EventType.NodeChildrenChanged);\n-\n-        qu.shutdownAll();\n     }\n }\n ",
      "parent_sha": "1ce2ca8107438d283581d18d064a25bd6b74adf7"
    }
  },
  {
    "oid": "efb2c56d3ab630ef571ee2abcab6f18e08c64c79",
    "message": "ZOOKEEPER-3548: Redundant zxid check in SnapStream.isValidSnapshot.\n\n`Util.getZxidFromName` is called twice in `SnapStream.isValidSnapshot`, and the second call is redundant: there is no way the check would return false when the second call of `Util.getZxidFromName` is executed as otherwise the code would already return false in the first call of `Util.getZxidFromName`.\n\nNo test as the logic is fairly obvious (and the logic is not well testable, in first place).\n\nAuthor: Michael Han <hanm@apache.org>\n\nReviewers: Norbert Kalmar <nkalmar@apache.org>\n\nCloses #1092 from hanm/wip",
    "date": "2019-09-26T12:16:50Z",
    "url": "https://github.com/apache/zookeeper/commit/efb2c56d3ab630ef571ee2abcab6f18e08c64c79",
    "details": {
      "sha": "9f28569436a73ed951573f29500ea43fcdfbe56e",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/persistence/SnapStream.java",
      "status": "modified",
      "additions": 1,
      "deletions": 6,
      "changes": 7,
      "blob_url": "https://github.com/apache/zookeeper/blob/efb2c56d3ab630ef571ee2abcab6f18e08c64c79/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fpersistence%2FSnapStream.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/efb2c56d3ab630ef571ee2abcab6f18e08c64c79/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fpersistence%2FSnapStream.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fpersistence%2FSnapStream.java?ref=efb2c56d3ab630ef571ee2abcab6f18e08c64c79",
      "patch": "@@ -181,13 +181,8 @@ public static boolean isValidSnapshot(File file) throws IOException {\n             return false;\n         }\n \n-        String fileName = file.getName();\n-        if (Util.getZxidFromName(fileName, \"snapshot\") == -1) {\n-            return false;\n-        }\n-\n         boolean isValid = false;\n-        switch (getStreamMode(fileName)) {\n+        switch (getStreamMode(file.getName())) {\n         case GZIP:\n             isValid = isValidGZipStream(file);\n             break;",
      "parent_sha": "4279758ead655aff34cdff21c9f2c71d66030d14"
    }
  },
  {
    "oid": "d1b07d588e445085eff4abeb42cf730cc7c57e83",
    "message": "ZOOKEEPER-1580: QuorumPeer.setRunning is not used\n\n- more details in [JIRA:ZOOKEEPER-1580](https://issues.apache.org/jira/browse/ZOOKEEPER-1580)\n- I forget fetching the upstream codes, make a mistake in the origin [PR-446] (https://github.com/apache/zookeeper/pull/446) which includes some review history,so I close it and open a new one\n\nAuthor: maoling <maoling199210191@sina.com>\n\nReviewers: Patrick Hunt <phunt@apache.org>, Andor Moln\u00e1r <andor@cloudera.com>, Abraham Fine <afine@apache.org>\n\nCloses #452 from maoling/ZOOKEEPER-1580 and squashes the following commits:\n\n29a5aba1e [maoling] remove the setter and return back to setting the running field directly\n28de1e88f [maoling] ZOOKEEPER-1580:QuorumPeer.setRunning is not used",
    "date": "2018-01-30T07:02:41Z",
    "url": "https://github.com/apache/zookeeper/commit/d1b07d588e445085eff4abeb42cf730cc7c57e83",
    "details": {
      "sha": "cec1f9489018ff72509419a7d88e368334271aff",
      "filename": "src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java",
      "status": "modified",
      "additions": 1,
      "deletions": 5,
      "changes": 6,
      "blob_url": "https://github.com/apache/zookeeper/blob/d1b07d588e445085eff4abeb42cf730cc7c57e83/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeer.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/d1b07d588e445085eff4abeb42cf730cc7c57e83/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeer.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeer.java?ref=d1b07d588e445085eff4abeb42cf730cc7c57e83",
      "patch": "@@ -479,7 +479,7 @@ public synchronized void setCurrentVote(Vote v){\n         currentVote = v;\n     }\n \n-    volatile boolean running = true;\n+    private volatile boolean running = true;\n \n     /**\n      * The number of milliseconds of each tick\n@@ -1750,10 +1750,6 @@ protected ZKDatabase getZkDb() {\n     public synchronized void initConfigInZKDatabase() {   \n         if (zkDb != null) zkDb.initConfigInZKDatabase(getQuorumVerifier());\n     }\n-    \n-    public void setRunning(boolean running) {\n-        this.running = running;\n-    }\n \n     public boolean isRunning() {\n         return running;",
      "parent_sha": "78708a8587841ccdcb3d07f33d3114e0c8cfc380"
    }
  },
  {
    "oid": "4f515673464e540fa8555b7a3ac85c5d1abe41fb",
    "message": "ZOOKEEPER-4360: Avoid NPE during gauge execution if the leader is not set on FOLLOWER node\n\nOn a follower node, we had this error\n```\nago 20, 2021 1:46:28 PM org.apache.catalina.core.StandardWrapperValve invoke\nGRAVE: Servlet.service() for servlet [metrics] in context with path [/metrics] threw exception\njava.lang.NullPointerException: Cannot invoke \"org.apache.zookeeper.server.quorum.Leader.getProposalStats()\" because the return value of \"org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.getLeader()\" is null\n        at org.apache.zookeeper.server.quorum.LeaderZooKeeperServer.lambda$registerMetrics$5(LeaderZooKeeperServer.java:122)\n        at magnews.zookeeper.ZooKeeperMetricsProviderAdapter$MetricsContextImpl.lambda$registerGauge$0(ZooKeeperMetricsProviderAdapter.java:91)\n```\n\nUnfortunately, I'm not able to reproduce this error deterministically\n\nI've added the null check on leader variable, this will cause the gauge return value to be not registered (on `DefaultMetricsProvider`) and considered as zero on prometheus\n\nNot sure if tests were needed even if the fix is so simple, I can them if requested from reviewers\n\nAuthor: Nicol\u00f2 Boschi <boschi1997@gmail.com>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>, Damien Diederen <ddiederen@apache.org>\n\nCloses #1743 from nicoloboschi/fix/npe-metrics",
    "date": "2021-09-02T16:48:15Z",
    "url": "https://github.com/apache/zookeeper/commit/4f515673464e540fa8555b7a3ac85c5d1abe41fb",
    "details": {
      "sha": "5a51bc23d7e49e819a3b0ea29f6f02723795437a",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/LeaderZooKeeperServer.java",
      "status": "modified",
      "additions": 34,
      "deletions": 26,
      "changes": 60,
      "blob_url": "https://github.com/apache/zookeeper/blob/4f515673464e540fa8555b7a3ac85c5d1abe41fb/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLeaderZooKeeperServer.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/4f515673464e540fa8555b7a3ac85c5d1abe41fb/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLeaderZooKeeperServer.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLeaderZooKeeperServer.java?ref=4f515673464e540fa8555b7a3ac85c5d1abe41fb",
      "patch": "@@ -20,6 +20,7 @@\n \n import java.io.IOException;\n import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n import javax.management.JMException;\n import org.apache.zookeeper.KeeperException.SessionExpiredException;\n import org.apache.zookeeper.jmx.MBeanRegistry;\n@@ -99,34 +100,41 @@ protected void registerMetrics() {\n         super.registerMetrics();\n \n         MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();\n-\n-        rootContext.registerGauge(\"learners\", () -> {\n-            return getLeader().getLearners().size();\n-        });\n-        rootContext.registerGauge(\"synced_followers\", () -> {\n-            return getLeader().getForwardingFollowers().size();\n-        });\n-        rootContext.registerGauge(\"synced_non_voting_followers\", () -> {\n-            return getLeader().getNonVotingFollowers().size();\n-        });\n-\n+        rootContext.registerGauge(\"learners\", gaugeWithLeader(\n+                (leader) -> leader.getLearners().size())\n+        );\n+        rootContext.registerGauge(\"synced_followers\", gaugeWithLeader(\n+                (leader) -> leader.getForwardingFollowers().size()\n+        ));\n+        rootContext.registerGauge(\"synced_non_voting_followers\", gaugeWithLeader(\n+                (leader) -> leader.getNonVotingFollowers().size()\n+        ));\n         rootContext.registerGauge(\"synced_observers\", self::getSynced_observers_metric);\n+        rootContext.registerGauge(\"pending_syncs\", gaugeWithLeader(\n+                (leader) -> leader.getNumPendingSyncs()\n+        ));\n+        rootContext.registerGauge(\"leader_uptime\", gaugeWithLeader(\n+                (leader) -> leader.getUptime()\n+        ));\n+        rootContext.registerGauge(\"last_proposal_size\", gaugeWithLeader(\n+                (leader) -> leader.getProposalStats().getLastBufferSize()\n+        ));\n+        rootContext.registerGauge(\"max_proposal_size\", gaugeWithLeader(\n+                (leader) -> leader.getProposalStats().getMaxBufferSize()\n+        ));\n+        rootContext.registerGauge(\"min_proposal_size\", gaugeWithLeader(\n+                (leader) -> leader.getProposalStats().getMinBufferSize()\n+        ));\n+    }\n \n-        rootContext.registerGauge(\"pending_syncs\", () -> {\n-            return getLeader().getNumPendingSyncs();\n-        });\n-        rootContext.registerGauge(\"leader_uptime\", () -> {\n-            return getLeader().getUptime();\n-        });\n-        rootContext.registerGauge(\"last_proposal_size\", () -> {\n-            return getLeader().getProposalStats().getLastBufferSize();\n-        });\n-        rootContext.registerGauge(\"max_proposal_size\", () -> {\n-            return getLeader().getProposalStats().getMaxBufferSize();\n-        });\n-        rootContext.registerGauge(\"min_proposal_size\", () -> {\n-            return getLeader().getProposalStats().getMinBufferSize();\n-        });\n+    private org.apache.zookeeper.metrics.Gauge gaugeWithLeader(Function<Leader, Number> supplier) {\n+        return () -> {\n+            final Leader leader = getLeader();\n+            if (leader == null) {\n+                return null;\n+            }\n+            return supplier.apply(leader);\n+        };\n     }\n \n     @Override",
      "parent_sha": "726ec30fdd47bccd2a2be021cf6a6b848e9ee28b"
    }
  },
  {
    "oid": "6c7a273bc1c553be34dc7b9e658c6c16b8a023ef",
    "message": "ZOOKEEPER-3728: move traceMask calculation logic into the trace log i\u2026\n\n\u2026n the FinalRequestProcessor#processRequest\n\nAuthor: Brittany Barnes <60981978+blb93@users.noreply.github.com>\nAuthor: Brittany Barnes <brittany.barnes@ibm.com>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>, Justin Ling Mao <maoling199210191@sina.com>, Luciano Resende <lresende@apache.org>\n\nCloses #1271 from blb93/ZOOKEEPER-3728",
    "date": "2020-03-26T21:12:18Z",
    "url": "https://github.com/apache/zookeeper/commit/6c7a273bc1c553be34dc7b9e658c6c16b8a023ef",
    "details": {
      "sha": "a487626dee6fbd8afb64525ed5edf5f5a9432ef5",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/FinalRequestProcessor.java",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/apache/zookeeper/blob/6c7a273bc1c553be34dc7b9e658c6c16b8a023ef/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FFinalRequestProcessor.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/6c7a273bc1c553be34dc7b9e658c6c16b8a023ef/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FFinalRequestProcessor.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FFinalRequestProcessor.java?ref=6c7a273bc1c553be34dc7b9e658c6c16b8a023ef",
      "patch": "@@ -145,12 +145,11 @@ private ProcessTxnResult applyRequest(Request request) {\n     public void processRequest(Request request) {\n         LOG.debug(\"Processing request:: {}\", request);\n \n-        // request.addRQRec(\">final\");\n-        long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;\n-        if (request.type == OpCode.ping) {\n-            traceMask = ZooTrace.SERVER_PING_TRACE_MASK;\n-        }\n         if (LOG.isTraceEnabled()) {\n+            long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;\n+            if (request.type == OpCode.ping) {\n+                traceMask = ZooTrace.SERVER_PING_TRACE_MASK;\n+            }\n             ZooTrace.logRequest(LOG, traceMask, 'E', request, \"\");\n         }\n         ProcessTxnResult rc = null;",
      "parent_sha": "2581f71dd97cfda2cf6768c3457b81c7a93b9ef7"
    }
  },
  {
    "oid": "20daae7d5fa934629e7825ed72e66ad76a94d6aa",
    "message": "ZOOKEEPER-3651: try to fix flaky NettyServerCnxnFactoryTest\n\nThe testOutstandingHandshakeLimit is flaky, I tried to fix it in this commit.\n- I added extra comments and did some restructuring in the code.\n- Avoiding to start unnecessary ZooKeeper servers for tests don't require it\n- Decreasing the number of client connections the test tries to initiate\n- Increasing the timeout to make sure the connections get established\n- Filtering the 'SyncConnected' events in the client watcher to make sure\nthe given connection is really established before counting it\n\nI think the last two points above should fix the flakiness. I tried to run the\ntest in docker, and before the fix it failed for me once in every 4-5 execution.\nAfter applying these changes I re-executed it 100 times without failure.\n\nIf these fixes are not enough, then we can introduce some only-visible-by-test\nmethod to add sleep in the SSLHandshake process in the production code to\nforce to have handshakes in parallel. However, it would be nice to avoid that.\nLet's hope that these fixes will be enough.\n\nAuthor: Mate Szalay-Beko <szalay.beko.mate@gmail.com>\n\nReviewers: Enrico Olivelli <eolivelli@apache.org>, Norbert Kalmar <nkalmar@cloudera.com>\n\nCloses #1184 from symat/ZOOKEEPER-3651",
    "date": "2019-12-16T21:09:36Z",
    "url": "https://github.com/apache/zookeeper/commit/20daae7d5fa934629e7825ed72e66ad76a94d6aa",
    "details": {
      "sha": "76136c4ee4f0d2e491493c32e161c7b2cc9f5c39",
      "filename": "zookeeper-server/src/test/java/org/apache/zookeeper/server/NettyServerCnxnFactoryTest.java",
      "status": "modified",
      "additions": 114,
      "deletions": 36,
      "changes": 150,
      "blob_url": "https://github.com/apache/zookeeper/blob/20daae7d5fa934629e7825ed72e66ad76a94d6aa/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNettyServerCnxnFactoryTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/20daae7d5fa934629e7825ed72e66ad76a94d6aa/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNettyServerCnxnFactoryTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNettyServerCnxnFactoryTest.java?ref=20daae7d5fa934629e7825ed72e66ad76a94d6aa",
      "patch": "@@ -43,24 +43,33 @@ public class NettyServerCnxnFactoryTest extends ClientBase {\n     private static final Logger LOG = LoggerFactory\n             .getLogger(NettyServerCnxnFactoryTest.class);\n \n-    final LinkedBlockingQueue<ZooKeeper> zks = new LinkedBlockingQueue<ZooKeeper>();\n+    ClientX509Util x509Util;\n+    final LinkedBlockingQueue<ZooKeeper> zooKeeperClients = new LinkedBlockingQueue<>();\n+\n \n     @Override\n     public void setUp() throws Exception {\n         System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY,\n                 \"org.apache.zookeeper.server.NettyServerCnxnFactory\");\n-        super.setUp();\n+\n+        // by default, we don't start any ZooKeeper server, as not all the tests are needing it.\n     }\n \n     @Override\n     public void tearDown() throws Exception {\n-        System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);\n \n-        // clean up\n-        for (ZooKeeper zk : zks) {\n+        System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);\n+        if (x509Util != null) {\n+            SSLAuthTest.clearSecureSetting(x509Util);\n+        }\n+        for (ZooKeeper zk : zooKeeperClients) {\n             zk.close();\n         }\n-        super.tearDown();\n+\n+        //stopping the server only if it was started\n+        if (serverFactory != null) {\n+            super.tearDown();\n+        }\n     }\n \n     @Test\n@@ -96,63 +105,132 @@ public void testRebindIPv4IPv6() throws Exception {\n         Assert.assertTrue(factory.getParentChannel().isActive());\n     }\n \n+    /*\n+     * In this test we are flooding the server with SSL connections, and expecting that not\n+     * all the connection will succeed at once. Some of the connections should be closed,\n+     * as there is a maximum number of parallel SSL handshake the server is willing to do\n+     * for security reasons.\n+     */\n     @Test\n     public void testOutstandingHandshakeLimit() throws Exception {\n \n+        // setting up SSL params, but disable some debug logs\n+        x509Util = SSLAuthTest.setUpSecure();\n+        System.clearProperty(\"javax.net.debug\");\n+\n+        // starting a single server (it will be closed in the tearDown)\n+        setUpWithServerId(1);\n+\n+        // initializing the statistics\n         SimpleCounter tlsHandshakeExceeded = (SimpleCounter) ServerMetrics.getMetrics().TLS_HANDSHAKE_EXCEEDED;\n         tlsHandshakeExceeded.reset();\n         Assert.assertEquals(tlsHandshakeExceeded.get(), 0);\n \n-        ClientX509Util x509Util = SSLAuthTest.setUpSecure();\n+        // setting the HandshakeLimit to 3, so only 3 SSL handshakes can happen in parallel\n         NettyServerCnxnFactory factory = (NettyServerCnxnFactory) serverFactory;\n         factory.setSecure(true);\n-        factory.setOutstandingHandshakeLimit(10);\n+        factory.setOutstandingHandshakeLimit(3);\n \n+        // starting the threads that will try to connect to the server\n+        // we will have 3 threads, each of them establishing 3 connections\n         int threadNum = 3;\n-        int cnxnPerThread = 10;\n-        Thread[] cnxnWorker = new Thread[threadNum];\n-\n+        int cnxnPerThread = 3;\n+        int cnxnLimit = threadNum * cnxnPerThread;\n         AtomicInteger cnxnCreated = new AtomicInteger(0);\n         CountDownLatch latch = new CountDownLatch(1);\n-\n+        Thread[] cnxnWorker = new Thread[threadNum];\n         for (int i = 0; i < cnxnWorker.length; i++) {\n-            cnxnWorker[i] = new Thread() {\n-                @Override\n-                public void run() {\n-                    for (int i = 0; i < cnxnPerThread; i++) {\n-                        try {\n-                            zks.add(new ZooKeeper(hostPort, 3000, new Watcher() {\n-                                @Override\n-                                public void process(WatchedEvent event) {\n-                                    int created = cnxnCreated.addAndGet(1);\n-                                    if (created == threadNum * cnxnPerThread) {\n-                                        latch.countDown();\n-                                    }\n-                                }\n-                            }));\n-                        } catch (Exception e) {\n-                            LOG.info(\"Error while creating zk client\", e);\n-                        }\n-                    }\n-                }\n-            };\n+            cnxnWorker[i] = new ClientConnectionGenerator(i, cnxnPerThread, cnxnCreated, cnxnLimit, latch, zooKeeperClients);\n             cnxnWorker[i].start();\n         }\n \n-        Assert.assertThat(latch.await(3, TimeUnit.SECONDS), Matchers.is(true));\n-        LOG.info(\"created {} connections\", threadNum * cnxnPerThread);\n+        // we might need to wait potentially for a longer time for all the connection to get established,\n+        // as the ZooKeeper Server will close some of the connections and the clients will have to re-try\n+        boolean allConnectionsCreatedInTime = latch.await(30, TimeUnit.SECONDS);\n+        int actualConnections = cnxnCreated.get();\n+        LOG.info(\"created {} connections\", actualConnections);\n+        if (!allConnectionsCreatedInTime) {\n+          Assert.fail(String.format(\"Only %d out of %d connections created!\", actualConnections, cnxnLimit));\n+        }\n \n-        // Assert throttling not 0\n+        // Assert the server refused some of the connections because the handshake limit was reached\n+        // (throttling should be greater than 0)\n         long handshakeThrottledNum = tlsHandshakeExceeded.get();\n         LOG.info(\"TLS_HANDSHAKE_EXCEEDED: {}\", handshakeThrottledNum);\n         Assert.assertThat(\"The number of handshake throttled should be \"\n                 + \"greater than 0\", handshakeThrottledNum, Matchers.greaterThan(0L));\n \n-        // Assert there is no outstanding handshake anymore\n+        // Assert there is no outstanding handshake anymore, all the clients connected in the end\n         int outstandingHandshakeNum = factory.getOutstandingHandshakeNum();\n         LOG.info(\"outstanding handshake is {}\", outstandingHandshakeNum);\n         Assert.assertThat(\"The outstanding handshake number should be 0 \"\n                 + \"after all cnxns established\", outstandingHandshakeNum, Matchers.is(0));\n+    }\n \n+\n+    private final class ClientConnectionWatcher implements Watcher {\n+\n+        private final AtomicInteger cnxnCreated;\n+        private final int cnxnLimit;\n+        private final int cnxnThreadId;\n+        private final int cnxnId;\n+        private final CountDownLatch latch;\n+\n+        public ClientConnectionWatcher(AtomicInteger cnxnCreated, int cnxnLimit, int cnxnThreadId,\n+                                       int cnxnId, CountDownLatch latch) {\n+            this.cnxnCreated = cnxnCreated;\n+            this.cnxnLimit = cnxnLimit;\n+            this.cnxnThreadId = cnxnThreadId;\n+            this.cnxnId = cnxnId;\n+            this.latch = latch;\n+        }\n+\n+        @Override\n+        public void process(WatchedEvent event) {\n+            LOG.info(String.format(\"WATCHER [thread: %d, cnx:%d] - new event: %s\", cnxnThreadId, cnxnId, event.toString()));\n+            if (event.getState() == Event.KeeperState.SyncConnected) {\n+              int created = cnxnCreated.addAndGet(1);\n+              if (created == cnxnLimit) {\n+                latch.countDown();\n+              }\n+            }\n+        }\n     }\n+\n+\n+    private final class ClientConnectionGenerator extends Thread {\n+\n+        private final int cnxnThreadId;\n+        private final int cnxnPerThread;\n+        private final AtomicInteger cnxnCreated;\n+        private final int cnxnLimit;\n+        private final CountDownLatch latch;\n+        private final LinkedBlockingQueue<ZooKeeper> zks;\n+\n+        private ClientConnectionGenerator(int cnxnThreadId, int cnxnPerThread,\n+                                          AtomicInteger cnxnCreated, int cnxnLimit,\n+                                          CountDownLatch latch,\n+                                          LinkedBlockingQueue<ZooKeeper> zks) {\n+            this.cnxnThreadId = cnxnThreadId;\n+            this.cnxnPerThread = cnxnPerThread;\n+            this.cnxnCreated = cnxnCreated;\n+            this.cnxnLimit = cnxnLimit;\n+            this.latch = latch;\n+            this.zks = zks;\n+        }\n+\n+        @Override\n+        public void run() {\n+\n+            for (int j = 0; j < cnxnPerThread; j++) {\n+                try {\n+                    zks.add(new ZooKeeper(hostPort, 30000,\n+                                          new ClientConnectionWatcher(cnxnCreated, cnxnLimit, cnxnThreadId, j, latch)));\n+                } catch (Exception e) {\n+                    LOG.info(\"Error while creating zk client\", e);\n+                }\n+            }\n+        }\n+    }\n+\n }",
      "parent_sha": "280bceebcedb29cf58f636931bd975d3622a6c6e"
    }
  },
  {
    "oid": "a30acd2b9168042d52f593c985cbbda8622d83d7",
    "message": "ZOOKEEPER-4037: Closing autoCloseable resource with try-with-resources block\n\nAuthor: lan <1728209643@qq.com>\n\nReviewers: maoling <maoling199210191@sina.com>, Matteo Minardi <matteo.minardi@diennea.com>\n\nCloses #1565 from lanicc/ZOOKEEPER-4037",
    "date": "2021-01-26T14:35:44Z",
    "url": "https://github.com/apache/zookeeper/commit/a30acd2b9168042d52f593c985cbbda8622d83d7",
    "details": {
      "sha": "c56204f1f7634e80961764ee26f5688389e181f9",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java",
      "status": "modified",
      "additions": 5,
      "deletions": 23,
      "changes": 28,
      "blob_url": "https://github.com/apache/zookeeper/blob/a30acd2b9168042d52f593c985cbbda8622d83d7/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerConfig.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/a30acd2b9168042d52f593c985cbbda8622d83d7/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerConfig.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerConfig.java?ref=a30acd2b9168042d52f593c985cbbda8622d83d7",
      "patch": "@@ -180,12 +180,9 @@ public void parse(String path) throws ConfigException {\n                 .build()).create(path);\n \n             Properties cfg = new Properties();\n-            FileInputStream in = new FileInputStream(configFile);\n-            try {\n+            try (FileInputStream in = new FileInputStream(configFile)) {\n                 cfg.load(in);\n                 configFileStr = path;\n-            } finally {\n-                in.close();\n             }\n \n             /* Read entire config file as initial configuration */\n@@ -201,8 +198,7 @@ public void parse(String path) throws ConfigException {\n         if (dynamicConfigFileStr != null) {\n             try {\n                 Properties dynamicCfg = new Properties();\n-                FileInputStream inConfig = new FileInputStream(dynamicConfigFileStr);\n-                try {\n+                try (FileInputStream inConfig = new FileInputStream(dynamicConfigFileStr)) {\n                     dynamicCfg.load(inConfig);\n                     if (dynamicCfg.getProperty(\"version\") != null) {\n                         throw new ConfigException(\"dynamic file shouldn't have version inside\");\n@@ -214,8 +210,6 @@ public void parse(String path) throws ConfigException {\n                     if (version != null) {\n                         dynamicCfg.setProperty(\"version\", version);\n                     }\n-                } finally {\n-                    inConfig.close();\n                 }\n                 setupQuorumPeerConfig(dynamicCfg, false);\n \n@@ -228,11 +222,8 @@ public void parse(String path) throws ConfigException {\n             if (nextDynamicConfigFile.exists()) {\n                 try {\n                     Properties dynamicConfigNextCfg = new Properties();\n-                    FileInputStream inConfigNext = new FileInputStream(nextDynamicConfigFile);\n-                    try {\n+                    try (FileInputStream inConfigNext = new FileInputStream(nextDynamicConfigFile)) {\n                         dynamicConfigNextCfg.load(inConfigNext);\n-                    } finally {\n-                        inConfigNext.close();\n                     }\n                     boolean isHierarchical = false;\n                     for (Entry<Object, Object> entry : dynamicConfigNextCfg.entrySet()) {\n@@ -529,18 +520,12 @@ private void backupOldConfig() throws IOException {\n         new AtomicFileWritingIdiom(new File(configFileStr + \".bak\"), new OutputStreamStatement() {\n             @Override\n             public void write(OutputStream output) throws IOException {\n-                InputStream input = null;\n-                try {\n-                    input = new FileInputStream(new File(configFileStr));\n+                try (InputStream input = new FileInputStream(new File(configFileStr))) {\n                     byte[] buf = new byte[1024];\n                     int bytesRead;\n                     while ((bytesRead = input.read(buf)) > 0) {\n                         output.write(buf, 0, bytesRead);\n                     }\n-                } finally {\n-                    if (input != null) {\n-                        input.close();\n-                    }\n                 }\n             }\n         });\n@@ -597,11 +582,8 @@ public static void editStaticConfig(final String configFileStr, final String dyn\n             .build()).create(dynamicFileStr);\n \n         final Properties cfg = new Properties();\n-        FileInputStream in = new FileInputStream(configFile);\n-        try {\n+        try (FileInputStream in = new FileInputStream(configFile)) {\n             cfg.load(in);\n-        } finally {\n-            in.close();\n         }\n \n         new AtomicFileWritingIdiom(new File(configFileStr), new WriterStatement() {",
      "parent_sha": "fc28f4ec48a674ec1e074645109e2aae87739fe5"
    }
  },
  {
    "oid": "570285af427fd69471a682a071a47483f8f7ddf8",
    "message": "ZOOKEEPER-3649: Add a line break in ls -s CLI\n\nAs per the ticket [ZOOKEEEPER-3649](https://issues.apache.org/jira/browse/ZOOKEEPER-3649) we need to add line break ls -s command.\n\nTo achieve the desired behavior I have added new line character in option.add of  LsCommand.printChildren(). Please do let me know if made changes gives us the desired behavior or if anything else needs to be changed.\n\nAuthor: ravowlga123 <ravowlga@gmail.com>\n\nReviewers: eolivelli@apache.org, andor@apache.org\n\nCloses #1183 from ravowlga123/ZOOKEEPER-3649 and squashes the following commits:\n\nf2e1997d6 [ravowlga123] ZOOKEEPER-3649 Removed additional new line from printChildren\nb36d63664 [ravowlga123] ZOOKEEPER-3649 Add a line break in ls -s CLI",
    "date": "2020-01-09T21:51:51Z",
    "url": "https://github.com/apache/zookeeper/commit/570285af427fd69471a682a071a47483f8f7ddf8",
    "details": {
      "sha": "b12a12acd46a67a3c83f70d1bb1c06343bf36e89",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/cli/LsCommand.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/apache/zookeeper/blob/570285af427fd69471a682a071a47483f8f7ddf8/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fcli%2FLsCommand.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/570285af427fd69471a682a071a47483f8f7ddf8/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fcli%2FLsCommand.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fcli%2FLsCommand.java?ref=570285af427fd69471a682a071a47483f8f7ddf8",
      "patch": "@@ -127,11 +127,10 @@ private void printChildren(List<String> children, Stat stat) {\n             }\n             out.append(child);\n         }\n-        out.append(\"]\");\n+        out.append(\"]\\n\");\n         if (stat != null) {\n             new StatPrinter(out).print(stat);\n         }\n-        out.append(\"\\n\");\n     }\n \n }",
      "parent_sha": "590e3cbcf1967d4de6ebc08a938584e3b4caf7c4"
    }
  },
  {
    "oid": "fd211a5275b6231e668268fb9df2820e07f5f33c",
    "message": "ZOOKEEPER-2687: Deadlock while shutting down the Leader server\n\nLeader server enters into deadlock while shutting down itself. Shutdown of the leader server is called from the synchronized block which must be called from outside the synchronized block. For detail pls refer ZOOKEEPER-2380\n\nAuthor: Mohammad Arshad <arshad@apache.org>\n\nReviewers: Abraham Fine <afine@apache.org>, Rakesh Radhakrishnan <rakeshr@apache.org>\n\nCloses #176 from arshadmohammad/ZOOKEEPER-2687 and squashes the following commits:\n\n7551f5c [Mohammad Arshad] Fixed Rakesh's comments\n1e3ed70 [Mohammad Arshad] ZOOKEEPER-2687:Deadlock while shutting down the Leader server.",
    "date": "2017-02-15T22:04:18Z",
    "url": "https://github.com/apache/zookeeper/commit/fd211a5275b6231e668268fb9df2820e07f5f33c",
    "details": {
      "sha": "0ef5e2c6b0d9d423dbe426b0c0c4450f50398ff3",
      "filename": "src/java/main/org/apache/zookeeper/server/quorum/Leader.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/apache/zookeeper/blob/fd211a5275b6231e668268fb9df2820e07f5f33c/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLeader.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/fd211a5275b6231e668268fb9df2820e07f5f33c/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLeader.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLeader.java?ref=fd211a5275b6231e668268fb9df2820e07f5f33c",
      "patch": "@@ -590,8 +590,9 @@ void lead() throws IOException, InterruptedException {\n \n                     // check leader running status\n                     if (!this.isRunning()) {\n-                        shutdown(\"Unexpected internal error\");\n-                        return;\n+                        // set shutdown flag\n+                        shutdownMessage = \"Unexpected internal error\";\n+                        break;\n                     }\n \n                     if (!tickSkip && !syncedAckSet.hasAllQuorums()) {",
      "parent_sha": "15e3f7fccc770783786e8097f7a6618509bfee0f"
    }
  },
  {
    "oid": "ce0aa2bac7faf1eff3a6317aa8fc889ba13e7130",
    "message": "ZOOKEEPER-2796: Fix broken test testCreateNodeWithoutData caused by ZK-2757.\n\nZK-2757 introduces a new MalformedPathException which intercepts and wraps the IllegalArgumentException that this test was expecting.\n\nAuthor: Michael Han <hanm@apache.org>\n\nCloses #265 from hanm/ZOOKEEPER-2796",
    "date": "2017-05-30T17:43:52Z",
    "url": "https://github.com/apache/zookeeper/commit/ce0aa2bac7faf1eff3a6317aa8fc889ba13e7130",
    "details": {
      "sha": "b0ac07fc2d5c2d3a2b27be35b7af51074bc092aa",
      "filename": "src/java/test/org/apache/zookeeper/ZooKeeperTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/ce0aa2bac7faf1eff3a6317aa8fc889ba13e7130/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2FZooKeeperTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/ce0aa2bac7faf1eff3a6317aa8fc889ba13e7130/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2FZooKeeperTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2FZooKeeperTest.java?ref=ce0aa2bac7faf1eff3a6317aa8fc889ba13e7130",
      "patch": "@@ -293,7 +293,7 @@ public void testCreateNodeWithoutData() throws Exception {\n                     .processZKCmd(zkMain.cl));\n             Assert.fail(\"Created the node with wrong option should \"\n                     + \"throw Exception.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (MalformedPathException e) {\n             Assert.assertEquals(\"Path must start with / character\", e\n                     .getMessage());\n         }",
      "parent_sha": "5bfcc13fd6820c212d67c39fede4dc4a50d84d83"
    }
  },
  {
    "oid": "edf75b5e31f0d9e2fbfadbd95bae9d1d6c4737f6",
    "message": "ZOOKEEPER-2622: ZooTrace.logQuorumPacket does nothing\n\nAuthor: fpj <fpj@apache.org>\n\nReviewers: Edward Ribeiro <edward.ribeiro@gmail.com>\n\nCloses #95 from fpj/ZK-2622",
    "date": "2017-01-28T05:43:53Z",
    "url": "https://github.com/apache/zookeeper/commit/edf75b5e31f0d9e2fbfadbd95bae9d1d6c4737f6",
    "details": {
      "sha": "12ce7d07bd0fb89cda1a92f6906beb8784de1c2a",
      "filename": "src/java/main/org/apache/zookeeper/server/ZooTrace.java",
      "status": "modified",
      "additions": 5,
      "deletions": 7,
      "changes": 12,
      "blob_url": "https://github.com/apache/zookeeper/blob/edf75b5e31f0d9e2fbfadbd95bae9d1d6c4737f6/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooTrace.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/edf75b5e31f0d9e2fbfadbd95bae9d1d6c4737f6/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooTrace.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooTrace.java?ref=edf75b5e31f0d9e2fbfadbd95bae9d1d6c4737f6",
      "patch": "@@ -20,7 +20,7 @@\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-\n+import org.apache.zookeeper.server.quorum.LearnerHandler;\n import org.apache.zookeeper.server.quorum.QuorumPacket;\n \n /**\n@@ -75,12 +75,10 @@ public static void logTraceMessage(Logger log, long mask, String msg) {\n     static public void logQuorumPacket(Logger log, long mask,\n             char direction, QuorumPacket qp)\n     {\n-        return;\n-\n-        // if (isTraceEnabled(log, mask)) {\n-        // logTraceMessage(LOG, mask, direction + \" \"\n-        // + FollowerHandler.packetToString(qp));\n-        // }\n+        if (isTraceEnabled(log, mask)) { \n+            logTraceMessage(log, mask, direction +\n+                    \" \" + LearnerHandler.packetToString(qp));\n+         }\n     }\n \n     static public void logRequest(Logger log, long mask,",
      "parent_sha": "8771ffdaacb87126a485ae740558f6a288ab980b"
    }
  },
  {
    "oid": "d5876e88d6bab3cc1cee04f996b9804ff21581cb",
    "message": "ZOOKEEPER-4514: ClientCnxnSocketNetty throwing NPE\n\nMoved channel object null check to sendPkt method to cover all calling scenarios\n\nAuthor: Mohammad Arshad <arshad@apache.org>\n\nReviewers: Mate Szalay-Beko <symat@apache.org>\n\nCloses #1854 from arshadmohammad/ZOOKEEPER-4514-npe",
    "date": "2022-04-08T16:38:55Z",
    "url": "https://github.com/apache/zookeeper/commit/d5876e88d6bab3cc1cee04f996b9804ff21581cb",
    "details": {
      "sha": "df53978559a3c5f9290fb19ac52632b194663a32",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/ClientCnxnSocketNetty.java",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/apache/zookeeper/blob/d5876e88d6bab3cc1cee04f996b9804ff21581cb/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2FClientCnxnSocketNetty.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/d5876e88d6bab3cc1cee04f996b9804ff21581cb/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2FClientCnxnSocketNetty.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2FClientCnxnSocketNetty.java?ref=d5876e88d6bab3cc1cee04f996b9804ff21581cb",
      "patch": "@@ -304,7 +304,7 @@ private void addBack(Packet head) {\n      * @return a ChannelFuture that will complete when the write operation\n      *         succeeds or fails.\n      */\n-    private ChannelFuture sendPktAndFlush(Packet p) {\n+    private ChannelFuture sendPktAndFlush(Packet p) throws IOException {\n         return sendPkt(p, true);\n     }\n \n@@ -314,7 +314,7 @@ private ChannelFuture sendPktAndFlush(Packet p) {\n      * @return a ChannelFuture that will complete when the write operation\n      *         succeeds or fails.\n      */\n-    private ChannelFuture sendPktOnly(Packet p) {\n+    private ChannelFuture sendPktOnly(Packet p) throws IOException {\n         return sendPkt(p, false);\n     }\n \n@@ -325,7 +325,10 @@ private ChannelFuture sendPktOnly(Packet p) {\n         }\n     };\n \n-    private ChannelFuture sendPkt(Packet p, boolean doFlush) {\n+    private ChannelFuture sendPkt(Packet p, boolean doFlush) throws IOException {\n+        if (channel == null) {\n+            throw new IOException(\"channel has been closed\");\n+        }\n         // Assuming the packet will be sent out successfully. Because if it fails,\n         // the channel will close and clean up queues.\n         p.createBB();\n@@ -336,15 +339,15 @@ private ChannelFuture sendPkt(Packet p, boolean doFlush) {\n         return result;\n     }\n \n-    private void sendPrimePacket() {\n+    private void sendPrimePacket() throws IOException {\n         // assuming the first packet is the priming packet.\n         sendPktAndFlush(outgoingQueue.remove());\n     }\n \n     /**\n      * doWrite handles writing the packets from outgoingQueue via network to server.\n      */\n-    private void doWrite(Queue<Packet> pendingQueue, Packet p, ClientCnxn cnxn) {\n+    private void doWrite(Queue<Packet> pendingQueue, Packet p, ClientCnxn cnxn) throws IOException {\n         updateNow();\n         boolean anyPacketsSent = false;\n         while (true) {\n@@ -374,9 +377,6 @@ private void doWrite(Queue<Packet> pendingQueue, Packet p, ClientCnxn cnxn) {\n \n     @Override\n     void sendPacket(ClientCnxn.Packet p) throws IOException {\n-        if (channel == null) {\n-            throw new IOException(\"channel has been closed\");\n-        }\n         sendPktAndFlush(p);\n     }\n ",
      "parent_sha": "54cb5c39a445c63967ec7c3a46724fe87908440b"
    }
  },
  {
    "oid": "6b70544bddadae8b40ede0f52abe30021ff47bb7",
    "message": "ZOOKEEPER-4853: Fix assert in ZooKeeperQuotaTest#testQuota\n\nReviewers: maoling, shoothzj\nAuthor: 1neverknow\nCloses #2169 from 1neverknow/master",
    "date": "2024-08-26T04:13:18Z",
    "url": "https://github.com/apache/zookeeper/commit/6b70544bddadae8b40ede0f52abe30021ff47bb7",
    "details": {
      "sha": "211f91a476fc50df47c45b8b25cc378888f7c7f5",
      "filename": "zookeeper-server/src/test/java/org/apache/zookeeper/test/ZooKeeperQuotaTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/apache/zookeeper/blob/6b70544bddadae8b40ede0f52abe30021ff47bb7/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Ftest%2FZooKeeperQuotaTest.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/6b70544bddadae8b40ede0f52abe30021ff47bb7/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Ftest%2FZooKeeperQuotaTest.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fzookeeper%2Ftest%2FZooKeeperQuotaTest.java?ref=6b70544bddadae8b40ede0f52abe30021ff47bb7",
      "patch": "@@ -116,7 +116,7 @@ public void testQuota() throws Exception {\n         stopServer();\n         startServer();\n         ZooKeeperServer server = serverFactory.getZooKeeperServer();\n-        assertNotNull(server.getZKDatabase().getDataTree().getMaxPrefixWithQuota(path) != null, \"Quota is still set\");\n+        assertNotNull(server.getZKDatabase().getDataTree().getMaxPrefixWithQuota(path), \"Quota is still set\");\n     }\n \n     @Test",
      "parent_sha": "b64146d3d337e830f8fd4f5ce6a960a50b9e363c"
    }
  },
  {
    "oid": "9f2e2f238c4bcbb0170bb6a983ffa4e92f701488",
    "message": "ZOOKEEPER-3537: Leader election - Use of out of election messages\n\nJust a small change. Check leader in `recvset` when consider notifications from the same election, and not from `outofelection`.\n\nParameter `n.state` is needed when creating the new `Vote` because otherwise the vote will be in a `LOOKING` state and hence `checkLeader` will fail when checking whether the leader is [`LEADING`](https://github.com/apache/zookeeper/blob/master/zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FastLeaderElection.java#L793).\n\nAuthor: Karolos Antoniadis <karolos@gmail.com>\n\nReviewers: Allan Lyu <fangmin@apache.org>, Michael Han <hanm@apache.org>\n\nCloses #1081 from insumity/ZOOKEEPER-3537",
    "date": "2019-09-30T21:22:31Z",
    "url": "https://github.com/apache/zookeeper/commit/9f2e2f238c4bcbb0170bb6a983ffa4e92f701488",
    "details": {
      "sha": "b3657dadcb9c686d4d6cd726a0aadc39bf2809c1",
      "filename": "zookeeper-server/src/main/java/org/apache/zookeeper/server/quorum/FastLeaderElection.java",
      "status": "modified",
      "additions": 17,
      "deletions": 2,
      "changes": 19,
      "blob_url": "https://github.com/apache/zookeeper/blob/9f2e2f238c4bcbb0170bb6a983ffa4e92f701488/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFastLeaderElection.java",
      "raw_url": "https://github.com/apache/zookeeper/raw/9f2e2f238c4bcbb0170bb6a983ffa4e92f701488/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFastLeaderElection.java",
      "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/zookeeper-server%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFastLeaderElection.java?ref=9f2e2f238c4bcbb0170bb6a983ffa4e92f701488",
      "patch": "@@ -907,8 +907,20 @@ public Vote lookForLeader() throws InterruptedException {\n \n         self.start_fle = Time.currentElapsedTime();\n         try {\n+            /*\n+             * The votes from the current leader election are stored in recvset. In other words, a vote v is in recvset\n+             * if v.electionEpoch == logicalclock. The current participant uses recvset to deduce on whether a majority\n+             * of participants has voted for it.\n+             */\n             Map<Long, Vote> recvset = new HashMap<Long, Vote>();\n \n+            /*\n+             * The votes from previous leader elections, as well as the votes from the current leader election are\n+             * stored in outofelection. Note that notifications in a LOOKING state are not stored in outofelection.\n+             * Only FOLLOWING or LEADING notifications are stored in outofelection. The current participant could use\n+             * outofelection to learn which participant is the leader if it arrives late (i.e., higher logicalclock than\n+             * the electionEpoch of the received notifications) in a leader election.\n+             */\n             Map<Long, Vote> outofelection = new HashMap<Long, Vote>();\n \n             int notTimeout = minNotificationInterval;\n@@ -1032,9 +1044,9 @@ public Vote lookForLeader() throws InterruptedException {\n                          * together.\n                          */\n                         if (n.electionEpoch == logicalclock.get()) {\n-                            recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));\n+                            recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));\n                             voteSet = getVoteTracker(recvset, new Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));\n-                            if (voteSet.hasAllQuorums() && checkLeader(outofelection, n.leader, n.electionEpoch)) {\n+                            if (voteSet.hasAllQuorums() && checkLeader(recvset, n.leader, n.electionEpoch)) {\n                                 setPeerState(n.leader, voteSet);\n                                 Vote endVote = new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);\n                                 leaveInstance(endVote);\n@@ -1045,6 +1057,9 @@ public Vote lookForLeader() throws InterruptedException {\n                         /*\n                          * Before joining an established ensemble, verify that\n                          * a majority are following the same leader.\n+                         *\n+                         * Note that the outofelection map also stores votes from the current leader election.\n+                         * See ZOOKEEPER-1732 for more information.\n                          */\n                         outofelection.put(n.sid, new Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));\n                         voteSet = getVoteTracker(outofelection, new Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));",
      "parent_sha": "0d7be16b86830f4bacc4fea9389e0dff760d38e0"
    }
  }
]