[
  {
    "oid": "ff2a1a11dad2b86c673cc4a998abd2db031afaeb",
    "message": "Added DivRemOp that produces both the division result and the remainder.",
    "date": "2013-01-15T17:27:01Z",
    "url": "https://github.com/oracle/graal/commit/ff2a1a11dad2b86c673cc4a998abd2db031afaeb",
    "details": {
      "sha": "11b265e38afccf473a05d344b3e7d9cbd18a865e",
      "filename": "graal/com.oracle.graal.lir.amd64/src/com/oracle/graal/lir/amd64/AMD64Arithmetic.java",
      "status": "modified",
      "additions": 37,
      "deletions": 2,
      "changes": 39,
      "blob_url": "https://github.com/oracle/graal/blob/ff2a1a11dad2b86c673cc4a998abd2db031afaeb/graal%2Fcom.oracle.graal.lir.amd64%2Fsrc%2Fcom%2Foracle%2Fgraal%2Flir%2Famd64%2FAMD64Arithmetic.java",
      "raw_url": "https://github.com/oracle/graal/raw/ff2a1a11dad2b86c673cc4a998abd2db031afaeb/graal%2Fcom.oracle.graal.lir.amd64%2Fsrc%2Fcom%2Foracle%2Fgraal%2Flir%2Famd64%2FAMD64Arithmetic.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.lir.amd64%2Fsrc%2Fcom%2Foracle%2Fgraal%2Flir%2Famd64%2FAMD64Arithmetic.java?ref=ff2a1a11dad2b86c673cc4a998abd2db031afaeb",
      "patch": "@@ -35,8 +35,8 @@\n import com.oracle.graal.lir.asm.*;\n \n public enum AMD64Arithmetic {\n-    IADD, ISUB, IMUL, IDIV, IREM, IUDIV, IUREM, IAND, IOR, IXOR, ISHL, ISHR, IUSHR,\n-    LADD, LSUB, LMUL, LDIV, LREM, LUDIV, LUREM, LAND, LOR, LXOR, LSHL, LSHR, LUSHR,\n+    IADD, ISUB, IMUL, IDIV, IDIVREM, IREM, IUDIV, IUREM, IAND, IOR, IXOR, ISHL, ISHR, IUSHR,\n+    LADD, LSUB, LMUL, LDIV, LDIVREM, LREM, LUDIV, LUREM, LAND, LOR, LXOR, LSHL, LSHR, LUSHR,\n     FADD, FSUB, FMUL, FDIV, FAND, FOR, FXOR,\n     DADD, DSUB, DMUL, DDIV, DAND, DOR, DXOR,\n     INEG, LNEG,\n@@ -195,6 +195,39 @@ public void verify() {\n         }\n     }\n \n+    public static class DivRemOp extends AMD64LIRInstruction {\n+        @Opcode private final AMD64Arithmetic opcode;\n+        @Def protected Value divResult;\n+        @Def protected Value remResult;\n+        @Use protected Value x;\n+        @Alive protected Value y;\n+        @State protected LIRFrameState state;\n+\n+        public DivRemOp(AMD64Arithmetic opcode, Value x, Value y, LIRFrameState state) {\n+            this.opcode = opcode;\n+            this.divResult = AMD64.rax.asValue();\n+            this.remResult = AMD64.rdx.asValue();\n+            this.x = x;\n+            this.y = y;\n+            this.state = state;\n+        }\n+\n+        @Override\n+        public void emitCode(TargetMethodAssembler tasm, AMD64MacroAssembler masm) {\n+            emit(tasm, masm, opcode, null, y, state);\n+        }\n+\n+        @Override\n+        protected void verify() {\n+            super.verify();\n+            // left input in rax, right input in any register but rax and rdx, result quotient in rax, result remainder in rdx\n+            assert asRegister(x) == AMD64.rax;\n+            assert differentRegisters(y, AMD64.rax.asValue(), AMD64.rdx.asValue());\n+            verifyKind(opcode, divResult, x, y);\n+            verifyKind(opcode, remResult, x, y);\n+        }\n+    }\n+\n     public static class DivOp extends AMD64LIRInstruction {\n         @Opcode private final AMD64Arithmetic opcode;\n         @Def protected Value result;\n@@ -310,13 +343,15 @@ public static void emit(TargetMethodAssembler tasm, AMD64MacroAssembler masm, AM\n                 case MOV_F2I: masm.movdl(asIntReg(dst), asFloatReg(src)); break;\n                 case MOV_D2L: masm.movdq(asLongReg(dst), asDoubleReg(src)); break;\n \n+                case IDIVREM:\n                 case IDIV:\n                 case IREM:\n                     masm.cdql();\n                     exceptionOffset = masm.codeBuffer.position();\n                     masm.idivl(asRegister(src));\n                     break;\n \n+                case LDIVREM:\n                 case LDIV:\n                 case LREM:\n                     masm.cdqq();",
      "parent_sha": "14792b03a106a60969b664578bbacf89968d61bb"
    }
  },
  {
    "oid": "baac2dae50769cf6a39cd0e4a49d03da835c62cf",
    "message": "Tests for reconstructing the shadow stack.",
    "date": "2018-07-12T07:46:47Z",
    "url": "https://github.com/oracle/graal/commit/baac2dae50769cf6a39cd0e4a49d03da835c62cf",
    "details": {
      "sha": "e2ffdb2abb3cbb2f1d45fd10fdd309a253b68824",
      "filename": "tools/src/com.oracle.truffle.tools.profiler.test/src/com/oracle/truffle/tools/profiler/test/CPUSamplerTest.java",
      "status": "modified",
      "additions": 306,
      "deletions": 6,
      "changes": 312,
      "blob_url": "https://github.com/oracle/graal/blob/baac2dae50769cf6a39cd0e4a49d03da835c62cf/tools%2Fsrc%2Fcom.oracle.truffle.tools.profiler.test%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Ftools%2Fprofiler%2Ftest%2FCPUSamplerTest.java",
      "raw_url": "https://github.com/oracle/graal/raw/baac2dae50769cf6a39cd0e4a49d03da835c62cf/tools%2Fsrc%2Fcom.oracle.truffle.tools.profiler.test%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Ftools%2Fprofiler%2Ftest%2FCPUSamplerTest.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/tools%2Fsrc%2Fcom.oracle.truffle.tools.profiler.test%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Ftools%2Fprofiler%2Ftest%2FCPUSamplerTest.java?ref=baac2dae50769cf6a39cd0e4a49d03da835c62cf",
      "patch": "@@ -24,21 +24,35 @@\n  */\n package com.oracle.truffle.tools.profiler.test;\n \n-import java.util.Collection;\n-import java.util.Iterator;\n-\n+import com.oracle.truffle.api.CallTarget;\n+import com.oracle.truffle.api.RootCallTarget;\n+import com.oracle.truffle.api.Truffle;\n+import com.oracle.truffle.api.TruffleLanguage;\n+import com.oracle.truffle.api.frame.VirtualFrame;\n+import com.oracle.truffle.api.instrumentation.GenerateWrapper;\n+import com.oracle.truffle.api.instrumentation.InstrumentableNode;\n+import com.oracle.truffle.api.instrumentation.ProbeNode;\n+import com.oracle.truffle.api.instrumentation.ProvidedTags;\n+import com.oracle.truffle.api.instrumentation.StandardTags;\n+import com.oracle.truffle.api.instrumentation.Tag;\n+import com.oracle.truffle.api.nodes.DirectCallNode;\n+import com.oracle.truffle.api.nodes.Node;\n+import com.oracle.truffle.api.nodes.RootNode;\n+import com.oracle.truffle.api.source.SourceSection;\n+import com.oracle.truffle.tools.profiler.CPUSampler;\n+import com.oracle.truffle.tools.profiler.ProfilerNode;\n import org.graalvm.polyglot.Source;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Ignore;\n import org.junit.Test;\n \n-import com.oracle.truffle.tools.profiler.CPUSampler;\n-import com.oracle.truffle.tools.profiler.ProfilerNode;\n+import java.util.Collection;\n+import java.util.Iterator;\n \n public class CPUSamplerTest extends AbstractProfilerTest {\n \n-    private CPUSampler sampler;\n+    private static CPUSampler sampler;\n \n     final int executionCount = 10;\n \n@@ -190,4 +204,290 @@ public void testShadowStackOverflows() {\n     private static void checkTimeline(CPUSampler.Payload payload) {\n         Assert.assertEquals(\"Timeline length and self hit count to not match!\", payload.getSelfHitCount(), payload.getSelfHitTimes().size());\n     }\n+\n+    @TruffleLanguage.Registration(id = RecreateShadowStackTestLanguage.ID, mimeType = RecreateShadowStackTestLanguage.MIME_TYPE, name = \"RecreateShadowStackTestLanguage\", version = \"0.1\")\n+    @ProvidedTags({StandardTags.StatementTag.class, StandardTags.RootTag.class})\n+    public static class RecreateShadowStackTestLanguage extends TruffleLanguage<Integer> {\n+\n+        public static final String ID = \"RecreateShadowStackTestLanguage\";\n+        public static final String MIME_TYPE = \"RecreateShadowStackTestLanguageMime\";\n+\n+        @Override\n+        protected Integer createContext(Env env) {\n+            return 0;\n+        }\n+\n+        @Override\n+        protected boolean isObjectOfLanguage(Object object) {\n+            return false;\n+        }\n+\n+        @Override\n+        protected boolean isThreadAccessAllowed(Thread thread, boolean singleThreaded) {\n+            return true;\n+        }\n+\n+        @Override\n+        protected CallTarget parse(ParsingRequest request) throws Exception {\n+            com.oracle.truffle.api.source.Source source = request.getSource();\n+            SourceSection statement = null;\n+            SourceSection root = null;\n+            Statement startSamplerChild = null;\n+\n+            // Case when we want to test statements and roots\n+            if (source.getCharacters().toString().equals(\"Statement Root\")) {\n+                statement = source.createSection(0, 9);\n+                root = source.createSection(10, 4);\n+                startSamplerChild = new Statement(statement, new SleepNode());\n+            }\n+\n+            // Case when we want to test roots only\n+            if (source.getCharacters().toString().equals(\"Root Root\")) {\n+                statement = source.createUnavailableSection();\n+                root = source.createSection(0, 4);\n+                RootCallTarget sleepTarget = Truffle.getRuntime().createCallTarget(new SRootNode(this, new Root(root, new SleepNode())));\n+                startSamplerChild = new Statement(statement, new CallNode(Truffle.getRuntime().createDirectCallNode(sleepTarget)));\n+            }\n+\n+            RootCallTarget innerTarget = Truffle.getRuntime().createCallTarget(\n+                            new SRootNode(this, new Root(root,\n+                                            new Wrapper(new Statement(statement, new Wrapper(new Statement(statement, new Wrapper(new StartSamplerNode(sampler, startSamplerChild)))))))));\n+            DirectCallNode directCallNode = Truffle.getRuntime().createDirectCallNode(innerTarget);\n+            return Truffle.getRuntime().createCallTarget(\n+                            new SRootNode(this, new Root(root, new Wrapper(new Statement(statement, new Wrapper(new Statement(statement, new Wrapper(new CallNode(directCallNode)))))))));\n+\n+        }\n+\n+        abstract static class SamplerTestNode extends Node {\n+            public abstract Object execute(VirtualFrame frame);\n+        }\n+\n+        static class SleepNode extends SamplerTestNode {\n+\n+            @Override\n+            public Object execute(VirtualFrame frame) {\n+                try {\n+                    Thread.sleep(3000);\n+                } catch (InterruptedException e) {\n+                    Assert.fail(\"Thread interrupted\");\n+                }\n+                return 5;\n+            }\n+        }\n+\n+        static class Wrapper extends SamplerTestNode {\n+            @Child SamplerTestNode node;\n+\n+            Wrapper(SamplerTestNode node) {\n+                this.node = node;\n+                adoptChildren();\n+            }\n+\n+            @Override\n+            public Object execute(VirtualFrame frame) {\n+                return node.execute(frame);\n+            }\n+        }\n+\n+        @GenerateWrapper\n+        static class Statement extends SamplerTestNode implements InstrumentableNode {\n+\n+            @Child SamplerTestNode node;\n+            SourceSection sourceSection;\n+\n+            Statement(Statement other) {\n+                node = other.node;\n+                sourceSection = other.sourceSection;\n+                adoptChildren();\n+            }\n+\n+            Statement(SourceSection sourceSection, SamplerTestNode node) {\n+                this.sourceSection = sourceSection;\n+                this.node = node;\n+            }\n+\n+            @Override\n+            public SourceSection getSourceSection() {\n+                return sourceSection;\n+            }\n+\n+            @Override\n+            public boolean isInstrumentable() {\n+                return true;\n+            }\n+\n+            @Override\n+            public WrapperNode createWrapper(ProbeNode probe) {\n+                return new StatementWrapper(this, this, probe);\n+            }\n+\n+            @Override\n+            public boolean hasTag(Class<? extends Tag> tag) {\n+                return tag == StandardTags.StatementTag.class;\n+            }\n+\n+            @Override\n+            public Object execute(VirtualFrame frame) {\n+                return node.execute(frame);\n+            }\n+        }\n+\n+        @GenerateWrapper\n+        static class Root extends SamplerTestNode implements InstrumentableNode {\n+\n+            @Child SamplerTestNode node;\n+            SourceSection sourceSection;\n+\n+            Root(Root other) {\n+                node = other.node;\n+                sourceSection = other.sourceSection;\n+                adoptChildren();\n+            }\n+\n+            @Override\n+            public SourceSection getSourceSection() {\n+                return sourceSection;\n+            }\n+\n+            Root(SourceSection sourceSection, SamplerTestNode node) {\n+                this.sourceSection = sourceSection;\n+                this.node = node;\n+            }\n+\n+            @Override\n+            public boolean isInstrumentable() {\n+                return true;\n+            }\n+\n+            @Override\n+            public WrapperNode createWrapper(ProbeNode probe) {\n+                return new RootWrapper(this, this, probe);\n+            }\n+\n+            @Override\n+            public boolean hasTag(Class<? extends Tag> tag) {\n+                return tag == StandardTags.RootTag.class;\n+            }\n+\n+            @Override\n+            public Object execute(VirtualFrame frame) {\n+                return node.execute(frame);\n+            }\n+        }\n+\n+        static class SRootNode extends RootNode {\n+\n+            private final RecreateShadowStackTestLanguage language;\n+            @Child SamplerTestNode child;\n+\n+            SRootNode(RecreateShadowStackTestLanguage language, SamplerTestNode child) {\n+                super(language);\n+                this.language = language;\n+                this.child = child;\n+                adoptChildren();\n+            }\n+\n+            protected SRootNode(SRootNode other) {\n+                super(other.language);\n+                language = other.language;\n+                child = other.child;\n+                adoptChildren();\n+            }\n+\n+            @Override\n+            public Object execute(VirtualFrame frame) {\n+                return child.execute(frame);\n+            }\n+        }\n+\n+        static class CallNode extends SamplerTestNode {\n+            @Child DirectCallNode callNode;\n+\n+            CallNode(DirectCallNode callNode) {\n+                this.callNode = callNode;\n+                adoptChildren();\n+            }\n+\n+            @Override\n+            public Object execute(VirtualFrame frame) {\n+                return callNode.call(new Object[]{});\n+            }\n+        }\n+\n+        static class StartSamplerNode extends SamplerTestNode {\n+            CPUSampler sampler;\n+            @Child SamplerTestNode child;\n+\n+            StartSamplerNode(CPUSampler sampler, SamplerTestNode child) {\n+                this.sampler = sampler;\n+                this.child = child;\n+                adoptChildren();\n+            }\n+\n+            @Override\n+            public Object execute(VirtualFrame frame) {\n+                Assert.assertTrue(\"Found roots before enabling sampler\", sampler.getRootNodes().isEmpty());\n+                sampler.setCollecting(true);\n+                return child.execute(frame);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testCorrectInitShadowStackStatements() {\n+        sampler.setMode(CPUSampler.Mode.STATEMENTS);\n+        sampler.setFilter(NO_INTERNAL_STATEMENT_TAG_FILTER);\n+        Source test = Source.newBuilder(RecreateShadowStackTestLanguage.ID, \"Statement Root\", \"test\").buildLiteral();\n+        context.eval(test);\n+        Collection<ProfilerNode<CPUSampler.Payload>> rootNodes = sampler.getRootNodes();\n+\n+        ProfilerNode<CPUSampler.Payload> current = rootNodes.iterator().next();\n+        Assert.assertEquals(\"Stack not correct\", \"Root\", current.getSourceSection().getCharacters().toString());\n+        Assert.assertTrue(\"Stack not deep enough\", current.getChildren().iterator().hasNext());\n+\n+        current = current.getChildren().iterator().next();\n+        Assert.assertEquals(\"Stack not correct\", \"Statement\", current.getSourceSection().getCharacters().toString());\n+        Assert.assertTrue(\"Stack not deep enough\", current.getChildren().iterator().hasNext());\n+\n+        current = current.getChildren().iterator().next();\n+        Assert.assertEquals(\"Stack not correct\", \"Statement\", current.getSourceSection().getCharacters().toString());\n+        Assert.assertTrue(\"Stack not deep enough\", current.getChildren().iterator().hasNext());\n+\n+        current = current.getChildren().iterator().next();\n+        Assert.assertEquals(\"Stack not correct\", \"Root\", current.getSourceSection().getCharacters().toString());\n+        Assert.assertTrue(\"Stack not deep enough\", current.getChildren().iterator().hasNext());\n+\n+        current = current.getChildren().iterator().next();\n+        Assert.assertEquals(\"Stack not correct\", \"Statement\", current.getSourceSection().getCharacters().toString());\n+        Assert.assertTrue(\"Stack not deep enough\", current.getChildren().iterator().hasNext());\n+\n+        current = current.getChildren().iterator().next();\n+        Assert.assertEquals(\"Stack not correct\", \"Statement\", current.getSourceSection().getCharacters().toString());\n+        Assert.assertTrue(\"Stack not deep enough\", current.getChildren().iterator().hasNext());\n+\n+        current = current.getChildren().iterator().next();\n+        Assert.assertEquals(\"Stack not correct\", \"Statement\", current.getSourceSection().getCharacters().toString());\n+        Assert.assertFalse(\"Stack too deep\", current.getChildren().iterator().hasNext());\n+    }\n+\n+    @Test\n+    public void testCorrectInitShadowStackRoots() {\n+        sampler.setMode(CPUSampler.Mode.ROOTS);\n+        sampler.setFilter(NO_INTERNAL_ROOT_TAG_FILTER);\n+        Source test = Source.newBuilder(RecreateShadowStackTestLanguage.ID, \"Root Root\", \"test\").buildLiteral();\n+        context.eval(test);\n+        Collection<ProfilerNode<CPUSampler.Payload>> rootNodes = sampler.getRootNodes();\n+\n+        ProfilerNode<CPUSampler.Payload> current = rootNodes.iterator().next();\n+        Assert.assertEquals(\"Stack not correct\", \"Root\", current.getSourceSection().getCharacters().toString());\n+        Assert.assertTrue(\"Stack not deep enough\", current.getChildren().iterator().hasNext());\n+\n+        current = current.getChildren().iterator().next();\n+        Assert.assertEquals(\"Stack not correct\", \"Root\", current.getSourceSection().getCharacters().toString());\n+        Assert.assertTrue(\"Stack not deep enough\", current.getChildren().iterator().hasNext());\n+\n+        current = current.getChildren().iterator().next();\n+        Assert.assertEquals(\"Stack not correct\", \"Root\", current.getSourceSection().getCharacters().toString());\n+        Assert.assertFalse(\"Stack too deep\", current.getChildren().iterator().hasNext());\n+    }\n }",
      "parent_sha": "43e7d14a63716263d6829bc18e7824b7b8c0e8a1"
    }
  },
  {
    "oid": "8266efd98019ed8fe000bf9ada44b7dbf2f88db2",
    "message": "remove useless guard",
    "date": "2022-01-26T11:27:54Z",
    "url": "https://github.com/oracle/graal/commit/8266efd98019ed8fe000bf9ada44b7dbf2f88db2",
    "details": {
      "sha": "46154ebcbceb07452344d2506a872540f28e9a68",
      "filename": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/oracle/graal/blob/8266efd98019ed8fe000bf9ada44b7dbf2f88db2/substratevm%2Fsrc%2Fcom.oracle.svm.reflect%2Fsrc%2Fcom%2Foracle%2Fsvm%2Freflect%2Fserialize%2Fhosted%2FSerializationFeature.java",
      "raw_url": "https://github.com/oracle/graal/raw/8266efd98019ed8fe000bf9ada44b7dbf2f88db2/substratevm%2Fsrc%2Fcom.oracle.svm.reflect%2Fsrc%2Fcom%2Foracle%2Fsvm%2Freflect%2Fserialize%2Fhosted%2FSerializationFeature.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm%2Fsrc%2Fcom.oracle.svm.reflect%2Fsrc%2Fcom%2Foracle%2Fsvm%2Freflect%2Fserialize%2Fhosted%2FSerializationFeature.java?ref=8266efd98019ed8fe000bf9ada44b7dbf2f88db2",
      "patch": "@@ -264,7 +264,7 @@ private void registerIncludingAssociatedClasses(ConfigurationCondition condition\n         try {\n             for (Object o : (Object[]) getDataLayoutMethod.invoke(osc)) {\n                 ObjectStreamClass desc = (ObjectStreamClass) descField.get(o);\n-                if (!desc.equals(osc) && !desc.equals(clazz)) {\n+                if (!desc.equals(osc)) {\n                     registerIncludingAssociatedClasses(condition, desc.forClass(), alreadyVisited);\n                 }\n             }",
      "parent_sha": "9df7809a85270aa366735542105e2f66563d487f"
    }
  },
  {
    "oid": "6db1df2a0ba72a0ab3fded02e8269d47dcd43574",
    "message": "style",
    "date": "2023-12-04T19:19:06Z",
    "url": "https://github.com/oracle/graal/commit/6db1df2a0ba72a0ab3fded02e8269d47dcd43574",
    "details": {
      "sha": "c2ff45da8f9fca9dd2ac0bdd6199e54834b6ad18",
      "filename": "substratevm/src/com.oracle.svm.test/src/com/oracle/svm/test/jfr/TestThrottler.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/oracle/graal/blob/6db1df2a0ba72a0ab3fded02e8269d47dcd43574/substratevm%2Fsrc%2Fcom.oracle.svm.test%2Fsrc%2Fcom%2Foracle%2Fsvm%2Ftest%2Fjfr%2FTestThrottler.java",
      "raw_url": "https://github.com/oracle/graal/raw/6db1df2a0ba72a0ab3fded02e8269d47dcd43574/substratevm%2Fsrc%2Fcom.oracle.svm.test%2Fsrc%2Fcom%2Foracle%2Fsvm%2Ftest%2Fjfr%2FTestThrottler.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm%2Fsrc%2Fcom.oracle.svm.test%2Fsrc%2Fcom%2Foracle%2Fsvm%2Ftest%2Fjfr%2FTestThrottler.java?ref=6db1df2a0ba72a0ab3fded02e8269d47dcd43574",
      "patch": "@@ -261,7 +261,8 @@ public void testZeroRate() throws Throwable {\n         recording.stop();\n         recording.close();\n \n-        // Call getEvents directly because we expect zero events (which ordinarily would result in failure).\n+        // Call getEvents directly because we expect zero events (which ordinarily would result in\n+        // failure).\n         assertTrue(getEvents(recording.getDestination(), new String[]{JfrEvent.ObjectAllocationSample.getName()}, true).size() == 0);\n     }\n ",
      "parent_sha": "8a64fd656cc8afd1b93a42a8c0e20e9e83bbf6c9"
    }
  },
  {
    "oid": "d256e10975cfb50e07b6ce4c100d8a8dc866d6b0",
    "message": "Document single threaded mode limitations.",
    "date": "2020-03-04T22:56:54Z",
    "url": "https://github.com/oracle/graal/commit/d256e10975cfb50e07b6ce4c100d8a8dc866d6b0",
    "details": {
      "sha": "76e3fc559adec232d5194ec8b315b9506292fdf6",
      "filename": "src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/EspressoOptions.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/oracle/graal/blob/d256e10975cfb50e07b6ce4c100d8a8dc866d6b0/src%2Fcom.oracle.truffle.espresso%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fespresso%2FEspressoOptions.java",
      "raw_url": "https://github.com/oracle/graal/raw/d256e10975cfb50e07b6ce4c100d8a8dc866d6b0/src%2Fcom.oracle.truffle.espresso%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fespresso%2FEspressoOptions.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/src%2Fcom.oracle.truffle.espresso%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fespresso%2FEspressoOptions.java?ref=d256e10975cfb50e07b6ce4c100d8a8dc866d6b0",
      "patch": "@@ -247,7 +247,9 @@ public JDWPOptions apply(String s) {\n                     category = OptionCategory.EXPERT, stability = OptionStability.EXPERIMENTAL) //\n     public static final OptionKey<Boolean> EnableManagement = new OptionKey<>(true);\n \n-    @Option(help = \"Enable support for threads (disable for single-threaded implementation)\", //\n+    @Option(help = \"Enable support for threads. \" +\n+                    \"In single-threaded mode, Thread.start is disabled, weak references and finalizers won't be processed. \" +\n+                    \"Lock operations may be optimized away.\", //\n                     category = OptionCategory.EXPERT, stability = OptionStability.EXPERIMENTAL) //\n     public static final OptionKey<Boolean> MultiThreaded = new OptionKey<>(true);\n ",
      "parent_sha": "fc7ac7df945a96c17dd06fe636684a2102afb632"
    }
  },
  {
    "oid": "2cc4f30c28e58b0ca74ddd19e7e0cdd3b03b891e",
    "message": "[GR-35704] Polyglot shutdown hook thread runs in the Polyglot's thread scope.",
    "date": "2022-04-05T16:56:27Z",
    "url": "https://github.com/oracle/graal/commit/2cc4f30c28e58b0ca74ddd19e7e0cdd3b03b891e",
    "details": {
      "sha": "889bd540aa32838c79c2c738786b2330893fb3ad",
      "filename": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
      "status": "modified",
      "additions": 19,
      "deletions": 15,
      "changes": 34,
      "blob_url": "https://github.com/oracle/graal/blob/2cc4f30c28e58b0ca74ddd19e7e0cdd3b03b891e/truffle%2Fsrc%2Fcom.oracle.truffle.polyglot%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fpolyglot%2FPolyglotEngineImpl.java",
      "raw_url": "https://github.com/oracle/graal/raw/2cc4f30c28e58b0ca74ddd19e7e0cdd3b03b891e/truffle%2Fsrc%2Fcom.oracle.truffle.polyglot%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fpolyglot%2FPolyglotEngineImpl.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/truffle%2Fsrc%2Fcom.oracle.truffle.polyglot%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fpolyglot%2FPolyglotEngineImpl.java?ref=2cc4f30c28e58b0ca74ddd19e7e0cdd3b03b891e",
      "patch": "@@ -92,6 +92,7 @@\n import org.graalvm.polyglot.PolyglotAccess;\n import org.graalvm.polyglot.Source;\n import org.graalvm.polyglot.impl.AbstractPolyglotImpl.AbstractHostService;\n+import org.graalvm.polyglot.impl.AbstractPolyglotImpl.ThreadScope;\n import org.graalvm.polyglot.io.FileSystem;\n import org.graalvm.polyglot.io.MessageTransport;\n import org.graalvm.polyglot.io.ProcessHandler;\n@@ -1416,31 +1417,34 @@ void setAsynchronousStackDepth(PolyglotInstrument polyglotInstrument, int depth)\n \n     private static final class PolyglotShutDownHook implements Runnable {\n \n+        @SuppressWarnings(\"try\")\n         public void run() {\n             PolyglotEngineImpl[] engines;\n             synchronized (ENGINES) {\n                 engines = ENGINES.keySet().toArray(new PolyglotEngineImpl[0]);\n             }\n             for (PolyglotEngineImpl engine : engines) {\n-                if (DEBUG_MISSING_CLOSE) {\n-                    PrintStream out = System.out;\n-                    out.println(\"Missing close on vm shutdown: \");\n-                    out.print(\" InitializedLanguages:\");\n-                    synchronized (engine.lock) {\n-                        for (PolyglotContextImpl context : engine.collectAliveContexts()) {\n-                            for (PolyglotLanguageContext langContext : context.contexts) {\n-                                if (langContext.env != null) {\n-                                    out.print(langContext.language.getId());\n-                                    out.print(\", \");\n+                try (ThreadScope scope = engine.getImpl().getRootImpl().createThreadScope()) {\n+                    if (DEBUG_MISSING_CLOSE) {\n+                        PrintStream out = System.out;\n+                        out.println(\"Missing close on vm shutdown: \");\n+                        out.print(\" InitializedLanguages:\");\n+                        synchronized (engine.lock) {\n+                            for (PolyglotContextImpl context : engine.collectAliveContexts()) {\n+                                for (PolyglotLanguageContext langContext : context.contexts) {\n+                                    if (langContext.env != null) {\n+                                        out.print(langContext.language.getId());\n+                                        out.print(\", \");\n+                                    }\n                                 }\n                             }\n                         }\n+                        out.println();\n+                        engine.createdLocation.printStackTrace();\n+                    }\n+                    if (engine != null) {\n+                        engine.ensureClosed(false, true);\n                     }\n-                    out.println();\n-                    engine.createdLocation.printStackTrace();\n-                }\n-                if (engine != null) {\n-                    engine.ensureClosed(false, true);\n                 }\n             }\n         }",
      "parent_sha": "5b4bb224d313ec698403589945503e9bff6b8ae8"
    }
  },
  {
    "oid": "15a353423dcbf948a4fb635f3e0fd3519ebf6549",
    "message": "Fix style",
    "date": "2022-03-03T15:04:23Z",
    "url": "https://github.com/oracle/graal/commit/15a353423dcbf948a4fb635f3e0fd3519ebf6549",
    "details": {
      "sha": "98629ac4287cecc415c97aa98e78d6a078dabee8",
      "filename": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jfr/events/ExecuteVMOperationEvent.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/oracle/graal/blob/15a353423dcbf948a4fb635f3e0fd3519ebf6549/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2Fjfr%2Fevents%2FExecuteVMOperationEvent.java",
      "raw_url": "https://github.com/oracle/graal/raw/15a353423dcbf948a4fb635f3e0fd3519ebf6549/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2Fjfr%2Fevents%2FExecuteVMOperationEvent.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2Fjfr%2Fevents%2FExecuteVMOperationEvent.java?ref=15a353423dcbf948a4fb635f3e0fd3519ebf6549",
      "patch": "@@ -59,7 +59,7 @@ public static void emit(VMOperation vmOperation, IsolateThread requestingThread,\n             JfrNativeEventWriter.putLong(data, JfrTicks.elapsedTicks() - startTicks);\n             JfrNativeEventWriter.putEventThread(data);\n             JfrNativeEventWriter.putLong(data, JfrVMOperations.singleton().getVMOperationId(vmOperation.getClass()));\n-            JfrNativeEventWriter.putBoolean(data, vmOperation.getCausesSafepoint());  // At a safepoint\n+            JfrNativeEventWriter.putBoolean(data, vmOperation.getCausesSafepoint());\n             JfrNativeEventWriter.putBoolean(data, true);  // Blocking\n             JfrNativeEventWriter.putThread(data, requestingThread);\n             JfrNativeEventWriter.putLong(data, vmOperation.getCausesSafepoint() ? Safepoint.Master.singleton().getSafepointId().rawValue() : 0);",
      "parent_sha": "e499738198550881758ea4aaaf8e5aee01902d6e"
    }
  },
  {
    "oid": "0c7e88710ce185614f9b601c45b548ba6d98feb2",
    "message": "Consider ShortCircuitOr when splitting IfNodes",
    "date": "2016-02-19T18:57:00Z",
    "url": "https://github.com/oracle/graal/commit/0c7e88710ce185614f9b601c45b548ba6d98feb2",
    "details": {
      "sha": "4e7650a03a6dcb1daa6052e14726864474de3497",
      "filename": "graal/com.oracle.graal.nodes/src/com/oracle/graal/nodes/IfNode.java",
      "status": "modified",
      "additions": 64,
      "deletions": 25,
      "changes": 89,
      "blob_url": "https://github.com/oracle/graal/blob/0c7e88710ce185614f9b601c45b548ba6d98feb2/graal%2Fcom.oracle.graal.nodes%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fnodes%2FIfNode.java",
      "raw_url": "https://github.com/oracle/graal/raw/0c7e88710ce185614f9b601c45b548ba6d98feb2/graal%2Fcom.oracle.graal.nodes%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fnodes%2FIfNode.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.nodes%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fnodes%2FIfNode.java?ref=0c7e88710ce185614f9b601c45b548ba6d98feb2",
      "patch": "@@ -776,7 +776,6 @@ private ConditionalNode canonicalizeConditionalCascade(ValueNode trueValue, Valu\n      *\n      * @param tool\n      */\n-    @SuppressWarnings(\"unchecked\")\n     private boolean splitIfAtPhi(SimplifierTool tool) {\n         if (!(predecessor() instanceof MergeNode)) {\n             return false;\n@@ -802,17 +801,7 @@ private boolean splitIfAtPhi(SimplifierTool tool) {\n             return false;\n         }\n \n-        if (condition() instanceof Canonicalizable.Unary<?>) {\n-            Canonicalizable.Unary<?> unary = (Canonicalizable.Unary<?>) condition();\n-            if (unary.getValue() != phi) {\n-                return false;\n-            }\n-        } else if (condition() instanceof Canonicalizable.Binary<?>) {\n-            Canonicalizable.Binary<?> binary = (Canonicalizable.Binary<?>) condition();\n-            if (binary.getX() != phi && binary.getY() != phi) {\n-                return false;\n-            }\n-        } else {\n+        if (!conditionUses(condition(), phi)) {\n             return false;\n         }\n \n@@ -829,19 +818,7 @@ private boolean splitIfAtPhi(SimplifierTool tool) {\n \n         for (EndNode end : merge.forwardEnds().snapshot()) {\n             Node value = phi.valueAt(end);\n-            LogicNode result = null;\n-            if (condition() instanceof Canonicalizable.Binary<?>) {\n-                Canonicalizable.Binary<Node> compare = (Canonicalizable.Binary<Node>) condition;\n-                if (compare.getX() == phi) {\n-                    result = (LogicNode) compare.canonical(tool, value, compare.getY());\n-                } else {\n-                    result = (LogicNode) compare.canonical(tool, compare.getX(), value);\n-                }\n-            } else {\n-                assert condition() instanceof Canonicalizable.Unary<?>;\n-                Canonicalizable.Unary<Node> compare = (Canonicalizable.Unary<Node>) condition;\n-                result = (LogicNode) compare.canonical(tool, value);\n-            }\n+            LogicNode result = computeCondition(tool, condition, phi, value);\n             if (result instanceof LogicConstantNode) {\n                 merge.removeEnd(end);\n                 if (((LogicConstantNode) result).getValue()) {\n@@ -892,6 +869,68 @@ private boolean splitIfAtPhi(SimplifierTool tool) {\n         return true;\n     }\n \n+    /**\n+     * @param condition\n+     * @param phi\n+     * @return true if the passed in {@code condition} uses {@code phi}.\n+     */\n+    private static boolean conditionUses(LogicNode condition, PhiNode phi) {\n+        if (condition instanceof ShortCircuitOrNode) {\n+            if (condition.graph().getGuardsStage().areDeoptsFixed()) {\n+                /*\n+                 * It can be unsafe to simplify a ShortCircuitOr before deopts are fixed because\n+                 * conversion to guards assumes that all the required conditions are being tested.\n+                 * Simplfying the condition based on context before this happens may lose a\n+                 * condition.\n+                 */\n+                ShortCircuitOrNode orNode = (ShortCircuitOrNode) condition;\n+                return conditionUses(orNode.x, phi) || conditionUses(orNode.y, phi);\n+            }\n+        } else if (condition instanceof Canonicalizable.Unary<?>) {\n+            Canonicalizable.Unary<?> unary = (Canonicalizable.Unary<?>) condition;\n+            return unary.getValue() == phi;\n+        } else if (condition instanceof Canonicalizable.Binary<?>) {\n+            Canonicalizable.Binary<?> binary = (Canonicalizable.Binary<?>) condition;\n+            return binary.getX() == phi || binary.getY() == phi;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Canonicalize {@code} condition using {@code value} in place of {@code phi}.\n+     *\n+     * @param tool\n+     * @param condition\n+     * @param phi\n+     * @param value\n+     * @return an improved LogicNode or the original condition\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private static LogicNode computeCondition(SimplifierTool tool, LogicNode condition, PhiNode phi, Node value) {\n+        if (condition instanceof ShortCircuitOrNode) {\n+            if (condition.graph().getGuardsStage().areDeoptsFixed()) {\n+                ShortCircuitOrNode orNode = (ShortCircuitOrNode) condition;\n+                LogicNode resultX = computeCondition(tool, orNode.x, phi, value);\n+                LogicNode resultY = computeCondition(tool, orNode.y, phi, value);\n+                return orNode.canonical(tool, resultX, resultY);\n+            }\n+            return null;\n+        } else if (condition instanceof Canonicalizable.Binary<?>) {\n+            Canonicalizable.Binary<Node> compare = (Canonicalizable.Binary<Node>) condition;\n+            if (compare.getX() == phi) {\n+                return (LogicNode) compare.canonical(tool, value, compare.getY());\n+            } else {\n+                assert compare.getY() == phi;\n+                return (LogicNode) compare.canonical(tool, compare.getX(), value);\n+            }\n+        } else if (condition instanceof Canonicalizable.Unary<?>) {\n+            Canonicalizable.Unary<Node> compare = (Canonicalizable.Unary<Node>) condition;\n+            return (LogicNode) compare.canonical(tool, value);\n+        } else {\n+            throw new JVMCIError(\"unexpected conditional\");\n+        }\n+    }\n+\n     private static void transferProxies(AbstractBeginNode successor, MergeNode falseMerge) {\n         if (successor instanceof LoopExitNode && falseMerge != null) {\n             LoopExitNode loopExitNode = (LoopExitNode) successor;",
      "parent_sha": "0a68438187e7e3196476e7815316773d7929f049"
    }
  },
  {
    "oid": "61216a12928ef1036e625d49dd10d836631082c9",
    "message": "non-adding factory methods in BitLogicNode",
    "date": "2014-06-25T09:20:53Z",
    "url": "https://github.com/oracle/graal/commit/61216a12928ef1036e625d49dd10d836631082c9",
    "details": {
      "sha": "4f39127a356ce9ccabf58de913e815a2b5c5fdac",
      "filename": "graal/com.oracle.graal.nodes/src/com/oracle/graal/nodes/calc/BitLogicNode.java",
      "status": "modified",
      "additions": 16,
      "deletions": 1,
      "changes": 17,
      "blob_url": "https://github.com/oracle/graal/blob/61216a12928ef1036e625d49dd10d836631082c9/graal%2Fcom.oracle.graal.nodes%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fnodes%2Fcalc%2FBitLogicNode.java",
      "raw_url": "https://github.com/oracle/graal/raw/61216a12928ef1036e625d49dd10d836631082c9/graal%2Fcom.oracle.graal.nodes%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fnodes%2Fcalc%2FBitLogicNode.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.nodes%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fnodes%2Fcalc%2FBitLogicNode.java?ref=61216a12928ef1036e625d49dd10d836631082c9",
      "patch": "@@ -34,7 +34,7 @@ public abstract class BitLogicNode extends BinaryNode implements ArithmeticLIRLo\n \n     /**\n      * Constructs a new logic operation node.\n-     * \n+     *\n      * @param x the first input into this node\n      * @param y the second input into this node\n      */\n@@ -48,13 +48,28 @@ public static BitLogicNode and(StructuredGraph graph, ValueNode v1, ValueNode v2\n         return graph.unique(new AndNode(StampTool.and(v1.stamp(), v2.stamp()), v1, v2));\n     }\n \n+    public static BitLogicNode and(ValueNode v1, ValueNode v2) {\n+        assert v1.stamp().isCompatible(v2.stamp());\n+        return new AndNode(StampTool.and(v1.stamp(), v2.stamp()), v1, v2);\n+    }\n+\n     public static BitLogicNode or(StructuredGraph graph, ValueNode v1, ValueNode v2) {\n         assert v1.stamp().isCompatible(v2.stamp());\n         return graph.unique(new OrNode(StampTool.or(v1.stamp(), v2.stamp()), v1, v2));\n     }\n \n+    public static BitLogicNode or(ValueNode v1, ValueNode v2) {\n+        assert v1.stamp().isCompatible(v2.stamp());\n+        return new OrNode(StampTool.or(v1.stamp(), v2.stamp()), v1, v2);\n+    }\n+\n     public static BitLogicNode xor(StructuredGraph graph, ValueNode v1, ValueNode v2) {\n         assert v1.stamp().isCompatible(v2.stamp());\n         return graph.unique(new XorNode(StampTool.xor(v1.stamp(), v2.stamp()), v1, v2));\n     }\n+\n+    public static BitLogicNode xor(ValueNode v1, ValueNode v2) {\n+        assert v1.stamp().isCompatible(v2.stamp());\n+        return new XorNode(StampTool.xor(v1.stamp(), v2.stamp()), v1, v2);\n+    }\n }",
      "parent_sha": "dacbfa62cdd2169ac6f8f4f18b6054bcbc43d8e9"
    }
  },
  {
    "oid": "48b99698b7fe680759fd707b01e8340654fe2dde",
    "message": "Fix copyright year formatting.",
    "date": "2018-11-29T09:16:19Z",
    "url": "https://github.com/oracle/graal/commit/48b99698b7fe680759fd707b01e8340654fe2dde",
    "details": {
      "sha": "afd1f81fdd791d9b40a93e7c373fbebd369ada38",
      "filename": "compiler/src/org.graalvm.compiler.jtt/src/org/graalvm/compiler/jtt/lang/CheckedListTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/oracle/graal/blob/48b99698b7fe680759fd707b01e8340654fe2dde/compiler%2Fsrc%2Forg.graalvm.compiler.jtt%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Fjtt%2Flang%2FCheckedListTest.java",
      "raw_url": "https://github.com/oracle/graal/raw/48b99698b7fe680759fd707b01e8340654fe2dde/compiler%2Fsrc%2Forg.graalvm.compiler.jtt%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Fjtt%2Flang%2FCheckedListTest.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/compiler%2Fsrc%2Forg.graalvm.compiler.jtt%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Fjtt%2Flang%2FCheckedListTest.java?ref=48b99698b7fe680759fd707b01e8340654fe2dde",
      "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2018, 2018, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * This code is free software; you can redistribute it and/or modify it",
      "parent_sha": "da0fe50d4ec382c9c2ace1171a51955ff2983676"
    }
  },
  {
    "oid": "a534a1f888960168f391f149512f8b9fc4f54b01",
    "message": "Support GuardProxyNode in GraphDecoder",
    "date": "2017-03-31T22:14:52Z",
    "url": "https://github.com/oracle/graal/commit/a534a1f888960168f391f149512f8b9fc4f54b01",
    "details": {
      "sha": "75edeb10a4fed9092c08b51731f24d552a52262d",
      "filename": "graal/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/GraphDecoder.java",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/oracle/graal/blob/a534a1f888960168f391f149512f8b9fc4f54b01/graal%2Forg.graalvm.compiler.nodes%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Fnodes%2FGraphDecoder.java",
      "raw_url": "https://github.com/oracle/graal/raw/a534a1f888960168f391f149512f8b9fc4f54b01/graal%2Forg.graalvm.compiler.nodes%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Fnodes%2FGraphDecoder.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Forg.graalvm.compiler.nodes%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Fnodes%2FGraphDecoder.java?ref=a534a1f888960168f391f149512f8b9fc4f54b01",
      "patch": "@@ -860,7 +860,14 @@ protected void handleLoopExplosionProxyNodes(MethodScope methodScope, LoopScope\n \n             } else if (!merge.isPhiAtMerge(existing)) {\n                 /* Now we have two different values, so we need to create a phi node. */\n-                PhiNode phi = graph.addWithoutUnique(new ValuePhiNode(proxy.stamp(), merge));\n+                PhiNode phi;\n+                if (proxy instanceof ValueProxyNode) {\n+                    phi = graph.addWithoutUnique(new ValuePhiNode(proxy.stamp(), merge));\n+                } else if (proxy instanceof GuardProxyNode) {\n+                    phi = graph.addWithoutUnique(new GuardPhiNode(merge));\n+                } else {\n+                    throw GraalError.shouldNotReachHere();\n+                }\n                 /* Add the inputs from all previous exits. */\n                 for (int j = 0; j < merge.phiPredecessorCount() - 1; j++) {\n                     phi.addInput(existing);",
      "parent_sha": "b29777785b119726baf9afc2fe4f6ba2b4a38705"
    }
  },
  {
    "oid": "df24325338bbfed676dc7d9c4ce04d9094f6a30f",
    "message": "Fix ECJ warnings in generated OptionDescriptors classes",
    "date": "2021-11-22T14:44:46Z",
    "url": "https://github.com/oracle/graal/commit/df24325338bbfed676dc7d9c4ce04d9094f6a30f",
    "details": {
      "sha": "941470ff57b1a63d7827e3f8937c6a2c6484f81c",
      "filename": "compiler/src/org.graalvm.compiler.options.processor/src/org/graalvm/compiler/options/processor/OptionProcessor.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/oracle/graal/blob/df24325338bbfed676dc7d9c4ce04d9094f6a30f/compiler%2Fsrc%2Forg.graalvm.compiler.options.processor%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Foptions%2Fprocessor%2FOptionProcessor.java",
      "raw_url": "https://github.com/oracle/graal/raw/df24325338bbfed676dc7d9c4ce04d9094f6a30f/compiler%2Fsrc%2Forg.graalvm.compiler.options.processor%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Foptions%2Fprocessor%2FOptionProcessor.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/compiler%2Fsrc%2Forg.graalvm.compiler.options.processor%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Foptions%2Fprocessor%2FOptionProcessor.java?ref=df24325338bbfed676dc7d9c4ce04d9094f6a30f",
      "patch": "@@ -303,7 +303,7 @@ public static void createOptionsDescriptorsFile(ProcessingEnvironment processing\n             out.println();\n             out.println(\"    @Override\");\n             out.println(\"    public Iterator<\" + desc + \"> iterator() {\");\n-            out.println(\"        return new Iterator<OptionDescriptor>() {\");\n+            out.println(\"        return new Iterator<\" + (processingEnv.getSourceVersion().compareTo(SourceVersion.RELEASE_8) <= 0 ? desc : \"\") + \">() {\");\n             out.println(\"            int i = 0;\");\n             out.println(\"            @Override\");\n             out.println(\"            public boolean hasNext() {\");",
      "parent_sha": "63bce3c91c6f77f31954cfecc9dea6d9e4c742f4"
    }
  },
  {
    "oid": "0a90aad6c5275f84d8598125b6d87a51214e0aa1",
    "message": "Refactor WasmBlockNode according to Alex's comment",
    "date": "2020-03-17T14:17:16Z",
    "url": "https://github.com/oracle/graal/commit/0a90aad6c5275f84d8598125b6d87a51214e0aa1",
    "details": {
      "sha": "755613f5c9534a45166aee69d346be62f1b40074",
      "filename": "wasm/src/org.graalvm.wasm/src/org/graalvm/wasm/nodes/WasmBlockNode.java",
      "status": "modified",
      "additions": 65,
      "deletions": 23,
      "changes": 88,
      "blob_url": "https://github.com/oracle/graal/blob/0a90aad6c5275f84d8598125b6d87a51214e0aa1/wasm%2Fsrc%2Forg.graalvm.wasm%2Fsrc%2Forg%2Fgraalvm%2Fwasm%2Fnodes%2FWasmBlockNode.java",
      "raw_url": "https://github.com/oracle/graal/raw/0a90aad6c5275f84d8598125b6d87a51214e0aa1/wasm%2Fsrc%2Forg.graalvm.wasm%2Fsrc%2Forg%2Fgraalvm%2Fwasm%2Fnodes%2FWasmBlockNode.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/wasm%2Fsrc%2Forg.graalvm.wasm%2Fsrc%2Forg%2Fgraalvm%2Fwasm%2Fnodes%2FWasmBlockNode.java?ref=0a90aad6c5275f84d8598125b6d87a51214e0aa1",
      "patch": "@@ -237,6 +237,7 @@\n import org.graalvm.wasm.WasmLanguage;\n import org.graalvm.wasm.WasmModule;\n import org.graalvm.wasm.constants.TargetOffset;\n+import org.graalvm.wasm.exception.BinaryParserException;\n import org.graalvm.wasm.exception.WasmExecutionException;\n import org.graalvm.wasm.exception.WasmTrap;\n import org.graalvm.wasm.memory.WasmMemory;\n@@ -939,12 +940,8 @@ public TargetOffset execute(WasmContext context, VirtualFrame frame) {\n                 case I64_LOAD32_S:\n                 case I64_LOAD32_U: {\n                     /* The memAlign hint is not currently used or taken into account. */\n-                    if (isLeb128InPool(offset)) {\n-                        offset += codeEntry().byteConstant(byteConstantOffset);\n-                        byteConstantOffset++;\n-                    } else {\n-                        offset += getLeb128Length(offset);\n-                    }\n+                    offset += offsetDelta(offset, byteConstantOffset);\n+                    byteConstantOffset += byteConstantDelta(offset);\n \n                     // region Load LEB128 Unsigned32 -> memOffset\n                     int memOffset = unsignedIntConstant(offset, intConstantOffset);\n@@ -1050,12 +1047,8 @@ public TargetOffset execute(WasmContext context, VirtualFrame frame) {\n                 case I64_STORE_16:\n                 case I64_STORE_32: {\n                     /* The memAlign hint is not currently used or taken into account. */\n-                    if (isLeb128InPool(offset)) {\n-                        offset += codeEntry().intConstant(byteConstantOffset);\n-                        byteConstantOffset++;\n-                    } else {\n-                        offset += getLeb128Length(offset);\n-                    }\n+                    offset += offsetDelta(offset, byteConstantOffset);\n+                    byteConstantOffset += byteConstantDelta(offset);\n \n                     // region Load LEB128 Unsigned32 -> memOffset\n                     int memOffset = unsignedIntConstant(offset, intConstantOffset);\n@@ -2473,39 +2466,88 @@ public int continuationTypeLength() {\n         return typeLength(continuationTypeId);\n     }\n \n-    private int signedIntConstant(int offset, int intConstantOffset) {\n-        return isLeb128InPool(offset) ? codeEntry().intConstant(intConstantOffset) : BinaryStreamParser.peekSignedInt32(codeEntry().data(), offset);\n+    private int unsignedIntConstant(int offset, int intConstantOffset) {\n+        switch (module().storeConstantsInPool) {\n+            case ALWAYS:\n+                return codeEntry().intConstant(intConstantOffset);\n+            case ONLY_BIG:\n+                return isLargeConstant(offset) ? codeEntry().intConstant(intConstantOffset) : codeEntry().data()[offset];\n+            case NONE:\n+                return BinaryStreamParser.peekUnsignedInt32(codeEntry().data(), offset);\n+            default:\n+                throw new WasmExecutionException(this, \"Invalid StoreConstantsInPoolChoice\");\n+        }\n     }\n \n-    private int unsignedIntConstant(int offset, int intConstantOffset) {\n-        return isLeb128InPool(offset) ? codeEntry().intConstant(intConstantOffset) : BinaryStreamParser.peekUnsignedInt32(codeEntry().data(), offset);\n+    private int signedIntConstant(int offset, int intConstantOffset) {\n+        switch (module().storeConstantsInPool) {\n+            case ALWAYS:\n+                return codeEntry().intConstant(intConstantOffset);\n+            case ONLY_BIG:\n+                return isLargeConstant(offset) ? codeEntry().intConstant(intConstantOffset) : BinaryStreamParser.peekSignedInt32(codeEntry().data(), offset);\n+            case NONE:\n+                return BinaryStreamParser.peekSignedInt32(codeEntry().data(), offset);\n+            default:\n+                throw new WasmExecutionException(this, \"Invalid StoreConstantsInPoolChoice\");\n+        }\n     }\n \n     public long signedLongConstant(int offset, int longConstantOffset) {\n-        return isLeb128InPool(offset) ? codeEntry().longConstant(longConstantOffset) : BinaryStreamParser.peekSignedInt64(codeEntry().data(), offset);\n+        switch (module().storeConstantsInPool) {\n+            case ALWAYS:\n+                return codeEntry().longConstant(longConstantOffset);\n+            case ONLY_BIG:\n+                return isLargeConstant(offset) ? codeEntry().longConstant(longConstantOffset) : BinaryStreamParser.peekSignedInt64(codeEntry().data(), offset);\n+            case NONE:\n+                return BinaryStreamParser.peekSignedInt64(codeEntry().data(), offset);\n+            default:\n+                throw new WasmExecutionException(this, \"Invalid StoreConstantsInPoolChoice\");\n+        }\n     }\n \n     private int offsetDelta(int offset, int byteConstantOffset) {\n-        return isLeb128InPool(offset) ? codeEntry().byteConstant(byteConstantOffset) : getLeb128Length(offset);\n+        switch (module().storeConstantsInPool) {\n+            case ALWAYS:\n+                return codeEntry().byteConstant(byteConstantOffset);\n+            case ONLY_BIG:\n+                return isLargeConstant(offset) ? codeEntry().byteConstant(byteConstantOffset) : 1;\n+            case NONE:\n+                return getLeb128Length(offset);\n+            default:\n+                throw new WasmExecutionException(this, \"Invalid StoreConstantsInPoolChoice\");\n+        }\n     }\n \n     private int longConstantDelta(int offset) {\n-        return isLeb128InPool(offset) ? 1 : 0;\n+        return constantDelta(offset);\n     }\n \n     private int intConstantDelta(int offset) {\n-        return isLeb128InPool(offset) ? 1 : 0;\n+        return constantDelta(offset);\n     }\n \n     private int byteConstantDelta(int offset) {\n-        return isLeb128InPool(offset) ? 1 : 0;\n+        return constantDelta(offset);\n+    }\n+\n+    private int constantDelta(int offset) {\n+        switch (module().storeConstantsInPool) {\n+            case ALWAYS:\n+                return 1;\n+            case ONLY_BIG:\n+                return isLargeConstant(offset) ? 1 : 0;\n+            case NONE:\n+                return 0;\n+            default:\n+                throw new WasmExecutionException(this, \"Invalid StoreConstantsInPoolChoice\");\n+        }\n     }\n \n     public int getLeb128Length(int offset) {\n         return BinaryStreamParser.getLeb128Length(codeEntry().data(), offset);\n     }\n \n-    public boolean isLeb128InPool(int offset) {\n-        return BinaryStreamParser.mustPoolLeb128(codeEntry().data(), offset, module().storeConstantsInPool);\n+    private boolean isLargeConstant(int offset) {\n+        return (codeEntry().data()[offset] & 0x80) != 0;\n     }\n }",
      "parent_sha": "b38c89935308777216aed4acee5200e0aa41f5d7"
    }
  },
  {
    "oid": "8503f68e43c71e38ca73347f273d234020c2a8f3",
    "message": "svm: do not trim Throwable#backtrace array",
    "date": "2023-04-21T14:02:29Z",
    "url": "https://github.com/oracle/graal/commit/8503f68e43c71e38ca73347f273d234020c2a8f3",
    "details": {
      "sha": "e0c37a5c86a0be77a4db2dc9e41aa58d4b611aac",
      "filename": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/StackTraceUtils.java",
      "status": "modified",
      "additions": 11,
      "deletions": 4,
      "changes": 15,
      "blob_url": "https://github.com/oracle/graal/blob/8503f68e43c71e38ca73347f273d234020c2a8f3/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2Fjdk%2FStackTraceUtils.java",
      "raw_url": "https://github.com/oracle/graal/raw/8503f68e43c71e38ca73347f273d234020c2a8f3/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2Fjdk%2FStackTraceUtils.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2Fjdk%2FStackTraceUtils.java?ref=8503f68e43c71e38ca73347f273d234020c2a8f3",
      "patch": "@@ -276,6 +276,9 @@ static StackTraceElement[] decodeBacktrace(Object backtrace) {\n     @Uninterruptible(reason = \"Prevent the GC from freeing the CodeInfo object.\")\n     private static void decodeRawBacktrace(long[] trace, BuildStackTraceVisitor visitor) {\n         for (long address : trace) {\n+            if (address == 0) {\n+                break;\n+            }\n             CodePointer ip = WordFactory.pointer(address);\n             UntetheredCodeInfo untetheredInfo = CodeInfoTable.lookupCodeInfo(ip);\n             if (untetheredInfo.isNull()) {\n@@ -307,7 +310,9 @@ protected boolean visitFrame(Pointer sp, CodePointer ip, CodeInfo codeInfo, Deop\n             return false;\n         }\n         VMError.guarantee(deoptimizedFrame == null, \"Deoptimization not supported\");\n-        add(ip.rawValue());\n+        long rawValue = ip.rawValue();\n+        VMError.guarantee(rawValue != 0, \"Unexpected code pointer: 0\");\n+        add(rawValue);\n         return true;\n     }\n \n@@ -319,9 +324,11 @@ private void add(long value) {\n     }\n \n     long[] getArray() {\n-        VMError.guarantee(trace != null, \"No trace\");\n-        // trim to size\n-        return Arrays.copyOf(trace, index);\n+        VMError.guarantee(trace != null, \"Already acquired\");\n+        VMError.guarantee(index == trace.length || trace[index] == 0, \"Unterminated trace?\");\n+        long[] tmp = trace;\n+        trace = null;\n+        return tmp;\n     }\n }\n ",
      "parent_sha": "7261e7ee885ad79d02488a2ee439375a78f9ca52"
    }
  },
  {
    "oid": "8fd8d1676bb7dcfc2c6df80dbeca51042c66945b",
    "message": "Fix checkstyle",
    "date": "2017-05-09T13:24:33Z",
    "url": "https://github.com/oracle/graal/commit/8fd8d1676bb7dcfc2c6df80dbeca51042c66945b",
    "details": {
      "sha": "f5cf7ab0b40500a9296abf18e2db3e17bf430c6e",
      "filename": "truffle/src/com.oracle.truffle.api.dsl.test/src/com/oracle/truffle/api/dsl/test/CachedTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/oracle/graal/blob/8fd8d1676bb7dcfc2c6df80dbeca51042c66945b/truffle%2Fsrc%2Fcom.oracle.truffle.api.dsl.test%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Fdsl%2Ftest%2FCachedTest.java",
      "raw_url": "https://github.com/oracle/graal/raw/8fd8d1676bb7dcfc2c6df80dbeca51042c66945b/truffle%2Fsrc%2Fcom.oracle.truffle.api.dsl.test%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Fdsl%2Ftest%2FCachedTest.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/truffle%2Fsrc%2Fcom.oracle.truffle.api.dsl.test%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Fdsl%2Ftest%2FCachedTest.java?ref=8fd8d1676bb7dcfc2c6df80dbeca51042c66945b",
      "patch": "@@ -520,7 +520,7 @@ public void testCacheDimension2() throws NoSuchFieldException, SecurityException\n     }\n \n     @NodeChild\n-    static abstract class ChildrenAdoption1 extends ValueNode {\n+    abstract static class ChildrenAdoption1 extends ValueNode {\n \n         abstract NodeInterface[] execute(Object value);\n \n@@ -532,7 +532,7 @@ static NodeInterface[] do1(NodeInterface[] value, @Cached(\"value\") NodeInterface\n     }\n \n     @NodeChild\n-    static abstract class ChildrenAdoption2 extends ValueNode {\n+    abstract static class ChildrenAdoption2 extends ValueNode {\n \n         abstract NodeInterface execute(Object value);\n \n@@ -544,7 +544,7 @@ static NodeInterface do1(NodeInterface value, @Cached(\"value\") NodeInterface cac\n     }\n \n     @NodeChild\n-    static abstract class ChildrenAdoption3 extends ValueNode {\n+    abstract static class ChildrenAdoption3 extends ValueNode {\n \n         abstract Node[] execute(Object value);\n \n@@ -556,7 +556,7 @@ static Node[] do1(Node[] value, @Cached(\"value\") Node[] cachedValue) {\n     }\n \n     @NodeChild\n-    static abstract class ChildrenAdoption4 extends ValueNode {\n+    abstract static class ChildrenAdoption4 extends ValueNode {\n \n         abstract Node execute(Object value);\n ",
      "parent_sha": "aa01684e8e40a71b4a0aa50e32cfebb87638d946"
    }
  },
  {
    "oid": "bb5b4adbf342c65ec29f10c16aacf22fead5823a",
    "message": "Increase timeout for test",
    "date": "2015-05-11T17:06:21Z",
    "url": "https://github.com/oracle/graal/commit/bb5b4adbf342c65ec29f10c16aacf22fead5823a",
    "details": {
      "sha": "afad474a20646061f7357ed289e485cb83669b0d",
      "filename": "graal/com.oracle.graal.truffle.test/src/com/oracle/graal/truffle/test/BytecodeInterpreterPartialEvaluationTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/oracle/graal/blob/bb5b4adbf342c65ec29f10c16aacf22fead5823a/graal%2Fcom.oracle.graal.truffle.test%2Fsrc%2Fcom%2Foracle%2Fgraal%2Ftruffle%2Ftest%2FBytecodeInterpreterPartialEvaluationTest.java",
      "raw_url": "https://github.com/oracle/graal/raw/bb5b4adbf342c65ec29f10c16aacf22fead5823a/graal%2Fcom.oracle.graal.truffle.test%2Fsrc%2Fcom%2Foracle%2Fgraal%2Ftruffle%2Ftest%2FBytecodeInterpreterPartialEvaluationTest.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.truffle.test%2Fsrc%2Fcom%2Foracle%2Fgraal%2Ftruffle%2Ftest%2FBytecodeInterpreterPartialEvaluationTest.java?ref=bb5b4adbf342c65ec29f10c16aacf22fead5823a",
      "patch": "@@ -269,7 +269,7 @@ public void nestedLoopsProgram() {\n         assertPartialEvalEqualsAndRunsCorrect(new Program(\"nestedLoopsProgram\", bytecodes, 0, 6));\n     }\n \n-    @Test(timeout = 1000)\n+    @Test(timeout = 2000)\n     public void manyIfsProgram() {\n         byte[] bytecodes = new byte[]{\n         /* 0: */Bytecode.CONST,",
      "parent_sha": "e7d066233f4df239af3ef125bdea436a45810eec"
    }
  },
  {
    "oid": "bed0793dc3cd3c8768046bd74452e48b9c11c929",
    "message": "sulong: inject libsulong++ dependency not for libc+abi itself but for executables depending on libc++abi",
    "date": "2020-03-25T10:19:00Z",
    "url": "https://github.com/oracle/graal/commit/bed0793dc3cd3c8768046bd74452e48b9c11c929",
    "details": {
      "sha": "88a36b9c99baaab9549be97e87c07aa8e3568f8c",
      "filename": "sulong/projects/com.oracle.truffle.llvm.parser.factories/src/com/oracle/truffle/llvm/parser/factories/BasicPlatformCapability.java",
      "status": "modified",
      "additions": 8,
      "deletions": 9,
      "changes": 17,
      "blob_url": "https://github.com/oracle/graal/blob/bed0793dc3cd3c8768046bd74452e48b9c11c929/sulong%2Fprojects%2Fcom.oracle.truffle.llvm.parser.factories%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fparser%2Ffactories%2FBasicPlatformCapability.java",
      "raw_url": "https://github.com/oracle/graal/raw/bed0793dc3cd3c8768046bd74452e48b9c11c929/sulong%2Fprojects%2Fcom.oracle.truffle.llvm.parser.factories%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fparser%2Ffactories%2FBasicPlatformCapability.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/sulong%2Fprojects%2Fcom.oracle.truffle.llvm.parser.factories%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fparser%2Ffactories%2FBasicPlatformCapability.java?ref=bed0793dc3cd3c8768046bd74452e48b9c11c929",
      "patch": "@@ -94,15 +94,6 @@ public String[] getSulongDefaultLibraries() {\n     @Override\n     public List<String> preprocessDependencies(LLVMContext ctx, ExternalLibrary library, List<String> dependencies) {\n         List<String> newDeps = null;\n-        // inject libsulong++ dependency\n-        if (ctx.isInternalLibrary(library) && library.hasFile()) {\n-            Path path = Paths.get(library.getFile().getPath());\n-            String remainder = ctx.getInternalLibraryPath().relativize(path).toString();\n-            if (remainder.startsWith(LIBCXXABI_PREFIX)) {\n-                newDeps = new ArrayList<>(dependencies);\n-                newDeps.add(LIBSULONGXX_FILENAME);\n-            }\n-        }\n         // replace absolute dependencies to libc++* to relative ones (in the llvm home)\n         for (int i = 0; i < dependencies.size(); i++) {\n             String dep = dependencies.get(i);\n@@ -116,9 +107,17 @@ public List<String> preprocessDependencies(LLVMContext ctx, ExternalLibrary libr\n                         }\n                         // replace with file name\n                         newDeps.set(i, filename);\n+                        dep = filename;\n                     }\n                 }\n             }\n+            if (dep.startsWith(LIBCXXABI_PREFIX)) {\n+                // inject libsulong++ dependency\n+                if (newDeps == null) {\n+                    newDeps = new ArrayList<>(dependencies);\n+                }\n+                newDeps.add(LIBSULONGXX_FILENAME);\n+            }\n         }\n         if (newDeps != null) {\n             return newDeps;",
      "parent_sha": "9f76be7a87f6dbefc13f9d88b57e31da5ec59ea3"
    }
  },
  {
    "oid": "4be65173f2e638d52cd94d18ac30dd09bdf3ee14",
    "message": "TraceRA: TraceLinearScanLifetimeAnalysisPhase: remove unused code.",
    "date": "2015-09-08T15:46:39Z",
    "url": "https://github.com/oracle/graal/commit/4be65173f2e638d52cd94d18ac30dd09bdf3ee14",
    "details": {
      "sha": "a267f560ca51f085073ed9bbb12cbf8084b1a139",
      "filename": "graal/com.oracle.graal.lir/src/com/oracle/graal/lir/alloc/trace/TraceLinearScanLifetimeAnalysisPhase.java",
      "status": "modified",
      "additions": 18,
      "deletions": 366,
      "changes": 384,
      "blob_url": "https://github.com/oracle/graal/blob/4be65173f2e638d52cd94d18ac30dd09bdf3ee14/graal%2Fcom.oracle.graal.lir%2Fsrc%2Fcom%2Foracle%2Fgraal%2Flir%2Falloc%2Ftrace%2FTraceLinearScanLifetimeAnalysisPhase.java",
      "raw_url": "https://github.com/oracle/graal/raw/4be65173f2e638d52cd94d18ac30dd09bdf3ee14/graal%2Fcom.oracle.graal.lir%2Fsrc%2Fcom%2Foracle%2Fgraal%2Flir%2Falloc%2Ftrace%2FTraceLinearScanLifetimeAnalysisPhase.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.lir%2Fsrc%2Fcom%2Foracle%2Fgraal%2Flir%2Falloc%2Ftrace%2FTraceLinearScanLifetimeAnalysisPhase.java?ref=4be65173f2e638d52cd94d18ac30dd09bdf3ee14",
      "patch": "@@ -22,45 +22,36 @@\n  */\n package com.oracle.graal.lir.alloc.trace;\n \n-import static com.oracle.graal.compiler.common.GraalOptions.DetailedAsserts;\n import static com.oracle.graal.lir.LIRValueUtil.asVariable;\n import static com.oracle.graal.lir.LIRValueUtil.isVariable;\n import static com.oracle.graal.lir.alloc.trace.TraceLinearScan.isVariableOrRegister;\n import static com.oracle.graal.lir.alloc.trace.TraceRegisterAllocationPhase.Options.TraceRAshareSpillInformation;\n import static com.oracle.graal.lir.alloc.trace.TraceRegisterAllocationPhase.Options.TraceRAuseInterTraceHints;\n-import static com.oracle.graal.lir.debug.LIRGenerationDebugContext.getSourceForOperandFromDebugContext;\n import static jdk.internal.jvmci.code.ValueUtil.asRegisterValue;\n import static jdk.internal.jvmci.code.ValueUtil.asStackSlot;\n import static jdk.internal.jvmci.code.ValueUtil.isIllegal;\n import static jdk.internal.jvmci.code.ValueUtil.isRegister;\n import static jdk.internal.jvmci.code.ValueUtil.isStackSlot;\n \n-import java.util.ArrayDeque;\n import java.util.BitSet;\n-import java.util.Deque;\n import java.util.EnumSet;\n-import java.util.HashSet;\n import java.util.List;\n \n import jdk.internal.jvmci.code.BailoutException;\n import jdk.internal.jvmci.code.Register;\n import jdk.internal.jvmci.code.RegisterValue;\n import jdk.internal.jvmci.code.StackSlot;\n import jdk.internal.jvmci.code.TargetDescription;\n-import jdk.internal.jvmci.common.JVMCIError;\n import jdk.internal.jvmci.meta.AllocatableValue;\n import jdk.internal.jvmci.meta.JavaConstant;\n-import jdk.internal.jvmci.meta.Kind;\n import jdk.internal.jvmci.meta.LIRKind;\n import jdk.internal.jvmci.meta.Value;\n \n import com.oracle.graal.compiler.common.alloc.ComputeBlockOrder;\n import com.oracle.graal.compiler.common.alloc.RegisterAllocationConfig;\n import com.oracle.graal.compiler.common.alloc.TraceBuilder.TraceBuilderResult;\n import com.oracle.graal.compiler.common.cfg.AbstractBlockBase;\n-import com.oracle.graal.compiler.common.util.BitMap2D;\n import com.oracle.graal.debug.Debug;\n-import com.oracle.graal.debug.Debug.Scope;\n import com.oracle.graal.debug.Indent;\n import com.oracle.graal.lir.InstructionValueConsumer;\n import com.oracle.graal.lir.LIR;\n@@ -76,7 +67,6 @@\n import com.oracle.graal.lir.Variable;\n import com.oracle.graal.lir.alloc.trace.TraceInterval.RegisterPriority;\n import com.oracle.graal.lir.alloc.trace.TraceInterval.SpillState;\n-import com.oracle.graal.lir.alloc.trace.TraceLinearScan.BlockData;\n import com.oracle.graal.lir.gen.LIRGenerationResult;\n import com.oracle.graal.lir.gen.LIRGeneratorTool.SpillMoveFactory;\n import com.oracle.graal.lir.ssi.SSIUtil;\n@@ -89,9 +79,9 @@ protected <B extends AbstractBlockBase<B>> void run(TargetDescription target, LI\n         new Analyser(allocator, traceBuilderResult).analyze();\n     }\n \n-    private static class Analyser {\n+    private static final class Analyser {\n         private static final int DUMP_DURING_ANALYSIS_LEVEL = 4;\n-        protected final TraceLinearScan allocator;\n+        private final TraceLinearScan allocator;\n         private final TraceBuilderResult<?> traceBuilderResult;\n \n         /**\n@@ -117,7 +107,7 @@ private boolean isAllocatedOrCurrent(AbstractBlockBase<?> currentBlock, Abstract\n             return traceBuilderResult.getTraceForBlock(other) <= traceBuilderResult.getTraceForBlock(currentBlock);\n         }\n \n-        static void setHint(final LIRInstruction op, TraceInterval to, IntervalHint from) {\n+        private static void setHint(final LIRInstruction op, TraceInterval to, IntervalHint from) {\n             IntervalHint currentHint = to.locationHint(false);\n             if (currentHint == null) {\n                 /*\n@@ -131,20 +121,11 @@ static void setHint(final LIRInstruction op, TraceInterval to, IntervalHint from\n             }\n         }\n \n-        /**\n-         * Bit set for each variable that is contained in each loop.\n-         */\n-        private BitMap2D intervalInLoop;\n-\n-        boolean isIntervalInLoop(int interval, int loop) {\n-            return intervalInLoop.at(interval, loop);\n-        }\n-\n         /**\n          * Numbers all instructions in all blocks. The numbering follows the\n          * {@linkplain ComputeBlockOrder linear scan order}.\n          */\n-        protected void numberInstructions() {\n+        private void numberInstructions() {\n \n             allocator.initIntervals();\n \n@@ -189,338 +170,7 @@ protected void numberInstructions() {\n             assert (index << 1) == opId : \"must match: \" + (index << 1);\n         }\n \n-        /**\n-         * Computes local live sets (i.e. {@link BlockData#liveGen} and {@link BlockData#liveKill})\n-         * separately for each block.\n-         */\n-        @SuppressWarnings(\"try\")\n-        void computeLocalLiveSets() {\n-            int liveSize = allocator.liveSetSize();\n-\n-            intervalInLoop = new BitMap2D(allocator.operandSize(), allocator.numLoops());\n-\n-            // iterate all blocks\n-            for (final AbstractBlockBase<?> block : allocator.sortedBlocks()) {\n-                try (Indent indent = Debug.logAndIndent(\"compute local live sets for block %s\", block)) {\n-\n-                    final BitSet liveGen = new BitSet(liveSize);\n-                    final BitSet liveKill = new BitSet(liveSize);\n-\n-                    List<LIRInstruction> instructions = allocator.getLIR().getLIRforBlock(block);\n-                    int numInst = instructions.size();\n-\n-                    ValueConsumer useConsumer = (operand, mode, flags) -> {\n-                        if (isVariable(operand)) {\n-                            int operandNum = allocator.operandNumber(operand);\n-                            if (!liveKill.get(operandNum)) {\n-                                liveGen.set(operandNum);\n-                                if (Debug.isLogEnabled()) {\n-                                    Debug.log(\"liveGen for operand %d(%s)\", operandNum, operand);\n-                                }\n-                            }\n-                            if (block.getLoop() != null) {\n-                                intervalInLoop.setBit(operandNum, block.getLoop().getIndex());\n-                            }\n-                        }\n-\n-                        if (DetailedAsserts.getValue()) {\n-                            verifyInput(block, liveKill, operand);\n-                        }\n-                    };\n-                    ValueConsumer stateConsumer = (operand, mode, flags) -> {\n-                        if (TraceLinearScan.isVariableOrRegister(operand)) {\n-                            int operandNum = allocator.operandNumber(operand);\n-                            if (!liveKill.get(operandNum)) {\n-                                liveGen.set(operandNum);\n-                                if (Debug.isLogEnabled()) {\n-                                    Debug.log(\"liveGen in state for operand %d(%s)\", operandNum, operand);\n-                                }\n-                            }\n-                        }\n-                    };\n-                    ValueConsumer defConsumer = (operand, mode, flags) -> {\n-                        if (isVariable(operand)) {\n-                            int varNum = allocator.operandNumber(operand);\n-                            liveKill.set(varNum);\n-                            if (Debug.isLogEnabled()) {\n-                                Debug.log(\"liveKill for operand %d(%s)\", varNum, operand);\n-                            }\n-                            if (block.getLoop() != null) {\n-                                intervalInLoop.setBit(varNum, block.getLoop().getIndex());\n-                            }\n-                        }\n-\n-                        if (DetailedAsserts.getValue()) {\n-                            /*\n-                             * Fixed intervals are never live at block boundaries, so they need not\n-                             * be processed in live sets. Process them only in debug mode so that\n-                             * this can be checked\n-                             */\n-                            verifyTemp(liveKill, operand);\n-                        }\n-                    };\n-\n-                    // iterate all instructions of the block\n-                    for (int j = 0; j < numInst; j++) {\n-                        final LIRInstruction op = instructions.get(j);\n-\n-                        try (Indent indent2 = Debug.logAndIndent(\"handle op %d: %s\", op.id(), op)) {\n-                            op.visitEachInput(useConsumer);\n-                            op.visitEachAlive(useConsumer);\n-                            /*\n-                             * Add uses of live locals from interpreter's point of view for proper\n-                             * debug information generation.\n-                             */\n-                            op.visitEachState(stateConsumer);\n-                            op.visitEachTemp(defConsumer);\n-                            op.visitEachOutput(defConsumer);\n-                        }\n-                    } // end of instruction iteration\n-\n-                    BlockData blockSets = allocator.getBlockData(block);\n-                    blockSets.liveGen = liveGen;\n-                    blockSets.liveKill = liveKill;\n-                    blockSets.liveIn = new BitSet(liveSize);\n-                    blockSets.liveOut = new BitSet(liveSize);\n-\n-                    if (Debug.isLogEnabled()) {\n-                        Debug.log(\"liveGen  B%d %s\", block.getId(), blockSets.liveGen);\n-                        Debug.log(\"liveKill B%d %s\", block.getId(), blockSets.liveKill);\n-                    }\n-\n-                }\n-            } // end of block iteration\n-        }\n-\n-        private void verifyTemp(BitSet liveKill, Value operand) {\n-            /*\n-             * Fixed intervals are never live at block boundaries, so they need not be processed in\n-             * live sets. Process them only in debug mode so that this can be checked\n-             */\n-            if (isRegister(operand)) {\n-                if (allocator.isProcessed(operand)) {\n-                    liveKill.set(allocator.operandNumber(operand));\n-                }\n-            }\n-        }\n-\n-        private void verifyInput(AbstractBlockBase<?> block, BitSet liveKill, Value operand) {\n-            /*\n-             * Fixed intervals are never live at block boundaries, so they need not be processed in\n-             * live sets. This is checked by these assertions to be sure about it. The entry block\n-             * may have incoming values in registers, which is ok.\n-             */\n-            if (isRegister(operand) && block != allocator.getLIR().getControlFlowGraph().getStartBlock()) {\n-                if (allocator.isProcessed(operand)) {\n-                    assert liveKill.get(allocator.operandNumber(operand)) : \"using fixed register that is not defined in this block\";\n-                }\n-            }\n-        }\n-\n-        /**\n-         * Performs a backward dataflow analysis to compute global live sets (i.e.\n-         * {@link BlockData#liveIn} and {@link BlockData#liveOut}) for each block.\n-         */\n-        @SuppressWarnings(\"try\")\n-        protected void computeGlobalLiveSets() {\n-            try (Indent indent = Debug.logAndIndent(\"compute global live sets\")) {\n-                int numBlocks = allocator.blockCount();\n-                boolean changeOccurred;\n-                boolean changeOccurredInBlock;\n-                int iterationCount = 0;\n-                BitSet liveOut = new BitSet(allocator.liveSetSize()); // scratch set for\n-// calculations\n-\n-                /*\n-                 * Perform a backward dataflow analysis to compute liveOut and liveIn for each\n-                 * block. The loop is executed until a fixpoint is reached (no changes in an\n-                 * iteration).\n-                 */\n-                do {\n-                    changeOccurred = false;\n-\n-                    try (Indent indent2 = Debug.logAndIndent(\"new iteration %d\", iterationCount)) {\n-\n-                        // iterate all blocks in reverse order\n-                        for (int i = numBlocks - 1; i >= 0; i--) {\n-                            AbstractBlockBase<?> block = allocator.blockAt(i);\n-                            BlockData blockSets = allocator.getBlockData(block);\n-\n-                            changeOccurredInBlock = false;\n-\n-                            /*\n-                             * liveOut(block) is the union of liveIn(sux), for successors sux of\n-                             * block.\n-                             */\n-                            int n = block.getSuccessorCount();\n-                            if (n > 0) {\n-                                liveOut.clear();\n-                                // block has successors\n-                                if (n > 0) {\n-                                    for (AbstractBlockBase<?> successor : block.getSuccessors()) {\n-                                        if (allocator.sortedBlocks().contains(successor)) {\n-                                            liveOut.or(allocator.getBlockData(successor).liveIn);\n-                                        }\n-                                    }\n-                                }\n-\n-                                if (!blockSets.liveOut.equals(liveOut)) {\n-                                    /*\n-                                     * A change occurred. Swap the old and new live out sets to\n-                                     * avoid copying.\n-                                     */\n-                                    BitSet temp = blockSets.liveOut;\n-                                    blockSets.liveOut = liveOut;\n-                                    liveOut = temp;\n-\n-                                    changeOccurred = true;\n-                                    changeOccurredInBlock = true;\n-                                }\n-                            }\n-\n-                            if (iterationCount == 0 || changeOccurredInBlock) {\n-                                /*\n-                                 * liveIn(block) is the union of liveGen(block) with (liveOut(block)\n-                                 * & !liveKill(block)).\n-                                 * \n-                                 * Note: liveIn has to be computed only in first iteration or if\n-                                 * liveOut has changed!\n-                                 */\n-                                BitSet liveIn = blockSets.liveIn;\n-                                liveIn.clear();\n-                                liveIn.or(blockSets.liveOut);\n-                                liveIn.andNot(blockSets.liveKill);\n-                                liveIn.or(blockSets.liveGen);\n-\n-                                if (Debug.isLogEnabled()) {\n-                                    Debug.log(\"block %d: livein = %s,  liveout = %s\", block.getId(), liveIn, blockSets.liveOut);\n-                                }\n-                            }\n-                        }\n-                        iterationCount++;\n-\n-                        if (changeOccurred && iterationCount > 50) {\n-                            throw new BailoutException(\"too many iterations in computeGlobalLiveSets\");\n-                        }\n-                    }\n-                } while (changeOccurred);\n-\n-                if (DetailedAsserts.getValue()) {\n-                    verifyLiveness();\n-                }\n-\n-                // check that the liveIn set of the first block is empty\n-                AbstractBlockBase<?> startBlock = allocator.blockAt(0);\n-                if (allocator.getBlockData(startBlock).liveIn.cardinality() != 0) {\n-                    if (DetailedAsserts.getValue()) {\n-                        reportFailure(numBlocks);\n-                    }\n-                    // bailout if this occurs in product mode.\n-                    throw new JVMCIError(\"liveIn set of first block must be empty: \" + allocator.getBlockData(startBlock).liveIn);\n-                }\n-            }\n-        }\n-\n-        @SuppressWarnings(\"try\")\n-        protected void reportFailure(int numBlocks) {\n-            try (Scope s = Debug.forceLog()) {\n-                try (Indent indent = Debug.logAndIndent(\"report failure\")) {\n-\n-                    BitSet startBlockLiveIn = allocator.getBlockData(allocator.getLIR().getControlFlowGraph().getStartBlock()).liveIn;\n-                    try (Indent indent2 = Debug.logAndIndent(\"Error: liveIn set of first block must be empty (when this fails, variables are used before they are defined):\")) {\n-                        for (int operandNum = startBlockLiveIn.nextSetBit(0); operandNum >= 0; operandNum = startBlockLiveIn.nextSetBit(operandNum + 1)) {\n-                            TraceInterval interval = allocator.intervalFor(operandNum);\n-                            if (interval != null) {\n-                                Value operand = interval.operand;\n-                                Debug.log(\"var %d; operand=%s; node=%s\", operandNum, operand, getSourceForOperandFromDebugContext(operand));\n-                            } else {\n-                                Debug.log(\"var %d; missing operand\", operandNum);\n-                            }\n-                        }\n-                    }\n-\n-                    // print some additional information to simplify debugging\n-                    for (int operandNum = startBlockLiveIn.nextSetBit(0); operandNum >= 0; operandNum = startBlockLiveIn.nextSetBit(operandNum + 1)) {\n-                        TraceInterval interval = allocator.intervalFor(operandNum);\n-                        Value operand = null;\n-                        Object valueForOperandFromDebugContext = null;\n-                        if (interval != null) {\n-                            operand = interval.operand;\n-                            valueForOperandFromDebugContext = getSourceForOperandFromDebugContext(operand);\n-                        }\n-                        try (Indent indent2 = Debug.logAndIndent(\"---- Detailed information for var %d; operand=%s; node=%s ----\", operandNum, operand, valueForOperandFromDebugContext)) {\n-\n-                            Deque<AbstractBlockBase<?>> definedIn = new ArrayDeque<>();\n-                            HashSet<AbstractBlockBase<?>> usedIn = new HashSet<>();\n-                            for (AbstractBlockBase<?> block : allocator.sortedBlocks()) {\n-                                if (allocator.getBlockData(block).liveGen.get(operandNum)) {\n-                                    usedIn.add(block);\n-                                    try (Indent indent3 = Debug.logAndIndent(\"used in block B%d\", block.getId())) {\n-                                        for (LIRInstruction ins : allocator.getLIR().getLIRforBlock(block)) {\n-                                            try (Indent indent4 = Debug.logAndIndent(\"%d: %s\", ins.id(), ins)) {\n-                                                ins.forEachState((liveStateOperand, mode, flags) -> {\n-                                                    Debug.log(\"operand=%s\", liveStateOperand);\n-                                                    return liveStateOperand;\n-                                                });\n-                                            }\n-                                        }\n-                                    }\n-                                }\n-                                if (allocator.getBlockData(block).liveKill.get(operandNum)) {\n-                                    definedIn.add(block);\n-                                    try (Indent indent3 = Debug.logAndIndent(\"defined in block B%d\", block.getId())) {\n-                                        for (LIRInstruction ins : allocator.getLIR().getLIRforBlock(block)) {\n-                                            Debug.log(\"%d: %s\", ins.id(), ins);\n-                                        }\n-                                    }\n-                                }\n-                            }\n-\n-                            int[] hitCount = new int[numBlocks];\n-\n-                            while (!definedIn.isEmpty()) {\n-                                AbstractBlockBase<?> block = definedIn.removeFirst();\n-                                usedIn.remove(block);\n-                                for (AbstractBlockBase<?> successor : block.getSuccessors()) {\n-                                    if (successor.isLoopHeader()) {\n-                                        if (!block.isLoopEnd()) {\n-                                            definedIn.add(successor);\n-                                        }\n-                                    } else {\n-                                        if (++hitCount[successor.getId()] == successor.getPredecessorCount()) {\n-                                            definedIn.add(successor);\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                            try (Indent indent3 = Debug.logAndIndent(\"**** offending usages are in: \")) {\n-                                for (AbstractBlockBase<?> block : usedIn) {\n-                                    Debug.log(\"B%d\", block.getId());\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            } catch (Throwable e) {\n-                throw Debug.handle(e);\n-            }\n-        }\n-\n-        protected void verifyLiveness() {\n-            /*\n-             * Check that fixed intervals are not live at block boundaries (live set must be empty\n-             * at fixed intervals).\n-             */\n-            for (AbstractBlockBase<?> block : allocator.sortedBlocks()) {\n-                for (int j = 0; j < allocator.numRegisters(); j++) {\n-                    assert !allocator.getBlockData(block).liveIn.get(j) : \"liveIn  set of fixed register must be empty\";\n-                    assert !allocator.getBlockData(block).liveOut.get(j) : \"liveOut set of fixed register must be empty\";\n-                    assert !allocator.getBlockData(block).liveGen.get(j) : \"liveGen set of fixed register must be empty\";\n-                }\n-            }\n-        }\n-\n-        protected void addUse(AllocatableValue operand, int from, int to, RegisterPriority registerPriority, LIRKind kind) {\n+        private void addUse(AllocatableValue operand, int from, int to, RegisterPriority registerPriority, LIRKind kind) {\n             if (!allocator.isProcessed(operand)) {\n                 return;\n             }\n@@ -557,7 +207,7 @@ private void addVariableUse(Variable operand, int from, int to, RegisterPriority\n             }\n         }\n \n-        protected void addTemp(AllocatableValue operand, int tempPos, RegisterPriority registerPriority, LIRKind kind) {\n+        private void addTemp(AllocatableValue operand, int tempPos, RegisterPriority registerPriority, LIRKind kind) {\n             if (!allocator.isProcessed(operand)) {\n                 return;\n             }\n@@ -598,7 +248,7 @@ private void addVariableTemp(Variable operand, int tempPos, RegisterPriority reg\n             }\n         }\n \n-        protected void addDef(AllocatableValue operand, LIRInstruction op, RegisterPriority registerPriority, LIRKind kind) {\n+        private void addDef(AllocatableValue operand, LIRInstruction op, RegisterPriority registerPriority, LIRKind kind) {\n             if (!allocator.isProcessed(operand)) {\n                 return;\n             }\n@@ -678,7 +328,7 @@ private void addVariableDef(Variable operand, LIRInstruction op, RegisterPriorit\n          * destination of such moves is assigned the stack slot (which is in the caller's frame) as\n          * its spill slot.\n          */\n-        protected void handleMethodArguments(LIRInstruction op) {\n+        private void handleMethodArguments(LIRInstruction op) {\n             if (op instanceof StackStoreOp) {\n                 StackStoreOp store = (StackStoreOp) op;\n                 StackSlot slot = asStackSlot(store.getStackSlot());\n@@ -688,7 +338,7 @@ protected void handleMethodArguments(LIRInstruction op) {\n             }\n         }\n \n-        protected void addRegisterHint(final LIRInstruction op, final Value targetValue, OperandMode mode, EnumSet<OperandFlag> flags, final boolean hintAtDef) {\n+        private void addRegisterHint(final LIRInstruction op, final Value targetValue, OperandMode mode, EnumSet<OperandFlag> flags, final boolean hintAtDef) {\n             if (flags.contains(OperandFlag.HINT) && TraceLinearScan.isVariableOrRegister(targetValue)) {\n \n                 op.forEachRegisterHint(targetValue, mode, (registerHint, valueMode, valueFlags) -> {\n@@ -736,7 +386,7 @@ private IntervalHint getIntervalHint(AllocatableValue from) {\n          * @param op\n          * @param operand\n          */\n-        protected void changeSpillDefinitionPos(LIRInstruction op, AllocatableValue operand, TraceInterval interval, int defPos) {\n+        private void changeSpillDefinitionPos(LIRInstruction op, AllocatableValue operand, TraceInterval interval, int defPos) {\n             assert interval.isSplitParent() : \"can only be called for split parents\";\n \n             switch (interval.spillState()) {\n@@ -752,8 +402,10 @@ protected void changeSpillDefinitionPos(LIRInstruction op, AllocatableValue oper\n                 case NoSpillStore:\n                     assert defPos <= interval.spillDefinitionPos() : \"positions are processed in reverse order when intervals are created\";\n                     if (defPos < interval.spillDefinitionPos() - 2) {\n-                        // second definition found, so no spill optimization possible for this\n-// interval\n+                        /*\n+                         * Second definition found, so no spill optimization possible for this\n+                         * interval.\n+                         */\n                         interval.setSpillState(SpillState.NoOptimization);\n                     } else {\n                         // two consecutive definitions (because of two-operand LIR form)\n@@ -781,7 +433,7 @@ private static boolean optimizeMethodArgument(Value value) {\n         /**\n          * Determines the register priority for an instruction's output/result operand.\n          */\n-        protected static RegisterPriority registerPriorityOfOutputOperand(LIRInstruction op) {\n+        private static RegisterPriority registerPriorityOfOutputOperand(LIRInstruction op) {\n             if (op instanceof LabelOp) {\n                 // skip method header\n                 return RegisterPriority.None;\n@@ -803,7 +455,7 @@ protected static RegisterPriority registerPriorityOfOutputOperand(LIRInstruction\n          * Determines the priority which with an instruction's input operand will be allocated a\n          * register.\n          */\n-        protected static RegisterPriority registerPriorityOfInputOperand(EnumSet<OperandFlag> flags) {\n+        private static RegisterPriority registerPriorityOfInputOperand(EnumSet<OperandFlag> flags) {\n             if (flags.contains(OperandFlag.STACK)) {\n                 return RegisterPriority.ShouldHaveRegister;\n             }\n@@ -812,7 +464,7 @@ protected static RegisterPriority registerPriorityOfInputOperand(EnumSet<Operand\n         }\n \n         @SuppressWarnings(\"try\")\n-        protected void buildIntervals() {\n+        private void buildIntervals() {\n \n             try (Indent indent = Debug.logAndIndent(\"build intervals\")) {\n                 InstructionValueConsumer outputConsumer = (op, operand, mode, flags) -> {\n@@ -985,7 +637,7 @@ private void addInterTraceHints() {\n          *         all reload-locations in case the interval of this instruction is spilled.\n          *         Currently this can only be a {@link JavaConstant}.\n          */\n-        protected static JavaConstant getMaterializedValue(LIRInstruction op, Value operand, TraceInterval interval) {\n+        private static JavaConstant getMaterializedValue(LIRInstruction op, Value operand, TraceInterval interval) {\n             if (op instanceof LoadConstantOp) {\n                 LoadConstantOp move = (LoadConstantOp) op;\n                 if (move.getConstant() instanceof JavaConstant) {",
      "parent_sha": "d4e7b1afef53a288b0fb8d2cddb531c665cf4d97"
    }
  },
  {
    "oid": "b9f43cbaf11c8409683ca3dc8a4d9b0197460b18",
    "message": "Ignore versioning from multi-versioned jar files when enumerating classes.",
    "date": "2018-10-04T22:47:25Z",
    "url": "https://github.com/oracle/graal/commit/b9f43cbaf11c8409683ca3dc8a4d9b0197460b18",
    "details": {
      "sha": "8eaaa04a0760e3ef825b0e6ee6ca0e545a1413cf",
      "filename": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/ImageClassLoader.java",
      "status": "modified",
      "additions": 35,
      "deletions": 4,
      "changes": 39,
      "blob_url": "https://github.com/oracle/graal/blob/b9f43cbaf11c8409683ca3dc8a4d9b0197460b18/substratevm%2Fsrc%2Fcom.oracle.svm.hosted%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fhosted%2FImageClassLoader.java",
      "raw_url": "https://github.com/oracle/graal/raw/b9f43cbaf11c8409683ca3dc8a4d9b0197460b18/substratevm%2Fsrc%2Fcom.oracle.svm.hosted%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fhosted%2FImageClassLoader.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm%2Fsrc%2Fcom.oracle.svm.hosted%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fhosted%2FImageClassLoader.java?ref=b9f43cbaf11c8409683ca3dc8a4d9b0197460b18",
      "patch": "@@ -78,7 +78,8 @@ static class Options {\n     }\n     /* } GR-8964: Add an option to control tracing. */\n \n-    private static final int CLASS_LENGTH = \".class\".length();\n+    private static final String CLASS_EXTENSION = \".class\";\n+    private static final int CLASS_EXTENSION_LENGTH = CLASS_EXTENSION.length();\n     private static final int CLASS_LOADING_TIMEOUT_IN_MINUTES = 10;\n \n     static {\n@@ -266,9 +267,10 @@ public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IO\n                     return FileVisitResult.SKIP_SIBLINGS;\n                 }\n                 executor.execute(() -> {\n-                    String fileName = root.relativize(file).toString().replace('/', '.');\n-                    if (fileName.endsWith(\".class\")) {\n-                        String className = fileName.substring(0, fileName.length() - CLASS_LENGTH);\n+                    String fileName = root.relativize(file).toString();\n+                    if (fileName.endsWith(CLASS_EXTENSION)) {\n+                        String unversionedClassName = unversionedFileName(fileName);\n+                        String className = curtail(unversionedClassName, CLASS_EXTENSION_LENGTH).replace('/', '.');\n                         try {\n                             Class<?> systemClass = Class.forName(className, false, classLoader);\n                             if (includedInPlatform(systemClass)) {\n@@ -290,6 +292,35 @@ public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOExce\n                 /* Silently ignore inaccessible files or directories. */\n                 return FileVisitResult.CONTINUE;\n             }\n+\n+            /**\n+             * Take a file name from a possibly-multi-versioned jar file and remove the versioning\n+             * information. See https://docs.oracle.com/javase/9/docs/api/java/util/jar/JarFile.html\n+             * for the specification of the versioning strings.\n+             *\n+             * Then, depend on the JDK class loading mechanism to prefer the appropriately-versioned\n+             * class when the class is loaded. The same class name be loaded multiple times, but\n+             * each request will return the same appropriately-versioned class. If a\n+             * higher-versioned class is not available in a lower-versioned JDK, a\n+             * ClassNotFoundException will be thrown, which will be handled appropriately.\n+             */\n+            private String unversionedFileName(String fileName) {\n+                final String versionedPrefix = \"META-INF/versions/\";\n+                final String versionedSuffix = \"/\";\n+                String result = fileName;\n+                if (fileName.startsWith(versionedPrefix)) {\n+                    final int versionedSuffixIndex = fileName.indexOf(versionedSuffix, versionedPrefix.length());\n+                    if (versionedSuffixIndex >= 0) {\n+                        result = fileName.substring(versionedSuffixIndex + versionedSuffix.length());\n+                    }\n+                }\n+                return result;\n+            }\n+\n+            /** Remove the requested number of characters from the tail of the given string. */\n+            private String curtail(String str, int tailLength) {\n+                return str.substring(0, str.length() - tailLength);\n+            }\n         };\n \n         try {",
      "parent_sha": "6e504410a9dac15d7a241b2427809ea034833660"
    }
  },
  {
    "oid": "4c78bc604b1d60e93809ad1af8f888be3bbe1cbf",
    "message": "MoveResolver: refactor handling of blocked registers.",
    "date": "2015-04-27T14:26:14Z",
    "url": "https://github.com/oracle/graal/commit/4c78bc604b1d60e93809ad1af8f888be3bbe1cbf",
    "details": {
      "sha": "fd7b07ae7d696d03309d9dcfd61be48ab26351e2",
      "filename": "graal/com.oracle.graal.lir/src/com/oracle/graal/lir/alloc/lsra/MoveResolver.java",
      "status": "modified",
      "additions": 18,
      "deletions": 13,
      "changes": 31,
      "blob_url": "https://github.com/oracle/graal/blob/4c78bc604b1d60e93809ad1af8f888be3bbe1cbf/graal%2Fcom.oracle.graal.lir%2Fsrc%2Fcom%2Foracle%2Fgraal%2Flir%2Falloc%2Flsra%2FMoveResolver.java",
      "raw_url": "https://github.com/oracle/graal/raw/4c78bc604b1d60e93809ad1af8f888be3bbe1cbf/graal%2Fcom.oracle.graal.lir%2Fsrc%2Fcom%2Foracle%2Fgraal%2Flir%2Falloc%2Flsra%2FMoveResolver.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.lir%2Fsrc%2Fcom%2Foracle%2Fgraal%2Flir%2Falloc%2Flsra%2FMoveResolver.java?ref=4c78bc604b1d60e93809ad1af8f888be3bbe1cbf",
      "patch": "@@ -29,6 +29,7 @@\n \n import com.oracle.graal.api.code.*;\n import com.oracle.graal.api.meta.*;\n+import com.oracle.graal.compiler.common.*;\n import com.oracle.graal.debug.*;\n import com.oracle.graal.lir.*;\n \n@@ -47,13 +48,18 @@ final class MoveResolver {\n     private boolean multipleReadsAllowed;\n     private final int[] registerBlocked;\n \n-    private int registerBlocked(int reg) {\n-        return registerBlocked[reg];\n+    private void setValueBlocked(Value location, int direction) {\n+        assert direction == 1 || direction == -1 : \"out of bounds\";\n+        if (isRegister(location)) {\n+            registerBlocked[asRegister(location).number] += direction;\n+        }\n     }\n \n-    private void setRegisterBlocked(int reg, int direction) {\n-        assert direction == 1 || direction == -1 : \"out of bounds\";\n-        registerBlocked[reg] += direction;\n+    private int valueBlocked(Value location) {\n+        if (isRegister(location)) {\n+            return registerBlocked[asRegister(location).number];\n+        }\n+        throw GraalInternalError.shouldNotReachHere(\"unhandled value \" + location);\n     }\n \n     void setMultipleReadsAllowed() {\n@@ -80,7 +86,7 @@ boolean hasMappings() {\n     boolean checkEmpty() {\n         assert mappingFrom.size() == 0 && mappingFromOpr.size() == 0 && mappingTo.size() == 0 : \"list must be empty before and after processing\";\n         for (int i = 0; i < allocator.registers.length; i++) {\n-            assert registerBlocked(i) == 0 : \"register map must be empty before and after processing\";\n+            assert registerBlocked[i] == 0 : \"register map must be empty before and after processing\";\n         }\n         assert !multipleReadsAllowed : \"must have default value\";\n         return true;\n@@ -149,19 +155,18 @@ private boolean verifyBeforeResolve() {\n     private void blockRegisters(Interval interval) {\n         Value location = interval.location();\n         if (isRegister(location)) {\n-            int reg = asRegister(location).number;\n-            assert multipleReadsAllowed || registerBlocked(reg) == 0 : \"register already marked as used\";\n-            setRegisterBlocked(reg, 1);\n+            assert multipleReadsAllowed || valueBlocked(location) == 0 : \"register already marked as used\";\n+            int direction = 1;\n+            setValueBlocked(location, direction);\n         }\n     }\n \n     // mark assignedReg and assignedRegHi of the interval as unblocked\n     private void unblockRegisters(Interval interval) {\n         Value location = interval.location();\n         if (isRegister(location)) {\n-            int reg = asRegister(location).number;\n-            assert registerBlocked(reg) > 0 : \"register already marked as unused\";\n-            setRegisterBlocked(reg, -1);\n+            assert valueBlocked(location) > 0 : \"register already marked as unused\";\n+            setValueBlocked(location, -1);\n         }\n     }\n \n@@ -174,7 +179,7 @@ private boolean safeToProcessMove(Interval from, Interval to) {\n \n         Value reg = to.location();\n         if (isRegister(reg)) {\n-            if (registerBlocked(asRegister(reg).number) > 1 || (registerBlocked(asRegister(reg).number) == 1 && !reg.equals(fromReg))) {\n+            if (valueBlocked(reg) > 1 || (valueBlocked(reg) == 1 && !reg.equals(fromReg))) {\n                 return false;\n             }\n         }",
      "parent_sha": "4f1096b268faaf6ff5384eff05535a58cfbbd99d"
    }
  },
  {
    "oid": "9b2fc6ac8d0231487a99da8d11a55f0aa80fd87d",
    "message": "Use compilationProfile for checking whether call target is initialized",
    "date": "2016-11-09T23:21:12Z",
    "url": "https://github.com/oracle/graal/commit/9b2fc6ac8d0231487a99da8d11a55f0aa80fd87d",
    "details": {
      "sha": "020235f29da0f5f3591a8e384e46dca71a979a0b",
      "filename": "graal/com.oracle.graal.truffle/src/com/oracle/graal/truffle/OptimizedCallTarget.java",
      "status": "modified",
      "additions": 24,
      "deletions": 20,
      "changes": 44,
      "blob_url": "https://github.com/oracle/graal/blob/9b2fc6ac8d0231487a99da8d11a55f0aa80fd87d/graal%2Fcom.oracle.graal.truffle%2Fsrc%2Fcom%2Foracle%2Fgraal%2Ftruffle%2FOptimizedCallTarget.java",
      "raw_url": "https://github.com/oracle/graal/raw/9b2fc6ac8d0231487a99da8d11a55f0aa80fd87d/graal%2Fcom.oracle.graal.truffle%2Fsrc%2Fcom%2Foracle%2Fgraal%2Ftruffle%2FOptimizedCallTarget.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.truffle%2Fsrc%2Fcom%2Foracle%2Fgraal%2Ftruffle%2FOptimizedCallTarget.java?ref=9b2fc6ac8d0231487a99da8d11a55f0aa80fd87d",
      "patch": "@@ -88,7 +88,6 @@ public class OptimizedCallTarget extends InstalledCode implements RootCallTarget\n     private volatile RootNode uninitializedRootNode;\n     private volatile int cachedNonTrivialNodeCount = -1;\n     private volatile SpeculationLog speculationLog;\n-    @CompilationFinal private volatile boolean initialized;\n     private volatile int callSitesKnown;\n     private volatile Future<?> compilationTask;\n     /**\n@@ -152,11 +151,14 @@ public final RootNode getRootNode() {\n     }\n \n     public final OptimizedCompilationProfile getCompilationProfile() {\n-        if (!initialized) {\n+        OptimizedCompilationProfile profile = compilationProfile;\n+        if (profile != null) {\n+            return profile;\n+        } else {\n             CompilerDirectives.transferToInterpreterAndInvalidate();\n             initialize();\n+            return compilationProfile;\n         }\n-        return compilationProfile;\n     }\n \n     @Override\n@@ -231,34 +233,32 @@ private void notifyDeoptimized(VirtualFrame frame) {\n         runtime().getCompilationNotify().notifyCompilationDeoptimized(this, frame);\n     }\n \n+    private static GraalTruffleRuntime runtime() {\n+        return (GraalTruffleRuntime) Truffle.getRuntime();\n+    }\n+\n     private synchronized void initialize() {\n-        if (!initialized) {\n+        if (compilationProfile == null) {\n             if (sourceCallTarget == null && rootNode.isCloningAllowed()) {\n                 // We are the source CallTarget, so make a copy.\n                 this.uninitializedRootNode = cloneRootNode(rootNode);\n             }\n-            GraalTruffleRuntime runtime = runtime();\n-            if (TruffleCallTargetProfiling.getValue()) {\n-                this.compilationProfile = TraceCompilationProfile.create();\n-            } else {\n-                this.compilationProfile = OptimizedCompilationProfile.create();\n-            }\n-            runtime.getTvmci().onFirstExecution(this);\n-            initialized = true;\n+            runtime().getTvmci().onFirstExecution(this);\n+            this.compilationProfile = createCompilationProfile();\n         }\n     }\n \n-    private static GraalTruffleRuntime runtime() {\n-        return (GraalTruffleRuntime) Truffle.getRuntime();\n-    }\n-\n-    public static final void log(String message) {\n-        runtime().log(message);\n+    private static OptimizedCompilationProfile createCompilationProfile() {\n+        if (TruffleCallTargetProfiling.getValue()) {\n+            return TraceCompilationProfile.create();\n+        } else {\n+            return OptimizedCompilationProfile.create();\n+        }\n     }\n \n     public final void compile() {\n         if (!isCompiling()) {\n-            if (!initialized) {\n+            if (compilationProfile == null) {\n                 initialize();\n             }\n \n@@ -304,7 +304,7 @@ private static RootNode cloneRootNode(RootNode root) {\n \n     OptimizedCallTarget cloneUninitialized() {\n         assert sourceCallTarget == null;\n-        if (!initialized) {\n+        if (compilationProfile == null) {\n             initialize();\n         }\n         RootNode copiedRoot = cloneRootNode(uninitializedRootNode);\n@@ -366,6 +366,10 @@ private static void printException(Throwable e) {\n         log(string.toString());\n     }\n \n+    public static final void log(String message) {\n+        runtime().log(message);\n+    }\n+\n     final int getKnownCallSiteCount() {\n         return callSitesKnown;\n     }",
      "parent_sha": "d2955a25ece4c9799f468a9f210a189ffde473ea"
    }
  },
  {
    "oid": "f6a7f884ca79c3eee33c609c80e3bb97a1fb24da",
    "message": "fixed spelling",
    "date": "2014-02-06T17:41:16Z",
    "url": "https://github.com/oracle/graal/commit/f6a7f884ca79c3eee33c609c80e3bb97a1fb24da",
    "details": {
      "sha": "07706ece52c045c7f01d87873271f378a6d1f9b7",
      "filename": "graal/com.oracle.graal.api.meta/src/com/oracle/graal/api/meta/Kind.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/oracle/graal/blob/f6a7f884ca79c3eee33c609c80e3bb97a1fb24da/graal%2Fcom.oracle.graal.api.meta%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fapi%2Fmeta%2FKind.java",
      "raw_url": "https://github.com/oracle/graal/raw/f6a7f884ca79c3eee33c609c80e3bb97a1fb24da/graal%2Fcom.oracle.graal.api.meta%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fapi%2Fmeta%2FKind.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.api.meta%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fapi%2Fmeta%2FKind.java?ref=f6a7f884ca79c3eee33c609c80e3bb97a1fb24da",
      "patch": "@@ -72,12 +72,12 @@ public enum Kind implements PlatformKind {\n     private final Class primitiveJavaClass;\n     private final Class boxedJavaClass;\n \n-    private Kind(char typeChar, String javaName, boolean isStackInt, Class primitiveJavaClass, Class boxedJavasClass) {\n+    private Kind(char typeChar, String javaName, boolean isStackInt, Class primitiveJavaClass, Class boxedJavaClass) {\n         this.typeChar = typeChar;\n         this.javaName = javaName;\n         this.isStackInt = isStackInt;\n         this.primitiveJavaClass = primitiveJavaClass;\n-        this.boxedJavaClass = boxedJavasClass;\n+        this.boxedJavaClass = boxedJavaClass;\n         assert primitiveJavaClass == null || javaName.equals(primitiveJavaClass.getName());\n     }\n ",
      "parent_sha": "6f74548f1f82cc553ffa5dada5712598f8d78392"
    }
  },
  {
    "oid": "541b3b4819d1bd9d3a9ab1ad3b10f32566954bbf",
    "message": "Data layout retrieval fix in LLVMVaListNode",
    "date": "2021-11-04T09:22:02Z",
    "url": "https://github.com/oracle/graal/commit/541b3b4819d1bd9d3a9ab1ad3b10f32566954bbf",
    "details": {
      "sha": "18d633dc09d21c2edbde9a5faf9092659a79016f",
      "filename": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/nodes/intrinsics/llvm/va/LLVMVAListNode.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/oracle/graal/blob/541b3b4819d1bd9d3a9ab1ad3b10f32566954bbf/sulong%2Fprojects%2Fcom.oracle.truffle.llvm.runtime%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fruntime%2Fnodes%2Fintrinsics%2Fllvm%2Fva%2FLLVMVAListNode.java",
      "raw_url": "https://github.com/oracle/graal/raw/541b3b4819d1bd9d3a9ab1ad3b10f32566954bbf/sulong%2Fprojects%2Fcom.oracle.truffle.llvm.runtime%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fruntime%2Fnodes%2Fintrinsics%2Fllvm%2Fva%2FLLVMVAListNode.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/sulong%2Fprojects%2Fcom.oracle.truffle.llvm.runtime%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fruntime%2Fnodes%2Fintrinsics%2Fllvm%2Fva%2FLLVMVAListNode.java?ref=541b3b4819d1bd9d3a9ab1ad3b10f32566954bbf",
      "patch": "@@ -58,7 +58,7 @@ protected LLVMVAListNode() {\n     }\n \n     LLVMExpressionNode createAllocaNode() {\n-        DataLayout dataLayout = LLVMVaListStorage.findDataLayoutFromCurrentFrame();\n+        DataLayout dataLayout = getDataLayout();\n         LLVMLanguage language = LLVMLanguage.get(null);\n         PlatformCapability<?> capability = language.getCapability(PlatformCapability.class);\n         return language.getActiveConfiguration().createNodeFactory(language, dataLayout).createAlloca(capability.getVAListType(), capability.getVAListAlignment());",
      "parent_sha": "13fa1b165e1249bf022ff5bc54c9ef577f4c674f"
    }
  },
  {
    "oid": "fb87420e5c4c197863a8a6b0d7817c0d6312660b",
    "message": "Handle \\b and \\B in Python unicode regexps",
    "date": "2018-10-23T11:26:49Z",
    "url": "https://github.com/oracle/graal/commit/fb87420e5c4c197863a8a6b0d7817c0d6312660b",
    "details": {
      "sha": "2b5f81147ed45b455e276cd4fbc77eb7f5725c6c",
      "filename": "regex/src/com.oracle.truffle.regex/src/com/oracle/truffle/regex/tregex/parser/flavors/PythonFlavor.java",
      "status": "modified",
      "additions": 129,
      "deletions": 90,
      "changes": 219,
      "blob_url": "https://github.com/oracle/graal/blob/fb87420e5c4c197863a8a6b0d7817c0d6312660b/regex%2Fsrc%2Fcom.oracle.truffle.regex%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fregex%2Ftregex%2Fparser%2Fflavors%2FPythonFlavor.java",
      "raw_url": "https://github.com/oracle/graal/raw/fb87420e5c4c197863a8a6b0d7817c0d6312660b/regex%2Fsrc%2Fcom.oracle.truffle.regex%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fregex%2Ftregex%2Fparser%2Fflavors%2FPythonFlavor.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/regex%2Fsrc%2Fcom.oracle.truffle.regex%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fregex%2Ftregex%2Fparser%2Fflavors%2FPythonFlavor.java?ref=fb87420e5c4c197863a8a6b0d7817c0d6312660b",
      "patch": "@@ -51,11 +51,6 @@ private enum PythonREMode {\n     public static final PythonFlavor STR_INSTANCE = new PythonFlavor(PythonREMode.Str);\n     public static final PythonFlavor BYTES_INSTANCE = new PythonFlavor(PythonREMode.Bytes);\n \n-    public static final CompilationFinalBitSet SYNTAX_CHARACTERS =\n-            CompilationFinalBitSet.valueOf('^', '$', '\\\\', '.', '*', '+', '?', '(', ')', '[', ']', '{', '}', '|');\n-    public static final CompilationFinalBitSet CHAR_CLASS_SYNTAX_CHARACTERS =\n-            CompilationFinalBitSet.valueOf('\\\\', ']', '-');\n-\n     private final PythonREMode mode;\n \n     private PythonFlavor(PythonREMode mode) {\n@@ -69,6 +64,97 @@ public RegexFlavorProcessor forRegex(RegexSource source) {\n \n     private static final class PythonFlavorProcessor implements RegexFlavorProcessor {\n \n+        public static final CompilationFinalBitSet SYNTAX_CHARACTERS =\n+                CompilationFinalBitSet.valueOf('^', '$', '\\\\', '.', '*', '+', '?', '(', ')', '[', ']', '{', '}', '|');\n+        public static final CompilationFinalBitSet CHAR_CLASS_SYNTAX_CHARACTERS =\n+                CompilationFinalBitSet.valueOf('\\\\', ']', '-');\n+\n+        /**\n+         * Maps Python's predefined Unicode character classes (d, D, s, S, w, W) to equivalent\n+         * expressions in ECMAScript regular expressions. The results are not wrapped in brackets\n+         * and can therefore be directly pasted in to character classes (e.g. when translating\n+         * [\\s,.:]).\n+         *\n+         * This map is partial. If no replacement exists, a set from\n+         * {@link #UNICODE_CHAR_CLASS_SETS} has to be listed out explicitly instead.\n+         */\n+        public static final Map<Character, String> UNICODE_CHAR_CLASS_REPLACEMENTS;\n+        /**\n+         * Maps Python's predefined Unicode character classes to sets containing the characters\n+         * to be matched.\n+         */\n+        public static final Map<Character, CodePointSet> UNICODE_CHAR_CLASS_SETS;\n+\n+        static {\n+            UNICODE_CHAR_CLASS_REPLACEMENTS = new HashMap<>();\n+            UNICODE_CHAR_CLASS_SETS = new HashMap<>();\n+\n+            // Digits: \\\\d\n+            // Python accepts characters with the Numeric_Type=Decimal property.\n+            // As of Unicode 11.0.0, these happen to be exactly the characters\n+            // in the Decimal_Number General Category.\n+            UNICODE_CHAR_CLASS_REPLACEMENTS.put('d', \"\\\\p{General_Category=Decimal_Number}\");\n+\n+            // Non-digits: \\\\D\n+            UNICODE_CHAR_CLASS_REPLACEMENTS.put('D', \"\\\\P{General_Category=Decimal_Number}\");\n+\n+            // \\\\d and \\\\D as CodePointSets (currently not needed, included for consistency)\n+            CodePointSet decimals = UnicodeCharacterProperties.getProperty(\"General_Category=Decimal_Number\");\n+            CodePointSet nonDecimals = decimals.createInverse();\n+            UNICODE_CHAR_CLASS_SETS.put('d', decimals);\n+            UNICODE_CHAR_CLASS_SETS.put('D', nonDecimals);\n+\n+            // Spaces: \\\\s\n+            // Python accepts characters with either the Space_Separator General Category\n+            // or one of the WS, B or S Bidi_Classes. A close analogue available in\n+            // ECMAScript regular expressions is the White_Space Unicode property,\n+            // which is only missing the characters \\\\u001c-\\\\u001f (as of Unicode 11.0.0).\n+            UNICODE_CHAR_CLASS_REPLACEMENTS.put('s', \"\\\\p{White_Space}\\u001c-\\u001f\");\n+\n+            // Non-spaces: \\\\S\n+            // If we are translating an occurrence of \\\\S inside a character class, we cannot\n+            // use the negated Unicode character property \\\\P{White_Space}, because then we would\n+            // need to subtract the code points \\\\u001c-\\\\u001f from the resulting character class,\n+            // which is not possible in ECMAScript regular expressions. Therefore, we have to expand\n+            // the definition of the White_Space property, do the set subtraction and then list the\n+            // contents of the resulting set.\n+            CodePointSet unicodeSpaces = UnicodeCharacterProperties.getProperty(\"White_Space\");\n+            CodePointSet spaces = unicodeSpaces.addRange(new CodePointRange('\\u001c', '\\u001f'));\n+            CodePointSet nonSpaces = spaces.createInverse();\n+            UNICODE_CHAR_CLASS_SETS.put('s', spaces);\n+            UNICODE_CHAR_CLASS_SETS.put('S', nonSpaces);\n+\n+            // Word characters: \\\\w\n+            // As alphabetic characters, Python accepts those in the general category L.\n+            // As numeric, it takes any character with either Numeric_Type=Decimal,\n+            // Numeric_Type=Digit or Numeric_Type=Numeric. As of Unicode 11.0.0, this\n+            // corresponds to the general category Number, along with the following\n+            // code points:\n+            // F96B;CJK COMPATIBILITY IDEOGRAPH-F96B;Lo;0;L;53C3;;;3;N;;;;;\n+            // F973;CJK COMPATIBILITY IDEOGRAPH-F973;Lo;0;L;62FE;;;10;N;;;;;\n+            // F978;CJK COMPATIBILITY IDEOGRAPH-F978;Lo;0;L;5169;;;2;N;;;;;\n+            // F9B2;CJK COMPATIBILITY IDEOGRAPH-F9B2;Lo;0;L;96F6;;;0;N;;;;;\n+            // F9D1;CJK COMPATIBILITY IDEOGRAPH-F9D1;Lo;0;L;516D;;;6;N;;;;;\n+            // F9D3;CJK COMPATIBILITY IDEOGRAPH-F9D3;Lo;0;L;9678;;;6;N;;;;;\n+            // F9FD;CJK COMPATIBILITY IDEOGRAPH-F9FD;Lo;0;L;4EC0;;;10;N;;;;;\n+            // 2F890;CJK COMPATIBILITY IDEOGRAPH-2F890;Lo;0;L;5EFE;;;9;N;;;;;\n+            String alphaStr = \"\\\\p{General_Category=Letter}\";\n+            String numericStr = \"\\\\p{General_Category=Number}\\uf96b\\uf973\\uf978\\uf9b2\\uf9d1\\uf9d3\\uf9fd\\\\u{2f890}\";\n+            String wordCharsStr = alphaStr + numericStr + \"_\";\n+            UNICODE_CHAR_CLASS_REPLACEMENTS.put('w', wordCharsStr);\n+\n+            // Non-word characters: \\\\W\n+            // Similarly as for \\\\S, we will not be able to produce a replacement string for \\\\W.\n+            // We will need to construct the set ourselves.\n+            CodePointSet alpha = UnicodeCharacterProperties.getProperty(\"General_Category=Letter\");\n+            CodePointSet numericExtras = CodePointSet.create(0xf96b, 0xf973, 0xf978, 0xf9b2, 0xf9d1, 0xf9d3, 0xf9fd, 0x2f890);\n+            CodePointSet numeric = UnicodeCharacterProperties.getProperty(\"General_Category=Number\").addSet(numericExtras);\n+            CodePointSet wordChars = alpha.addSet(numeric).addRange(new CodePointRange('_'));\n+            CodePointSet nonWordChars = wordChars.createInverse();\n+            UNICODE_CHAR_CLASS_SETS.put('w', wordChars);\n+            UNICODE_CHAR_CLASS_SETS.put('W', nonWordChars);\n+        }\n+\n         private enum TermCategory {\n             Assertion,\n             Atom,\n@@ -302,15 +388,35 @@ private boolean assertionEscape() {\n                 case 'b':\n                     advance();\n                     if (getFlags().isUnicode()) {\n-                        // TODO: handle Python's unicode-aware \\b\n+                        // This is the snippet that we want to paste in, but with Python's\n+                        // definitions of \\\\w and \\\\W:\n+                        // \"(?:^|(?<=\\\\W))(?=\\\\w)|(?<=\\\\w)(?:(?=\\\\W)|$)\"\n+                        emitSnippet(\"(?:^|(?<=[\");\n+                        emitCharSetNoCasing(UNICODE_CHAR_CLASS_SETS.get('W'));\n+                        emitSnippet(\"]))(?=[\");\n+                        emitSnippet(UNICODE_CHAR_CLASS_REPLACEMENTS.get('w'));\n+                        emitSnippet(\"])|(?<=[\");\n+                        emitSnippet(UNICODE_CHAR_CLASS_REPLACEMENTS.get('w'));\n+                        emitSnippet(\"])(?:(?=[\");\n+                        emitCharSetNoCasing(UNICODE_CHAR_CLASS_SETS.get('W'));\n+                        emitSnippet(\"])|$)\");\n                     } else {\n                         emitSnippet(\"\\\\b\");\n                     }\n                     return true;\n                 case 'B':\n                     advance();\n                     if (getFlags().isUnicode()) {\n-                        // TODO: handle Python's unicode-aware \\B\n+                        // \"(?:^|(?<=\\\\W))(?:(?=\\\\W)|$)|(?<=\\\\w)(?=\\\\w)\"\n+                        emitSnippet(\"(?:^|(?<=[\");\n+                        emitCharSetNoCasing(UNICODE_CHAR_CLASS_SETS.get('W'));\n+                        emitSnippet(\"]))(?:(?=[\");\n+                        emitCharSetNoCasing(UNICODE_CHAR_CLASS_SETS.get('W'));\n+                        emitSnippet(\"])|$)|(?<=[\");\n+                        emitSnippet(UNICODE_CHAR_CLASS_REPLACEMENTS.get('w'));\n+                        emitSnippet(\"])(?=[\");\n+                        emitSnippet(UNICODE_CHAR_CLASS_REPLACEMENTS.get('w'));\n+                        emitSnippet(\"])\");\n                     } else {\n                         emitSnippet(\"\\\\B\");\n                     }\n@@ -383,100 +489,33 @@ private boolean categoryEscape(boolean inCharClass) {\n             // TODO: Check with asserts that these character classes are closed on case folding.\n             switch (curChar()) {\n                 case 'd':\n-                    advance();\n-                    if (getFlags().isUnicode()) {\n-                        // Python accepts characters with the Numeric_Type=Decimal property.\n-                        // As of Unicode 11.0.0, these happen to be exactly the characters\n-                        // in the Decimal_Number General Category.\n-                        String charSet = \"\\\\p{General_Category=Decimal_Number}\";\n-                        emitSnippet(inCharClass ? charSet : \"[\" + charSet + \"]\");\n-                    } else {\n-                        emitSnippet(\"\\\\d\");\n-                    }\n-                    return true;\n                 case 'D':\n-                    advance();\n-                    if (getFlags().isUnicode()) {\n-                        String charSet = \"\\\\P{General_Category=Decimal_Number}\";\n-                        emitSnippet(inCharClass ? charSet : \"[\" + charSet + \"]\");\n-                    } else {\n-                        emitSnippet(\"\\\\D\");\n-                    }\n-                    return true;\n                 case 's':\n-                    advance();\n-                    if (getFlags().isUnicode()) {\n-                        // Python accepts characters with either the Space_Separator General Category\n-                        // or one of the WS, B or S Bidi_Classes. A close analogue available in\n-                        // ECMAScript regular expressions is the White_Space Unicode property,\n-                        // which is only missing the characters \\x1c-\\x1f (as of Unicode 11.0.0).\n-                        String charSet = \"\\\\p{White_Space}\\\\x1c-\\\\x1f\";\n-                        emitSnippet(inCharClass ? charSet : \"[\" + charSet + \"]\");\n-                    } else {\n-                        emitSnippet(\"\\\\s\");\n-                    }\n-                    return true;\n                 case 'S':\n-                    advance();\n-                    if (getFlags().isUnicode()) {\n-                        if (inCharClass) {\n-                            // We are inside a character class and so we cannot add all the characters\n-                            // in \\P{White_Space} and then subtract \\x1c-\\x1f. Therefore, we will\n-                            // need to write out the definition of \\P{White_Space} explicitly.\n-                            CodePointSet unicodeSpaces = UnicodeCharacterProperties.getProperty(\"White_Space\");\n-                            CodePointSet pythonSpaces = unicodeSpaces.addRange(new CodePointRange('\\u001c', '\\u001f'));\n-                            CodePointSet complement = pythonSpaces.createInverse();\n-                            emitCharSetNoCasing(complement);\n-                        } else {\n-                            String charSet = \"\\\\p{White_Space}\\\\x1c-\\\\x1f\";\n-                            emitSnippet(\"[^\" + charSet + \"]\");\n-                        }\n-                    } else {\n-                        emitSnippet(\"\\\\S\");\n-                    }\n-                    return true;\n                 case 'w':\n-                    advance();\n-                    if (getFlags().isUnicode()) {\n-                        // As alphabetic characters, Python accepts those in the general category L.\n-                        // As numeric, it takes any character with either Numeric_Type=Decimal,\n-                        // Numeric_Type=Digit or Numeric_Type=Numeric. As of Unicode 11.0.0, this\n-                        // corresponds to the general category Number, along with the following\n-                        // code points:\n-                        // F96B;CJK COMPATIBILITY IDEOGRAPH-F96B;Lo;0;L;53C3;;;3;N;;;;;\n-                        // F973;CJK COMPATIBILITY IDEOGRAPH-F973;Lo;0;L;62FE;;;10;N;;;;;\n-                        // F978;CJK COMPATIBILITY IDEOGRAPH-F978;Lo;0;L;5169;;;2;N;;;;;\n-                        // F9B2;CJK COMPATIBILITY IDEOGRAPH-F9B2;Lo;0;L;96F6;;;0;N;;;;;\n-                        // F9D1;CJK COMPATIBILITY IDEOGRAPH-F9D1;Lo;0;L;516D;;;6;N;;;;;\n-                        // F9D3;CJK COMPATIBILITY IDEOGRAPH-F9D3;Lo;0;L;9678;;;6;N;;;;;\n-                        // F9FD;CJK COMPATIBILITY IDEOGRAPH-F9FD;Lo;0;L;4EC0;;;10;N;;;;;\n-                        // 2F890;CJK COMPATIBILITY IDEOGRAPH-2F890;Lo;0;L;5EFE;;;9;N;;;;;\n-                        String alpha = \"\\\\p{General_Category=Letter}\";\n-                        String numeric = \"\\\\p{General_Category=Number}\\\\uf96b\\\\uf973\\\\uf978\\\\uf9b2\\\\uf9d1\\\\uf9d3\\\\uf9fd\\\\u{2f890}\";\n-                        String charSet = alpha + numeric + \"_\";\n-                        emitSnippet(inCharClass ? charSet : \"[\" + charSet + \"]\");\n-                    } else {\n-                        emitSnippet(\"\\\\w\");\n-                    }\n-                    return true;\n                 case 'W':\n+                    char className = (char) curChar();\n                     advance();\n                     if (getFlags().isUnicode()) {\n                         if (inCharClass) {\n-                            CodePointSet alpha = UnicodeCharacterProperties.getProperty(\"General_Category=Letter\");\n-                            CodePointSet numericExtras = CodePointSet.create(0xf96b, 0xf973, 0xf978, 0xf9b2, 0xf9d1, 0xf9d3, 0xf9fd, 0x2f890);\n-                            CodePointSet numeric = UnicodeCharacterProperties.getProperty(\"General_Category=Number\").addSet(numericExtras);\n-                            CodePointSet pythonWordChars = alpha.addSet(numeric).addRange(new CodePointRange('_'));\n-                            CodePointSet complement = pythonWordChars.createInverse();\n-                            emitCharSetNoCasing(complement);\n+                            if (UNICODE_CHAR_CLASS_REPLACEMENTS.containsKey(className)) {\n+                                emitSnippet(UNICODE_CHAR_CLASS_REPLACEMENTS.get(className));\n+                            } else {\n+                                emitCharSetNoCasing(UNICODE_CHAR_CLASS_SETS.get(className));\n+                            }\n                         } else {\n-                            String alpha = \"\\\\p{General_Category=Letter}\";\n-                            String numeric = \"\\\\p{General_Category=Number}\\\\uf96b\\\\uf973\\\\uf978\\\\uf9b2\\\\uf9d1\\\\uf9d3\\\\uf9fd\\\\u{2f890}\";\n-                            String charSet = alpha + numeric + \"_\";\n-                            emitSnippet(\"[^\" + charSet + \"]\");\n+                            if (UNICODE_CHAR_CLASS_REPLACEMENTS.containsKey(className)) {\n+                                emitSnippet(\"[\" + UNICODE_CHAR_CLASS_REPLACEMENTS.get(className) + \"]\");\n+                            } else if (UNICODE_CHAR_CLASS_REPLACEMENTS.containsKey(Character.toLowerCase(className))) {\n+                                emitSnippet(\"[^\" + UNICODE_CHAR_CLASS_REPLACEMENTS.get(Character.toLowerCase(className)) + \"]\");\n+                            } else {\n+                                emitSnippet(\"[\");\n+                                emitCharSetNoCasing(UNICODE_CHAR_CLASS_SETS.get(className));\n+                                emitSnippet(\"]\");\n+                            }\n                         }\n                     } else {\n-                        emitSnippet(\"\\\\W\");\n+                        emitSnippet(\"\\\\\" + className);\n                     }\n                     return true;\n                 default:",
      "parent_sha": "bae004ac5d13716a4fe00a8ac48e9df7c5c0d44a"
    }
  },
  {
    "oid": "7311e18a6885c1d17fe0ecce4169c95473542981",
    "message": "Run PolyglotExceptionTest#testHostOOMResourceLimit in a subprocess.",
    "date": "2024-09-03T09:23:36Z",
    "url": "https://github.com/oracle/graal/commit/7311e18a6885c1d17fe0ecce4169c95473542981",
    "details": {
      "sha": "5622cfd8aefc4fc720744ed830a9052cddaed285",
      "filename": "truffle/src/com.oracle.truffle.api.test/src/com/oracle/truffle/api/test/polyglot/PolyglotExceptionTest.java",
      "status": "modified",
      "additions": 33,
      "deletions": 11,
      "changes": 44,
      "blob_url": "https://github.com/oracle/graal/blob/7311e18a6885c1d17fe0ecce4169c95473542981/truffle%2Fsrc%2Fcom.oracle.truffle.api.test%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Ftest%2Fpolyglot%2FPolyglotExceptionTest.java",
      "raw_url": "https://github.com/oracle/graal/raw/7311e18a6885c1d17fe0ecce4169c95473542981/truffle%2Fsrc%2Fcom.oracle.truffle.api.test%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Ftest%2Fpolyglot%2FPolyglotExceptionTest.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/truffle%2Fsrc%2Fcom.oracle.truffle.api.test%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Ftest%2Fpolyglot%2FPolyglotExceptionTest.java?ref=7311e18a6885c1d17fe0ecce4169c95473542981",
      "patch": "@@ -499,17 +499,39 @@ public void run() {\n     }\n \n     @Test\n-    public void testHostOOMResourceLimit() {\n-        try (Context c = Context.newBuilder().allowHostAccess(HostAccess.ALL).build()) {\n-            Value v = c.asValue(new ThrowOOM());\n-            assertFails(() -> v.execute(), PolyglotException.class, (e) -> {\n-                assertTrue(e.isResourceExhausted());\n-                assertFalse(e.isInternalError());\n-                assertFalse(e.isGuestException());\n-                assertTrue(e.isHostException());\n-                assertFalse(e.isCancelled());\n-                // no guarantees for stack frames.\n-            });\n+    public void testHostOOMResourceLimit() throws IOException, InterruptedException {\n+        Runnable test = () -> {\n+            try (Context c = Context.newBuilder().allowHostAccess(HostAccess.ALL).build()) {\n+                Value v = c.asValue(new ThrowOOM());\n+                assertFails(() -> v.execute(), PolyglotException.class, (e) -> {\n+                    assertTrue(e.isResourceExhausted());\n+                    assertFalse(e.isInternalError());\n+                    assertFalse(e.isGuestException());\n+                    assertTrue(e.isHostException());\n+                    assertFalse(e.isCancelled());\n+                    // no guarantees for stack frames.\n+                });\n+            }\n+        };\n+        if (ImageInfo.inImageCode()) {\n+            test.run();\n+        } else {\n+            List<String> vmOptions = new ArrayList<>();\n+            /*\n+             * Limits the maximum heap size to prevent hotspot crashes when the operating system is\n+             * unable to commit the reserved memory. This can happen when the physical memory is\n+             * unable to hold a large heap and the swap space is not configured or is too small.\n+             */\n+            vmOptions.add(\"-Xmx1G\");\n+            /*\n+             * The optimized HotSpot runtime is initialized lazily. We have to use synchronous\n+             * compilation to prevent OOM in the compiler thread.\n+             */\n+            if (TruffleTestAssumptions.isOptimizingRuntime()) {\n+                vmOptions.add(\"-Dpolyglot.engine.CompileImmediately=true\");\n+                vmOptions.add(\"-Dpolyglot.engine.BackgroundCompilation=false\");\n+            }\n+            SubprocessTestUtils.newBuilder(PolyglotExceptionTest.class, test).prefixVmOption(vmOptions.toArray(new String[0])).postfixVmOption(\"-Djdk.graal.CompilationFailureAction=Print\").run();\n         }\n     }\n ",
      "parent_sha": "fe84b5ff6a26b93ab28543a6bae1cffa66ea868f"
    }
  },
  {
    "oid": "a4510ce73bcd3f9850749ec72f69a021f8a067b7",
    "message": "Improve debug printing",
    "date": "2012-01-04T02:33:54Z",
    "url": "https://github.com/oracle/graal/commit/a4510ce73bcd3f9850749ec72f69a021f8a067b7",
    "details": {
      "sha": "3e7ff5a58778b6817740c91c91123c6fc223b6e9",
      "filename": "graal/com.oracle.max.cri/src/com/oracle/max/cri/ci/CiStackSlot.java",
      "status": "modified",
      "additions": 3,
      "deletions": 5,
      "changes": 8,
      "blob_url": "https://github.com/oracle/graal/blob/a4510ce73bcd3f9850749ec72f69a021f8a067b7/graal%2Fcom.oracle.max.cri%2Fsrc%2Fcom%2Foracle%2Fmax%2Fcri%2Fci%2FCiStackSlot.java",
      "raw_url": "https://github.com/oracle/graal/raw/a4510ce73bcd3f9850749ec72f69a021f8a067b7/graal%2Fcom.oracle.max.cri%2Fsrc%2Fcom%2Foracle%2Fmax%2Fcri%2Fci%2FCiStackSlot.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.max.cri%2Fsrc%2Fcom%2Foracle%2Fmax%2Fcri%2Fci%2FCiStackSlot.java?ref=a4510ce73bcd3f9850749ec72f69a021f8a067b7",
      "patch": "@@ -119,15 +119,13 @@ public boolean equals(Object o) {\n \n     @Override\n     public String toString() {\n-        String s;\n         if (!addFrameSize) {\n-            s = \"out:\";\n+            return \"out:\" + offset + kindSuffix();\n         } else if (offset >= 0) {\n-            s = \"in:\";\n+            return \"in:\" + offset + kindSuffix();\n         } else {\n-            s = \"spill:\";\n+            return \"spill:\" + (-offset) + kindSuffix();\n         }\n-        return s + offset + kindSuffix();\n     }\n \n     /**",
      "parent_sha": "a8019f8ed23298d949aaf1ac97aa34fe7bd010f5"
    }
  },
  {
    "oid": "55d046bc56c53f0e8d9a394718faa1f6e5125047",
    "message": "Make CompileTheWorldTest silent.",
    "date": "2019-10-30T10:25:39Z",
    "url": "https://github.com/oracle/graal/commit/55d046bc56c53f0e8d9a394718faa1f6e5125047",
    "details": {
      "sha": "961fc55bbb11ca175b983d82bc3aa2be22339fe5",
      "filename": "compiler/src/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/CompileTheWorldTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/oracle/graal/blob/55d046bc56c53f0e8d9a394718faa1f6e5125047/compiler%2Fsrc%2Forg.graalvm.compiler.hotspot.test%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Fhotspot%2Ftest%2FCompileTheWorldTest.java",
      "raw_url": "https://github.com/oracle/graal/raw/55d046bc56c53f0e8d9a394718faa1f6e5125047/compiler%2Fsrc%2Forg.graalvm.compiler.hotspot.test%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Fhotspot%2Ftest%2FCompileTheWorldTest.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/compiler%2Fsrc%2Forg.graalvm.compiler.hotspot.test%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Fhotspot%2Ftest%2FCompileTheWorldTest.java?ref=55d046bc56c53f0e8d9a394718faa1f6e5125047",
      "patch": "@@ -66,7 +66,7 @@ public void testJDK() throws Throwable {\n                         excludeMethodFilters,\n                         verbose,\n                         harnessOptions,\n-                        new OptionValues(initialOptions, HighTier.Options.Inline, false));\n+                        new OptionValues(initialOptions, HighTier.Options.Inline, false, CompilationFailureAction, ExceptionAction.Silent));\n         ctw.compile();\n         assert CompilationBailoutAsFailure.getValue(initialOptions) == originalBailoutAction;\n         assert CompilationFailureAction.getValue(initialOptions) == originalFailureAction;",
      "parent_sha": "fc957582989d6d6465e76fe3f77acacff46f312a"
    }
  },
  {
    "oid": "e4c991bf7f62050014d048320076234000517173",
    "message": "Recursive implementation of propagating polymorphic specialize.",
    "date": "2018-03-21T08:26:31Z",
    "url": "https://github.com/oracle/graal/commit/e4c991bf7f62050014d048320076234000517173",
    "details": {
      "sha": "9be1aa0fc1ad645671cf4aacf72f1617d26aec9d",
      "filename": "compiler/src/org.graalvm.compiler.truffle.runtime/src/org/graalvm/compiler/truffle/runtime/OptimizedCallTarget.java",
      "status": "modified",
      "additions": 9,
      "deletions": 12,
      "changes": 21,
      "blob_url": "https://github.com/oracle/graal/blob/e4c991bf7f62050014d048320076234000517173/compiler%2Fsrc%2Forg.graalvm.compiler.truffle.runtime%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Ftruffle%2Fruntime%2FOptimizedCallTarget.java",
      "raw_url": "https://github.com/oracle/graal/raw/e4c991bf7f62050014d048320076234000517173/compiler%2Fsrc%2Forg.graalvm.compiler.truffle.runtime%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Ftruffle%2Fruntime%2FOptimizedCallTarget.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/compiler%2Fsrc%2Forg.graalvm.compiler.truffle.runtime%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Ftruffle%2Fruntime%2FOptimizedCallTarget.java?ref=e4c991bf7f62050014d048320076234000517173",
      "patch": "@@ -679,44 +679,41 @@ boolean isProfilePolluted() {\n \n     void polymorphicSpecialize(Node source) {\n         if (TruffleCompilerOptions.getValue(TruffleUsePollutionBasedSplittingStrategy)) {\n-            List<Node> toDump = new ArrayList<>();\n+            List<Node> toDump = null;\n             if (TruffleCompilerOptions.getValue(TruffleDumpPolymorphicSpecialize)) {\n+                toDump = new ArrayList<>();\n                 pullOutParentChain(source, toDump);\n             }\n-            this.polluteProfile(0, new ArrayList<>(), toDump);\n+            this.polluteProfile(0, toDump);\n         }\n     }\n \n-    // TODO get rid of toPollute by using recursion\n     // TODO use pullOutParentChain ONLY to get the dump data and not to extract root\n     // TODO get rid of needsSplit in OptimizedDirectCallNode keep it only in the callTarget, profilePolluted goes away\n-    private void polluteProfile(int depth, List<RootCallTarget> toPollute, List<Node> toDump) {\n+    private boolean polluteProfile(int depth, List<Node> toDump) {\n         if (depth > TruffleCompilerOptions.getValue(TruffleSplittingMaxPollutionDepth) || profilePolluted || knownCallNodes.size() == 0 ||\n-                        compilationProfile.getInterpreterCallCount() == 1 || toPollute.containsAll(Arrays.asList(this, this))) {\n-            return;\n+                        compilationProfile.getInterpreterCallCount() == 1) {\n+            return false;\n         }\n         if (knownCallNodes.size() == 1) {\n-            toPollute.add(this);\n             final OptimizedDirectCallNode callNode = knownCallNodes.iterator().next();\n             final OptimizedCallTarget callTarget;\n             if (TruffleCompilerOptions.getValue(TruffleDumpPolymorphicSpecialize)) {\n                 callTarget = (OptimizedCallTarget) pullOutParentChain(callNode, toDump).getCallTarget();\n             } else {\n                 callTarget = (OptimizedCallTarget) callNode.getRootNode().getCallTarget();\n             }\n-            callTarget.polluteProfile(depth + 1, toPollute, toDump);\n+            profilePolluted = callTarget.polluteProfile(depth + 1, toDump);\n         } else {\n             for (OptimizedDirectCallNode node : knownCallNodes) {\n                 node.setNeedsSplit(true);\n             }\n-            profilePolluted = true;\n-            for (RootCallTarget target : toPollute) {\n-                ((OptimizedCallTarget) target).profilePolluted = true;\n-            }\n             if (TruffleCompilerOptions.getValue(TruffleDumpPolymorphicSpecialize)) {\n                 PolymorphicSpecializeDump.dumpPolymorphicSpecialize(toDump, knownCallNodes);\n             }\n+            profilePolluted = true;\n         }\n+        return profilePolluted;\n     }\n \n     private static RootNode pullOutParentChain(Node node, List<Node> toDump) {",
      "parent_sha": "b9b07aa2044e09c47794ee5bcea9565e29b4d54b"
    }
  },
  {
    "oid": "76646a80693ee1ef4aa1f2bb77eccb0f0d9857c7",
    "message": "[GR-9487] Change TypeDescriptor.ANY from INTERSECTION to UNION.",
    "date": "2018-04-26T05:07:31Z",
    "url": "https://github.com/oracle/graal/commit/76646a80693ee1ef4aa1f2bb77eccb0f0d9857c7",
    "details": {
      "sha": "e9333da9119c4fd3704ea64259605e16c6b0beb0",
      "filename": "sdk/src/org.graalvm.polyglot.tck/src/org/graalvm/polyglot/tck/TypeDescriptor.java",
      "status": "modified",
      "additions": 52,
      "deletions": 32,
      "changes": 84,
      "blob_url": "https://github.com/oracle/graal/blob/76646a80693ee1ef4aa1f2bb77eccb0f0d9857c7/sdk%2Fsrc%2Forg.graalvm.polyglot.tck%2Fsrc%2Forg%2Fgraalvm%2Fpolyglot%2Ftck%2FTypeDescriptor.java",
      "raw_url": "https://github.com/oracle/graal/raw/76646a80693ee1ef4aa1f2bb77eccb0f0d9857c7/sdk%2Fsrc%2Forg.graalvm.polyglot.tck%2Fsrc%2Forg%2Fgraalvm%2Fpolyglot%2Ftck%2FTypeDescriptor.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/sdk%2Fsrc%2Forg.graalvm.polyglot.tck%2Fsrc%2Forg%2Fgraalvm%2Fpolyglot%2Ftck%2FTypeDescriptor.java?ref=76646a80693ee1ef4aa1f2bb77eccb0f0d9857c7",
      "patch": "@@ -25,6 +25,7 @@\n package org.graalvm.polyglot.tck;\n \n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.HashSet;\n@@ -43,12 +44,7 @@\n  */\n public final class TypeDescriptor {\n \n-    /**\n-     * Represents all types. It's an intersection of no type.\n-     *\n-     * @since 0.30\n-     */\n-    public static final TypeDescriptor ANY = new TypeDescriptor(new IntersectionImpl(Collections.emptySet()));\n+    private static final TypeDescriptor NOTYPE = new TypeDescriptor(new IntersectionImpl(Collections.emptySet()));\n \n     /**\n      * The NULL type represents a type of null or undefined value.\n@@ -94,7 +90,7 @@ public final class TypeDescriptor {\n      * @see Value#hasMembers().\n      * @since 0.30\n      */\n-    public static final TypeDescriptor ARRAY = new TypeDescriptor(new ArrayImpl(ANY.impl));\n+    public static final TypeDescriptor ARRAY = new TypeDescriptor(new ArrayImpl(null));\n     /**\n      * Represents a host object.\n      *\n@@ -125,7 +121,7 @@ public final class TypeDescriptor {\n      * @see Value#canExecute().\n      * @since 0.30\n      */\n-    public static final TypeDescriptor EXECUTABLE = new TypeDescriptor(new ExecutableImpl(ExecutableImpl.Kind.BOTTOM, ANY.impl, true, Collections.emptyList()));\n+    public static final TypeDescriptor EXECUTABLE = new TypeDescriptor(new ExecutableImpl(ExecutableImpl.Kind.BOTTOM, null, true, Collections.emptyList()));\n \n     /**\n      * Represents a raw executable type. Any executable can be assigned into the raw executable\n@@ -143,10 +139,18 @@ public final class TypeDescriptor {\n      * @see TypeDescriptor#EXECUTABLE\n      * @since 1.0\n      */\n-    public static final TypeDescriptor EXECUTABLE_ANY = new TypeDescriptor(new ExecutableImpl(ExecutableImpl.Kind.TOP, ANY.impl, true, Collections.emptyList()));\n+    public static final TypeDescriptor EXECUTABLE_ANY = new TypeDescriptor(new ExecutableImpl(ExecutableImpl.Kind.TOP, null, true, Collections.emptyList()));\n+\n+    /**\n+     * Represents all types. It's an intersection of no type.\n+     *\n+     * @since 0.30\n+     */\n+    public static final TypeDescriptor ANY = new TypeDescriptor(new UnionImpl(new HashSet<>(Arrays.asList(\n+                    NOTYPE.impl, NULL.impl, BOOLEAN.impl, NUMBER.impl, STRING.impl, HOST_OBJECT.impl, NATIVE_POINTER.impl, OBJECT.impl, ARRAY.impl, EXECUTABLE_ANY.impl))));\n \n     private static final TypeDescriptor[] PREDEFINED_TYPES = new TypeDescriptor[]{\n-                    NULL, BOOLEAN, NUMBER, STRING, HOST_OBJECT, NATIVE_POINTER, OBJECT, ARRAY, EXECUTABLE, EXECUTABLE_ANY, ANY\n+                    NOTYPE, NULL, BOOLEAN, NUMBER, STRING, HOST_OBJECT, NATIVE_POINTER, OBJECT, ARRAY, EXECUTABLE, EXECUTABLE_ANY, ANY\n     };\n \n     private final TypeDescriptorImpl impl;\n@@ -286,23 +290,23 @@ private static TypeDescriptorImpl unionImpl(Collection<? extends TypeDescriptorI\n                 final Set<TypeDescriptorImpl> contentTypes = new HashSet<>();\n                 for (ArrayImpl array : arrays) {\n                     final TypeDescriptorImpl contentType = array.contentType;\n-                    if (contentType.isAssignable(contentType, ANY.impl)) {\n+                    if (contentType == null || isAny(contentType)) {\n                         seenWildCard = true;\n                         break;\n                     }\n                     contentTypes.add(contentType);\n                 }\n-                impls.add(seenWildCard ? ARRAY.impl : new ArrayImpl(unionImpl(contentTypes)));\n+                final TypeDescriptorImpl contentType = unionImpl(contentTypes);\n+                impls.add(seenWildCard ? ARRAY.impl : new ArrayImpl(isAny(contentType) ? null : contentType));\n         }\n         return impls.size() == 1 ? impls.iterator().next() : new UnionImpl(impls);\n     }\n \n     /**\n      * Creates a new intersection type. The intersection type is all of the given types. The\n      * intersection can be also used to create a no type. The no type is a type which has no other\n-     * specialized type. The no type can be assigned to {@link TypeDescriptor#ANY} and itself. Any\n-     * type can be assigned to no type. The no type is created as an empty intersection,\n-     * {@code TypeDescriptor.intersection()}.\n+     * specialized type. The no type can be assigned to {@link TypeDescriptor#ANY} and itself. The\n+     * no type is created as an empty intersection, {@code TypeDescriptor.intersection()}.\n      *\n      * @param types the types to include in the intersection\n      * @return the intersection type containing the given types\n@@ -314,7 +318,7 @@ public static TypeDescriptor intersection(TypeDescriptor... types) {\n         Collections.addAll(typesSet, types);\n         switch (typesSet.size()) {\n             case 0:\n-                return ANY;\n+                return NOTYPE;\n             case 1:\n                 return types[0];\n             default:\n@@ -420,6 +424,10 @@ private static void collectDNFComponents(\n         }\n     }\n \n+    private static boolean isAny(TypeDescriptorImpl type) {\n+        return type.isAssignable(type, ANY.impl);\n+    }\n+\n     /**\n      * Creates a new array type with given component type. To create a multi-dimensional array use\n      * an array type as a component type.\n@@ -430,7 +438,7 @@ private static void collectDNFComponents(\n      */\n     public static TypeDescriptor array(TypeDescriptor componentType) {\n         Objects.requireNonNull(componentType, \"Component type canot be null\");\n-        return componentType.isAssignable(ANY) ? ARRAY : new TypeDescriptor(new ArrayImpl(componentType.impl));\n+        return isAny(componentType.impl) ? ARRAY : new TypeDescriptor(new ArrayImpl(componentType.impl));\n     }\n \n     /**\n@@ -461,15 +469,15 @@ public static TypeDescriptor executable(TypeDescriptor returnType, TypeDescripto\n     public static TypeDescriptor executable(TypeDescriptor returnType, boolean vararg, TypeDescriptor... parameterTypes) {\n         Objects.requireNonNull(returnType, \"Return type cannot be null\");\n         Objects.requireNonNull(parameterTypes, \"Parameter types cannot be null\");\n-        if (returnType.isAssignable(ANY) && parameterTypes.length == 0) {\n+        if (isAny(returnType.impl) && parameterTypes.length == 0) {\n             return EXECUTABLE;\n         }\n         final List<TypeDescriptorImpl> paramTypeImpls = new ArrayList<>(parameterTypes.length);\n         for (TypeDescriptor td : parameterTypes) {\n             Objects.requireNonNull(td, \"Parameter types cannot contain null\");\n             paramTypeImpls.add(td.impl);\n         }\n-        return new TypeDescriptor(new ExecutableImpl(ExecutableImpl.Kind.UNIT, returnType.impl, vararg, paramTypeImpls));\n+        return new TypeDescriptor(new ExecutableImpl(ExecutableImpl.Kind.UNIT, isAny(returnType.impl) ? null : returnType.impl, vararg, paramTypeImpls));\n     }\n \n     /**\n@@ -506,7 +514,7 @@ public static TypeDescriptor forValue(final Value value) {\n             }\n             switch (contentTypes.size()) {\n                 case 0:\n-                    descs.add(intersection(NULL, BOOLEAN, NUMBER, STRING, HOST_OBJECT, NATIVE_POINTER, OBJECT, ARRAY, EXECUTABLE));\n+                    descs.add(intersection(NOTYPE, NULL, BOOLEAN, NUMBER, STRING, HOST_OBJECT, NATIVE_POINTER, OBJECT, ARRAY, EXECUTABLE));\n                     break;\n                 case 1:\n                     descs.add(array(contentTypes.iterator().next()));\n@@ -635,9 +643,8 @@ enum Kind {\n                         final boolean vararg,\n                         final List<? extends TypeDescriptorImpl> paramTypes) {\n             assert kind != null;\n-            assert retType != null;\n             assert paramTypes != null;\n-            assert kind == Kind.UNIT || (retType.equals(ANY.impl) && paramTypes.isEmpty());\n+            assert kind == Kind.UNIT || (retType == null && paramTypes.isEmpty());\n             this.kind = kind;\n             this.retType = retType;\n             this.vararg = vararg;\n@@ -660,7 +667,7 @@ boolean isAssignable(final TypeDescriptorImpl origType, final TypeDescriptorImpl\n                 if (byExec.kind == Kind.TOP) {\n                     return false;\n                 }\n-                if (!origExec.retType.isAssignable(origExec.retType, byExec.retType)) {\n+                if (!origExec.resolveRetType().isAssignable(origExec.resolveRetType(), byExec.resolveRetType())) {\n                     return false;\n                 }\n                 if (!byExec.paramTypes.isEmpty()) {\n@@ -689,7 +696,7 @@ public int hashCode() {\n             int res = 17;\n             res = res * 31 + (vararg ? 1 : 0);\n             res = res * 31 + kind.hashCode();\n-            res = res * 31 + retType.hashCode();\n+            res = res * 31 + (retType == null ? 0 : retType.hashCode());\n             for (TypeDescriptorImpl paramType : paramTypes) {\n                 res = res * 31 + paramType.hashCode();\n             }\n@@ -705,7 +712,7 @@ public boolean equals(final Object obj) {\n                 return false;\n             }\n             final ExecutableImpl other = (ExecutableImpl) obj;\n-            return vararg == other.vararg && kind == other.kind && retType.equals(other.retType) && paramTypes.equals(other.paramTypes);\n+            return vararg == other.vararg && kind == other.kind && Objects.equals(retType, other.retType) && paramTypes.equals(other.paramTypes);\n         }\n \n         @Override\n@@ -736,16 +743,19 @@ public String toString() {\n                 sb.append(\", *\");\n             }\n             sb.append(\"):\");\n-            sb.append(retType.isAssignable(retType, ANY.impl) ? \"<any>\" : retType);\n+            sb.append(retType == null ? \"<any>\" : retType);\n             return sb.toString();\n         }\n+\n+        private TypeDescriptorImpl resolveRetType() {\n+            return retType != null ? retType : ANY.impl;\n+        }\n     }\n \n     private static final class ArrayImpl extends TypeDescriptorImpl {\n         private final TypeDescriptorImpl contentType;\n \n         ArrayImpl(final TypeDescriptorImpl contentType) {\n-            assert contentType != null;\n             this.contentType = contentType;\n         }\n \n@@ -758,15 +768,15 @@ boolean isAssignable(final TypeDescriptorImpl origType, final TypeDescriptorImpl\n             } else if (otherClz == ArrayImpl.class) {\n                 final ArrayImpl origArray = (ArrayImpl) origType;\n                 final ArrayImpl byArray = (ArrayImpl) byType;\n-                return origArray.contentType.isAssignable(origArray.contentType, byArray.contentType);\n+                return origArray.resolveContentType().isAssignable(origArray.resolveContentType(), byArray.resolveContentType());\n             } else {\n                 return other.isAssignable(origType, byType);\n             }\n         }\n \n         @Override\n         public int hashCode() {\n-            return contentType.hashCode();\n+            return contentType != null ? contentType.hashCode() : 0;\n         }\n \n         @Override\n@@ -777,20 +787,24 @@ public boolean equals(Object obj) {\n             if (obj == null || obj.getClass() != ArrayImpl.class) {\n                 return false;\n             }\n-            return contentType.equals(((ArrayImpl) obj).contentType);\n+            return Objects.equals(contentType, ((ArrayImpl) obj).contentType);\n         }\n \n         @Override\n         public String toString() {\n             final StringBuilder sb = new StringBuilder(\"Array<\");\n-            if (contentType.isAssignable(contentType, ANY.impl)) {\n+            if (contentType == null) {\n                 sb.append(\"<any>\");\n             } else {\n                 sb.append(contentType.toString());\n             }\n             sb.append(\">\");\n             return sb.toString();\n         }\n+\n+        private TypeDescriptorImpl resolveContentType() {\n+            return contentType != null ? contentType : ANY.impl;\n+        }\n     }\n \n     private static final class IntersectionImpl extends TypeDescriptorImpl {\n@@ -813,6 +827,9 @@ boolean isAssignable(TypeDescriptorImpl origType, TypeDescriptorImpl byType) {\n                     }\n                     return false;\n                 } else {\n+                    if (types.isEmpty()) {\n+                        return false;\n+                    }\n                     for (TypeDescriptorImpl type : types) {\n                         if (!type.isAssignable(type, other)) {\n                             return false;\n@@ -823,6 +840,9 @@ boolean isAssignable(TypeDescriptorImpl origType, TypeDescriptorImpl byType) {\n             } else if (otherClz == IntersectionImpl.class) {\n                 final IntersectionImpl origIntersection = (IntersectionImpl) origType;\n                 final IntersectionImpl byIntersection = (IntersectionImpl) byType;\n+                if (origIntersection.types.isEmpty()) {\n+                    return byIntersection.types.isEmpty();\n+                }\n                 for (TypeDescriptorImpl subType : origIntersection.types) {\n                     if (byIntersection.types.contains(subType)) {\n                         continue;\n@@ -880,7 +900,7 @@ public boolean equals(Object obj) {\n \n         @Override\n         public String toString() {\n-            return types.isEmpty() ? \"<any>\" : types.stream().map(Object::toString).collect(Collectors.joining(\" & \", \"[\", \"]\"));\n+            return types.isEmpty() ? \"<none>\" : types.stream().map(Object::toString).collect(Collectors.joining(\" & \", \"[\", \"]\"));\n         }\n     }\n ",
      "parent_sha": "0ddd65fdbfd5498e3dcc5552d0142161d7ff76af"
    }
  },
  {
    "oid": "8e8672279def61409fe465c9dc89140dfee5471c",
    "message": "Make sourceCacheComputer final static.",
    "date": "2018-07-10T09:56:22Z",
    "url": "https://github.com/oracle/graal/commit/8e8672279def61409fe465c9dc89140dfee5471c",
    "details": {
      "sha": "f4aeb9e0bc22399fe0d612083ee4a35aeb550b4e",
      "filename": "truffle/src/com.oracle.truffle.api.vm/src/com/oracle/truffle/api/vm/PolyglotLanguageInstance.java",
      "status": "modified",
      "additions": 5,
      "deletions": 7,
      "changes": 12,
      "blob_url": "https://github.com/oracle/graal/blob/8e8672279def61409fe465c9dc89140dfee5471c/truffle%2Fsrc%2Fcom.oracle.truffle.api.vm%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Fvm%2FPolyglotLanguageInstance.java",
      "raw_url": "https://github.com/oracle/graal/raw/8e8672279def61409fe465c9dc89140dfee5471c/truffle%2Fsrc%2Fcom.oracle.truffle.api.vm%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Fvm%2FPolyglotLanguageInstance.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/truffle%2Fsrc%2Fcom.oracle.truffle.api.vm%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Fvm%2FPolyglotLanguageInstance.java?ref=8e8672279def61409fe465c9dc89140dfee5471c",
      "patch": "@@ -41,7 +41,11 @@ final class PolyglotLanguageInstance {\n \n     private final PolyglotSourceCache sourceCache;\n     private final Map<Object, PolyglotSourceCache> sourceCaches;\n-    private final Function<Object, PolyglotSourceCache> sourceCacheCompute;\n+    private static final Function<Object, PolyglotSourceCache> sourceCacheCompute = new Function<Object, PolyglotSourceCache>() {\n+        public PolyglotSourceCache apply(Object t) {\n+            return new PolyglotSourceCache();\n+        }\n+    };\n \n     PolyglotLanguageInstance(PolyglotLanguage language, boolean singleContext) {\n         this.singleContext = singleContext;\n@@ -59,15 +63,9 @@ final class PolyglotLanguageInstance {\n         if (singleContext) {\n             this.sourceCache = new PolyglotSourceCache();\n             this.sourceCaches = null;\n-            this.sourceCacheCompute = null;\n         } else {\n             this.sourceCache = null;\n             this.sourceCaches = new ConcurrentHashMap<>();\n-            this.sourceCacheCompute = new Function<Object, PolyglotSourceCache>() {\n-                public PolyglotSourceCache apply(Object t) {\n-                    return new PolyglotSourceCache();\n-                }\n-            };\n         }\n     }\n ",
      "parent_sha": "9a4726970e6170bacb0ec40ed75206f495bb7429"
    }
  },
  {
    "oid": "ee19c7178f72099dfd9ec3fc7d205152cb441811",
    "message": "FrameMappingToolImpl: type switch for call to transform().",
    "date": "2014-11-17T18:27:32Z",
    "url": "https://github.com/oracle/graal/commit/ee19c7178f72099dfd9ec3fc7d205152cb441811",
    "details": {
      "sha": "77c4b426c110289c2320999ebafe3b63d934aab3",
      "filename": "graal/com.oracle.graal.lir/src/com/oracle/graal/lir/framemap/FrameMappingToolImpl.java",
      "status": "modified",
      "additions": 19,
      "deletions": 1,
      "changes": 20,
      "blob_url": "https://github.com/oracle/graal/blob/ee19c7178f72099dfd9ec3fc7d205152cb441811/graal%2Fcom.oracle.graal.lir%2Fsrc%2Fcom%2Foracle%2Fgraal%2Flir%2Fframemap%2FFrameMappingToolImpl.java",
      "raw_url": "https://github.com/oracle/graal/raw/ee19c7178f72099dfd9ec3fc7d205152cb441811/graal%2Fcom.oracle.graal.lir%2Fsrc%2Fcom%2Foracle%2Fgraal%2Flir%2Fframemap%2FFrameMappingToolImpl.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.lir%2Fsrc%2Fcom%2Foracle%2Fgraal%2Flir%2Fframemap%2FFrameMappingToolImpl.java?ref=ee19c7178f72099dfd9ec3fc7d205152cb441811",
      "patch": "@@ -25,7 +25,10 @@\n import java.util.*;\n \n import com.oracle.graal.api.code.*;\n+import com.oracle.graal.compiler.common.*;\n+import com.oracle.graal.lir.framemap.DelayedFrameMapBuilder.SimpleVirtualStackSlot;\n import com.oracle.graal.lir.framemap.DelayedFrameMapBuilder.TrackedVirtualStackSlot;\n+import com.oracle.graal.lir.framemap.DelayedFrameMapBuilder.VirtualStackSlotRange;\n \n public class FrameMappingToolImpl implements FrameMappingTool {\n \n@@ -43,8 +46,23 @@ public StackSlot getStackSlot(VirtualStackSlot slot) {\n \n     public void mapStackSlots() {\n         for (TrackedVirtualStackSlot virtualSlot : builder.getStackSlots()) {\n-            StackSlot slot = virtualSlot.transform();\n+            final StackSlot slot;\n+            if (virtualSlot instanceof SimpleVirtualStackSlot) {\n+                slot = mapSimpleVirtualStackSlot((SimpleVirtualStackSlot) virtualSlot);\n+            } else if (virtualSlot instanceof VirtualStackSlotRange) {\n+                slot = mapVirtualStackSlotRange((VirtualStackSlotRange) virtualSlot);\n+            } else {\n+                throw GraalInternalError.shouldNotReachHere(\"Unknown VirtualStackSlot: \" + virtualSlot);\n+            }\n             mapping.put(virtualSlot, slot);\n         }\n     }\n+\n+    protected StackSlot mapSimpleVirtualStackSlot(SimpleVirtualStackSlot virtualStackSlot) {\n+        return virtualStackSlot.transform();\n+    }\n+\n+    protected StackSlot mapVirtualStackSlotRange(VirtualStackSlotRange virtualStackSlot) {\n+        return virtualStackSlot.transform();\n+    }\n }",
      "parent_sha": "db0df53148b8346152dbbe69e8abad82ec2bee32"
    }
  },
  {
    "oid": "5cc82638040c845be0ecaf9819f85d045d735c5c",
    "message": "Fix NPE when debugging continuations.",
    "date": "2024-06-27T11:11:04Z",
    "url": "https://github.com/oracle/graal/commit/5cc82638040c845be0ecaf9819f85d045d735c5c",
    "details": {
      "sha": "af42ec59f893d10e7c3adf5de14d313e4eed3b62",
      "filename": "espresso/src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/nodes/BytecodeNode.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/oracle/graal/blob/5cc82638040c845be0ecaf9819f85d045d735c5c/espresso%2Fsrc%2Fcom.oracle.truffle.espresso%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fespresso%2Fnodes%2FBytecodeNode.java",
      "raw_url": "https://github.com/oracle/graal/raw/5cc82638040c845be0ecaf9819f85d045d735c5c/espresso%2Fsrc%2Fcom.oracle.truffle.espresso%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fespresso%2Fnodes%2FBytecodeNode.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/espresso%2Fsrc%2Fcom.oracle.truffle.espresso%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fespresso%2Fnodes%2FBytecodeNode.java?ref=5cc82638040c845be0ecaf9819f85d045d735c5c",
      "patch": "@@ -568,7 +568,7 @@ public void createContinuableNode(int bci, int top) {\n                 return;\n             } else {\n                 InstrumentationSupport instrument = instrumentation;\n-                int statementIndex = instrument == null ? 0 : instrument.hookBCIToNodeIndex.lookup(0, 0, bs.endBCI());\n+                int statementIndex = instrument == null ? 0 : instrument.getStatementIndexAfterJump(0, 0, bs.endBCI());\n                 quickenInvoke(top, bci, opcode, statementIndex);\n                 // continue loop, will execute at most once more.\n             }",
      "parent_sha": "3f99990576b81d65353d6a2916e4cdfc12b85bf9"
    }
  },
  {
    "oid": "7e4db7c3441d87974ef1a25a0c3b5010978bf5bf",
    "message": "TraceRA: hinting: propagate outgoing stack slots correctly.",
    "date": "2015-11-17T18:02:13Z",
    "url": "https://github.com/oracle/graal/commit/7e4db7c3441d87974ef1a25a0c3b5010978bf5bf",
    "details": {
      "sha": "1a9aab545116d58baa5404422c20da6f3fb5fe6b",
      "filename": "graal/com.oracle.graal.lir/src/com/oracle/graal/lir/alloc/trace/TraceLinearScanLifetimeAnalysisPhase.java",
      "status": "modified",
      "additions": 32,
      "deletions": 14,
      "changes": 46,
      "blob_url": "https://github.com/oracle/graal/blob/7e4db7c3441d87974ef1a25a0c3b5010978bf5bf/graal%2Fcom.oracle.graal.lir%2Fsrc%2Fcom%2Foracle%2Fgraal%2Flir%2Falloc%2Ftrace%2FTraceLinearScanLifetimeAnalysisPhase.java",
      "raw_url": "https://github.com/oracle/graal/raw/7e4db7c3441d87974ef1a25a0c3b5010978bf5bf/graal%2Fcom.oracle.graal.lir%2Fsrc%2Fcom%2Foracle%2Fgraal%2Flir%2Falloc%2Ftrace%2FTraceLinearScanLifetimeAnalysisPhase.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.lir%2Fsrc%2Fcom%2Foracle%2Fgraal%2Flir%2Falloc%2Ftrace%2FTraceLinearScanLifetimeAnalysisPhase.java?ref=7e4db7c3441d87974ef1a25a0c3b5010978bf5bf",
      "patch": "@@ -23,13 +23,15 @@\n package com.oracle.graal.lir.alloc.trace;\n \n import static com.oracle.graal.lir.LIRValueUtil.asVariable;\n+import static com.oracle.graal.lir.LIRValueUtil.isStackSlotValue;\n import static com.oracle.graal.lir.LIRValueUtil.isVariable;\n import static com.oracle.graal.lir.alloc.trace.TraceLinearScan.isVariableOrRegister;\n import static com.oracle.graal.lir.alloc.trace.TraceRegisterAllocationPhase.Options.TraceRAshareSpillInformation;\n import static com.oracle.graal.lir.alloc.trace.TraceRegisterAllocationPhase.Options.TraceRAuseInterTraceHints;\n+import static com.oracle.graal.lir.alloc.trace.TraceUtil.asShadowedRegisterValue;\n+import static com.oracle.graal.lir.alloc.trace.TraceUtil.isShadowedRegisterValue;\n import static jdk.vm.ci.code.ValueUtil.asRegisterValue;\n import static jdk.vm.ci.code.ValueUtil.asStackSlot;\n-import static jdk.vm.ci.code.ValueUtil.isIllegal;\n import static jdk.vm.ci.code.ValueUtil.isRegister;\n import static jdk.vm.ci.code.ValueUtil.isStackSlot;\n \n@@ -41,6 +43,7 @@\n import jdk.vm.ci.code.Register;\n import jdk.vm.ci.code.RegisterValue;\n import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.common.JVMCIError;\n import jdk.vm.ci.meta.AllocatableValue;\n import jdk.vm.ci.meta.JavaConstant;\n import jdk.vm.ci.meta.LIRKind;\n@@ -57,6 +60,7 @@\n import com.oracle.graal.lir.LIRInstruction;\n import com.oracle.graal.lir.LIRInstruction.OperandFlag;\n import com.oracle.graal.lir.LIRInstruction.OperandMode;\n+import com.oracle.graal.lir.LIRValueUtil;\n import com.oracle.graal.lir.StandardOp.BlockEndOp;\n import com.oracle.graal.lir.StandardOp.LabelOp;\n import com.oracle.graal.lir.StandardOp.LoadConstantOp;\n@@ -584,21 +588,12 @@ private void addInterTraceHints() {\n                         BlockEndOp outgoing = SSIUtil.outgoing(lir, pred);\n                         for (int i = 0; i < outgoing.getOutgoingSize(); i++) {\n                             Value toValue = label.getIncomingValue(i);\n-                            if (!isIllegal(toValue) && !isRegister(toValue)) {\n+                            assert !isShadowedRegisterValue(toValue) : \"Shadowed Registers are not allowed here: \" + toValue;\n+                            if (isVariable(toValue)) {\n                                 Value fromValue = outgoing.getOutgoingValue(i);\n                                 assert sameTrace(block, pred) || !isVariable(fromValue) : \"Unallocated variable: \" + fromValue;\n-\n-                                if (isVariableOrRegister(fromValue)) {\n-                                    IntervalHint from = getIntervalHint((AllocatableValue) fromValue);\n-                                    TraceInterval to = allocator.getOrCreateInterval((AllocatableValue) toValue);\n-                                    setHint(label, to, from);\n-                                } else if (TraceRAshareSpillInformation.getValue() && TraceUtil.isShadowedRegisterValue(fromValue)) {\n-                                    ShadowedRegisterValue shadowedRegisterValue = TraceUtil.asShadowedRegisterValue(fromValue);\n-                                    IntervalHint from = getIntervalHint(shadowedRegisterValue.getRegister());\n-                                    TraceInterval to = allocator.getOrCreateInterval((AllocatableValue) toValue);\n-                                    setHint(label, to, from);\n-                                    to.setSpillSlot(shadowedRegisterValue.getStackSlot());\n-                                    to.setSpillState(SpillState.StartInMemory);\n+                                if (!LIRValueUtil.isConstantValue(fromValue)) {\n+                                    addInterTraceHint(label, (AllocatableValue) toValue, fromValue);\n                                 }\n                             }\n                         }\n@@ -607,6 +602,29 @@ private void addInterTraceHints() {\n             }\n         }\n \n+        private void addInterTraceHint(LabelOp label, AllocatableValue toValue, Value fromValue) {\n+            assert isVariable(toValue) : \"Wrong toValue: \" + toValue;\n+            assert isRegister(fromValue) || isVariable(fromValue) || isStackSlotValue(fromValue) || isShadowedRegisterValue(fromValue) : \"Wrong fromValue: \" + fromValue;\n+            if (isVariableOrRegister(fromValue)) {\n+                TraceInterval to = allocator.getOrCreateInterval(toValue);\n+                IntervalHint from = getIntervalHint((AllocatableValue) fromValue);\n+                setHint(label, to, from);\n+            } else if (isStackSlotValue(fromValue)) {\n+                TraceInterval to = allocator.getOrCreateInterval(toValue);\n+                to.setSpillSlot((AllocatableValue) fromValue);\n+                to.setSpillState(SpillState.StartInMemory);\n+            } else if (TraceRAshareSpillInformation.getValue() && isShadowedRegisterValue(fromValue)) {\n+                ShadowedRegisterValue shadowedRegisterValue = asShadowedRegisterValue(fromValue);\n+                IntervalHint from = getIntervalHint(shadowedRegisterValue.getRegister());\n+                TraceInterval to = allocator.getOrCreateInterval(toValue);\n+                setHint(label, to, from);\n+                to.setSpillSlot(shadowedRegisterValue.getStackSlot());\n+                to.setSpillState(SpillState.StartInMemory);\n+            } else {\n+                throw JVMCIError.shouldNotReachHere();\n+            }\n+        }\n+\n         /**\n          * Returns a value for a interval definition, which can be used for re-materialization.\n          *",
      "parent_sha": "171c3572b210e1aee7e1d4afb9140b4c2df357e2"
    }
  },
  {
    "oid": "626be6543e63ad7e0f6107e4024c2df4c36ab174",
    "message": "Sulong: Cleanup sigprocmask syscall implementation\n\nAnd additionally support set being a pointer and oldset being a long.",
    "date": "2021-04-20T08:36:20Z",
    "url": "https://github.com/oracle/graal/commit/626be6543e63ad7e0f6107e4024c2df4c36ab174",
    "details": {
      "sha": "66a4bba3e4e3de3f2b7fe57d2bb6ebcd613646c8",
      "filename": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/nodes/asm/syscall/LLVMAMD64SyscallRtSigprocmaskNode.java",
      "status": "modified",
      "additions": 3,
      "deletions": 9,
      "changes": 12,
      "blob_url": "https://github.com/oracle/graal/blob/626be6543e63ad7e0f6107e4024c2df4c36ab174/sulong%2Fprojects%2Fcom.oracle.truffle.llvm.runtime%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fruntime%2Fnodes%2Fasm%2Fsyscall%2FLLVMAMD64SyscallRtSigprocmaskNode.java",
      "raw_url": "https://github.com/oracle/graal/raw/626be6543e63ad7e0f6107e4024c2df4c36ab174/sulong%2Fprojects%2Fcom.oracle.truffle.llvm.runtime%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fruntime%2Fnodes%2Fasm%2Fsyscall%2FLLVMAMD64SyscallRtSigprocmaskNode.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/sulong%2Fprojects%2Fcom.oracle.truffle.llvm.runtime%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fruntime%2Fnodes%2Fasm%2Fsyscall%2FLLVMAMD64SyscallRtSigprocmaskNode.java?ref=626be6543e63ad7e0f6107e4024c2df4c36ab174",
      "patch": "@@ -31,30 +31,24 @@\n \n import com.oracle.truffle.api.dsl.Specialization;\n import com.oracle.truffle.llvm.runtime.memory.LLVMSyscallOperationNode;\n-import com.oracle.truffle.llvm.runtime.pointer.LLVMNativePointer;\n import com.oracle.truffle.llvm.runtime.pointer.LLVMPointer;\n \n public abstract class LLVMAMD64SyscallRtSigprocmaskNode extends LLVMSyscallOperationNode {\n \n     /**\n      * @param how\n-     * @param set\n-     * @param oldset\n+     * @param set Can be {@code long} or {@link LLVMPointer}.\n+     * @param oldset Can be {@code long} or {@link LLVMPointer}.\n      * @param sigsetsize\n      * @see #executeGeneric(Object, Object, Object, Object, Object, Object)\n      */\n     @Specialization\n-    protected long doI64(long how, LLVMPointer set, LLVMPointer oldset, long sigsetsize) {\n+    protected long doIt(long how, Object set, Object oldset, long sigsetsize) {\n         return -LLVMAMD64Error.ENOSYS;\n     }\n \n     @Override\n     public final String getName() {\n         return \"rt_sigprocmask\";\n     }\n-\n-    @Specialization\n-    protected long doI64(long how, long set, long oldset, long sigsetsize) {\n-        return doI64(how, LLVMNativePointer.create(set), LLVMNativePointer.create(oldset), sigsetsize);\n-    }\n }",
      "parent_sha": "26020916891d5590dd9710b602ce5c723b1c3cce"
    }
  },
  {
    "oid": "6d50af95cb1120c92a048b6af033a0fce5a60ff8",
    "message": "adapt to org.graalvm.compiler rename in graal-core",
    "date": "2016-12-06T20:21:04Z",
    "url": "https://github.com/oracle/graal/commit/6d50af95cb1120c92a048b6af033a0fce5a60ff8",
    "details": {
      "sha": "11d42f1c4d71474d1e541d134977eb1ced72a6da",
      "filename": "truffle/com.oracle.truffle.api/src/com/oracle/truffle/api/impl/TVMCI.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/oracle/graal/blob/6d50af95cb1120c92a048b6af033a0fce5a60ff8/truffle%2Fcom.oracle.truffle.api%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Fimpl%2FTVMCI.java",
      "raw_url": "https://github.com/oracle/graal/raw/6d50af95cb1120c92a048b6af033a0fce5a60ff8/truffle%2Fcom.oracle.truffle.api%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Fimpl%2FTVMCI.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/truffle%2Fcom.oracle.truffle.api%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Fimpl%2FTVMCI.java?ref=6d50af95cb1120c92a048b6af033a0fce5a60ff8",
      "patch": "@@ -43,8 +43,10 @@ public abstract class TVMCI {\n      * @since 0.12\n      */\n     protected TVMCI() {\n-        // export only for com.oracle.graal.truffle and com.oracle.truffle.api.impl\n-        assert getClass().getPackage().getName().equals(\"com.oracle.graal.truffle\") || getClass().getPackage().getName().equals(\"com.oracle.truffle.api.impl\");\n+        // export only for select packages\n+        assert getClass().getPackage().getName().equals(\"org.graalvm.compiler.truffle\") ||\n+                        getClass().getPackage().getName().equals(\"com.oracle.graal.truffle\") ||\n+                        getClass().getPackage().getName().equals(\"com.oracle.truffle.api.impl\");\n     }\n \n     /**",
      "parent_sha": "9df13defd34241a0bee2769b5b64c62611c3c042"
    }
  },
  {
    "oid": "16c7796924987b325693da21102c4425c099d27f",
    "message": "[GR-20605] Ensure that br and br.table behave like stack-polymorphic\ninstructions when in block-end positions.",
    "date": "2020-01-14T17:07:16Z",
    "url": "https://github.com/oracle/graal/commit/16c7796924987b325693da21102c4425c099d27f",
    "details": {
      "sha": "0f6e46130863a66441975c364109a985d58d6fad",
      "filename": "wasm/src/org.graalvm.wasm/src/org/graalvm/wasm/BinaryParser.java",
      "status": "modified",
      "additions": 19,
      "deletions": 2,
      "changes": 21,
      "blob_url": "https://github.com/oracle/graal/blob/16c7796924987b325693da21102c4425c099d27f/wasm%2Fsrc%2Forg.graalvm.wasm%2Fsrc%2Forg%2Fgraalvm%2Fwasm%2FBinaryParser.java",
      "raw_url": "https://github.com/oracle/graal/raw/16c7796924987b325693da21102c4425c099d27f/wasm%2Fsrc%2Forg.graalvm.wasm%2Fsrc%2Forg%2Fgraalvm%2Fwasm%2FBinaryParser.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/wasm%2Fsrc%2Forg.graalvm.wasm%2Fsrc%2Forg%2Fgraalvm%2Fwasm%2FBinaryParser.java?ref=16c7796924987b325693da21102c4425c099d27f",
      "patch": "@@ -494,8 +494,16 @@ private WasmBlockNode readBlockBody(WasmContext context, WasmCodeEntry codeEntry\n                     int unwindLevel = readLabelIndex(bytesConsumed);\n                     state.useLongConstant(unwindLevel);\n                     state.useByteConstant(bytesConsumed[0]);\n-                    state.useIntConstant(state.getStackState(unwindLevel));\n-                    state.useIntConstant(state.getContinuationReturnLength(unwindLevel));\n+                    final int targetStackSize = state.getStackState(unwindLevel);\n+                    state.useIntConstant(targetStackSize);\n+                    final int continuationReturnLength = state.getContinuationReturnLength(unwindLevel);\n+                    state.useIntConstant(continuationReturnLength);\n+                    // This instruction is stack-polymorphic.\n+                    if ((peek1() & 0xFF) == Instructions.END) {\n+                        while (state.stackSize() > targetStackSize + continuationReturnLength) {\n+                            state.pop();\n+                        }\n+                    }\n                     break;\n                 }\n                 case Instructions.BR_IF: {\n@@ -544,11 +552,20 @@ private WasmBlockNode readBlockBody(WasmContext context, WasmCodeEntry codeEntry\n                     branchTable[0] = returnLength;\n                     // The offset to the branch table.\n                     state.saveBranchTable(branchTable);\n+                    // This instruction is stack-polymorphic.\n+                    if ((peek1() & 0xFF) == Instructions.END) {\n+                        final int targetStackSize = state.getStackState(0);\n+                        final int continuationReturnLength = state.getContinuationReturnLength(0);\n+                        while (state.stackSize() > targetStackSize + continuationReturnLength) {\n+                            state.pop();\n+                        }\n+                    }\n                     break;\n                 }\n                 case Instructions.RETURN: {\n                     state.useLongConstant(state.stackStateCount());\n                     state.useIntConstant(state.getRootBlockReturnLength());\n+                    // TODO: Pop values from the stack if necessary.\n                     break;\n                 }\n                 case Instructions.CALL: {",
      "parent_sha": "d863d0b7718ace5dbdc4399bfdfb12340aca3356"
    }
  },
  {
    "oid": "fdb68e86bf1db8223fea262b5f82376d6383569a",
    "message": "minor cleanup",
    "date": "2023-11-08T18:03:27Z",
    "url": "https://github.com/oracle/graal/commit/fdb68e86bf1db8223fea262b5f82376d6383569a",
    "details": {
      "sha": "e64874b1962eb04eb00bb8965a7b9b1a91e4bb96",
      "filename": "substratevm/src/com.oracle.svm.test/src/com/oracle/svm/test/jfr/TestMirrorEvents.java",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/oracle/graal/blob/fdb68e86bf1db8223fea262b5f82376d6383569a/substratevm%2Fsrc%2Fcom.oracle.svm.test%2Fsrc%2Fcom%2Foracle%2Fsvm%2Ftest%2Fjfr%2FTestMirrorEvents.java",
      "raw_url": "https://github.com/oracle/graal/raw/fdb68e86bf1db8223fea262b5f82376d6383569a/substratevm%2Fsrc%2Fcom.oracle.svm.test%2Fsrc%2Fcom%2Foracle%2Fsvm%2Ftest%2Fjfr%2FTestMirrorEvents.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm%2Fsrc%2Fcom.oracle.svm.test%2Fsrc%2Fcom%2Foracle%2Fsvm%2Ftest%2Fjfr%2FTestMirrorEvents.java?ref=fdb68e86bf1db8223fea262b5f82376d6383569a",
      "patch": "@@ -50,7 +50,7 @@ public class TestMirrorEvents extends JfrRecordingTest {\n     public void test() throws Throwable {\n         Recording recording = new Recording();\n \n-        // Disable all events except Mirror Events.\n+        // Disable all events except mirror events.\n         recording.enable(\"jdk.ThreadSleep\");\n         recording.enable(\"jdk.VirtualThreadStart\");\n         recording.enable(\"jdk.VirtualThreadEnd\");\n@@ -59,7 +59,7 @@ public void test() throws Throwable {\n         recording.setDestination(path);\n         recording.start();\n \n-        // Generate some mirror event emissions.\n+        // Generate some event emissions.\n         Runnable eventEmitter = () -> {\n             try {\n                 Thread.sleep(100);\n@@ -90,7 +90,6 @@ public void test() throws Throwable {\n             assertTrue(\"Mirror event metadata not applied correctly.\", !eventType.getName().equals(\"jdk.internal.event.ThreadSleepEvent\") &&\n                             !eventType.getName().equals(\"jdk.internal.event.VirtualThreadStartEvent\") && !eventType.getName().equals(\"jdk.internal.event.VirtualThreadEndEvent\"));\n \n-            System.out.println(eventType.getName());\n             if (eventType.getName().equals(\"jdk.ThreadSleep\") && eventType.getCategoryNames().contains(\"Java Application\") && eventType.getLabel().equals(\"Java Thread Sleep\")) {\n                 foundSleepEvent = true;\n             }",
      "parent_sha": "d7b075864c3191835014564179feefbd4021a7ca"
    }
  },
  {
    "oid": "1f297af441d3dcc94ce2d87a283bfbd610d121a8",
    "message": "use TTY in BenchmarkCounters",
    "date": "2014-07-22T13:05:09Z",
    "url": "https://github.com/oracle/graal/commit/1f297af441d3dcc94ce2d87a283bfbd610d121a8",
    "details": {
      "sha": "85258f367b5cc14a85b489728daf17c432b2b2b6",
      "filename": "graal/com.oracle.graal.hotspot/src/com/oracle/graal/hotspot/debug/BenchmarkCounters.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/oracle/graal/blob/1f297af441d3dcc94ce2d87a283bfbd610d121a8/graal%2Fcom.oracle.graal.hotspot%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fhotspot%2Fdebug%2FBenchmarkCounters.java",
      "raw_url": "https://github.com/oracle/graal/raw/1f297af441d3dcc94ce2d87a283bfbd610d121a8/graal%2Fcom.oracle.graal.hotspot%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fhotspot%2Fdebug%2FBenchmarkCounters.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.hotspot%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fhotspot%2Fdebug%2FBenchmarkCounters.java?ref=1f297af441d3dcc94ce2d87a283bfbd610d121a8",
      "patch": "@@ -32,6 +32,7 @@\n import com.oracle.graal.api.meta.*;\n import com.oracle.graal.compiler.common.*;\n import com.oracle.graal.compiler.common.type.*;\n+import com.oracle.graal.debug.*;\n import com.oracle.graal.hotspot.*;\n import com.oracle.graal.hotspot.bridge.*;\n import com.oracle.graal.hotspot.meta.*;\n@@ -342,7 +343,7 @@ protected void patternFound(int index) {\n         if (Options.TimedDynamicCounters.getValue() > 0) {\n             Thread thread = new Thread() {\n                 long lastTime = System.nanoTime();\n-                PrintStream out = System.out;\n+                PrintStream out = TTY.cachedOut;\n \n                 @Override\n                 public void run() {\n@@ -369,7 +370,7 @@ public void run() {\n \n     public static void shutdown(CompilerToVM compilerToVM, long compilerStartTime) {\n         if (Options.GenericDynamicCounters.getValue()) {\n-            dump(System.out, (System.nanoTime() - compilerStartTime) / 1000000000d, compilerToVM.collectCounters(), 100);\n+            dump(TTY.cachedOut, (System.nanoTime() - compilerStartTime) / 1000000000d, compilerToVM.collectCounters(), 100);\n         }\n     }\n ",
      "parent_sha": "fc4d50f10a401f464e364cf3ee0b5e735f6863eb"
    }
  },
  {
    "oid": "6992c6e856f9f1009d151ab40e95f8f979ac2c4b",
    "message": "Augment write barrier addition tests for G1",
    "date": "2013-08-06T12:23:23Z",
    "url": "https://github.com/oracle/graal/commit/6992c6e856f9f1009d151ab40e95f8f979ac2c4b",
    "details": {
      "sha": "b0f41073a2a6207c8658c2d49a1d38ab8a471687",
      "filename": "graal/com.oracle.graal.hotspot.test/src/com/oracle/graal/hotspot/test/WriteBarrierAdditionTest.java",
      "status": "modified",
      "additions": 12,
      "deletions": 10,
      "changes": 22,
      "blob_url": "https://github.com/oracle/graal/blob/6992c6e856f9f1009d151ab40e95f8f979ac2c4b/graal%2Fcom.oracle.graal.hotspot.test%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fhotspot%2Ftest%2FWriteBarrierAdditionTest.java",
      "raw_url": "https://github.com/oracle/graal/raw/6992c6e856f9f1009d151ab40e95f8f979ac2c4b/graal%2Fcom.oracle.graal.hotspot.test%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fhotspot%2Ftest%2FWriteBarrierAdditionTest.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.hotspot.test%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fhotspot%2Ftest%2FWriteBarrierAdditionTest.java?ref=6992c6e856f9f1009d151ab40e95f8f979ac2c4b",
      "patch": "@@ -22,6 +22,8 @@\n  */\n package com.oracle.graal.hotspot.test;\n \n+import static com.oracle.graal.hotspot.replacements.HotSpotReplacementsUtil.*;\n+\n import java.lang.ref.*;\n import java.lang.reflect.*;\n \n@@ -41,7 +43,6 @@\n import com.oracle.graal.phases.*;\n import com.oracle.graal.phases.common.*;\n import com.oracle.graal.phases.tiers.*;\n-import static com.oracle.graal.hotspot.replacements.HotSpotReplacementsUtil.*;\n \n /**\n  * The following unit tests assert the presence of write barriers for both Serial and G1 GCs.\n@@ -146,17 +147,17 @@ public static Object test4Snippet() {\n     static Container con = new Container();\n \n     /**\n-     * Expected 4 barriers for the Serial GC and 9 for G1 (5 pre + 4 post). In this test, we load\n-     * the correct offset of the WeakReference object so naturally we assert the presence of the pre\n-     * barrier.\n+     * Expected 4 barriers for the Serial GC and 9 for G1 (1 ref + 4 pre + 4 post). In this test, we\n+     * load the correct offset of the WeakReference object so naturally we assert the presence of\n+     * the pre barrier.\n      */\n     @Test\n     public void test5() throws Exception {\n         test(\"test5Snippet\", useG1GC() ? 9 : 4);\n     }\n \n     public static Object test5Snippet() throws Exception {\n-        return UnsafeLoadNode.load(wr, 0, 16, Kind.Object);\n+        return UnsafeLoadNode.load(wr, 0, useCompressedOops() ? 12 : 16, Kind.Object);\n     }\n \n     /**\n@@ -246,9 +247,12 @@ private void test(final String snippet, final int expectedBarriers) throws Excep\n \n             public void run() {\n                 StructuredGraph graph = parse(snippet);\n-                HighTierContext context = new HighTierContext(runtime(), new Assumptions(false), replacements, null, getDefaultPhasePlan(), OptimisticOptimizations.ALL);\n-                new InliningPhase(new InliningPhase.InlineEverythingPolicy()).apply(graph, context);\n-                new LoweringPhase(LoweringType.BEFORE_GUARDS).apply(graph, context);\n+                HighTierContext highContext = new HighTierContext(runtime(), new Assumptions(false), replacements, null, getDefaultPhasePlan(), OptimisticOptimizations.ALL);\n+                MidTierContext midContext = new MidTierContext(runtime(), new Assumptions(false), replacements, runtime().getTarget(), OptimisticOptimizations.ALL);\n+                new InliningPhase(new InliningPhase.InlineEverythingPolicy()).apply(graph, highContext);\n+                new LoweringPhase(LoweringType.BEFORE_GUARDS).apply(graph, highContext);\n+                new GuardLoweringPhase().apply(graph, midContext);\n+                new LoweringPhase(LoweringType.AFTER_GUARDS).apply(graph, midContext);\n                 new WriteBarrierAdditionPhase().apply(graph);\n                 Debug.dump(graph, \"After Write Barrier Addition\");\n \n@@ -278,8 +282,6 @@ public void run() {\n                     if (read.getBarrierType() != BarrierType.NONE) {\n                         if (read.location() instanceof ConstantLocationNode) {\n                             Assert.assertTrue(((ConstantLocationNode) (read.location())).getDisplacement() == referentOffset());\n-                        } else {\n-                            Assert.assertTrue(((IndexedLocationNode) (read.location())).getDisplacement() == referentOffset());\n                         }\n                         Assert.assertTrue(useG1GC());\n                         Assert.assertTrue(read.getBarrierType() == BarrierType.PRECISE);",
      "parent_sha": "3512c74cc5ba9b0a7201e78e95b5bd3a5e7ebc5c"
    }
  },
  {
    "oid": "7f91934551329ff4350dbe3f77ceaf946e7de00e",
    "message": "Truffle/SourceSection: change the default name for \"unknown\" to a public static for comparisions.",
    "date": "2015-12-07T04:12:43Z",
    "url": "https://github.com/oracle/graal/commit/7f91934551329ff4350dbe3f77ceaf946e7de00e",
    "details": {
      "sha": "546704dfe162d0bdabc7a70d004ab0d8e92f7b73",
      "filename": "truffle/com.oracle.truffle.api/src/com/oracle/truffle/api/source/SourceSection.java",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/oracle/graal/blob/7f91934551329ff4350dbe3f77ceaf946e7de00e/truffle%2Fcom.oracle.truffle.api%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Fsource%2FSourceSection.java",
      "raw_url": "https://github.com/oracle/graal/raw/7f91934551329ff4350dbe3f77ceaf946e7de00e/truffle%2Fcom.oracle.truffle.api%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Fsource%2FSourceSection.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/truffle%2Fcom.oracle.truffle.api%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Fsource%2FSourceSection.java?ref=7f91934551329ff4350dbe3f77ceaf946e7de00e",
      "patch": "@@ -37,6 +37,12 @@\n  * @see #createUnavailable\n  */\n public final class SourceSection {\n+\n+    /**\n+     * The identifier stored when source information is unavailable.\n+     */\n+    public static String UNKNOWN = \"<unknown>\";\n+\n     private final Source source;\n     private final String identifier;\n     private final int startLine;\n@@ -262,6 +268,6 @@ public boolean equals(Object obj) {\n      * @return source section which is mostly <em>empty</em>\n      */\n     public static SourceSection createUnavailable(String kind, String name) {\n-        return new SourceSection(kind, null, name == null ? \"<unknown>\" : name, -1, -1, -1, -1);\n+        return new SourceSection(kind, null, name == null ? UNKNOWN : name, -1, -1, -1, -1);\n     }\n }",
      "parent_sha": "da1ff1426d84f58cbf429cbabe2416cb9addc103"
    }
  },
  {
    "oid": "93426aa417ab9c5bc9cc3c546e949a9e4ad6c1db",
    "message": "Make Write Barrier abstract class",
    "date": "2013-06-24T10:06:32Z",
    "url": "https://github.com/oracle/graal/commit/93426aa417ab9c5bc9cc3c546e949a9e4ad6c1db",
    "details": {
      "sha": "7e1df5bbf7962213e48778ada7b174c1deeae3db",
      "filename": "graal/com.oracle.graal.nodes/src/com/oracle/graal/nodes/WriteBarrier.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/oracle/graal/blob/93426aa417ab9c5bc9cc3c546e949a9e4ad6c1db/graal%2Fcom.oracle.graal.nodes%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fnodes%2FWriteBarrier.java",
      "raw_url": "https://github.com/oracle/graal/raw/93426aa417ab9c5bc9cc3c546e949a9e4ad6c1db/graal%2Fcom.oracle.graal.nodes%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fnodes%2FWriteBarrier.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.nodes%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fnodes%2FWriteBarrier.java?ref=93426aa417ab9c5bc9cc3c546e949a9e4ad6c1db",
      "patch": "@@ -27,7 +27,7 @@\n import com.oracle.graal.nodes.spi.*;\n import com.oracle.graal.nodes.type.*;\n \n-public class WriteBarrier extends FixedWithNextNode implements Lowerable, Node.IterableNodeType {\n+public abstract class WriteBarrier extends FixedWithNextNode implements Lowerable, Node.IterableNodeType {\n \n     @Input private ValueNode object;\n     @Input private LocationNode location;",
      "parent_sha": "ac96211c2b861c249ca1e867501dc50cca796612"
    }
  },
  {
    "oid": "7261e7ee885ad79d02488a2ee439375a78f9ca52",
    "message": "svm: refactor Throwable#fillInStackTrace substitution",
    "date": "2023-04-21T14:02:29Z",
    "url": "https://github.com/oracle/graal/commit/7261e7ee885ad79d02488a2ee439375a78f9ca52",
    "details": {
      "sha": "b4039d2fc6c3f7461260e70c45fc2024418a0bc2",
      "filename": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/JavaLangSubstitutions.java",
      "status": "modified",
      "additions": 39,
      "deletions": 17,
      "changes": 56,
      "blob_url": "https://github.com/oracle/graal/blob/7261e7ee885ad79d02488a2ee439375a78f9ca52/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2Fjdk%2FJavaLangSubstitutions.java",
      "raw_url": "https://github.com/oracle/graal/raw/7261e7ee885ad79d02488a2ee439375a78f9ca52/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2Fjdk%2FJavaLangSubstitutions.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2Fjdk%2FJavaLangSubstitutions.java?ref=7261e7ee885ad79d02488a2ee439375a78f9ca52",
      "patch": "@@ -280,39 +280,61 @@ final class Target_java_lang_StringUTF16 {\n final class Target_java_lang_Throwable {\n \n     @Alias @RecomputeFieldValue(kind = Reset)//\n-    private Object backtrace;\n+    Object backtrace;\n \n     @Alias @RecomputeFieldValue(kind = Reset)//\n     StackTraceElement[] stackTrace;\n \n     @Alias String detailMessage;\n \n+    /**\n+     * Records the execution stack in an internal format. The information is transformed into\n+     * {@link StackTraceElement} array in\n+     * {@link Target_java_lang_StackTraceElement#of(Object, int)}.\n+     * \n+     * @param dummy to change signature\n+     */\n     @Substitute\n     @NeverInline(\"Starting a stack walk in the caller frame\")\n-    private Target_java_lang_Throwable fillInStackTrace() {\n-        if (!RuntimeCompilation.isEnabled()) {\n-            RawStackTraceVisitor visitor = new RawStackTraceVisitor();\n-            JavaThreads.visitStackTrace(Thread.currentThread(), visitor);\n-            backtrace = visitor.getArray();\n-            stackTrace = null;\n+    private Target_java_lang_Throwable fillInStackTrace(int dummy) {\n+        /*\n+         * Start out by clearing the backtrace for this object, in case the VM runs out of memory\n+         * while allocating the stack trace.\n+         */\n+        backtrace = null;\n+\n+        if (RuntimeCompilation.isEnabled()) {\n+            /*\n+             * Runtime compilation not yet optimized. Store the eagerly constructed stack trace in\n+             * `backtrace`. We directly use `stackTrace` because it is overwritten by the caller.\n+             */\n+            backtrace = JavaThreads.getStackTrace(true, Thread.currentThread());\n             return this;\n         }\n-        stackTrace = JavaThreads.getStackTrace(true, Thread.currentThread());\n+\n+        RawStackTraceVisitor visitor = new RawStackTraceVisitor();\n+        JavaThreads.visitStackTrace(Thread.currentThread(), visitor);\n+        backtrace = visitor.getArray();\n         return this;\n     }\n+}\n \n+@TargetClass(java.lang.StackTraceElement.class)\n+@Platforms(InternalPlatform.NATIVE_ONLY.class)\n+final class Target_java_lang_StackTraceElement {\n+    /**\n+     * Constructs the {@link StackTraceElement} array from a backtrace.\n+     *\n+     * @param x backtrace stored in {@link Target_java_lang_Throwable#backtrace}\n+     * @param depth ignored\n+     */\n     @Substitute\n-    private StackTraceElement[] getOurStackTrace() {\n-        if (stackTrace != null) {\n-            return stackTrace;\n-        } else if (backtrace != null) {\n-            Object backtraceCopy = backtrace;\n-            backtrace = null;\n-            stackTrace = RawStackTraceVisitor.decodeBacktrace(backtraceCopy);\n+    static StackTraceElement[] of(Object x, int depth) {\n+        if (x instanceof StackTraceElement[] stackTrace) {\n+            /* Stack trace eagerly created. */\n             return stackTrace;\n-        } else {\n-            return new StackTraceElement[0];\n         }\n+        return RawStackTraceVisitor.decodeBacktrace(x);\n     }\n }\n ",
      "parent_sha": "4eb08950fedb2948d6e649169e79243a7b52b4bc"
    }
  },
  {
    "oid": "71ca5ccad9b80244ff8ac4f56e95c6d977c36762",
    "message": "Don't allocate EngineTruffleObject twice in the 'as' method",
    "date": "2016-11-21T09:51:38Z",
    "url": "https://github.com/oracle/graal/commit/71ca5ccad9b80244ff8ac4f56e95c6d977c36762",
    "details": {
      "sha": "5293c29bbc32a4c51c07f6641f489a2448e7b930",
      "filename": "truffle/com.oracle.truffle.api.vm/src/com/oracle/truffle/api/vm/PolyglotEngine.java",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/oracle/graal/blob/71ca5ccad9b80244ff8ac4f56e95c6d977c36762/truffle%2Fcom.oracle.truffle.api.vm%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Fvm%2FPolyglotEngine.java",
      "raw_url": "https://github.com/oracle/graal/raw/71ca5ccad9b80244ff8ac4f56e95c6d977c36762/truffle%2Fcom.oracle.truffle.api.vm%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Fvm%2FPolyglotEngine.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/truffle%2Fcom.oracle.truffle.api.vm%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Fvm%2FPolyglotEngine.java?ref=71ca5ccad9b80244ff8ac4f56e95c6d977c36762",
      "patch": "@@ -812,17 +812,17 @@ public abstract class Value {\n          * @since 0.9\n          */\n         public Object get() {\n-            return get(true);\n+            return get(true, true);\n         }\n \n-        private Object get(boolean unwrapJava) {\n+        private Object get(boolean unwrapJava, boolean wrapEngine) {\n             assertNoTruffle();\n             Object result = waitForSymbol();\n             if (result instanceof TruffleObject) {\n                 if (unwrapJava) {\n                     result = JavaInterop.asJavaObject(Object.class, (TruffleObject) result);\n                 }\n-                if (executor != null && result instanceof TruffleObject) {\n+                if (wrapEngine && executor != null && result instanceof TruffleObject) {\n                     return new EngineTruffleObject(PolyglotEngine.this, (TruffleObject) result);\n                 }\n             }\n@@ -847,7 +847,7 @@ private Object get(boolean unwrapJava) {\n          */\n         public <T> T as(final Class<T> representation) {\n             assertNoTruffle();\n-            final Object obj = get();\n+            final Object obj = get(true, false);\n             if (obj instanceof EngineTruffleObject) {\n                 EngineTruffleObject eto = (EngineTruffleObject) obj;\n                 if (representation.isInstance(eto.getDelegate())) {\n@@ -865,7 +865,7 @@ public <T> T as(final Class<T> representation) {\n             if (representation.isInstance(obj)) {\n                 return representation.cast(obj);\n             }\n-            return JavaInterop.asJavaObject(representation, (TruffleObject) get(false));\n+            return JavaInterop.asJavaObject(representation, (TruffleObject) get(false, true));\n         }\n \n         /**",
      "parent_sha": "cbdbee11ecd52d9231073808e4810eee77f1b9a8"
    }
  },
  {
    "oid": "edb2d50e64edfb8f1aa9bd3aa61b672087eac488",
    "message": "Added workaround for native image.",
    "date": "2022-11-10T10:02:29Z",
    "url": "https://github.com/oracle/graal/commit/edb2d50e64edfb8f1aa9bd3aa61b672087eac488",
    "details": {
      "sha": "9ae138247c97e244d9c9d52764d8a71b9cad51d9",
      "filename": "wasm/src/org.graalvm.wasm/src/org/graalvm/wasm/nodes/WasmFunctionNode.java",
      "status": "modified",
      "additions": 47,
      "deletions": 20,
      "changes": 67,
      "blob_url": "https://github.com/oracle/graal/blob/edb2d50e64edfb8f1aa9bd3aa61b672087eac488/wasm%2Fsrc%2Forg.graalvm.wasm%2Fsrc%2Forg%2Fgraalvm%2Fwasm%2Fnodes%2FWasmFunctionNode.java",
      "raw_url": "https://github.com/oracle/graal/raw/edb2d50e64edfb8f1aa9bd3aa61b672087eac488/wasm%2Fsrc%2Forg.graalvm.wasm%2Fsrc%2Forg%2Fgraalvm%2Fwasm%2Fnodes%2FWasmFunctionNode.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/wasm%2Fsrc%2Forg.graalvm.wasm%2Fsrc%2Forg%2Fgraalvm%2Fwasm%2Fnodes%2FWasmFunctionNode.java?ref=edb2d50e64edfb8f1aa9bd3aa61b672087eac488",
      "patch": "@@ -549,15 +549,28 @@ public Object executeBodyFromOffset(WasmContext context, VirtualFrame frame, int\n                     final int targetStackPointer = numLocals + fifthValueUnsigned(extraData, extraOffset, compact);\n                     final int targetResultCount = fourthValueUnsigned(extraData, extraOffset, compact);\n \n-                    CompilerAsserts.partialEvaluationConstant(targetUnwindType);\n-                    if (targetUnwindType == PRIMITIVE_UNWIND) {\n-                        unwindPrimitiveStack(frame, stackPointer, targetStackPointer, targetResultCount);\n-                    } else if (targetUnwindType == REFERENCE_UNWIND) {\n-                        CompilerDirectives.transferToInterpreterAndInvalidate();\n-                        unwindReferenceStack(frame, stackPointer, targetStackPointer, targetResultCount);\n-                    } else if (targetUnwindType == UNKNOWN_UNWIND) {\n-                        CompilerDirectives.transferToInterpreterAndInvalidate();\n-                        unwindStack(frame, stackPointer, targetStackPointer, targetResultCount);\n+                    if (CompilerDirectives.inInterpreter()) {\n+                        CompilerAsserts.partialEvaluationConstant(targetUnwindType);\n+                        if (targetUnwindType == PRIMITIVE_UNWIND) {\n+                            unwindPrimitiveStack(frame, stackPointer, targetStackPointer, targetResultCount);\n+                        } else if (targetUnwindType == REFERENCE_UNWIND) {\n+                            // Workaround for native image performance\n+                            CompilerDirectives.transferToInterpreterAndInvalidate();\n+                            unwindReferenceStack(frame, stackPointer, targetStackPointer, targetResultCount);\n+                        } else if (targetUnwindType == UNKNOWN_UNWIND) {\n+                            // Workaround for native image performance\n+                            CompilerDirectives.transferToInterpreterAndInvalidate();\n+                            unwindStack(frame, stackPointer, targetStackPointer, targetResultCount);\n+                        }\n+                    } else {\n+                        CompilerAsserts.partialEvaluationConstant(targetUnwindType);\n+                        if (targetUnwindType == PRIMITIVE_UNWIND) {\n+                            unwindPrimitiveStack(frame, stackPointer, targetStackPointer, targetResultCount);\n+                        } else if (targetUnwindType == REFERENCE_UNWIND) {\n+                            unwindReferenceStack(frame, stackPointer, targetStackPointer, targetResultCount);\n+                        } else if (targetUnwindType == UNKNOWN_UNWIND) {\n+                            unwindStack(frame, stackPointer, targetStackPointer, targetResultCount);\n+                        }\n                     }\n                     // Jump to the target block.\n                     offset += secondValueSigned(extraData, extraOffset, compact);\n@@ -575,15 +588,27 @@ public Object executeBodyFromOffset(WasmContext context, VirtualFrame frame, int\n                         final int targetStackPointer = numLocals + fifthValueUnsigned(extraData, extraOffset, compact);\n                         final int targetResultCount = fourthValueUnsigned(extraData, extraOffset, compact);\n \n-                        CompilerAsserts.partialEvaluationConstant(targetUnwindType);\n-                        if (targetUnwindType == PRIMITIVE_UNWIND) {\n-                            unwindPrimitiveStack(frame, stackPointer, targetStackPointer, targetResultCount);\n-                        } else if (targetUnwindType == REFERENCE_UNWIND) {\n-                            CompilerDirectives.transferToInterpreterAndInvalidate();\n-                            unwindReferenceStack(frame, stackPointer, targetStackPointer, targetResultCount);\n-                        } else if (targetUnwindType == UNKNOWN_UNWIND) {\n-                            CompilerDirectives.transferToInterpreterAndInvalidate();\n-                            unwindStack(frame, stackPointer, targetStackPointer, targetResultCount);\n+                        if (CompilerDirectives.inInterpreter()) {\n+                            if (targetUnwindType == PRIMITIVE_UNWIND) {\n+                                unwindPrimitiveStack(frame, stackPointer, targetStackPointer, targetResultCount);\n+                            } else if (targetUnwindType == REFERENCE_UNWIND) {\n+                                // Workaround for native image performance\n+                                CompilerDirectives.transferToInterpreterAndInvalidate();\n+                                unwindReferenceStack(frame, stackPointer, targetStackPointer, targetResultCount);\n+                            } else if (targetUnwindType == UNKNOWN_UNWIND) {\n+                                // Workaround for native image performance\n+                                CompilerDirectives.transferToInterpreterAndInvalidate();\n+                                unwindStack(frame, stackPointer, targetStackPointer, targetResultCount);\n+                            }\n+                        } else {\n+                            CompilerAsserts.partialEvaluationConstant(targetUnwindType);\n+                            if (targetUnwindType == PRIMITIVE_UNWIND) {\n+                                unwindPrimitiveStack(frame, stackPointer, targetStackPointer, targetResultCount);\n+                            } else if (targetUnwindType == REFERENCE_UNWIND) {\n+                                unwindReferenceStack(frame, stackPointer, targetStackPointer, targetResultCount);\n+                            } else if (targetUnwindType == UNKNOWN_UNWIND) {\n+                                unwindStack(frame, stackPointer, targetStackPointer, targetResultCount);\n+                            }\n                         }\n \n                         // Jump to the target block.\n@@ -625,8 +650,12 @@ public Object executeBodyFromOffset(WasmContext context, VirtualFrame frame, int\n                         if (targetUnwindType == PRIMITIVE_UNWIND) {\n                             unwindPrimitiveStack(frame, stackPointer, targetStackPointer, targetResultCount);\n                         } else if (targetUnwindType == REFERENCE_UNWIND) {\n+                            // Workaround for native image performance\n+                            CompilerDirectives.transferToInterpreterAndInvalidate();\n                             unwindReferenceStack(frame, stackPointer, targetStackPointer, targetResultCount);\n                         } else if (targetUnwindType == UNKNOWN_UNWIND) {\n+                            // Workaround for native image performance\n+                            CompilerDirectives.transferToInterpreterAndInvalidate();\n                             unwindStack(frame, stackPointer, targetStackPointer, targetResultCount);\n                         }\n \n@@ -652,10 +681,8 @@ public Object executeBodyFromOffset(WasmContext context, VirtualFrame frame, int\n                                 if (targetUnwindType == PRIMITIVE_UNWIND) {\n                                     unwindPrimitiveStack(frame, stackPointer, targetStackPointer, targetResultCount);\n                                 } else if (targetUnwindType == REFERENCE_UNWIND) {\n-                                    CompilerDirectives.transferToInterpreterAndInvalidate();\n                                     unwindReferenceStack(frame, stackPointer, targetStackPointer, targetResultCount);\n                                 } else if (targetUnwindType == UNKNOWN_UNWIND) {\n-                                    CompilerDirectives.transferToInterpreterAndInvalidate();\n                                     unwindStack(frame, stackPointer, targetStackPointer, targetResultCount);\n                                 }\n ",
      "parent_sha": "e89f985e56b7506df04f866eb9ea853b96a26652"
    }
  },
  {
    "oid": "096eb4d1e7739711526b421bf3de49d8566bb175",
    "message": "Allow inlining of InvokeWithExceptionNodes in JNI",
    "date": "2020-12-23T10:48:32Z",
    "url": "https://github.com/oracle/graal/commit/096eb4d1e7739711526b421bf3de49d8566bb175",
    "details": {
      "sha": "7d5af365ce7039c1d1d283b4400b2e8bbbb2101a",
      "filename": "compiler/src/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/GraphKit.java",
      "status": "modified",
      "additions": 9,
      "deletions": 5,
      "changes": 14,
      "blob_url": "https://github.com/oracle/graal/blob/096eb4d1e7739711526b421bf3de49d8566bb175/compiler%2Fsrc%2Forg.graalvm.compiler.replacements%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Freplacements%2FGraphKit.java",
      "raw_url": "https://github.com/oracle/graal/raw/096eb4d1e7739711526b421bf3de49d8566bb175/compiler%2Fsrc%2Forg.graalvm.compiler.replacements%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Freplacements%2FGraphKit.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/compiler%2Fsrc%2Forg.graalvm.compiler.replacements%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Freplacements%2FGraphKit.java?ref=096eb4d1e7739711526b421bf3de49d8566bb175",
      "patch": "@@ -41,6 +41,7 @@\n import org.graalvm.compiler.debug.DebugContext;\n import org.graalvm.compiler.debug.GraalError;\n import org.graalvm.compiler.graph.Graph;\n+import org.graalvm.compiler.graph.Node;\n import org.graalvm.compiler.graph.Node.ValueNumberable;\n import org.graalvm.compiler.graph.NodeSourcePosition;\n import org.graalvm.compiler.java.FrameStateBuilder;\n@@ -53,6 +54,7 @@\n import org.graalvm.compiler.nodes.FixedNode;\n import org.graalvm.compiler.nodes.FixedWithNextNode;\n import org.graalvm.compiler.nodes.IfNode;\n+import org.graalvm.compiler.nodes.Invoke;\n import org.graalvm.compiler.nodes.InvokeNode;\n import org.graalvm.compiler.nodes.InvokeWithExceptionNode;\n import org.graalvm.compiler.nodes.KillingBeginNode;\n@@ -368,18 +370,20 @@ public void inlineInvokes(String reason, String phase) {\n      * Inlines a given invocation to a method. The graph of the inlined method is processed in the\n      * same manner as for snippets and method substitutions.\n      */\n-    public void inline(InvokeNode invoke, String reason, String phase) {\n-        ResolvedJavaMethod method = ((MethodCallTargetNode) invoke.callTarget()).targetMethod();\n+    public void inline(Invoke invoke, String reason, String phase) {\n+        assert invoke instanceof Node;\n+        Node invokeNode = (Node) invoke;\n+        ResolvedJavaMethod method = invoke.callTarget().targetMethod();\n \n         Plugins plugins = new Plugins(graphBuilderPlugins);\n         GraphBuilderConfiguration config = GraphBuilderConfiguration.getSnippetDefault(plugins);\n \n         StructuredGraph calleeGraph;\n         if (IS_IN_NATIVE_IMAGE) {\n-            calleeGraph = providers.getReplacements().getSnippet(method, null, null, false, null, invoke.getOptions());\n+            calleeGraph = providers.getReplacements().getSnippet(method, null, null, false, null, invokeNode.getOptions());\n         } else {\n-            calleeGraph = new StructuredGraph.Builder(invoke.getOptions(), invoke.getDebug()).method(method).trackNodeSourcePosition(invoke.graph().trackNodeSourcePosition()).setIsSubstitution(\n-                            true).build();\n+            calleeGraph = new StructuredGraph.Builder(invokeNode.getOptions(), invokeNode.getDebug()).method(method).trackNodeSourcePosition(\n+                            invokeNode.graph().trackNodeSourcePosition()).setIsSubstitution(true).build();\n             IntrinsicContext initialReplacementContext = new IntrinsicContext(method, method, providers.getReplacements().getDefaultReplacementBytecodeProvider(), INLINE_AFTER_PARSING);\n             GraphBuilderPhase.Instance instance = createGraphBuilderInstance(providers, config, OptimisticOptimizations.NONE, initialReplacementContext);\n             instance.apply(calleeGraph);",
      "parent_sha": "f1d809d06cc15140705de72f4e383b7cfc78e062"
    }
  },
  {
    "oid": "ad3843ebd2d61068fb8542cf94038f41efb8e7d9",
    "message": "Fix failure when no resource bundle nullary constructor is present",
    "date": "2023-12-14T12:34:28Z",
    "url": "https://github.com/oracle/graal/commit/ad3843ebd2d61068fb8542cf94038f41efb8e7d9",
    "details": {
      "sha": "fe2cb8dd272021e96da4785c1ed8d444a81aaac5",
      "filename": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/localization/LocalizationSupport.java",
      "status": "modified",
      "additions": 20,
      "deletions": 9,
      "changes": 29,
      "blob_url": "https://github.com/oracle/graal/blob/ad3843ebd2d61068fb8542cf94038f41efb8e7d9/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2Fjdk%2Flocalization%2FLocalizationSupport.java",
      "raw_url": "https://github.com/oracle/graal/raw/ad3843ebd2d61068fb8542cf94038f41efb8e7d9/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2Fjdk%2Flocalization%2FLocalizationSupport.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2Fjdk%2Flocalization%2FLocalizationSupport.java?ref=ad3843ebd2d61068fb8542cf94038f41efb8e7d9",
      "patch": "@@ -115,13 +115,7 @@ public void prepareBundle(String bundleName, ResourceBundle bundle, Function<Str\n          */\n         registerRequiredReflectionAndResourcesForBundle(bundleName, Set.of(locale));\n         if (!(bundle instanceof PropertyResourceBundle)) {\n-            RuntimeReflection.register(bundle.getClass());\n-            try {\n-                Constructor<?> nullaryConstructor = bundle.getClass().getDeclaredConstructor();\n-                RuntimeReflection.register(nullaryConstructor);\n-            } catch (NoSuchMethodException e) {\n-                RuntimeReflection.registerConstructorLookup(bundle.getClass());\n-            }\n+            registerNullaryConstructor(bundle.getClass());\n         }\n \n         /* Property-based bundle lookup happens only if class-based lookup fails */\n@@ -258,8 +252,25 @@ public static Locale parseLocaleFromTag(String tag) {\n     }\n \n     public void prepareClassResourceBundle(@SuppressWarnings(\"unused\") String basename, Class<?> bundleClass) {\n-        RuntimeReflection.register(bundleClass);\n-        RuntimeReflection.registerForReflectiveInstantiation(bundleClass);\n+        registerNullaryConstructor(bundleClass);\n         onClassBundlePrepared(bundleClass);\n     }\n+\n+    /**\n+     * Bundle lookup code tries to reflectively access the default constructor of candidate bundle\n+     * classes, and then tries to invoke them if they exist. We therefore need to register the\n+     * default constructor as invoked if it exists, and as queried if it doesn't, which we know will\n+     * result in a negative query.\n+     */\n+    private void registerNullaryConstructor(Class<?> bundleClass) {\n+        RuntimeReflection.register(bundleClass);\n+        Constructor<?> nullaryConstructor;\n+        try {\n+            nullaryConstructor = bundleClass.getDeclaredConstructor();\n+        } catch (NoSuchMethodException e) {\n+            RuntimeReflection.registerConstructorLookup(bundleClass);\n+            return;\n+        }\n+        RuntimeReflection.register(nullaryConstructor);\n+    }\n }",
      "parent_sha": "8d7d2c80d7c4a6872a19d7e259b923fb24cd6131"
    }
  },
  {
    "oid": "2cb5b6e1c30e608d9baa4b13ed02459726ab3a6d",
    "message": "Merge.",
    "date": "2014-01-28T11:52:57Z",
    "url": "https://github.com/oracle/graal/commit/2cb5b6e1c30e608d9baa4b13ed02459726ab3a6d",
    "details": {
      "sha": "8bdc37b52463b0954338e027cd78b8700625f813",
      "filename": "graal/com.oracle.graal.truffle/src/com/oracle/graal/truffle/TruffleInliningImpl.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/oracle/graal/blob/2cb5b6e1c30e608d9baa4b13ed02459726ab3a6d/graal%2Fcom.oracle.graal.truffle%2Fsrc%2Fcom%2Foracle%2Fgraal%2Ftruffle%2FTruffleInliningImpl.java",
      "raw_url": "https://github.com/oracle/graal/raw/2cb5b6e1c30e608d9baa4b13ed02459726ab3a6d/graal%2Fcom.oracle.graal.truffle%2Fsrc%2Fcom%2Foracle%2Fgraal%2Ftruffle%2FTruffleInliningImpl.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.truffle%2Fsrc%2Fcom%2Foracle%2Fgraal%2Ftruffle%2FTruffleInliningImpl.java?ref=2cb5b6e1c30e608d9baa4b13ed02459726ab3a6d",
      "patch": "@@ -84,7 +84,7 @@ public boolean performInlining(OptimizedCallTarget target) {\n \n         if (inlined) {\n             for (InlinableCallSiteInfo callSite : inlinableCallSites) {\n-                if (callSite.getCallSite().isInlinable()) {\n+                if (callSite.getCallSite().isInlinable() && !callSite.getCallSite().isInlined()) {\n                     CallNode.internalResetCallCount(callSite.getCallSite());\n                 }\n             }\n@@ -215,7 +215,7 @@ static List<InlinableCallSiteInfo> getInlinableCallSites(final DefaultCallTarget\n             public boolean visit(Node node) {\n                 if (node instanceof CallNode) {\n                     CallNode callNode = (CallNode) node;\n-                    if (callNode.isInlinable()) {\n+                    if (callNode.isInlinable() && !callNode.isInlined()) {\n                         inlinableCallSites.add(new InlinableCallSiteInfo(callNode));\n                     }\n                 }",
      "parent_sha": "7ac914bab6845e4a4065cad69225669c6ebe7d13"
    }
  },
  {
    "oid": "02767148af12804adf9eac1c5676db38cd762a12",
    "message": "Use Global Variage Store for Global Variables",
    "date": "2016-09-22T09:29:44Z",
    "url": "https://github.com/oracle/graal/commit/02767148af12804adf9eac1c5676db38cd762a12",
    "details": {
      "sha": "94e94c085e8f78b62bb7a0ef30c7f3ef9e0a21eb",
      "filename": "projects/com.oracle.truffle.llvm.parser.bc.impl/src/com/oracle/truffle/llvm/parser/bc/impl/LLVMBitcodeVisitor.java",
      "status": "modified",
      "additions": 33,
      "deletions": 4,
      "changes": 37,
      "blob_url": "https://github.com/oracle/graal/blob/02767148af12804adf9eac1c5676db38cd762a12/projects%2Fcom.oracle.truffle.llvm.parser.bc.impl%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fparser%2Fbc%2Fimpl%2FLLVMBitcodeVisitor.java",
      "raw_url": "https://github.com/oracle/graal/raw/02767148af12804adf9eac1c5676db38cd762a12/projects%2Fcom.oracle.truffle.llvm.parser.bc.impl%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fparser%2Fbc%2Fimpl%2FLLVMBitcodeVisitor.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/projects%2Fcom.oracle.truffle.llvm.parser.bc.impl%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fparser%2Fbc%2Fimpl%2FLLVMBitcodeVisitor.java?ref=02767148af12804adf9eac1c5676db38cd762a12",
      "patch": "@@ -41,6 +41,7 @@\n import com.oracle.truffle.api.nodes.NodeUtil;\n import com.oracle.truffle.api.nodes.RootNode;\n import com.oracle.truffle.api.source.Source;\n+import com.oracle.truffle.llvm.nativeint.NativeLookup;\n import com.oracle.truffle.llvm.nodes.base.LLVMExpressionNode;\n import com.oracle.truffle.llvm.nodes.base.LLVMNode;\n import com.oracle.truffle.llvm.nodes.base.LLVMStackFrameNuller;\n@@ -54,6 +55,7 @@\n import com.oracle.truffle.llvm.nodes.impl.literals.LLVMSimpleLiteralNode.LLVMAddressLiteralNode;\n import com.oracle.truffle.llvm.nodes.impl.literals.LLVMSimpleLiteralNode.LLVMI1LiteralNode;\n import com.oracle.truffle.llvm.nodes.impl.literals.LLVMSimpleLiteralNode.LLVMI32LiteralNode;\n+import com.oracle.truffle.llvm.nodes.impl.others.LLVMAccessGlobalVariableStorageNodeGen;\n import com.oracle.truffle.llvm.nodes.impl.others.LLVMStaticInitsBlockNode;\n import com.oracle.truffle.llvm.parser.LLVMBaseType;\n import com.oracle.truffle.llvm.parser.LLVMParserResult;\n@@ -67,8 +69,10 @@\n import com.oracle.truffle.llvm.parser.factories.LLVMMemoryReadWriteFactory;\n import com.oracle.truffle.llvm.parser.factories.LLVMRootNodeFactory;\n import com.oracle.truffle.llvm.runtime.options.LLVMBaseOptionFacade;\n+import com.oracle.truffle.llvm.types.LLVMAddress;\n import com.oracle.truffle.llvm.types.LLVMFunctionDescriptor;\n import com.oracle.truffle.llvm.types.LLVMFunctionDescriptor.LLVMRuntimeType;\n+import com.oracle.truffle.llvm.types.LLVMGlobalVariableDescriptor;\n import com.oracle.truffle.llvm.types.memory.LLVMHeap;\n \n import uk.ac.man.cs.llvm.ir.LLVMParser;\n@@ -225,7 +229,7 @@ private LLVMNode createGlobal(GlobalValueSymbol global, FrameSlot stack) {\n             final LLVMBaseType baseType = LLVMBitcodeTypeHelper.getLLVMBaseType(type);\n             final int size = typeHelper.getByteSize(type);\n \n-            final LLVMAddressLiteralNode globalVarAddress = (LLVMAddressLiteralNode) getGlobalVariable(global);\n+            final LLVMAddressNode globalVarAddress = (LLVMAddressNode) getGlobalVariable(global);\n \n             if (size != 0) {\n                 final LLVMNode store;\n@@ -283,9 +287,7 @@ public LLVMExpressionNode getGlobalVariable(GlobalValueSymbol global) {\n             LLVMAddressNode address = globals.get(variable);\n \n             if (address == null) {\n-                final Type type = ((PointerType) variable.getType()).getPointeeType();\n-                address = new LLVMAddressLiteralNode(LLVMHeap.allocateMemory(typeHelper.getByteSize(type)));\n-                deallocations.add(LLVMFreeFactory.create(address));\n+                address = allocateGlobal(variable);\n                 globals.put(variable, address);\n             }\n             return address;\n@@ -294,6 +296,32 @@ public LLVMExpressionNode getGlobalVariable(GlobalValueSymbol global) {\n         }\n     }\n \n+    // NativeLookup expects a NodeFactoryFacade but does not use it for our purpose\n+    private final NativeLookup nativeLookup = new NativeLookup(null);\n+\n+    private LLVMAddressNode allocateGlobal(GlobalValueSymbol global) {\n+        final String name = global.getName();\n+\n+        final LLVMGlobalVariableDescriptor.NativeResolver nativeResolver = () -> LLVMAddress.fromLong(nativeLookup.getNativeHandle(name));\n+\n+        final LLVMGlobalVariableDescriptor descriptor;\n+        if (global.isStatic()) {\n+            descriptor = new LLVMGlobalVariableDescriptor(name, nativeResolver);\n+        } else {\n+            descriptor = context.getGlobalVaraibleRegistry().lookupOrAdd(name, nativeResolver);\n+        }\n+\n+        if (!descriptor.isDeclared()) {\n+            final int byteSize = typeHelper.getByteSize(((PointerType) global.getType()).getPointeeType());\n+            final LLVMAddress nativeStorage = LLVMHeap.allocateMemory(byteSize);\n+            final LLVMAddressNode addressLiteralNode = new LLVMAddressLiteralNode(nativeStorage);\n+            deallocations.add(LLVMFreeFactory.create(addressLiteralNode));\n+            descriptor.declare(nativeStorage);\n+        }\n+\n+        return LLVMAccessGlobalVariableStorageNodeGen.create(descriptor);\n+    }\n+\n     public List<LLVMNode> getGobalVariables(FrameSlot stack) {\n         final List<LLVMNode> globalNodes = new ArrayList<>();\n         for (GlobalValueSymbol global : this.globals.keySet()) {\n@@ -364,6 +392,7 @@ public void visit(FunctionDefinition method) {\n         LLVMFunctionStartNode rootNode = new LLVMFunctionStartNode(body, beforeFunction, afterFunction, null, frame, method.getName());\n         if (LLVMBaseOptionFacade.printFunctionASTs()) {\n             NodeUtil.printTree(System.out, rootNode);\n+            System.out.flush();\n         }\n \n         LLVMRuntimeType llvmReturnType = LLVMBitcodeTypeHelper.toRuntimeType(method.getReturnType());",
      "parent_sha": "8688075f701b407725987cfe11aed514f1157c65"
    }
  },
  {
    "oid": "e35bffa4149441f1e5f5eba182be1a48ed4a36fe",
    "message": "Ensure bootstrapping waits until methods are compiled",
    "date": "2011-12-29T22:05:08Z",
    "url": "https://github.com/oracle/graal/commit/e35bffa4149441f1e5f5eba182be1a48ed4a36fe",
    "details": {
      "sha": "f6a6c5a6e20024e69071fef1832115fdb8cc9656",
      "filename": "graal/com.oracle.max.graal.hotspot/src/com/oracle/max/graal/hotspot/VMExitsNative.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/oracle/graal/blob/e35bffa4149441f1e5f5eba182be1a48ed4a36fe/graal%2Fcom.oracle.max.graal.hotspot%2Fsrc%2Fcom%2Foracle%2Fmax%2Fgraal%2Fhotspot%2FVMExitsNative.java",
      "raw_url": "https://github.com/oracle/graal/raw/e35bffa4149441f1e5f5eba182be1a48ed4a36fe/graal%2Fcom.oracle.max.graal.hotspot%2Fsrc%2Fcom%2Foracle%2Fmax%2Fgraal%2Fhotspot%2FVMExitsNative.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.max.graal.hotspot%2Fsrc%2Fcom%2Foracle%2Fmax%2Fgraal%2Fhotspot%2FVMExitsNative.java?ref=e35bffa4149441f1e5f5eba182be1a48ed4a36fe",
      "patch": "@@ -121,7 +121,7 @@ public void bootstrap() throws Throwable {\n \n         // Compile until the queue is empty.\n         int z = 0;\n-        while (compileQueue.getCompletedTaskCount() < compileQueue.getTaskCount()) {\n+        while (compileQueue.getCompletedTaskCount() < Math.max(2, compileQueue.getTaskCount())) {\n             Thread.sleep(100);\n             while (z < compileQueue.getCompletedTaskCount() / 100) {\n                 ++z;",
      "parent_sha": "f834596f25958841ee25f0f31ab23be49da27901"
    }
  },
  {
    "oid": "cea65ebc8158e692855f71bd0561b177b97aa5b8",
    "message": "made it possible for a MacroNode to be lowered via a standard method substitution",
    "date": "2013-07-26T17:49:00Z",
    "url": "https://github.com/oracle/graal/commit/cea65ebc8158e692855f71bd0561b177b97aa5b8",
    "details": {
      "sha": "277acc81ef94d59b4fbc2af3a652b49a15cf95af",
      "filename": "graal/com.oracle.graal.replacements/src/com/oracle/graal/replacements/nodes/MacroNode.java",
      "status": "modified",
      "additions": 17,
      "deletions": 3,
      "changes": 20,
      "blob_url": "https://github.com/oracle/graal/blob/cea65ebc8158e692855f71bd0561b177b97aa5b8/graal%2Fcom.oracle.graal.replacements%2Fsrc%2Fcom%2Foracle%2Fgraal%2Freplacements%2Fnodes%2FMacroNode.java",
      "raw_url": "https://github.com/oracle/graal/raw/cea65ebc8158e692855f71bd0561b177b97aa5b8/graal%2Fcom.oracle.graal.replacements%2Fsrc%2Fcom%2Foracle%2Fgraal%2Freplacements%2Fnodes%2FMacroNode.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.replacements%2Fsrc%2Fcom%2Foracle%2Fgraal%2Freplacements%2Fnodes%2FMacroNode.java?ref=cea65ebc8158e692855f71bd0561b177b97aa5b8",
      "patch": "@@ -62,20 +62,34 @@ public JavaType getReturnType() {\n         return returnType;\n     }\n \n+    /**\n+     * Gets a snippet to be used for lowering this macro node.\n+     */\n     @SuppressWarnings(\"unused\")\n     protected StructuredGraph getSnippetGraph(LoweringTool tool) {\n         return null;\n     }\n \n+    /**\n+     * Gets a normal method substitution to be used for lowering this macro node. This is only\n+     * called if {@link #getSnippetGraph(LoweringTool)} return nulls.\n+     */\n+    protected StructuredGraph getSubstitutionGraph(LoweringTool tool) {\n+        return tool.getReplacements().getMethodSubstitution(getTargetMethod());\n+    }\n+\n     @Override\n     public void lower(LoweringTool tool, LoweringType loweringType) {\n-        StructuredGraph snippetGraph = getSnippetGraph(tool);\n+        StructuredGraph replacementGraph = getSnippetGraph(tool);\n+        if (replacementGraph == null) {\n+            replacementGraph = getSubstitutionGraph(tool);\n+        }\n \n         InvokeNode invoke = replaceWithInvoke();\n         assert invoke.verify();\n \n-        if (snippetGraph != null) {\n-            InliningUtil.inline(invoke, snippetGraph, false);\n+        if (replacementGraph != null) {\n+            InliningUtil.inline(invoke, replacementGraph, false);\n         }\n     }\n ",
      "parent_sha": "a73b3bc880ddc1e9d477d17ec41bf252d4be4ab8"
    }
  },
  {
    "oid": "43451f1e1dddd2fbc4a44310d279ca1593c6437a",
    "message": "Make java.UseBindingLoader option experimental.",
    "date": "2022-08-10T17:18:31Z",
    "url": "https://github.com/oracle/graal/commit/43451f1e1dddd2fbc4a44310d279ca1593c6437a",
    "details": {
      "sha": "9fb395cca2c9b7f8414cfb529f098b0dc5e2ef0b",
      "filename": "espresso/src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/EspressoOptions.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/oracle/graal/blob/43451f1e1dddd2fbc4a44310d279ca1593c6437a/espresso%2Fsrc%2Fcom.oracle.truffle.espresso%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fespresso%2FEspressoOptions.java",
      "raw_url": "https://github.com/oracle/graal/raw/43451f1e1dddd2fbc4a44310d279ca1593c6437a/espresso%2Fsrc%2Fcom.oracle.truffle.espresso%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fespresso%2FEspressoOptions.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/espresso%2Fsrc%2Fcom.oracle.truffle.espresso%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fespresso%2FEspressoOptions.java?ref=43451f1e1dddd2fbc4a44310d279ca1593c6437a",
      "patch": "@@ -473,7 +473,7 @@ public JDWPOptions apply(String s) {\n \n     @Option(help = \"Use Custom ClassLoader for Bindings, allowing the addition of new locations for loading.\", //\n                     category = OptionCategory.INTERNAL, //\n-                    stability = OptionStability.STABLE, //\n+                    stability = OptionStability.EXPERIMENTAL, //\n                     usageSyntax = \"false|true\") //\n     public static final OptionKey<Boolean> UseBindingsLoader = new OptionKey<>(false);\n ",
      "parent_sha": "b33927680b1f1ee7a7715bbbcbbc9d2962ac5fdf"
    }
  },
  {
    "oid": "3fd5336b2f4d872efa0cc39f4391354ceb019153",
    "message": "Small fixes in LLVMSmaxOperator and LLVMSminOperator",
    "date": "2022-04-14T14:30:48Z",
    "url": "https://github.com/oracle/graal/commit/3fd5336b2f4d872efa0cc39f4391354ceb019153",
    "details": {
      "sha": "00fe3e3dfb12d398bb676ac3c65c09cd6d5b0fed",
      "filename": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/nodes/intrinsics/c/LLVMCMathsIntrinsics.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/oracle/graal/blob/3fd5336b2f4d872efa0cc39f4391354ceb019153/sulong%2Fprojects%2Fcom.oracle.truffle.llvm.runtime%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fruntime%2Fnodes%2Fintrinsics%2Fc%2FLLVMCMathsIntrinsics.java",
      "raw_url": "https://github.com/oracle/graal/raw/3fd5336b2f4d872efa0cc39f4391354ceb019153/sulong%2Fprojects%2Fcom.oracle.truffle.llvm.runtime%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fruntime%2Fnodes%2Fintrinsics%2Fc%2FLLVMCMathsIntrinsics.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/sulong%2Fprojects%2Fcom.oracle.truffle.llvm.runtime%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fruntime%2Fnodes%2Fintrinsics%2Fc%2FLLVMCMathsIntrinsics.java?ref=3fd5336b2f4d872efa0cc39f4391354ceb019153",
      "patch": "@@ -894,7 +894,7 @@ protected int compare(int a, int b) {\n \n         @Override\n         protected long compare(long a, long b) {\n-            return Math.max(a, b) >= 0 ? a : b;\n+            return Math.max(a, b);\n         }\n \n         @Override\n@@ -918,12 +918,12 @@ protected boolean compare(boolean a, boolean b) {\n \n         @Override\n         protected int compare(int a, int b) {\n-            return Math.min(a, b) <= 0 ? a : b;\n+            return Math.min(a, b);\n         }\n \n         @Override\n         protected long compare(long a, long b) {\n-            return Math.min(a, b) <= 0 ? a : b;\n+            return Math.min(a, b);\n         }\n \n         @Override",
      "parent_sha": "c255c6e6c1353cec0cf09b2c6036906fd44f5d36"
    }
  },
  {
    "oid": "6a0cfecf8b273c54af96a4e0ee7a050e0f24454a",
    "message": "Fast path monitor enter/exit snippets",
    "date": "2023-10-20T20:30:23Z",
    "url": "https://github.com/oracle/graal/commit/6a0cfecf8b273c54af96a4e0ee7a050e0f24454a",
    "details": {
      "sha": "ca5d8afe687bdbfb4e6a7f073b0523fe4e9b8b74",
      "filename": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/monitor/MultiThreadedMonitorSupport.java",
      "status": "modified",
      "additions": 39,
      "deletions": 4,
      "changes": 43,
      "blob_url": "https://github.com/oracle/graal/blob/6a0cfecf8b273c54af96a4e0ee7a050e0f24454a/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2Fmonitor%2FMultiThreadedMonitorSupport.java",
      "raw_url": "https://github.com/oracle/graal/raw/6a0cfecf8b273c54af96a4e0ee7a050e0f24454a/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2Fmonitor%2FMultiThreadedMonitorSupport.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2Fmonitor%2FMultiThreadedMonitorSupport.java?ref=6a0cfecf8b273c54af96a4e0ee7a050e0f24454a",
      "patch": "@@ -72,7 +72,7 @@\n  * monitor slot because it would increase the size of every array and it is not possible to\n  * distinguish between arrays with different header sizes. See\n  * {@code UniverseBuilder.getImmutableTypes()} for details.\n- * \n+ *\n  * Synchronization on {@link String}, arrays, and other types not having a monitor slot fall back to\n  * a monitor stored in {@link #additionalMonitors}. Synchronization of such objects is very slow and\n  * not scaling well with more threads because the {@link #additionalMonitorsLock additional monitor\n@@ -196,8 +196,32 @@ private static void slowPathMonitorEnter(Object obj) {\n         StackOverflowCheck.singleton().makeYellowZoneAvailable();\n         VMOperationControl.guaranteeOkayToBlock(\"No Java synchronization must be performed within a VMOperation: if the object is already locked, the VM is deadlocked\");\n         try {\n-            singleton().monitorEnter(obj, MonitorInflationCause.MONITOR_ENTER);\n+            int monitorOffset = getMonitorOffset(obj);\n+            if (monitorOffset == 0) {\n+                // Slow path\n+                singleton().monitorEnter(obj, MonitorInflationCause.MONITOR_ENTER);\n+                return;\n+            }\n \n+            /*\n+             * Optimized path takes advantage of the knowledge that, when a new monitor object is\n+             * created, it is not shared with other threads, so we can set its state without CAS. It\n+             * also has acquisitions == 1 by construction, so we don't need to set that too.\n+             */\n+            long current = JavaMonitor.getCurrentThreadIdentity();\n+            JavaMonitor monitor = (JavaMonitor) BarrieredAccess.readObject(obj, monitorOffset);\n+            if (monitor == null) {\n+                long startTicks = JfrTicks.elapsedTicks();\n+                JavaMonitor newMonitor = newMonitorLock();\n+                newMonitor.setState(current);\n+                monitor = (JavaMonitor) UNSAFE.compareAndExchangeObject(obj, monitorOffset, null, newMonitor);\n+                if (monitor == null) {\n+                    JavaMonitorInflateEvent.emit(obj, startTicks, MonitorInflationCause.MONITOR_ENTER);\n+                    newMonitor.latestJfrTid = current;\n+                    return;\n+                }\n+            }\n+            monitor.monitorEnter(obj);\n         } catch (OutOfMemoryError ex) {\n             /*\n              * Exposing OutOfMemoryError to application. Note that since the foreign call from\n@@ -243,8 +267,19 @@ private static void slowPathMonitorExit(Object obj) {\n              * Monitor inflation cannot happen here because Graal enforces structured locking and\n              * unlocking, see comment below.\n              */\n-            singleton().monitorExit(obj, MonitorInflationCause.VM_INTERNAL);\n+            int monitorOffset = getMonitorOffset(obj);\n+            if (monitorOffset == 0) {\n+                // Slow path\n+                singleton().monitorExit(obj, MonitorInflationCause.VM_INTERNAL);\n+                return;\n+            }\n \n+            /*\n+             * Optimized path: we know that monitor object exists, due to structured locking, so\n+             * does not need to be created/inflated.\n+             */\n+            JavaMonitor monitor = (JavaMonitor) BarrieredAccess.readObject(obj, monitorOffset);\n+            monitor.monitorExit();\n         } catch (OutOfMemoryError ex) {\n             /*\n              * Exposing OutOfMemoryError to application. Note that since the foreign call from\n@@ -461,7 +496,7 @@ protected JavaMonitor getOrCreateMonitorFromMap(Object obj, boolean createIfNotE\n         }\n     }\n \n-    protected JavaMonitor newMonitorLock() {\n+    protected static JavaMonitor newMonitorLock() {\n         return new JavaMonitor();\n     }\n }",
      "parent_sha": "66482ac8bb7174cec24ae9f3c10695afcf22f316"
    }
  },
  {
    "oid": "b72dd5e5aac1d2faf6a401c3dc7d0ce5e1698bfd",
    "message": "We should only load SP from FP in old versions of HotSpot.",
    "date": "2016-12-02T18:59:46Z",
    "url": "https://github.com/oracle/graal/commit/b72dd5e5aac1d2faf6a401c3dc7d0ce5e1698bfd",
    "details": {
      "sha": "89095b3b40b8aa468c04efc90a53e4a8546994e9",
      "filename": "graal/com.oracle.graal.hotspot.aarch64/src/com/oracle/graal/hotspot/aarch64/AArch64HotSpotJumpToExceptionHandlerInCallerOp.java",
      "status": "modified",
      "additions": 12,
      "deletions": 9,
      "changes": 21,
      "blob_url": "https://github.com/oracle/graal/blob/b72dd5e5aac1d2faf6a401c3dc7d0ce5e1698bfd/graal%2Fcom.oracle.graal.hotspot.aarch64%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fhotspot%2Faarch64%2FAArch64HotSpotJumpToExceptionHandlerInCallerOp.java",
      "raw_url": "https://github.com/oracle/graal/raw/b72dd5e5aac1d2faf6a401c3dc7d0ce5e1698bfd/graal%2Fcom.oracle.graal.hotspot.aarch64%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fhotspot%2Faarch64%2FAArch64HotSpotJumpToExceptionHandlerInCallerOp.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.hotspot.aarch64%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fhotspot%2Faarch64%2FAArch64HotSpotJumpToExceptionHandlerInCallerOp.java?ref=b72dd5e5aac1d2faf6a401c3dc7d0ce5e1698bfd",
      "patch": "@@ -68,16 +68,19 @@ public AArch64HotSpotJumpToExceptionHandlerInCallerOp(AllocatableValue handlerIn\n     public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n         leaveFrame(crb, masm, /* emitSafepoint */false);\n \n-        // Restore sp from fp if the exception PC is a method handle call site.\n-        try (ScratchRegister sc = masm.getScratchRegister()) {\n-            Register scratch = sc.getRegister();\n-            AArch64Address address = masm.makeAddress(thread, isMethodHandleReturnOffset, scratch, 4, /* allowOverwrite */false);\n-            masm.ldr(32, scratch, address);\n-            Label noRestore = new Label();\n-            masm.cbz(32, scratch, noRestore);\n-            masm.mov(64, sp, fp);\n-            masm.bind(noRestore);\n+        if (System.getProperty(\"java.specification.version\").compareTo(\"1.8\") < 0) {\n+            // Restore sp from fp if the exception PC is a method handle call site.\n+            try (ScratchRegister sc = masm.getScratchRegister()) {\n+                Register scratch = sc.getRegister();\n+                AArch64Address address = masm.makeAddress(thread, isMethodHandleReturnOffset, scratch, 4, /* allowOverwrite */false);\n+                masm.ldr(32, scratch, address);\n+                Label noRestore = new Label();\n+                masm.cbz(32, scratch, noRestore);\n+                masm.mov(64, sp, fp);\n+                masm.bind(noRestore);\n+            }\n         }\n+\n         masm.jmp(asRegister(handlerInCallerPc));\n     }\n }",
      "parent_sha": "f56f8fb0d01a89ba2c25afcaa6feadb867ef7982"
    }
  },
  {
    "oid": "3be69be68217712ed5b4546618110902ec497873",
    "message": "minor comment update in ServiceLoaderFeature",
    "date": "2021-07-08T11:16:24Z",
    "url": "https://github.com/oracle/graal/commit/3be69be68217712ed5b4546618110902ec497873",
    "details": {
      "sha": "9a550cf97e32d48c0c4ef88c16514c2dfea29fcc",
      "filename": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/ServiceLoaderFeature.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/oracle/graal/blob/3be69be68217712ed5b4546618110902ec497873/substratevm%2Fsrc%2Fcom.oracle.svm.hosted%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fhosted%2FServiceLoaderFeature.java",
      "raw_url": "https://github.com/oracle/graal/raw/3be69be68217712ed5b4546618110902ec497873/substratevm%2Fsrc%2Fcom.oracle.svm.hosted%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fhosted%2FServiceLoaderFeature.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm%2Fsrc%2Fcom.oracle.svm.hosted%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fhosted%2FServiceLoaderFeature.java?ref=3be69be68217712ed5b4546618110902ec497873",
      "patch": "@@ -79,8 +79,7 @@\n  *\n  * For each service interface, a single service loader file is added as a resource to the image. The\n  * single file combines all the individual files that can come from different .jar files.\n- *\n- *\n+ * \n  * Unfortunately, state of the art module support in SVM is not sophisticated enough to allow the\n  * original ServiceLoader infrastructure to discover providers registered in modules. Therefore, as\n  * a temporary solution, we're disabling the ModuleServicesLookupIterator in favour of the",
      "parent_sha": "9f49a4df8fec8397cd6a468f7940ac115790f6e0"
    }
  },
  {
    "oid": "460e56baaf283c72502f70434c406a3c8b812f58",
    "message": "Remove leftover code from old LLVM expression parser.",
    "date": "2020-01-30T14:30:30Z",
    "url": "https://github.com/oracle/graal/commit/460e56baaf283c72502f70434c406a3c8b812f58",
    "details": {
      "sha": "13586f67f75c16cd7ccd82bf049e5f6f14aff3d4",
      "filename": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/LLVMLanguage.java",
      "status": "modified",
      "additions": 1,
      "deletions": 8,
      "changes": 9,
      "blob_url": "https://github.com/oracle/graal/blob/460e56baaf283c72502f70434c406a3c8b812f58/sulong%2Fprojects%2Fcom.oracle.truffle.llvm.runtime%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fruntime%2FLLVMLanguage.java",
      "raw_url": "https://github.com/oracle/graal/raw/460e56baaf283c72502f70434c406a3c8b812f58/sulong%2Fprojects%2Fcom.oracle.truffle.llvm.runtime%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fruntime%2FLLVMLanguage.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/sulong%2Fprojects%2Fcom.oracle.truffle.llvm.runtime%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fruntime%2FLLVMLanguage.java?ref=460e56baaf283c72502f70434c406a3c8b812f58",
      "patch": "@@ -241,14 +241,7 @@ protected void initializeContext(LLVMContext context) {\n     }\n \n     @Override\n-    protected ExecutableNode parse(InlineParsingRequest request) throws Exception {\n-        if (!Boolean.getBoolean(\"debugexpr.antlr\")) {\n-            return parseAntlr(request);\n-        }\n-        throw new IllegalStateException(\"The antlr parser is not enabled.\");\n-    }\n-\n-    private ExecutableNode parseAntlr(InlineParsingRequest request) {\n+    protected ExecutableNode parse(InlineParsingRequest request) {\n         Iterable<Scope> globalScopes = findTopScopes(getCurrentContext(LLVMLanguage.class));\n         final com.oracle.truffle.llvm.runtime.debug.debugexpr.parser.antlr.DebugExprParser d = new com.oracle.truffle.llvm.runtime.debug.debugexpr.parser.antlr.DebugExprParser(request, globalScopes,\n                         getCurrentContext(LLVMLanguage.class));",
      "parent_sha": "af4ef4b9b72799e318e9684a8f409e33a5217e55"
    }
  },
  {
    "oid": "11bbdef989ce595320dd240af5e3a620f7ea2058",
    "message": "Bump the supported class file version for JDK13",
    "date": "2019-01-02T17:56:06Z",
    "url": "https://github.com/oracle/graal/commit/11bbdef989ce595320dd240af5e3a620f7ea2058",
    "details": {
      "sha": "cd8fb23f9ac1f1c1916622630e67fb663bdd5881",
      "filename": "compiler/src/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/classfile/Classfile.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/oracle/graal/blob/11bbdef989ce595320dd240af5e3a620f7ea2058/compiler%2Fsrc%2Forg.graalvm.compiler.replacements%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Freplacements%2Fclassfile%2FClassfile.java",
      "raw_url": "https://github.com/oracle/graal/raw/11bbdef989ce595320dd240af5e3a620f7ea2058/compiler%2Fsrc%2Forg.graalvm.compiler.replacements%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Freplacements%2Fclassfile%2FClassfile.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/compiler%2Fsrc%2Forg.graalvm.compiler.replacements%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Freplacements%2Fclassfile%2FClassfile.java?ref=11bbdef989ce595320dd240af5e3a620f7ea2058",
      "patch": "@@ -49,7 +49,7 @@ public class Classfile {\n     private final List<ClassfileBytecode> codeAttributes;\n \n     private static final int MAJOR_VERSION_JAVA_MIN = 51; // JDK7\n-    private static final int MAJOR_VERSION_JAVA_MAX = 56; // JDK12\n+    private static final int MAJOR_VERSION_JAVA_MAX = 57; // JDK13\n     private static final int MAGIC = 0xCAFEBABE;\n \n     /**",
      "parent_sha": "ab426fd70e30026d6988d512d5afcd3cc29cd565"
    }
  },
  {
    "oid": "5ef9495c2a5848a78f44cedb19475f087e3ba11a",
    "message": "Read immutable objects through the shadow heap.",
    "date": "2023-11-18T11:18:42Z",
    "url": "https://github.com/oracle/graal/commit/5ef9495c2a5848a78f44cedb19475f087e3ba11a",
    "details": {
      "sha": "dd76230459fde25bc11a26f812ae2a567627a47e",
      "filename": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageHeap.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/oracle/graal/blob/5ef9495c2a5848a78f44cedb19475f087e3ba11a/substratevm%2Fsrc%2Fcom.oracle.svm.hosted%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fhosted%2Fimage%2FNativeImageHeap.java",
      "raw_url": "https://github.com/oracle/graal/raw/5ef9495c2a5848a78f44cedb19475f087e3ba11a/substratevm%2Fsrc%2Fcom.oracle.svm.hosted%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fhosted%2Fimage%2FNativeImageHeap.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm%2Fsrc%2Fcom.oracle.svm.hosted%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fhosted%2Fimage%2FNativeImageHeap.java?ref=5ef9495c2a5848a78f44cedb19475f087e3ba11a",
      "patch": "@@ -292,10 +292,10 @@ public void registerAsImmutable(Object root, Predicate<Object> includeObject) {\n                     addToWorklist(aUniverse.replaceObject(element), includeObject, worklist, registeredObjects);\n                 }\n             } else {\n-                JavaConstant constant = aUniverse.getSnippetReflection().forObject(cur);\n+                JavaConstant constant = hUniverse.getSnippetReflection().forObject(cur);\n                 for (HostedField field : hMetaAccess.lookupJavaType(constant).getInstanceFields(true)) {\n                     if (field.isAccessed() && field.getStorageKind() == JavaKind.Object) {\n-                        Object fieldValue = aUniverse.getSnippetReflection().asObject(Object.class, hConstantReflection.readFieldValue(field, constant));\n+                        Object fieldValue = hUniverse.getSnippetReflection().asObject(Object.class, hConstantReflection.readFieldValue(field, constant));\n                         addToWorklist(fieldValue, includeObject, worklist, registeredObjects);\n                     }\n                 }",
      "parent_sha": "d2b77d001ac49eeee95e540f11e185c744b641f0"
    }
  },
  {
    "oid": "d60a5fe34303459746b5b38f48b10655cce4c6e5",
    "message": "Document some Espresso JNI methods.",
    "date": "2018-12-11T17:29:53Z",
    "url": "https://github.com/oracle/graal/commit/d60a5fe34303459746b5b38f48b10655cce4c6e5",
    "details": {
      "sha": "bf647548ba69b4fc4cabbb28d37b0f4519c0ef74",
      "filename": "src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/jni/JniEnv.java",
      "status": "modified",
      "additions": 320,
      "deletions": 38,
      "changes": 358,
      "blob_url": "https://github.com/oracle/graal/blob/d60a5fe34303459746b5b38f48b10655cce4c6e5/src%2Fcom.oracle.truffle.espresso%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fespresso%2Fjni%2FJniEnv.java",
      "raw_url": "https://github.com/oracle/graal/raw/d60a5fe34303459746b5b38f48b10655cce4c6e5/src%2Fcom.oracle.truffle.espresso%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fespresso%2Fjni%2FJniEnv.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/src%2Fcom.oracle.truffle.espresso%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fespresso%2Fjni%2FJniEnv.java?ref=d60a5fe34303459746b5b38f48b10655cce4c6e5",
      "patch": "@@ -61,7 +61,6 @@\n import com.oracle.truffle.espresso.meta.Meta;\n import com.oracle.truffle.espresso.meta.MetaUtil;\n import com.oracle.truffle.espresso.nodes.VmNativeNode;\n-import com.oracle.truffle.espresso.runtime.EspressoContext;\n import com.oracle.truffle.espresso.runtime.EspressoException;\n import com.oracle.truffle.espresso.runtime.StaticObject;\n import com.oracle.truffle.espresso.runtime.StaticObjectArray;\n@@ -77,7 +76,6 @@ public class JniEnv extends NativeEnv {\n     public static final int JNI_COMMIT = 1;\n     public static final int JNI_ABORT = 2;\n \n-\n     public static final int JVM_INTERFACE_VERSION = 4;\n     public static final int JNI_TRUE = 1;\n     public static final int JNI_FALSE = 0;\n@@ -176,7 +174,6 @@ public Callback jniMethodWrapper(Method m) {\n         });\n     }\n \n-\n     public static String jniNativeSignature(Method method) {\n         StringBuilder sb = new StringBuilder(\"(\");\n         // Prepend JNIEnv* . The raw pointer will be substituted by the proper `this` reference.\n@@ -424,61 +421,188 @@ public void dispose() {\n         assert jniEnvPtr == 0L;\n     }\n \n+    /**\n+     * <h3>jint GetVersion(JNIEnv *env);</h3>\n+     *\n+     * Returns the version of the native method interface.\n+     *\n+     * @returns the major version number in the higher 16 bits and the minor version number in the\n+     *          lower 16 bits.\n+     *\n+     *          <b>Error codes</b>\n+     * \n+     *          <pre>\n+     * #define JNI_EDETACHED   (-2)             // thread detached from the VM\n+     * #define JNI_EVERSION    (-3)             // JNI version error\n+     *          </pre>\n+     */\n     @JniImpl\n     public int GetVersion() {\n         return JniVersion.JNI_VERSION_ESPRESSO;\n     }\n \n+    /**\n+     * <h3>jsize GetArrayLength(JNIEnv *env, jarray array);</h3>\n+     *\n+     * Returns the number of elements in the array.\n+     *\n+     * @param array a Java array object.\n+     *\n+     * @returns the length of the array.\n+     */\n     @JniImpl\n-    public int GetArrayLength(Object arr) {\n-        return EspressoLanguage.getCurrentContext().getInterpreterToVM().arrayLength(arr);\n+    public int GetArrayLength(Object array) {\n+        return EspressoLanguage.getCurrentContext().getInterpreterToVM().arrayLength(array);\n     }\n \n+    /**\n+     * <h3>jsize GetStringLength(JNIEnv *env, jstring string);</h3>\n+     *\n+     * Returns the length (the count of Unicode characters) of a Java string.\n+     *\n+     * @param string a Java string object.\n+     *\n+     * @returns the length of the Java string.\n+     */\n     @JniImpl\n-    public int GetStringLength(@Type(String.class) StaticObject str) {\n-        if (str == StaticObject.NULL) {\n+    public int GetStringLength(@Type(String.class) StaticObject string) {\n+        if (string == StaticObject.NULL) {\n             return 0;\n         }\n-        return (int) meta(str).method(\"length\", int.class).invokeDirect();\n+        return (int) meta(string).method(\"length\", int.class).invokeDirect();\n     }\n \n     // region Get*ID\n \n+    /**\n+     * <h3>jfieldID GetFieldID(JNIEnv *env, jclass clazz, const char *name, const char *sig);</h3>\n+     *\n+     * Returns the field ID for an instance (nonstatic) field of a class. The field is specified by\n+     * its name and signature. The Get<type>Field and Set<type>Field families of accessor functions\n+     * use field IDs to retrieve object fields. GetFieldID() causes an uninitialized class to be\n+     * initialized. GetFieldID() cannot be used to obtain the length field of an array. Use\n+     * GetArrayLength() instead.\n+     *\n+     * @param clazz a Java class object.\n+     * @param name the field name in a 0-terminated modified UTF-8 string.\n+     * @param signature the field signature in a 0-terminated modified UTF-8 string.\n+     * @return a field ID, or NULL if the operation fails.\n+     *\n+     * @throws NoSuchFieldError: if the specified field cannot be found.\n+     * @throws ExceptionInInitializerError: if the class initializer fails due to an exception.\n+     * @throws OutOfMemoryError: if the system runs out of memory.\n+     */\n     @JniImpl\n-    public long GetFieldID(StaticObjectClass clazz, String name, String signature) {\n-        clazz.getMirror().initialize();\n-        Meta.Field field = meta((clazz).getMirror()).declaredField(name);\n+    public long GetFieldID(@Type(Class.class) StaticObject clazz, String name, String signature) {\n+        Meta.Klass klass = meta(((StaticObjectClass) clazz).getMirror());\n+        klass.safeInitialize();\n+        Meta.Field field = klass.declaredField(name);\n+        if (field == null) {\n+            throw EspressoLanguage.getCurrentContext().getMeta().throwEx(NoSuchFieldError.class, name);\n+        }\n+        assert !field.isStatic();\n+        assert field.getType().getInternalName().equals(signature);\n         return fieldIds.handlify(field.rawField());\n     }\n \n+    /**\n+     * <h3>jfieldID GetStaticFieldID(JNIEnv *env, jclass clazz, const char *name, const char\n+     * *sig);</h3>\n+     *\n+     * Returns the field ID for a static field of a class. The field is specified by its name and\n+     * signature. The GetStatic<type>Field and SetStatic<type>Field families of accessor functions\n+     * use field IDs to retrieve static fields.\n+     *\n+     * GetStaticFieldID() causes an uninitialized class to be initialized.\n+     * \n+     * @param clazz a Java class object.\n+     * @param name the static field name in a 0-terminated modified UTF-8 string.\n+     * @param sig the field signature in a 0-terminated modified UTF-8 string.\n+     *\n+     * @returns a field ID, or NULL if the specified static field cannot be found.\n+     * @throws NoSuchFieldError if the specified static field cannot be found.\n+     * @throws ExceptionInInitializerError if the class initializer fails due to an exception.\n+     * @throws OutOfMemoryError if the system runs out of memory.\n+     */\n     @JniImpl\n-    public long GetStaticFieldID(StaticObjectClass clazz, String name, String signature) {\n-        clazz.getMirror().initialize();\n-        return fieldIds.handlify(meta((clazz).getMirror()).staticField(name).getField().rawField());\n+    public long GetStaticFieldID(@Type(Class.class) StaticObject clazz, String name, String sig) {\n+        Meta.Klass klass = meta(((StaticObjectClass) clazz).getMirror());\n+        klass.safeInitialize();\n+        Meta.Field field = klass.staticField(name).getField();\n+        if (field == null) {\n+            throw EspressoLanguage.getCurrentContext().getMeta().throwEx(NoSuchFieldError.class, name);\n+        }\n+        assert field.isStatic();\n+        assert field.getType().getInternalName().equals(sig);\n+        return fieldIds.handlify(field.rawField());\n     }\n \n+    /**\n+     * <h3>jmethodID GetMethodID(JNIEnv *env, jclass clazz, const char *name, const char *sig);</h3>\n+     *\n+     * Returns the method ID for an instance (nonstatic) method of a class or interface. The method\n+     * may be defined in one of the clazz\u2019s superclasses and inherited by clazz. The method is\n+     * determined by its name and signature.\n+     *\n+     * GetMethodID() causes an uninitialized class to be initialized.\n+     *\n+     * To obtain the method ID of a constructor, supply <init> as the method name and void (V) as\n+     * the return type.\n+     *\n+     * @param clazz a Java class object.\n+     * @param name the method name in a 0-terminated modified UTF-8 string.\n+     * @param sig the method signature in 0-terminated modified UTF-8 string.\n+     *\n+     * @returns a method ID, or NULL if the specified method cannot be found.\n+     *\n+     * @throws NoSuchMethodError if the specified method cannot be found.\n+     * @throws ExceptionInInitializerError if the class initializer fails due to an exception.\n+     * @throws OutOfMemoryError if the system runs out of memory.\n+     *\n+     */\n     @JniImpl\n-    public long GetMethodID(StaticObjectClass clazz, String name, String signature) {\n-        clazz.getMirror().initialize();\n-        Meta.Method[] methods = meta(clazz.getMirror()).methods(true);\n+    public long GetMethodID(@Type(Class.class) StaticObject clazz, String name, String sig) {\n+        Meta.Klass klass = meta(((StaticObjectClass) clazz).getMirror());\n+        klass.safeInitialize();\n+        Meta.Method[] methods = klass.methods(true);\n         for (Meta.Method m : methods) {\n-            if (m.getName().equals(name) && m.rawMethod().getSignature().toString().equals(signature)) {\n+            if (m.getName().equals(name) && m.rawMethod().getSignature().toString().equals(sig)) {\n                 return methodIds.handlify(m.rawMethod());\n             }\n         }\n-        throw new RuntimeException(\"Method \" + name + \" not found\");\n+        throw EspressoLanguage.getCurrentContext().getMeta().throwEx(NoSuchMethodError.class, name + sig);\n     }\n \n+    /**\n+     * <h3>jmethodID GetStaticMethodID(JNIEnv *env, jclass clazz, const char *name, const char\n+     * *sig);</h3>\n+     *\n+     * Returns the method ID for a static method of a class. The method is specified by its name and\n+     * signature.\n+     *\n+     * GetStaticMethodID() causes an uninitialized class to be initialized.\n+     *\n+     * @param clazz a Java class object.\n+     * @param name the static method name in a 0-terminated modified UTF-8 string.\n+     * @param sig the method signature in a 0-terminated modified UTF-8 string.\n+     *\n+     * @returns a method ID, or NULL if the operation fails.\n+     *\n+     * @throws NoSuchMethodError if the specified static method cannot be found. *\n+     * @throws ExceptionInInitializerError if the class initializer fails due to an exception.\n+     * @throws OutOfMemoryError if the system runs out of memory.\n+     */\n     @JniImpl\n-    public long GetStaticMethodID(StaticObjectClass clazz, String name, String signature) {\n-        clazz.getMirror().initialize();\n-        Meta.Method[] methods = meta(clazz.getMirror()).methods(false);\n+    public long GetStaticMethodID(@Type(Class.class) StaticObject clazz, String name, String sig) {\n+        Meta.Klass klass = meta(((StaticObjectClass) clazz).getMirror());\n+        klass.safeInitialize();\n+        Meta.Method[] methods = klass.methods(false);\n         for (Meta.Method m : methods) {\n-            if (m.getName().equals(name) && m.rawMethod().getSignature().toString().equals(signature)) {\n+            if (m.isStatic() && m.getName().equals(name) && m.rawMethod().getSignature().toString().equals(sig)) {\n                 return methodIds.handlify(m.rawMethod());\n             }\n         }\n-        throw new RuntimeException(\"Method \" + name + \" not found\");\n+        throw EspressoLanguage.getCurrentContext().getMeta().throwEx(NoSuchMethodError.class, name + sig);\n     }\n \n     // endregion Get*ID\n@@ -1099,26 +1223,108 @@ public StaticObject NewStringUTF(String str) {\n         return EspressoLanguage.getCurrentContext().getMeta().toGuest(str);\n     }\n \n+    /**\n+     * <h3>jclass FindClass(JNIEnv *env, const char *name);</h3>\n+     *\n+     * <p>\n+     * FindClass locates the class loader associated with the current native method; that is, the\n+     * class loader of the class that declared the native method. If the native method belongs to a\n+     * system class, no class loader will be involved. Otherwise, the proper class loader will be\n+     * invoked to load and link the named class. Since Java 2 SDK release 1.2, when FindClass is\n+     * called through the Invocation Interface, there is no current native method or its associated\n+     * class loader. In that case, the result of {@link ClassLoader#getSystemClassLoader} is used.\n+     * This is the class loader the virtual machine creates for applications, and is able to locate\n+     * classes listed in the java.class.path property. The name argument is a fully-qualified class\n+     * name or an array type signature .\n+     * <p>\n+     * For example, the fully-qualified class name for the {@code java.lang.String} class is:\n+     *\n+     * <pre>\n+     * \"java/lang/String\"}\n+     * </pre>\n+     *\n+     * <p>\n+     * The array type signature of the array class {@code java.lang.Object[]} is:\n+     *\n+     * <pre>\n+     * \"[Ljava/lang/Object;\"\n+     * </pre>\n+     *\n+     * @param name a fully-qualified class name (that is, a package name, delimited by \"/\", followed\n+     *            by the class name). If the name begins with \"[\" (the array signature character),\n+     *            it returns an array class. The string is encoded in modified UTF-8.\n+     *\n+     * @return Returns a class object from a fully-qualified name, or NULL if the class cannot be\n+     *         found.\n+     *\n+     * @throws ClassFormatError if the class data does not specify a valid class.\n+     * @throws ClassCircularityError if a class or interface would be its own superclass or\n+     *             superinterface.\n+     * @throws NoClassDefFoundError if no definition for a requested class or interface can be\n+     *             found.\n+     * @throws OutOfMemoryError if the system runs out of memory.\n+     */\n     @JniImpl\n     public StaticObject FindClass(String name) {\n         Meta meta = EspressoLanguage.getCurrentContext().getMeta();\n         StaticObject internalName = meta.toGuest(MetaUtil.toInternalName(name));\n         return (StaticObject) meta.knownKlass(Class.class).staticMethod(\"forName\", Class.class, String.class).invokeDirect(internalName);\n     }\n \n+    /**\n+     * <h3>jobject NewLocalRef(JNIEnv *env, jobject ref);</h3>\n+     *\n+     * Creates a new local reference that refers to the same object as ref. The given ref may be a\n+     * global or local reference. Returns NULL if ref refers to null.\n+     */\n     @JniImpl\n-    public Object NewLocalRef(Object obj) {\n+    public Object NewLocalRef(Object ref) {\n         // Local ref is allocated by host JNI on return.\n-        return obj;\n+        return ref;\n     }\n \n+    /**\n+     * <h3>jboolean ExceptionCheck(JNIEnv *env);</h3>\n+     * \n+     * A convenience function to check for pending exceptions without creating a local reference to\n+     * the exception object.\n+     *\n+     * @returns JNI_TRUE when there is a pending exception; otherwise, returns JNI_FALSE.\n+     */\n     @JniImpl\n     public boolean ExceptionCheck() {\n         StaticObject ex = threadLocalPendingException.get();\n         assert ex != StaticObject.NULL;\n         return ex != null;\n     }\n \n+    /**\n+     * <h3>void ExceptionClear(JNIEnv *env);</h3>\n+     *\n+     * Clears any exception that is currently being thrown. If no exception is currently being\n+     * thrown, this routine has no effect.\n+     */\n+    @JniImpl\n+    public void ExceptionClear() {\n+        getThreadLocalPendingException().clear();\n+    }\n+\n+    /**\n+     * <h3>const jchar * GetStringCritical(JNIEnv *env, jstring string, jboolean *isCopy);</h3>\n+     *\n+     * The semantics of these two functions are similar to the existing Get/ReleaseStringChars\n+     * functions. If possible, the VM returns a pointer to string elements; otherwise, a copy is\n+     * made.\n+     *\n+     * <p>\n+     * However, there are significant restrictions on how these functions can be used. In a code\n+     * segment enclosed by Get/ReleaseStringCritical calls, the native code must not issue arbitrary\n+     * JNI calls, or cause the current thread to block.\n+     *\n+     * <p>\n+     * The restrictions on Get/ReleaseStringCritical are similar to those on\n+     * Get/ReleasePrimitiveArrayCritical.\n+     */\n     @JniImpl\n     public long GetStringCritical(@Type(String.class) StaticObject str, long isCopyPtr) {\n         if (isCopyPtr != 0L) {\n@@ -1180,22 +1386,55 @@ public void DeleteLocalRef(Object localRef) {\n         // nop\n     }\n \n+    /**\n+     * <h3>jint Throw(JNIEnv *env, jthrowable obj);</h3>\n+     *\n+     * Causes a {@link java.lang.Throwable} object to be thrown.\n+     *\n+     * @param obj a {@link java.lang.Throwable} object.\n+     *\n+     * @returns 0 on success; a negative value on failure.\n+     */\n     @JniImpl\n-    public int Throw(StaticObject ex) {\n+    public int Throw(@Type(Throwable.class) StaticObject obj) {\n         assert EspressoLanguage.getCurrentContext().getMeta() //\n-                        .THROWABLE.isAssignableFrom(meta(ex.getKlass()));\n-\n-        threadLocalPendingException.set(ex);\n-        return JNI_OK;\n+                        .THROWABLE.isAssignableFrom(meta(obj.getKlass()));\n+        // The TLS exception slot will be set by the JNI wrapper.\n+        // Throwing methods always return the default value, in this case 0 (success).\n+        throw new EspressoException(obj);\n     }\n \n+    /**\n+     * <h3>jint ThrowNew(JNIEnv *env, jclass clazz, const char *message);</h3>\n+     *\n+     * Constructs an exception object from the specified class with the message specified by message\n+     * and causes that exception to be thrown.\n+     *\n+     * @param clazz a subclass of java.lang.Throwable.\n+     * @param message the message used to construct the {@link java.lang.Throwable} object. The\n+     *            string is encoded in modified UTF-8.\n+     *\n+     * @returns 0 on success; a negative value on failure.\n+     *\n+     * @throws Exception the newly constructed {@link java.lang.Throwable} object.\n+     */\n     @JniImpl\n-    public int ThrowNew(@Type(Class.class) StaticObjectClass clazz, String message) {\n-        StaticObject ex = meta(clazz).getMeta().initEx(meta(clazz.getKlass()), message);\n-        threadLocalPendingException.set(ex);\n-        return JNI_OK;\n+    public int ThrowNew(@Type(Class.class) StaticObject clazz, String message) {\n+        StaticObject ex = EspressoLanguage.getCurrentContext().getMeta().initEx(meta(clazz.getKlass()), message);\n+        // The TLS exception slot will be set by the JNI wrapper.\n+        // Throwing methods always return the default value, in this case 0 (success).\n+        throw new EspressoException(ex);\n     }\n \n+    /**\n+     * <h3>jthrowable ExceptionOccurred(JNIEnv *env);</h3>\n+     *\n+     * Determines if an exception is being thrown. The exception stays being thrown until either the\n+     * native code calls {@link #ExceptionClear}, or the Java code handles the exception.\n+     *\n+     * @returns the exception object that is currently in the process of being thrown, or NULL if no\n+     *          exception is currently being thrown.\n+     */\n     @JniImpl\n     public StaticObject ExceptionOccurred() {\n         StaticObject ex = threadLocalPendingException.get();\n@@ -1300,10 +1539,12 @@ public void GetStringUTFRegion(@Type(String.class) StaticObject str, int start,\n     }\n \n     /**\n-     * Loads a class from a buffer of raw class data. The buffer containing the raw class data is not\n-     * referenced by the VM after the DefineClass call returns, and it may be discarded if desired.\n+     * Loads a class from a buffer of raw class data. The buffer containing the raw class data is\n+     * not referenced by the VM after the DefineClass call returns, and it may be discarded if\n+     * desired.\n      *\n-     * @param name the name of the class or interface to be defined. The string is encoded in modified UTF-8.\n+     * @param name the name of the class or interface to be defined. The string is encoded in\n+     *            modified UTF-8.\n      * @param loader a class loader assigned to the defined class.\n      * @param bufPtr buffer containing the .class file data.\n      * @param bufLen buffer length.\n@@ -1324,4 +1565,45 @@ public int GetJavaVM(long vmPtr) {\n         buf.putLong(EspressoLanguage.getCurrentContext().getVM().getJavaVM());\n         return JNI_OK;\n     }\n+\n+    /**\n+     * <h3>jboolean IsAssignableFrom(JNIEnv *env, jclass clazz1, jclass clazz2);</h3>\n+     *\n+     * Determines whether an object of clazz1 can be safely cast to clazz2.\n+     *\n+     * @param clazz1: the first class argument.\n+     * @param clazz2 the second class argument.\n+     *\n+     * @returns Returns JNI_TRUE if either of the following is true:\n+     *          <ul>\n+     *          <li>The first and second class arguments refer to the same Java class.\n+     *          <li>The first class is a subclass of the second class.\n+     *          <li>The first class has the second class as one of its interfaces.\n+     *          </ul>\n+     */\n+    @JniImpl\n+    public boolean IsAssignableFrom(@Type(Class.class) StaticObject clazz1, @Type(Class.class) StaticObject clazz2) {\n+        Meta.Klass klass = Meta.meta(((StaticObjectClass) clazz2).getMirror());\n+        return klass.isAssignableFrom(Meta.meta(((StaticObjectClass) clazz1).getMirror()));\n+    }\n+\n+    /**\n+     * <h3>jboolean IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz);</h3>\n+     *\n+     * Tests whether an object is an instance of a class.\n+     *\n+     * @param obj a Java object.\n+     * @param clazz a Java class object.\n+     *\n+     * @returns Returns {@code JNI_TRUE} if obj can be cast to clazz; otherwise, returns\n+     *          {@code JNI_FALSE}. <b>A NULL object can be cast to any class.</b>\n+     */\n+    @JniImpl\n+    public boolean IsInstanceOf(Object obj, @Type(Class.class) StaticObjectClass clazz) {\n+        if (obj == StaticObject.NULL) {\n+            return true;\n+        }\n+        return EspressoLanguage.getCurrentContext().getInterpreterToVM().instanceOf(obj, clazz.getMirror());\n+    }\n+\n }",
      "parent_sha": "e6ab28b97f2f52569c8de9076232defdbc9a5cb2"
    }
  },
  {
    "oid": "1a3d5f4e1a4dc24d5a28f67e71487aa0895ba077",
    "message": "Conservatively assume the CPU has Intel JCC erratum if VM_Version::_has_intel_jcc_erratum does not exist.",
    "date": "2020-03-31T08:17:41Z",
    "url": "https://github.com/oracle/graal/commit/1a3d5f4e1a4dc24d5a28f67e71487aa0895ba077",
    "details": {
      "sha": "5136d57f83044d2f14f67bcf7828ca6ffba15dad",
      "filename": "compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/GraalHotSpotVMConfig.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/oracle/graal/blob/1a3d5f4e1a4dc24d5a28f67e71487aa0895ba077/compiler%2Fsrc%2Forg.graalvm.compiler.hotspot%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Fhotspot%2FGraalHotSpotVMConfig.java",
      "raw_url": "https://github.com/oracle/graal/raw/1a3d5f4e1a4dc24d5a28f67e71487aa0895ba077/compiler%2Fsrc%2Forg.graalvm.compiler.hotspot%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Fhotspot%2FGraalHotSpotVMConfig.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/compiler%2Fsrc%2Forg.graalvm.compiler.hotspot%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Fhotspot%2FGraalHotSpotVMConfig.java?ref=1a3d5f4e1a4dc24d5a28f67e71487aa0895ba077",
      "patch": "@@ -897,7 +897,7 @@ private boolean checkNullAllocationStubs() {\n     public final int MARKID_CARD_TABLE_ADDRESS = getConstant(\"CodeInstaller::CARD_TABLE_ADDRESS\", Integer.class);\n     public final int MARKID_INVOKE_INVALID = getConstant(\"CodeInstaller::INVOKE_INVALID\", Integer.class);\n \n-    public final boolean CPU_HAS_INTEL_JCC_ERRATUM = getFieldValue(\"VM_Version::_has_intel_jcc_erratum\", Boolean.class, \"bool\", false);\n+    public final boolean CPU_HAS_INTEL_JCC_ERRATUM = getFieldValue(\"VM_Version::_has_intel_jcc_erratum\", Boolean.class, \"bool\", true);\n \n     /**\n      * The following constants are given default values here since they are missing in the native",
      "parent_sha": "04fa54153cb4ffb798bd51ef07063f08eb5fb3a4"
    }
  },
  {
    "oid": "cd2eb4e9b07e063018b2bd382c3069d50687320e",
    "message": "fixed misspelling",
    "date": "2020-08-24T18:57:02Z",
    "url": "https://github.com/oracle/graal/commit/cd2eb4e9b07e063018b2bd382c3069d50687320e",
    "details": {
      "sha": "15e4d9558f1f46ba722cc496fbc68badf1675d1d",
      "filename": "tools/src/org.graalvm.tools.lsp/src/org/graalvm/tools/lsp/server/types/ResponseErrorLiteral.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/oracle/graal/blob/cd2eb4e9b07e063018b2bd382c3069d50687320e/tools%2Fsrc%2Forg.graalvm.tools.lsp%2Fsrc%2Forg%2Fgraalvm%2Ftools%2Flsp%2Fserver%2Ftypes%2FResponseErrorLiteral.java",
      "raw_url": "https://github.com/oracle/graal/raw/cd2eb4e9b07e063018b2bd382c3069d50687320e/tools%2Fsrc%2Forg.graalvm.tools.lsp%2Fsrc%2Forg%2Fgraalvm%2Ftools%2Flsp%2Fserver%2Ftypes%2FResponseErrorLiteral.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/tools%2Fsrc%2Forg.graalvm.tools.lsp%2Fsrc%2Forg%2Fgraalvm%2Ftools%2Flsp%2Fserver%2Ftypes%2FResponseErrorLiteral.java?ref=cd2eb4e9b07e063018b2bd382c3069d50687320e",
      "patch": "@@ -34,7 +34,7 @@ public class ResponseErrorLiteral extends JSONBase {\n     }\n \n     /**\n-     * A number indicating the error type that occured.\n+     * A number indicating the error type that occurred.\n      */\n     public int getCode() {\n         return jsonData.getInt(\"code\");",
      "parent_sha": "32ded591543dc74e88f127a607868b864c52a196"
    }
  },
  {
    "oid": "ab4365113da3d10536a547baa8e9c035cf6ffd22",
    "message": "Treat deref handles in 'LLVMLoadVectorNode'.",
    "date": "2018-04-17T09:46:23Z",
    "url": "https://github.com/oracle/graal/commit/ab4365113da3d10536a547baa8e9c035cf6ffd22",
    "details": {
      "sha": "f007bd7d116534fa8073159c8179ebb6d6f7638d",
      "filename": "projects/com.oracle.truffle.llvm.nodes/src/com/oracle/truffle/llvm/nodes/memory/load/LLVMLoadVectorNode.java",
      "status": "modified",
      "additions": 63,
      "deletions": 28,
      "changes": 91,
      "blob_url": "https://github.com/oracle/graal/blob/ab4365113da3d10536a547baa8e9c035cf6ffd22/projects%2Fcom.oracle.truffle.llvm.nodes%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fnodes%2Fmemory%2Fload%2FLLVMLoadVectorNode.java",
      "raw_url": "https://github.com/oracle/graal/raw/ab4365113da3d10536a547baa8e9c035cf6ffd22/projects%2Fcom.oracle.truffle.llvm.nodes%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fnodes%2Fmemory%2Fload%2FLLVMLoadVectorNode.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/projects%2Fcom.oracle.truffle.llvm.nodes%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fnodes%2Fmemory%2Fload%2FLLVMLoadVectorNode.java?ref=ab4365113da3d10536a547baa8e9c035cf6ffd22",
      "patch": "@@ -68,7 +68,7 @@ protected LLVMI1Vector doI1Vector(LLVMAddress addr) {\n         }\n \n         @Specialization(guards = \"isAutoDerefHandle(addr)\")\n-        protected LLVMI1Vector doI32DerefHandle(LLVMAddress addr,\n+        protected LLVMI1Vector doI1VectorDerefHandle(LLVMAddress addr,\n                         @Cached(\"createForeignReads()\") LLVMForeignReadNode[] foreignReads) {\n             return doForeign(getDerefHandleGetReceiverNode().execute(addr), foreignReads);\n         }\n@@ -110,10 +110,15 @@ protected LLVMI8Vector doI8Vector(LLVMGlobal addr,\n             return memory.getI8Vector(globalAccess.executeWithTarget(addr), getSize());\n         }\n \n-        @Specialization\n-        protected LLVMI8Vector doI8Vector(LLVMAddress addr,\n-                        @Cached(\"getLLVMMemory()\") LLVMMemory memory) {\n-            return memory.getI8Vector(addr, getSize());\n+        @Specialization(guards = \"!isAutoDerefHandle(addr)\")\n+        protected LLVMI8Vector doI8Vector(LLVMAddress addr) {\n+            return getLLVMMemoryCached().getI8Vector(addr, getSize());\n+        }\n+\n+        @Specialization(guards = \"isAutoDerefHandle(addr)\")\n+        protected LLVMI8Vector doI8VectorDerefHandle(LLVMAddress addr,\n+                        @Cached(\"createForeignReads()\") LLVMForeignReadNode[] foreignReads) {\n+            return doForeign(getDerefHandleGetReceiverNode().execute(addr), foreignReads);\n         }\n \n         @Specialization(guards = \"addr.isNative()\")\n@@ -148,10 +153,15 @@ protected LLVMI16Vector doI16Vector(LLVMGlobal addr,\n             return memory.getI16Vector(globalAccess.executeWithTarget(addr), getSize());\n         }\n \n-        @Specialization\n-        protected LLVMI16Vector doI16Vector(LLVMAddress addr,\n-                        @Cached(\"getLLVMMemory()\") LLVMMemory memory) {\n-            return memory.getI16Vector(addr, getSize());\n+        @Specialization(guards = \"!isAutoDerefHandle(addr)\")\n+        protected LLVMI16Vector doI16Vector(LLVMAddress addr) {\n+            return getLLVMMemoryCached().getI16Vector(addr, getSize());\n+        }\n+\n+        @Specialization(guards = \"isAutoDerefHandle(addr)\")\n+        protected LLVMI16Vector doI16VectorDerefHandle(LLVMAddress addr,\n+                        @Cached(\"createForeignReads()\") LLVMForeignReadNode[] foreignReads) {\n+            return doForeign(getDerefHandleGetReceiverNode().execute(addr), foreignReads);\n         }\n \n         @Specialization(guards = \"addr.isNative()\")\n@@ -186,10 +196,15 @@ protected LLVMI32Vector doI32Vector(LLVMGlobal addr,\n             return memory.getI32Vector(globalAccess.executeWithTarget(addr), getSize());\n         }\n \n-        @Specialization\n-        protected LLVMI32Vector doI32Vector(LLVMAddress addr,\n-                        @Cached(\"getLLVMMemory()\") LLVMMemory memory) {\n-            return memory.getI32Vector(addr, getSize());\n+        @Specialization(guards = \"!isAutoDerefHandle(addr)\")\n+        protected LLVMI32Vector doI32Vector(LLVMAddress addr) {\n+            return getLLVMMemoryCached().getI32Vector(addr, getSize());\n+        }\n+\n+        @Specialization(guards = \"isAutoDerefHandle(addr)\")\n+        protected LLVMI32Vector doI32VectorDerefHandle(LLVMAddress addr,\n+                        @Cached(\"createForeignReads()\") LLVMForeignReadNode[] foreignReads) {\n+            return doForeign(getDerefHandleGetReceiverNode().execute(addr), foreignReads);\n         }\n \n         @Specialization(guards = \"addr.isNative()\")\n@@ -224,10 +239,15 @@ protected LLVMI64Vector doI64Vector(LLVMGlobal addr,\n             return memory.getI64Vector(globalAccess.executeWithTarget(addr), getSize());\n         }\n \n-        @Specialization\n-        protected LLVMI64Vector doI64Vector(LLVMAddress addr,\n-                        @Cached(\"getLLVMMemory()\") LLVMMemory memory) {\n-            return memory.getI64Vector(addr, getSize());\n+        @Specialization(guards = \"!isAutoDerefHandle(addr)\")\n+        protected LLVMI64Vector doI64Vector(LLVMAddress addr) {\n+            return getLLVMMemoryCached().getI64Vector(addr, getSize());\n+        }\n+\n+        @Specialization(guards = \"isAutoDerefHandle(addr)\")\n+        protected LLVMI64Vector doI64VectorDerefHandle(LLVMAddress addr,\n+                        @Cached(\"createForeignReads()\") LLVMForeignReadNode[] foreignReads) {\n+            return doForeign(getDerefHandleGetReceiverNode().execute(addr), foreignReads);\n         }\n \n         @Specialization(guards = \"addr.isNative()\")\n@@ -262,10 +282,15 @@ protected LLVMFloatVector doFloatVector(LLVMGlobal addr,\n             return memory.getFloatVector(globalAccess.executeWithTarget(addr), getSize());\n         }\n \n-        @Specialization\n-        protected LLVMFloatVector doFloatVector(LLVMAddress addr,\n-                        @Cached(\"getLLVMMemory()\") LLVMMemory memory) {\n-            return memory.getFloatVector(addr, getSize());\n+        @Specialization(guards = \"!isAutoDerefHandle(addr)\")\n+        protected LLVMFloatVector doFloatVector(LLVMAddress addr) {\n+            return getLLVMMemoryCached().getFloatVector(addr, getSize());\n+        }\n+\n+        @Specialization(guards = \"isAutoDerefHandle(addr)\")\n+        protected LLVMFloatVector doFloatVectorDerefHandle(LLVMAddress addr,\n+                        @Cached(\"createForeignReads()\") LLVMForeignReadNode[] foreignReads) {\n+            return doForeign(getDerefHandleGetReceiverNode().execute(addr), foreignReads);\n         }\n \n         @Specialization(guards = \"addr.isNative()\")\n@@ -300,10 +325,15 @@ protected LLVMDoubleVector doDoubleVector(LLVMGlobal addr,\n             return memory.getDoubleVector(globalAccess.executeWithTarget(addr), getSize());\n         }\n \n-        @Specialization\n+        @Specialization(guards = \"!isAutoDerefHandle(addr)\")\n+        protected LLVMDoubleVector doDoubleVector(LLVMAddress addr) {\n+            return getLLVMMemoryCached().getDoubleVector(addr, getSize());\n+        }\n+\n+        @Specialization(guards = \"isAutoDerefHandle(addr)\")\n         protected LLVMDoubleVector doDoubleVector(LLVMAddress addr,\n-                        @Cached(\"getLLVMMemory()\") LLVMMemory memory) {\n-            return memory.getDoubleVector(addr, getSize());\n+                        @Cached(\"createForeignReads()\") LLVMForeignReadNode[] foreignReads) {\n+            return doForeign(getDerefHandleGetReceiverNode().execute(addr), foreignReads);\n         }\n \n         @Specialization(guards = \"addr.isNative()\")\n@@ -338,10 +368,15 @@ protected LLVMAddressVector doAddressVector(LLVMGlobal addr,\n             return memory.getAddressVector(globalAccess.executeWithTarget(addr), getSize());\n         }\n \n-        @Specialization\n-        protected LLVMAddressVector doAddressVector(LLVMAddress addr,\n-                        @Cached(\"getLLVMMemory()\") LLVMMemory memory) {\n-            return memory.getAddressVector(addr, getSize());\n+        @Specialization(guards = \"!isAutoDerefHandle(addr)\")\n+        protected LLVMAddressVector doAddressVector(LLVMAddress addr) {\n+            return getLLVMMemoryCached().getAddressVector(addr, getSize());\n+        }\n+\n+        @Specialization(guards = \"isAutoDerefHandle(addr)\")\n+        protected Object doAddressVectorDerefHandle(LLVMAddress addr,\n+                        @Cached(\"createForeignReads()\") LLVMForeignReadNode[] foreignReads) {\n+            return doForeign(getDerefHandleGetReceiverNode().execute(addr), foreignReads);\n         }\n \n         @Specialization(guards = \"addr.isNative()\")",
      "parent_sha": "781a34b3beacc01ffe3334cee41a599b052f47a0"
    }
  },
  {
    "oid": "28c28fbd27a9cb829c447c3428f5a39a73f2f57f",
    "message": "Enable SpawnIsolates on LLVM backend by default",
    "date": "2023-01-13T12:51:55Z",
    "url": "https://github.com/oracle/graal/commit/28c28fbd27a9cb829c447c3428f5a39a73f2f57f",
    "details": {
      "sha": "b4811a2be9c791013a8fa0d308919de066b802ea",
      "filename": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java",
      "status": "modified",
      "additions": 1,
      "deletions": 19,
      "changes": 20,
      "blob_url": "https://github.com/oracle/graal/blob/28c28fbd27a9cb829c447c3428f5a39a73f2f57f/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2FSubstrateOptions.java",
      "raw_url": "https://github.com/oracle/graal/raw/28c28fbd27a9cb829c447c3428f5a39a73f2f57f/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2FSubstrateOptions.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2FSubstrateOptions.java?ref=28c28fbd27a9cb829c447c3428f5a39a73f2f57f",
      "patch": "@@ -336,25 +336,7 @@ protected void onValueUpdate(EconomicMap<OptionKey<?>, Object> values, Boolean o\n     public static final HostedOptionKey<Boolean> ForceNoROSectionRelocations = new HostedOptionKey<>(false);\n \n     @Option(help = \"Support multiple isolates.\") //\n-    public static final HostedOptionKey<Boolean> SpawnIsolates = new HostedOptionKey<>(null) {\n-        @Override\n-        public Boolean getValueOrDefault(UnmodifiableEconomicMap<OptionKey<?>, Object> values) {\n-            if (!values.containsKey(this)) {\n-                /*\n-                 * With the LLVM backend, isolate support has a significant performance cost, so we\n-                 * disable it unless it is explicitly enabled.\n-                 */\n-                return !useLLVMBackend();\n-            }\n-            return (Boolean) values.get(this);\n-        }\n-\n-        @Override\n-        public Boolean getValue(OptionValues values) {\n-            assert checkDescriptorExists();\n-            return getValueOrDefault(values.getMap());\n-        }\n-    };\n+    public static final HostedOptionKey<Boolean> SpawnIsolates = new HostedOptionKey<>(true);\n \n     @Option(help = \"At CEntryPoints check that the passed IsolateThread is valid.\") //\n     public static final HostedOptionKey<Boolean> CheckIsolateThreadAtEntry = new HostedOptionKey<>(false);",
      "parent_sha": "0088f4a8d8ca92096ea799c3cf4311b6b9d87af1"
    }
  },
  {
    "oid": "6ddb21cdebd87c9af0b95cd732dc3b276495d7e5",
    "message": "Fix after another rebase.",
    "date": "2024-01-25T14:16:07Z",
    "url": "https://github.com/oracle/graal/commit/6ddb21cdebd87c9af0b95cd732dc3b276495d7e5",
    "details": {
      "sha": "184a84e1cdf2e2f0609cefb144e7ceb0f4de1513",
      "filename": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jfr/sampler/JfrRecurringCallbackExecutionSampler.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/oracle/graal/blob/6ddb21cdebd87c9af0b95cd732dc3b276495d7e5/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2Fjfr%2Fsampler%2FJfrRecurringCallbackExecutionSampler.java",
      "raw_url": "https://github.com/oracle/graal/raw/6ddb21cdebd87c9af0b95cd732dc3b276495d7e5/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2Fjfr%2Fsampler%2FJfrRecurringCallbackExecutionSampler.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2Fjfr%2Fsampler%2FJfrRecurringCallbackExecutionSampler.java?ref=6ddb21cdebd87c9af0b95cd732dc3b276495d7e5",
      "patch": "@@ -30,6 +30,7 @@\n import java.util.Collections;\n import java.util.List;\n \n+import com.oracle.svm.core.jfr.JfrExecutionSamplerSupported;\n import org.graalvm.nativeimage.CurrentIsolate;\n import org.graalvm.nativeimage.ImageSingletons;\n import org.graalvm.nativeimage.IsolateThread;\n@@ -44,7 +45,6 @@\n import com.oracle.svm.core.Uninterruptible;\n import com.oracle.svm.core.feature.AutomaticallyRegisteredFeature;\n import com.oracle.svm.core.feature.InternalFeature;\n-import com.oracle.svm.core.jfr.JfrExecutionSamplerSupported;\n import com.oracle.svm.core.jfr.JfrFeature;\n import com.oracle.svm.core.jfr.SubstrateJVM;\n import com.oracle.svm.core.thread.ThreadListenerSupport;\n@@ -108,7 +108,6 @@ private static void install(IsolateThread thread, RecurringCallbackTimer callbac\n \n     @Override\n     @Uninterruptible(reason = \"Prevent VM operations that modify the recurring callbacks.\")\n-    @Override\n     protected void uninstall(IsolateThread thread) {\n         assert thread == CurrentIsolate.getCurrentThread() || VMOperation.isInProgressAtSafepoint();\n ",
      "parent_sha": "b3f1794331463ad4429cd7661761d8f620a7df1e"
    }
  },
  {
    "oid": "4e64adfe6b5b7e497455f6d472377279f15fcad3",
    "message": "Optimize HotSpotCompiledCodeBuilder.getSortedSites()",
    "date": "2018-09-03T15:39:21Z",
    "url": "https://github.com/oracle/graal/commit/4e64adfe6b5b7e497455f6d472377279f15fcad3",
    "details": {
      "sha": "18b0fda10dae8b519c8c16a22ab1a9e69f697f25",
      "filename": "compiler/src/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/HotSpotCompiledCodeBuilder.java",
      "status": "modified",
      "additions": 53,
      "deletions": 10,
      "changes": 63,
      "blob_url": "https://github.com/oracle/graal/blob/4e64adfe6b5b7e497455f6d472377279f15fcad3/compiler%2Fsrc%2Forg.graalvm.compiler.hotspot%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Fhotspot%2FHotSpotCompiledCodeBuilder.java",
      "raw_url": "https://github.com/oracle/graal/raw/4e64adfe6b5b7e497455f6d472377279f15fcad3/compiler%2Fsrc%2Forg.graalvm.compiler.hotspot%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Fhotspot%2FHotSpotCompiledCodeBuilder.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/compiler%2Fsrc%2Forg.graalvm.compiler.hotspot%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Fhotspot%2FHotSpotCompiledCodeBuilder.java?ref=4e64adfe6b5b7e497455f6d472377279f15fcad3",
      "patch": "@@ -33,6 +33,7 @@\n import java.util.Comparator;\n import java.util.EnumMap;\n import java.util.List;\n+import java.util.ListIterator;\n import java.util.Map;\n import java.util.stream.Stream;\n import java.util.stream.Stream.Builder;\n@@ -220,32 +221,73 @@ private static Site[] getSortedSites(CodeCacheProvider codeCache, CompilationRes\n              * results and corresponds with what C1 and C2 do. HotSpot doesn't like to see these\n              * unless -XX:+DebugNonSafepoints is enabled, so don't emit them in that case.\n              */\n-            List<Site> sourcePositionSites = new ArrayList<>();\n+\n+            List<SourceMapping> sourceMappings = new ArrayList<>();\n             for (SourceMapping source : target.getSourceMappings()) {\n                 NodeSourcePosition sourcePosition = source.getSourcePosition();\n                 if (sourcePosition.isPlaceholder() || sourcePosition.isSubstitution()) {\n                     // HotSpot doesn't understand any of the special positions so just drop them.\n                     continue;\n                 }\n+                sourceMappings.add(source);\n+            }\n+\n+            /*\n+             * Don't add BYTECODE_POSITION info points that would potentially create conflicts.\n+             * Under certain conditions the site's pc is not the pc that gets recorded by HotSpot\n+             * (see @code {CodeInstaller::site_Call}). So, avoid adding any source positions that\n+             * can potentially map to the same pc. To do that the following code makes sure that the\n+             * source mapping doesn't contain a pc of any important Site.\n+             */\n+            sourceMappings.sort(Comparator.comparingInt(SourceMapping::getStartOffset));\n+            sites.sort(new SiteComparator());\n+\n+            ListIterator<Site> siteListIterator = sites.listIterator();\n+            ListIterator<SourceMapping> sourceMappingListIterator = sourceMappings.listIterator();\n+\n+            List<Site> sourcePositionSites = new ArrayList<>();\n+            Site site = null;\n+\n+            // Iterate over sourceMappings and sites in parallel. Create source position infopoints\n+            // only for source mappings that don't have any sites inside their intervals.\n+            while (sourceMappingListIterator.hasNext()) {\n+                SourceMapping source = sourceMappingListIterator.next();\n+\n+                // Skip sites before the current source mapping\n+                if (site == null || site.pcOffset < source.getStartOffset()) {\n+                    while (siteListIterator.hasNext()) {\n+                        site = siteListIterator.next();\n+                        if (site.pcOffset >= source.getStartOffset()) {\n+                            break;\n+                        }\n+                    }\n+                }\n+\n+                assert site == null || site.pcOffset >= source.getStartOffset();\n+                if (site != null && site.pcOffset <= source.getEndOffset()) {\n+                    // Conflicting source mapping, skip it.\n+                    continue;\n+                } else {\n+                    // Since the sites are sorted there can not be any more sites in this interval.\n+                }\n+\n+                assert site == null || site.pcOffset > source.getEndOffset();\n+                // Good source mapping. Create an infopoint and add it to the list.\n+                NodeSourcePosition sourcePosition = source.getSourcePosition();\n                 assert sourcePosition.verify();\n                 sourcePosition = sourcePosition.trim();\n-                /*\n-                 * Don't add BYTECODE_POSITION info points that would potentially create conflicts.\n-                 * Under certain conditions the site's pc is not the pc that gets recorded by\n-                 * HotSpot (see @code {CodeInstaller::site_Call}). So, avoid adding any source\n-                 * positions that can potentially map to the same pc. To do that make sure that the\n-                 * source mapping doesn't contain a pc of any important Site.\n-                 */\n-                if (sourcePosition != null && !anyMatch(sites, s -> source.contains(s.pcOffset))) {\n+                if (sourcePosition != null) {\n+                    assert !anyMatch(sites, s -> source.contains(s.pcOffset));\n                     sourcePositionSites.add(new Infopoint(source.getEndOffset(), new DebugInfo(sourcePosition), InfopointReason.BYTECODE_POSITION));\n-\n                 }\n             }\n+\n             sites.addAll(sourcePositionSites);\n         }\n \n         SiteComparator c = new SiteComparator();\n         Collections.sort(sites, c);\n+\n         if (c.sawCollidingInfopoints) {\n             Infopoint lastInfopoint = null;\n             List<Site> copy = new ArrayList<>(sites.size());\n@@ -265,6 +307,7 @@ private static Site[] getSortedSites(CodeCacheProvider codeCache, CompilationRes\n             }\n             sites = copy;\n         }\n+\n         return sites.toArray(new Site[sites.size()]);\n     }\n }",
      "parent_sha": "645bde4b0607409801bc8dbc27aaabb0b51e6866"
    }
  },
  {
    "oid": "112a30d0d095ccfde6c3d7cdee35e2676e50c492",
    "message": "Unsafe: Respect potential hidden field access",
    "date": "2022-11-15T12:37:18Z",
    "url": "https://github.com/oracle/graal/commit/112a30d0d095ccfde6c3d7cdee35e2676e50c492",
    "details": {
      "sha": "b4a74484154ca8536249174e3e2d92e05980e362",
      "filename": "espresso/src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/substitutions/Target_sun_misc_Unsafe.java",
      "status": "modified",
      "additions": 10,
      "deletions": 7,
      "changes": 17,
      "blob_url": "https://github.com/oracle/graal/blob/112a30d0d095ccfde6c3d7cdee35e2676e50c492/espresso%2Fsrc%2Fcom.oracle.truffle.espresso%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fespresso%2Fsubstitutions%2FTarget_sun_misc_Unsafe.java",
      "raw_url": "https://github.com/oracle/graal/raw/112a30d0d095ccfde6c3d7cdee35e2676e50c492/espresso%2Fsrc%2Fcom.oracle.truffle.espresso%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fespresso%2Fsubstitutions%2FTarget_sun_misc_Unsafe.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/espresso%2Fsrc%2Fcom.oracle.truffle.espresso%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fespresso%2Fsubstitutions%2FTarget_sun_misc_Unsafe.java?ref=112a30d0d095ccfde6c3d7cdee35e2676e50c492",
      "patch": "@@ -70,9 +70,12 @@ public final class Target_sun_misc_Unsafe {\n \n     /** The value of {@code addressSize()}. */\n     public static final int ADDRESS_SIZE;\n+    private static final long PARK_BLOCKER_OFFSET;\n+\n     private static final int SAFETY_FIELD_OFFSET = 123456789;\n     private static final int SAFETY_STATIC_FIELD_OFFSET = 3456789;\n-    private static final long PARK_BLOCKER_OFFSET;\n+    private static final int ALLOWED_HIDDEN_FIELDS = 0x1000;\n+\n     private static final String TARGET_JDK_INTERNAL_MISC_UNSAFE = \"Target_jdk_internal_misc_Unsafe\";\n     private static final String TARGET_SUN_MISC_UNSAFE = \"Target_sun_misc_Unsafe\";\n \n@@ -221,10 +224,10 @@ private ResolvedAccess(Field field, StaticObject holder) {\n \n     static int safetyOffsetToSlot(long safetyOffset) {\n         int offset = Math.toIntExact(safetyOffset);\n-        if (offset >= SAFETY_FIELD_OFFSET) {\n+        if (offset >= (SAFETY_FIELD_OFFSET - ALLOWED_HIDDEN_FIELDS)) {\n             return offset - SAFETY_FIELD_OFFSET;\n         } else {\n-            assert offset >= SAFETY_STATIC_FIELD_OFFSET : \"offset: \" + offset;\n+            assert offset >= (SAFETY_STATIC_FIELD_OFFSET - ALLOWED_HIDDEN_FIELDS) : \"offset: \" + offset;\n             return offset - SAFETY_STATIC_FIELD_OFFSET;\n         }\n     }\n@@ -237,19 +240,19 @@ private static ResolvedAccess resolveUnsafeAccess(StaticObject holder, long offs\n         int slot;\n         int safetyOffset = Math.toIntExact(offset);\n         boolean isStatic = false;\n-        if (safetyOffset >= SAFETY_FIELD_OFFSET) {\n+        if (safetyOffset >= (SAFETY_FIELD_OFFSET - ALLOWED_HIDDEN_FIELDS)) {\n             slot = safetyOffset - SAFETY_FIELD_OFFSET;\n         } else {\n-            assert safetyOffset >= SAFETY_STATIC_FIELD_OFFSET : \"safetyOffset: \" + safetyOffset;\n+            assert safetyOffset >= (SAFETY_STATIC_FIELD_OFFSET - ALLOWED_HIDDEN_FIELDS) : \"safetyOffset: \" + safetyOffset;\n             slot = safetyOffset - SAFETY_STATIC_FIELD_OFFSET;\n             isStatic = true;\n         }\n \n         assert !StaticObject.isNull(holder);\n \n-        if (slot >= 1 << 16) {\n+        if (slot >= 1 << 16 || slot < (-ALLOWED_HIDDEN_FIELDS)) {\n             CompilerDirectives.transferToInterpreterAndInvalidate();\n-            throw EspressoError.shouldNotReachHere(\"the field offset is not normalized\");\n+            throw EspressoError.shouldNotReachHere(\"the field offset is not normalized: slot=\" + slot + \", safteyOffset=\" + safetyOffset);\n         }\n         Field field = null;\n         StaticObject resolvedHolder = holder;",
      "parent_sha": "e8077ba829492eb72f0673e8eb421950e21cb57d"
    }
  },
  {
    "oid": "94b21ff717169c30a021901397bcec59075578ff",
    "message": "Fix formatting.",
    "date": "2016-03-27T13:20:32Z",
    "url": "https://github.com/oracle/graal/commit/94b21ff717169c30a021901397bcec59075578ff",
    "details": {
      "sha": "6ff5c7a05fe4673ed09916b5b177f6baff67b862",
      "filename": "truffle/com.oracle.truffle.api.instrumentation.test/src/com/oracle/truffle/api/instrumentation/SourceSectionFilterTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/oracle/graal/blob/94b21ff717169c30a021901397bcec59075578ff/truffle%2Fcom.oracle.truffle.api.instrumentation.test%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Finstrumentation%2FSourceSectionFilterTest.java",
      "raw_url": "https://github.com/oracle/graal/raw/94b21ff717169c30a021901397bcec59075578ff/truffle%2Fcom.oracle.truffle.api.instrumentation.test%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Finstrumentation%2FSourceSectionFilterTest.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/truffle%2Fcom.oracle.truffle.api.instrumentation.test%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Finstrumentation%2FSourceSectionFilterTest.java?ref=94b21ff717169c30a021901397bcec59075578ff",
      "patch": "@@ -592,10 +592,10 @@ public void testComplexFilter() {\n         SourceSection root = sampleSource1.createSection(null, 0, 23);\n \n         SourceSectionFilter filter = SourceSectionFilter.newBuilder().tagIs(InstrumentationTestLanguage.EXPRESSION, InstrumentationTestLanguage.DEFINE).//\n-                        tagIsNot(InstrumentationTestLanguage.DEFINE, InstrumentationTestLanguage.ROOT).//\n-                        indexIn(0, 3).//\n-                        sourceIs(sampleSource1).sourceSectionEquals(sampleSource1.createSection(null, 0, 5)).//\n-                        lineIn(1, 1).lineIs(1).mimeTypeIs(\"mime1\", \"mime2\").build();\n+        tagIsNot(InstrumentationTestLanguage.DEFINE, InstrumentationTestLanguage.ROOT).//\n+        indexIn(0, 3).//\n+        sourceIs(sampleSource1).sourceSectionEquals(sampleSource1.createSection(null, 0, 5)).//\n+        lineIn(1, 1).lineIs(1).mimeTypeIs(\"mime1\", \"mime2\").build();\n \n         Assert.assertFalse(isInstrumented(filter, root, source()));\n         Assert.assertTrue(isInstrumentedRoot(filter, null));",
      "parent_sha": "e18d12ab9e31b224647e1be04bb7a418555a6efa"
    }
  },
  {
    "oid": "c25d30d1e6745217040ad484c5e2ab3ddfc830da",
    "message": "Making sure each invocation of yieldAnError is executed in interpreter",
    "date": "2017-03-10T03:55:43Z",
    "url": "https://github.com/oracle/graal/commit/c25d30d1e6745217040ad484c5e2ab3ddfc830da",
    "details": {
      "sha": "3e45557b4f63744c2c1ca96c908ab4676704a60f",
      "filename": "truffle/com.oracle.truffle.api.interop/src/com/oracle/truffle/api/interop/InteropAccessNode.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/oracle/graal/blob/c25d30d1e6745217040ad484c5e2ab3ddfc830da/truffle%2Fcom.oracle.truffle.api.interop%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Finterop%2FInteropAccessNode.java",
      "raw_url": "https://github.com/oracle/graal/raw/c25d30d1e6745217040ad484c5e2ab3ddfc830da/truffle%2Fcom.oracle.truffle.api.interop%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Finterop%2FInteropAccessNode.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/truffle%2Fcom.oracle.truffle.api.interop%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Finterop%2FInteropAccessNode.java?ref=c25d30d1e6745217040ad484c5e2ab3ddfc830da",
      "patch": "@@ -118,14 +118,13 @@ private static Object checkInteropType(Object obj) {\n                         clazz == String.class) {\n             return obj;\n         } else {\n-            CompilerDirectives.transferToInterpreter();\n             yieldAnError(obj.getClass());\n             return null;\n         }\n     }\n \n-    @TruffleBoundary\n     private static Object yieldAnError(Class<?> clazz) {\n+        CompilerDirectives.transferToInterpreter();\n         StringBuilder sb = new StringBuilder();\n         sb.append(clazz == null ? \"null\" : clazz.getName());\n         sb.append(\" isn't allowed Truffle interop type!\\n\");",
      "parent_sha": "fc9c6955a113314ca2ce73a7c522a21bef099702"
    }
  },
  {
    "oid": "d21c7ac9c24f568a1500b3aaed30845035ff1885",
    "message": "Fix typo in TVMCI.",
    "date": "2017-02-27T15:36:52Z",
    "url": "https://github.com/oracle/graal/commit/d21c7ac9c24f568a1500b3aaed30845035ff1885",
    "details": {
      "sha": "a497467f00bdb64b8c1859df08a2ec0034355918",
      "filename": "graal/org.graalvm.compiler.truffle/src/org/graalvm/compiler/truffle/GraalTVMCI.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/oracle/graal/blob/d21c7ac9c24f568a1500b3aaed30845035ff1885/graal%2Forg.graalvm.compiler.truffle%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Ftruffle%2FGraalTVMCI.java",
      "raw_url": "https://github.com/oracle/graal/raw/d21c7ac9c24f568a1500b3aaed30845035ff1885/graal%2Forg.graalvm.compiler.truffle%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Ftruffle%2FGraalTVMCI.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Forg.graalvm.compiler.truffle%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Ftruffle%2FGraalTVMCI.java?ref=d21c7ac9c24f568a1500b3aaed30845035ff1885",
      "patch": "@@ -75,8 +75,8 @@ protected boolean getFrameMaterializeCalled(FrameDescriptor descriptor) {\n     }\n \n     @Override\n-    public RootNode cloneUnitialized(RootNode root) {\n-        return super.cloneUnitialized(root);\n+    public RootNode cloneUninitialized(RootNode root) {\n+        return super.cloneUninitialized(root);\n     }\n \n     @Override",
      "parent_sha": "7d9581a3f0a82ff7d5e9a9eb03642d1eb12b0dc2"
    }
  },
  {
    "oid": "d4e7cedb2e06b8fad266c22ae94361e82c5f281b",
    "message": "Fix build time warnings.",
    "date": "2021-11-17T18:16:00Z",
    "url": "https://github.com/oracle/graal/commit/d4e7cedb2e06b8fad266c22ae94361e82c5f281b",
    "details": {
      "sha": "804696b0c7507d322bc154a79339880316a56368",
      "filename": "truffle/src/com.oracle.truffle.api.staticobject.test.jdk17/src/com/oracle/truffle/api/staticobject/test/HiddenClassProperty.java",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/oracle/graal/blob/d4e7cedb2e06b8fad266c22ae94361e82c5f281b/truffle%2Fsrc%2Fcom.oracle.truffle.api.staticobject.test.jdk17%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Fstaticobject%2Ftest%2FHiddenClassProperty.java",
      "raw_url": "https://github.com/oracle/graal/raw/d4e7cedb2e06b8fad266c22ae94361e82c5f281b/truffle%2Fsrc%2Fcom.oracle.truffle.api.staticobject.test.jdk17%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Fstaticobject%2Ftest%2FHiddenClassProperty.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/truffle%2Fsrc%2Fcom.oracle.truffle.api.staticobject.test.jdk17%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Fstaticobject%2Ftest%2FHiddenClassProperty.java?ref=d4e7cedb2e06b8fad266c22ae94361e82c5f281b",
      "patch": "@@ -65,6 +65,7 @@ public static TestConfiguration[] data() {\n     // To support Native Image, the hidden class must be generated at image build time\n     private static Class<HiddenClassInterface> hiddenClass = generateHiddenClass();\n \n+    @SuppressWarnings(\"unchecked\")\n     private static Class<HiddenClassInterface> generateHiddenClass() {\n         try {\n             MethodHandles.Lookup lookup = MethodHandles.lookup();\n@@ -76,11 +77,9 @@ private static Class<HiddenClassInterface> generateHiddenClass() {\n     }\n \n     @Test\n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-    public void hiddenClass() throws Throwable {\n+    public void hiddenClass() {\n         try (TestEnvironment te = new TestEnvironment(config)) {\n             StaticShape.Builder builder = StaticShape.newBuilder(te.testLanguage);\n-\n             StaticProperty property = new DefaultStaticProperty((\"property\"));\n             try {\n                 builder.property(property, hiddenClass, false);",
      "parent_sha": "3087d58aa258acfe7ab7c282d429bd5d53737f2a"
    }
  },
  {
    "oid": "056db8b3e5c1b864cb04d93b79f28a5b638723f1",
    "message": "Style fixes",
    "date": "2022-04-19T16:07:44Z",
    "url": "https://github.com/oracle/graal/commit/056db8b3e5c1b864cb04d93b79f28a5b638723f1",
    "details": {
      "sha": "90c5e6b3b709bda9a6a540a7107e6833ed9e6074",
      "filename": "espresso/src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/analysis/hierarchy/DefaultClassHierarchyOracle.java",
      "status": "modified",
      "additions": 3,
      "deletions": 5,
      "changes": 8,
      "blob_url": "https://github.com/oracle/graal/blob/056db8b3e5c1b864cb04d93b79f28a5b638723f1/espresso%2Fsrc%2Fcom.oracle.truffle.espresso%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fespresso%2Fanalysis%2Fhierarchy%2FDefaultClassHierarchyOracle.java",
      "raw_url": "https://github.com/oracle/graal/raw/056db8b3e5c1b864cb04d93b79f28a5b638723f1/espresso%2Fsrc%2Fcom.oracle.truffle.espresso%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fespresso%2Fanalysis%2Fhierarchy%2FDefaultClassHierarchyOracle.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/espresso%2Fsrc%2Fcom.oracle.truffle.espresso%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fespresso%2Fanalysis%2Fhierarchy%2FDefaultClassHierarchyOracle.java?ref=056db8b3e5c1b864cb04d93b79f28a5b638723f1",
      "patch": "@@ -27,8 +27,6 @@\n import com.oracle.truffle.espresso.impl.Method;\n import com.oracle.truffle.espresso.impl.ObjectKlass;\n \n-import java.util.ArrayList;\n-\n /**\n  * Computes the classes that are effectively final by keeping track of currently loaded classes. To\n  * compute currently leaf classes, it creates {@code noConcreteSubclassesAssumption} in the\n@@ -106,11 +104,11 @@ private void updateVirtualAndInterfaceTables(ObjectKlass.KlassVersion newKlassVe\n             Method.MethodVersion m = vTable[i];\n             ObjectKlass current = newKlassVersion.getSuperKlass();\n             while (current != null) {\n-                Method.MethodVersion[] vtable = current.getKlassVersion().getVtable();\n-                if (i >= vtable.length) {\n+                Method.MethodVersion[] superVTable = current.getKlassVersion().getVtable();\n+                if (i >= superVTable.length) {\n                     break;\n                 }\n-                Method.MethodVersion overridden = vtable[i];\n+                Method.MethodVersion overridden = superVTable[i];\n                 if (overridden != m) {\n                     overridden.getMethod().getLeafAssumption(ClassHierarchyAccessor.accessor).invalidate();\n                     if (current.isConcrete()) {",
      "parent_sha": "9cd8efd55fe29df52f20846caf5e11a41221b8fb"
    }
  },
  {
    "oid": "4efaa1c148194a381cf451ba9f85b70df6f28192",
    "message": "Simplify error code checks in FdUtils methods",
    "date": "2024-08-05T13:45:54Z",
    "url": "https://github.com/oracle/graal/commit/4efaa1c148194a381cf451ba9f85b70df6f28192",
    "details": {
      "sha": "6db0f6dc37230174e8bad23b05cd30edc21b484a",
      "filename": "wasm/src/org.graalvm.wasm/src/org/graalvm/wasm/predefined/wasi/fd/FdUtils.java",
      "status": "modified",
      "additions": 2,
      "deletions": 10,
      "changes": 12,
      "blob_url": "https://github.com/oracle/graal/blob/4efaa1c148194a381cf451ba9f85b70df6f28192/wasm%2Fsrc%2Forg.graalvm.wasm%2Fsrc%2Forg%2Fgraalvm%2Fwasm%2Fpredefined%2Fwasi%2Ffd%2FFdUtils.java",
      "raw_url": "https://github.com/oracle/graal/raw/4efaa1c148194a381cf451ba9f85b70df6f28192/wasm%2Fsrc%2Forg.graalvm.wasm%2Fsrc%2Forg%2Fgraalvm%2Fwasm%2Fpredefined%2Fwasi%2Ffd%2FFdUtils.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/wasm%2Fsrc%2Forg.graalvm.wasm%2Fsrc%2Forg%2Fgraalvm%2Fwasm%2Fpredefined%2Fwasi%2Ffd%2FFdUtils.java?ref=4efaa1c148194a381cf451ba9f85b70df6f28192",
      "patch": "@@ -115,11 +115,7 @@ static Errno writeToStreamAt(Node node, WasmMemory memory, OutputStream stream,\n             long currentOffset = channel.position();\n             try {\n                 channel.position(offset);\n-                Errno status = writeToStream(node, memory, stream, iovecArrayAddress, iovecCount, sizeAddress);\n-                if (status != Errno.Success) {\n-                    return status;\n-                }\n-                return Errno.Success;\n+                return writeToStream(node, memory, stream, iovecArrayAddress, iovecCount, sizeAddress);\n             } finally {\n                 channel.position(currentOffset);\n             }\n@@ -133,11 +129,7 @@ static Errno readFromStreamAt(Node node, WasmMemory memory, InputStream stream,\n             long currentOffset = channel.position();\n             try {\n                 channel.position(offset);\n-                Errno status = readFromStream(node, memory, stream, iovecArrayAddress, iovecCount, sizeAddress);\n-                if (status != Errno.Success) {\n-                    return status;\n-                }\n-                return Errno.Success;\n+                return readFromStream(node, memory, stream, iovecArrayAddress, iovecCount, sizeAddress);\n             } finally {\n                 channel.position(currentOffset);\n             }",
      "parent_sha": "02b31416d9e6a02bb47140a295029534a8aac5d4"
    }
  },
  {
    "oid": "02710ddcf6a51f9aecf0ab36d18188a3634d5720",
    "message": "style fixes",
    "date": "2021-12-22T11:50:41Z",
    "url": "https://github.com/oracle/graal/commit/02710ddcf6a51f9aecf0ab36d18188a3634d5720",
    "details": {
      "sha": "a8eec1ce765d38ab34a41b529112848174455a07",
      "filename": "substratevm/src/com.oracle.svm.core.posix/src/com/oracle/svm/core/posix/headers/darwin/DarwinStat.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/oracle/graal/blob/02710ddcf6a51f9aecf0ab36d18188a3634d5720/substratevm%2Fsrc%2Fcom.oracle.svm.core.posix%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2Fposix%2Fheaders%2Fdarwin%2FDarwinStat.java",
      "raw_url": "https://github.com/oracle/graal/raw/02710ddcf6a51f9aecf0ab36d18188a3634d5720/substratevm%2Fsrc%2Fcom.oracle.svm.core.posix%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2Fposix%2Fheaders%2Fdarwin%2FDarwinStat.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm%2Fsrc%2Fcom.oracle.svm.core.posix%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2Fposix%2Fheaders%2Fdarwin%2FDarwinStat.java?ref=02710ddcf6a51f9aecf0ab36d18188a3634d5720",
      "patch": "@@ -56,11 +56,11 @@ public interface stat extends PointerBase {\n     }\n \n     @CFunction(\"fstat$INODE64\")\n-    @Platforms({Platform.DARWIN_AMD64.class})\n+    @Platforms(Platform.DARWIN_AMD64.class)\n     public static native int fstat_amd64(int fd, stat buf);\n \n     @CFunction(\"fstat\")\n-    @Platforms({Platform.DARWIN_AARCH64.class})\n+    @Platforms(Platform.DARWIN_AARCH64.class)\n     public static native int fstat_aarch64(int fd, stat buf);\n \n     @Platforms(Platform.DARWIN.class)\n@@ -76,11 +76,11 @@ public static int fstat(int fd, stat buf) {\n \n     public static class NoTransitions {\n         @CFunction(value = \"fstat$INODE64\", transition = CFunction.Transition.NO_TRANSITION)\n-        @Platforms({Platform.DARWIN_AMD64.class})\n+        @Platforms(Platform.DARWIN_AMD64.class)\n         public static native int fstat_amd64(int fd, stat buf);\n \n         @CFunction(value = \"fstat\", transition = CFunction.Transition.NO_TRANSITION)\n-        @Platforms({Platform.DARWIN_AARCH64.class})\n+        @Platforms(Platform.DARWIN_AARCH64.class)\n         public static native int fstat_aarch64(int fd, stat buf);\n \n         @Platforms(Platform.DARWIN.class)",
      "parent_sha": "3e0c8ce287e6c48e230d556eb61cd1f60b2b398e"
    }
  },
  {
    "oid": "5fc7b0ae32b3b7c522b8c6a6c638ff7b453c27ae",
    "message": "Enabling experimental options when wasm.BulkMemoryAndRefTypes is used.",
    "date": "2023-04-06T19:17:45Z",
    "url": "https://github.com/oracle/graal/commit/5fc7b0ae32b3b7c522b8c6a6c638ff7b453c27ae",
    "details": {
      "sha": "9097b29d79b79d07ef88e8675733bffc15a27d4a",
      "filename": "wasm/src/org.graalvm.wasm.test/src/org/graalvm/wasm/test/WasmJsApiSuite.java",
      "status": "modified",
      "additions": 9,
      "deletions": 5,
      "changes": 14,
      "blob_url": "https://github.com/oracle/graal/blob/5fc7b0ae32b3b7c522b8c6a6c638ff7b453c27ae/wasm%2Fsrc%2Forg.graalvm.wasm.test%2Fsrc%2Forg%2Fgraalvm%2Fwasm%2Ftest%2FWasmJsApiSuite.java",
      "raw_url": "https://github.com/oracle/graal/raw/5fc7b0ae32b3b7c522b8c6a6c638ff7b453c27ae/wasm%2Fsrc%2Forg.graalvm.wasm.test%2Fsrc%2Forg%2Fgraalvm%2Fwasm%2Ftest%2FWasmJsApiSuite.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/wasm%2Fsrc%2Forg.graalvm.wasm.test%2Fsrc%2Forg%2Fgraalvm%2Fwasm%2Ftest%2FWasmJsApiSuite.java?ref=5fc7b0ae32b3b7c522b8c6a6c638ff7b453c27ae",
      "patch": "@@ -316,9 +316,13 @@ public void testInstantiateWithImportGlobalExternref() throws IOException {\n         checkInstantiateWithImportGlobal(binaryWithGlobalImportExternref, \"externref\", \"foo\");\n     }\n \n+    private static void disableRefTypes(Context.Builder builder) {\n+        builder.allowExperimentalOptions(true).option(REF_TYPES_OPTION, \"false\");\n+    }\n+\n     @Test\n     public void testCreateAnyfuncGlobalRefTypesDisabled() throws IOException {\n-        runTest(builder -> builder.option(REF_TYPES_OPTION, \"false\"), context -> {\n+        runTest(builder -> disableRefTypes(builder), context -> {\n             final WebAssembly wasm = new WebAssembly(context);\n             try {\n                 wasm.globalAlloc(ValueType.anyfunc, false, WasmConstant.NULL);\n@@ -331,7 +335,7 @@ public void testCreateAnyfuncGlobalRefTypesDisabled() throws IOException {\n \n     @Test\n     public void testCreateExternrefGlobalRefTypesDisabled() throws IOException {\n-        runTest(builder -> builder.option(REF_TYPES_OPTION, \"false\"), context -> {\n+        runTest(builder -> disableRefTypes(builder), context -> {\n             final WebAssembly wasm = new WebAssembly(context);\n             try {\n                 wasm.globalAlloc(ValueType.externref, false, WasmConstant.NULL);\n@@ -477,7 +481,7 @@ public void testGlobalWriteNull() throws IOException {\n \n     @Test\n     public void testGlobalWriteAnyfuncRefTypesDisabled() throws IOException {\n-        runTest(builder -> builder.option(REF_TYPES_OPTION, \"false\"), context -> {\n+        runTest(builder -> disableRefTypes(builder), context -> {\n             final WebAssembly wasm = new WebAssembly(context);\n             final WasmGlobal global = new DefaultWasmGlobal(ValueType.anyfunc, true, WasmConstant.NULL);\n             try {\n@@ -491,7 +495,7 @@ public void testGlobalWriteAnyfuncRefTypesDisabled() throws IOException {\n \n     @Test\n     public void testGlobalWriteExternrefRefTypesDisabled() throws IOException {\n-        runTest(builder -> builder.option(REF_TYPES_OPTION, \"false\"), context -> {\n+        runTest(builder -> disableRefTypes(builder), context -> {\n             final WebAssembly wasm = new WebAssembly(context);\n             final WasmGlobal global = new DefaultWasmGlobal(ValueType.externref, true, WasmConstant.NULL);\n             try {\n@@ -1422,7 +1426,7 @@ public void testTableInitExternref() throws IOException {\n \n     @Test\n     public void testTableAlloc1Param() throws IOException {\n-        runTest(builder -> builder.option(REF_TYPES_OPTION, \"false\"), context -> {\n+        runTest(builder -> disableRefTypes(builder), context -> {\n             final WebAssembly wasm = new WebAssembly(context);\n             final InteropLibrary lib = InteropLibrary.getUncached();\n             try {",
      "parent_sha": "5eb87ce97d5cce3f14a74fe6462986f70990d319"
    }
  },
  {
    "oid": "1eef051ae55f32f08f276bb9e1bb517fd4b4ba48",
    "message": "use addOrUniqueWithInputs, inputs may not be alive",
    "date": "2024-11-21T13:36:08Z",
    "url": "https://github.com/oracle/graal/commit/1eef051ae55f32f08f276bb9e1bb517fd4b4ba48",
    "details": {
      "sha": "492e40b63d2c0ed68dc022229112a61d71a3e10b",
      "filename": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/java/ArrayLengthNode.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/oracle/graal/blob/1eef051ae55f32f08f276bb9e1bb517fd4b4ba48/compiler%2Fsrc%2Fjdk.graal.compiler%2Fsrc%2Fjdk%2Fgraal%2Fcompiler%2Fnodes%2Fjava%2FArrayLengthNode.java",
      "raw_url": "https://github.com/oracle/graal/raw/1eef051ae55f32f08f276bb9e1bb517fd4b4ba48/compiler%2Fsrc%2Fjdk.graal.compiler%2Fsrc%2Fjdk%2Fgraal%2Fcompiler%2Fnodes%2Fjava%2FArrayLengthNode.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/compiler%2Fsrc%2Fjdk.graal.compiler%2Fsrc%2Fjdk%2Fgraal%2Fcompiler%2Fnodes%2Fjava%2FArrayLengthNode.java?ref=1eef051ae55f32f08f276bb9e1bb517fd4b4ba48",
      "patch": "@@ -187,7 +187,7 @@ public void simplify(SimplifierTool tool) {\n      */\n     public static ValueNode maybeAddPositivePi(ValueNode length, FixedWithNextNode insertionPosition) {\n         StructuredGraph graph = insertionPosition.graph();\n-        ValueNode localLength = graph.addOrUnique(length);\n+        ValueNode localLength = graph.addOrUniqueWithInputs(length);\n         ValueNode replacement = localLength;\n         if (!localLength.isConstant() && localLength.stamp(NodeView.DEFAULT).canBeImprovedWith(StampFactory.positiveInt())) {\n             ValueAnchorNode g = graph.add(new ValueAnchorNode());",
      "parent_sha": "cb464855ea73fa08e27715e9f32f5f2e87dc41ad"
    }
  },
  {
    "oid": "3c81a0b994336f2ffdcf237113528a2df3b1bcdd",
    "message": "Remove unnecessary registration of analysis types",
    "date": "2022-11-14T11:43:32Z",
    "url": "https://github.com/oracle/graal/commit/3c81a0b994336f2ffdcf237113528a2df3b1bcdd",
    "details": {
      "sha": "9893fb01a5683a44d70dbe29fa23287de37099dc",
      "filename": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/reflect/ReflectionDataBuilder.java",
      "status": "modified",
      "additions": 12,
      "deletions": 21,
      "changes": 33,
      "blob_url": "https://github.com/oracle/graal/blob/3c81a0b994336f2ffdcf237113528a2df3b1bcdd/substratevm%2Fsrc%2Fcom.oracle.svm.hosted%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fhosted%2Freflect%2FReflectionDataBuilder.java",
      "raw_url": "https://github.com/oracle/graal/raw/3c81a0b994336f2ffdcf237113528a2df3b1bcdd/substratevm%2Fsrc%2Fcom.oracle.svm.hosted%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fhosted%2Freflect%2FReflectionDataBuilder.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm%2Fsrc%2Fcom.oracle.svm.hosted%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fhosted%2Freflect%2FReflectionDataBuilder.java?ref=3c81a0b994336f2ffdcf237113528a2df3b1bcdd",
      "patch": "@@ -50,7 +50,6 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.stream.Collectors;\n \n-import org.graalvm.nativeimage.AnnotationAccess;\n import org.graalvm.nativeimage.ImageSingletons;\n import org.graalvm.nativeimage.hosted.Feature.DuringAnalysisAccess;\n import org.graalvm.nativeimage.hosted.RuntimeProxyCreation;\n@@ -64,7 +63,6 @@\n import com.oracle.graal.pointsto.meta.AnalysisMethod;\n import com.oracle.graal.pointsto.meta.AnalysisType;\n import com.oracle.svm.core.SubstrateOptions;\n-import com.oracle.svm.core.annotate.InjectAccessors;\n import com.oracle.svm.core.hub.ClassForNameSupport;\n import com.oracle.svm.core.hub.ClassLoadingExceptionSupport;\n import com.oracle.svm.core.hub.DynamicHub;\n@@ -248,6 +246,7 @@ protected void processMethodMetadata(DuringAnalysisAccessImpl access) {\n         for (Field reflectField : reflectionFields) {\n             if (!registeredFields.containsKey(reflectField) && !SubstitutionReflectivityFilter.shouldExclude(reflectField, access.getMetaAccess(), access.getUniverse())) {\n                 AnalysisField analysisField = access.getMetaAccess().lookupJavaField(reflectField);\n+                access.requireAnalysisIteration();\n                 registerTypesForField(access, analysisField, reflectField);\n                 registeredFields.put(reflectField, analysisField);\n             }\n@@ -261,6 +260,7 @@ protected void processMethodMetadata(DuringAnalysisAccessImpl access) {\n             }\n             if (!registeredMethods.containsKey(method)) {\n                 AnalysisMethod analysisMethod = access.getMetaAccess().lookupJavaMethod(method);\n+                access.requireAnalysisIteration();\n                 registerTypesForMethod(access, analysisMethod, method);\n                 registeredMethods.put(method, analysisMethod);\n             }\n@@ -285,12 +285,14 @@ protected void processMethodMetadata(DuringAnalysisAccessImpl access) {\n                     Field field = (Field) object;\n                     if (!SubstitutionReflectivityFilter.shouldExclude(field, access.getMetaAccess(), access.getUniverse())) {\n                         analysisElement = access.getMetaAccess().lookupJavaField(field);\n+                        access.requireAnalysisIteration();\n                         registerTypesForField(access, (AnalysisField) analysisElement, field);\n                     }\n                 } else if (object instanceof Executable) {\n                     Executable executable = (Executable) object;\n                     if (!SubstitutionReflectivityFilter.shouldExclude(executable, access.getMetaAccess(), access.getUniverse())) {\n                         analysisElement = access.getMetaAccess().lookupJavaMethod(executable);\n+                        access.requireAnalysisIteration();\n                         registerTypesForMethod(access, (AnalysisMethod) analysisElement, executable);\n                     }\n                 }\n@@ -471,13 +473,8 @@ private void registerTypesForField(DuringAnalysisAccessImpl access, AnalysisFiel\n          * registered as unsafe-accessible, whether they have been explicitly registered or their\n          * Field object is reachable in the image heap.\n          */\n-        if (!analysisField.isUnsafeAccessed() && !AnnotationAccess.isAnnotationPresent(analysisField, InjectAccessors.class)) {\n-            analysisField.registerAsAccessed();\n-            analysisField.registerAsUnsafeAccessed();\n-        }\n+        access.registerAsUnsafeAccessed(analysisField);\n \n-        makeAnalysisTypeReachable(access, analysisField.getDeclaringClass());\n-        makeAnalysisTypeReachable(access, analysisField.getType());\n         registerTypesForGenericSignature(access, reflectField.getGenericType());\n \n         /*\n@@ -488,8 +485,6 @@ private void registerTypesForField(DuringAnalysisAccessImpl access, AnalysisFiel\n     }\n \n     private void registerTypesForMethod(DuringAnalysisAccessImpl access, AnalysisMethod analysisMethod, Executable reflectMethod) {\n-        makeAnalysisTypeReachable(access, analysisMethod.getDeclaringClass());\n-\n         registerTypesForGenericSignature(access, reflectMethod.getTypeParameters());\n         registerTypesForGenericSignature(access, reflectMethod.getGenericParameterTypes());\n         registerTypesForGenericSignature(access, reflectMethod.getGenericExceptionTypes());\n@@ -547,22 +542,18 @@ private void registerTypesForGenericSignature(DuringAnalysisAccessImpl access, T\n         processedTypes.put(type, dimension);\n         if (type instanceof Class<?> && !shouldExcludeClass(access, (Class<?>) type)) {\n             Class<?> clazz = (Class<?>) type;\n-            makeAnalysisTypeReachable(access, access.getMetaAccess().lookupJavaType(clazz).getArrayClass(dimension));\n-\n-            /*\n-             * Reflection signature parsing will try to instantiate classes via Class.forName().\n-             */\n-            if (ClassForNameSupport.forNameOrNull(clazz.getName(), null) == null) {\n-                access.requireAnalysisIteration();\n+            if (dimension > 0) {\n+                /*\n+                 * We only need to register the array type here, since it is the one that gets\n+                 * stored in the heap. The component type will be registered elsewhere if needed.\n+                 */\n+                makeAnalysisTypeReachable(access, access.getMetaAccess().lookupJavaType(clazz).getArrayClass(dimension));\n             }\n+            /* Generic signature parsing will try to instantiate classes via Class.forName(). */\n             ClassForNameSupport.registerClass(clazz);\n         } else if (type instanceof TypeVariable<?>) {\n             registerTypesForGenericSignature(access, ((TypeVariable<?>) type).getBounds());\n         } else if (type instanceof GenericArrayType) {\n-            /*\n-             * We only need to register the array type here, since it is the one that gets stored in\n-             * the heap. The component type will be registered elsewhere if needed.\n-             */\n             registerTypesForGenericSignature(access, ((GenericArrayType) type).getGenericComponentType(), dimension + 1);\n         } else if (type instanceof ParameterizedType) {\n             ParameterizedType parameterizedType = (ParameterizedType) type;",
      "parent_sha": "6866f5314c073ec6e9ace9f5d313df4650de77ea"
    }
  },
  {
    "oid": "325ad064716920424eef6c1518d24fbe55a706b4",
    "message": "Fix failing safe replace test.",
    "date": "2016-06-20T21:03:28Z",
    "url": "https://github.com/oracle/graal/commit/325ad064716920424eef6c1518d24fbe55a706b4",
    "details": {
      "sha": "9cc74d461b8650cccd16a2448890e4c14ae951e3",
      "filename": "truffle/com.oracle.truffle.api.test/src/com/oracle/truffle/api/nodes/SafeReplaceTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/oracle/graal/blob/325ad064716920424eef6c1518d24fbe55a706b4/truffle%2Fcom.oracle.truffle.api.test%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Fnodes%2FSafeReplaceTest.java",
      "raw_url": "https://github.com/oracle/graal/raw/325ad064716920424eef6c1518d24fbe55a706b4/truffle%2Fcom.oracle.truffle.api.test%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Fnodes%2FSafeReplaceTest.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/truffle%2Fcom.oracle.truffle.api.test%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fapi%2Fnodes%2FSafeReplaceTest.java?ref=325ad064716920424eef6c1518d24fbe55a706b4",
      "patch": "@@ -43,7 +43,7 @@ public void testCorrectReplacement() {\n         final TestNode oldChild = new TestNode();\n         final TestNode newChild = new TestNode();\n         root.child = oldChild;\n-        assertFalse(oldChild.isSafelyReplaceableBy(newChild));  // No parent node\n+        assertTrue(oldChild.isSafelyReplaceableBy(newChild));  // No parent node\n         root.adoptChildren();\n         assertTrue(oldChild.isSafelyReplaceableBy(newChild));   // Now adopted by parent\n         // new node\n@@ -62,7 +62,7 @@ public void testIncorrectReplacement() {\n         root.adoptChildren();\n         final TestNode newChild = new TestNode();\n         final TestNode strayChild = new TestNode();\n-        assertFalse(strayChild.isSafelyReplaceableBy(newChild)); // Stray not a child of parent\n+        assertTrue(strayChild.isSafelyReplaceableBy(newChild)); // Stray not a child of parent\n         final WrongTestNode wrongTypeNewChild = new WrongTestNode();\n         assertFalse(oldChild.isSafelyReplaceableBy(wrongTypeNewChild));\n     }",
      "parent_sha": "9d35d7c0758213d69a6860c12e96fa346d25b704"
    }
  },
  {
    "oid": "84fd1ff5d7f0472a3893df4a97adcd87db6a3705",
    "message": "GR-8486: send the original node's Class instead of wrapper's one",
    "date": "2018-03-02T09:54:01Z",
    "url": "https://github.com/oracle/graal/commit/84fd1ff5d7f0472a3893df4a97adcd87db6a3705",
    "details": {
      "sha": "53e33ce9b67cb4b4e358a2ad5fe3a8f0c5054d99",
      "filename": "compiler/src/org.graalvm.compiler.truffle.runtime/src/org/graalvm/compiler/truffle/runtime/TruffleTreeDumpHandler.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/oracle/graal/blob/84fd1ff5d7f0472a3893df4a97adcd87db6a3705/compiler%2Fsrc%2Forg.graalvm.compiler.truffle.runtime%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Ftruffle%2Fruntime%2FTruffleTreeDumpHandler.java",
      "raw_url": "https://github.com/oracle/graal/raw/84fd1ff5d7f0472a3893df4a97adcd87db6a3705/compiler%2Fsrc%2Forg.graalvm.compiler.truffle.runtime%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Ftruffle%2Fruntime%2FTruffleTreeDumpHandler.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/compiler%2Fsrc%2Forg.graalvm.compiler.truffle.runtime%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Ftruffle%2Fruntime%2FTruffleTreeDumpHandler.java?ref=84fd1ff5d7f0472a3893df4a97adcd87db6a3705",
      "patch": "@@ -474,7 +474,7 @@ public String nameTemplate(ASTNodeClass nodeClass) {\n \n         @Override\n         public Object nodeClassType(ASTNodeClass nodeClass) {\n-            return nodeClass.getClass();\n+            return nodeClass.node.source.getClass();\n         }\n \n         @Override",
      "parent_sha": "012435d3f3b925c685c7e96ecb292a30ee9ed2f1"
    }
  },
  {
    "oid": "5e8e349aa22c8cbac68b0721ff20cd838f5b2203",
    "message": "Warn when using -g on darwin with new debug info",
    "date": "2023-02-16T15:39:33Z",
    "url": "https://github.com/oracle/graal/commit/5e8e349aa22c8cbac68b0721ff20cd838f5b2203",
    "details": {
      "sha": "d1cab1e5a60e057caa024e8c812a33e39e01fee7",
      "filename": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java",
      "status": "modified",
      "additions": 11,
      "deletions": 5,
      "changes": 16,
      "blob_url": "https://github.com/oracle/graal/blob/5e8e349aa22c8cbac68b0721ff20cd838f5b2203/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2FSubstrateOptions.java",
      "raw_url": "https://github.com/oracle/graal/raw/5e8e349aa22c8cbac68b0721ff20cd838f5b2203/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2FSubstrateOptions.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm%2Fsrc%2Fcom.oracle.svm.core%2Fsrc%2Fcom%2Foracle%2Fsvm%2Fcore%2FSubstrateOptions.java?ref=5e8e349aa22c8cbac68b0721ff20cd838f5b2203",
      "patch": "@@ -617,7 +617,7 @@ public static int codeAlignment() {\n \n     @APIOption(name = \"-g\", fixedValue = \"2\", customHelp = \"generate debugging information\")//\n     @Option(help = \"Insert debug info into the generated native image or library\")//\n-    public static final HostedOptionKey<Integer> GenerateDebugInfo = new HostedOptionKey<>(0) {\n+    public static final HostedOptionKey<Integer> GenerateDebugInfo = new HostedOptionKey<>(0, SubstrateOptions::validateGenerateDebugInfo) {\n         @Override\n         protected void onValueUpdate(EconomicMap<OptionKey<?>, Object> values, Integer oldValue, Integer newValue) {\n             if (OS.WINDOWS.isCurrent()) {\n@@ -627,6 +627,12 @@ protected void onValueUpdate(EconomicMap<OptionKey<?>, Object> values, Integer o\n         }\n     };\n \n+    private static void validateGenerateDebugInfo(HostedOptionKey<Integer> optionKey) {\n+        if (OS.getCurrent() == OS.DARWIN && optionKey.hasBeenSet() && optionKey.getValue() > 0 && !SubstrateOptions.UseOldDebugInfo.getValue()) {\n+            System.out.printf(\"Warning: Using %s is not supported on macOS%n\", SubstrateOptionsParser.commandArgument(optionKey, optionKey.getValue().toString()));\n+        }\n+    }\n+\n     @Option(help = \"Control debug information output: 0 - no debuginfo, 1 - AOT code debuginfo, 2 - AOT and runtime code debuginfo (runtime code support only with -H:+UseOldDebugInfo).\", //\n                     deprecated = true, deprecationMessage = \"Please use the -g option.\")//\n     public static final HostedOptionKey<Integer> Debug = new HostedOptionKey<>(0) {\n@@ -663,11 +669,11 @@ public static Path getDebugInfoSourceCacheRoot() {\n     public static final HostedOptionKey<Boolean> StripDebugInfo = new HostedOptionKey<>(OS.getCurrent() != OS.DARWIN, SubstrateOptions::validateStripDebugInfo);\n \n     private static void validateStripDebugInfo(HostedOptionKey<Boolean> optionKey) {\n-        if (OS.getCurrent() == OS.DARWIN && optionKey.getValue()) {\n-            System.out.printf(\"Warning: Using %s not supported on macOS%n\", SubstrateOptionsParser.commandArgument(SubstrateOptions.StripDebugInfo, \"+\"));\n+        if (OS.getCurrent() == OS.DARWIN && optionKey.hasBeenSet() && optionKey.getValue()) {\n+            System.out.printf(\"Warning: Using %s is not supported on macOS%n\", SubstrateOptionsParser.commandArgument(SubstrateOptions.StripDebugInfo, \"+\"));\n         }\n-        if (OS.getCurrent() == OS.WINDOWS && !optionKey.getValue()) {\n-            System.out.printf(\"Warning: Using %s not supported on Windows: debug info is always generated in a separate file%n\", SubstrateOptionsParser.commandArgument(optionKey, \"-\"));\n+        if (OS.getCurrent() == OS.WINDOWS && optionKey.hasBeenSet() && !optionKey.getValue()) {\n+            System.out.printf(\"Warning: Using %s is not supported on Windows: debug info is always generated in a separate file%n\", SubstrateOptionsParser.commandArgument(optionKey, \"-\"));\n         }\n     }\n ",
      "parent_sha": "1979a0f7ec24f7bdacbcb25cca0e553a9c9b44d5"
    }
  },
  {
    "oid": "1d6a3da23001f24a6f9bd747bb7e3fe32d3465d4",
    "message": "Process inputs of ProxyNodes in the scheduler.",
    "date": "2015-01-28T14:07:54Z",
    "url": "https://github.com/oracle/graal/commit/1d6a3da23001f24a6f9bd747bb7e3fe32d3465d4",
    "details": {
      "sha": "75e30138d31f9c978109ec41b260e2c1c81236c2",
      "filename": "graal/com.oracle.graal.phases/src/com/oracle/graal/phases/schedule/SchedulePhase.java",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/oracle/graal/blob/1d6a3da23001f24a6f9bd747bb7e3fe32d3465d4/graal%2Fcom.oracle.graal.phases%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fphases%2Fschedule%2FSchedulePhase.java",
      "raw_url": "https://github.com/oracle/graal/raw/1d6a3da23001f24a6f9bd747bb7e3fe32d3465d4/graal%2Fcom.oracle.graal.phases%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fphases%2Fschedule%2FSchedulePhase.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.phases%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fphases%2Fschedule%2FSchedulePhase.java?ref=1d6a3da23001f24a6f9bd747bb7e3fe32d3465d4",
      "patch": "@@ -1068,7 +1068,13 @@ private void addUnscheduledToLatestSorting(VirtualState state, SortState sortSta\n     }\n \n     private void addToLatestSorting(ValueNode i, SortState state) {\n-        if (i == null || state.isVisited(i) || cfg.getNodeToBlock().get(i) != state.currentBlock() || i instanceof PhiNode || i instanceof ProxyNode) {\n+        if (i == null || state.isVisited(i) || cfg.getNodeToBlock().get(i) != state.currentBlock() || i instanceof PhiNode) {\n+            return;\n+        }\n+\n+        if (i instanceof ProxyNode) {\n+            ProxyNode proxyNode = (ProxyNode) i;\n+            addToLatestSorting(proxyNode.value(), state);\n             return;\n         }\n ",
      "parent_sha": "92865474d4b06809b0e712b024df8712ff9cd870"
    }
  },
  {
    "oid": "ea02d51d33e1be6f5ec582a593775adb77021218",
    "message": "Truffle: improved error mesage for accessing unknonw frame slots.",
    "date": "2013-11-22T13:45:09Z",
    "url": "https://github.com/oracle/graal/commit/ea02d51d33e1be6f5ec582a593775adb77021218",
    "details": {
      "sha": "a7088a8bf11cd741f88577e9f46431d41f3405ec",
      "filename": "graal/com.oracle.graal.truffle/src/com/oracle/graal/truffle/FrameWithoutBoxing.java",
      "status": "modified",
      "additions": 9,
      "deletions": 3,
      "changes": 12,
      "blob_url": "https://github.com/oracle/graal/blob/ea02d51d33e1be6f5ec582a593775adb77021218/graal%2Fcom.oracle.graal.truffle%2Fsrc%2Fcom%2Foracle%2Fgraal%2Ftruffle%2FFrameWithoutBoxing.java",
      "raw_url": "https://github.com/oracle/graal/raw/ea02d51d33e1be6f5ec582a593775adb77021218/graal%2Fcom.oracle.graal.truffle%2Fsrc%2Fcom%2Foracle%2Fgraal%2Ftruffle%2FFrameWithoutBoxing.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.truffle%2Fsrc%2Fcom%2Foracle%2Fgraal%2Ftruffle%2FFrameWithoutBoxing.java?ref=ea02d51d33e1be6f5ec582a593775adb77021218",
      "patch": "@@ -239,7 +239,9 @@ private void verifySet(FrameSlot slot, FrameSlotKind accessKind) {\n         int slotIndex = slot.getIndex();\n         if (slotIndex >= getTags().length) {\n             CompilerDirectives.transferToInterpreter();\n-            resize();\n+            if (!resize()) {\n+                throw new IllegalArgumentException(String.format(\"The frame slot '%s' is not known by the frame descriptor.\", slot));\n+            }\n         }\n         getTags()[slotIndex] = (byte) accessKind.ordinal();\n     }\n@@ -248,7 +250,9 @@ private void verifyGet(FrameSlot slot, FrameSlotKind accessKind) throws FrameSlo\n         int slotIndex = slot.getIndex();\n         if (slotIndex >= getTags().length) {\n             CompilerDirectives.transferToInterpreter();\n-            resize();\n+            if (!resize()) {\n+                throw new IllegalArgumentException(String.format(\"The frame slot '%s' is not known by the frame descriptor.\", slot));\n+            }\n         }\n         byte tag = this.getTags()[slotIndex];\n         if (tag != accessKind.ordinal()) {\n@@ -289,15 +293,17 @@ public Object getValue(FrameSlot slot) {\n         }\n     }\n \n-    private void resize() {\n+    private boolean resize() {\n         int oldSize = tags.length;\n         int newSize = descriptor.getSize();\n         if (newSize > oldSize) {\n             locals = Arrays.copyOf(locals, newSize);\n             Arrays.fill(locals, oldSize, newSize, descriptor.getTypeConversion().getDefaultValue());\n             primitiveLocals = Arrays.copyOf(primitiveLocals, newSize);\n             tags = Arrays.copyOf(tags, newSize);\n+            return true;\n         }\n+        return false;\n     }\n \n     private byte getTag(FrameSlot slot) {",
      "parent_sha": "5efb4b36f0d94084be0119059fdc2f5ecfddcee6"
    }
  },
  {
    "oid": "97d306ef02b620b3d9f38f3123d23f9051f19a71",
    "message": "fail fast in jargraal if Unsafe in inaccessible",
    "date": "2024-09-27T09:44:01Z",
    "url": "https://github.com/oracle/graal/commit/97d306ef02b620b3d9f38f3123d23f9051f19a71",
    "details": {
      "sha": "d6c8842b7120867d727a9481f096c996d3fe4893",
      "filename": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/hotspot/HotSpotGraalCompilerFactory.java",
      "status": "modified",
      "additions": 24,
      "deletions": 1,
      "changes": 25,
      "blob_url": "https://github.com/oracle/graal/blob/97d306ef02b620b3d9f38f3123d23f9051f19a71/compiler%2Fsrc%2Fjdk.graal.compiler%2Fsrc%2Fjdk%2Fgraal%2Fcompiler%2Fhotspot%2FHotSpotGraalCompilerFactory.java",
      "raw_url": "https://github.com/oracle/graal/raw/97d306ef02b620b3d9f38f3123d23f9051f19a71/compiler%2Fsrc%2Fjdk.graal.compiler%2Fsrc%2Fjdk%2Fgraal%2Fcompiler%2Fhotspot%2FHotSpotGraalCompilerFactory.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/compiler%2Fsrc%2Fjdk.graal.compiler%2Fsrc%2Fjdk%2Fgraal%2Fcompiler%2Fhotspot%2FHotSpotGraalCompilerFactory.java?ref=97d306ef02b620b3d9f38f3123d23f9051f19a71",
      "patch": "@@ -169,8 +169,9 @@ static class Options {\n \n     @Override\n     public HotSpotGraalCompiler createCompiler(JVMCIRuntime runtime) {\n-        ensureInitialized();\n         HotSpotJVMCIRuntime hsRuntime = (HotSpotJVMCIRuntime) runtime;\n+        checkUnsafeAccess(hsRuntime);\n+        ensureInitialized();\n         if (optionsFailure != null) {\n             System.err.printf(\"Error parsing Graal options: %s%nError: A fatal exception has occurred. Program will exit.%n\", optionsFailure.getMessage());\n             HotSpotGraalServices.exit(1, hsRuntime);\n@@ -195,6 +196,28 @@ public HotSpotGraalCompiler createCompiler(JVMCIRuntime runtime) {\n         return compiler;\n     }\n \n+    /**\n+     * Exit the VM now if {@code jdk.internal.misc.Unsafe} is not accessible.\n+     */\n+    private void checkUnsafeAccess(HotSpotJVMCIRuntime hsRuntime) {\n+        if (Services.IS_IN_NATIVE_IMAGE) {\n+            // Access checks were performed when building libgraal.\n+            return;\n+        }\n+        try {\n+            jdk.internal.misc.Unsafe.getUnsafe();\n+        } catch (IllegalAccessError e) {\n+            Module module = getClass().getModule();\n+            String targets = module.getName();\n+            String ee = \"com.oracle.graal.graal_enterprise\";\n+            if (module.getDescriptor().exports().stream().anyMatch(export -> export.targets().contains(ee))) {\n+                targets += \",\" + ee;\n+            }\n+            System.err.printf(\"Error: jargraal requires --add-exports=java.base/jdk.internal.misc=%s to be specified to the launcher.%n\", targets);\n+            HotSpotGraalServices.exit(1, hsRuntime);\n+        }\n+    }\n+\n     /**\n      * Creates a new {@link HotSpotGraalRuntime} object and a new {@link HotSpotGraalCompiler} and\n      * returns the latter.",
      "parent_sha": "589514c33a609bfe7633a196017015cd2e3b587e"
    }
  },
  {
    "oid": "239e5bddf95ff4004a7e306aaa41c22a5e450586",
    "message": "Fix for removeIntermediateMaterialization.",
    "date": "2013-04-28T05:06:31Z",
    "url": "https://github.com/oracle/graal/commit/239e5bddf95ff4004a7e306aaa41c22a5e450586",
    "details": {
      "sha": "3c1299717401ea0562376db4f06d345680910c1f",
      "filename": "graal/com.oracle.graal.nodes/src/com/oracle/graal/nodes/IfNode.java",
      "status": "modified",
      "additions": 17,
      "deletions": 10,
      "changes": 27,
      "blob_url": "https://github.com/oracle/graal/blob/239e5bddf95ff4004a7e306aaa41c22a5e450586/graal%2Fcom.oracle.graal.nodes%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fnodes%2FIfNode.java",
      "raw_url": "https://github.com/oracle/graal/raw/239e5bddf95ff4004a7e306aaa41c22a5e450586/graal%2Fcom.oracle.graal.nodes%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fnodes%2FIfNode.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.nodes%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fnodes%2FIfNode.java?ref=239e5bddf95ff4004a7e306aaa41c22a5e450586",
      "patch": "@@ -157,13 +157,15 @@ public void simplify(SimplifierTool tool) {\n                 ((StructuredGraph) graph()).removeSplit(this, falseSuccessor());\n                 return;\n             }\n-        } else if (trueSuccessor().guards().isEmpty() && falseSuccessor().guards().isEmpty()) {\n+        } else if (trueSuccessor().usages().isEmpty() && falseSuccessor().usages().isEmpty()) {\n+\n             if (removeOrMaterializeIf(tool)) {\n                 return;\n             }\n-        }\n-        if (removeIntermediateMaterialization(tool)) {\n-            return;\n+\n+            if (removeIntermediateMaterialization(tool)) {\n+                return;\n+            }\n         }\n \n         if (falseSuccessor().usages().isEmpty() && (!(falseSuccessor() instanceof LoopExitNode)) && falseSuccessor().next() instanceof IfNode) {\n@@ -413,11 +415,12 @@ private boolean removeIntermediateMaterialization(SimplifierTool tool) {\n             return false;\n         }\n \n-        MergeNode merge = (MergeNode) predecessor();\n-        if (!merge.anchored().isEmpty()) {\n+        if (predecessor() instanceof LoopBeginNode) {\n             return false;\n         }\n \n+        MergeNode merge = (MergeNode) predecessor();\n+\n         // Only consider merges with a single usage that is both a phi and an operand of the\n         // comparison\n         NodeIterable<Node> mergeUsages = merge.usages();\n@@ -442,10 +445,7 @@ private boolean removeIntermediateMaterialization(SimplifierTool tool) {\n         }\n \n         List<EndNode> mergePredecessors = merge.cfgPredecessors().snapshot();\n-        if (phi.valueCount() != merge.forwardEndCount()) {\n-            // Handles a loop begin merge\n-            return false;\n-        }\n+        assert phi.valueCount() == merge.forwardEndCount();\n \n         Constant[] xs = constantValues(compare.x(), merge);\n         Constant[] ys = constantValues(compare.y(), merge);\n@@ -504,6 +504,13 @@ private void connectEnds(List<EndNode> ends, Map<EndNode, ValueNode> phiValues,\n         } else {\n             if (ends.size() == 1) {\n                 EndNode end = ends.get(0);\n+                FrameState stateAfter = oldMerge.stateAfter();\n+                if (stateAfter != null) {\n+                    stateAfter = stateAfter.duplicate();\n+                    PhiNode oldPhi = (PhiNode) oldMerge.usages().first();\n+                    stateAfter.replaceFirstInput(oldPhi, phiValues.get(end));\n+                    successor.setStateAfter(stateAfter);\n+                }\n                 ((FixedWithNextNode) end.predecessor()).setNext(successor);\n                 oldMerge.removeEnd(end);\n                 GraphUtil.killCFG(end);",
      "parent_sha": "8b6cfb00a094a4ff2b00bc7365c8bde2459e36d2"
    }
  },
  {
    "oid": "3de4ec0faa35f86c0fd53579bff5762cc49b6112",
    "message": "canonicalize IntegerSwitchNode with only a default successor",
    "date": "2012-09-12T09:29:34Z",
    "url": "https://github.com/oracle/graal/commit/3de4ec0faa35f86c0fd53579bff5762cc49b6112",
    "details": {
      "sha": "d8456190f99636a3ab8c6b560531de53a4c8d3fa",
      "filename": "graal/com.oracle.graal.nodes/src/com/oracle/graal/nodes/extended/IntegerSwitchNode.java",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/oracle/graal/blob/3de4ec0faa35f86c0fd53579bff5762cc49b6112/graal%2Fcom.oracle.graal.nodes%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fnodes%2Fextended%2FIntegerSwitchNode.java",
      "raw_url": "https://github.com/oracle/graal/raw/3de4ec0faa35f86c0fd53579bff5762cc49b6112/graal%2Fcom.oracle.graal.nodes%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fnodes%2Fextended%2FIntegerSwitchNode.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.nodes%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fnodes%2Fextended%2FIntegerSwitchNode.java?ref=3de4ec0faa35f86c0fd53579bff5762cc49b6112",
      "patch": "@@ -91,7 +91,10 @@ public void generate(LIRGeneratorTool gen) {\n \n     @Override\n     public void simplify(SimplifierTool tool) {\n-        if (value() instanceof ConstantNode) {\n+        if (blockSuccessorCount() == 1) {\n+            tool.addToWorkList(defaultSuccessor());\n+            ((StructuredGraph) graph()).removeSplitPropagate(this, defaultSuccessorIndex());\n+        } else if (value() instanceof ConstantNode) {\n             int constant = value().asConstant().asInt();\n \n             int survivingEdge = keySuccessorIndex(keyCount());\n@@ -107,8 +110,7 @@ public void simplify(SimplifierTool tool) {\n             }\n             tool.addToWorkList(blockSuccessor(survivingEdge));\n             ((StructuredGraph) graph()).removeSplitPropagate(this, survivingEdge);\n-        }\n-        if (value() != null) {\n+        } else if (value() != null) {\n             IntegerStamp stamp = value().integerStamp();\n             if (!stamp.isUnrestricted()) {\n                 int validKeys = 0;",
      "parent_sha": "47e37ccf9e3e4e0ea303936b059fd5fbc6cba416"
    }
  },
  {
    "oid": "c8cca81d9b1e14a85325066888bce6286c53c483",
    "message": "Returning OSR result by exception removed to fix AOT benchmark regressions",
    "date": "2022-03-04T11:44:34Z",
    "url": "https://github.com/oracle/graal/commit/c8cca81d9b1e14a85325066888bce6286c53c483",
    "details": {
      "sha": "578863e34c3648acabd91bfc23bee90e499f7416",
      "filename": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/nodes/control/LLVMDispatchBasicBlockNode.java",
      "status": "modified",
      "additions": 163,
      "deletions": 150,
      "changes": 313,
      "blob_url": "https://github.com/oracle/graal/blob/c8cca81d9b1e14a85325066888bce6286c53c483/sulong%2Fprojects%2Fcom.oracle.truffle.llvm.runtime%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fruntime%2Fnodes%2Fcontrol%2FLLVMDispatchBasicBlockNode.java",
      "raw_url": "https://github.com/oracle/graal/raw/c8cca81d9b1e14a85325066888bce6286c53c483/sulong%2Fprojects%2Fcom.oracle.truffle.llvm.runtime%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fruntime%2Fnodes%2Fcontrol%2FLLVMDispatchBasicBlockNode.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/sulong%2Fprojects%2Fcom.oracle.truffle.llvm.runtime%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Fruntime%2Fnodes%2Fcontrol%2FLLVMDispatchBasicBlockNode.java?ref=c8cca81d9b1e14a85325066888bce6286c53c483",
      "patch": "@@ -36,7 +36,6 @@\n import com.oracle.truffle.api.instrumentation.StandardTags;\n import com.oracle.truffle.api.instrumentation.Tag;\n import com.oracle.truffle.api.nodes.BytecodeOSRNode;\n-import com.oracle.truffle.api.nodes.ControlFlowException;\n import com.oracle.truffle.api.nodes.ExplodeLoop;\n import com.oracle.truffle.api.nodes.ExplodeLoop.LoopExplosionKind;\n import com.oracle.truffle.api.nodes.LoopNode;\n@@ -77,184 +76,198 @@ public LocalVariableDebugInfo getDebugInfo() {\n \n     @Specialization\n     public Object doDispatch(VirtualFrame frame) {\n-        return dispatchFromBasicBlock(frame, 0, new Counter());\n+        return dispatchFromBasicBlock(frame, 0, new Counters());\n     }\n \n     /**\n      * The code in this function is mirrored in {@link LLVMLoopDispatchNode}, any changes need to be\n      * done in both places.\n      */\n     @ExplodeLoop(kind = LoopExplosionKind.MERGE_EXPLODE)\n-    private Object dispatchFromBasicBlock(VirtualFrame frame, int bci, Counter counter) {\n-        assert counter != null;\n-\n+    private Object dispatchFromBasicBlock(VirtualFrame frame, int bci, Counters counters) {\n         Object returnValue = null;\n         int basicBlockIndex = bci;\n \n         CompilerAsserts.partialEvaluationConstant(bodyNodes.length);\n-        try {\n-            outer: while (basicBlockIndex != LLVMBasicBlockNode.RETURN_FROM_FUNCTION) {\n-                CompilerAsserts.partialEvaluationConstant(basicBlockIndex);\n-                LLVMBasicBlockNode bb = bodyNodes[basicBlockIndex];\n+        outer: while (basicBlockIndex != LLVMBasicBlockNode.RETURN_FROM_FUNCTION) {\n+            CompilerAsserts.partialEvaluationConstant(basicBlockIndex);\n+            if (CompilerDirectives.hasNextTier()) {\n+                if (basicBlockIndex <= counters.previousBasicBlockIndex) {\n+                    counters.backEdgeCounter++;\n+                    if (CompilerDirectives.inInterpreter() && LLVMContext.get(this).getOSRMode() == SulongEngineOption.OSRMode.BYTECODE && BytecodeOSRNode.pollOSRBackEdge(this)) {\n+                        returnValue = BytecodeOSRNode.tryOSR(this, basicBlockIndex, counters, null, frame);\n+                        if (returnValue != null) {\n+                            break outer;\n+                        }\n+                    }\n+                }\n+                counters.previousBasicBlockIndex = basicBlockIndex; // remember this block for next\n+                // iteration\n+            }\n+            LLVMBasicBlockNode bb = bodyNodes[basicBlockIndex];\n \n-                // lazily insert the basic block into the AST\n-                bb.initialize();\n+            // lazily insert the basic block into the AST\n+            bb.initialize();\n \n-                // the newly inserted block may have been instrumented\n-                bb = bodyNodes[basicBlockIndex];\n+            // the newly inserted block may have been instrumented\n+            bb = bodyNodes[basicBlockIndex];\n \n-                // execute all statements\n-                bb.execute(frame);\n+            // execute all statements\n+            bb.execute(frame);\n \n-                // execute control flow node, write phis, null stack frame slots, and dispatch to\n-                // the correct successor block\n-                LLVMControlFlowNode controlFlowNode = bb.getTerminatingInstruction();\n-                if (controlFlowNode instanceof LLVMConditionalBranchNode) {\n-                    LLVMConditionalBranchNode conditionalBranchNode = (LLVMConditionalBranchNode) controlFlowNode;\n-                    boolean condition = conditionalBranchNode.executeCondition(frame);\n-                    if (CompilerDirectives.injectBranchProbability(bb.getBranchProbability(LLVMConditionalBranchNode.TRUE_SUCCESSOR), condition)) {\n-                        bb.enterSuccessor(LLVMConditionalBranchNode.TRUE_SUCCESSOR);\n-                        basicBlockIndex = beforeJumpChecks(basicBlockIndex, conditionalBranchNode.getTrueSuccessor(), LLVMConditionalBranchNode.TRUE_SUCCESSOR, counter, controlFlowNode, frame);\n-                        // continue outer;\n-                    } else {\n-                        bb.enterSuccessor(LLVMConditionalBranchNode.FALSE_SUCCESSOR);\n-                        basicBlockIndex = beforeJumpChecks(basicBlockIndex, conditionalBranchNode.getFalseSuccessor(), LLVMConditionalBranchNode.FALSE_SUCCESSOR, counter, controlFlowNode, frame);\n-                    }\n-                } else if (controlFlowNode instanceof LLVMSwitchNode) {\n-                    LLVMSwitchNode switchNode = (LLVMSwitchNode) controlFlowNode;\n-                    Object condition = switchNode.executeCondition(frame);\n-                    int[] successors = switchNode.getSuccessors();\n-                    for (int i = 0; i < successors.length - 1; i++) {\n-                        if (CompilerDirectives.injectBranchProbability(bb.getBranchProbability(i), switchNode.checkCase(frame, i, condition))) {\n-                            bb.enterSuccessor(i);\n-                            basicBlockIndex = beforeJumpChecks(basicBlockIndex, successors[i], i, counter, controlFlowNode, frame);\n-                            continue outer;\n-                        }\n+            // execute control flow node, write phis, null stack frame slots, and dispatch to\n+            // the correct successor block\n+            LLVMControlFlowNode controlFlowNode = bb.getTerminatingInstruction();\n+            if (controlFlowNode instanceof LLVMConditionalBranchNode) {\n+                LLVMConditionalBranchNode conditionalBranchNode = (LLVMConditionalBranchNode) controlFlowNode;\n+                boolean condition = conditionalBranchNode.executeCondition(frame);\n+                if (CompilerDirectives.injectBranchProbability(bb.getBranchProbability(LLVMConditionalBranchNode.TRUE_SUCCESSOR), condition)) {\n+                    bb.enterSuccessor(LLVMConditionalBranchNode.TRUE_SUCCESSOR);\n+                    nullDeadSlots(frame, bb.nullableAfter);\n+                    executePhis(frame, conditionalBranchNode, LLVMConditionalBranchNode.TRUE_SUCCESSOR);\n+                    basicBlockIndex = conditionalBranchNode.getTrueSuccessor();\n+                    nullDeadSlots(frame, bodyNodes[basicBlockIndex].nullableBefore);\n+                    continue outer;\n+                } else {\n+                    bb.enterSuccessor(LLVMConditionalBranchNode.FALSE_SUCCESSOR);\n+                    nullDeadSlots(frame, bb.nullableAfter);\n+                    executePhis(frame, conditionalBranchNode, LLVMConditionalBranchNode.FALSE_SUCCESSOR);\n+                    basicBlockIndex = conditionalBranchNode.getFalseSuccessor();\n+                    nullDeadSlots(frame, bodyNodes[basicBlockIndex].nullableBefore);\n+                    continue outer;\n+                }\n+            } else if (controlFlowNode instanceof LLVMSwitchNode) {\n+                LLVMSwitchNode switchNode = (LLVMSwitchNode) controlFlowNode;\n+                Object condition = switchNode.executeCondition(frame);\n+                int[] successors = switchNode.getSuccessors();\n+                for (int i = 0; i < successors.length - 1; i++) {\n+                    if (CompilerDirectives.injectBranchProbability(bb.getBranchProbability(i), switchNode.checkCase(frame, i, condition))) {\n+                        bb.enterSuccessor(i);\n+                        nullDeadSlots(frame, bb.nullableAfter);\n+                        executePhis(frame, switchNode, i);\n+                        basicBlockIndex = successors[i];\n+                        nullDeadSlots(frame, bodyNodes[basicBlockIndex].nullableBefore);\n+                        continue outer;\n                     }\n+                }\n \n-                    int i = successors.length - 1;\n-                    bb.enterSuccessor(i);\n-                    basicBlockIndex = beforeJumpChecks(basicBlockIndex, successors[i], i, counter, controlFlowNode, frame);\n-                } else if (controlFlowNode instanceof LLVMLoopNode) {\n-                    LLVMLoopNode loop = (LLVMLoopNode) controlFlowNode;\n-                    loop.executeLoop(frame);\n-                    int successorBasicBlockIndex = frame.getInt(loopSuccessorSlot);\n-                    frame.setInt(loopSuccessorSlot, 0); // null frame\n-                    int[] successors = loop.getSuccessors();\n-                    for (int i = 0; i < successors.length - 1; i++) {\n-                        if (successorBasicBlockIndex == successors[i]) {\n-                            basicBlockIndex = beforeJumpChecks(basicBlockIndex, successors[i], -1, counter, null, frame);\n-                            continue outer;\n-                        }\n+                int i = successors.length - 1;\n+                bb.enterSuccessor(i);\n+                nullDeadSlots(frame, bb.nullableAfter);\n+                executePhis(frame, switchNode, i);\n+                basicBlockIndex = successors[i];\n+                nullDeadSlots(frame, bodyNodes[basicBlockIndex].nullableBefore);\n+                continue outer;\n+            } else if (controlFlowNode instanceof LLVMLoopNode) {\n+                LLVMLoopNode loop = (LLVMLoopNode) controlFlowNode;\n+                loop.executeLoop(frame);\n+                int successorBasicBlockIndex = frame.getInt(loopSuccessorSlot);\n+                frame.setInt(loopSuccessorSlot, 0); // null frame\n+                int[] successors = loop.getSuccessors();\n+                for (int i = 0; i < successors.length - 1; i++) {\n+                    if (successorBasicBlockIndex == successors[i]) {\n+                        basicBlockIndex = successors[i];\n+                        continue outer;\n                     }\n-                    int i = successors.length - 1;\n-                    assert successors[i] == successorBasicBlockIndex : \"Could not find loop successor!\";\n-                    basicBlockIndex = beforeJumpChecks(basicBlockIndex, successors[i], -1, counter, null, frame);\n-                } else if (controlFlowNode instanceof LLVMIndirectBranchNode) {\n-                    // TODO (chaeubl): we need a different approach here - this is awfully\n-                    // inefficient (see GR-3664)\n-                    LLVMIndirectBranchNode indirectBranchNode = (LLVMIndirectBranchNode) controlFlowNode;\n-                    int[] successors = indirectBranchNode.getSuccessors();\n-                    int successorBasicBlockIndex = indirectBranchNode.executeCondition(frame);\n-                    for (int i = 0; i < successors.length - 1; i++) {\n-                        if (CompilerDirectives.injectBranchProbability(bb.getBranchProbability(i), successors[i] == successorBasicBlockIndex)) {\n-                            bb.enterSuccessor(i);\n-                            basicBlockIndex = beforeJumpChecks(basicBlockIndex, successors[i], i, counter, controlFlowNode, frame);\n-                            continue outer;\n-                        }\n+                }\n+                int i = successors.length - 1;\n+                assert successors[i] == successorBasicBlockIndex : \"Could not find loop successor!\";\n+                basicBlockIndex = successors[i];\n+                continue outer;\n+            } else if (controlFlowNode instanceof LLVMIndirectBranchNode) {\n+                // TODO (chaeubl): we need a different approach here - this is awfully\n+                // inefficient (see GR-3664)\n+                LLVMIndirectBranchNode indirectBranchNode = (LLVMIndirectBranchNode) controlFlowNode;\n+                int[] successors = indirectBranchNode.getSuccessors();\n+                int successorBasicBlockIndex = indirectBranchNode.executeCondition(frame);\n+                for (int i = 0; i < successors.length - 1; i++) {\n+                    if (CompilerDirectives.injectBranchProbability(bb.getBranchProbability(i), successors[i] == successorBasicBlockIndex)) {\n+                        bb.enterSuccessor(i);\n+                        nullDeadSlots(frame, bb.nullableAfter);\n+                        executePhis(frame, indirectBranchNode, i);\n+                        basicBlockIndex = successors[i];\n+                        nullDeadSlots(frame, bodyNodes[basicBlockIndex].nullableBefore);\n+                        continue outer;\n                     }\n+                }\n \n-                    int i = successors.length - 1;\n-                    assert successorBasicBlockIndex == successors[i];\n-                    bb.enterSuccessor(i);\n-                    basicBlockIndex = beforeJumpChecks(basicBlockIndex, successors[i], i, counter, indirectBranchNode, frame);\n-                } else if (controlFlowNode instanceof LLVMBrUnconditionalNode) {\n-                    LLVMBrUnconditionalNode unconditionalNode = (LLVMBrUnconditionalNode) controlFlowNode;\n-                    unconditionalNode.execute(frame); // required for instrumentation\n-                    basicBlockIndex = beforeJumpChecks(basicBlockIndex, unconditionalNode.getSuccessor(), 0, counter, controlFlowNode, frame);\n-                } else if (controlFlowNode instanceof LLVMInvokeNode) {\n-                    LLVMInvokeNode invokeNode = (LLVMInvokeNode) controlFlowNode;\n-                    try {\n-                        invokeNode.execute(frame);\n-                        bb.enterSuccessor(LLVMInvokeNode.NORMAL_SUCCESSOR);\n-                        basicBlockIndex = beforeJumpChecks(basicBlockIndex, invokeNode.getNormalSuccessor(), LLVMInvokeNode.NORMAL_SUCCESSOR, counter, controlFlowNode, frame);\n-                    } catch (LLVMUserException e) {\n-                        bb.enterSuccessor(LLVMInvokeNode.UNWIND_SUCCESSOR);\n-                        frame.setObject(exceptionValueSlot, e);\n-                        basicBlockIndex = beforeJumpChecks(basicBlockIndex, invokeNode.getUnwindSuccessor(), LLVMInvokeNode.UNWIND_SUCCESSOR, counter, controlFlowNode, frame);\n-                    }\n-                } else if (controlFlowNode instanceof LLVMRetNode) {\n-                    LLVMRetNode retNode = (LLVMRetNode) controlFlowNode;\n-                    returnValue = retNode.execute(frame);\n-                    assert noPhisNecessary(retNode);\n+                int i = successors.length - 1;\n+                assert successorBasicBlockIndex == successors[i];\n+                bb.enterSuccessor(i);\n+                nullDeadSlots(frame, bb.nullableAfter);\n+                executePhis(frame, indirectBranchNode, i);\n+                basicBlockIndex = successors[i];\n+                nullDeadSlots(frame, bodyNodes[basicBlockIndex].nullableBefore);\n+                continue outer;\n+            } else if (controlFlowNode instanceof LLVMBrUnconditionalNode) {\n+                LLVMBrUnconditionalNode unconditionalNode = (LLVMBrUnconditionalNode) controlFlowNode;\n+                unconditionalNode.execute(frame); // required for instrumentation\n+                nullDeadSlots(frame, bb.nullableAfter);\n+                executePhis(frame, unconditionalNode, 0);\n+                basicBlockIndex = unconditionalNode.getSuccessor();\n+                nullDeadSlots(frame, bodyNodes[basicBlockIndex].nullableBefore);\n+                continue outer;\n+            } else if (controlFlowNode instanceof LLVMInvokeNode) {\n+                LLVMInvokeNode invokeNode = (LLVMInvokeNode) controlFlowNode;\n+                try {\n+                    invokeNode.execute(frame);\n+                    bb.enterSuccessor(LLVMInvokeNode.NORMAL_SUCCESSOR);\n                     nullDeadSlots(frame, bb.nullableAfter);\n-                    basicBlockIndex = beforeJumpChecks(basicBlockIndex, retNode.getSuccessor(), -1, counter, null, frame);\n-                } else if (controlFlowNode instanceof LLVMResumeNode) {\n-                    LLVMResumeNode resumeNode = (LLVMResumeNode) controlFlowNode;\n-                    assert noPhisNecessary(resumeNode);\n-                    resumeNode.execute(frame);\n-                    CompilerDirectives.transferToInterpreterAndInvalidate();\n-                    throw new IllegalStateException(\"must not reach here\");\n-                } else if (controlFlowNode instanceof LLVMUnreachableNode) {\n-                    LLVMUnreachableNode unreachableNode = (LLVMUnreachableNode) controlFlowNode;\n-                    assert noPhisNecessary(unreachableNode);\n-                    unreachableNode.execute(frame);\n-                    CompilerDirectives.transferToInterpreterAndInvalidate();\n-                    throw new IllegalStateException(\"must not reach here\");\n-                } else {\n-                    CompilerDirectives.transferToInterpreterAndInvalidate();\n-                    throw new UnsupportedOperationException(\"unexpected controlFlowNode type: \" + controlFlowNode);\n+                    executePhis(frame, invokeNode, LLVMInvokeNode.NORMAL_SUCCESSOR);\n+                    basicBlockIndex = invokeNode.getNormalSuccessor();\n+                    nullDeadSlots(frame, bodyNodes[basicBlockIndex].nullableBefore);\n+                    continue outer;\n+                } catch (LLVMUserException e) {\n+                    bb.enterSuccessor(LLVMInvokeNode.UNWIND_SUCCESSOR);\n+                    frame.setObject(exceptionValueSlot, e);\n+                    nullDeadSlots(frame, bb.nullableAfter);\n+                    executePhis(frame, invokeNode, LLVMInvokeNode.UNWIND_SUCCESSOR);\n+                    basicBlockIndex = invokeNode.getUnwindSuccessor();\n+                    nullDeadSlots(frame, bodyNodes[basicBlockIndex].nullableBefore);\n+                    continue outer;\n                 }\n+            } else if (controlFlowNode instanceof LLVMRetNode) {\n+                LLVMRetNode retNode = (LLVMRetNode) controlFlowNode;\n+                returnValue = retNode.execute(frame);\n+                assert noPhisNecessary(retNode);\n+                nullDeadSlots(frame, bb.nullableAfter);\n+                basicBlockIndex = retNode.getSuccessor();\n+                continue outer;\n+            } else if (controlFlowNode instanceof LLVMResumeNode) {\n+                LLVMResumeNode resumeNode = (LLVMResumeNode) controlFlowNode;\n+                assert noPhisNecessary(resumeNode);\n+                resumeNode.execute(frame);\n+                CompilerDirectives.transferToInterpreterAndInvalidate();\n+                throw new IllegalStateException(\"must not reach here\");\n+            } else if (controlFlowNode instanceof LLVMUnreachableNode) {\n+                LLVMUnreachableNode unreachableNode = (LLVMUnreachableNode) controlFlowNode;\n+                assert noPhisNecessary(unreachableNode);\n+                unreachableNode.execute(frame);\n+                CompilerDirectives.transferToInterpreterAndInvalidate();\n+                throw new IllegalStateException(\"must not reach here\");\n+            } else {\n+                CompilerDirectives.transferToInterpreterAndInvalidate();\n+                throw new UnsupportedOperationException(\"unexpected controlFlowNode type: \" + controlFlowNode);\n             }\n-        } catch (OSRReturnException e) {\n-            returnValue = e.getResult();\n         }\n         // only report non-zero counters to reduce interpreter overhead\n-        int value = counter.value;\n-        if (CompilerDirectives.hasNextTier() && value != 0) {\n-            LoopNode.reportLoopCount(this, value > 0 ? value : Integer.MAX_VALUE);\n+        if (CompilerDirectives.hasNextTier() && counters.backEdgeCounter != 0) {\n+            LoopNode.reportLoopCount(this, counters.backEdgeCounter > 0 ? counters.backEdgeCounter : Integer.MAX_VALUE);\n         }\n-\n         assert returnValue != null;\n         return returnValue;\n     }\n \n-    int beforeJumpChecks(int currentBCI, int nextBCI, int successorIndex, Counter counter, LLVMControlFlowNode controlFlowNode, VirtualFrame frame) {\n-        if (controlFlowNode != null) {\n-            nullDeadSlots(frame, bodyNodes[currentBCI].nullableAfter);\n-            executePhis(frame, controlFlowNode, successorIndex);\n-            nullDeadSlots(frame, bodyNodes[nextBCI].nullableBefore);\n-        }\n-\n-        if (CompilerDirectives.hasNextTier()) {\n-            if (nextBCI <= currentBCI) {\n-                counter.value++;\n-                if (CompilerDirectives.inInterpreter() && LLVMContext.get(this).getOSRMode() == SulongEngineOption.OSRMode.BYTECODE && BytecodeOSRNode.pollOSRBackEdge(this)) {\n-                    Object returnValue = BytecodeOSRNode.tryOSR(this, nextBCI, counter, null, frame);\n-                    if (returnValue != null) {\n-                        throw new OSRReturnException(returnValue);\n-                    }\n-                }\n-            }\n-        }\n-        return nextBCI;\n-    }\n-\n-    private static final class Counter {\n-        private int value;\n-    }\n-\n-    private static final class OSRReturnException extends ControlFlowException {\n-        private static final long serialVersionUID = 9137598429747678409L;\n-        private final Object result;\n-\n-        OSRReturnException(Object result) {\n-            this.result = result;\n-        }\n-\n-        Object getResult() {\n-            return result;\n-        }\n+    /**\n+     * Smaller than int[1], does not kill int[] on write and doesn't need bounds checks.\n+     */\n+    private static final class Counters {\n+        /*\n+         * Maintain backEdgeCounter in Counter so that the compiler does not confuse it with the\n+         * basicBlockIndex because both are constant within the loop (GR-35072).\n+         */\n+        int backEdgeCounter;\n+        int previousBasicBlockIndex = Integer.MIN_VALUE;\n     }\n \n     @ExplodeLoop\n@@ -292,7 +305,7 @@ public boolean hasTag(Class<? extends Tag> tag) {\n \n     @Override\n     public final Object executeOSR(VirtualFrame osrFrame, int target, Object interpreterState) {\n-        return dispatchFromBasicBlock(osrFrame, target, (Counter) interpreterState);\n+        return dispatchFromBasicBlock(osrFrame, target, (Counters) interpreterState);\n     }\n \n     @Override",
      "parent_sha": "e9c293d18bf8a42620fba5bdce8bd4e46390ba6e"
    }
  },
  {
    "oid": "2a0c48cf32ecf6f91812359031e6f4435a8b6a7f",
    "message": "Truffle-DSL: fix crash for findNearestEnclosingType",
    "date": "2015-02-12T11:44:43Z",
    "url": "https://github.com/oracle/graal/commit/2a0c48cf32ecf6f91812359031e6f4435a8b6a7f",
    "details": {
      "sha": "882f33ac71b7b64dc306f87a70a9631acc19cda8",
      "filename": "graal/com.oracle.truffle.dsl.processor/src/com/oracle/truffle/dsl/processor/java/ElementUtils.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/oracle/graal/blob/2a0c48cf32ecf6f91812359031e6f4435a8b6a7f/graal%2Fcom.oracle.truffle.dsl.processor%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fdsl%2Fprocessor%2Fjava%2FElementUtils.java",
      "raw_url": "https://github.com/oracle/graal/raw/2a0c48cf32ecf6f91812359031e6f4435a8b6a7f/graal%2Fcom.oracle.truffle.dsl.processor%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fdsl%2Fprocessor%2Fjava%2FElementUtils.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.truffle.dsl.processor%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fdsl%2Fprocessor%2Fjava%2FElementUtils.java?ref=2a0c48cf32ecf6f91812359031e6f4435a8b6a7f",
      "patch": "@@ -569,7 +569,7 @@ public static List<Element> getElementHierarchy(Element e) {\n     public static TypeElement findNearestEnclosingType(Element element) {\n         List<Element> elements = getElementHierarchy(element);\n         for (Element e : elements) {\n-            if (e.getKind().isClass()) {\n+            if (e.getKind().isClass() || e.getKind().isInterface()) {\n                 return (TypeElement) e;\n             }\n         }",
      "parent_sha": "a6ca66cbb1f997ae19755c379c608db15926a760"
    }
  },
  {
    "oid": "2984f959873fcc9b00b2f3ac0ec3bb21ac95ca75",
    "message": "Fix polyglot launcher",
    "date": "2017-09-20T09:57:51Z",
    "url": "https://github.com/oracle/graal/commit/2984f959873fcc9b00b2f3ac0ec3bb21ac95ca75",
    "details": {
      "sha": "7751e88f032dc32a9f8e2fcf3aca56baedfe2ea1",
      "filename": "sdk/src/org.graalvm.launcher/src/org/graalvm/launcher/PolyglotLauncher.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/oracle/graal/blob/2984f959873fcc9b00b2f3ac0ec3bb21ac95ca75/sdk%2Fsrc%2Forg.graalvm.launcher%2Fsrc%2Forg%2Fgraalvm%2Flauncher%2FPolyglotLauncher.java",
      "raw_url": "https://github.com/oracle/graal/raw/2984f959873fcc9b00b2f3ac0ec3bb21ac95ca75/sdk%2Fsrc%2Forg.graalvm.launcher%2Fsrc%2Forg%2Fgraalvm%2Flauncher%2FPolyglotLauncher.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/sdk%2Fsrc%2Forg.graalvm.launcher%2Fsrc%2Forg%2Fgraalvm%2Flauncher%2FPolyglotLauncher.java?ref=2984f959873fcc9b00b2f3ac0ec3bb21ac95ca75",
      "patch": "@@ -28,6 +28,7 @@\n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n@@ -95,7 +96,7 @@ protected void printVersion() {\n     private void launch(String[] args) {\n         List<String> arguments = new ArrayList<>(Arrays.asList(args));\n         if (isAOT()) {\n-            nativeAccess.maybeExec(arguments, true, null, VMType.Native);\n+            nativeAccess.maybeExec(arguments, true, Collections.emptyMap(), VMType.Native);\n             nativeAccess.setGraalVMProperties();\n         }\n ",
      "parent_sha": "3a80250368eec3f4df9cdd9660fdec85218a8d53"
    }
  },
  {
    "oid": "6c2ffe0c3a30abd0acd75840b74959c199196737",
    "message": "[inlining-4] one less alias in getExactInlineInfo()",
    "date": "2014-05-19T14:32:02Z",
    "url": "https://github.com/oracle/graal/commit/6c2ffe0c3a30abd0acd75840b74959c199196737",
    "details": {
      "sha": "4f17a1cf97cef140d9b373e5c3e986d3ead3a873",
      "filename": "graal/com.oracle.graal.phases.common/src/com/oracle/graal/phases/common/inlining/walker/InliningData.java",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/oracle/graal/blob/6c2ffe0c3a30abd0acd75840b74959c199196737/graal%2Fcom.oracle.graal.phases.common%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fphases%2Fcommon%2Finlining%2Fwalker%2FInliningData.java",
      "raw_url": "https://github.com/oracle/graal/raw/6c2ffe0c3a30abd0acd75840b74959c199196737/graal%2Fcom.oracle.graal.phases.common%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fphases%2Fcommon%2Finlining%2Fwalker%2FInliningData.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.phases.common%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fphases%2Fcommon%2Finlining%2Fwalker%2FInliningData.java?ref=6c2ffe0c3a30abd0acd75840b74959c199196737",
      "patch": "@@ -108,7 +108,7 @@ public InlineInfo getInlineInfo(Invoke invoke, Assumptions assumptions) {\n         final OptimisticOptimizations optimisticOpts = context.getOptimisticOptimizations();\n \n         if (callTarget.invokeKind() == MethodCallTargetNode.InvokeKind.Special || targetMethod.canBeStaticallyBound()) {\n-            return getExactInlineInfo(invoke, optimisticOpts, targetMethod);\n+            return getExactInlineInfo(invoke, targetMethod);\n         }\n \n         assert callTarget.invokeKind() == MethodCallTargetNode.InvokeKind.Virtual || callTarget.invokeKind() == MethodCallTargetNode.InvokeKind.Interface;\n@@ -133,7 +133,7 @@ public InlineInfo getInlineInfo(Invoke invoke, Assumptions assumptions) {\n                     assert targetMethod.getDeclaringClass().isAssignableFrom(holder) : holder + \" subtype of \" + targetMethod.getDeclaringClass() + \" for \" + targetMethod;\n                     ResolvedJavaMethod resolvedMethod = holder.resolveMethod(targetMethod, contextType);\n                     if (resolvedMethod != null) {\n-                        return getExactInlineInfo(invoke, optimisticOpts, resolvedMethod);\n+                        return getExactInlineInfo(invoke, resolvedMethod);\n                     }\n                 }\n             }\n@@ -143,7 +143,7 @@ public InlineInfo getInlineInfo(Invoke invoke, Assumptions assumptions) {\n             // arrays can be treated as Objects\n             ResolvedJavaMethod resolvedMethod = holder.resolveMethod(targetMethod, contextType);\n             if (resolvedMethod != null) {\n-                return getExactInlineInfo(invoke, optimisticOpts, resolvedMethod);\n+                return getExactInlineInfo(invoke, resolvedMethod);\n             }\n         }\n \n@@ -298,9 +298,9 @@ public InlineInfo getAssumptionInlineInfo(Invoke invoke, OptimisticOptimizations\n         return new AssumptionInlineInfo(invoke, concrete, takenAssumption);\n     }\n \n-    public InlineInfo getExactInlineInfo(Invoke invoke, OptimisticOptimizations optimisticOpts, ResolvedJavaMethod targetMethod) {\n+    public InlineInfo getExactInlineInfo(Invoke invoke, ResolvedJavaMethod targetMethod) {\n         assert !targetMethod.isAbstract();\n-        if (!InliningUtil.checkTargetConditions(this, context.getReplacements(), invoke, targetMethod, optimisticOpts)) {\n+        if (!InliningUtil.checkTargetConditions(this, context.getReplacements(), invoke, targetMethod, context.getOptimisticOptimizations())) {\n             return null;\n         }\n         return new ExactInlineInfo(invoke, targetMethod);",
      "parent_sha": "a1b3568bc26ffe1694fb753bec4168ed59c5b7eb"
    }
  },
  {
    "oid": "1939e1fd3978f4a1799f51eb9e8bdb71ae9a66d5",
    "message": "rename graal-core compiler configuration from basic to core",
    "date": "2016-09-26T13:07:40Z",
    "url": "https://github.com/oracle/graal/commit/1939e1fd3978f4a1799f51eb9e8bdb71ae9a66d5",
    "details": {
      "sha": "67a876e2516e32e16a8b1083761acbecdf7c142c",
      "filename": "graal/com.oracle.graal.hotspot/src/com/oracle/graal/hotspot/CoreCompilerConfigurationFactory.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/oracle/graal/blob/1939e1fd3978f4a1799f51eb9e8bdb71ae9a66d5/graal%2Fcom.oracle.graal.hotspot%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fhotspot%2FCoreCompilerConfigurationFactory.java",
      "raw_url": "https://github.com/oracle/graal/raw/1939e1fd3978f4a1799f51eb9e8bdb71ae9a66d5/graal%2Fcom.oracle.graal.hotspot%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fhotspot%2FCoreCompilerConfigurationFactory.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.hotspot%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fhotspot%2FCoreCompilerConfigurationFactory.java?ref=1939e1fd3978f4a1799f51eb9e8bdb71ae9a66d5",
      "patch": "@@ -29,7 +29,7 @@\n @ServiceProvider(CompilerConfigurationFactory.class)\n public class CoreCompilerConfigurationFactory extends CompilerConfigurationFactory {\n \n-    public static final String NAME = \"basic\";\n+    public static final String NAME = \"core\";\n \n     public static final int AUTO_SELECTION_PRIORITY = 2;\n ",
      "parent_sha": "538cc5ce800d87ea5a382df893d8322e84138953"
    }
  },
  {
    "oid": "63ae6541e6f345fb1303bf605dcf5a30409591b5",
    "message": "removed static access to HotSpotGraalRuntime from KlassLayoutHelperNode",
    "date": "2014-11-26T09:02:49Z",
    "url": "https://github.com/oracle/graal/commit/63ae6541e6f345fb1303bf605dcf5a30409591b5",
    "details": {
      "sha": "b4479f5065f00cff7abd2e7f63b554012d0c3967",
      "filename": "graal/com.oracle.graal.hotspot/src/com/oracle/graal/hotspot/replacements/KlassLayoutHelperNode.java",
      "status": "modified",
      "additions": 14,
      "deletions": 17,
      "changes": 31,
      "blob_url": "https://github.com/oracle/graal/blob/63ae6541e6f345fb1303bf605dcf5a30409591b5/graal%2Fcom.oracle.graal.hotspot%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fhotspot%2Freplacements%2FKlassLayoutHelperNode.java",
      "raw_url": "https://github.com/oracle/graal/raw/63ae6541e6f345fb1303bf605dcf5a30409591b5/graal%2Fcom.oracle.graal.hotspot%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fhotspot%2Freplacements%2FKlassLayoutHelperNode.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.hotspot%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fhotspot%2Freplacements%2FKlassLayoutHelperNode.java?ref=63ae6541e6f345fb1303bf605dcf5a30409591b5",
      "patch": "@@ -22,13 +22,13 @@\n  */\n package com.oracle.graal.hotspot.replacements;\n \n-import static com.oracle.graal.hotspot.HotSpotGraalRuntime.*;\n import static com.oracle.graal.hotspot.replacements.HotSpotReplacementsUtil.*;\n \n import com.oracle.graal.api.meta.*;\n import com.oracle.graal.compiler.common.type.*;\n import com.oracle.graal.graph.*;\n import com.oracle.graal.graph.spi.*;\n+import com.oracle.graal.hotspot.*;\n import com.oracle.graal.hotspot.meta.*;\n import com.oracle.graal.nodeinfo.*;\n import com.oracle.graal.nodes.*;\n@@ -37,30 +37,27 @@\n import com.oracle.graal.nodes.spi.*;\n \n /**\n- * Read Klass::_layout_helper and incorporate any useful stamp information based on any type\n+ * Read {@code Klass::_layout_helper} and incorporate any useful stamp information based on any type\n  * information in {@code klass}.\n  */\n @NodeInfo\n public class KlassLayoutHelperNode extends FloatingGuardedNode implements Canonicalizable, Lowerable {\n \n     @Input protected ValueNode klass;\n+    protected final HotSpotVMConfig config;\n \n-    public static KlassLayoutHelperNode create(ValueNode klass) {\n-        return new KlassLayoutHelperNode(klass);\n+    public static KlassLayoutHelperNode create(@InjectedNodeParameter HotSpotVMConfig config, ValueNode klass) {\n+        return new KlassLayoutHelperNode(config, klass, null);\n     }\n \n-    public static KlassLayoutHelperNode create(ValueNode klass, ValueNode guard) {\n-        return new KlassLayoutHelperNode(klass, guard);\n+    public static KlassLayoutHelperNode create(@InjectedNodeParameter HotSpotVMConfig config, ValueNode klass, ValueNode guard) {\n+        return new KlassLayoutHelperNode(config, klass, guard);\n     }\n \n-    protected KlassLayoutHelperNode(ValueNode klass) {\n-        super(StampFactory.forKind(Kind.Int));\n-        this.klass = klass;\n-    }\n-\n-    protected KlassLayoutHelperNode(ValueNode klass, ValueNode guard) {\n+    protected KlassLayoutHelperNode(HotSpotVMConfig config, ValueNode klass, ValueNode guard) {\n         super(StampFactory.forKind(Kind.Int), (GuardingNode) guard);\n         this.klass = klass;\n+        this.config = config;\n     }\n \n     @Override\n@@ -76,10 +73,10 @@ public boolean inferStamp() {\n                         /*\n                          * Definitely some form of instance type.\n                          */\n-                        return updateStamp(StampFactory.forInteger(Kind.Int, runtime().getConfig().klassLayoutHelperNeutralValue, Integer.MAX_VALUE));\n+                        return updateStamp(StampFactory.forInteger(Kind.Int, config.klassLayoutHelperNeutralValue, Integer.MAX_VALUE));\n                     }\n                     if (type.isArray()) {\n-                        return updateStamp(StampFactory.forInteger(Kind.Int, Integer.MIN_VALUE, runtime().getConfig().klassLayoutHelperNeutralValue - 1));\n+                        return updateStamp(StampFactory.forInteger(Kind.Int, Integer.MIN_VALUE, config.klassLayoutHelperNeutralValue - 1));\n                     }\n                 }\n             }\n@@ -94,7 +91,7 @@ public Node canonical(CanonicalizerTool tool) {\n         } else {\n             if (klass.isConstant()) {\n                 if (!klass.asConstant().isDefaultForKind()) {\n-                    Constant constant = stamp().readConstant(tool.getConstantReflection().getMemoryAccessProvider(), klass.asJavaConstant(), runtime().getConfig().klassLayoutHelperOffset);\n+                    Constant constant = stamp().readConstant(tool.getConstantReflection().getMemoryAccessProvider(), klass.asJavaConstant(), config.klassLayoutHelperOffset);\n                     return ConstantNode.forConstant(stamp(), constant, tool.getMetaAccess());\n                 }\n             }\n@@ -106,7 +103,7 @@ public Node canonical(CanonicalizerTool tool) {\n                     HotSpotResolvedObjectType type = (HotSpotResolvedObjectType) ostamp.type();\n                     if (type != null && type.isArray() && !type.getComponentType().isPrimitive()) {\n                         // The layout for all object arrays is the same.\n-                        Constant constant = stamp().readConstant(tool.getConstantReflection().getMemoryAccessProvider(), type.klass(), runtime().getConfig().klassLayoutHelperOffset);\n+                        Constant constant = stamp().readConstant(tool.getConstantReflection().getMemoryAccessProvider(), type.klass(), config.klassLayoutHelperOffset);\n                         return ConstantNode.forConstant(stamp(), constant, tool.getMetaAccess());\n                     }\n                 }\n@@ -120,7 +117,7 @@ public void lower(LoweringTool tool) {\n         if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {\n             return;\n         }\n-        LocationNode location = ConstantLocationNode.create(KLASS_LAYOUT_HELPER_LOCATION, Kind.Int, runtime().getConfig().klassLayoutHelperOffset, graph());\n+        LocationNode location = ConstantLocationNode.create(KLASS_LAYOUT_HELPER_LOCATION, Kind.Int, config.klassLayoutHelperOffset, graph());\n         assert !klass.isConstant();\n         graph().replaceFloating(this, graph().unique(FloatingReadNode.create(klass, location, null, stamp(), getGuard(), BarrierType.NONE)));\n     }",
      "parent_sha": "39bc23797a7bc246d53f526f5f6ae96ff05493d9"
    }
  },
  {
    "oid": "b2bcc76941ebd8c264974fe380294610d81c12d0",
    "message": "Fix AArch64 signExtend constant folding ignoring output bits",
    "date": "2023-12-19T14:40:54Z",
    "url": "https://github.com/oracle/graal/commit/b2bcc76941ebd8c264974fe380294610d81c12d0",
    "details": {
      "sha": "73082f13097fdc0126063c23793978605e04d802",
      "filename": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/core/aarch64/AArch64ArithmeticLIRGenerator.java",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/oracle/graal/blob/b2bcc76941ebd8c264974fe380294610d81c12d0/compiler%2Fsrc%2Fjdk.graal.compiler%2Fsrc%2Fjdk%2Fgraal%2Fcompiler%2Fcore%2Faarch64%2FAArch64ArithmeticLIRGenerator.java",
      "raw_url": "https://github.com/oracle/graal/raw/b2bcc76941ebd8c264974fe380294610d81c12d0/compiler%2Fsrc%2Fjdk.graal.compiler%2Fsrc%2Fjdk%2Fgraal%2Fcompiler%2Fcore%2Faarch64%2FAArch64ArithmeticLIRGenerator.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/compiler%2Fsrc%2Fjdk.graal.compiler%2Fsrc%2Fjdk%2Fgraal%2Fcompiler%2Fcore%2Faarch64%2FAArch64ArithmeticLIRGenerator.java?ref=b2bcc76941ebd8c264974fe380294610d81c12d0",
      "patch": "@@ -363,12 +363,11 @@ public Value emitSignExtend(Value inputVal, int fromBits, int toBits) {\n             /*\n              * Performing sign extend via a left shift followed by an arithmetic right shift. First,\n              * a left shift of (64 - fromBits) is performed to remove non-meaningful bits, and then\n-             * an arithmetic right shift is used to set correctly all sign bits. Note the \"toBits\"\n-             * size is not considered, as the constant is saved as a long value.\n+             * an arithmetic right shift is used to set correctly all sign bits.\n              */\n             int shiftSize = 64 - fromBits;\n             long signExtendedValue = (constant << shiftSize) >> shiftSize;\n-            return new ConstantValue(resultKind, JavaConstant.forLong(signExtendedValue));\n+            return new ConstantValue(resultKind, JavaConstant.forPrimitiveInt(toBits, signExtendedValue));\n         }\n         Variable result = getLIRGen().newVariable(resultKind);\n         getLIRGen().append(new AArch64Convert.SignExtendOp(result, asAllocatable(inputVal), fromBits, toBits));",
      "parent_sha": "c203aac336154710279d84f2c802010923cc31a2"
    }
  },
  {
    "oid": "34e891e587cbd60e7f0c0c7c4b0d06174d24d0d6",
    "message": "[GR-29298] Specialize HostObject.getArraySize.",
    "date": "2021-03-02T12:56:10Z",
    "url": "https://github.com/oracle/graal/commit/34e891e587cbd60e7f0c0c7c4b0d06174d24d0d6",
    "details": {
      "sha": "d9cfc04df6287547a23b61af63fb90ce4a79553b",
      "filename": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/HostObject.java",
      "status": "modified",
      "additions": 21,
      "deletions": 10,
      "changes": 31,
      "blob_url": "https://github.com/oracle/graal/blob/34e891e587cbd60e7f0c0c7c4b0d06174d24d0d6/truffle%2Fsrc%2Fcom.oracle.truffle.polyglot%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fpolyglot%2FHostObject.java",
      "raw_url": "https://github.com/oracle/graal/raw/34e891e587cbd60e7f0c0c7c4b0d06174d24d0d6/truffle%2Fsrc%2Fcom.oracle.truffle.polyglot%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fpolyglot%2FHostObject.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/truffle%2Fsrc%2Fcom.oracle.truffle.polyglot%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fpolyglot%2FHostObject.java?ref=34e891e587cbd60e7f0c0c7c4b0d06174d24d0d6",
      "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and/or its affiliates. All rights reserved.\n  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n  *\n  * The Universal Permissive License (UPL), Version 1.0\n@@ -662,16 +662,27 @@ protected static Object doNotArrayOrList(HostObject receiver, long index,\n     }\n \n     @ExportMessage\n-    long getArraySize(@Shared(\"isArray\") @Cached IsArrayNode isArray,\n-                    @Shared(\"isList\") @Cached IsListNode isList,\n-                    @Shared(\"error\") @Cached BranchProfile error) throws UnsupportedMessageException {\n-        if (isArray.execute(this)) {\n-            return Array.getLength(obj);\n-        } else if (isList.execute(this)) {\n-            return getListSize();\n+    abstract static class GetArraySize {\n+\n+        @Specialization(guards = {\"isArray.execute(receiver)\"}, limit = \"1\")\n+        protected static long doArray(HostObject receiver,\n+                        @Shared(\"isArray\") @Cached IsArrayNode isArray) {\n+            return Array.getLength(receiver.obj);\n         }\n-        error.enter();\n-        throw UnsupportedMessageException.create();\n+\n+        @Specialization(guards = {\"isList.execute(receiver)\"}, limit = \"1\")\n+        protected static long doList(HostObject receiver,\n+                        @Shared(\"isList\") @Cached IsListNode isList) {\n+            return receiver.getListSize();\n+        }\n+\n+        @Specialization(guards = {\"!isArray.execute(receiver)\", \"!isList.execute(receiver)\"}, limit = \"1\")\n+        protected static long doNotArrayOrList(HostObject receiver,\n+                        @Shared(\"isArray\") @Cached IsArrayNode isArray,\n+                        @Shared(\"isList\") @Cached IsListNode isList) throws UnsupportedMessageException {\n+            throw UnsupportedMessageException.create();\n+        }\n+\n     }\n \n     // region Buffer Messages",
      "parent_sha": "a468957c03450f98dfc10ccd3f5b0826970c9313"
    }
  },
  {
    "oid": "ac77b1baa77057a6a475c455f73daf978b583699",
    "message": "Avoid double null check.",
    "date": "2020-02-27T10:52:16Z",
    "url": "https://github.com/oracle/graal/commit/ac77b1baa77057a6a475c455f73daf978b583699",
    "details": {
      "sha": "15b1b98b8c1cd90a2b601fba066f5be65c49ad31",
      "filename": "truffle/src/com.oracle.truffle.dsl.processor/src/com/oracle/truffle/dsl/processor/parser/SpecializationMethodParser.java",
      "status": "modified",
      "additions": 5,
      "deletions": 7,
      "changes": 12,
      "blob_url": "https://github.com/oracle/graal/blob/ac77b1baa77057a6a475c455f73daf978b583699/truffle%2Fsrc%2Fcom.oracle.truffle.dsl.processor%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fdsl%2Fprocessor%2Fparser%2FSpecializationMethodParser.java",
      "raw_url": "https://github.com/oracle/graal/raw/ac77b1baa77057a6a475c455f73daf978b583699/truffle%2Fsrc%2Fcom.oracle.truffle.dsl.processor%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fdsl%2Fprocessor%2Fparser%2FSpecializationMethodParser.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/truffle%2Fsrc%2Fcom.oracle.truffle.dsl.processor%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fdsl%2Fprocessor%2Fparser%2FSpecializationMethodParser.java?ref=ac77b1baa77057a6a475c455f73daf978b583699",
      "patch": "@@ -94,6 +94,7 @@ public DeclaredType getAnnotationType() {\n     private SpecializationData parseSpecialization(TemplateMethod method) {\n         List<SpecializationThrowsData> exceptionData = new ArrayList<>();\n         boolean unexpectedResultRewrite = false;\n+        boolean annotated = false;\n         if (method.getMethod() != null) {\n             AnnotationValue rewriteValue = ElementUtils.getAnnotationValue(method.getMarkerAnnotation(), \"rewriteOn\");\n             List<TypeMirror> exceptionTypes = ElementUtils.getAnnotationValueList(TypeMirror.class, method.getMarkerAnnotation(), \"rewriteOn\");\n@@ -122,9 +123,9 @@ public int compare(SpecializationThrowsData o1, SpecializationThrowsData o2) {\n                     return ElementUtils.compareByTypeHierarchy(o1.getJavaClass(), o2.getJavaClass());\n                 }\n             });\n+            annotated = isAnnotatedWithReportPolymorphismExclude(method);\n         }\n-        SpecializationData specialization = new SpecializationData(getNode(), method, SpecializationKind.SPECIALIZED, exceptionData, unexpectedResultRewrite,\n-                        !isAnnotatedWithReportPolymorphismExclude(method));\n+        SpecializationData specialization = new SpecializationData(getNode(), method, SpecializationKind.SPECIALIZED, exceptionData, unexpectedResultRewrite, !annotated);\n \n         if (method.getMethod() != null) {\n             String insertBeforeName = ElementUtils.getAnnotationValue(String.class, method.getMarkerAnnotation(), \"insertBefore\");\n@@ -154,10 +155,7 @@ public int compare(SpecializationThrowsData o1, SpecializationThrowsData o2) {\n     }\n \n     private boolean isAnnotatedWithReportPolymorphismExclude(TemplateMethod method) {\n-        final ExecutableElement executableElement = method.getMethod();\n-        if (executableElement != null) {\n-            return ElementUtils.findAnnotationMirror(method.getMethod(), types.ReportPolymorphism_Exclude) != null;\n-        }\n-        return false;\n+        assert method.getMethod() != null;\n+        return ElementUtils.findAnnotationMirror(method.getMethod(), types.ReportPolymorphism_Exclude) != null;\n     }\n }",
      "parent_sha": "b7d694c4e1ae4dd50c01e3814b974cec237e41f3"
    }
  },
  {
    "oid": "30fc80bc2a2ce426da733ef477107a32848b710f",
    "message": "added help text to CompileTheWorld options",
    "date": "2013-08-29T19:31:15Z",
    "url": "https://github.com/oracle/graal/commit/30fc80bc2a2ce426da733ef477107a32848b710f",
    "details": {
      "sha": "1e33a540b51dd8c0891c2529b835cfb0c285a782",
      "filename": "graal/com.oracle.graal.phases/src/com/oracle/graal/phases/GraalOptions.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/oracle/graal/blob/30fc80bc2a2ce426da733ef477107a32848b710f/graal%2Fcom.oracle.graal.phases%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fphases%2FGraalOptions.java",
      "raw_url": "https://github.com/oracle/graal/raw/30fc80bc2a2ce426da733ef477107a32848b710f/graal%2Fcom.oracle.graal.phases%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fphases%2FGraalOptions.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.phases%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fphases%2FGraalOptions.java?ref=30fc80bc2a2ce426da733ef477107a32848b710f",
      "patch": "@@ -89,12 +89,12 @@ public final class GraalOptions {\n     @Option(help = \"\")\n     public static final OptionValue<Integer> DeoptsToDisableOptimisticOptimization = new OptionValue<>(40);\n \n-    // comilation queue\n-    @Option(help = \"\")\n+    // compilation queue\n+    @Option(help = \"Compile all methods in all classes on given class path\")\n     public static final OptionValue<String> CompileTheWorld = new OptionValue<>(null);\n-    @Option(help = \"\")\n+    @Option(help = \"First class to consider when using CompileTheWorld\")\n     public static final OptionValue<Integer> CompileTheWorldStartAt = new OptionValue<>(1);\n-    @Option(help = \"\")\n+    @Option(help = \"Last class to consider when using CompileTheWorld\")\n     public static final OptionValue<Integer> CompileTheWorldStopAt = new OptionValue<>(Integer.MAX_VALUE);\n \n     // graph caching",
      "parent_sha": "26435fcd62f9c2f6731cae6c9761d9825ac87864"
    }
  },
  {
    "oid": "d8baf71562d47e6b2dfcb2bdadd23842287222a5",
    "message": "G1PostWriteBarrier contains a memory barrier, so it has to kill any().",
    "date": "2015-04-21T12:57:13Z",
    "url": "https://github.com/oracle/graal/commit/d8baf71562d47e6b2dfcb2bdadd23842287222a5",
    "details": {
      "sha": "63b3678d33ba8733f6847c0772367698962a8361",
      "filename": "graal/com.oracle.graal.hotspot/src/com/oracle/graal/hotspot/nodes/G1PostWriteBarrier.java",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/oracle/graal/blob/d8baf71562d47e6b2dfcb2bdadd23842287222a5/graal%2Fcom.oracle.graal.hotspot%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fhotspot%2Fnodes%2FG1PostWriteBarrier.java",
      "raw_url": "https://github.com/oracle/graal/raw/d8baf71562d47e6b2dfcb2bdadd23842287222a5/graal%2Fcom.oracle.graal.hotspot%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fhotspot%2Fnodes%2FG1PostWriteBarrier.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/graal%2Fcom.oracle.graal.hotspot%2Fsrc%2Fcom%2Foracle%2Fgraal%2Fhotspot%2Fnodes%2FG1PostWriteBarrier.java?ref=d8baf71562d47e6b2dfcb2bdadd23842287222a5",
      "patch": "@@ -22,13 +22,14 @@\n  */\n package com.oracle.graal.hotspot.nodes;\n \n+import com.oracle.graal.api.meta.*;\n import com.oracle.graal.graph.*;\n import com.oracle.graal.nodeinfo.*;\n import com.oracle.graal.nodes.*;\n import com.oracle.graal.nodes.extended.*;\n \n @NodeInfo\n-public class G1PostWriteBarrier extends WriteBarrier {\n+public class G1PostWriteBarrier extends WriteBarrier implements MemoryCheckpoint.Single {\n \n     public static final NodeClass<G1PostWriteBarrier> TYPE = NodeClass.create(G1PostWriteBarrier.class);\n     protected final boolean alwaysNull;\n@@ -45,4 +46,8 @@ protected G1PostWriteBarrier(NodeClass<? extends G1PostWriteBarrier> c, ValueNod\n     public boolean alwaysNull() {\n         return alwaysNull;\n     }\n+\n+    public LocationIdentity getLocationIdentity() {\n+        return LocationIdentity.any();\n+    }\n }",
      "parent_sha": "1c3e66aea692172542837fa942fa17300537335e"
    }
  },
  {
    "oid": "6ab7736174ea87ad6dd53c42a7a9be7daaa0e2d7",
    "message": "Sulong: add allowExperimentalOptions for managed testing suite",
    "date": "2020-10-23T13:06:35Z",
    "url": "https://github.com/oracle/graal/commit/6ab7736174ea87ad6dd53c42a7a9be7daaa0e2d7",
    "details": {
      "sha": "72bf27c4b5150694c893aeeeb3d507bbf4bb2504",
      "filename": "sulong/tests/com.oracle.truffle.llvm.tests/src/com/oracle/truffle/llvm/tests/BaseSuiteHarness.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/oracle/graal/blob/6ab7736174ea87ad6dd53c42a7a9be7daaa0e2d7/sulong%2Ftests%2Fcom.oracle.truffle.llvm.tests%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Ftests%2FBaseSuiteHarness.java",
      "raw_url": "https://github.com/oracle/graal/raw/6ab7736174ea87ad6dd53c42a7a9be7daaa0e2d7/sulong%2Ftests%2Fcom.oracle.truffle.llvm.tests%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Ftests%2FBaseSuiteHarness.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/sulong%2Ftests%2Fcom.oracle.truffle.llvm.tests%2Fsrc%2Fcom%2Foracle%2Ftruffle%2Fllvm%2Ftests%2FBaseSuiteHarness.java?ref=6ab7736174ea87ad6dd53c42a7a9be7daaa0e2d7",
      "patch": "@@ -107,7 +107,7 @@ protected void validateResults(Path referenceBinary, ProcessUtil.ProcessResult r\n \n     @BeforeClass\n     public static void createEngine() {\n-        engine = Engine.newBuilder().build();\n+        engine = Engine.newBuilder().allowExperimentalOptions(true).build();\n     }\n \n     @AfterClass\n@@ -126,6 +126,7 @@ private void runCandidate(Path referenceBinary, ProcessResult referenceResult, P\n         String[] inputArgs = getInputArgs(candidateBinary);\n         ProcessResult result;\n         try {\n+            assert engine != null;\n             result = ProcessUtil.executeSulongTestMainSameEngine(candidateBinary.toAbsolutePath().toFile(), inputArgs, getContextOptions(), getCaptureOutput(), engine);\n         } catch (Exception e) {\n             throw fail(getTestName(), new Exception(\"Candidate binary that failed: \" + candidateBinary, e));",
      "parent_sha": "69cae7c178fd1686c55e81e1ddf6fe8a36ab14d4"
    }
  },
  {
    "oid": "a79ff61825ad7567d1f52ae0e38d8100fc084243",
    "message": "Prevent Clashes of Block Names",
    "date": "2016-09-27T20:26:48Z",
    "url": "https://github.com/oracle/graal/commit/a79ff61825ad7567d1f52ae0e38d8100fc084243",
    "details": {
      "sha": "2b033545ba3c62b0c8c3dfadeda4a8c90d2ce590",
      "filename": "projects/uk.ac.man.cs.llvm/src/uk/ac/man/cs/llvm/ir/model/FunctionDefinition.java",
      "status": "modified",
      "additions": 11,
      "deletions": 8,
      "changes": 19,
      "blob_url": "https://github.com/oracle/graal/blob/a79ff61825ad7567d1f52ae0e38d8100fc084243/projects%2Fuk.ac.man.cs.llvm%2Fsrc%2Fuk%2Fac%2Fman%2Fcs%2Fllvm%2Fir%2Fmodel%2FFunctionDefinition.java",
      "raw_url": "https://github.com/oracle/graal/raw/a79ff61825ad7567d1f52ae0e38d8100fc084243/projects%2Fuk.ac.man.cs.llvm%2Fsrc%2Fuk%2Fac%2Fman%2Fcs%2Fllvm%2Fir%2Fmodel%2FFunctionDefinition.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/projects%2Fuk.ac.man.cs.llvm%2Fsrc%2Fuk%2Fac%2Fman%2Fcs%2Fllvm%2Fir%2Fmodel%2FFunctionDefinition.java?ref=a79ff61825ad7567d1f52ae0e38d8100fc084243",
      "patch": "@@ -102,25 +102,28 @@ public void createParameter(Type type) {\n \n     @Override\n     public void exitFunction() {\n-        int identifier = 1; // Zero clashes with entry block in sulong\n+        int valueSymbolIdentifier = 0;\n+        int blockIdentifier = 1; // Zero clashes with entry block in sulong\n \n         // in K&R style function declarations the parameters are not assigned names\n-        for (FunctionParameter parameter : parameters) {\n+        for (final FunctionParameter parameter : parameters) {\n             if (ValueSymbol.UNKNOWN.equals(parameter.getName())) {\n-                parameter.setName(String.valueOf(identifier++));\n+                parameter.setName(String.valueOf(valueSymbolIdentifier++));\n             }\n         }\n \n-        for (InstructionBlock block : blocks) {\n+        for (final InstructionBlock block : blocks) {\n             if (block.getName().equals(ValueSymbol.UNKNOWN)) {\n-                block.setName(String.valueOf(identifier++));\n+                // compilers like to assign numbers as blocknames, we name unnamed blocks this way\n+                // to prevent name clashes\n+                block.setName(String.format(\"%s\\\"%d\\\"\", ValueSymbol.UNKNOWN, blockIdentifier++));\n             }\n             for (int i = 0; i < block.getInstructionCount(); i++) {\n-                Instruction instruction = block.getInstruction(i);\n+                final Instruction instruction = block.getInstruction(i);\n                 if (instruction instanceof ValueInstruction) {\n-                    ValueInstruction value = (ValueInstruction) instruction;\n+                    final ValueInstruction value = (ValueInstruction) instruction;\n                     if (value.getName().equals(ValueSymbol.UNKNOWN)) {\n-                        value.setName(String.valueOf(identifier++));\n+                        value.setName(String.valueOf(valueSymbolIdentifier++));\n                     }\n                 }\n             }",
      "parent_sha": "32861b0b1e429d3d58b6ff33f39b4b946056cd79"
    }
  },
  {
    "oid": "cf003dd0c7a4589484f2141c5818b01a85b58b1a",
    "message": "Remove Virtualizable from ValueAnchorNode",
    "date": "2023-11-26T19:51:59Z",
    "url": "https://github.com/oracle/graal/commit/cf003dd0c7a4589484f2141c5818b01a85b58b1a",
    "details": {
      "sha": "e89c6ce4df26f3db8af6345653247f35fc4dc674",
      "filename": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/extended/ValueAnchorNode.java",
      "status": "modified",
      "additions": 1,
      "deletions": 8,
      "changes": 9,
      "blob_url": "https://github.com/oracle/graal/blob/cf003dd0c7a4589484f2141c5818b01a85b58b1a/compiler%2Fsrc%2Fjdk.graal.compiler%2Fsrc%2Fjdk%2Fgraal%2Fcompiler%2Fnodes%2Fextended%2FValueAnchorNode.java",
      "raw_url": "https://github.com/oracle/graal/raw/cf003dd0c7a4589484f2141c5818b01a85b58b1a/compiler%2Fsrc%2Fjdk.graal.compiler%2Fsrc%2Fjdk%2Fgraal%2Fcompiler%2Fnodes%2Fextended%2FValueAnchorNode.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/compiler%2Fsrc%2Fjdk.graal.compiler%2Fsrc%2Fjdk%2Fgraal%2Fcompiler%2Fnodes%2Fextended%2FValueAnchorNode.java?ref=cf003dd0c7a4589484f2141c5818b01a85b58b1a",
      "patch": "@@ -40,8 +40,6 @@\n import jdk.graal.compiler.nodes.spi.CanonicalizerTool;\n import jdk.graal.compiler.nodes.spi.LIRLowerable;\n import jdk.graal.compiler.nodes.spi.NodeLIRBuilderTool;\n-import jdk.graal.compiler.nodes.spi.Virtualizable;\n-import jdk.graal.compiler.nodes.spi.VirtualizerTool;\n \n /**\n  * This node can be used to keep nodes below a certain point in the graph by using this node as an\n@@ -53,7 +51,7 @@\n  * {@link ControlFlowAnchored}.\n  */\n @NodeInfo(allowedUsageTypes = {Anchor, Guard}, cycles = CYCLES_0, size = SIZE_0)\n-public final class ValueAnchorNode extends FixedWithNextNode implements LIRLowerable, Canonicalizable, Virtualizable, AnchoringNode, GuardingNode, NodeWithIdentity {\n+public final class ValueAnchorNode extends FixedWithNextNode implements LIRLowerable, Canonicalizable, AnchoringNode, GuardingNode, NodeWithIdentity {\n \n     public static final NodeClass<ValueAnchorNode> TYPE = NodeClass.create(ValueAnchorNode.class);\n \n@@ -73,9 +71,4 @@ public Node canonical(CanonicalizerTool tool) {\n         }\n         return this;\n     }\n-\n-    @Override\n-    public void virtualize(VirtualizerTool tool) {\n-        tool.delete();\n-    }\n }",
      "parent_sha": "7b6c5d357d08e3d491f58a345cd77f24cb2400ce"
    }
  },
  {
    "oid": "3a41a416a056ae80c47f73a58479038deb65abde",
    "message": "Simplify logic for JDK 14+ reflection package name",
    "date": "2020-12-23T10:48:32Z",
    "url": "https://github.com/oracle/graal/commit/3a41a416a056ae80c47f73a58479038deb65abde",
    "details": {
      "sha": "7f84c43d0f3615314e62ce05866ed95014f12859",
      "filename": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/hosted/ReflectionSubstitution.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/oracle/graal/blob/3a41a416a056ae80c47f73a58479038deb65abde/substratevm%2Fsrc%2Fcom.oracle.svm.reflect%2Fsrc%2Fcom%2Foracle%2Fsvm%2Freflect%2Fhosted%2FReflectionSubstitution.java",
      "raw_url": "https://github.com/oracle/graal/raw/3a41a416a056ae80c47f73a58479038deb65abde/substratevm%2Fsrc%2Fcom.oracle.svm.reflect%2Fsrc%2Fcom%2Foracle%2Fsvm%2Freflect%2Fhosted%2FReflectionSubstitution.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/substratevm%2Fsrc%2Fcom.oracle.svm.reflect%2Fsrc%2Fcom%2Foracle%2Fsvm%2Freflect%2Fhosted%2FReflectionSubstitution.java?ref=3a41a416a056ae80c47f73a58479038deb65abde",
      "patch": "@@ -132,11 +132,11 @@ private static byte[] generateProxyClass(final String name, Class<?>[] interface\n     }\n \n     private static byte[] generateProxyClass14(final String name, Class<?>[] interfaces, ClassLoader loader) {\n+        assert JavaVersionUtil.JAVA_SPEC >= 14;\n         /* { Allow reflection in hosted code. Checkstyle: stop. */\n         try {\n             if (generateProxyMethod == null) {\n-                final String packageName = (JavaVersionUtil.JAVA_SPEC <= 8 ? \"sun.misc.\" : \"java.lang.reflect.\");\n-                generateProxyMethod = ReflectionUtil.lookupMethod(Class.forName(packageName + \"ProxyGenerator\"), \"generateProxyClass\", ClassLoader.class, String.class, List.class, int.class);\n+                generateProxyMethod = ReflectionUtil.lookupMethod(Class.forName(\"java.lang.reflect.ProxyGenerator\"), \"generateProxyClass\", ClassLoader.class, String.class, List.class, int.class);\n             }\n             List<Class<?>> ilist = new ArrayList<>(Arrays.asList(interfaces));\n             return (byte[]) generateProxyMethod.invoke(null, loader, name, ilist, (ACC_PUBLIC | ACC_FINAL | ACC_SUPER));",
      "parent_sha": "24959cc6f1392f80603d6e1d1633f1f66893adb7"
    }
  },
  {
    "oid": "7b23bf06999cba7ae603e1a7695a962f991bad32",
    "message": "loop peeling: cleanups",
    "date": "2020-02-07T13:40:21Z",
    "url": "https://github.com/oracle/graal/commit/7b23bf06999cba7ae603e1a7695a962f991bad32",
    "details": {
      "sha": "63a406011628864998720c8c24a63a950a379428",
      "filename": "compiler/src/org.graalvm.compiler.loop.phases/src/org/graalvm/compiler/loop/phases/LoopPeelingPhase.java",
      "status": "modified",
      "additions": 2,
      "deletions": 10,
      "changes": 12,
      "blob_url": "https://github.com/oracle/graal/blob/7b23bf06999cba7ae603e1a7695a962f991bad32/compiler%2Fsrc%2Forg.graalvm.compiler.loop.phases%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Floop%2Fphases%2FLoopPeelingPhase.java",
      "raw_url": "https://github.com/oracle/graal/raw/7b23bf06999cba7ae603e1a7695a962f991bad32/compiler%2Fsrc%2Forg.graalvm.compiler.loop.phases%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Floop%2Fphases%2FLoopPeelingPhase.java",
      "contents_url": "https://api.github.com/repos/oracle/graal/contents/compiler%2Fsrc%2Forg.graalvm.compiler.loop.phases%2Fsrc%2Forg%2Fgraalvm%2Fcompiler%2Floop%2Fphases%2FLoopPeelingPhase.java?ref=7b23bf06999cba7ae603e1a7695a962f991bad32",
      "patch": "@@ -25,9 +25,7 @@\n package org.graalvm.compiler.loop.phases;\n \n import org.graalvm.compiler.debug.CounterKey;\n-import org.graalvm.compiler.debug.DebugCloseable;\n import org.graalvm.compiler.debug.DebugContext;\n-import org.graalvm.compiler.debug.TimerKey;\n import org.graalvm.compiler.loop.LoopEx;\n import org.graalvm.compiler.loop.LoopPolicies;\n import org.graalvm.compiler.loop.LoopsData;\n@@ -38,8 +36,6 @@ public class LoopPeelingPhase extends LoopPhase<LoopPolicies> {\n \n     public static final CounterKey PEELED = DebugContext.counter(\"Peeled\");\n \n-    public static final TimerKey TimerHeuristic = DebugContext.timer(\"Peeling_Heuristic\");\n-\n     public LoopPeelingPhase(LoopPolicies policies) {\n         super(policies);\n     }\n@@ -53,11 +49,7 @@ protected void run(StructuredGraph graph, CoreProviders context) {\n             try (DebugContext.Scope s = debug.scope(\"peeling\", data.getCFG())) {\n                 for (LoopEx loop : data.outerFirst()) {\n                     if (loop.canDuplicateLoop() && loop.loopBegin().getLoopEndCount() > 0) {\n-                        boolean shouldPeel = false;\n-                        try (DebugCloseable dc = TimerHeuristic.start(graph.getDebug())) {\n-                            shouldPeel = LoopPolicies.Options.PeelALot.getValue(graph.getOptions()) || getPolicies().shouldPeel(loop, data.getCFG(), context);\n-                        }\n-                        if (shouldPeel) {\n+                        if (LoopPolicies.Options.PeelALot.getValue(graph.getOptions()) || getPolicies().shouldPeel(loop, data.getCFG(), context)) {\n                             debug.log(\"Peeling %s\", loop);\n                             PEELED.increment(debug);\n                             LoopTransformations.peel(loop);\n@@ -74,6 +66,6 @@ protected void run(StructuredGraph graph, CoreProviders context) {\n \n     @Override\n     public float codeSizeIncrease() {\n-        return 5.0f;\n+        return 10.0f;\n     }\n }",
      "parent_sha": "4e3d2190b5b70e6c09472f07cf08755f135d6919"
    }
  }
]