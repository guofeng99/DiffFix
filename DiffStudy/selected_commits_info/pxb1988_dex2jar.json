[
  {
    "oid": "f00474ffd9bf38aa7442779aed965c3b9f4e1775",
    "message": "Fix a bug in ZeroTransformer\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2012-10-18T14:39:31Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/f00474ffd9bf38aa7442779aed965c3b9f4e1775",
    "details": {
      "sha": "b25de03285b79630dcac775fa35a7b5301a1cfef",
      "filename": "dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/ZeroTransformer.java",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/f00474ffd9bf38aa7442779aed965c3b9f4e1775/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FZeroTransformer.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/f00474ffd9bf38aa7442779aed965c3b9f4e1775/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FZeroTransformer.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FZeroTransformer.java?ref=f00474ffd9bf38aa7442779aed965c3b9f4e1775",
      "patch": "@@ -45,7 +45,7 @@\n  */\r\n public class ZeroTransformer implements Transformer {\r\n \r\n-    static class Phi {\r\n+    public static class Phi {\r\n         public Boolean isZero = null;\r\n         // public Set<Phi> parents = new HashSet<Phi>();\r\n         public Set<Phi> children = new HashSet<Phi>();\r\n@@ -249,7 +249,7 @@ public void transform(IrMethod irMethod) {\n                 break;\r\n             case E2:\r\n                 E2Stmt e2 = (E2Stmt) p;\r\n-                if (e2.st != ST.ASSIGN && e2.st != ST.IDENTITY) {\r\n+                if (e2.op1.value.vt != VT.LOCAL) {\r\n                     replace(e2.op1, frame);\r\n                 }\r\n                 replace(e2.op2, frame);\r\n@@ -262,7 +262,6 @@ public void transform(IrMethod irMethod) {\n                 break;\r\n             }\r\n         }\r\n-\r\n     }\r\n \r\n     private void replace(ValueBox op, Phi[] frame) {\r",
      "parent_sha": "02edfff1d5adb158639784de1587564cbb3d5ce9"
    }
  },
  {
    "oid": "b5771406a9c3073ba25fdfe4e43146ca36f655dc",
    "message": "translate DEX_037 to V1_8\n\nfix https://github.com/pxb1988/dex2jar/issues/194",
    "date": "2018-07-04T12:13:22Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/b5771406a9c3073ba25fdfe4e43146ca36f655dc",
    "details": {
      "sha": "c9062a208463657b1ebd404f64a702114e117a50",
      "filename": "dex-translator/src/main/java/com/googlecode/d2j/dex/Dex2Asm.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/b5771406a9c3073ba25fdfe4e43146ca36f655dc/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FDex2Asm.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/b5771406a9c3073ba25fdfe4e43146ca36f655dc/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FDex2Asm.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FDex2Asm.java?ref=b5771406a9c3073ba25fdfe4e43146ca36f655dc",
      "patch": "@@ -400,7 +400,7 @@ public void convertClass(int dexVersion, DexClassNode classNode, ClassVisitorFac\n         }\n         access = clearClassAccess(isInnerClass, access);\n \n-        int version = dexVersion >= DexConstants.DEX_037 ? Opcodes.V1_7 : Opcodes.V1_6;\n+        int version = dexVersion >= DexConstants.DEX_037 ? Opcodes.V1_8 : Opcodes.V1_6;\n         cv.visit(version, access, toInternalName(classNode.className), signature,\n                 classNode.superClass == null ? null : toInternalName(classNode.superClass), interfaceInterNames);\n ",
      "parent_sha": "f5855ebfcbb2124d1a9ff6563125620077ff009a"
    }
  },
  {
    "oid": "62cb70e220c32627812e41f90aef437f1b493a4e",
    "message": "fix set argument type of java.nio.Path in BaseCmd\n\n--HG--\nbranch : 2.x",
    "date": "2014-07-31T13:58:16Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/62cb70e220c32627812e41f90aef437f1b493a4e",
    "details": {
      "sha": "32a55106d8c724a83aa60b717c11f4e3aa80e7b9",
      "filename": "d2j-base-cmd/src/main/java/com/googlecode/dex2jar/tools/BaseCmd.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/62cb70e220c32627812e41f90aef437f1b493a4e/d2j-base-cmd%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FBaseCmd.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/62cb70e220c32627812e41f90aef437f1b493a4e/d2j-base-cmd%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FBaseCmd.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/d2j-base-cmd%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FBaseCmd.java?ref=62cb70e220c32627812e41f90aef437f1b493a4e",
      "patch": "@@ -226,7 +226,7 @@ protected Object convert(String value, Class type) {\n             return new File(value);\n         }\n         if (type.equals(Path.class)) {\n-            return new File(value).getPath();\n+            return new File(value).toPath();\n         }\n         try {\n             type.asSubclass(Enum.class);",
      "parent_sha": "c45ae97fbdfb9b4b89de28f960f9ce3e2ffeb6ce"
    }
  },
  {
    "oid": "c45ae97fbdfb9b4b89de28f960f9ce3e2ffeb6ce",
    "message": "fix offset check in code read\n\n--HG--\nbranch : 2.x",
    "date": "2014-07-31T13:50:43Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/c45ae97fbdfb9b4b89de28f960f9ce3e2ffeb6ce",
    "details": {
      "sha": "ffae8208984899717d18aca26be5a3ce47a47ad0",
      "filename": "dex-reader/src/main/java/com/googlecode/d2j/reader/DexFileReader.java",
      "status": "modified",
      "additions": 6,
      "deletions": 3,
      "changes": 9,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/c45ae97fbdfb9b4b89de28f960f9ce3e2ffeb6ce/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Freader%2FDexFileReader.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/c45ae97fbdfb9b4b89de28f960f9ce3e2ffeb6ce/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Freader%2FDexFileReader.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Freader%2FDexFileReader.java?ref=c45ae97fbdfb9b4b89de28f960f9ce3e2ffeb6ce",
      "patch": "@@ -1015,10 +1015,10 @@ private void findLabels(byte[] insns, BitSet nextBit, Map<Integer, DexLabel> lab\n             } else {\r\n                 nextBit.set(offset);\r\n             }\r\n-            if (offset >= insns.length) {\r\n+            int u1offset = offset * 2;\r\n+            if (u1offset >= insns.length) {\r\n                 continue;\r\n             }\r\n-            int u1offset = offset * 2;\r\n             int opcode = 0xFF & insns[u1offset];\r\n             Op op = null;\r\n             if (opcode < values.length) {\r\n@@ -1141,7 +1141,7 @@ private void findLabels(byte[] insns, BitSet nextBit, Map<Integer, DexLabel> lab\n                 default:\r\n                 }\r\n                 if (!canContinue) {\r\n-                    WARN(\"GLITCH: index-out-of-range at %s for %s @%04x\", method.toString(), op, u1offset);\r\n+                    WARN(\"GLITCH: index-out-of-range at %s for %s @%04x\", method.toString(), op, offset);\r\n                 }\r\n             }\r\n \r\n@@ -1276,6 +1276,9 @@ private void acceptInsn(byte[] insns, DexCodeVisitor dcv, BitSet nextInsn, Map<I\n                 }\r\n             }\r\n             int u1offset = offset * 2;\r\n+            if (u1offset >= insns.length) {\r\n+                continue;\r\n+            }\r\n             int opcode = 0xFF & insns[u1offset];\r\n \r\n             Op op = null;\r",
      "parent_sha": "9512768270c84dc352f095951534043ffb62af19"
    }
  },
  {
    "oid": "59f17b8181c15c847c286d64f3ca32f1f95b58c0",
    "message": "fix apksign verify error on android\n\n--HG--\nbranch : 2.x",
    "date": "2014-12-23T14:01:46Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/59f17b8181c15c847c286d64f3ca32f1f95b58c0",
    "details": {
      "sha": "ce4741253251040c357c9656f1158de6b18df4be",
      "filename": "dex-tools/src/main/java/com/googlecode/d2j/signapk/AbstractJarSign.java",
      "status": "modified",
      "additions": 3,
      "deletions": 8,
      "changes": 11,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/59f17b8181c15c847c286d64f3ca32f1f95b58c0/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fsignapk%2FAbstractJarSign.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/59f17b8181c15c847c286d64f3ca32f1f95b58c0/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fsignapk%2FAbstractJarSign.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fsignapk%2FAbstractJarSign.java?ref=59f17b8181c15c847c286d64f3ca32f1f95b58c0",
      "patch": "@@ -307,14 +307,9 @@ public void write(int b) throws IOException {\n         main.putValue(digestAlg + \"-Digest-Manifest\", encodeBase64(md.digest()));\r\n \r\n         // digest main attribute\r\n-        for (Map.Entry<Object, Object> att : manifest.getMainAttributes().entrySet()) {\r\n-            print.write(att.getKey().toString().getBytes(StandardCharsets.UTF_8));\r\n-            print.write(COL);\r\n-            print.write(att.getKey().toString().getBytes(StandardCharsets.UTF_8));\r\n-            print.write(EOL);\r\n-        }\r\n-        print.write(EOL);\r\n-        print.flush();\r\n+        Manifest m2 = new Manifest();\r\n+        m2.getMainAttributes().putAll(manifest.getMainAttributes());\r\n+        m2.write(print);\r\n         main.putValue(digestAlg + \"-Digest-Manifest-Main-Attributes\", encodeBase64(md.digest()));\r\n \r\n         String digName = digestAlg + \"-Digest\";\r",
      "parent_sha": "4aec75ddb45b82a623ea29521ec2f8c6edadc461"
    }
  },
  {
    "oid": "41b32da696ee3c5ea930ce9ac2600b1ff8ad0a52",
    "message": "fix ArrayIndexOutOfBoundsException when zero-ops in FilledArrayExpr\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2012-08-15T06:55:33Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/41b32da696ee3c5ea930ce9ac2600b1ff8ad0a52",
    "details": {
      "sha": "eefa35c8ab95e25a363ced15bb7b8ef07af93797",
      "filename": "dex-ir/src/main/java/com/googlecode/dex2jar/ir/expr/FilledArrayExpr.java",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/41b32da696ee3c5ea930ce9ac2600b1ff8ad0a52/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fexpr%2FFilledArrayExpr.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/41b32da696ee3c5ea930ce9ac2600b1ff8ad0a52/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fexpr%2FFilledArrayExpr.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fexpr%2FFilledArrayExpr.java?ref=41b32da696ee3c5ea930ce9ac2600b1ff8ad0a52",
      "patch": "@@ -48,11 +48,13 @@ public Value clone() {\n     @Override\r\n     public String toString() {\r\n         StringBuilder sb = new StringBuilder().append('{');\r\n-        for (int i = 0; i < ops.length - 1; i++) {\r\n+        for (int i = 0; i < ops.length; i++) {\r\n             sb.append(ops[i]).append(\", \");\r\n         }\r\n-        sb.append(ops[ops.length - 1]).append('}');\r\n+        if (ops.length > 0) {\r\n+            sb.setLength(sb.length() - 2); // remove tail \", \"\r\n+        }\r\n+        sb.append('}');\r\n         return sb.toString();\r\n     }\r\n-\r\n }\r",
      "parent_sha": "26c9e0b6cc084c4e76da65f4837396b611410cce"
    }
  },
  {
    "oid": "ca7e8f224cfe2896c6067b80c9e04b67ac63eeba",
    "message": "sort all InnerClass\n\n--HG--\nbranch : 2.x",
    "date": "2014-08-07T12:49:14Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/ca7e8f224cfe2896c6067b80c9e04b67ac63eeba",
    "details": {
      "sha": "cd55a3c64ad3adc555e0ee92a855ca2a65769be9",
      "filename": "dex-translator/src/main/java/com/googlecode/d2j/dex/Dex2Asm.java",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/ca7e8f224cfe2896c6067b80c9e04b67ac63eeba/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FDex2Asm.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/ca7e8f224cfe2896c6067b80c9e04b67ac63eeba/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FDex2Asm.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FDex2Asm.java?ref=ca7e8f224cfe2896c6067b80c9e04b67ac63eeba",
      "patch": "@@ -371,8 +371,9 @@ public void convertClass(DexClassNode classNode, ClassVisitorFactory cvf, Map<St\n         cv.visit(Opcodes.V1_6, access, toInternalName(classNode.className), signature,\n                 classNode.superClass == null ? null : toInternalName(classNode.superClass), interfaceInterNames);\n \n+        List<InnerClassNode> innerClassNodes = new ArrayList<InnerClassNode>(5);\n         if (clzInfo != null) {\n-            searchInnerClass(clzInfo, cv, classNode.className);\n+            searchInnerClass(clzInfo, innerClassNodes, classNode.className);\n         }\n         if (isInnerClass) {\n             // build Outer Clz\n@@ -386,7 +387,11 @@ public void convertClass(DexClassNode classNode, ClassVisitorFactory cvf, Map<St\n                     cv.visitOuterClass(toInternalName(enclosingClass.name), null, null);\n                 }\n             }\n-            searchEnclosing(clzInfo, cv);\n+            searchEnclosing(clzInfo, innerClassNodes);\n+        }\n+        Collections.sort(innerClassNodes, INNER_CLASS_NODE_COMPARATOR);\n+        for (InnerClassNode icn : innerClassNodes) {\n+            icn.accept(cv);\n         }\n \n         accept(classNode.anns, cv);\n@@ -590,18 +595,18 @@ public void optimize(IrMethod irMethod) {\n      * to WeAreHere.class\n      * \n      */\n-    private static void searchEnclosing(Clz clz, ClassVisitor cv) {\n+    private static void searchEnclosing(Clz clz, List<InnerClassNode> innerClassNodes) {\n         for (Clz p = clz; p != null; p = p.enclosingClass) {\n             Clz enclosingClass = p.enclosingClass;\n             if (enclosingClass == null) {\n                 break;\n             }\n             int accessInInner = clearInnerAccess(p.access);\n             if (p.innerName != null) {// non-anonymous Innerclass\n-                cv.visitInnerClass(Type.getType(p.name).getInternalName(), Type.getType(enclosingClass.name)\n-                        .getInternalName(), p.innerName, accessInInner);\n+                innerClassNodes.add(new InnerClassNode(toInternalName(p.name),\n+                        toInternalName(enclosingClass.name), p.innerName, accessInInner));\n             } else {// anonymous Innerclass\n-                cv.visitInnerClass(Type.getType(p.name).getInternalName(), null, null, accessInInner);\n+                innerClassNodes.add(new InnerClassNode(toInternalName(p.name), null, null, accessInInner));\n             }\n         }\n     }\n@@ -631,10 +636,9 @@ private static void searchEnclosing(Clz clz, ClassVisitor cv) {\n      * \n      * @param clz\n      */\n-    private static void searchInnerClass(Clz clz, ClassVisitor cv, String className) {\n+    private static void searchInnerClass(Clz clz, List<InnerClassNode> innerClassNodes, String className) {\n         Set<Clz> visited = new HashSet<>();\n         Stack<Clz> stack = new Stack<>();\n-        List<InnerClassNode> innerClassNodes = new ArrayList<InnerClassNode>(5);\n         stack.push(clz);\n         while (!stack.empty()) {\n             clz = stack.pop();\n@@ -656,10 +660,6 @@ private static void searchInnerClass(Clz clz, ClassVisitor cv, String className)\n                 }\n             }\n         }\n-        Collections.sort(innerClassNodes, INNER_CLASS_NODE_COMPARATOR);\n-        for (InnerClassNode icn : innerClassNodes) {\n-            icn.accept(cv);\n-        }\n     }\n \n     private static final Comparator<InnerClassNode> INNER_CLASS_NODE_COMPARATOR = new Comparator<InnerClassNode>() {",
      "parent_sha": "0f030e4b2bea088ede46d946e82f9245dd10f601"
    }
  },
  {
    "oid": "d6383b7d1df27d940e4934debad8357b03e76f3f",
    "message": "[type] minor improve of type transformer",
    "date": "2016-03-04T13:05:33Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/d6383b7d1df27d940e4934debad8357b03e76f3f",
    "details": {
      "sha": "b095c9ca1e114d09f0a2c0119cd4c5fcb5b75d2d",
      "filename": "dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/TypeTransformer.java",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/d6383b7d1df27d940e4934debad8357b03e76f3f/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FTypeTransformer.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/d6383b7d1df27d940e4934debad8357b03e76f3f/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FTypeTransformer.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FTypeTransformer.java?ref=d6383b7d1df27d940e4934debad8357b03e76f3f",
      "patch": "@@ -223,6 +223,9 @@ private TypeRef getReal() {\n             while (x.next != null) {\n                 x = x.next;\n             }\n+            if (x != this) {\n+                this.next = x;\n+            }\n             return x;\n         }\n \n@@ -280,8 +283,9 @@ public String getType() {\n         }\n \n         public boolean updateTypeClass(TypeClass clz) {\n-            TypeClass merged = TypeClass.merge(this.getClz(), clz);\n-            if (merged == this.getClz()) {\n+            TypeClass thizClz = this.getClz();\n+            TypeClass merged = TypeClass.merge(thizClz, clz);\n+            if (merged == thizClz) {\n                 return false;\n             }\n             this.setClz(merged);",
      "parent_sha": "8e58b0eb4073ca4a2fb215da0e26d0ff63a59f17"
    }
  },
  {
    "oid": "319b7416dc936ef3a469a71be0555241684bf76a",
    "message": "1.\u5b8c\u5584V3\u8f6c\u6362\n\n--HG--\nbranch : 0.0.7",
    "date": "2010-09-16T14:18:55Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/319b7416dc936ef3a469a71be0555241684bf76a",
    "details": {
      "sha": "c4336f26c39814aa55e90aa1fb34548ff1ee128f",
      "filename": "src/main/java/pxb/android/dex2jar/optimize/B.java",
      "status": "modified",
      "additions": 9,
      "deletions": 5,
      "changes": 14,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/319b7416dc936ef3a469a71be0555241684bf76a/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Foptimize%2FB.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/319b7416dc936ef3a469a71be0555241684bf76a/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Foptimize%2FB.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Foptimize%2FB.java?ref=319b7416dc936ef3a469a71be0555241684bf76a",
      "patch": "@@ -151,15 +151,12 @@ public String toString() {\n \tprivate int order() {\r\n \t\treturn max++;\r\n \t}\r\n-\r\n-\tpublic void transform(MethodNode method) {\r\n-\r\n+\tprivate void cut(){\r\n \t\t// long timeStart = System.currentTimeMillis();\r\n \r\n \t\t// log.debug(\"enter {}\", m);\r\n \t\tint blockIndex = 0;\r\n-\t\tinsnList = method.instructions;\r\n-\t\tthis.method = method;\r\n+\t\t\r\n \t\t// dump();\r\n \r\n \t\tMap<Integer, AbstractInsnNode> in = new HashMap();\r\n@@ -213,6 +210,13 @@ public void transform(MethodNode method) {\n \t\t\t}\r\n \t\t\tp = p.getNext();\r\n \t\t}\r\n+\t}\r\n+\r\n+\tpublic void transform(MethodNode method) {\r\n+\t\tinsnList = method.instructions;\r\n+\t\tthis.method = method;\r\n+\r\n+\t\tcut();\r\n \r\n \t\tlinkTryCatch();\r\n \r",
      "parent_sha": "e5c2684225f66cb0696a63ed52c66fb09678dd22"
    }
  },
  {
    "oid": "fa30b84cd3191144cfdedf8f90d3d5c1bcb6aecd",
    "message": "fix https://github.com/pxb1988/dex2jar/issues/501",
    "date": "2021-10-30T07:56:20Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/fa30b84cd3191144cfdedf8f90d3d5c1bcb6aecd",
    "details": {
      "sha": "3fb02b031729e4993f2167bf3546e50fabed69ef",
      "filename": "dex-translator/src/main/java/com/googlecode/d2j/converter/Dex2IRConverter.java",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/fa30b84cd3191144cfdedf8f90d3d5c1bcb6aecd/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fconverter%2FDex2IRConverter.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/fa30b84cd3191144cfdedf8f90d3d5c1bcb6aecd/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fconverter%2FDex2IRConverter.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fconverter%2FDex2IRConverter.java?ref=fa30b84cd3191144cfdedf8f90d3d5c1bcb6aecd",
      "patch": "@@ -17,6 +17,7 @@\n import com.googlecode.dex2jar.ir.expr.Local;\n import com.googlecode.dex2jar.ir.expr.Value;\n import com.googlecode.dex2jar.ir.stmt.*;\n+import com.googlecode.dex2jar.ir.ts.UniqueQueue;\n \n import java.util.*;\n \n@@ -115,7 +116,9 @@ public IrMethod convert(boolean isStatic, Method method, DexCodeNode dexCodeNode\n         emitStmts = null;\n \n \n-        Queue<DvmValue> queue = new LinkedList<>();\n+        // https://github.com/pxb1988/dex2jar/issues/501\n+        // too many Object put to Q, make the object unique in Q\n+        Queue<DvmValue> queue = new UniqueQueue<>();\n \n         for (int i1 = 0; i1 < frames.length; i1++) {\n             Dex2IrFrame frame = frames[i1];",
      "parent_sha": "7da8850a0f9b9669a3e7747e6317f55219de4b73"
    }
  },
  {
    "oid": "cf7760a49f200d184bb115fac48a2f8be4d873ca",
    "message": "1.\u5b8c\u5584v3\u5757\u5207\u5206\n\n--HG--\nbranch : 0.0.7",
    "date": "2010-08-20T19:06:00Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/cf7760a49f200d184bb115fac48a2f8be4d873ca",
    "details": {
      "sha": "674fb1ff735d3c3cdd741332db3576b54df2af5d",
      "filename": "src/main/java/pxb/android/dex2jar/optimize/B.java",
      "status": "modified",
      "additions": 49,
      "deletions": 15,
      "changes": 64,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/cf7760a49f200d184bb115fac48a2f8be4d873ca/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Foptimize%2FB.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/cf7760a49f200d184bb115fac48a2f8be4d873ca/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Foptimize%2FB.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Foptimize%2FB.java?ref=cf7760a49f200d184bb115fac48a2f8be4d873ca",
      "patch": "@@ -149,16 +149,10 @@ public String toString() {\n \tList<Block> blocks = new ArrayList();\r\n \tMap<Label, Block> blockMaps = new HashMap();\r\n \r\n-\tint max = -1;\r\n+\tint max = 0;\r\n \r\n \tprivate int order() {\r\n-\t\treturn ++max;\r\n-\t}\r\n-\r\n-\tprivate void max(int max) {\r\n-\t\tif (max > this.max) {\r\n-\t\t\tthis.max = max;\r\n-\t\t}\r\n+\t\treturn max++;\r\n \t}\r\n \r\n \tpublic void transform(MethodNode method) {\r\n@@ -191,15 +185,13 @@ public void transform(MethodNode method) {\n \t\twhile (p != null) {\r\n \t\t\tif (isRead(p)) {\r\n \t\t\t\tint r = var(p);\r\n-\t\t\t\tmax(r);\r\n \t\t\t\tif (in.get(r) == null) {\r\n \t\t\t\t\tif (out.get(r) == null) {\r\n \t\t\t\t\t\tin.put(r, p);\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t} else if (isWrite(p)) {\r\n \t\t\t\tint r = var(p);\r\n-\t\t\t\tmax(r);\r\n \t\t\t\tout.put(r, p);\r\n \t\t\t} else if (needBreak(p)) {\r\n \t\t\t\tif (p.getType() != AbstractInsnNode.LABEL) {\r\n@@ -247,6 +239,21 @@ public void transform(MethodNode method) {\n \t\tfor (Block block : blocks) {\r\n \t\t\tdoBlock(block);\r\n \t\t}\r\n+\t\tint i = 0;\r\n+\t\tif ((m.getAccessFlags() & ACC_STATIC) == 0) {\r\n+\t\t\tgrobalMap.put(i++, order()); // this\r\n+\t\t}\r\n+\t\tfor (String t : m.getType().getParameterTypes()) {\r\n+\t\t\tgrobalMap.put(i++, order());\r\n+\t\t}\r\n+\r\n+\t\tif (m.toString().equals(\"Lcom/slgmobile/beamreader/Open;.b(Landroid/net/Uri;)Ljava/lang/String;\")) {\r\n+\t\t\tSystem.out.println(\"\");\r\n+\t\t}\r\n+\t\tfor (Block block : blocks) {\r\n+\t\t\tdoReIndex(block);\r\n+\t\t}\r\n+\t\tSystem.out.println(\"\");\r\n \t}\r\n \r\n \t/**\r\n@@ -648,11 +655,10 @@ public void doBlock(Block block) {\n \r\n \t\tdoVar(block);\r\n \t\t// dump(block);\r\n-\t\tdoReIndex(block);\r\n-\t\t// System.out.println(\"AFTER\");\r\n-\t\t// dump(block);\r\n \t}\r\n \r\n+\tMap<Integer, Integer> grobalMap = new HashMap();\r\n+\r\n \t/**\r\n \t * @param block\r\n \t * @deprecated\r\n@@ -749,14 +755,22 @@ protected void doReIndex(Block block) {\n \t\tfor (AbstractInsnNode p = block.first; p != block.last; p = p.getNext()) {\r\n \t\t\tif (isWrite(p)) {\r\n \t\t\t\tint r = var(p);\r\n-\t\t\t\tif (block.out.get(r) == null) {// \u4e0d\u8f93\u51fa\r\n+\t\t\t\tif (block.out.get(r) != p) {// \u4e0d\u8f93\u51fa\r\n \t\t\t\t\tint nr = order();\r\n \t\t\t\t\tvar(p, nr);\r\n \t\t\t\t\tmap.put(r, nr);\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\tInteger v = this.grobalMap.get(r);\r\n+\t\t\t\t\tif (v == null) {\r\n+\t\t\t\t\t\tv = order();\r\n+\t\t\t\t\t\tgrobalMap.put(r, v);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\tvar(p, v);\r\n+\t\t\t\t\tmap.put(r, v);\r\n \t\t\t\t}\r\n \t\t\t} else if (isRead(p)) {\r\n \t\t\t\tint r = var(p);\r\n-\t\t\t\tif (block.in.get(r) == null && block.out.get(r) == null) {// \u4e0d\u8f93\u5165\uff0c\u4e0d\u8f93\u51fa\r\n+\t\t\t\tif (block.in.get(r) != p) {\r\n \t\t\t\t\tInteger v = map.get(r);\r\n \t\t\t\t\tif (v == null) {\r\n \t\t\t\t\t\tint nr = order();\r\n@@ -765,8 +779,28 @@ protected void doReIndex(Block block) {\n \t\t\t\t\t} else {\r\n \t\t\t\t\t\tvar(p, v);\r\n \t\t\t\t\t}\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\tInteger v = this.grobalMap.get(r);\r\n+\t\t\t\t\tif (v == null) {\r\n+\t\t\t\t\t\tv = order();\r\n+\t\t\t\t\t\tgrobalMap.put(r, v);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\tvar(p, v);\r\n+\t\t\t\t\tmap.put(r, v);\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n+\r\n+\t\tMap<Integer, AbstractInsnNode> old = block.in;\r\n+\t\tblock.in = new HashMap();\r\n+\t\tfor (Map.Entry<Integer, AbstractInsnNode> e : old.entrySet()) {\r\n+\t\t\tblock.in.put(this.grobalMap.get(e.getKey()), e.getValue());\r\n+\t\t}\r\n+\t\told = block.out;\r\n+\t\tblock.out = new HashMap();\r\n+\t\tfor (Map.Entry<Integer, AbstractInsnNode> e : old.entrySet()) {\r\n+\t\t\tblock.out.put(this.grobalMap.get(e.getKey()), e.getValue());\r\n+\t\t}\r\n+\r\n \t}\r\n }\r",
      "parent_sha": "da7b59036c17fcc514df135a5be66c2dbef42a01"
    }
  },
  {
    "oid": "a4800715220899c02fe42aa54abdff71ab32ae37",
    "message": "i\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2011-12-14T12:07:39Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/a4800715220899c02fe42aa54abdff71ab32ae37",
    "details": {
      "sha": "2747f834e59df7bf985148dc41ea98f2af557771",
      "filename": "dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/LiveAnalyze.java",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/a4800715220899c02fe42aa54abdff71ab32ae37/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FLiveAnalyze.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/a4800715220899c02fe42aa54abdff71ab32ae37/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FLiveAnalyze.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FLiveAnalyze.java?ref=a4800715220899c02fe42aa54abdff71ab32ae37",
      "patch": "@@ -42,9 +42,8 @@ public class LiveAnalyze {\n     @SuppressWarnings(\"serial\")\r\n     public static class Phi extends HashSet<Phi> {\r\n         public Local local;\r\n-\r\n-        private Phi tag;\r\n-        private boolean used;\r\n+        public Phi tag;\r\n+        public boolean used;\r\n \r\n         private Phi() {\r\n             super(3);\r",
      "parent_sha": "2618359e5c97be636750423fe43788739c796638"
    }
  },
  {
    "oid": "f548b03cdc4d01c74a0a5eeeb6363e728abe9c38",
    "message": "disable test case",
    "date": "2016-01-18T11:03:02Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/f548b03cdc4d01c74a0a5eeeb6363e728abe9c38",
    "details": {
      "sha": "047612b9163888074fa3b7ee05b4c94dd2771c3c",
      "filename": "dex-ir/src/test/java/com/googlecode/dex2jar/ir/test/TypeTransformerTest.java",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/f548b03cdc4d01c74a0a5eeeb6363e728abe9c38/dex-ir%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Ftest%2FTypeTransformerTest.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/f548b03cdc4d01c74a0a5eeeb6363e728abe9c38/dex-ir%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Ftest%2FTypeTransformerTest.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-ir%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Ftest%2FTypeTransformerTest.java?ref=f548b03cdc4d01c74a0a5eeeb6363e728abe9c38",
      "patch": "@@ -66,7 +66,8 @@ public void test2byte() {\n         addStmt(nAssign(nStaticField(\"La;\", \"z\", \"B\"), b));\n         addStmt(nReturnVoid());\n         transform();\n-        Assert.assertEquals(\"\", b.valueType, \"B\");\n+        // FIXME fix type detect\n+        // Assert.assertEquals(\"\", \"I\", b.valueType);\n     }\n \n     @Test\n@@ -79,7 +80,8 @@ public void test2char() {\n         addStmt(nAssign(nStaticField(\"La;\", \"z\", \"C\"), b));\n         addStmt(nReturnVoid());\n         transform();\n-        Assert.assertEquals(\"\", \"C\", b.valueType);\n+        // FIXME fix type detect\n+        // Assert.assertEquals(\"\", \"I\", b.valueType);\n     }\n \n     // @Ignore(\"type b to Int is ok to this context\")\n@@ -162,7 +164,7 @@ public void testGithubIssue28x() {\n         addStmt(nAssign(nArray(nArray(b, nInt(5), TypeClass.OBJECT.name), nInt(1), TypeClass.JD.name), nLong(0)));\n         addStmt(nReturnVoid());\n         transform();\n-        Assert.assertEquals(\"\", b.valueType, \"[[D\");\n+        // this case is ok to fail as the NPE transformer cover this\n+        // Assert.assertEquals(\"\", \"[[D\", b.valueType);\n     }\n-\n }",
      "parent_sha": "305f294de765d7f337c72a96d39cdca939b7eee5"
    }
  },
  {
    "oid": "e5c2684225f66cb0696a63ed52c66fb09678dd22",
    "message": "\u4fee\u590d\u4e00\u4e2aPOP\u6307\u4ee4\u4f7f\u7528\u9519\u8bef\n\nFixes issue 26\n\n--HG--\nbranch : 0.0.7",
    "date": "2010-09-12T09:38:39Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/e5c2684225f66cb0696a63ed52c66fb09678dd22",
    "details": {
      "sha": "f7dca846969b80a58f2e84e231c99008c49bb979",
      "filename": "src/main/java/pxb/android/dex2jar/v3/V3CodeAdapter.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/e5c2684225f66cb0696a63ed52c66fb09678dd22/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Fv3%2FV3CodeAdapter.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/e5c2684225f66cb0696a63ed52c66fb09678dd22/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Fv3%2FV3CodeAdapter.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Fv3%2FV3CodeAdapter.java?ref=e5c2684225f66cb0696a63ed52c66fb09678dd22",
      "patch": "@@ -1069,7 +1069,7 @@ public void visitTableSwitchInsn(int opcode, int reg, int first_case, int last_c\n \r\n \tprivate void checkResult() {\r\n \t\tif (typeInStack != null) {\r\n-\t\t\tif (Type.LONG_TYPE.equals(typeInStack)) {\r\n+\t\t\tif (Type.LONG_TYPE.equals(typeInStack) || Type.DOUBLE_TYPE.equals(typeInStack)) {\r\n \t\t\t\tmv.visitInsn(POP2);\r\n \t\t\t} else {\r\n \t\t\t\tmv.visitInsn(POP);\r",
      "parent_sha": "e59a18a298936b68b698e935bb884d773053d356"
    }
  },
  {
    "oid": "fd927793a7ea173524548d0167bc9f6883869d87",
    "message": "correct array type display is ir\n\n--HG--\nbranch : 2.x",
    "date": "2014-12-06T18:16:13Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/fd927793a7ea173524548d0167bc9f6883869d87",
    "details": {
      "sha": "35a8358d5fda4402b14a70a90943e3ce6a3bd899",
      "filename": "dex-ir/src/main/java/com/googlecode/dex2jar/ir/Util.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/fd927793a7ea173524548d0167bc9f6883869d87/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2FUtil.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/fd927793a7ea173524548d0167bc9f6883869d87/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2FUtil.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2FUtil.java?ref=fd927793a7ea173524548d0167bc9f6883869d87",
      "patch": "@@ -142,8 +142,7 @@ public static String toShortClassName(String desc) {\n                     break;\r\n                 }\r\n             }\r\n-            int i = desc.lastIndexOf('/');\r\n-            StringBuilder sb = new StringBuilder().append(desc.substring(i < 0 ? d : i + 1, desc.length() - 1));\r\n+            StringBuilder sb = new StringBuilder().append(toShortClassName(desc.substring(d)));\r\n             for (int t = 0; t < d; t++) {\r\n                 sb.append(\"[]\");\r\n             }\r",
      "parent_sha": "3a3a1e90e79790d4cbcaa911856de7308b833ae1"
    }
  },
  {
    "oid": "f3333b3e7bacb0d5b76d487a73dfe52eeb01536b",
    "message": "Fix issue #27, NPE on accept DexAnnotationVisitor\n\nhttps://github.com/pxb1988/dex2jar/issues/27\n\n--HG--\nbranch : 2.x",
    "date": "2015-09-02T04:44:01Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/f3333b3e7bacb0d5b76d487a73dfe52eeb01536b",
    "details": {
      "sha": "a44445686dadd800f78e13021cf93d8893074c99",
      "filename": "dex-reader-api/src/main/java/com/googlecode/d2j/node/DexAnnotationNode.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/f3333b3e7bacb0d5b76d487a73dfe52eeb01536b/dex-reader-api%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fnode%2FDexAnnotationNode.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/f3333b3e7bacb0d5b76d487a73dfe52eeb01536b/dex-reader-api%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fnode%2FDexAnnotationNode.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-reader-api%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fnode%2FDexAnnotationNode.java?ref=f3333b3e7bacb0d5b76d487a73dfe52eeb01536b",
      "patch": "@@ -122,7 +122,7 @@ public DexAnnotationNode(String type, Visibility visibility) {\n \r\n     public void accept(DexAnnotationAble av) {\r\n         DexAnnotationVisitor av1 = av.visitAnnotation(type, visibility);\r\n-        if (av != null) {\r\n+        if (av1 != null) {\r\n             for (Item item : items) {\r\n                 acceptAnnotationItem(av1, item.name, item.value);\r\n             }\r",
      "parent_sha": "1020541e3ccc86a59aa3a85aacd64f8ddf15f7a5"
    }
  },
  {
    "oid": "2a58b8efd73ba8d3b05194b1951c25812b67f51e",
    "message": "comments test case for issue 122,123\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2012-07-18T07:15:59Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/2a58b8efd73ba8d3b05194b1951c25812b67f51e",
    "details": {
      "sha": "d4af96c078a7e58012fd3024860b805b2a89f047",
      "filename": "dex-translator/src/test/java/com/googlecode/dex2jar/test/ArrayTypeTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/2a58b8efd73ba8d3b05194b1951c25812b67f51e/dex-translator%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftest%2FArrayTypeTest.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/2a58b8efd73ba8d3b05194b1951c25812b67f51e/dex-translator%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftest%2FArrayTypeTest.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftest%2FArrayTypeTest.java?ref=2a58b8efd73ba8d3b05194b1951c25812b67f51e",
      "patch": "@@ -70,15 +70,17 @@ public void test120() throws IllegalArgumentException, IllegalAccessException, A\n         TestUtils.verify(cr);\n     }\n \n-    @Test\n+    // FIXME issue 122 \n+    // @Test\n     public void test122() throws IllegalArgumentException, IllegalAccessException, AnalyzerException {\n         TestDexClassV cv = new TestDexClassV(\"Lt\", V3.OPTIMIZE_SYNCHRONIZED | V3.TOPOLOGICAL_SORT);\n         a123(cv);\n         ClassReader cr = new ClassReader(cv.toByteArray());\n         TestUtils.verify(cr);\n     }\n \n-    @Test\n+    // FIXME issue 123\n+    // @Test\n     public void test123() throws IllegalArgumentException, IllegalAccessException, AnalyzerException {\n         TestDexClassV cv = new TestDexClassV(\"Lt\", V3.OPTIMIZE_SYNCHRONIZED | V3.TOPOLOGICAL_SORT);\n         a122(cv);",
      "parent_sha": "bbe00834ae768f5b35ed3f565d37ce5077d2da74"
    }
  },
  {
    "oid": "3178ae5a690c47ff17ee6d584a41d79fa60c0d69",
    "message": "merge patch from yyjdelete\n\nFix that IINC does not work as expected\n\n--HG--\nbranch : 2.x",
    "date": "2015-01-05T15:05:23Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/3178ae5a690c47ff17ee6d584a41d79fa60c0d69",
    "details": {
      "sha": "21b791e41a268ff634c54d9a546356c5ad3c924a",
      "filename": "dex-translator/src/main/java/com/googlecode/d2j/converter/IR2JConverter.java",
      "status": "modified",
      "additions": 17,
      "deletions": 12,
      "changes": 29,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/3178ae5a690c47ff17ee6d584a41d79fa60c0d69/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fconverter%2FIR2JConverter.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/3178ae5a690c47ff17ee6d584a41d79fa60c0d69/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fconverter%2FIR2JConverter.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fconverter%2FIR2JConverter.java?ref=3178ae5a690c47ff17ee6d584a41d79fa60c0d69",
      "patch": "@@ -140,26 +140,27 @@ private void reBuildInstructions(IrMethod ir, MethodVisitor asm) {\n                     Local local = ((Local) v1);\r\n                     int i = local._ls_index;\r\n \r\n-                    if (v2.vt == VT.LOCAL && (i == ((Local) v2)._ls_index)) {//\r\n-                        continue;\r\n-                    }\r\n-\r\n                     boolean skipOrg = false;\r\n-                    if (v1.valueType.charAt(0) == 'I') {// check for IINC\r\n+                    if (v2.vt == VT.LOCAL && (i == ((Local) v2)._ls_index)) {// check for a=a\r\n+                        skipOrg = true;\r\n+                    } else if (v1.valueType.charAt(0) == 'I') {// check for IINC\r\n                         if (v2.vt == VT.ADD) {\r\n-                            E2Expr e = (E2Expr) v2;\r\n-                            if ((e.op1 == local && e.op2.vt == VT.CONSTANT)\r\n-                                    || (e.op2 == local && e.op1.vt == VT.CONSTANT)) {\r\n-                                int increment = (Integer) ((Constant) (e.op1 == local ? e.op2 : e.op1)).value;\r\n+                            if (isLocalWithIndex(v2.getOp1(), i) && v2.getOp2().vt == VT.CONSTANT) { // a=a+1;\r\n+                                int increment = (Integer) ((Constant) v2.getOp2()).value;\r\n+                                if (increment >= Short.MIN_VALUE && increment <= Short.MAX_VALUE) {\r\n+                                    asm.visitIincInsn(i, increment);\r\n+                                    skipOrg = true;\r\n+                                }\r\n+                            } else if (isLocalWithIndex(v2.getOp2(), i) && v2.getOp1().vt == VT.CONSTANT) { // a=1+a;\r\n+                                int increment = (Integer) ((Constant) v2.getOp1()).value;\r\n                                 if (increment >= Short.MIN_VALUE && increment <= Short.MAX_VALUE) {\r\n                                     asm.visitIincInsn(i, increment);\r\n                                     skipOrg = true;\r\n                                 }\r\n                             }\r\n                         } else if (v2.vt == VT.SUB) {\r\n-                            E2Expr e = (E2Expr) v2;\r\n-                            if (e.op1 == local && e.op2.vt == VT.CONSTANT) {\r\n-                                int increment = -(Integer) ((Constant) e.op2).value;\r\n+                            if (isLocalWithIndex(v2.getOp1(), i) && v2.getOp2().vt == VT.CONSTANT) { // a=a-1;\r\n+                                int increment = -(Integer) ((Constant) v2.getOp2()).value;\r\n                                 if (increment >= Short.MIN_VALUE && increment <= Short.MAX_VALUE) {\r\n                                     asm.visitIincInsn(i, increment);\r\n                                     skipOrg = true;\r\n@@ -381,6 +382,10 @@ private void reBuildInstructions(IrMethod ir, MethodVisitor asm) {\n         }\r\n     }\r\n \r\n+    private static boolean isLocalWithIndex(Value v, int i) {\r\n+        return v.vt == VT.LOCAL && ((Local) v)._ls_index == i;\r\n+    }\r\n+\r\n     private int[] buildLocalUsage(IrMethod ir) {\r\n         int maxLocal = 0;\r\n         for (Local local : ir.locals) {\r",
      "parent_sha": "9be99ac0be1c216892402268f525752b5d75cef5"
    }
  },
  {
    "oid": "9f5c16537ecab67a6054bfcef8791e835c1fab18",
    "message": "fix typos of hex strings decoding",
    "date": "2023-08-31T10:35:56Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/9f5c16537ecab67a6054bfcef8791e835c1fab18",
    "details": {
      "sha": "4995b76f58ce6d28c52b130215d852edc28913bd",
      "filename": "dex-translator/src/main/java/res/Hex.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/9f5c16537ecab67a6054bfcef8791e835c1fab18/dex-translator%2Fsrc%2Fmain%2Fjava%2Fres%2FHex.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/9f5c16537ecab67a6054bfcef8791e835c1fab18/dex-translator%2Fsrc%2Fmain%2Fjava%2Fres%2FHex.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Fmain%2Fjava%2Fres%2FHex.java?ref=9f5c16537ecab67a6054bfcef8791e835c1fab18",
      "patch": "@@ -56,15 +56,15 @@ public static byte[] decode_B(String src) {\n             }\n             int ll;\n             if (l >= '0' && l <= '9') {\n-                ll = h - '0';\n+                ll = l - '0';\n             } else if (l >= 'a' && l <= 'f') {\n-                ll = h - 'a' + 10;\n+                ll = l - 'a' + 10;\n             } else if (l >= 'A' && l <= 'F') {\n-                ll = h - 'A' + 10;\n+                ll = l - 'A' + 10;\n             } else {\n                 throw new RuntimeException();\n             }\n-            d[i] = (char) ((hh << 4) | ll);\n+            ret[i] = (byte) ((hh << 4) | ll);\n         }\n         return ret;\n     }",
      "parent_sha": "e9e05f89365a84930055cf2bc0e64333fa3b9070"
    }
  },
  {
    "oid": "0f6afbf5307a8f0a810b6406988c1f20ddf7a6f5",
    "message": "\u5c1d\u8bd5\u6307\u4ee4\u987a\u5e8f\u8c03\u6574\n\n--HG--\nbranch : 0.0.7",
    "date": "2011-01-22T17:11:59Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/0f6afbf5307a8f0a810b6406988c1f20ddf7a6f5",
    "details": {
      "sha": "1e5e84a17d8eb719d42b5a42eabb3b146b0a2b39",
      "filename": "src/main/java/pxb/android/dex2jar/optimize/D.java",
      "status": "modified",
      "additions": 116,
      "deletions": 69,
      "changes": 185,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/0f6afbf5307a8f0a810b6406988c1f20ddf7a6f5/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Foptimize%2FD.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/0f6afbf5307a8f0a810b6406988c1f20ddf7a6f5/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Foptimize%2FD.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Foptimize%2FD.java?ref=0f6afbf5307a8f0a810b6406988c1f20ddf7a6f5",
      "patch": "@@ -22,8 +22,10 @@\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.Stack;\n import java.util.TreeMap;\n+import java.util.TreeSet;\n \n import org.objectweb.asm.Opcodes;\n import org.objectweb.asm.tree.AbstractInsnNode;\n@@ -43,10 +45,12 @@ public class D implements MethodTransformer, Opcodes {\n \n     private static class Block {\n         final public int id;\n-\n+        public AbstractInsnNode extraInsn;\n         public List<AbstractInsnNode> insns = new ArrayList<AbstractInsnNode>();\n         final public LabelNode label;\n         public LabelNode next;\n+        public List<Block> fromBlocks = new ArrayList<Block>();\n+        public Block nextBlock;\n \n         public Block(int id, LabelNode label) {\n             this.id = id;\n@@ -59,24 +63,22 @@ public String toString() {\n     }\n \n     private static final class BranchBlock extends Block {\n-        public final AbstractInsnNode branchInsn;\n-\n         public BranchBlock(int id, LabelNode label, AbstractInsnNode insn) {\n             super(id, label);\n-            this.branchInsn = insn;\n+            this.extraInsn = insn;\n         }\n+\n+        public List<Block> toBlocks = new ArrayList<Block>();\n     }\n \n     private static class EndBlock extends Block {\n-        public final AbstractInsnNode endInsn;\n-\n         public EndBlock(int id, LabelNode label, AbstractInsnNode endInsn) {\n             super(id, label);\n-            this.endInsn = endInsn;\n+            this.extraInsn = endInsn;\n         }\n \n         public EndBlock clone() {\n-            EndBlock n = new EndBlock(id, new LabelNode(), endInsn.clone(null));\n+            EndBlock n = new EndBlock(id, new LabelNode(), extraInsn.clone(null));\n             List<AbstractInsnNode> insnList = new ArrayList<AbstractInsnNode>();\n             for (AbstractInsnNode p : insns) {\n                 insnList.add(p.clone(null));\n@@ -86,8 +88,25 @@ public EndBlock clone() {\n         }\n     }\n \n+    private static final Comparator<Block> BlockComparator = new Comparator<Block>() {\n+        @Override\n+        public int compare(Block o1, Block o2) {\n+            return o1.id - o2.id;\n+        }\n+    };\n+\n+    private static final Comparator<TcbK> TcbKComparator = new Comparator<TcbK>() {\n+        @Override\n+        public int compare(TcbK o1, TcbK o2) {\n+            int i = o1.start.id - o2.start.id;\n+            int j = o1.end.id - o2.end.id;\n+            return i == 0 ? j : i;\n+        }\n+    };\n+\n     private static class TcbK {\n         final public Block start, end;\n+        final public Map<Block, String> handlers = new TreeMap<Block, String>(BlockComparator);\n \n         public TcbK(Block start, Block end) {\n             this.start = start;\n@@ -119,15 +138,7 @@ private static LabelNode getNextLabelNode(AbstractInsnNode p, InsnList insns) {\n \n     private Map<LabelNode, Block> map = new HashMap<LabelNode, Block>();\n \n-    private Map<TcbK, Map<Block, String>> tcbs = new TreeMap<TcbK, Map<Block, String>>(new Comparator<TcbK>() {\n-\n-        @Override\n-        public int compare(TcbK o1, TcbK o2) {\n-            int i = o1.start.id - o2.start.id;\n-            int j = o1.end.id - o2.end.id;\n-            return i == 0 ? j : i;\n-        }\n-    });\n+    private Map<Block, Set<TcbK>> tcbs = new HashMap<Block, Set<TcbK>>();\n \n     private void addToMap(Block block) {\n         map.put(block.label, block);\n@@ -181,9 +192,7 @@ public LabelNode get(Object key) {\n                 preBlockMap.put(label, block);\n                 break;\n             }\n-            case AbstractInsnNode.JUMP_INSN:\n-            case AbstractInsnNode.LOOKUPSWITCH_INSN:\n-            case AbstractInsnNode.TABLESWITCH_INSN: {\n+            case AbstractInsnNode.JUMP_INSN: {\n                 if (cp.getOpcode() == GOTO) {\n                     block = new Block(i++, label);\n                     block.next = (LabelNode) ((JumpInsnNode) cp).label;\n@@ -197,6 +206,16 @@ public LabelNode get(Object key) {\n                 label = null;\n                 break;\n             }\n+            case AbstractInsnNode.LOOKUPSWITCH_INSN:\n+            case AbstractInsnNode.TABLESWITCH_INSN: {\n+                block = new BranchBlock(i++, label, cp);\n+                block.insns = currentInsnList;\n+                block.next = cp.getType() == AbstractInsnNode.LOOKUPSWITCH_INSN ? ((LookupSwitchInsnNode) cp).dflt : ((TableSwitchInsnNode) cp).dflt;\n+                addToMap(block);\n+                currentInsnList = null;\n+                label = null;\n+                break;\n+            }\n             case AbstractInsnNode.FRAME:\n             case AbstractInsnNode.LINE:\n                 // ignore\n@@ -225,25 +244,56 @@ public LabelNode get(Object key) {\n             }\n         }\n \n+        for (Block b : map.values()) {\n+            if (b.next != null) {\n+                b.nextBlock = map.get(b.next);\n+                b.nextBlock.fromBlocks.add(b);\n+            }\n+            if (b instanceof BranchBlock) {\n+                BranchBlock bb = (BranchBlock) b;\n+                switch (bb.extraInsn.getType()) {\n+                case AbstractInsnNode.LOOKUPSWITCH_INSN:\n+                case AbstractInsnNode.TABLESWITCH_INSN:\n+                    List<LabelNode> labels = bb.extraInsn.getType() == AbstractInsnNode.LOOKUPSWITCH_INSN ? ((LookupSwitchInsnNode) bb.extraInsn).labels\n+                            : ((TableSwitchInsnNode) bb.extraInsn).labels;\n+                    for (LabelNode ln : labels) {\n+                        Block t = map.get(ln);\n+                        bb.toBlocks.add(b);\n+                        t.fromBlocks.add(bb);\n+                    }\n+                    break;\n+                default:\n+                    Block t = map.get(((JumpInsnNode) bb.extraInsn).label);\n+                    bb.toBlocks.add(t);\n+                    t.fromBlocks.add(bb);\n+                }\n+            }\n+\n+        }\n+\n         for (Iterator<?> it = method.tryCatchBlocks.iterator(); it.hasNext();) {\n             TryCatchBlockNode tcn = (TryCatchBlockNode) it.next();\n \n             Block s = map.get((LabelNode) tcn.start.clone(cloneMap));\n             Block e = map.get((LabelNode) tcn.end.clone(cloneMap));\n             Block handler = map.get(tcn.handler.clone(cloneMap));\n-            TcbK key = new TcbK(s, e);\n \n-            Map<Block, String> handlers = tcbs.get(key);\n+            Set<TcbK> handlers = tcbs.get(s);\n             if (handlers == null) {\n-                handlers = new TreeMap<Block, String>(new Comparator<Block>() {\n-                    @Override\n-                    public int compare(Block o1, Block o2) {\n-                        return o1.id - o2.id;\n+                handlers = new TreeSet<TcbK>(TcbKComparator);\n+                tcbs.put(s, handlers);\n+            }\n+            TcbK key = new TcbK(s, e);\n+            if (!handlers.add(key)) {\n+                for (TcbK x : handlers) {\n+                    if (TcbKComparator.compare(key, x) == 0) {\n+                        key = x;\n+                        break;\n                     }\n-                });\n-                tcbs.put(key, handlers);\n+                }\n             }\n-            handlers.put(handler, tcn.type);\n+            key.handlers.put(handler, tcn.type);\n+\n             tcn.start = s.label;\n             tcn.end = e.label;\n             tcn.handler = handler.label;\n@@ -261,40 +311,28 @@ public int compare(Block o1, Block o2) {\n     // }\n     // }\n \n-    private void doRebuild(InsnList insnList, Stack<Block> toWriteBlock, List<LabelNode> visited) {\n+    private void doRebuild(Stack<Block> toWriteBlock, List<LabelNode> visited) {\n         while (!toWriteBlock.empty()) {\n             Block b = toWriteBlock.pop();\n             if (visited.contains(b.label)) {\n                 continue;\n             }\n             visited.add(b.label);\n-            insnList.add(b.label);\n-            for (AbstractInsnNode p : b.insns) {\n-                insnList.add(p);\n-            }\n             if (b instanceof BranchBlock) {\n                 BranchBlock bb = (BranchBlock) b;\n-                switch (bb.branchInsn.getType()) {\n+                switch (bb.extraInsn.getType()) {\n                 case AbstractInsnNode.JUMP_INSN:\n-                    JumpInsnNode jump = (JumpInsnNode) bb.branchInsn;\n-                    insnList.add(jump);\n+                    JumpInsnNode jump = (JumpInsnNode) bb.extraInsn;\n                     toWriteBlock.push(map.get(jump.label));\n-                    if (visited.contains(bb.next)) {\n-                        insnList.add(new JumpInsnNode(GOTO, bb.next));\n-                    } else {\n-                        toWriteBlock.push(map.get(bb.next));\n-                    }\n                     continue;\n                 case AbstractInsnNode.LOOKUPSWITCH_INSN:\n                 case AbstractInsnNode.TABLESWITCH_INSN: {\n-                    AbstractInsnNode ts = bb.branchInsn;\n+                    AbstractInsnNode ts = bb.extraInsn;\n                     LabelNode dfltLabel = ts.getType() == AbstractInsnNode.LOOKUPSWITCH_INSN ? ((LookupSwitchInsnNode) ts).dflt\n                             : ((TableSwitchInsnNode) ts).dflt;\n                     @SuppressWarnings(\"unchecked\")\n                     List<LabelNode> labels = ts.getType() == AbstractInsnNode.LOOKUPSWITCH_INSN ? ((LookupSwitchInsnNode) ts).labels\n                             : ((TableSwitchInsnNode) ts).labels;\n-\n-                    insnList.add(ts);\n                     toWriteBlock.push(map.get(dfltLabel));\n                     List<LabelNode> cLables = new ArrayList<LabelNode>(labels);\n                     Collections.reverse(cLables);\n@@ -305,39 +343,36 @@ private void doRebuild(InsnList insnList, Stack<Block> toWriteBlock, List<LabelN\n                     continue;\n                 }\n                 }\n-            } else {\n-                if (b instanceof EndBlock) {\n-                    EndBlock eb = (EndBlock) b;\n-                    insnList.add(eb.endInsn);\n-                }\n-                if (b.next != null) {\n-                    if (visited.contains(b.next)) {\n-                        insnList.add(new JumpInsnNode(GOTO, b.next));\n-                    } else {\n-                        toWriteBlock.push(map.get(b.next));\n-                    }\n-                }\n             }\n         }\n     }\n \n     /**\n+     * \n      * @param method\n+     * @param blocks\n      */\n-    @SuppressWarnings(\"rawtypes\")\n-    private void rebuild(MethodNode method) {\n+    private static void rebuild(MethodNode method, List<Block> blocks) {\n         InsnList insnList = new InsnList();\n         method.instructions = insnList;\n-        List<LabelNode> visited = new ArrayList<LabelNode>();\n-        Stack<Block> toWriteBlock = new Stack<Block>();\n-        toWriteBlock.push(first);\n-        doRebuild(insnList, toWriteBlock, visited);\n-        method.tryCatchBlocks = new ArrayList();\n-        for (Iterator<?> it = method.tryCatchBlocks.iterator(); it.hasNext();) {\n-            TryCatchBlockNode tcn = (TryCatchBlockNode) it.next();\n-            toWriteBlock.push(map.get(tcn.handler));\n-            doRebuild(insnList, toWriteBlock, visited);\n+\n+        for (int i = 0; i < blocks.size(); i++) {\n+            Block b = blocks.get(i);\n+            insnList.add(b.label);\n+            for (AbstractInsnNode p : b.insns) {\n+                insnList.add(p);\n+            }\n+            if (b.extraInsn != null) {\n+                insnList.add(b.extraInsn);\n+            }\n+            if (b.next != null) {\n+                LabelNode labelNode = i + 1 < blocks.size() ? blocks.get(i + 1).label : null;\n+                if (!b.next.equals(labelNode)) {// \u4e0e\u4e0b\u4e00\u5757\u7684\u5f00\u59cb\u5730\u5740\u4e0d\u4e00\u6837\n+                    insnList.add(new JumpInsnNode(GOTO, b.next));\n+                }\n+            }\n         }\n+\n     }\n \n     /*\n@@ -348,6 +383,18 @@ private void rebuild(MethodNode method) {\n     @Override\n     public void transform(MethodNode method) {\n         cut(method);\n-        rebuild(method);\n+        List<Block> blocks = reOrder();\n+        rebuild(method, blocks);\n+    }\n+\n+    /**\n+     * @return\n+     */\n+    private List<Block> reOrder() {\n+        List<Block> blocks = new ArrayList(map.size());\n+        blocks.addAll(map.values());\n+        Block current = first;\n+\n+        return blocks;\n     }\n }",
      "parent_sha": "b7942c613c3d51ecbdadb0cf22ae99d6bda00896"
    }
  },
  {
    "oid": "b6f2a0048210d3c0e8ec2deea21642bb1ebd420b",
    "message": "fix empty file in jar\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2012-12-04T07:26:41Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/b6f2a0048210d3c0e8ec2deea21642bb1ebd420b",
    "details": {
      "sha": "b081610afa749ac7356c39017b9715ddc7d87e57",
      "filename": "dex-translator/src/main/java/com/googlecode/dex2jar/v3/Dex2jar.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/b6f2a0048210d3c0e8ec2deea21642bb1ebd420b/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FDex2jar.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/b6f2a0048210d3c0e8ec2deea21642bb1ebd420b/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FDex2jar.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FDex2jar.java?ref=b6f2a0048210d3c0e8ec2deea21642bb1ebd420b",
      "patch": "@@ -182,7 +182,7 @@ private void check(String dir, ZipOutputStream zos) throws IOException {\n         if (i > 0) {\n             check(dir.substring(0, i), zos);\n         }\n-        zos.putNextEntry(new ZipEntry(dir));\n+        zos.putNextEntry(new ZipEntry(dir + \"/\"));\n         zos.closeEntry();\n     }\n ",
      "parent_sha": "4f349ac68c881a3a76793f771159ef6db1e21e20"
    }
  },
  {
    "oid": "f3fc040a09cf9d34694946688995086be64095e7",
    "message": "Finally fix handling of large arrays\n\n\n# Conflicts:\n#\tdex-translator/src/main/java/com/googlecode/d2j/dex/Dex2Asm.java",
    "date": "2023-08-31T10:33:38Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/f3fc040a09cf9d34694946688995086be64095e7",
    "details": {
      "sha": "003c61a0240b6c24140e4d252508884a885d1092",
      "filename": "dex-translator/src/main/java/com/googlecode/d2j/dex/Dex2Asm.java",
      "status": "modified",
      "additions": 11,
      "deletions": 7,
      "changes": 18,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/f3fc040a09cf9d34694946688995086be64095e7/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FDex2Asm.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/f3fc040a09cf9d34694946688995086be64095e7/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FDex2Asm.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FDex2Asm.java?ref=f3fc040a09cf9d34694946688995086be64095e7",
      "patch": "@@ -524,11 +524,13 @@ public void convertClass(int dexVersion, DexClassNode classNode, ClassVisitorFac\n         cv.visitEnd();\n     }\n \n+    private static final String HEX_CLASS_LOCATION = \"res/Hex\";\n+\n     private static final Set<String> HEX_DECODE_METHODS =\n             new HashSet<>(Arrays.asList(\"decode_J\", \"decode_I\", \"decode_S\", \"decode_B\"));\n \n     private void addHexDecodeMethod(ClassVisitor outCV, String className, String hexDecodeMethodNameBase) {\n-        try (InputStream is = Dex2Asm.class.getResourceAsStream(\"/res/Hex.class\")) {\n+        try (InputStream is = Dex2Asm.class.getResourceAsStream(\"/\" + HEX_CLASS_LOCATION + \".class\")) {\n             ClassReader cr = new ClassReader(is);\n             cr.accept(new ClassVisitor(Opcodes.ASM9) {\n                 @Override\n@@ -537,14 +539,16 @@ public MethodVisitor visitMethod(int access, String name, String desc, String si\n                     if (HEX_DECODE_METHODS.contains(name)) {\n                         return new MethodVisitor(Opcodes.ASM9,\n                                 outCV.visitMethod(Opcodes.ACC_PRIVATE | Opcodes.ACC_STATIC,\n-                                        hexDecodeMethodNameBase + \"$\" + name,\n-                                        desc, signature, exceptions\n-                                )) {\n+                                        hexDecodeMethodNameBase + \"$\" + name, desc, signature, exceptions)) {\n                             @Override\n                             public void visitMethodInsn(int opcode, String owner, String name, String descriptor,\n                                                         boolean isInterface) {\n-                                super.visitMethodInsn(opcode, owner.equals(\"res/Hex\") ? className : owner, name,\n-                                        descriptor, isInterface);\n+                                if (owner.equals(HEX_CLASS_LOCATION)) {\n+                                    super.visitMethodInsn(opcode, className, hexDecodeMethodNameBase + \"$\" + name,\n+                                            descriptor, isInterface);\n+                                } else {\n+                                    super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\n+                                }\n                             }\n                         };\n                     } else {\n@@ -553,7 +557,7 @@ public void visitMethodInsn(int opcode, String owner, String name, String descri\n                 }\n             }, ClassReader.EXPAND_FRAMES);\n         } catch (Throwable t) {\n-            throw new RuntimeException(\"Failed to add Hex.decode_*\", t);\n+            throw new RuntimeException(\"Failed to add \" + HEX_CLASS_LOCATION + \".decode_*\", t);\n         }\n     }\n     public void convertCode(DexMethodNode methodNode, MethodVisitor mv, ClzCtx clzCtx) {",
      "parent_sha": "6a798f7518f83d4223efad473f9e034cb44ab9ff"
    }
  },
  {
    "oid": "bf54180dec4f63a63482b9fc0ba821f9b3d00e03",
    "message": "github has attachement support",
    "date": "2018-03-27T03:42:04Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/bf54180dec4f63a63482b9fc0ba821f9b3d00e03",
    "details": {
      "sha": "5fc6e216a31eca42d1ea53b2c17e585746df1480",
      "filename": "dex-tools/src/main/java/com/googlecode/dex2jar/tools/BaksmaliBaseDexExceptionHandler.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/bf54180dec4f63a63482b9fc0ba821f9b3d00e03/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FBaksmaliBaseDexExceptionHandler.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/bf54180dec4f63a63482b9fc0ba821f9b3d00e03/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FBaksmaliBaseDexExceptionHandler.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FBaksmaliBaseDexExceptionHandler.java?ref=bf54180dec4f63a63482b9fc0ba821f9b3d00e03",
      "patch": "@@ -43,7 +43,7 @@ public class BaksmaliBaseDexExceptionHandler extends BaseDexExceptionHandler {\n     public static final String REPORT_MESSAGE = \"Please report this file to one of following link if possible (any one).\\n\" + //\n             \"    https://sourceforge.net/p/dex2jar/tickets/\\n\" + //\n             \"    https://bitbucket.org/pxb1988/dex2jar/issues\\n\" + //\n-            \"    https://github.com/pxb1988/dex2jar/issues [no attachment support, not preferred]\\n\" + //\n+            \"    https://github.com/pxb1988/dex2jar/issues\\n\" + //\n             \"    dex2jar@googlegroups.com\";\n \n     private Map<DexMethodNode, Exception> exceptionMap = new HashMap<>();",
      "parent_sha": "5a2f61965c6e7a957405836b73d9012f418dc604"
    }
  },
  {
    "oid": "41f54dccb71dfe09a6835dd9c3ad41e626e663f8",
    "message": "check dead code in zero transform\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2012-01-02T06:14:24Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/41f54dccb71dfe09a6835dd9c3ad41e626e663f8",
    "details": {
      "sha": "b22c07ca76936d41f2479ce94a465a2e26bfed0c",
      "filename": "dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/ZeroTransformer.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/41f54dccb71dfe09a6835dd9c3ad41e626e663f8/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FZeroTransformer.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/41f54dccb71dfe09a6835dd9c3ad41e626e663f8/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FZeroTransformer.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FZeroTransformer.java?ref=41f54dccb71dfe09a6835dd9c3ad41e626e663f8",
      "patch": "@@ -235,7 +235,7 @@ public void transform(IrMethod irMethod) {\n         for (Stmt p = irMethod.stmts.getFirst(); p != null; p = p.getNext()) {\r\n             Phi[] frame = (Phi[]) p._ls_forward_frame;\r\n             p._ls_forward_frame = null;\r\n-            if (frame == null) {// dead code ?\r\n+            if (frame == null || !p._cfg_visited) {// dead code ?\r\n                 continue;\r\n             }\r\n             switch (p.et) {\r",
      "parent_sha": "30377462ad6c99969a3058736b3d6c8366c08abb"
    }
  },
  {
    "oid": "305f294de765d7f337c72a96d39cdca939b7eee5",
    "message": "[decrypt-string] mute exception stack\n\nhttps://github.com/pxb1988/dex2jar/issues/51",
    "date": "2016-01-18T09:13:51Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/305f294de765d7f337c72a96d39cdca939b7eee5",
    "details": {
      "sha": "59f3e0ea70a668c71a16ee48e5483ac750b1e80a",
      "filename": "dex-tools/src/main/java/com/googlecode/dex2jar/tools/DecryptStringCmd.java",
      "status": "modified",
      "additions": 12,
      "deletions": 6,
      "changes": 18,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/305f294de765d7f337c72a96d39cdca939b7eee5/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FDecryptStringCmd.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/305f294de765d7f337c72a96d39cdca939b7eee5/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FDecryptStringCmd.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FDecryptStringCmd.java?ref=305f294de765d7f337c72a96d39cdca939b7eee5",
      "patch": "@@ -757,20 +757,25 @@ private Map<MethodConfig, MethodConfig> loadMethods(Path jar, List<MethodConfig>\n \n         URLClassLoader cl = new URLClassLoader(urls);\n         for (MethodConfig config : methodConfigs) {\n+            Method jmethod;\n             try {\n                 Class<?> clz = cl.loadClass(config.owner.replace('/', '.'));\n                 if (clz == null) {\n                     System.err.println(\"clz is null:\" + config.owner);\n                 }\n-                Method jmethod = findAnyMethodMatch(clz, config.name,\n+                jmethod = findAnyMethodMatch(clz, config.name,\n                         toJavaType(Type.getArgumentTypes(config.desc)));\n-                jmethod.setAccessible(true);\n-                config.jmethod = jmethod;\n-                map.put(config, config);\n             } catch (Exception ex) {\n                 System.err.println(\"can't load method: L\" + config.owner + \";->\" + config.name + config.desc);\n                 throw ex;\n             }\n+            if (jmethod != null) {\n+                jmethod.setAccessible(true);\n+                config.jmethod = jmethod;\n+                map.put(config, config);\n+            } else {\n+                throw new NoSuchMethodException(\"can't find method \" + config.name + config.desc + \" on class \" + config.owner + \" or its parent\");\n+            }\n         }\n         return map;\n     }\n@@ -853,8 +858,9 @@ private Method findAnyMethodMatch(Class<?> clz, String name, Class<?>[] classes)\n             if (m != null) {\n                 return m;\n             }\n-        } catch (NoSuchMethodException e) {\n-            e.printStackTrace();\n+        } catch (NoSuchMethodException ignored) {\n+            // https://github.com/pxb1988/dex2jar/issues/51\n+            // mute exception stack\n         }\n         Class<?> sup = clz.getSuperclass();\n         if (sup != null) {",
      "parent_sha": "a6298932f832045a196f68f375ef74f4c56cf362"
    }
  },
  {
    "oid": "48f9849ac2e8b5d540664d334f87c75a7654320a",
    "message": "1.\u91cd\u5199dex-reader\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2011-04-05T06:55:48Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/48f9849ac2e8b5d540664d334f87c75a7654320a",
    "details": {
      "sha": "1aaca81721f1ddd5abdc8c4b9e582b9da1e265f2",
      "filename": "dex-reader/src/main/java/com/googlecode/dex2jar/reader/DexOpcodeUtil.java",
      "status": "modified",
      "additions": 384,
      "deletions": 793,
      "changes": 1177,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/48f9849ac2e8b5d540664d334f87c75a7654320a/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexOpcodeUtil.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/48f9849ac2e8b5d540664d334f87c75a7654320a/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexOpcodeUtil.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexOpcodeUtil.java?ref=48f9849ac2e8b5d540664d334f87c75a7654320a",
      "patch": "@@ -40,8 +40,6 @@\n import static com.googlecode.dex2jar.reader.OpcodeFormat.F3rc;\r\n import static com.googlecode.dex2jar.reader.OpcodeFormat.F51l;\r\n \r\n-import org.objectweb.asm.Opcodes;\r\n-\r\n import com.googlecode.dex2jar.DexOpcodeDump;\r\n import com.googlecode.dex2jar.DexOpcodes;\r\n \r\n@@ -51,887 +49,480 @@\n  * @author Panxiaobo [pxb1988@gmail.com]\r\n  * @version $Id$\r\n  */\r\n-class DexOpcodeUtil implements DexOpcodes, Opcodes, DexInternalOpcode {\r\n+class DexOpcodeUtil implements DexOpcodes, DexInternalOpcode {\r\n     public static int format(int opcode) {\r\n         switch (opcode) {\r\n+        case OP_GOTO:\r\n+            return F10t;\r\n         case OP_NOP:\r\n+        case OP_RETURN_VOID:\r\n             return F10x;\r\n-        case OP_MOVE:\r\n-            return F12x;\r\n-        case OP_MOVE_FROM16:\r\n-            return F22x;\r\n-        case OP_MOVE_16:\r\n-            return F32x;\r\n-        case OP_MOVE_WIDE:\r\n-            return F12x;\r\n-        case OP_MOVE_WIDE_FROM16:\r\n-            return F22x;\r\n-        case OP_MOVE_WIDE_16:\r\n-            return F32x;\r\n-        case OP_MOVE_OBJECT:\r\n-            return F12x;\r\n-        case OP_MOVE_OBJECT_FROM16:\r\n-            return F22x;\r\n-        case OP_MOVE_OBJECT_16:\r\n-            return F32x;\r\n+        case OP_CONST_4:\r\n+            return F11n;\r\n         case OP_MOVE_RESULT:\r\n-            return F11x;\r\n         case OP_MOVE_RESULT_WIDE:\r\n-            return F11x;\r\n         case OP_MOVE_RESULT_OBJECT:\r\n-            return F11x;\r\n         case OP_MOVE_EXCEPTION:\r\n-            return F11x;\r\n-        case OP_RETURN_VOID:\r\n-            return F10x;\r\n         case OP_RETURN:\r\n-            return F11x;\r\n         case OP_RETURN_WIDE:\r\n-            return F11x;\r\n         case OP_RETURN_OBJECT:\r\n-            return F11x;\r\n-        case OP_CONST_4:\r\n-            return F11n;\r\n-        case OP_CONST_16:\r\n-            return F21s;\r\n-        case OP_CONST:\r\n-            return F31i;\r\n-        case OP_CONST_HIGH16:\r\n-            return F21h;\r\n-        case OP_CONST_WIDE_16:\r\n-            return F21s;\r\n-        case OP_CONST_WIDE_32:\r\n-            return F31i;\r\n-        case OP_CONST_WIDE:\r\n-            return F51l;\r\n-        case OP_CONST_WIDE_HIGH16:\r\n-            return F21h;\r\n-        case OP_CONST_STRING:\r\n-            return F21c;\r\n-        case OP_CONST_STRING_JUMBO:\r\n-            return F31c;\r\n-        case OP_CONST_CLASS:\r\n-            return F21c;\r\n         case OP_MONITOR_ENTER:\r\n-            return F11x;\r\n         case OP_MONITOR_EXIT:\r\n+        case OP_THROW:\r\n             return F11x;\r\n-        case OP_CHECK_CAST:\r\n-            return F21c;\r\n-        case OP_INSTANCE_OF:\r\n-            return F22c;\r\n+        case OP_MOVE:\r\n+        case OP_MOVE_WIDE:\r\n+        case OP_MOVE_OBJECT:\r\n         case OP_ARRAY_LENGTH:\r\n+        case OP_NEG_INT:\r\n+        case OP_NOT_INT:\r\n+        case OP_NEG_LONG:\r\n+        case OP_NOT_LONG:\r\n+        case OP_NEG_FLOAT:\r\n+        case OP_NEG_DOUBLE:\r\n+        case OP_INT_TO_LONG:\r\n+        case OP_INT_TO_FLOAT:\r\n+        case OP_INT_TO_DOUBLE:\r\n+        case OP_LONG_TO_INT:\r\n+        case OP_LONG_TO_FLOAT:\r\n+        case OP_LONG_TO_DOUBLE:\r\n+        case OP_FLOAT_TO_INT:\r\n+        case OP_FLOAT_TO_LONG:\r\n+        case OP_FLOAT_TO_DOUBLE:\r\n+        case OP_DOUBLE_TO_INT:\r\n+        case OP_DOUBLE_TO_LONG:\r\n+        case OP_DOUBLE_TO_FLOAT:\r\n+        case OP_INT_TO_BYTE:\r\n+        case OP_INT_TO_CHAR:\r\n+        case OP_INT_TO_SHORT:\r\n+        case OP_ADD_INT_2ADDR:\r\n+        case OP_SUB_INT_2ADDR:\r\n+        case OP_MUL_INT_2ADDR:\r\n+        case OP_DIV_INT_2ADDR:\r\n+        case OP_REM_INT_2ADDR:\r\n+        case OP_AND_INT_2ADDR:\r\n+        case OP_OR_INT_2ADDR:\r\n+        case OP_XOR_INT_2ADDR:\r\n+        case OP_SHL_INT_2ADDR:\r\n+        case OP_SHR_INT_2ADDR:\r\n+        case OP_USHR_INT_2ADDR:\r\n+        case OP_ADD_LONG_2ADDR:\r\n+        case OP_SUB_LONG_2ADDR:\r\n+        case OP_MUL_LONG_2ADDR:\r\n+        case OP_DIV_LONG_2ADDR:\r\n+        case OP_REM_LONG_2ADDR:\r\n+        case OP_AND_LONG_2ADDR:\r\n+        case OP_OR_LONG_2ADDR:\r\n+        case OP_XOR_LONG_2ADDR:\r\n+        case OP_SHL_LONG_2ADDR:\r\n+        case OP_SHR_LONG_2ADDR:\r\n+        case OP_USHR_LONG_2ADDR:\r\n+        case OP_ADD_FLOAT_2ADDR:\r\n+        case OP_SUB_FLOAT_2ADDR:\r\n+        case OP_MUL_FLOAT_2ADDR:\r\n+        case OP_DIV_FLOAT_2ADDR:\r\n+        case OP_REM_FLOAT_2ADDR:\r\n+        case OP_ADD_DOUBLE_2ADDR:\r\n+        case OP_SUB_DOUBLE_2ADDR:\r\n+        case OP_MUL_DOUBLE_2ADDR:\r\n+        case OP_DIV_DOUBLE_2ADDR:\r\n+        case OP_REM_DOUBLE_2ADDR:\r\n             return F12x;\r\n+        case OP_GOTO_16:\r\n+            return F20t;\r\n+        case OP_CONST_STRING:\r\n+        case OP_CONST_CLASS:\r\n+        case OP_CHECK_CAST:\r\n         case OP_NEW_INSTANCE:\r\n+        case OP_SGET:\r\n+        case OP_SGET_WIDE:\r\n+        case OP_SGET_OBJECT:\r\n+        case OP_SGET_BOOLEAN:\r\n+        case OP_SGET_BYTE:\r\n+        case OP_SGET_CHAR:\r\n+        case OP_SGET_SHORT:\r\n+        case OP_SPUT:\r\n+        case OP_SPUT_WIDE:\r\n+        case OP_SPUT_OBJECT:\r\n+        case OP_SPUT_BOOLEAN:\r\n+        case OP_SPUT_BYTE:\r\n+        case OP_SPUT_CHAR:\r\n+        case OP_SPUT_SHORT:\r\n             return F21c;\r\n+        case OP_CONST_HIGH16:\r\n+        case OP_CONST_WIDE_HIGH16:\r\n+            return F21h;\r\n+        case OP_CONST_16:\r\n+        case OP_CONST_WIDE_16:\r\n+            return F21s;\r\n+        case OP_IF_EQZ:\r\n+        case OP_IF_NEZ:\r\n+        case OP_IF_LTZ:\r\n+        case OP_IF_GEZ:\r\n+        case OP_IF_GTZ:\r\n+        case OP_IF_LEZ:\r\n+            return F21t;\r\n+        case OP_ADD_INT_LIT8:\r\n+        case OP_RSUB_INT_LIT8:\r\n+        case OP_MUL_INT_LIT8:\r\n+        case OP_DIV_INT_LIT8:\r\n+        case OP_REM_INT_LIT8:\r\n+        case OP_AND_INT_LIT8:\r\n+        case OP_OR_INT_LIT8:\r\n+        case OP_XOR_INT_LIT8:\r\n+        case OP_SHL_INT_LIT8:\r\n+        case OP_SHR_INT_LIT8:\r\n+        case OP_USHR_INT_LIT8:\r\n+            return F22b;\r\n+        case OP_INSTANCE_OF:\r\n         case OP_NEW_ARRAY:\r\n+        case OP_IGET:\r\n+        case OP_IGET_WIDE:\r\n+        case OP_IGET_OBJECT:\r\n+        case OP_IGET_BOOLEAN:\r\n+        case OP_IGET_BYTE:\r\n+        case OP_IGET_CHAR:\r\n+        case OP_IGET_SHORT:\r\n+        case OP_IPUT:\r\n+        case OP_IPUT_WIDE:\r\n+        case OP_IPUT_OBJECT:\r\n+        case OP_IPUT_BOOLEAN:\r\n+        case OP_IPUT_BYTE:\r\n+        case OP_IPUT_CHAR:\r\n+        case OP_IPUT_SHORT:\r\n             return F22c;\r\n-        case OP_FILLED_NEW_ARRAY:\r\n-            return F35c;\r\n-        case OP_FILLED_NEW_ARRAY_RANGE:\r\n-            return F3rc;\r\n-        case OP_FILL_ARRAY_DATA:\r\n-            return F31t;\r\n-        case OP_THROW:\r\n-            return F11x;\r\n-        case OP_GOTO:\r\n-            return F10t;\r\n-        case OP_GOTO_16:\r\n-            return F20t;\r\n-        case OP_GOTO_32:\r\n-            return F30t;\r\n-        case OP_PACKED_SWITCH:\r\n-            return F31t;\r\n-        case OP_SPARSE_SWITCH:\r\n-            return F31t;\r\n-        case OP_CMPL_FLOAT:\r\n-            return F23x;\r\n-        case OP_CMPG_FLOAT:\r\n-            return F23x;\r\n-        case OP_CMPL_DOUBLE:\r\n-            return F23x;\r\n-        case OP_CMPG_DOUBLE:\r\n-            return F23x;\r\n-        case OP_CMP_LONG:\r\n-            return F23x;\r\n+        case OP_ADD_INT_LIT16:\r\n+        case OP_RSUB_INT:\r\n+        case OP_MUL_INT_LIT16:\r\n+        case OP_DIV_INT_LIT16:\r\n+        case OP_REM_INT_LIT16:\r\n+        case OP_AND_INT_LIT16:\r\n+        case OP_OR_INT_LIT16:\r\n+        case OP_XOR_INT_LIT16:\r\n+            return F22s;\r\n         case OP_IF_EQ:\r\n-            return F22t;\r\n         case OP_IF_NE:\r\n-            return F22t;\r\n         case OP_IF_LT:\r\n-            return F22t;\r\n         case OP_IF_GE:\r\n-            return F22t;\r\n         case OP_IF_GT:\r\n-            return F22t;\r\n         case OP_IF_LE:\r\n             return F22t;\r\n-        case OP_IF_EQZ:\r\n-            return F21t;\r\n-        case OP_IF_NEZ:\r\n-            return F21t;\r\n-        case OP_IF_LTZ:\r\n-            return F21t;\r\n-        case OP_IF_GEZ:\r\n-            return F21t;\r\n-        case OP_IF_GTZ:\r\n-            return F21t;\r\n-        case OP_IF_LEZ:\r\n-            return F21t;\r\n+        case OP_MOVE_FROM16:\r\n+        case OP_MOVE_WIDE_FROM16:\r\n+        case OP_MOVE_OBJECT_FROM16:\r\n+            return F22x;\r\n+        case OP_CMPL_FLOAT:\r\n+        case OP_CMPG_FLOAT:\r\n+        case OP_CMPL_DOUBLE:\r\n+        case OP_CMPG_DOUBLE:\r\n+        case OP_CMP_LONG:\r\n         case OP_AGET:\r\n-            return F23x;\r\n         case OP_AGET_WIDE:\r\n-            return F23x;\r\n         case OP_AGET_OBJECT:\r\n-            return F23x;\r\n         case OP_AGET_BOOLEAN:\r\n-            return F23x;\r\n         case OP_AGET_BYTE:\r\n-            return F23x;\r\n         case OP_AGET_CHAR:\r\n-            return F23x;\r\n         case OP_AGET_SHORT:\r\n-            return F23x;\r\n         case OP_APUT:\r\n-            return F23x;\r\n         case OP_APUT_WIDE:\r\n-            return F23x;\r\n         case OP_APUT_OBJECT:\r\n-            return F23x;\r\n         case OP_APUT_BOOLEAN:\r\n-            return F23x;\r\n         case OP_APUT_BYTE:\r\n-            return F23x;\r\n         case OP_APUT_CHAR:\r\n-            return F23x;\r\n         case OP_APUT_SHORT:\r\n-            return F23x;\r\n-        case OP_IGET:\r\n-            return F22c;\r\n-        case OP_IGET_WIDE:\r\n-            return F22c;\r\n-        case OP_IGET_OBJECT:\r\n-            return F22c;\r\n-        case OP_IGET_BOOLEAN:\r\n-            return F22c;\r\n-        case OP_IGET_BYTE:\r\n-            return F22c;\r\n-        case OP_IGET_CHAR:\r\n-            return F22c;\r\n-        case OP_IGET_SHORT:\r\n-            return F22c;\r\n-        case OP_IPUT:\r\n-            return F22c;\r\n-        case OP_IPUT_WIDE:\r\n-            return F22c;\r\n-        case OP_IPUT_OBJECT:\r\n-            return F22c;\r\n-        case OP_IPUT_BOOLEAN:\r\n-            return F22c;\r\n-        case OP_IPUT_BYTE:\r\n-            return F22c;\r\n-        case OP_IPUT_CHAR:\r\n-            return F22c;\r\n-        case OP_IPUT_SHORT:\r\n-            return F22c;\r\n-        case OP_SGET:\r\n-            return F21c;\r\n-        case OP_SGET_WIDE:\r\n-            return F21c;\r\n-        case OP_SGET_OBJECT:\r\n-            return F21c;\r\n-        case OP_SGET_BOOLEAN:\r\n-            return F21c;\r\n-        case OP_SGET_BYTE:\r\n-            return F21c;\r\n-        case OP_SGET_CHAR:\r\n-            return F21c;\r\n-        case OP_SGET_SHORT:\r\n-            return F21c;\r\n-        case OP_SPUT:\r\n-            return F21c;\r\n-        case OP_SPUT_WIDE:\r\n-            return F21c;\r\n-        case OP_SPUT_OBJECT:\r\n-            return F21c;\r\n-        case OP_SPUT_BOOLEAN:\r\n-            return F21c;\r\n-        case OP_SPUT_BYTE:\r\n-            return F21c;\r\n-        case OP_SPUT_CHAR:\r\n-            return F21c;\r\n-        case OP_SPUT_SHORT:\r\n-            return F21c;\r\n-        case OP_INVOKE_VIRTUAL:\r\n-            return F35c;\r\n-        case OP_INVOKE_SUPER:\r\n-            return F35c;\r\n-        case OP_INVOKE_DIRECT:\r\n-            return F35c;\r\n-        case OP_INVOKE_STATIC:\r\n-            return F35c;\r\n-        case OP_INVOKE_INTERFACE:\r\n-            return F35c;\r\n-        case OP_INVOKE_VIRTUAL_RANGE:\r\n-            return F3rc;\r\n-        case OP_INVOKE_SUPER_RANGE:\r\n-            return F3rc;\r\n-        case OP_INVOKE_DIRECT_RANGE:\r\n-            return F3rc;\r\n-        case OP_INVOKE_STATIC_RANGE:\r\n-            return F3rc;\r\n-        case OP_INVOKE_INTERFACE_RANGE:\r\n-            return F3rc;\r\n-        case OP_NEG_INT:\r\n-            return F12x;\r\n-        case OP_NOT_INT:\r\n-            return F12x;\r\n-        case OP_NEG_LONG:\r\n-            return F12x;\r\n-        case OP_NOT_LONG:\r\n-            return F12x;\r\n-        case OP_NEG_FLOAT:\r\n-            return F12x;\r\n-        case OP_NEG_DOUBLE:\r\n-            return F12x;\r\n-        case OP_INT_TO_LONG:\r\n-            return F12x;\r\n-        case OP_INT_TO_FLOAT:\r\n-            return F12x;\r\n-        case OP_INT_TO_DOUBLE:\r\n-            return F12x;\r\n-        case OP_LONG_TO_INT:\r\n-            return F12x;\r\n-        case OP_LONG_TO_FLOAT:\r\n-            return F12x;\r\n-        case OP_LONG_TO_DOUBLE:\r\n-            return F12x;\r\n-        case OP_FLOAT_TO_INT:\r\n-            return F12x;\r\n-        case OP_FLOAT_TO_LONG:\r\n-            return F12x;\r\n-        case OP_FLOAT_TO_DOUBLE:\r\n-            return F12x;\r\n-        case OP_DOUBLE_TO_INT:\r\n-            return F12x;\r\n-        case OP_DOUBLE_TO_LONG:\r\n-            return F12x;\r\n-        case OP_DOUBLE_TO_FLOAT:\r\n-            return F12x;\r\n-        case OP_INT_TO_BYTE:\r\n-            return F12x;\r\n-        case OP_INT_TO_CHAR:\r\n-            return F12x;\r\n-        case OP_INT_TO_SHORT:\r\n-            return F12x;\r\n         case OP_ADD_INT:\r\n-            return F23x;\r\n         case OP_SUB_INT:\r\n-            return F23x;\r\n         case OP_MUL_INT:\r\n-            return F23x;\r\n         case OP_DIV_INT:\r\n-            return F23x;\r\n         case OP_REM_INT:\r\n-            return F23x;\r\n         case OP_AND_INT:\r\n-            return F23x;\r\n         case OP_OR_INT:\r\n-            return F23x;\r\n         case OP_XOR_INT:\r\n-            return F23x;\r\n         case OP_SHL_INT:\r\n-            return F23x;\r\n         case OP_SHR_INT:\r\n-            return F23x;\r\n         case OP_USHR_INT:\r\n-            return F23x;\r\n         case OP_ADD_LONG:\r\n-            return F23x;\r\n         case OP_SUB_LONG:\r\n-            return F23x;\r\n         case OP_MUL_LONG:\r\n-            return F23x;\r\n         case OP_DIV_LONG:\r\n-            return F23x;\r\n         case OP_REM_LONG:\r\n-            return F23x;\r\n         case OP_AND_LONG:\r\n-            return F23x;\r\n         case OP_OR_LONG:\r\n-            return F23x;\r\n         case OP_XOR_LONG:\r\n-            return F23x;\r\n         case OP_SHL_LONG:\r\n-            return F23x;\r\n         case OP_SHR_LONG:\r\n-            return F23x;\r\n         case OP_USHR_LONG:\r\n-            return F23x;\r\n         case OP_ADD_FLOAT:\r\n-            return F23x;\r\n         case OP_SUB_FLOAT:\r\n-            return F23x;\r\n         case OP_MUL_FLOAT:\r\n-            return F23x;\r\n         case OP_DIV_FLOAT:\r\n-            return F23x;\r\n         case OP_REM_FLOAT:\r\n-            return F23x;\r\n         case OP_ADD_DOUBLE:\r\n-            return F23x;\r\n         case OP_SUB_DOUBLE:\r\n-            return F23x;\r\n         case OP_MUL_DOUBLE:\r\n-            return F23x;\r\n         case OP_DIV_DOUBLE:\r\n-            return F23x;\r\n         case OP_REM_DOUBLE:\r\n             return F23x;\r\n-        case OP_ADD_INT_2ADDR:\r\n-            return F12x;\r\n-        case OP_SUB_INT_2ADDR:\r\n-            return F12x;\r\n-        case OP_MUL_INT_2ADDR:\r\n-            return F12x;\r\n-        case OP_DIV_INT_2ADDR:\r\n-            return F12x;\r\n-        case OP_REM_INT_2ADDR:\r\n-            return F12x;\r\n-        case OP_AND_INT_2ADDR:\r\n-            return F12x;\r\n-        case OP_OR_INT_2ADDR:\r\n-            return F12x;\r\n-        case OP_XOR_INT_2ADDR:\r\n-            return F12x;\r\n-        case OP_SHL_INT_2ADDR:\r\n-            return F12x;\r\n-        case OP_SHR_INT_2ADDR:\r\n-            return F12x;\r\n-        case OP_USHR_INT_2ADDR:\r\n-            return F12x;\r\n-        case OP_ADD_LONG_2ADDR:\r\n-            return F12x;\r\n-        case OP_SUB_LONG_2ADDR:\r\n-            return F12x;\r\n-        case OP_MUL_LONG_2ADDR:\r\n-            return F12x;\r\n-        case OP_DIV_LONG_2ADDR:\r\n-            return F12x;\r\n-        case OP_REM_LONG_2ADDR:\r\n-            return F12x;\r\n-        case OP_AND_LONG_2ADDR:\r\n-            return F12x;\r\n-        case OP_OR_LONG_2ADDR:\r\n-            return F12x;\r\n-        case OP_XOR_LONG_2ADDR:\r\n-            return F12x;\r\n-        case OP_SHL_LONG_2ADDR:\r\n-            return F12x;\r\n-        case OP_SHR_LONG_2ADDR:\r\n-            return F12x;\r\n-        case OP_USHR_LONG_2ADDR:\r\n-            return F12x;\r\n-        case OP_ADD_FLOAT_2ADDR:\r\n-            return F12x;\r\n-        case OP_SUB_FLOAT_2ADDR:\r\n-            return F12x;\r\n-        case OP_MUL_FLOAT_2ADDR:\r\n-            return F12x;\r\n-        case OP_DIV_FLOAT_2ADDR:\r\n-            return F12x;\r\n-        case OP_REM_FLOAT_2ADDR:\r\n-            return F12x;\r\n-        case OP_ADD_DOUBLE_2ADDR:\r\n-            return F12x;\r\n-        case OP_SUB_DOUBLE_2ADDR:\r\n-            return F12x;\r\n-        case OP_MUL_DOUBLE_2ADDR:\r\n-            return F12x;\r\n-        case OP_DIV_DOUBLE_2ADDR:\r\n-            return F12x;\r\n-        case OP_REM_DOUBLE_2ADDR:\r\n-            return F12x;\r\n-        case OP_ADD_INT_LIT16:\r\n-            return F22s;\r\n-        case OP_RSUB_INT:\r\n-            return F22s;\r\n-        case OP_MUL_INT_LIT16:\r\n-            return F22s;\r\n-        case OP_DIV_INT_LIT16:\r\n-            return F22s;\r\n-        case OP_REM_INT_LIT16:\r\n-            return F22s;\r\n-        case OP_AND_INT_LIT16:\r\n-            return F22s;\r\n-        case OP_OR_INT_LIT16:\r\n-            return F22s;\r\n-        case OP_XOR_INT_LIT16:\r\n-            return F22s;\r\n-        case OP_ADD_INT_LIT8:\r\n-            return F22b;\r\n-        case OP_RSUB_INT_LIT8:\r\n-            return F22b;\r\n-        case OP_MUL_INT_LIT8:\r\n-            return F22b;\r\n-        case OP_DIV_INT_LIT8:\r\n-            return F22b;\r\n-        case OP_REM_INT_LIT8:\r\n-            return F22b;\r\n-        case OP_AND_INT_LIT8:\r\n-            return F22b;\r\n-        case OP_OR_INT_LIT8:\r\n-            return F22b;\r\n-        case OP_XOR_INT_LIT8:\r\n-            return F22b;\r\n-        case OP_SHL_INT_LIT8:\r\n-            return F22b;\r\n-        case OP_SHR_INT_LIT8:\r\n-            return F22b;\r\n-        case OP_USHR_INT_LIT8:\r\n-            return F22b;\r\n-        }\r\n-        throw new RuntimeException(\"opcode length for \" + opcode + \" not found!\");\r\n-    }\r\n-\r\n-    public static int length(int opcode) {\r\n-        switch (opcode) {\r\n-        case OP_NOP:\r\n-            return 1;\r\n-        case OP_MOVE:\r\n-            return 1;\r\n-        case OP_MOVE_FROM16:\r\n-            return 2;\r\n-        case OP_MOVE_16:\r\n-            return 3;\r\n-        case OP_MOVE_WIDE:\r\n-            return 1;\r\n-        case OP_MOVE_WIDE_FROM16:\r\n-            return 2;\r\n-        case OP_MOVE_WIDE_16:\r\n-            return 3;\r\n-        case OP_MOVE_OBJECT:\r\n-            return 1;\r\n-        case OP_MOVE_OBJECT_FROM16:\r\n-            return 2;\r\n-        case OP_MOVE_OBJECT_16:\r\n-            return 3;\r\n-        case OP_MOVE_RESULT:\r\n-            return 1;\r\n-        case OP_MOVE_RESULT_WIDE:\r\n-            return 1;\r\n-        case OP_MOVE_RESULT_OBJECT:\r\n-            return 1;\r\n-        case OP_MOVE_EXCEPTION:\r\n-            return 1;\r\n-        case OP_RETURN_VOID:\r\n-            return 1;\r\n-        case OP_RETURN:\r\n-            return 1;\r\n-        case OP_RETURN_WIDE:\r\n-            return 1;\r\n-        case OP_RETURN_OBJECT:\r\n-            return 1;\r\n-        case OP_CONST_4:\r\n-            return 1;\r\n-        case OP_CONST_16:\r\n-            return 2;\r\n+        case OP_GOTO_32:\r\n+            return F30t;\r\n+        case OP_CONST_STRING_JUMBO:\r\n+            return F31c;\r\n         case OP_CONST:\r\n-            return 3;\r\n-        case OP_CONST_HIGH16:\r\n-            return 2;\r\n-        case OP_CONST_WIDE_16:\r\n-            return 2;\r\n         case OP_CONST_WIDE_32:\r\n-            return 3;\r\n-        case OP_CONST_WIDE:\r\n-            return 5;\r\n-        case OP_CONST_WIDE_HIGH16:\r\n-            return 2;\r\n-        case OP_CONST_STRING:\r\n-            return 2;\r\n-        case OP_CONST_STRING_JUMBO:\r\n-            return 3;\r\n-        case OP_CONST_CLASS:\r\n-            return 2;\r\n-        case OP_MONITOR_ENTER:\r\n-            return 1;\r\n-        case OP_MONITOR_EXIT:\r\n-            return 1;\r\n-        case OP_CHECK_CAST:\r\n-            return 2;\r\n-        case OP_INSTANCE_OF:\r\n-            return 2;\r\n-        case OP_ARRAY_LENGTH:\r\n-            return 1;\r\n-        case OP_NEW_INSTANCE:\r\n-            return 2;\r\n-        case OP_NEW_ARRAY:\r\n-            return 2;\r\n-        case OP_FILLED_NEW_ARRAY:\r\n-            return 3;\r\n-        case OP_FILLED_NEW_ARRAY_RANGE:\r\n-            return 3;\r\n+            return F31i;\r\n         case OP_FILL_ARRAY_DATA:\r\n-            return 3;\r\n-        case OP_THROW:\r\n-            return 1;\r\n-        case OP_GOTO:\r\n-            return 1;\r\n-        case OP_GOTO_16:\r\n-            return 2;\r\n-        case OP_GOTO_32:\r\n-            return 3;\r\n         case OP_PACKED_SWITCH:\r\n-            return 3;\r\n         case OP_SPARSE_SWITCH:\r\n-            return 3;\r\n-        case OP_CMPL_FLOAT:\r\n-            return 2;\r\n-        case OP_CMPG_FLOAT:\r\n-            return 2;\r\n-        case OP_CMPL_DOUBLE:\r\n-            return 2;\r\n-        case OP_CMPG_DOUBLE:\r\n-            return 2;\r\n-        case OP_CMP_LONG:\r\n-            return 2;\r\n-        case OP_IF_EQ:\r\n-            return 2;\r\n-        case OP_IF_NE:\r\n-            return 2;\r\n-        case OP_IF_LT:\r\n-            return 2;\r\n-        case OP_IF_GE:\r\n-            return 2;\r\n-        case OP_IF_GT:\r\n-            return 2;\r\n-        case OP_IF_LE:\r\n-            return 2;\r\n-        case OP_IF_EQZ:\r\n-            return 2;\r\n-        case OP_IF_NEZ:\r\n-            return 2;\r\n-        case OP_IF_LTZ:\r\n-            return 2;\r\n-        case OP_IF_GEZ:\r\n-            return 2;\r\n-        case OP_IF_GTZ:\r\n-            return 2;\r\n-        case OP_IF_LEZ:\r\n-            return 2;\r\n-        case OP_AGET:\r\n-            return 2;\r\n-        case OP_AGET_WIDE:\r\n-            return 2;\r\n-        case OP_AGET_OBJECT:\r\n-            return 2;\r\n-        case OP_AGET_BOOLEAN:\r\n-            return 2;\r\n-        case OP_AGET_BYTE:\r\n-            return 2;\r\n-        case OP_AGET_CHAR:\r\n-            return 2;\r\n-        case OP_AGET_SHORT:\r\n-            return 2;\r\n-        case OP_APUT:\r\n-            return 2;\r\n-        case OP_APUT_WIDE:\r\n-            return 2;\r\n-        case OP_APUT_OBJECT:\r\n-            return 2;\r\n-        case OP_APUT_BOOLEAN:\r\n-            return 2;\r\n-        case OP_APUT_BYTE:\r\n-            return 2;\r\n-        case OP_APUT_CHAR:\r\n-            return 2;\r\n-        case OP_APUT_SHORT:\r\n-            return 2;\r\n-        case OP_IGET:\r\n-            return 2;\r\n-        case OP_IGET_WIDE:\r\n-            return 2;\r\n-        case OP_IGET_OBJECT:\r\n-            return 2;\r\n-        case OP_IGET_BOOLEAN:\r\n-            return 2;\r\n-        case OP_IGET_BYTE:\r\n-            return 2;\r\n-        case OP_IGET_CHAR:\r\n-            return 2;\r\n-        case OP_IGET_SHORT:\r\n-            return 2;\r\n-        case OP_IPUT:\r\n-            return 2;\r\n-        case OP_IPUT_WIDE:\r\n-            return 2;\r\n-        case OP_IPUT_OBJECT:\r\n-            return 2;\r\n-        case OP_IPUT_BOOLEAN:\r\n-            return 2;\r\n-        case OP_IPUT_BYTE:\r\n-            return 2;\r\n-        case OP_IPUT_CHAR:\r\n-            return 2;\r\n-        case OP_IPUT_SHORT:\r\n-            return 2;\r\n-        case OP_SGET:\r\n-            return 2;\r\n-        case OP_SGET_WIDE:\r\n-            return 2;\r\n-        case OP_SGET_OBJECT:\r\n-            return 2;\r\n-        case OP_SGET_BOOLEAN:\r\n-            return 2;\r\n-        case OP_SGET_BYTE:\r\n-            return 2;\r\n-        case OP_SGET_CHAR:\r\n-            return 2;\r\n-        case OP_SGET_SHORT:\r\n-            return 2;\r\n-        case OP_SPUT:\r\n-            return 2;\r\n-        case OP_SPUT_WIDE:\r\n-            return 2;\r\n-        case OP_SPUT_OBJECT:\r\n-            return 2;\r\n-        case OP_SPUT_BOOLEAN:\r\n-            return 2;\r\n-        case OP_SPUT_BYTE:\r\n-            return 2;\r\n-        case OP_SPUT_CHAR:\r\n-            return 2;\r\n-        case OP_SPUT_SHORT:\r\n-            return 2;\r\n+            return F31t;\r\n+        case OP_MOVE_16:\r\n+        case OP_MOVE_WIDE_16:\r\n+        case OP_MOVE_OBJECT_16:\r\n+            return F32x;\r\n+        case OP_FILLED_NEW_ARRAY:\r\n         case OP_INVOKE_VIRTUAL:\r\n-            return 3;\r\n         case OP_INVOKE_SUPER:\r\n-            return 3;\r\n         case OP_INVOKE_DIRECT:\r\n-            return 3;\r\n         case OP_INVOKE_STATIC:\r\n-            return 3;\r\n         case OP_INVOKE_INTERFACE:\r\n-            return 3;\r\n+            return F35c;\r\n+        case OP_FILLED_NEW_ARRAY_RANGE:\r\n         case OP_INVOKE_VIRTUAL_RANGE:\r\n-            return 3;\r\n         case OP_INVOKE_SUPER_RANGE:\r\n-            return 3;\r\n         case OP_INVOKE_DIRECT_RANGE:\r\n-            return 3;\r\n         case OP_INVOKE_STATIC_RANGE:\r\n-            return 3;\r\n         case OP_INVOKE_INTERFACE_RANGE:\r\n+            return F3rc;\r\n+        case OP_CONST_WIDE:\r\n+            return F51l;\r\n+        }\r\n+        throw new RuntimeException(\"opcode length for \" + opcode + \" not found!\");\r\n+    }\r\n+\r\n+    public static int length(int opcode) {\r\n+        switch (opcode) {\r\n+        // case OP: //length\r\n+        case OP_NOP: // 1\r\n+        case OP_MOVE: // 1\r\n+        case OP_MOVE_WIDE: // 1\r\n+        case OP_MOVE_OBJECT: // 1\r\n+        case OP_MOVE_RESULT: // 1\r\n+        case OP_MOVE_RESULT_WIDE: // 1\r\n+        case OP_MOVE_RESULT_OBJECT: // 1\r\n+        case OP_MOVE_EXCEPTION: // 1\r\n+        case OP_RETURN_VOID: // 1\r\n+        case OP_RETURN: // 1\r\n+        case OP_RETURN_WIDE: // 1\r\n+        case OP_RETURN_OBJECT: // 1\r\n+        case OP_CONST_4: // 1\r\n+        case OP_MONITOR_ENTER: // 1\r\n+        case OP_MONITOR_EXIT: // 1\r\n+        case OP_ARRAY_LENGTH: // 1\r\n+        case OP_THROW: // 1\r\n+        case OP_GOTO: // 1\r\n+        case OP_NEG_INT: // 1\r\n+        case OP_NOT_INT: // 1\r\n+        case OP_NEG_LONG: // 1\r\n+        case OP_NOT_LONG: // 1\r\n+        case OP_NEG_FLOAT: // 1\r\n+        case OP_NEG_DOUBLE: // 1\r\n+        case OP_INT_TO_LONG: // 1\r\n+        case OP_INT_TO_FLOAT: // 1\r\n+        case OP_INT_TO_DOUBLE: // 1\r\n+        case OP_LONG_TO_INT: // 1\r\n+        case OP_LONG_TO_FLOAT: // 1\r\n+        case OP_LONG_TO_DOUBLE: // 1\r\n+        case OP_FLOAT_TO_INT: // 1\r\n+        case OP_FLOAT_TO_LONG: // 1\r\n+        case OP_FLOAT_TO_DOUBLE: // 1\r\n+        case OP_DOUBLE_TO_INT: // 1\r\n+        case OP_DOUBLE_TO_LONG: // 1\r\n+        case OP_DOUBLE_TO_FLOAT: // 1\r\n+        case OP_INT_TO_BYTE: // 1\r\n+        case OP_INT_TO_CHAR: // 1\r\n+        case OP_INT_TO_SHORT: // 1\r\n+        case OP_ADD_INT_2ADDR: // 1\r\n+        case OP_SUB_INT_2ADDR: // 1\r\n+        case OP_MUL_INT_2ADDR: // 1\r\n+        case OP_DIV_INT_2ADDR: // 1\r\n+        case OP_REM_INT_2ADDR: // 1\r\n+        case OP_AND_INT_2ADDR: // 1\r\n+        case OP_OR_INT_2ADDR: // 1\r\n+        case OP_XOR_INT_2ADDR: // 1\r\n+        case OP_SHL_INT_2ADDR: // 1\r\n+        case OP_SHR_INT_2ADDR: // 1\r\n+        case OP_USHR_INT_2ADDR: // 1\r\n+        case OP_ADD_LONG_2ADDR: // 1\r\n+        case OP_SUB_LONG_2ADDR: // 1\r\n+        case OP_MUL_LONG_2ADDR: // 1\r\n+        case OP_DIV_LONG_2ADDR: // 1\r\n+        case OP_REM_LONG_2ADDR: // 1\r\n+        case OP_AND_LONG_2ADDR: // 1\r\n+        case OP_OR_LONG_2ADDR: // 1\r\n+        case OP_XOR_LONG_2ADDR: // 1\r\n+        case OP_SHL_LONG_2ADDR: // 1\r\n+        case OP_SHR_LONG_2ADDR: // 1\r\n+        case OP_USHR_LONG_2ADDR: // 1\r\n+        case OP_ADD_FLOAT_2ADDR: // 1\r\n+        case OP_SUB_FLOAT_2ADDR: // 1\r\n+        case OP_MUL_FLOAT_2ADDR: // 1\r\n+        case OP_DIV_FLOAT_2ADDR: // 1\r\n+        case OP_REM_FLOAT_2ADDR: // 1\r\n+        case OP_ADD_DOUBLE_2ADDR: // 1\r\n+        case OP_SUB_DOUBLE_2ADDR: // 1\r\n+        case OP_MUL_DOUBLE_2ADDR: // 1\r\n+        case OP_DIV_DOUBLE_2ADDR: // 1\r\n+        case OP_REM_DOUBLE_2ADDR: // 1\r\n+            return 1;\r\n+        case OP_MOVE_FROM16: // 2\r\n+        case OP_MOVE_WIDE_FROM16: // 2\r\n+        case OP_MOVE_OBJECT_FROM16: // 2\r\n+        case OP_CONST_16: // 2\r\n+        case OP_CONST_HIGH16: // 2\r\n+        case OP_CONST_WIDE_16: // 2\r\n+        case OP_CONST_WIDE_HIGH16: // 2\r\n+        case OP_CONST_STRING: // 2\r\n+        case OP_CONST_CLASS: // 2\r\n+        case OP_CHECK_CAST: // 2\r\n+        case OP_INSTANCE_OF: // 2\r\n+        case OP_NEW_INSTANCE: // 2\r\n+        case OP_NEW_ARRAY: // 2\r\n+        case OP_GOTO_16: // 2\r\n+        case OP_CMPL_FLOAT: // 2\r\n+        case OP_CMPG_FLOAT: // 2\r\n+        case OP_CMPL_DOUBLE: // 2\r\n+        case OP_CMPG_DOUBLE: // 2\r\n+        case OP_CMP_LONG: // 2\r\n+        case OP_IF_EQ: // 2\r\n+        case OP_IF_NE: // 2\r\n+        case OP_IF_LT: // 2\r\n+        case OP_IF_GE: // 2\r\n+        case OP_IF_GT: // 2\r\n+        case OP_IF_LE: // 2\r\n+        case OP_IF_EQZ: // 2\r\n+        case OP_IF_NEZ: // 2\r\n+        case OP_IF_LTZ: // 2\r\n+        case OP_IF_GEZ: // 2\r\n+        case OP_IF_GTZ: // 2\r\n+        case OP_IF_LEZ: // 2\r\n+        case OP_AGET: // 2\r\n+        case OP_AGET_WIDE: // 2\r\n+        case OP_AGET_OBJECT: // 2\r\n+        case OP_AGET_BOOLEAN: // 2\r\n+        case OP_AGET_BYTE: // 2\r\n+        case OP_AGET_CHAR: // 2\r\n+        case OP_AGET_SHORT: // 2\r\n+        case OP_APUT: // 2\r\n+        case OP_APUT_WIDE: // 2\r\n+        case OP_APUT_OBJECT: // 2\r\n+        case OP_APUT_BOOLEAN: // 2\r\n+        case OP_APUT_BYTE: // 2\r\n+        case OP_APUT_CHAR: // 2\r\n+        case OP_APUT_SHORT: // 2\r\n+        case OP_IGET: // 2\r\n+        case OP_IGET_WIDE: // 2\r\n+        case OP_IGET_OBJECT: // 2\r\n+        case OP_IGET_BOOLEAN: // 2\r\n+        case OP_IGET_BYTE: // 2\r\n+        case OP_IGET_CHAR: // 2\r\n+        case OP_IGET_SHORT: // 2\r\n+        case OP_IPUT: // 2\r\n+        case OP_IPUT_WIDE: // 2\r\n+        case OP_IPUT_OBJECT: // 2\r\n+        case OP_IPUT_BOOLEAN: // 2\r\n+        case OP_IPUT_BYTE: // 2\r\n+        case OP_IPUT_CHAR: // 2\r\n+        case OP_IPUT_SHORT: // 2\r\n+        case OP_SGET: // 2\r\n+        case OP_SGET_WIDE: // 2\r\n+        case OP_SGET_OBJECT: // 2\r\n+        case OP_SGET_BOOLEAN: // 2\r\n+        case OP_SGET_BYTE: // 2\r\n+        case OP_SGET_CHAR: // 2\r\n+        case OP_SGET_SHORT: // 2\r\n+        case OP_SPUT: // 2\r\n+        case OP_SPUT_WIDE: // 2\r\n+        case OP_SPUT_OBJECT: // 2\r\n+        case OP_SPUT_BOOLEAN: // 2\r\n+        case OP_SPUT_BYTE: // 2\r\n+        case OP_SPUT_CHAR: // 2\r\n+        case OP_SPUT_SHORT: // 2\r\n+        case OP_ADD_INT: // 2\r\n+        case OP_SUB_INT: // 2\r\n+        case OP_MUL_INT: // 2\r\n+        case OP_DIV_INT: // 2\r\n+        case OP_REM_INT: // 2\r\n+        case OP_AND_INT: // 2\r\n+        case OP_OR_INT: // 2\r\n+        case OP_XOR_INT: // 2\r\n+        case OP_SHL_INT: // 2\r\n+        case OP_SHR_INT: // 2\r\n+        case OP_USHR_INT: // 2\r\n+        case OP_ADD_LONG: // 2\r\n+        case OP_SUB_LONG: // 2\r\n+        case OP_MUL_LONG: // 2\r\n+        case OP_DIV_LONG: // 2\r\n+        case OP_REM_LONG: // 2\r\n+        case OP_AND_LONG: // 2\r\n+        case OP_OR_LONG: // 2\r\n+        case OP_XOR_LONG: // 2\r\n+        case OP_SHL_LONG: // 2\r\n+        case OP_SHR_LONG: // 2\r\n+        case OP_USHR_LONG: // 2\r\n+        case OP_ADD_FLOAT: // 2\r\n+        case OP_SUB_FLOAT: // 2\r\n+        case OP_MUL_FLOAT: // 2\r\n+        case OP_DIV_FLOAT: // 2\r\n+        case OP_REM_FLOAT: // 2\r\n+        case OP_ADD_DOUBLE: // 2\r\n+        case OP_SUB_DOUBLE: // 2\r\n+        case OP_MUL_DOUBLE: // 2\r\n+        case OP_DIV_DOUBLE: // 2\r\n+        case OP_REM_DOUBLE: // 2\r\n+        case OP_ADD_INT_LIT16: // 2\r\n+        case OP_RSUB_INT: // 2\r\n+        case OP_MUL_INT_LIT16: // 2\r\n+        case OP_DIV_INT_LIT16: // 2\r\n+        case OP_REM_INT_LIT16: // 2\r\n+        case OP_AND_INT_LIT16: // 2\r\n+        case OP_OR_INT_LIT16: // 2\r\n+        case OP_XOR_INT_LIT16: // 2\r\n+        case OP_ADD_INT_LIT8: // 2\r\n+        case OP_RSUB_INT_LIT8: // 2\r\n+        case OP_MUL_INT_LIT8: // 2\r\n+        case OP_DIV_INT_LIT8: // 2\r\n+        case OP_REM_INT_LIT8: // 2\r\n+        case OP_AND_INT_LIT8: // 2\r\n+        case OP_OR_INT_LIT8: // 2\r\n+        case OP_XOR_INT_LIT8: // 2\r\n+        case OP_SHL_INT_LIT8: // 2\r\n+        case OP_SHR_INT_LIT8: // 2\r\n+        case OP_USHR_INT_LIT8: // 2\r\n+            return 2;\r\n+        case OP_MOVE_16: // 3\r\n+        case OP_MOVE_WIDE_16: // 3\r\n+        case OP_MOVE_OBJECT_16: // 3\r\n+        case OP_CONST: // 3\r\n+        case OP_CONST_WIDE_32: // 3\r\n+        case OP_CONST_STRING_JUMBO: // 3\r\n+        case OP_FILLED_NEW_ARRAY: // 3\r\n+        case OP_FILLED_NEW_ARRAY_RANGE: // 3\r\n+        case OP_FILL_ARRAY_DATA: // 3\r\n+        case OP_GOTO_32: // 3\r\n+        case OP_PACKED_SWITCH: // 3\r\n+        case OP_SPARSE_SWITCH: // 3\r\n+        case OP_INVOKE_VIRTUAL: // 3\r\n+        case OP_INVOKE_SUPER: // 3\r\n+        case OP_INVOKE_DIRECT: // 3\r\n+        case OP_INVOKE_STATIC: // 3\r\n+        case OP_INVOKE_INTERFACE: // 3\r\n+        case OP_INVOKE_VIRTUAL_RANGE: // 3\r\n+        case OP_INVOKE_SUPER_RANGE: // 3\r\n+        case OP_INVOKE_DIRECT_RANGE: // 3\r\n+        case OP_INVOKE_STATIC_RANGE: // 3\r\n+        case OP_INVOKE_INTERFACE_RANGE: // 3\r\n             return 3;\r\n-        case OP_NEG_INT:\r\n-            return 1;\r\n-        case OP_NOT_INT:\r\n-            return 1;\r\n-        case OP_NEG_LONG:\r\n-            return 1;\r\n-        case OP_NOT_LONG:\r\n-            return 1;\r\n-        case OP_NEG_FLOAT:\r\n-            return 1;\r\n-        case OP_NEG_DOUBLE:\r\n-            return 1;\r\n-        case OP_INT_TO_LONG:\r\n-            return 1;\r\n-        case OP_INT_TO_FLOAT:\r\n-            return 1;\r\n-        case OP_INT_TO_DOUBLE:\r\n-            return 1;\r\n-        case OP_LONG_TO_INT:\r\n-            return 1;\r\n-        case OP_LONG_TO_FLOAT:\r\n-            return 1;\r\n-        case OP_LONG_TO_DOUBLE:\r\n-            return 1;\r\n-        case OP_FLOAT_TO_INT:\r\n-            return 1;\r\n-        case OP_FLOAT_TO_LONG:\r\n-            return 1;\r\n-        case OP_FLOAT_TO_DOUBLE:\r\n-            return 1;\r\n-        case OP_DOUBLE_TO_INT:\r\n-            return 1;\r\n-        case OP_DOUBLE_TO_LONG:\r\n-            return 1;\r\n-        case OP_DOUBLE_TO_FLOAT:\r\n-            return 1;\r\n-        case OP_INT_TO_BYTE:\r\n-            return 1;\r\n-        case OP_INT_TO_CHAR:\r\n-            return 1;\r\n-        case OP_INT_TO_SHORT:\r\n-            return 1;\r\n-        case OP_ADD_INT:\r\n-            return 2;\r\n-        case OP_SUB_INT:\r\n-            return 2;\r\n-        case OP_MUL_INT:\r\n-            return 2;\r\n-        case OP_DIV_INT:\r\n-            return 2;\r\n-        case OP_REM_INT:\r\n-            return 2;\r\n-        case OP_AND_INT:\r\n-            return 2;\r\n-        case OP_OR_INT:\r\n-            return 2;\r\n-        case OP_XOR_INT:\r\n-            return 2;\r\n-        case OP_SHL_INT:\r\n-            return 2;\r\n-        case OP_SHR_INT:\r\n-            return 2;\r\n-        case OP_USHR_INT:\r\n-            return 2;\r\n-        case OP_ADD_LONG:\r\n-            return 2;\r\n-        case OP_SUB_LONG:\r\n-            return 2;\r\n-        case OP_MUL_LONG:\r\n-            return 2;\r\n-        case OP_DIV_LONG:\r\n-            return 2;\r\n-        case OP_REM_LONG:\r\n-            return 2;\r\n-        case OP_AND_LONG:\r\n-            return 2;\r\n-        case OP_OR_LONG:\r\n-            return 2;\r\n-        case OP_XOR_LONG:\r\n-            return 2;\r\n-        case OP_SHL_LONG:\r\n-            return 2;\r\n-        case OP_SHR_LONG:\r\n-            return 2;\r\n-        case OP_USHR_LONG:\r\n-            return 2;\r\n-        case OP_ADD_FLOAT:\r\n-            return 2;\r\n-        case OP_SUB_FLOAT:\r\n-            return 2;\r\n-        case OP_MUL_FLOAT:\r\n-            return 2;\r\n-        case OP_DIV_FLOAT:\r\n-            return 2;\r\n-        case OP_REM_FLOAT:\r\n-            return 2;\r\n-        case OP_ADD_DOUBLE:\r\n-            return 2;\r\n-        case OP_SUB_DOUBLE:\r\n-            return 2;\r\n-        case OP_MUL_DOUBLE:\r\n-            return 2;\r\n-        case OP_DIV_DOUBLE:\r\n-            return 2;\r\n-        case OP_REM_DOUBLE:\r\n-            return 2;\r\n-        case OP_ADD_INT_2ADDR:\r\n-            return 1;\r\n-        case OP_SUB_INT_2ADDR:\r\n-            return 1;\r\n-        case OP_MUL_INT_2ADDR:\r\n-            return 1;\r\n-        case OP_DIV_INT_2ADDR:\r\n-            return 1;\r\n-        case OP_REM_INT_2ADDR:\r\n-            return 1;\r\n-        case OP_AND_INT_2ADDR:\r\n-            return 1;\r\n-        case OP_OR_INT_2ADDR:\r\n-            return 1;\r\n-        case OP_XOR_INT_2ADDR:\r\n-            return 1;\r\n-        case OP_SHL_INT_2ADDR:\r\n-            return 1;\r\n-        case OP_SHR_INT_2ADDR:\r\n-            return 1;\r\n-        case OP_USHR_INT_2ADDR:\r\n-            return 1;\r\n-        case OP_ADD_LONG_2ADDR:\r\n-            return 1;\r\n-        case OP_SUB_LONG_2ADDR:\r\n-            return 1;\r\n-        case OP_MUL_LONG_2ADDR:\r\n-            return 1;\r\n-        case OP_DIV_LONG_2ADDR:\r\n-            return 1;\r\n-        case OP_REM_LONG_2ADDR:\r\n-            return 1;\r\n-        case OP_AND_LONG_2ADDR:\r\n-            return 1;\r\n-        case OP_OR_LONG_2ADDR:\r\n-            return 1;\r\n-        case OP_XOR_LONG_2ADDR:\r\n-            return 1;\r\n-        case OP_SHL_LONG_2ADDR:\r\n-            return 1;\r\n-        case OP_SHR_LONG_2ADDR:\r\n-            return 1;\r\n-        case OP_USHR_LONG_2ADDR:\r\n-            return 1;\r\n-        case OP_ADD_FLOAT_2ADDR:\r\n-            return 1;\r\n-        case OP_SUB_FLOAT_2ADDR:\r\n-            return 1;\r\n-        case OP_MUL_FLOAT_2ADDR:\r\n-            return 1;\r\n-        case OP_DIV_FLOAT_2ADDR:\r\n-            return 1;\r\n-        case OP_REM_FLOAT_2ADDR:\r\n-            return 1;\r\n-        case OP_ADD_DOUBLE_2ADDR:\r\n-            return 1;\r\n-        case OP_SUB_DOUBLE_2ADDR:\r\n-            return 1;\r\n-        case OP_MUL_DOUBLE_2ADDR:\r\n-            return 1;\r\n-        case OP_DIV_DOUBLE_2ADDR:\r\n-            return 1;\r\n-        case OP_REM_DOUBLE_2ADDR:\r\n-            return 1;\r\n-        case OP_ADD_INT_LIT16:\r\n-            return 2;\r\n-        case OP_RSUB_INT:\r\n-            return 2;\r\n-        case OP_MUL_INT_LIT16:\r\n-            return 2;\r\n-        case OP_DIV_INT_LIT16:\r\n-            return 2;\r\n-        case OP_REM_INT_LIT16:\r\n-            return 2;\r\n-        case OP_AND_INT_LIT16:\r\n-            return 2;\r\n-        case OP_OR_INT_LIT16:\r\n-            return 2;\r\n-        case OP_XOR_INT_LIT16:\r\n-            return 2;\r\n-        case OP_ADD_INT_LIT8:\r\n-            return 2;\r\n-        case OP_RSUB_INT_LIT8:\r\n-            return 2;\r\n-        case OP_MUL_INT_LIT8:\r\n-            return 2;\r\n-        case OP_DIV_INT_LIT8:\r\n-            return 2;\r\n-        case OP_REM_INT_LIT8:\r\n-            return 2;\r\n-        case OP_AND_INT_LIT8:\r\n-            return 2;\r\n-        case OP_OR_INT_LIT8:\r\n-            return 2;\r\n-        case OP_XOR_INT_LIT8:\r\n-            return 2;\r\n-        case OP_SHL_INT_LIT8:\r\n-            return 2;\r\n-        case OP_SHR_INT_LIT8:\r\n-            return 2;\r\n-        case OP_USHR_INT_LIT8:\r\n-            return 2;\r\n+        case OP_CONST_WIDE: // 5\r\n+            return 5;\r\n         }\r\n         throw new RuntimeException(\"opcode length for 0x\" + Integer.toHexString(opcode) + DexOpcodeDump.dump(opcode)\r\n                 + \" not found!\");\r",
      "parent_sha": "28f22e14e55722e89a984a217af4ea2b5a661e50"
    }
  },
  {
    "oid": "f2336482d1f02bdbbd8de4d47160a4e5d3696b0b",
    "message": "add option IGNORE_READ_EXCEPTION\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2013-08-02T07:44:07Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/f2336482d1f02bdbbd8de4d47160a4e5d3696b0b",
    "details": {
      "sha": "d26ec1a526452044443dc7045ce871a78af35ddc",
      "filename": "dex-reader/src/main/java/com/googlecode/dex2jar/reader/DexFileReader.java",
      "status": "modified",
      "additions": 30,
      "deletions": 2,
      "changes": 32,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/f2336482d1f02bdbbd8de4d47160a4e5d3696b0b/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexFileReader.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/f2336482d1f02bdbbd8de4d47160a4e5d3696b0b/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexFileReader.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexFileReader.java?ref=f2336482d1f02bdbbd8de4d47160a4e5d3696b0b",
      "patch": "@@ -98,7 +98,10 @@ public class DexFileReader {\n      * skip field constant in dex file.\r\n      */\r\n     public static final int SKIP_FIELD_CONSTANT = 1 << 4;\r\n-\r\n+    /**\r\n+    * ingore read exception\r\n+    */\r\n+    public static final int IGNORE_READ_EXCEPTION = 1 << 5;\r\n     private final boolean odex;\r\n     private DataIn odex_in;\r\n     private int odex_depsOffset;\r\n@@ -322,13 +325,38 @@ public void accept(DexFileVisitor dv, int config) {\n                 {\r\n                     acceptClass(dv, dcv, className, config);\r\n                 }\r\n+            } catch (Exception ex) {\r\n+                DexException dexException = new DexException(ex, \"Error process class: [%d]%s\", cid, className);\r\n+                if (0 != (config & IGNORE_READ_EXCEPTION)) {\r\n+                    niceExceptionMessage(dexException, 0);\r\n+                } else {\r\n+                    throw dexException;\r\n+                }\r\n             } finally {\r\n                 in.pop();\r\n             }\r\n         }\r\n         dv.visitEnd();\r\n     }\r\n-\r\n+    static void niceExceptionMessage(Throwable t, int deep) {\r\n+        StringBuilder sb = new StringBuilder();\r\n+        for (int i = 0; i < deep + 1; i++) {\r\n+            sb.append(\".\");\r\n+        }\r\n+        sb.append(' ');\r\n+        if (t instanceof DexException) {\r\n+            sb.append(t.getMessage());\r\n+            System.err.println(sb.toString());\r\n+            if (t.getCause() != null) {\r\n+                niceExceptionMessage(t.getCause(), deep + 1);\r\n+            }\r\n+        } else {\r\n+            if (t != null) {\r\n+                System.err.println(sb.append(\"ROOT cause:\").toString());\r\n+                t.printStackTrace(System.err);\r\n+            }\r\n+        }\r\n+    }\r\n     private void acceptClass(DexFileVisitor dv, DexClassVisitor dcv, String className, int config) {\r\n         DataIn in = this.in;\r\n         int source_file_idx = in.readUIntx();\r",
      "parent_sha": "7a0fd419a2b453e7f97bc3dd1f6037af813f8682"
    }
  },
  {
    "oid": "bacac414402bf221f38bfeca19a31178d25eb35d",
    "message": "reduce the size of array return by live analyze\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2011-12-31T07:58:17Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/bacac414402bf221f38bfeca19a31178d25eb35d",
    "details": {
      "sha": "03161bc861de64ae7725027ad9ec12114bdca7a4",
      "filename": "dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/LiveAnalyze.java",
      "status": "modified",
      "additions": 5,
      "deletions": 2,
      "changes": 7,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/bacac414402bf221f38bfeca19a31178d25eb35d/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FLiveAnalyze.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/bacac414402bf221f38bfeca19a31178d25eb35d/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FLiveAnalyze.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FLiveAnalyze.java?ref=bacac414402bf221f38bfeca19a31178d25eb35d",
      "patch": "@@ -240,13 +240,16 @@ private void use(ValueBox op, Phi[] frame) {\n         }\r\n         used.clear();\r\n \r\n-        Collections.sort(phis, new Comparator<Phi>() {\r\n+        // reduce the size of nPhis\r\n+        List<Phi> nPhis = new ArrayList<Phi>(phis);\r\n+\r\n+        Collections.sort(nPhis, new Comparator<Phi>() {\r\n             @Override\r\n             public int compare(Phi o1, Phi o2) {\r\n                 return o1.local._ls_index - o2.local._ls_index;\r\n             }\r\n         });\r\n-        return phis;\r\n+        return nPhis;\r\n     }\r\n \r\n     protected void init() {\r",
      "parent_sha": "0c435060cc048cfc82036dbcc96e41382d6f2d31"
    }
  },
  {
    "oid": "65db63854b0a9a9a8259ec933937d2f5f72417d8",
    "message": "1.\u4e0d\u628aOP_ADD_INT_LIT8\u8f6c\u6362\u6210IINC\u6307\u4ee4\n\nUpdate issue 23\n\u5df2\u77e5\u51fa\u73b0\u8be5\u95ee\u9898\u7684\u539f\u56e0\u6709\u4e24\u4e2a\n1.OP_ADD_INT_LIT8\u6307\u4ee4\u4f1a\u88ab\u4f18\u5316\u6210IINC\u6307\u4ee4,\u5e76\u5728\u5206\u5757\u7684\u65f6\u5019\u672a\u88ab\u6b63\u786e\u5904\u7406\n2.class\u6587\u4ef6\u4e2dlong(J)/double(D)\u7c7b\u578b\u5360\u7528\u4e24\u4e2a\u957f\u5ea6\u7684Local\u53d8\u91cf\n\n\u73b0\u57281\u5df2\u7ecf\u89e3\u51b3\n\n--HG--\nbranch : 0.0.7",
    "date": "2010-08-21T09:45:23Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/65db63854b0a9a9a8259ec933937d2f5f72417d8",
    "details": {
      "sha": "e97abab58558ca3e404c72f7c03f1235dffc0d5e",
      "filename": "src/main/java/pxb/android/dex2jar/v3/V3CodeAdapter.java",
      "status": "modified",
      "additions": 5,
      "deletions": 12,
      "changes": 17,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/65db63854b0a9a9a8259ec933937d2f5f72417d8/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Fv3%2FV3CodeAdapter.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/65db63854b0a9a9a8259ec933937d2f5f72417d8/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Fv3%2FV3CodeAdapter.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Fv3%2FV3CodeAdapter.java?ref=65db63854b0a9a9a8259ec933937d2f5f72417d8",
      "patch": "@@ -682,18 +682,11 @@ public void visitInInsn(int opcode, int saveToReg, int opReg, int opValueOrReg)\n \t\tcase OP_XOR_INT_LIT8:\r\n \t\tcase OP_DIV_INT_LIT8:\r\n \t\tcase OP_MUL_INT_LIT8: {\r\n-\t\t\tif (OP_ADD_INT_LIT8 == opcode && opReg == saveToReg) {\r\n-\t\t\t\t// \u9488\u5bf9 a=a+1\r\n-\t\t\t\tmv.visitIincInsn(map(opReg), opValueOrReg);\r\n-\t\t\t\tstack(0);\r\n-\t\t\t}\r\n-\t\t\telse {\r\n-\t\t\t\tmv.visitVarInsn(ILOAD, map(opReg));\r\n-\t\t\t\tmv.visitLdcInsn(opValueOrReg);\r\n-\t\t\t\tmv.visitInsn(DexOpcodeUtil.mapOpcode(opcode));\r\n-\t\t\t\tmv.visitVarInsn(ISTORE, map(saveToReg));\r\n-\t\t\t\tstack(2);\r\n-\t\t\t}\r\n+\t\t\tmv.visitVarInsn(ILOAD, map(opReg));\r\n+\t\t\tmv.visitLdcInsn(opValueOrReg);\r\n+\t\t\tmv.visitInsn(DexOpcodeUtil.mapOpcode(opcode));\r\n+\t\t\tmv.visitVarInsn(ISTORE, map(saveToReg));\r\n+\t\t\tstack(2);\r\n \t\t}\r\n \t\t\tbreak;\r\n \r",
      "parent_sha": "39ae422f4bdf32bb3caac6c42d95061c0a02264e"
    }
  },
  {
    "oid": "23b07bf4dbf136736e92be97cc664f3e321a66e4",
    "message": "fix error on extract apk\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2013-03-26T06:16:07Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/23b07bf4dbf136736e92be97cc664f3e321a66e4",
    "details": {
      "sha": "2c8a2e7915ef6a9dc8c32307252012bed26fbecc",
      "filename": "dex-reader/src/main/java/com/googlecode/dex2jar/reader/DexFileReader.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/23b07bf4dbf136736e92be97cc664f3e321a66e4/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexFileReader.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/23b07bf4dbf136736e92be97cc664f3e321a66e4/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexFileReader.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexFileReader.java?ref=23b07bf4dbf136736e92be97cc664f3e321a66e4",
      "patch": "@@ -126,7 +126,7 @@ public static byte[] readDex(byte[] data) throws IOException {\n             } catch (ClassNotFoundException e) {\r\n                 ze = new ZipExtractor();\r\n             }\r\n-            ze.extract(data, \"classes.dex\");\r\n+            return ze.extract(data, \"classes.dex\");\r\n         }\r\n         throw new RuntimeException(\"the src file not a .dex, .odex or zip file\");\r\n     }\r",
      "parent_sha": "f7ff615a8faf2134904175ab69ed2992506b44f3"
    }
  },
  {
    "oid": "133235a7cd2e34d8ce4dfaf58411377844be7220",
    "message": "add -da,--deep-analyze use dex2jar IR to static analyze more const arguments\nsupport primitive array type like 'byte[]'\nsupport decrypt jeb-like 'String m(byte[], int, int)' method\n\n--HG--\nbranch : 2.x",
    "date": "2015-02-21T14:41:07Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/133235a7cd2e34d8ce4dfaf58411377844be7220",
    "details": {
      "sha": "7ce588de44af543e5fba35d3e4aad476ef80ff09",
      "filename": "dex-tools/src/main/java/com/googlecode/dex2jar/tools/DecryptStringCmd.java",
      "status": "modified",
      "additions": 547,
      "deletions": 110,
      "changes": 657,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/133235a7cd2e34d8ce4dfaf58411377844be7220/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FDecryptStringCmd.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/133235a7cd2e34d8ce4dfaf58411377844be7220/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FDecryptStringCmd.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FDecryptStringCmd.java?ref=133235a7cd2e34d8ce4dfaf58411377844be7220",
      "patch": "@@ -16,6 +16,14 @@\n  */\n package com.googlecode.dex2jar.tools;\n \n+import com.googlecode.d2j.converter.IR2JConverter;\n+import com.googlecode.d2j.converter.J2IRConverter;\n+import com.googlecode.d2j.util.Escape;\n+import com.googlecode.dex2jar.ir.IrMethod;\n+import com.googlecode.dex2jar.ir.StmtTraveler;\n+import com.googlecode.dex2jar.ir.expr.*;\n+import com.googlecode.dex2jar.ir.ts.*;\n+import com.googlecode.dex2jar.ir.ts.array.FillArrayTransformer;\n import com.googlecode.dex2jar.tools.BaseCmd.Syntax;\n import org.objectweb.asm.ClassReader;\n import org.objectweb.asm.ClassWriter;\n@@ -25,6 +33,7 @@\n \n import java.io.File;\n import java.io.IOException;\n+import java.lang.reflect.Array;\n import java.lang.reflect.Method;\n import java.net.URL;\n import java.net.URLClassLoader;\n@@ -59,6 +68,8 @@ public static void main(String... args) {\n     private String parametersDescriptor;\n     @Opt(opt = \"d\", longOpt = \"delete\", hasArg = false, description = \"delete the method which can decrypt the stings\")\n     private boolean deleteMethod = false;\n+    @Opt(opt = \"da\", longOpt = \"deep-analyze\", hasArg = false, description = \"use dex2jar IR to static analyze and find more values like byte[]\")\n+    private boolean deepAnalyze = false;\n \n     static class MethodConfig {\n         Method jmethod;\n@@ -169,8 +180,8 @@ protected void doCommandLine() throws Exception {\n         List<MethodConfig> methodConfigs = collectMethodConfigs();\n         if (methodConfigs == null || methodConfigs.size() == 0) {\n             System.err.println(\"No method selected !\");\n-                return;\n-            }\n+            return;\n+        }\n \n         final Map<MethodConfig, MethodConfig> map = loadMethods(jar, methodConfigs);\n         try (FileSystem outputFileSystem = createZip(output)) {\n@@ -179,76 +190,501 @@ protected void doCommandLine() throws Exception {\n                 @Override\n                 public void visitFile(Path file, String relative) throws IOException {\n                     if (file.getFileName().toString().endsWith(\".class\")) {\n-                        MethodConfig key = new MethodConfig();\n-                        ClassReader cr = new ClassReader(Files.readAllBytes(file));\n-                        ClassNode cn = new ClassNode();\n-                        cr.accept(cn, ClassReader.EXPAND_FRAMES);\n-\n-                        for (MethodNode m : new ArrayList<MethodNode>(cn.methods)) {\n-                            if (m.instructions == null) {\n-                                continue;\n-                            }\n-                            key.owner = cn.name;\n-                            key.name = m.name;\n-                            key.desc = m.desc;\n-                            if (map.containsKey(key)) {\n-                                if (deleteMethod) {\n-                                    cn.methods.remove(m);\n-                                }\n-                                continue;\n+                        Path dist1 = outputBase.resolve(relative);\n+                        createParentDirectories(dist1);\n+                        byte[] data = Files.readAllBytes(file);\n+                        ClassNode cn = readClassNode(data);\n+\n+                        if (decrypt(cn, map)) {\n+                            byte[] data2 = toByteArray(cn);\n+                            Files.write(dist1, data2);\n+                        } else {\n+                            Files.write(dist1, data);\n+                        }\n+                    } else {\n+                        Path dist1 = outputBase.resolve(relative);\n+                        createParentDirectories(dist1);\n+                        Files.copy(file, dist1);\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    private byte[] toByteArray(ClassNode cn) {\n+        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n+        cn.accept(cw);\n+        return cw.toByteArray();\n+    }\n+\n+    private ClassNode readClassNode(byte[] data) {\n+        ClassReader cr = new ClassReader(data);\n+        ClassNode cn = new ClassNode();\n+        cr.accept(cn, ClassReader.EXPAND_FRAMES | ClassReader.SKIP_FRAMES);\n+        return cn;\n+    }\n+\n+    private boolean decrypt(ClassNode cn, Map<MethodConfig, MethodConfig> map) {\n+        if (deepAnalyze) {\n+            return decryptByIr(cn, map);\n+        } else {\n+            return decryptByStack(cn, map);\n+        }\n+    }\n+\n+    private boolean decryptByIr(ClassNode cn, Map<MethodConfig, MethodConfig> map) {\n+        MethodConfig key = this.key;\n+        boolean changed = false;\n+        System.err.println(\" >   on \" + cn.name);\n+        for (Iterator<MethodNode> it = cn.methods.iterator(); it.hasNext(); ) {\n+            MethodNode m = it.next();\n+            if (m.instructions == null) {\n+                continue;\n+            }\n+            key.owner = cn.name;\n+            key.name = m.name;\n+            key.desc = m.desc;\n+            if (map.containsKey(key)) {\n+                if (deleteMethod) {\n+                    it.remove();\n+                }\n+                continue;\n+            }\n+            boolean find = false;\n+            // search for the decrypt method\n+            for (AbstractInsnNode p = m.instructions.getFirst(); p != null; p = p.getNext()) {\n+                if (p.getOpcode() == Opcodes.INVOKESTATIC) {\n+                    MethodInsnNode mn = (MethodInsnNode) p;\n+                    key.owner = mn.owner;\n+                    key.name = mn.name;\n+                    key.desc = mn.desc;\n+                    MethodConfig config = map.get(key);\n+                    if (config != null) {\n+                        find = true;\n+                    }\n+                }\n+            }\n+            if (find) {\n+                try {\n+                    // copy m to m2 for cleanup debug info\n+                    MethodNode m2 = new MethodNode();\n+                    m2.tryCatchBlocks = new ArrayList<>();\n+                    m2.name = m.name;\n+                    m2.access = m.access;\n+                    m2.desc = m.desc;\n+                    m.accept(m2);\n+                    cleanDebug(m2);\n+                    // convert m2 to ir\n+                    IrMethod irMethod = J2IRConverter.convert(cn.name, m2);\n+                    // opt and decrypt\n+                    optAndDecrypt(irMethod, map);\n+\n+                    // convert ir to m3\n+                    MethodNode m3 = new MethodNode();\n+                    m3.tryCatchBlocks = new ArrayList<>();\n+                    new IR2JConverter(true).convert(irMethod, m3);\n+\n+                    // copy back m3 to m\n+                    m.maxLocals = -1;\n+                    m.maxLocals = -1;\n+                    m.instructions = m3.instructions;\n+                    m.tryCatchBlocks = m3.tryCatchBlocks;\n+                    m.localVariables = null;\n+                    changed = true;\n+                } catch (Exception ex) {\n+                    ex.printStackTrace();\n+                }\n+            }\n+        }\n+        return changed;\n+    }\n+\n+    MethodConfig key = new MethodConfig();\n+\n+    private boolean decryptByStack(ClassNode cn, Map<MethodConfig, MethodConfig> map) {\n+        MethodConfig key = this.key;\n+        boolean changed = false;\n+        for (Iterator<MethodNode> it = cn.methods.iterator(); it.hasNext(); ) {\n+            MethodNode m = it.next();\n+            if (m.instructions == null) {\n+                continue;\n+            }\n+            key.owner = cn.name;\n+            key.name = m.name;\n+            key.desc = m.desc;\n+            if (map.containsKey(key)) {\n+                if (deleteMethod) {\n+                    it.remove();\n+                }\n+                continue;\n+            }\n+            AbstractInsnNode p = m.instructions.getFirst();\n+            while (p != null) {\n+                if (p.getOpcode() == Opcodes.INVOKESTATIC) {\n+                    MethodInsnNode mn = (MethodInsnNode) p;\n+                    key.owner = mn.owner;\n+                    key.name = mn.name;\n+                    key.desc = mn.desc;\n+                    MethodConfig config = map.get(key);\n+                    if (config != null) {\n+                        //here we are, given that the decryption method is successfully recognised\n+                        Method jmethod = config.jmethod;\n+                        try {\n+                            int pSize = jmethod.getParameterTypes().length;\n+                            // arguments' list. each parameter's value is retrieved by reading bytecode backwards, starting from the INVOKESTATIC statement\n+                            Object[] as = readArgumentValues(mn, jmethod, pSize);\n+                            //decryption routine invocation\n+                            String newValue = (String) jmethod.invoke(null, as);\n+                            //LDC statement generation\n+                            LdcInsnNode nLdc = new LdcInsnNode(newValue);\n+                            //insertion of the decrypted string's LDC statement, after INVOKESTATIC statement\n+                            m.instructions.insert(mn, nLdc);\n+                            //removal of INVOKESTATIC and previous push statements\n+                            removeInsts(m, mn, pSize);\n+                            p = nLdc;\n+                            changed = true;\n+                        } catch (Exception ex) {\n+                            // ignore\n+                        }\n+                    }\n+                }\n+                p = p.getNext();\n+            }\n+        }\n+        return changed;\n+    }\n+\n+    protected final CleanLabel T_cleanLabel = new CleanLabel();\n+    protected final Ir2JRegAssignTransformer T_ir2jRegAssign = new Ir2JRegAssignTransformer();\n+    protected final NewTransformer T_new = new NewTransformer();\n+    protected final RemoveConstantFromSSA T_removeConst = new RemoveConstantFromSSA();\n+    protected final RemoveLocalFromSSA T_removeLocal = new RemoveLocalFromSSA();\n+    protected final ExceptionHandlerTrim T_trimEx = new ExceptionHandlerTrim();\n+    protected final TypeTransformer T_type = new TypeTransformer();\n+    protected final DeadCodeTransformer T_deadCode = new DeadCodeTransformer();\n+    protected final FillArrayTransformer T_fillArray = new FillArrayTransformer();\n+    protected final AggTransformer T_agg = new AggTransformer();\n+    protected final UnSSATransformer T_unssa = new UnSSATransformer();\n+    protected final ZeroTransformer T_zero = new ZeroTransformer();\n+    protected final VoidInvokeTransformer T_voidInvoke = new VoidInvokeTransformer();\n+    protected final NpeTransformer T_npe = new NpeTransformer();\n+\n+    public void optAndDecrypt(IrMethod irMethod, final Map<MethodConfig, MethodConfig> map) {\n+        T_deadCode.transform(irMethod);\n+        T_cleanLabel.transform(irMethod);\n+        T_removeLocal.transform(irMethod);\n+        T_removeConst.transform(irMethod);\n+        T_zero.transform(irMethod);\n+        if (T_npe.transformReportChanged(irMethod)) {\n+            T_deadCode.transform(irMethod);\n+            T_removeLocal.transform(irMethod);\n+            T_removeConst.transform(irMethod);\n+        }\n+        T_new.transform(irMethod);\n+        T_fillArray.transform(irMethod);\n+        T_agg.transform(irMethod);\n+        T_voidInvoke.transform(irMethod);\n+\n+        new StmtTraveler() {\n+            @Override\n+            public Value travel(Value op) {\n+                op = super.travel(op);\n+                if (op.vt == Value.VT.INVOKE_STATIC) {\n+                    InvokeExpr ie = (InvokeExpr) op;\n+                    MethodConfig key = DecryptStringCmd.this.key;\n+                    key.owner = ie.owner.substring(1, ie.owner.length() - 1);\n+                    key.name = ie.name;\n+                    key.desc = buildMethodDesc(ie.args, ie.ret);\n+\n+                    MethodConfig c = map.get(key);\n+                    if (c != null) {\n+                        try {\n+                            Method jmethod = c.jmethod;\n+                            if (ie.args.length != jmethod.getParameterCount()) {\n+                                throw new RuntimeException();\n                             }\n-                            AbstractInsnNode p = m.instructions.getFirst();\n-                            while (p != null) {\n-                                if (p.getOpcode() == Opcodes.INVOKESTATIC) {\n-                                    MethodInsnNode mn = (MethodInsnNode) p;\n-                                    key.owner = mn.owner;\n-                                    key.name = mn.name;\n-                                    key.desc = mn.desc;\n-                                    MethodConfig config = map.get(key);\n-                                    if (config != null) {\n-                                        //here we are, given that the decryption method is successfully recognised\n-                                        Method jmethod = config.jmethod;\n-                                                try {\n-                                            int pSize = jmethod.getParameterTypes().length;\n-                                            // arguments' list. each parameter's value is retrieved by reading bytecode backwards, starting from the INVOKESTATIC statement\n-                                            Object[] as = readArgumentValues(mn, jmethod, pSize);\n-                                            //decryption routine invocation\n-                                            String newValue = (String) jmethod.invoke(null, as);\n-                                            //LDC statement generation\n-                                            LdcInsnNode nLdc = new LdcInsnNode(newValue);\n-                                            //insertion of the decrypted string's LDC statement, after INVOKESTATIC statement\n-                                            m.instructions.insert(mn, nLdc);\n-                                            //removal of INVOKESTATIC and previous push statements\n-                                            removeInsts(m, mn, pSize);\n-                                            p = nLdc;\n-                                        } catch (Exception ex) {\n-                                            // ignore\n-                                        }\n-                                    }\n-                                }\n-                                p = p.getNext();\n+                            Object args[] = new Object[ie.args.length];\n+                            for (int i = 0; i < args.length; i++) {\n+                                args[i] = convertIr2Jobj(ie.getOps()[i], ie.args[i]);\n                             }\n+                            String str = (String) jmethod.invoke(null, args);\n+                            System.err.println(\"   < \" + Escape.v(str));\n+                            return Exprs.nString(str);\n+                        } catch (Exception e) {\n+                            e.printStackTrace();\n                         }\n \n-                        ClassWriter cw = new ClassWriter(0);\n-                        cn.accept(cw);\n-                        Path dist1 = outputBase.resolve(relative);\n-                        Path parent = dist1.getParent();\n-                        if (parent != null && !Files.exists(parent)) {\n-                            Files.createDirectories(parent);\n+                    }\n+                }\n+                return op;\n+            }\n+        }.travel(irMethod.stmts);\n+\n+        T_type.transform(irMethod);\n+        T_unssa.transform(irMethod);\n+        T_trimEx.transform(irMethod);\n+        T_ir2jRegAssign.transform(irMethod);\n+    }\n+\n+    private Object convertIr2Jobj(Value value, String type) {\n+        if (value instanceof Constant) {\n+            if (Constant.Null.equals(((Constant) value).value)) {\n+                return null;\n+            }\n+        }\n+        switch (type) {\n+            case \"Z\": {\n+                Object obj = ((Constant) value).value;\n+                return obj instanceof Boolean ? obj : ((Number) obj).intValue() != 0;\n+            }\n+            case \"B\": {\n+                Object obj = ((Constant) value).value;\n+                return ((Number) obj).byteValue();\n+            }\n+            case \"S\": {\n+                Object obj = ((Constant) value).value;\n+                return ((Number) obj).shortValue();\n+            }\n+            case \"C\": {\n+                Object obj = ((Constant) value).value;\n+                return obj instanceof Character ? obj : (char) ((Number) obj).intValue();\n+            }\n+            case \"I\": {\n+                Object obj = ((Constant) value).value;\n+                return ((Number) obj).intValue();\n+            }\n+            case \"J\": {\n+                Object obj = ((Constant) value).value;\n+                return ((Number) obj).longValue();\n+            }\n+            case \"F\": {\n+                Object obj = ((Constant) value).value;\n+                return obj instanceof Float ? obj : Float.intBitsToFloat(((Number) obj).intValue());\n+            }\n+            case \"D\": {\n+                Object obj = ((Constant) value).value;\n+                return obj instanceof Double ? obj : Double.longBitsToDouble(((Number) obj).longValue());\n+            }\n+            case \"Ljava/lang/String;\":\n+                return (String) ((Constant) value).value;\n+            case \"[Z\":\n+                if (value instanceof Constant) {\n+                    Object obj = ((Constant) value).value;\n+                    if (obj instanceof boolean[]) {\n+                        return obj;\n+                    } else {\n+\n+                        boolean[] b = new boolean[Array.getLength(obj)];\n+                        for (int i = 0; i < b.length; i++) {\n+                            b[i] = ((Number) Array.get(obj, i)).intValue() != 0;\n+                        }\n+                        return b;\n+                    }\n+                } else if (value instanceof FilledArrayExpr) {\n+                    boolean b[] = new boolean[value.getOps().length];\n+                    for (int i = 0; i < b.length; i++) {\n+                        Object obj = ((Constant) value.getOps()[i]).value;\n+                        if (obj instanceof Boolean) {\n+                            b[i] = ((Boolean) obj).booleanValue();\n+                        } else {\n+                            b[i] = ((Number) obj).intValue() != 0;\n                         }\n-                        Files.write(dist1, cw.toByteArray());\n+                    }\n+                    return b;\n+                }\n+                throw new RuntimeException();\n+            case \"[B\":\n+                if (value instanceof Constant) {\n+                    Object obj = ((Constant) value).value;\n+                    if (obj instanceof byte[]) {\n+                        return obj;\n                     } else {\n-                        Path dist1 = outputBase.resolve(relative);\n-                        Path parent = dist1.getParent();\n-                        if (parent != null && !Files.exists(parent)) {\n-                            Files.createDirectories(parent);\n+                        byte[] b = new byte[Array.getLength(obj)];\n+                        for (int i = 0; i < b.length; i++) {\n+                            b[i] = ((Number) Array.get(obj, i)).byteValue();\n                         }\n-                        Files.copy(file, dist1);\n+                        return b;\n+                    }\n+                } else if (value instanceof FilledArrayExpr) {\n+                    byte b[] = new byte[value.getOps().length];\n+                    for (int i = 0; i < b.length; i++) {\n+                        Object obj = ((Constant) value.getOps()[i]).value;\n+                        b[i] = ((Number) obj).byteValue();\n                     }\n+                    return b;\n                 }\n-            });\n+                throw new RuntimeException();\n+            case \"[S\":\n+                if (value instanceof Constant) {\n+                    Object obj = ((Constant) value).value;\n+                    if (obj instanceof short[]) {\n+                        return obj;\n+                    } else {\n+                        short[] b = new short[Array.getLength(obj)];\n+                        for (int i = 0; i < b.length; i++) {\n+                            b[i] = ((Number) Array.get(obj, i)).shortValue();\n+                        }\n+                        return b;\n+                    }\n+                } else if (value instanceof FilledArrayExpr) {\n+                    short b[] = new short[value.getOps().length];\n+                    for (int i = 0; i < b.length; i++) {\n+                        Object obj = ((Constant) value.getOps()[i]).value;\n+                        b[i] = ((Number) obj).shortValue();\n+                    }\n+                    return b;\n+                }\n+                throw new RuntimeException();\n+            case \"[C\":\n+                if (value instanceof Constant) {\n+                    Object obj = ((Constant) value).value;\n+                    if (obj instanceof char[]) {\n+                        return obj;\n+                    } else {\n+                        char[] b = new char[Array.getLength(obj)];\n+                        for (int i = 0; i < b.length; i++) {\n+                            b[i] = (char) ((Number) Array.get(obj, i)).intValue();\n+                        }\n+                        return b;\n+                    }\n+                } else if (value instanceof FilledArrayExpr) {\n+                    char b[] = new char[value.getOps().length];\n+                    for (int i = 0; i < b.length; i++) {\n+                        Object obj = ((Constant) value.getOps()[i]).value;\n+                        b[i] = obj instanceof Character ? ((Character) obj).charValue() : (char) ((Number) obj).intValue();\n+                    }\n+                    return b;\n+                }\n+                throw new RuntimeException();\n+            case \"[I\":\n+                if (value instanceof Constant) {\n+                    Object obj = ((Constant) value).value;\n+                    if (obj instanceof int[]) {\n+                        return obj;\n+                    } else {\n+                        int[] b = new int[Array.getLength(obj)];\n+                        for (int i = 0; i < b.length; i++) {\n+                            b[i] = ((Number) Array.get(obj, i)).intValue();\n+                        }\n+                        return b;\n+                    }\n+                } else if (value instanceof FilledArrayExpr) {\n+                    int b[] = new int[value.getOps().length];\n+                    for (int i = 0; i < b.length; i++) {\n+                        Object obj = ((Constant) value.getOps()[i]).value;\n+                        b[i] = ((Number) obj).intValue();\n+                    }\n+                    return b;\n+                }\n+                throw new RuntimeException();\n+            case \"[J\":\n+                if (value instanceof Constant) {\n+                    Object obj = ((Constant) value).value;\n+                    if (obj instanceof long[]) {\n+                        return obj;\n+                    } else {\n+                        long[] b = new long[Array.getLength(obj)];\n+                        for (int i = 0; i < b.length; i++) {\n+                            b[i] = ((Number) Array.get(obj, i)).longValue();\n+                        }\n+                        return b;\n+                    }\n+                } else if (value instanceof FilledArrayExpr) {\n+                    long b[] = new long[value.getOps().length];\n+                    for (int i = 0; i < b.length; i++) {\n+                        Object obj = ((Constant) value.getOps()[i]).value;\n+                        b[i] = ((Number) obj).longValue();\n+                    }\n+                    return b;\n+                }\n+                throw new RuntimeException();\n+            case \"[F\":\n+                if (value instanceof Constant) {\n+                    Object obj = ((Constant) value).value;\n+                    if (obj instanceof float[]) {\n+                        return obj;\n+                    } else {\n+                        float[] b = new float[Array.getLength(obj)];\n+                        for (int i = 0; i < b.length; i++) {\n+                            b[i] = (char) ((Number) Array.get(obj, i)).intValue();\n+                        }\n+                        return b;\n+                    }\n+                } else if (value instanceof FilledArrayExpr) {\n+                    float b[] = new float[value.getOps().length];\n+                    for (int i = 0; i < b.length; i++) {\n+                        Object obj = ((Constant) value.getOps()[i]).value;\n+                        b[i] = obj instanceof Float ? ((Float) obj).floatValue() : Float.intBitsToFloat(((Number) obj).intValue());\n+                    }\n+                    return b;\n+                }\n+                throw new RuntimeException();\n+            case \"[D\":\n+                if (value instanceof Constant) {\n+                    Object obj = ((Constant) value).value;\n+                    if (obj instanceof double[]) {\n+                        return obj;\n+                    } else {\n+                        double[] b = new double[Array.getLength(obj)];\n+                        for (int i = 0; i < b.length; i++) {\n+                            b[i] = (char) ((Number) Array.get(obj, i)).intValue();\n+                        }\n+                        return b;\n+                    }\n+                } else if (value instanceof FilledArrayExpr) {\n+                    double b[] = new double[value.getOps().length];\n+                    for (int i = 0; i < b.length; i++) {\n+                        Object obj = ((Constant) value.getOps()[i]).value;\n+                        b[i] = obj instanceof Double ? ((Double) obj).doubleValue() : Double.longBitsToDouble(((Number) obj).longValue());\n+                    }\n+                    return b;\n+                }\n+                throw new RuntimeException();\n+            case \"[Ljava/lang/String;\":\n+                if (value instanceof Constant) {\n+                    Object obj = ((Constant) value).value;\n+                    if (obj instanceof String[]) {\n+                        return obj;\n+                    }\n+                } else if (value instanceof FilledArrayExpr) {\n+                    String b[] = new String[value.getOps().length];\n+                    for (int i = 0; i < b.length; i++) {\n+                        Object obj = ((Constant) value.getOps()[i]).value;\n+                        if (obj instanceof String) {\n+                            b[i] = (String) obj;\n+                        } else if (Constant.Null.equals(obj)) {\n+                            b[i] = null;\n+                        } else {\n+                            throw new RuntimeException();\n+                        }\n+                    }\n+                    return b;\n+                }\n+                throw new RuntimeException();\n         }\n+        throw new RuntimeException();\n+    }\n+\n+    private String buildMethodDesc(String[] args, String ret) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('(');\n+        for (String s : args) {\n+            sb.append(s);\n+        }\n+        return sb.append(')').append(ret).toString();\n+    }\n+\n+    private void cleanDebug(MethodNode mn) {\n+        for (AbstractInsnNode p = mn.instructions.getFirst(); p != null; ) {\n+            if (p.getType() == AbstractInsnNode.LINE) {\n+                AbstractInsnNode q = p.getNext();\n+                mn.instructions.remove(p);\n+                p = q;\n+            } else {\n+                p = p.getNext();\n+            }\n+        }\n+        mn.localVariables = null;\n     }\n \n     void removeInsts(MethodNode m, MethodInsnNode mn, int pSize) {\n@@ -262,28 +698,28 @@ void removeInsts(MethodNode m, MethodInsnNode mn, int pSize) {\n \n     Object[] readArgumentValues(MethodInsnNode mn, Method jmethod, int pSize) {\n         AbstractInsnNode q = mn;\n-                                            Object[] as = new Object[pSize];\n-                                            for (int i = pSize - 1; i >= 0; i--) {\n-                                                q = q.getPrevious();\n-                                                Object object = readCst(q);\n-                                                as[i] = convert(object, jmethod.getParameterTypes()[i]);\n-                                                }\n+        Object[] as = new Object[pSize];\n+        for (int i = pSize - 1; i >= 0; i--) {\n+            q = q.getPrevious();\n+            Object object = readCst(q);\n+            as[i] = convert(object, jmethod.getParameterTypes()[i]);\n+        }\n         return as;\n-                        }\n+    }\n \n     Object convert(Object object, Class<?> type) {\n-                    if (int.class.equals(type)) {\n-                        return ((Number) object).intValue();\n-                    }\n-                    if (byte.class.equals(type)) {\n-                        return ((Number) object).byteValue();\n-                    }\n-                    if (short.class.equals(type)) {\n-                        return ((Number) object).shortValue();\n-                    }\n-                    if (char.class.equals(type)) {\n-                        return (char) ((Number) object).intValue();\n-                    }\n+        if (int.class.equals(type)) {\n+            return ((Number) object).intValue();\n+        }\n+        if (byte.class.equals(type)) {\n+            return ((Number) object).byteValue();\n+        }\n+        if (short.class.equals(type)) {\n+            return ((Number) object).shortValue();\n+        }\n+        if (char.class.equals(type)) {\n+            return (char) ((Number) object).intValue();\n+        }\n         if (boolean.class.equals(type)) {\n             return (char) ((Number) object).intValue() != 0;\n         }\n@@ -296,8 +732,8 @@ Object convert(Object object, Class<?> type) {\n         if (double.class.equals(type)) {\n             return (char) ((Number) object).doubleValue();\n         }\n-                    return object;\n-                }\n+        return object;\n+    }\n \n     /**\n      * load java methods from jar and --classpath\n@@ -416,7 +852,7 @@ private Method findAnyMethodMatch(Class<?> clz, String name, Class<?>[] classes)\n             Method m = clz.getDeclaredMethod(name, classes);\n             if (m != null) {\n                 return m;\n-}\n+            }\n         } catch (NoSuchMethodException e) {\n             e.printStackTrace();\n         }\n@@ -446,18 +882,18 @@ Object readCst(AbstractInsnNode q) {\n                 // LDC: String, integer, long and double cases (Opcodes.LDC comprehends LDC_W and LDC2_W)\n                 // push 32bit or 64bit int/float\n                 // push string/type\n-            LdcInsnNode ldc = (LdcInsnNode) q;\n+                LdcInsnNode ldc = (LdcInsnNode) q;\n                 if (ldc.cst instanceof Type) {\n                     throw new RuntimeException(\"not support .class value yet!\");\n                 }\n-            return ldc.cst;\n+                return ldc.cst;\n \n             case Opcodes.BIPUSH:\n             case Opcodes.SIPUSH:\n                 // INT_INSN (\"instruction with a single int operand\")\n                 // push 8bit or 16bit int\n-            IntInsnNode in = (IntInsnNode) q;\n-            return in.operand;\n+                IntInsnNode in = (IntInsnNode) q;\n+                return in.operand;\n \n             case Opcodes.ICONST_M1:\n             case Opcodes.ICONST_0:\n@@ -478,7 +914,7 @@ Object readCst(AbstractInsnNode q) {\n             case Opcodes.DCONST_0:\n             case Opcodes.DCONST_1:\n                 return (double) (q.getOpcode() - Opcodes.DCONST_0);\n-            }\n+        }\n \n         throw new RuntimeException();\n     }\n@@ -493,27 +929,28 @@ Class<?>[] toJavaType(Type[] pt) throws ClassNotFoundException {\n \n     Class<?> toJavaType(Type t) throws ClassNotFoundException {\n         switch (t.getSort()) {\n-        case Type.BOOLEAN:\n-            return boolean.class;\n-        case Type.BYTE:\n-            return byte.class;\n-        case Type.SHORT:\n-            return short.class;\n-        case Type.CHAR:\n-            return char.class;\n-        case Type.INT:\n-            return int.class;\n-        case Type.FLOAT:\n-            return float.class;\n-        case Type.LONG:\n-            return long.class;\n-        case Type.DOUBLE:\n-            return double.class;\n-        case Type.OBJECT:\n-        case Type.ARRAY:\n-            return Class.forName(t.getClassName());\n-        case Type.VOID:\n-            return void.class;\n+            case Type.BOOLEAN:\n+                return boolean.class;\n+            case Type.BYTE:\n+                return byte.class;\n+            case Type.SHORT:\n+                return short.class;\n+            case Type.CHAR:\n+                return char.class;\n+            case Type.INT:\n+                return int.class;\n+            case Type.FLOAT:\n+                return float.class;\n+            case Type.LONG:\n+                return long.class;\n+            case Type.DOUBLE:\n+                return double.class;\n+            case Type.OBJECT:\n+                return Class.forName(t.getClassName());\n+            case Type.ARRAY:\n+                return Class.forName(t.getDescriptor());\n+            case Type.VOID:\n+                return void.class;\n         }\n         throw new RuntimeException();\n     }",
      "parent_sha": "db2eb2d7759a3e611bf48a68c773cf4d0248b7a7"
    }
  },
  {
    "oid": "f48faf2567329fece977bba87b8ecd00e9215aa9",
    "message": "merge DecryptStringCmd.java@43d692ab4917 to 2.x\n\n--HG--\nbranch : 2.x",
    "date": "2014-10-29T13:07:21Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/f48faf2567329fece977bba87b8ecd00e9215aa9",
    "details": {
      "sha": "7a95929b024a7f35785075561e222bfc9227eddb",
      "filename": "dex-tools/src/main/java/com/googlecode/dex2jar/tools/DecryptStringCmd.java",
      "status": "modified",
      "additions": 278,
      "deletions": 45,
      "changes": 323,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/f48faf2567329fece977bba87b8ecd00e9215aa9/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FDecryptStringCmd.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/f48faf2567329fece977bba87b8ecd00e9215aa9/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FDecryptStringCmd.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FDecryptStringCmd.java?ref=f48faf2567329fece977bba87b8ecd00e9215aa9",
      "patch": "@@ -16,24 +16,23 @@\n  */\n package com.googlecode.dex2jar.tools;\n \n+import com.googlecode.dex2jar.tools.BaseCmd.Syntax;\n+import org.objectweb.asm.ClassReader;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.objectweb.asm.tree.*;\n+\n import java.io.File;\n import java.io.IOException;\n import java.lang.reflect.Method;\n import java.net.URL;\n import java.net.URLClassLoader;\n+import java.nio.charset.StandardCharsets;\n import java.nio.file.FileSystem;\n import java.nio.file.Files;\n import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-import org.objectweb.asm.ClassReader;\n-import org.objectweb.asm.ClassWriter;\n-import org.objectweb.asm.Opcodes;\n-import org.objectweb.asm.tree.*;\n-\n-import com.googlecode.dex2jar.tools.BaseCmd.Syntax;\n+import java.util.*;\n \n @Syntax(cmd = \"d2j-decrypt-string\", syntax = \"[options] <jar>\", desc = \"Decrypt in class file\", onlineHelp = \"https://code.google.com/p/dex2jar/wiki/DecryptStrings\")\n public class DecryptStringCmd extends BaseCmd {\n@@ -45,31 +44,113 @@ public static void main(String... args) {\n     private boolean forceOverwrite = false;\n     @Opt(opt = \"o\", longOpt = \"output\", description = \"output of .jar files, default is $current_dir/[jar-name]-decrypted.jar\", argName = \"out\")\n     private Path output;\n-\n-    @Opt(opt = \"mo\", longOpt = \"decrypt-method-owner\", description = \"the owner of the mothed which can decrypt the stings, example: java.lang.String\", argName = \"owner\")\n+    @Opt(opt = \"m\", longOpt = \"methods\", description = \"a file contain a list of methods, each line like: La/b;->decrypt(III)Ljava/lang/String;\", argName = \"cfg\")\n+    private Path method;\n+    @Opt(opt = \"mo\", longOpt = \"decrypt-method-owner\", description = \"the owner of the method which can decrypt the stings, example: java.lang.String\", argName = \"owner\")\n     private String methodOwner;\n-    @Opt(opt = \"mn\", longOpt = \"decrypt-method-name\", description = \"the owner of the mothed which can decrypt the stings, the method's signature must be static (Ljava/lang/String;)Ljava/lang/String;\", argName = \"name\")\n+    @Opt(opt = \"mn\", longOpt = \"decrypt-method-name\", description = \"the owner of the method which can decrypt the stings, the method's signature must be static (parameter-type)Ljava/lang/String;. Please use -pt,--parameter-type to set the argument descrypt.\", argName = \"name\")\n     private String methodName;\n-    @Opt(opt = \"cp\", longOpt = \"classpath\", description = \"\", argName = \"cp\")\n+    @Opt(opt = \"cp\", longOpt = \"classpath\", description = \"add extra lib to classpath\", argName = \"cp\")\n     private String classpath;\n+    @Opt(opt = \"t\", longOpt = \"arg-type\", description = \"ignored\")\n+    private String type = null;\n+\n+    @Opt(opt = \"pt\", longOpt = \"parameter-type\", description = \"the descript for the method which can decrypt the stings, example1: Ljava/lang/String; example2:III, default is Ljava/lang/String;\", argName = \"type\")\n+    private String parameterType = \"Ljava/lang/String;\";\n+    @Opt(opt = \"d\", longOpt = \"delete\", hasArg = false, description = \"delete the method which can decrypt the stings\")\n+    private boolean deleteMethod = false;\n+\n+    static class MethodConfig {\n+        Method jmethod;\n+        /**\n+         * in java/lang/String format\n+         */\n+        String owner;\n+        String name;\n+        String desc;\n+\n+        @Override\n+        public int hashCode() {\n+            final int prime = 31;\n+            int result = 1;\n+            result = prime * result + ((desc == null) ? 0 : desc.hashCode());\n+            result = prime * result + ((name == null) ? 0 : name.hashCode());\n+            result = prime * result + ((owner == null) ? 0 : owner.hashCode());\n+            return result;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj)\n+                return true;\n+            if (obj == null)\n+                return false;\n+            if (getClass() != obj.getClass())\n+                return false;\n+            MethodConfig other = (MethodConfig) obj;\n+            if (desc == null) {\n+                if (other.desc != null)\n+                    return false;\n+            } else if (!desc.equals(other.desc))\n+                return false;\n+            if (name == null) {\n+                if (other.name != null)\n+                    return false;\n+            } else if (!name.equals(other.name))\n+                return false;\n+            if (owner == null) {\n+                if (other.owner != null)\n+                    return false;\n+            } else if (!owner.equals(other.owner))\n+                return false;\n+            return true;\n+        }\n+    }\n+\n+    MethodConfig build(String line) {\n+        int idx = line.indexOf(\"->\");\n+        if (idx < 0) {\n+            throw new RuntimeException(\"Can't read line:\" + line);\n+        }\n+        String owner = line.substring(0, idx);\n+\n+        if (owner.startsWith(\"L\") && owner.endsWith(\";\")) {\n+            owner = owner.substring(1, owner.length() - 1);\n+        }\n+\n+        int idx2 = line.indexOf('(', idx);\n+        if (idx2 < 0) {\n+            throw new RuntimeException(\"Can't read line:\" + line);\n+        }\n+\n+        String name = line.substring(idx + 2, idx2);\n+\n+        String desc = line.substring(idx2);\n+        if (desc.endsWith(\")\")) {\n+            desc = desc + \"Ljava/lang/String;\";\n+        }\n+\n+        MethodConfig config = new MethodConfig();\n+        config.owner = owner;\n+        config.desc = desc;\n+        config.name = name;\n+        return config;\n+\n+    }\n \n     @Override\n     protected void doCommandLine() throws Exception {\n-        if (remainingArgs.length != 1) {\n-            usage();\n-            return;\n+        if (remainingArgs.length == 0) {\n+            throw new HelpException(\"One <jar> file is required\");\n+        } else if (remainingArgs.length > 1) {\n+            throw new HelpException(\"Only one <jar> file is required, But we found \" + remainingArgs.length);\n         }\n \n         final Path jar = new File(remainingArgs[0]).toPath();\n         if (!Files.exists(jar)) {\n             System.err.println(jar + \" is not exists\");\n             return;\n         }\n-        if (methodName == null || methodOwner == null) {\n-            System.err.println(\"Please set --decrypt-method-owner and --decrypt-method-name\");\n-            return;\n-        }\n-\n         if (output == null) {\n             if (Files.isDirectory(jar)) {\n                 output = new File(jar.getFileName() + \"-decrypted.jar\").toPath();\n@@ -85,6 +166,25 @@ protected void doCommandLine() throws Exception {\n \n         System.err.println(jar + \" -> \" + output);\n \n+        List<MethodConfig> methodConfigs = new ArrayList<MethodConfig>();\n+        if (this.method != null) {\n+            for (String line : Files.readAllLines(this.method, StandardCharsets.UTF_8)) {\n+                if (line.length() == 0 || line.startsWith(\"#\")) {\n+                    continue;\n+                }\n+                methodConfigs.add(this.build(line));\n+            }\n+        } else {\n+            if (methodOwner == null || methodName == null) {\n+                System.err.println(\"-mo/--decrypt-method-owner or -mn/decrypt-method-name is null\");\n+                return;\n+            }\n+            methodConfigs.add(this.build(\"L\" + methodOwner.replace('.', '/') + \";->\" + methodName + \"(\"\n+                    + this.parameterType + \")Ljava/lang/String;\"));\n+        }\n+\n+        final Map<MethodConfig, MethodConfig> map = new HashMap<MethodConfig, MethodConfig>();\n+        {\n         List<String> list = new ArrayList<String>();\n         if (classpath != null) {\n             list.addAll(Arrays.asList(classpath.split(\";|:\")));\n@@ -94,15 +194,25 @@ protected void doCommandLine() throws Exception {\n         for (int i = 0; i < list.size(); i++) {\n             urls[i] = new File(list.get(i)).toURI().toURL();\n         }\n-        final Method jmethod;\n-        try {\n+\n             URLClassLoader cl = new URLClassLoader(urls);\n-            jmethod = cl.loadClass(methodOwner).getMethod(methodName, String.class);\n+            for (MethodConfig config : methodConfigs) {\n+        try {\n+                    Class<?> clz = cl.loadClass(config.owner.replace('/', '.'));\n+                    if (clz == null) {\n+                        System.err.println(\"clz is null:\" + config.owner);\n+                    }\n+                    Method jmethod = findAnyMethodMatch(clz, config.name,\n+                            toJavaType(Type.getArgumentTypes(config.desc)));\n             jmethod.setAccessible(true);\n+                    config.jmethod = jmethod;\n+                    map.put(config, config);\n         } catch (Exception ex) {\n-            System.err.println(\"can't load method: String \" + methodOwner + \".\" + methodName + \"(String), message:\"\n-                    + ex.getMessage());\n+                    System.err.println(\"can't load method: L\" + config.owner + \";->\" + config.name + config.desc);\n+                    ex.printStackTrace();\n             return;\n+        }\n+            }\n         }\n         final String methodOwnerInternalType = this.methodOwner.replace('.', '/');\n         try (FileSystem outputFileSystem = createZip(output)) {\n@@ -111,36 +221,54 @@ protected void doCommandLine() throws Exception {\n                 @Override\n                 public void visitFile(Path file, Path relative) throws IOException {\n                     if (file.getFileName().toString().endsWith(\".class\")) {\n-\n+                        MethodConfig key = new MethodConfig();\n                         ClassReader cr = new ClassReader(Files.readAllBytes(file));\n                         ClassNode cn = new ClassNode();\n-                        cr.accept(cn, 0);\n+                        cr.accept(cn, ClassReader.EXPAND_FRAMES);\n \n-                        for (Object m0 : cn.methods) {\n-                            MethodNode m = (MethodNode) m0;\n+                        for (MethodNode m : new ArrayList<MethodNode>(cn.methods)) {\n                             if (m.instructions == null) {\n                                 continue;\n                             }\n+                            key.owner = cn.name;\n+                            key.name = m.name;\n+                            key.desc = m.desc;\n+                            if (map.containsKey(key)) {\n+                                if (deleteMethod) {\n+                                    cn.methods.remove(m);\n+                                }\n+                                continue;\n+                            }\n                             AbstractInsnNode p = m.instructions.getFirst();\n                             while (p != null) {\n-                                if (p.getOpcode() == Opcodes.LDC) {\n-                                    LdcInsnNode ldc = (LdcInsnNode) p;\n-                                    if (ldc.cst instanceof String) {\n-                                        String v = (String) ldc.cst;\n-                                        AbstractInsnNode q = p.getNext();\n-                                        if (q.getOpcode() == Opcodes.INVOKESTATIC) {\n-                                            MethodInsnNode mn = (MethodInsnNode) q;\n-                                            if (mn.name.equals(methodName)\n-                                                    && mn.desc.equals(\"(Ljava/lang/String;)Ljava/lang/String;\")\n-                                                    && mn.owner.equals(methodOwnerInternalType)) {\n+                                if (p.getOpcode() == Opcodes.INVOKESTATIC) {\n+                                    MethodInsnNode mn = (MethodInsnNode) p;\n+                                    key.owner = mn.owner;\n+                                    key.name = mn.name;\n+                                    key.desc = mn.desc;\n+                                    MethodConfig config = map.get(key);\n+                                    if (config != null) {\n+                                        Method jmethod = config.jmethod;\n                                                 try {\n-                                                    Object newValue = jmethod.invoke(null, v);\n-                                                    ldc.cst = newValue;\n-                                                } catch (Exception e) {\n-                                                    // ignore\n+                                            AbstractInsnNode q = p;\n+                                            int pSize = jmethod.getParameterTypes().length;\n+                                            Object[] as = new Object[pSize];\n+                                            for (int i = pSize - 1; i >= 0; i--) {\n+                                                q = q.getPrevious();\n+                                                Object object = readCst(q);\n+                                                as[i] = convert(object, jmethod.getParameterTypes()[i]);\n                                                 }\n+                                            String newValue = (String) jmethod.invoke(null, as);\n+                                            LdcInsnNode nLdc = new LdcInsnNode(newValue);\n+                                            m.instructions.insert(p, nLdc);\n+                                            q = p;\n+                                            for (int i = 0; i <= pSize; i++) {\n+                                                AbstractInsnNode z = q.getPrevious();\n                                                 m.instructions.remove(q);\n+                                                q = z;\n                                             }\n+                                            p = nLdc;\n+                                        } catch (Exception ex) {\n                                         }\n                                     }\n                                 }\n@@ -155,7 +283,112 @@ public void visitFile(Path file, Path relative) throws IOException {\n                         Files.copy(file, outputBase.resolve(relative));\n                     }\n                 }\n+\n+                private Object convert(Object object, Class<?> type) {\n+                    if (int.class.equals(type)) {\n+                        return ((Number) object).intValue();\n+                    }\n+                    if (byte.class.equals(type)) {\n+                        return ((Number) object).byteValue();\n+                    }\n+                    if (short.class.equals(type)) {\n+                        return ((Number) object).shortValue();\n+                    }\n+                    if (char.class.equals(type)) {\n+                        return (char) ((Number) object).intValue();\n+                    }\n+                    return object;\n+                }\n             });\n         }\n     }\n+\n+    /**\n+     * fix for issue 216, travel all the parent of class and use getDeclaredMethod to find methods\n+     */\n+    private Method findAnyMethodMatch(Class<?> clz, String name, Class<?>[] classes) {\n+        try {\n+            Method m = clz.getDeclaredMethod(name, classes);\n+            if (m != null) {\n+                return m;\n+}\n+        } catch (NoSuchMethodException e) {\n+            e.printStackTrace();\n+        }\n+        Class<?> sup = clz.getSuperclass();\n+        if (sup != null) {\n+            Method m = findAnyMethodMatch(sup, name, classes);\n+            if (m != null) {\n+                return m;\n+            }\n+        }\n+        Class<?>[] itfs = clz.getInterfaces();\n+        if (itfs != null && itfs.length > 0) {\n+            for (Class<?> itf : itfs) {\n+                Method m = findAnyMethodMatch(itf, name, classes);\n+                if (m != null) {\n+                    return m;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    Object readCst(AbstractInsnNode q) {\n+        if (q.getOpcode() == Opcodes.LDC) {\n+            LdcInsnNode ldc = (LdcInsnNode) q;\n+            return ldc.cst;\n+        } else if (q.getType() == AbstractInsnNode.INT_INSN) {\n+            IntInsnNode in = (IntInsnNode) q;\n+            return in.operand;\n+        } else {\n+            switch (q.getOpcode()) {\n+            case Opcodes.ICONST_M1:\n+            case Opcodes.ICONST_0:\n+            case Opcodes.ICONST_1:\n+            case Opcodes.ICONST_2:\n+            case Opcodes.ICONST_3:\n+            case Opcodes.ICONST_4:\n+            case Opcodes.ICONST_5:\n+                int x = ((InsnNode) q).getOpcode() - Opcodes.ICONST_0;\n+                return x;\n+            }\n+        }\n+        throw new RuntimeException();\n+    }\n+\n+    private Class<?>[] toJavaType(Type[] pt) throws ClassNotFoundException {\n+        Class<?> jt[] = new Class<?>[pt.length];\n+        for (int i = 0; i < pt.length; i++) {\n+            jt[i] = toJavaType(pt[i]);\n+        }\n+        return jt;\n+    }\n+\n+    private Class<?> toJavaType(Type t) throws ClassNotFoundException {\n+        switch (t.getSort()) {\n+        case Type.BOOLEAN:\n+            return boolean.class;\n+        case Type.BYTE:\n+            return byte.class;\n+        case Type.SHORT:\n+            return short.class;\n+        case Type.CHAR:\n+            return char.class;\n+        case Type.INT:\n+            return int.class;\n+        case Type.FLOAT:\n+            return float.class;\n+        case Type.LONG:\n+            return long.class;\n+        case Type.DOUBLE:\n+            return double.class;\n+        case Type.OBJECT:\n+        case Type.ARRAY:\n+            return Class.forName(t.getClassName());\n+        case Type.VOID:\n+            return void.class;\n+        }\n+        throw new RuntimeException();\n+    }\n }",
      "parent_sha": "f3ed76cca02c8b82f07841120722f4235d4800a5"
    }
  },
  {
    "oid": "e7c27aa52f60902b86f4693b2525d94c85eca767",
    "message": "(no commit message)",
    "date": "2010-07-18T15:36:42Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/e7c27aa52f60902b86f4693b2525d94c85eca767",
    "details": {
      "sha": "f43db9413377838a992da3f15499a6a7b98415fb",
      "filename": "src/main/java/pxb/android/dex2jar/reader/DexCodeReader.java",
      "status": "modified",
      "additions": 58,
      "deletions": 2,
      "changes": 60,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/e7c27aa52f60902b86f4693b2525d94c85eca767/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Freader%2FDexCodeReader.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/e7c27aa52f60902b86f4693b2525d94c85eca767/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Freader%2FDexCodeReader.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Freader%2FDexCodeReader.java?ref=e7c27aa52f60902b86f4693b2525d94c85eca767",
      "patch": "@@ -199,7 +199,35 @@ public void accept(DexCodeVisitor dcv) {\n \t\t\t\tbreak;\r\n \t\t\t}\r\n \t\t\tcase 0:// OP_NOP\r\n-\t\t\t\ti = instruction_size;\r\n+\t\t\t\tint x = in.readByte();\r\n+\t\t\t\tswitch (x) {\r\n+\t\t\t\tcase 0: // 0000 //spacer\r\n+\t\t\t\t\ti += 1;\r\n+\t\t\t\t\tbreak;\r\n+\t\t\t\tcase 1: // packed-switch-data\r\n+\t\t\t\t{\r\n+\t\t\t\t\tint switch_size = in.readShortx(); // switch_size\r\n+\t\t\t\t\t//int b = in.readIntx();// first_case\r\n+\t\t\t\t\tin.skip(4);\r\n+\t\t\t\t\tin.skip(switch_size * 4);\r\n+\t\t\t\t\ti += (1 + 2 + 4) + switch_size * 4;\r\n+\t\t\t\t\tbreak;\r\n+\t\t\t\t}\r\n+\t\t\t\tcase 2:// sparse-switch-data\r\n+\t\t\t\t{\r\n+\t\t\t\t\tint switch_size = in.readShortx();\r\n+\t\t\t\t\tin.skip(switch_size * 8);\r\n+\t\t\t\t\ti += 1 + switch_size * 8;\r\n+\t\t\t\t\tbreak;\r\n+\t\t\t\t}\r\n+\t\t\t\tcase 3: {\r\n+\t\t\t\t\tint elemWidth = in.readShortx();\r\n+\t\t\t\t\tint initLength = in.readIntx();\r\n+\t\t\t\t\tin.skip(elemWidth * initLength);\r\n+\t\t\t\t\ti += elemWidth * initLength;\r\n+\t\t\t\t\tbreak;\r\n+\t\t\t\t}\r\n+\t\t\t\t}\r\n \t\t\t\tbreak;\r\n \t\t\tcase -1: {\r\n \t\t\t\tin.skip(1);\r\n@@ -291,7 +319,35 @@ public void accept(DexCodeVisitor dcv) {\n \t\t\t\tbreak;\r\n \t\t\t}\r\n \t\t\tcase 0:// OP_NOP\r\n-\t\t\t\ti = instruction_size;\r\n+\t\t\t\tint x = in.readByte();\r\n+\t\t\t\tswitch (x) {\r\n+\t\t\t\tcase 0: // 0000 //spacer\r\n+\t\t\t\t\ti += 1;\r\n+\t\t\t\t\tbreak;\r\n+\t\t\t\tcase 1: // packed-switch-data\r\n+\t\t\t\t{\r\n+\t\t\t\t\tint switch_size = in.readShortx(); // switch_size\r\n+\t\t\t\t\t//int b = in.readIntx();// first_case\r\n+\t\t\t\t\tin.skip(4);\r\n+\t\t\t\t\tin.skip(switch_size * 4);\r\n+\t\t\t\t\ti += (1 + 2 + 4) + switch_size * 4;\r\n+\t\t\t\t\tbreak;\r\n+\t\t\t\t}\r\n+\t\t\t\tcase 2:// sparse-switch-data\r\n+\t\t\t\t{\r\n+\t\t\t\t\tint switch_size = in.readShortx();\r\n+\t\t\t\t\tin.skip(switch_size * 8);\r\n+\t\t\t\t\ti += 1 + switch_size * 8;\r\n+\t\t\t\t\tbreak;\r\n+\t\t\t\t}\r\n+\t\t\t\tcase 3: {\r\n+\t\t\t\t\tint elemWidth = in.readShortx();\r\n+\t\t\t\t\tint initLength = in.readIntx();\r\n+\t\t\t\t\tin.skip(elemWidth * initLength);\r\n+\t\t\t\t\ti += elemWidth * initLength;\r\n+\t\t\t\t\tbreak;\r\n+\t\t\t\t}\r\n+\t\t\t\t}\r\n \t\t\t\tbreak;\r\n \t\t\tcase -1: {\r\n \t\t\t\tint reg = in.readByte();\r",
      "parent_sha": "d60949012e2a4514645bc6b81d9e42e9a38f0856"
    }
  },
  {
    "oid": "4a1ea6f793d0f0662e1cccba68bfe45c26c86577",
    "message": "improve ZeroTransformer to insert x=0 if a ZERO local is merged to a non-ZERO local\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2012-11-07T13:57:36Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/4a1ea6f793d0f0662e1cccba68bfe45c26c86577",
    "details": {
      "sha": "8e2090bc7a52474f99dad2bfcb79a414ceff1425",
      "filename": "dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/ZeroTransformer.java",
      "status": "modified",
      "additions": 106,
      "deletions": 32,
      "changes": 138,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/4a1ea6f793d0f0662e1cccba68bfe45c26c86577/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FZeroTransformer.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/4a1ea6f793d0f0662e1cccba68bfe45c26c86577/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FZeroTransformer.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FZeroTransformer.java?ref=4a1ea6f793d0f0662e1cccba68bfe45c26c86577",
      "patch": "@@ -15,9 +15,10 @@\n  */\r\n package com.googlecode.dex2jar.ir.ts;\r\n \r\n-import java.util.ArrayList;\r\n import java.util.HashSet;\r\n+import java.util.LinkedList;\r\n import java.util.List;\r\n+import java.util.Queue;\r\n import java.util.Set;\r\n \r\n import com.googlecode.dex2jar.ir.Constant;\r\n@@ -31,10 +32,14 @@\n import com.googlecode.dex2jar.ir.Value.EnExpr;\r\n import com.googlecode.dex2jar.ir.Value.VT;\r\n import com.googlecode.dex2jar.ir.ValueBox;\r\n+import com.googlecode.dex2jar.ir.stmt.LabelStmt;\r\n import com.googlecode.dex2jar.ir.stmt.Stmt;\r\n import com.googlecode.dex2jar.ir.stmt.Stmt.E1Stmt;\r\n import com.googlecode.dex2jar.ir.stmt.Stmt.E2Stmt;\r\n import com.googlecode.dex2jar.ir.stmt.Stmt.EnStmt;\r\n+import com.googlecode.dex2jar.ir.stmt.Stmt.ST;\r\n+import com.googlecode.dex2jar.ir.stmt.StmtList;\r\n+import com.googlecode.dex2jar.ir.stmt.Stmts;\r\n import com.googlecode.dex2jar.ir.ts.Cfg.FrameVisitor;\r\n \r\n /**\r\n@@ -46,7 +51,7 @@ public class ZeroTransformer implements Transformer {\n \r\n     public static class Phi {\r\n         public Boolean isZero = null;\r\n-        // public Set<Phi> parents = new HashSet<Phi>();\r\n+        public Set<Phi> parents = new HashSet<Phi>();\r\n         public Set<Phi> children = new HashSet<Phi>();\r\n \r\n         @Override\r\n@@ -99,10 +104,10 @@ public void analyze() {\n         }\r\n \r\n         private void analyze0() {\r\n-            Cfg.createCFG(method);\r\n+            Cfg.createCfgForLiveAnalyze(method);\r\n             final int localSize = method.locals.size();\r\n             final Phi[] tmp = new Phi[localSize];\r\n-            final List<Phi> phis = new ArrayList<Phi>();\r\n+            final Queue<Phi> phis = new LinkedList<Phi>();\r\n             Cfg.Forward(method, new FrameVisitor<Phi[]>() {\r\n \r\n                 private Phi newPhi() {\r\n@@ -185,41 +190,52 @@ public void merge(Phi[] frame, Stmt dist) {\n                             }\r\n                             Phi a = frame[i];\r\n                             if (a != null) {\r\n-                                // b.parents.add(a);\r\n+                                b.parents.add(a);\r\n                                 a.children.add(b);\r\n                             }\r\n                         }\r\n                     }\r\n                 }\r\n             });\r\n \r\n-            markNotZeroes(phis);// mark all NOT zeroes\r\n-            for (Phi p : phis) {\r\n-                if (p.isZero == null) {\r\n-                    p.isZero = Boolean.TRUE;\r\n-                }\r\n-            }\r\n-            phis.clear();\r\n-        }\r\n+            Set<Phi> cache = new HashSet<Phi>();\r\n \r\n-        static void markNotZeroes(List<Phi> phis) {\r\n-            Set<Phi> notZeroSet = new HashSet<Phi>();\r\n-            for (Phi p : phis) {\r\n-                if (p.isZero != null && p.isZero.equals(Boolean.FALSE)) {\r\n-                    notZero(p, notZeroSet);\r\n-                }\r\n-            }\r\n-        }\r\n+            while (!phis.isEmpty()) {\r\n+                Phi phi = phis.poll();\r\n+                cache.clear();\r\n+                if (phi.isZero == null) {\r\n+                    if (phi.parents.size() > 0) {\r\n+                        boolean isZero = true;\r\n \r\n-        static void notZero(Phi p, Set<Phi> notZeroSet) {\r\n-            if (!notZeroSet.contains(p)) {\r\n-                notZeroSet.add(p);\r\n-                if (p.isZero != null && Boolean.TRUE.equals(p.isZero)) {\r\n-                    throw new RuntimeException();\r\n+                        for (Phi parent : phi.parents) {\r\n+                            if (!Boolean.TRUE.equals(parent.isZero)) {\r\n+                                isZero = false;\r\n+                                break;\r\n+                            }\r\n+                        }\r\n+                        if (isZero) {\r\n+                            phi.isZero = Boolean.TRUE;\r\n+                            for (Phi child : phi.children) {\r\n+                                if (child.isZero == null) {\r\n+                                    cache.add(child);\r\n+                                }\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                } else {\r\n+                    if (Boolean.FALSE.equals(phi.isZero)) {\r\n+                        for (Phi child : phi.children) {\r\n+                            if (child.isZero == null) {\r\n+                                cache.add(child);\r\n+                            }\r\n+                            child.isZero = Boolean.FALSE;\r\n+                        }\r\n+                    }\r\n                 }\r\n-                p.isZero = Boolean.FALSE;\r\n-                for (Phi s : p.children) {\r\n-                    notZero(s, notZeroSet);\r\n+                for (Phi x : cache) {\r\n+                    if (!phis.contains(x)) {\r\n+                        phis.add(x);\r\n+                    }\r\n                 }\r\n             }\r\n         }\r\n@@ -229,18 +245,36 @@ static void notZero(Phi p, Set<Phi> notZeroSet) {\n \r\n     @Override\r\n     public void transform(IrMethod irMethod) {\r\n-\r\n+        // 1. analyze\r\n         ZeroAnalyze za = new ZeroAnalyze(irMethod);\r\n         za.analyze();\r\n \r\n-        for (Stmt p = irMethod.stmts.getFirst(); p != null; p = p.getNext()) {\r\n+        List<Local> locals = irMethod.locals;\r\n+        int localSize = locals.size();\r\n+        StmtList stmts = irMethod.stmts;\r\n+        // 2. mark MUST-BE-ZERO\r\n+        for (Stmt p = stmts.getFirst(); p != null; p = p.getNext()) {\r\n             Phi[] frame = (Phi[]) p._ls_forward_frame;\r\n-            p._ls_forward_frame = null;\r\n             if (frame == null || !p._cfg_visited) {// dead code ?\r\n                 continue;\r\n             }\r\n             switch (p.et) {\r\n             case E0:\r\n+                if (p.st == ST.LABEL) {\r\n+                    if (p._cfg_froms.size() > 0) { // there is a merge here\r\n+                        for (int i = 0; i < localSize; i++) {\r\n+                            Phi phi = frame[i];\r\n+                            Local local = locals.get(i);\r\n+                            if (phi != null && phi.isZero != null && phi.isZero) {// the local is not null\r\n+                                for (Stmt from : p._cfg_froms) {// check for each from\r\n+                                    if (needInsertX(from, i)) {\r\n+                                        insertX(stmts, (LabelStmt) p, from, i, local);\r\n+                                    }\r\n+                                }\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                }\r\n                 break;\r\n             case E1:\r\n                 E1Stmt e1 = (E1Stmt) p;\r\n@@ -263,6 +297,46 @@ public void transform(IrMethod irMethod) {\n         }\r\n     }\r\n \r\n+    private void insertX(StmtList stmts, LabelStmt ls, Stmt p, int index, Local local) {\r\n+        switch (p.st) {\r\n+        case GOTO:\r\n+        case IF:\r\n+        case LOOKUP_SWITCH:\r\n+        case TABLE_SWITCH:\r\n+            while (p != null) {\r\n+                Stmt q = p.getPre();\r\n+                if (q == null || q.st != ST.LABEL) {// insert before any label\r\n+                    stmts.insertBefore(p, Stmts.nAssign(local, Constant.nInt(0)));\r\n+                    break;\r\n+                }\r\n+                p = q;\r\n+            }\r\n+            break;\r\n+        default:\r\n+            // TODO check if we need to insert for other smt\r\n+            // stmts.insertAfter(p, Stmts.nAssign(local, Constant.nInt(0)));\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * if the phi in frame p is ZERO, return true\r\n+     * \r\n+     * @param p\r\n+     * @param index\r\n+     * @return\r\n+     */\r\n+    private boolean needInsertX(Stmt p, int index) {\r\n+        Phi[] frame = (Phi[]) p._ls_forward_frame;\r\n+        if (frame == null) {\r\n+            return false;\r\n+        }\r\n+        Phi phi = frame[index];\r\n+        if (phi == null || phi.isZero == null) {\r\n+            return false;\r\n+        }\r\n+        return phi.isZero;\r\n+    }\r\n+\r\n     private void replace(ValueBox op, Phi[] frame) {\r\n         if (op == null) {\r\n             return;\r",
      "parent_sha": "a5acd1d5c8ce9024e06a32ceb1e9c19be28d7aa4"
    }
  },
  {
    "oid": "7f8376d96db980e3df9828edbb61b6dd275f8d4d",
    "message": "1.\u4fee\u590dcase OP_FILLED_NEW_ARRAY_RANGE\u4e22\u5931\u7684break;\n\n\nFixes issue 14\nthank you beanchx\n\n--HG--\nbranch : 0.0.7",
    "date": "2010-04-12T06:47:49Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/7f8376d96db980e3df9828edbb61b6dd275f8d4d",
    "details": {
      "sha": "0101e57c35c1d781b785dcf9231b7ddde76d0338",
      "filename": "src/main/java/pxb/android/dex2jar/reader/DexOpcodeAdapter.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/7f8376d96db980e3df9828edbb61b6dd275f8d4d/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Freader%2FDexOpcodeAdapter.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/7f8376d96db980e3df9828edbb61b6dd275f8d4d/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Freader%2FDexOpcodeAdapter.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Freader%2FDexOpcodeAdapter.java?ref=7f8376d96db980e3df9828edbb61b6dd275f8d4d",
      "patch": "@@ -449,8 +449,8 @@ public void visit(int opcode, int arg1, int arg2, int arg3) {\n \t\t\t\targs[i] = arg3 + i;\r\n \t\t\t}\r\n \t\t\tdcv.visitFilledNewArrayIns(OP_FILLED_NEW_ARRAY, dex.getType(arg2), args);\r\n-\r\n \t\t}\r\n+\t\t\tbreak;\r\n \t\tdefault:\r\n \t\t\tthrow new RuntimeException(String.format(\"Not support Opcode :[0x%04x] = %s\", opcode, DexOpcodeDump.dump(opcode)));\r\n \t\t}\r",
      "parent_sha": "d5fe7809ab275dd707782749bcc9b90fa471ecde"
    }
  },
  {
    "oid": "363489455b14c36756b0196560e6b7e7e1bc15fd",
    "message": "maks ZipInputStreamHack for openjdk6\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2013-04-26T02:53:48Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/363489455b14c36756b0196560e6b7e7e1bc15fd",
    "details": {
      "sha": "1cef3dd77a418633c9410e946c7dc69fdaf34a8e",
      "filename": "dex-reader/src/main/java/com/googlecode/dex2jar/reader/ZipInputStreamHack.java",
      "status": "modified",
      "additions": 38,
      "deletions": 5,
      "changes": 43,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/363489455b14c36756b0196560e6b7e7e1bc15fd/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FZipInputStreamHack.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/363489455b14c36756b0196560e6b7e7e1bc15fd/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FZipInputStreamHack.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FZipInputStreamHack.java?ref=363489455b14c36756b0196560e6b7e7e1bc15fd",
      "patch": "@@ -21,9 +21,11 @@\n import java.util.zip.ZipInputStream;\n \n /**\n- * A hack to the ZipInputStream, clean the encrypted-bit flag before checking. from the code we know the\n- * {@link #createZipEntry(String)} is always invoked before the check, so this class will change\n- * {@link ZipInputStream#flag} in {@link #createZipEntry(String)} using reflection API\n+ * A hack to the ZipInputStream, clean the encrypted-bit flag before checking.\n+ * \n+ * from the code we know the {@link #createZipEntry(String)} is always invoked before the check in openjdk7, and in\n+ * openjdk6 flag is read from tmpbuf after {@link #createZipEntry(String)} , so this class will change\n+ * {@link ZipInputStream#flag} and {@link ZipInputStream#tmpbuf} in {@link #createZipEntry(String)} using reflection API\n  * \n  * <pre>\n  * // here are the code from openjdk-7\n@@ -37,18 +39,39 @@\n  * e.time = get32(tmpbuf, LOCTIM);\n  * </pre>\n  * \n+ * <pre>\n+ * // here are the code from openjdk-6\n+ * ZipEntry e = createZipEntry(getUTF8String(b, 0, len));\n+ * // now get the remaining fields for the entry\n+ * flag = get16(tmpbuf, LOCFLG);\n+ * if ((flag &amp; 1) == 1) {\n+ *     throw new ZipException(&quot;encrypted ZIP entry not supported&quot;);\n+ * }\n+ * e.method = get16(tmpbuf, LOCHOW);\n+ * e.time = get32(tmpbuf, LOCTIM);\n+ * </pre>\n+ * \n  * @author Panxiaobo\n  * \n  */\n public class ZipInputStreamHack extends ZipInputStream {\n     static java.lang.reflect.Field flagField;\n+    static java.lang.reflect.Field tmpbufField;\n+\n     static {\n         try {\n             flagField = ZipInputStream.class.getDeclaredField(\"flag\");\n             flagField.setAccessible(true);\n         } catch (Exception ignored) {\n \n         }\n+        try {\n+            tmpbufField = ZipInputStream.class.getDeclaredField(\"tmpbuf\");\n+            tmpbufField.setAccessible(true);\n+        } catch (Exception ignored) {\n+\n+        }\n+\n     }\n \n     public ZipInputStreamHack(InputStream in) {\n@@ -57,15 +80,25 @@ public ZipInputStreamHack(InputStream in) {\n \n     @Override\n     protected ZipEntry createZipEntry(String name) {\n-        if (flagField != null) {\n+        if (flagField != null) { // for openjdk7\n             try {\n                 int flag = (Integer) flagField.get(this);\n                 flagField.set(this, (flag >> 1) << 1);\n             } catch (Exception e) {\n \n             }\n         }\n+        if (tmpbufField != null) {// for openjdk6\n+            try {\n+                byte[] buffer = (byte[]) flagField.get(this);\n+                int flagLow8 = buffer[6];// 6 is for LOCFLG\n+                flagLow8 = (flagLow8 >> 1) << 1;\n+                buffer[6] = (byte) flagLow8;\n+            } catch (Exception e) {\n+\n+            }\n+        }\n+\n         return super.createZipEntry(name);\n     }\n-\n }",
      "parent_sha": "149e09cba3da57111e105d4dc042459dce852cea"
    }
  },
  {
    "oid": "4aec75ddb45b82a623ea29521ec2f8c6edadc461",
    "message": "for http://sourceforge.net/p/dex2jar/tickets/233/\nmark hasException public\n\n--HG--\nbranch : 2.x",
    "date": "2014-12-23T04:59:04Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/4aec75ddb45b82a623ea29521ec2f8c6edadc461",
    "details": {
      "sha": "cead986201a1584df9fc0f3dca9002179fe0b29f",
      "filename": "dex-tools/src/main/java/com/googlecode/dex2jar/tools/BaksmaliBaseDexExceptionHandler.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/4aec75ddb45b82a623ea29521ec2f8c6edadc461/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FBaksmaliBaseDexExceptionHandler.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/4aec75ddb45b82a623ea29521ec2f8c6edadc461/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FBaksmaliBaseDexExceptionHandler.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FBaksmaliBaseDexExceptionHandler.java?ref=4aec75ddb45b82a623ea29521ec2f8c6edadc461",
      "patch": "@@ -42,7 +42,7 @@ public class BaksmaliBaseDexExceptionHandler extends BaseDexExceptionHandler {\n     private Map<DexMethodNode, Exception> exceptionMap = new HashMap<>();\n     private List<Exception> fileExceptions = new ArrayList<>();\n \n-    boolean hasException() {\n+    public boolean hasException() {\n         return exceptionMap.size() > 0 || fileExceptions.size() > 0;\n     }\n ",
      "parent_sha": "72e45b5039c4538417992290e20efa40dfc6d97b"
    }
  },
  {
    "oid": "4cf5d6dd4350af6a1ea48644c4f32e1d581bd2b1",
    "message": "Revert \"keep mapItem even if size is 0\"\n\n--HG--\nbranch : 2.x",
    "date": "2015-04-23T08:09:07Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/4cf5d6dd4350af6a1ea48644c4f32e1d581bd2b1",
    "details": {
      "sha": "29fb70675261ef0341004a4eea67628bd8ebf7e8",
      "filename": "dex-writer/src/main/java/com/googlecode/d2j/dex/writer/DexFileWriter.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/4cf5d6dd4350af6a1ea48644c4f32e1d581bd2b1/dex-writer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2Fwriter%2FDexFileWriter.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/4cf5d6dd4350af6a1ea48644c4f32e1d581bd2b1/dex-writer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2Fwriter%2FDexFileWriter.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-writer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2Fwriter%2FDexFileWriter.java?ref=4cf5d6dd4350af6a1ea48644c4f32e1d581bd2b1",
      "patch": "@@ -252,8 +252,7 @@ private void write(DataOut out) {\n \n     private int place() {\n         // 2. order\n-        // keep mapItem even if size is 0\n-        // mapItem.cleanZeroSizeEntry();\n+        mapItem.cleanZeroSizeEntry();\n \n         // 3. place\n         int offset = 0;",
      "parent_sha": "184407aa2642d0c514f8c3bc393dba27d7f7253b"
    }
  },
  {
    "oid": "62691b673f3b31cfd3b916faad8463bca909c200",
    "message": "Fixes issue 38\n\n--HG--\nbranch : 0.0.7",
    "date": "2010-12-27T17:34:26Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/62691b673f3b31cfd3b916faad8463bca909c200",
    "details": {
      "sha": "052018ad87f90f856595ff97c31f8249c1abb655",
      "filename": "src/main/java/pxb/android/dex2jar/reader/DexOpcodeAdapter.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/62691b673f3b31cfd3b916faad8463bca909c200/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Freader%2FDexOpcodeAdapter.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/62691b673f3b31cfd3b916faad8463bca909c200/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Freader%2FDexOpcodeAdapter.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Freader%2FDexOpcodeAdapter.java?ref=62691b673f3b31cfd3b916faad8463bca909c200",
      "patch": "@@ -460,7 +460,7 @@ public void visit(int opcode, int arg1, int arg2, int arg3) {\n \t\t\tdcv.visitFilledNewArrayIns(OP_FILLED_NEW_ARRAY, dex.getType(arg2 & 0xFFFF), args);\r\n \t\t}\r\n \t\tcase OP_CONST_STRING_JUMBO: {\r\n-\t\t\tdcv.visitLdcInsn(OP_CONST_STRING, dex.getString((arg3 << 16) | (arg2 & 0xFFFF)), arg1);\r\n+\t\t\tdcv.visitLdcInsn(OP_CONST_STRING, dex.getString(((arg3 << 16) & 0xFFFF) | (arg2 & 0xFFFF)), arg1);\r\n \t\t}\r\n \t\t\tbreak;\r\n \t\tdefault:\r",
      "parent_sha": "265d108a2b9559eb3e35350b459a2f2356883bbc"
    }
  },
  {
    "oid": "9d6c4432eed76d96f39a394136f00bc05800e5fc",
    "message": "1.\u4fee\u590d\u5904\u7406\u5185\u90e8\u7c7b\u65f6\u7684\u4e00\u4e2aNPE\uff0c\n\nFixes  issue 21",
    "date": "2010-07-26T16:52:20Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/9d6c4432eed76d96f39a394136f00bc05800e5fc",
    "details": {
      "sha": "f6ee23db430548c6aa59de5e6ec329584eeffeaf",
      "filename": "src/main/java/pxb/android/dex2jar/v3/V3ClassAdapter.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/9d6c4432eed76d96f39a394136f00bc05800e5fc/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Fv3%2FV3ClassAdapter.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/9d6c4432eed76d96f39a394136f00bc05800e5fc/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Fv3%2FV3ClassAdapter.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Fv3%2FV3ClassAdapter.java?ref=9d6c4432eed76d96f39a394136f00bc05800e5fc",
      "patch": "@@ -58,7 +58,8 @@ protected void build() {\n \t\t\t\t\t\t\t\tInteger access = accessFlagsMap.get(name);\r\n \t\t\t\t\t\t\t\tint d = name.lastIndexOf('$');\r\n \t\t\t\t\t\t\t\tString innerName = name.substring(d + 1, name.length() - 1);\r\n-\t\t\t\t\t\t\t\tcv.visitInnerClass(name, className, innerName, access);\r\n+\t\t\t\t\t\t\t\t// TODO\u8bbe\u7f6e\u9ed8\u8ba4\u5185\u90e8\u7c7b\u4fee\u9970\u7b26\r\n+\t\t\t\t\t\t\t\tcv.visitInnerClass(name, className, innerName, access == null ? 0 : access);\r\n \t\t\t\t\t\t\t}\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t}\r\n@@ -99,8 +100,7 @@ protected void build() {\n \t * @param superClass\r\n \t * @param interfaceNames\r\n \t */\r\n-\tpublic V3ClassAdapter(Map<String, Integer> accessFlagsMap, ClassVisitor cv, int access_flags, String className,\r\n-\t\t\tString superClass, String[] interfaceNames) {\r\n+\tpublic V3ClassAdapter(Map<String, Integer> accessFlagsMap, ClassVisitor cv, int access_flags, String className, String superClass, String[] interfaceNames) {\r\n \t\tsuper();\r\n \t\tthis.accessFlagsMap = accessFlagsMap;\r\n \t\tthis.cv = new TypeNameAdapter(cv);\r",
      "parent_sha": "a6e82a9d23e35baf238e05286dcacb4d72a2a199"
    }
  },
  {
    "oid": "a12de2bf55b3e9e709d8251adf91957d075f83a2",
    "message": "keep mapItem even if size is 0\n\n--HG--\nbranch : 2.x",
    "date": "2015-04-07T14:02:24Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/a12de2bf55b3e9e709d8251adf91957d075f83a2",
    "details": {
      "sha": "38320e6a48939f2c1c93f4c3154b470b95440ea0",
      "filename": "dex-writer/src/main/java/com/googlecode/d2j/dex/writer/DexFileWriter.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/a12de2bf55b3e9e709d8251adf91957d075f83a2/dex-writer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2Fwriter%2FDexFileWriter.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/a12de2bf55b3e9e709d8251adf91957d075f83a2/dex-writer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2Fwriter%2FDexFileWriter.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-writer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2Fwriter%2FDexFileWriter.java?ref=a12de2bf55b3e9e709d8251adf91957d075f83a2",
      "patch": "@@ -252,7 +252,8 @@ private void write(DataOut out) {\n \n     private int place() {\n         // 2. order\n-        mapItem.cleanZeroSizeEntry();\n+        // keep mapItem even if size is 0\n+        // mapItem.cleanZeroSizeEntry();\n \n         // 3. place\n         int offset = 0;",
      "parent_sha": "e538645d2c35fd09a562e03b29f28a6e934b052a"
    }
  },
  {
    "oid": "d6191ffa79087e80fcacb2c94af9ec4290812385",
    "message": "support debug signature\nfix field signature reading error\n\n--HG--\nbranch : 2.x",
    "date": "2014-08-17T07:34:31Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/d6191ffa79087e80fcacb2c94af9ec4290812385",
    "details": {
      "sha": "894a7d86dad6c6b5e07c13b30e6ec38fe61bce36",
      "filename": "dex-tools/src/main/java/com/googlecode/d2j/map/DexMappingAdapter.java",
      "status": "modified",
      "additions": 13,
      "deletions": 9,
      "changes": 22,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/d6191ffa79087e80fcacb2c94af9ec4290812385/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fmap%2FDexMappingAdapter.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/d6191ffa79087e80fcacb2c94af9ec4290812385/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fmap%2FDexMappingAdapter.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fmap%2FDexMappingAdapter.java?ref=d6191ffa79087e80fcacb2c94af9ec4290812385",
      "patch": "@@ -219,11 +219,13 @@ public MappingCode(Mapper mapper, DexCodeVisitor dcv) {\n         public DexDebugVisitor visitDebug() {\n             DexDebugVisitor v = super.visitDebug();\n             if (v != null) {\n-                return new DexDebugVisitor() {\n+                return new DexDebugVisitor(v) {\n                     @Override\n                     public void visitStartLocal(int reg, DexLabel label, String name, String type, String signature) {\n-                        // FIXME map signature\n-                        super.visitStartLocal(reg, label, name, mapClassName(mapper, type), null);\n+                        if (signature != null) {\n+                            signature = remapSignature(mapper, signature, true);\n+                        }\n+                        super.visitStartLocal(reg, label, name, mapClassName(mapper, type), signature);\n                     }\n                 };\n             }\n@@ -395,7 +397,7 @@ public DexAnnotationVisitor visitAnnotation(String name, Visibility visibility)\n                         public void visitEnd() {\n                             super.visitEnd();\n                             Item p = super.items.get(0);\n-                            Object[] newVs = remapSignature(mapper, (Object[]) p.value, false);\n+                            Object[] newVs = remapSignature(mapper, (Object[]) p.value, true);\n                             dav.visit(p.name, newVs);\n                             dav.visitEnd();\n                         }\n@@ -462,14 +464,17 @@ public DexAnnotationVisitor visitAnnotation(String name, Visibility visibility)\n             }\n             return a;\n         }\n-\n     }\n \n     static Object[] remapSignature(final Mapper mapper, Object vs[], boolean isType) {\n         StringBuilder sb = new StringBuilder();\n         for (Object v0 : vs) {\n             sb.append(v0);\n         }\n+        return Types.buildDexStyleSignature(remapSignature(mapper, sb.toString(), isType));\n+    }\n+\n+    static String remapSignature(final Mapper mapper, String sig, boolean isType) {\n         SignatureWriter w = new SignatureWriter() {\n             String clzName;\n \n@@ -504,11 +509,10 @@ public void visitInnerClassType(String simpleName) {\n             }\n         };\n         if (isType) {\n-            new SignatureReader(sb.toString()).acceptType(w);\n+            new SignatureReader(sig).acceptType(w);\n         } else {\n-            new SignatureReader(sb.toString()).accept(w);\n+            new SignatureReader(sig).accept(w);\n         }\n-        String newSignature = w.toString();\n-        return Types.buildDexStyleSignature(newSignature);\n+        return w.toString();\n     }\n }",
      "parent_sha": "35168af75377dd1ed5276589e9999d4f65f5be12"
    }
  },
  {
    "oid": "3f3cdc3a1893051e7c89815b824c5e8060b4ddfa",
    "message": "(no commit message)",
    "date": "2010-04-02T17:01:55Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/3f3cdc3a1893051e7c89815b824c5e8060b4ddfa",
    "details": {
      "sha": "66211dd1df85e90d0ac2bff30e58842009d66ca0",
      "filename": "src/main/java/pxb/android/dex2jar/v3/V3MethodAdapter.java",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/3f3cdc3a1893051e7c89815b824c5e8060b4ddfa/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Fv3%2FV3MethodAdapter.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/3f3cdc3a1893051e7c89815b824c5e8060b4ddfa/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Fv3%2FV3MethodAdapter.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Fv3%2FV3MethodAdapter.java?ref=3f3cdc3a1893051e7c89815b824c5e8060b4ddfa",
      "patch": "@@ -149,13 +149,13 @@ public void visitEnd() {\n \t\t\t\ttr.transform(methodNode);\r\n \t\t\t}\r\n \r\n-\t\t\tAnalyzer a = new Analyzer(new BasicInterpreter());\r\n-\t\t\ttry {\r\n-\t\t\t\ta.analyze(method.getOwner(), methodNode);\r\n-\t\t\t} catch (AnalyzerException e) {\r\n-\t\t\t\tthrow new RuntimeException(\"fail on \" + method, e);\r\n-\t\t\t}\r\n-\t\t\tFrame[] fs = a.getFrames();\r\n+//\t\t\tAnalyzer a = new Analyzer(new BasicInterpreter());\r\n+//\t\t\ttry {\r\n+//\t\t\t\ta.analyze(method.getOwner(), methodNode);\r\n+//\t\t\t} catch (AnalyzerException e) {\r\n+//\t\t\t\tthrow new RuntimeException(\"fail on \" + method, e);\r\n+//\t\t\t}\r\n+//\t\t\tFrame[] fs = a.getFrames();\r\n \r\n \t\t\tmethodNode.accept(new LocalVariablesSorter(method.getAccessFlags(), method.getType().getDesc(), new LdcOptimizeAdapter(mv)));\r\n \r",
      "parent_sha": "3bc703f3f07f5da772c0e36151bc05aff72fa16e"
    }
  },
  {
    "oid": "8356bbc7c62c06e262208d3f57eec606eab42b95",
    "message": "1.\u9488\u5bf9OP_ADD_INT_LIT8\u4f18\u5316\n\n--HG--\nbranch : 0.0.7",
    "date": "2010-04-10T16:35:00Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/8356bbc7c62c06e262208d3f57eec606eab42b95",
    "details": {
      "sha": "4cd8820beefbe7af21fc7593aca6b7f743e49c6f",
      "filename": "src/main/java/pxb/android/dex2jar/v3/V3CodeAdapter.java",
      "status": "modified",
      "additions": 12,
      "deletions": 5,
      "changes": 17,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/8356bbc7c62c06e262208d3f57eec606eab42b95/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Fv3%2FV3CodeAdapter.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/8356bbc7c62c06e262208d3f57eec606eab42b95/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Fv3%2FV3CodeAdapter.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Fv3%2FV3CodeAdapter.java?ref=8356bbc7c62c06e262208d3f57eec606eab42b95",
      "patch": "@@ -677,11 +677,18 @@ public void visitInInsn(int opcode, int saveToReg, int opReg, int opValueOrReg)\n \t\tcase OP_XOR_INT_LIT8:\r\n \t\tcase OP_DIV_INT_LIT8:\r\n \t\tcase OP_MUL_INT_LIT8: {\r\n-\t\t\tmv.visitVarInsn(ILOAD, map(opReg));\r\n-\t\t\tmv.visitLdcInsn(opValueOrReg);\r\n-\t\t\tmv.visitInsn(DexOpcodeUtil.mapOpcode(opcode));\r\n-\t\t\tmv.visitVarInsn(ISTORE, map(saveToReg));\r\n-\t\t\tstack(2);\r\n+\t\t\tif (OP_ADD_INT_LIT8 == opcode && opReg == saveToReg) {\r\n+\t\t\t\t// \u9488\u5bf9 a=a+1\r\n+\t\t\t\tmv.visitIincInsn(map(opReg), opValueOrReg);\r\n+\t\t\t\tstack(0);\r\n+\t\t\t}\r\n+\t\t\telse {\r\n+\t\t\t\tmv.visitVarInsn(ILOAD, map(opReg));\r\n+\t\t\t\tmv.visitLdcInsn(opValueOrReg);\r\n+\t\t\t\tmv.visitInsn(DexOpcodeUtil.mapOpcode(opcode));\r\n+\t\t\t\tmv.visitVarInsn(ISTORE, map(saveToReg));\r\n+\t\t\t\tstack(2);\r\n+\t\t\t}\r\n \t\t}\r\n \t\t\tbreak;\r\n \r",
      "parent_sha": "7f2e527f46449ac9a6738cbd8debc209bfba2999"
    }
  },
  {
    "oid": "5cf0fd9357e322c2df48d6b489a56805eb623b74",
    "message": "\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2011-11-04T05:21:16Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/5cf0fd9357e322c2df48d6b489a56805eb623b74",
    "details": {
      "sha": "81749c792f0e739cd63804f7edf89673d9cba756",
      "filename": "dex-translator/src/main/java/com/googlecode/dex2jar/v3/V3AccessFlagsAdapter.java",
      "status": "modified",
      "additions": 4,
      "deletions": 20,
      "changes": 24,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/5cf0fd9357e322c2df48d6b489a56805eb623b74/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FV3AccessFlagsAdapter.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/5cf0fd9357e322c2df48d6b489a56805eb623b74/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FV3AccessFlagsAdapter.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FV3AccessFlagsAdapter.java?ref=5cf0fd9357e322c2df48d6b489a56805eb623b74",
      "patch": "@@ -24,13 +24,11 @@\n \r\n import com.googlecode.dex2jar.Annotation;\r\n import com.googlecode.dex2jar.Annotation.Item;\r\n-import com.googlecode.dex2jar.Field;\r\n import com.googlecode.dex2jar.Method;\r\n import com.googlecode.dex2jar.visitors.DexAnnotationVisitor;\r\n import com.googlecode.dex2jar.visitors.DexClassVisitor;\r\n-import com.googlecode.dex2jar.visitors.DexFieldVisitor;\r\n import com.googlecode.dex2jar.visitors.DexFileVisitor;\r\n-import com.googlecode.dex2jar.visitors.DexMethodVisitor;\r\n+import com.googlecode.dex2jar.visitors.EmptyVisitor;\r\n \r\n /**\r\n  * @author Panxiaobo [pxb1988@gmail.com]\r\n@@ -40,7 +38,7 @@ public class V3AccessFlagsAdapter implements DexFileVisitor {\n     private Map<String, Integer> map = new HashMap<String, Integer>();\r\n     private Map<String, String> innerNameMap = new HashMap<String, String>();\r\n \r\n-    private Map<String, Set<String>> extraMember = new HashMap();\r\n+    private Map<String, Set<String>> extraMember = new HashMap<String, Set<String>>();\r\n \r\n     /**\r\n      * @return the innerNameMap\r\n@@ -65,7 +63,7 @@ public Map<String, Set<String>> getExtraMember() {\n      */\r\n     public DexClassVisitor visit(int access_flags, final String className, String superClass, String[] interfaceNames) {\r\n \r\n-        return new DexClassVisitor() {\r\n+        return new EmptyVisitor() {\r\n             protected List<Annotation> anns = new ArrayList<Annotation>();\r\n \r\n             @Override\r\n@@ -75,20 +73,6 @@ public DexAnnotationVisitor visitAnnotation(String name, boolean visible) {\n                 return new V3AnnAdapter(ann);\r\n             }\r\n \r\n-            @Override\r\n-            public void visitSource(String file) {\r\n-            }\r\n-\r\n-            @Override\r\n-            public DexMethodVisitor visitMethod(int accessFlags, Method method) {\r\n-                return null;\r\n-            }\r\n-\r\n-            @Override\r\n-            public DexFieldVisitor visitField(int accessFlags, Field field, Object value) {\r\n-                return null;\r\n-            }\r\n-\r\n             @Override\r\n             public void visitEnd() {\r\n                 String enclosingClass = null;\r\n@@ -118,7 +102,7 @@ public void visitEnd() {\n                                 if (it.value == null) {\r\n                                     Set<String> set = extraMember.get(enclosingClass);\r\n                                     if (set == null) {\r\n-                                        set = new TreeSet();\r\n+                                        set = new TreeSet<String>();\r\n                                         extraMember.put(enclosingClass, set);\r\n                                     }\r\n                                     set.add(className);\r",
      "parent_sha": "8b908c5e2048044d384294d031e103a23082ed18"
    }
  },
  {
    "oid": "f8d4ac31a822c00c07287c38e8004f07d067e485",
    "message": "make RETURN stmt throw because the contained expr may throw.\n\n\nFixes issue 121\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2012-06-12T13:28:15Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/f8d4ac31a822c00c07287c38e8004f07d067e485",
    "details": {
      "sha": "7d7e14b5cdb0d3b84b24c5909ec6a68213a444e6",
      "filename": "dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/Cfg.java",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/f8d4ac31a822c00c07287c38e8004f07d067e485/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FCfg.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/f8d4ac31a822c00c07287c38e8004f07d067e485/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FCfg.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FCfg.java?ref=f8d4ac31a822c00c07287c38e8004f07d067e485",
      "patch": "@@ -100,7 +100,6 @@ private static boolean notThrow(Value s) {\n     public static boolean notThrow(Stmt s) {\r\n         switch (s.st) {\r\n         case LABEL:\r\n-        case RETURN:\r\n         case RETURN_VOID:\r\n         case GOTO:\r\n         case NOP:\r\n@@ -111,8 +110,7 @@ public static boolean notThrow(Stmt s) {\n             return notThrow(e2.op1.value) && notThrow(e2.op2.value);\r\n         case TABLE_SWITCH:\r\n         case LOOKUP_SWITCH:\r\n-            E1Stmt s1 = (E1Stmt) s;\r\n-            return notThrow(s1.op.value);\r\n+        case RETURN:\r\n         case IF:\r\n             return notThrow(((E1Stmt) s).op.value);\r\n         }\r",
      "parent_sha": "c980842ef0edddc20edf8915eac5dbf15198e84a"
    }
  },
  {
    "oid": "5a2f61965c6e7a957405836b73d9012f418dc604",
    "message": "fix search for smalis on ideaj",
    "date": "2018-03-27T03:40:08Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/5a2f61965c6e7a957405836b73d9012f418dc604",
    "details": {
      "sha": "ba41bb86b6649c3f24a61ed781e86b438b3d633f",
      "filename": "dex-translator/src/test/java/com/googlecode/dex2jar/test/Smali2jTest.java",
      "status": "modified",
      "additions": 9,
      "deletions": 1,
      "changes": 10,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/5a2f61965c6e7a957405836b73d9012f418dc604/dex-translator%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftest%2FSmali2jTest.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/5a2f61965c6e7a957405836b73d9012f418dc604/dex-translator%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftest%2FSmali2jTest.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftest%2FSmali2jTest.java?ref=5a2f61965c6e7a957405836b73d9012f418dc604",
      "patch": "@@ -67,7 +67,15 @@ public void init(final Class<?> testClass) throws InitializationError {\n             String dirx = file.substring(0, file.length() - testClass.getName().length() - \".class\".length());\n \n             System.out.println(\"dirx is \" + dirx);\n-            final Path basePath = new File(dirx, \"smalis\").toPath();\n+            Path dirxpath = new File(dirx).toPath();\n+\n+            Path basePath0 = dirxpath.resolve(\"smalis\");\n+            if (!Files.exists(basePath0)) {\n+                basePath0 = dirxpath.resolve(\"../resources/smalis/\");\n+            }\n+\n+            final Path basePath = basePath0;\n+\n             final Set<Path> files = new TreeSet<>();\n             try {\n                 Files.walkFileTree(basePath, new SimpleFileVisitor<Path>() {",
      "parent_sha": "31ff5bba8ca45ccb22482e4a75e02467cb0c327b"
    }
  },
  {
    "oid": "f8ad4dc98ece7128c7033c3d611713f6a6998aea",
    "message": "replace to 'throw new NegativeArraySizeException()' when init a nagative size array\n\n--HG--\nbranch : 2.x",
    "date": "2015-12-02T14:44:08Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/f8ad4dc98ece7128c7033c3d611713f6a6998aea",
    "details": {
      "sha": "7236fc525d909395b3c32a7c0700b08f15b8d9e8",
      "filename": "dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/NpeTransformer.java",
      "status": "modified",
      "additions": 43,
      "deletions": 1,
      "changes": 44,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/f8ad4dc98ece7128c7033c3d611713f6a6998aea/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FNpeTransformer.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/f8ad4dc98ece7128c7033c3d611713f6a6998aea/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FNpeTransformer.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FNpeTransformer.java?ref=f8ad4dc98ece7128c7033c3d611713f6a6998aea",
      "patch": "@@ -37,6 +37,7 @@ private static class MustThrowException extends RuntimeException {\n \n     private static final MustThrowException NPE = new MustThrowException();\n     private static final MustThrowException DIVE = new MustThrowException();\n+    private static final MustThrowException NEGATIVE_ARRAY_SIZE = new MustThrowException();\n \n     @Override\n     public boolean transformReportChanged(IrMethod method) {\n@@ -94,6 +95,24 @@ public void travel(Value op) {\n                             }\n                         }\n                         break;\n+                    case NEW_ARRAY:\n+                        if (op.getOp().vt == Value.VT.CONSTANT) {\n+                            Constant constant = (Constant) op.getOp();\n+                            if (((Number) constant.value).intValue() < 0) {\n+                                throw NEGATIVE_ARRAY_SIZE;\n+                            }\n+                        }\n+                        break;\n+                    case NEW_MUTI_ARRAY:\n+                        for (Value size : op.getOps()) {\n+                            if (size.vt == Value.VT.CONSTANT) {\n+                                Constant constant = (Constant) size;\n+                                if (((Number) constant.value).intValue() < 0) {\n+                                    throw NEGATIVE_ARRAY_SIZE;\n+                                }\n+                            }\n+                        }\n+                        break;\n                 default:\n                 }\n             }\n@@ -162,6 +181,26 @@ public Value travel(Value op) {\n                             }\n                         }\n                         break;\n+                    case NEW_ARRAY:\n+                        if (op.getOp().vt == Value.VT.CONSTANT) {\n+                            Constant constant = (Constant) op.getOp();\n+                            if (((Number) constant.value).intValue() < 0) {\n+                                throw NEGATIVE_ARRAY_SIZE;\n+                            }\n+                        }\n+                        break;\n+                    case NEW_MUTI_ARRAY:\n+                        for (Value size : op.getOps()) {\n+                            if (size.vt == Value.VT.CONSTANT) {\n+                                Constant constant = (Constant) size;\n+                                if (((Number) constant.value).intValue() < 0) {\n+                                    throw NEGATIVE_ARRAY_SIZE;\n+                                }else {\n+                                    travel(size);\n+                                }\n+                            }\n+                        }\n+                        break;\n                 default:\n                 }\n                 Value sop = super.travel(op);\n@@ -216,9 +255,12 @@ public Value travel(Value op) {\n             if (e == NPE) {\n                 m.stmts.insertBefore(p,\n                         Stmts.nThrow(Exprs.nInvokeNew(new Value[0], new String[0], \"Ljava/lang/NullPointerException;\")));\n-            } else {\n+            } else if (e == DIVE) {\n                 m.stmts.insertBefore(p,\n                         Stmts.nThrow(Exprs.nInvokeNew(new Value[]{Exprs.nString(\"divide by zero\")}, new String[]{\"Ljava/lang/String;\"}, \"Ljava/lang/ArithmeticException;\")));\n+            } else if (e == NEGATIVE_ARRAY_SIZE) {\n+                m.stmts.insertBefore(p,\n+                        Stmts.nThrow(Exprs.nInvokeNew(new Value[0], new String[0], \"Ljava/lang/NegativeArraySizeException;\")));\n             }\n         }\n     }",
      "parent_sha": "09824bbb941adf1116307adc09c761db77e94bd3"
    }
  },
  {
    "oid": "f5855ebfcbb2124d1a9ff6563125620077ff009a",
    "message": "fix test fail",
    "date": "2018-06-14T05:51:42Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/f5855ebfcbb2124d1a9ff6563125620077ff009a",
    "details": {
      "sha": "9d572418ff1a2c92b73c4cbf9e073cbb27e5c9c0",
      "filename": "dex-translator/src/test/java/com/googlecode/dex2jar/test/TestUtils.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/f5855ebfcbb2124d1a9ff6563125620077ff009a/dex-translator%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftest%2FTestUtils.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/f5855ebfcbb2124d1a9ff6563125620077ff009a/dex-translator%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftest%2FTestUtils.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftest%2FTestUtils.java?ref=f5855ebfcbb2124d1a9ff6563125620077ff009a",
      "patch": "@@ -335,7 +335,7 @@ public ClassVisitor create(String classInternalName) {\n         CfOptions cfOptions = new CfOptions();\n         cfOptions.strictNameCheck = false;\n         DexOptions dexOptions = new DexOptions();\n-        if (fileNode.dexVersion >= DexConstants.DEX_037) {\n+        if (fileNode != null && fileNode.dexVersion >= DexConstants.DEX_037) {\n             dexOptions.minSdkVersion = 26;\n         }\n ",
      "parent_sha": "6e085153cf0bd9db86aa9e56afe462eba31c15e5"
    }
  },
  {
    "oid": "0b02af44085167e8f79fd01a1dd8e9f46b893cd1",
    "message": "add method to array datain\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2012-08-28T12:06:03Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/0b02af44085167e8f79fd01a1dd8e9f46b893cd1",
    "details": {
      "sha": "6174939c6898114cad31d177a85438e00119d09a",
      "filename": "dex-reader/src/main/java/com/googlecode/dex2jar/reader/io/ArrayDataIn.java",
      "status": "modified",
      "additions": 15,
      "deletions": 2,
      "changes": 17,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/0b02af44085167e8f79fd01a1dd8e9f46b893cd1/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2Fio%2FArrayDataIn.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/0b02af44085167e8f79fd01a1dd8e9f46b893cd1/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2Fio%2FArrayDataIn.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2Fio%2FArrayDataIn.java?ref=0b02af44085167e8f79fd01a1dd8e9f46b893cd1",
      "patch": "@@ -29,10 +29,18 @@ public static ArrayDataIn be(byte[] data) {\n         return new ArrayDataIn(data, false);\r\n     }\r\n \r\n+    public static ArrayDataIn be(byte[] data, int offset, int length) {\r\n+        return new ArrayDataIn(data, offset, length, false);\r\n+    }\r\n+\r\n     public static ArrayDataIn le(byte[] data) {\r\n         return new ArrayDataIn(data, true);\r\n     }\r\n \r\n+    public static ArrayDataIn le(byte[] data, int offset, int length) {\r\n+        return new ArrayDataIn(data, offset, length, true);\r\n+    }\r\n+\r\n     private boolean isLE;\r\n \r\n     private Stack<Integer> stack = new Stack<Integer>();\r\n@@ -42,14 +50,19 @@ public ArrayDataIn(byte[] data, boolean isLE) {\n         this.isLE = isLE;\r\n     }\r\n \r\n+    public ArrayDataIn(byte[] buf, int offset, int length, boolean isLE) {\r\n+        super(buf, offset, length);\r\n+        this.isLE = isLE;\r\n+    }\r\n+\r\n     @Override\r\n     public int getCurrentPosition() {\r\n-        return super.pos;\r\n+        return super.pos - super.mark;\r\n     }\r\n \r\n     @Override\r\n     public void move(int absOffset) {\r\n-        super.pos = absOffset;\r\n+        super.pos = absOffset + super.mark;\r\n     }\r\n \r\n     @Override\r",
      "parent_sha": "52907d62bc4d7598cda9ea17fa944fa3f631bd9a"
    }
  },
  {
    "oid": "184407aa2642d0c514f8c3bc393dba27d7f7253b",
    "message": "support txt/gz error file\n\n--HG--\nbranch : 2.x",
    "date": "2015-04-22T14:23:26Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/184407aa2642d0c514f8c3bc393dba27d7f7253b",
    "details": {
      "sha": "e41868702abd9bad0503a81f544a6e088eb3ca0a",
      "filename": "dex-tools/src/main/java/com/googlecode/dex2jar/tools/BaksmaliBaseDexExceptionHandler.java",
      "status": "modified",
      "additions": 97,
      "deletions": 52,
      "changes": 149,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/184407aa2642d0c514f8c3bc393dba27d7f7253b/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FBaksmaliBaseDexExceptionHandler.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/184407aa2642d0c514f8c3bc393dba27d7f7253b/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FBaksmaliBaseDexExceptionHandler.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FBaksmaliBaseDexExceptionHandler.java?ref=184407aa2642d0c514f8c3bc393dba27d7f7253b",
      "patch": "@@ -35,14 +35,15 @@\n import java.nio.file.Path;\n import java.text.SimpleDateFormat;\n import java.util.*;\n+import java.util.zip.GZIPOutputStream;\n import java.util.zip.ZipEntry;\n import java.util.zip.ZipOutputStream;\n \n public class BaksmaliBaseDexExceptionHandler extends BaseDexExceptionHandler {\n     public static final String REPORT_MESSAGE = \"Please report this file to one of following link if possible (any one).\\n\" + //\n-            \"    http://sourceforge.net/p/dex2jar/tickets/\\n\" + //\n+            \"    https://sourceforge.net/p/dex2jar/tickets/\\n\" + //\n             \"    https://bitbucket.org/pxb1988/dex2jar/issues\\n\" + //\n-            \"    https://github.com/pxb1988/dex2jar/issues\\n\" + //\n+            \"    https://github.com/pxb1988/dex2jar/issues [no attachment support, not preferred]\\n\" + //\n             \"    dex2jar@googlegroups.com\";\n \n     private Map<DexMethodNode, Exception> exceptionMap = new HashMap<>();\n@@ -84,65 +85,109 @@ private static void doAddVersion(List<String> vs, String pkg, Class<?> clz) {\n         }\n     }\n \n-    public void dump(Path exFile, String[] orginalArgs) {\n-        try (ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(exFile))) {\n-            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(zos, StandardCharsets.UTF_8));\n-            // dump summary: timestamp, version, cmdline\n-            zos.putNextEntry(new ZipEntry(\"summary.txt\"));\n-            if (fileExceptions.size() > 0) {\n-                writer.append(String.format(\"There are %d fails.\", fileExceptions.size()));\n-                writer.newLine();\n-            }\n-            if (exceptionMap.size() > 0) {\n-                writer.append(String.format(\"There are %d methods fail to translate.\", exceptionMap.size()));\n-                writer.newLine();\n+    public void dump(Path exFile, String[] originalArgs) {\n+        String fileName = exFile.getFileName().toString().toLowerCase();\n+        try {\n+            if (fileName.endsWith(\".zip\")) {\n+                dumpZip(exFile, originalArgs);\n+            } else if (fileName.endsWith(\".gz\")) {\n+                dumGZip(exFile, originalArgs);\n+            } else {\n+                dumpTxt(exFile, originalArgs);\n             }\n-            SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss z\");\n-            sdf.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-            writer.append(sdf.format(new Date()));\n-            writer.newLine();\n-            writer.append(\"version: \");\n-            writer.append(getVersionString());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void dumpTxt(Path exFile, String[] originalArgs) throws IOException {\n+        try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(Files\n+                .newOutputStream(exFile), StandardCharsets.UTF_8))) {\n+            dumpTxt0(writer, originalArgs);\n+        }\n+    }\n+\n+    private void dumGZip(Path exFile, String[] originalArgs) throws IOException {\n+        try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new GZIPOutputStream(Files\n+                .newOutputStream(exFile)), StandardCharsets.UTF_8))) {\n+            dumpTxt0(writer, originalArgs);\n+        }\n+    }\n+\n+    private void dumpTxt0(BufferedWriter writer, String[] originalArgs) throws IOException {\n+        dumpSummary(originalArgs, writer);\n+        int i = 0;\n+        for (Map.Entry<DexMethodNode, Exception> e : exceptionMap.entrySet()) {\n+            DexMethodNode dexMethodNode = e.getKey();\n+            Exception ex = e.getValue();\n             writer.newLine();\n-            writer.append(\"cmdline: \");\n-            writer.append(Arrays.asList(orginalArgs).toString());\n+            writer.write(\"================= \" + i++ + \" ===================\");\n             writer.newLine();\n+            dumpMethod(writer, dexMethodNode, ex);\n+        }\n+    }\n \n-            writer.append(\"env:\");\n-            writer.newLine();\n-            Properties properties = System.getProperties();\n-            for (String key : properties.stringPropertyNames()) {\n-                if (key.startsWith(\"java.\") && !key.toLowerCase().contains(\"pass\")) {\n-                    writer.append(key).append(\": \").append(properties.getProperty(key));\n-                    writer.newLine();\n-                }\n-            }\n-            PrintWriter p = new PrintWriter(writer, true);\n-            for (Exception ex : fileExceptions) {\n-                ex.printStackTrace(p);\n-            }\n-            writer.flush();\n+    public void dumpZip(Path exFile, String[] originalArgs) throws IOException {\n+        try (ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(exFile))) {\n+            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(zos, StandardCharsets.UTF_8));\n+\n+            zos.putNextEntry(new ZipEntry(\"summary.txt\"));\n+            dumpTxt0(writer, originalArgs);\n             zos.closeEntry();\n+            zos.flush();\n+        }\n+    }\n \n-            // dump each method\n+    // dump each method\n+    private void dumpMethod(BufferedWriter writer, DexMethodNode dexMethodNode, Exception ex) throws IOException {\n+        writer.append(dexMethodNode.method.toString());\n+        writer.newLine();\n+        writer.flush();\n+        ex.printStackTrace(new PrintWriter(writer, true));\n+        writer.newLine();\n+        new BaksmaliDumper().baksmaliMethod(dexMethodNode, writer);\n+        writer.flush();\n+    }\n \n-            int i = 0;\n-            BaksmaliDumper baksmaliDumper = new BaksmaliDumper();\n-            for (Map.Entry<DexMethodNode, Exception> e : exceptionMap.entrySet()) {\n-                zos.putNextEntry(new ZipEntry(\"m-\" + i++ + \".txt\"));\n-                writer.append(e.getKey().method.toString());\n-                writer.newLine();\n-                writer.flush();\n-                e.getValue().printStackTrace(new PrintWriter(writer, true));\n+    // dump summary: timestamp, version, cmdline\n+    private void dumpSummary(String[] originalArgs, BufferedWriter writer) throws IOException {\n+        writer.write(\"#This file is generated by dex2jar\");\n+        writer.newLine();\n+        writer.write(REPORT_MESSAGE);\n+        writer.newLine();\n+        writer.newLine();\n+        if (fileExceptions.size() > 0) {\n+            writer.append(String.format(\"There are %d fails.\", fileExceptions.size()));\n+            writer.newLine();\n+        }\n+        if (exceptionMap.size() > 0) {\n+            writer.append(String.format(\"There are %d methods fail to translate.\", exceptionMap.size()));\n+            writer.newLine();\n+        }\n+        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss z\");\n+        sdf.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+        writer.append(sdf.format(new Date()));\n+        writer.newLine();\n+        writer.append(\"version: \");\n+        writer.append(getVersionString());\n+        writer.newLine();\n+        writer.append(\"cmdline: \");\n+        writer.append(Arrays.asList(originalArgs).toString());\n+        writer.newLine();\n+\n+        writer.append(\"env:\");\n+        writer.newLine();\n+        Properties properties = System.getProperties();\n+        for (String key : properties.stringPropertyNames()) {\n+            if (key.startsWith(\"java.\") && !key.toLowerCase().contains(\"pass\")) {\n+                writer.append(key).append(\": \").append(properties.getProperty(key));\n                 writer.newLine();\n-                baksmaliDumper.baksmaliMethod(e.getKey(), writer);\n-                writer.flush();\n-                zos.closeEntry();\n             }\n-            zos.setComment(\"This file is generated by dex2jar\\n\" + REPORT_MESSAGE + \"\\n\");\n-            zos.flush();\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n         }\n+        PrintWriter p = new PrintWriter(writer, true);\n+        for (Exception ex : fileExceptions) {\n+            ex.printStackTrace(p);\n+        }\n+        writer.flush();\n     }\n }",
      "parent_sha": "2bfa264fbf0aade1de34e2619a679d993bf6fb5d"
    }
  },
  {
    "oid": "533b750b2d9b712959e98d2f935f2a416287c37e",
    "message": "spport read zip from maped memory\n\n--HG--\nbranch : 2.x",
    "date": "2015-10-28T17:10:08Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/533b750b2d9b712959e98d2f935f2a416287c37e",
    "details": {
      "sha": "07eec9e7d74005e27827b86277ccd748a8966e73",
      "filename": "dex-reader/src/main/java/com/googlecode/d2j/util/zip/ZipFile.java",
      "status": "modified",
      "additions": 21,
      "deletions": 27,
      "changes": 48,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/533b750b2d9b712959e98d2f935f2a416287c37e/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Futil%2Fzip%2FZipFile.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/533b750b2d9b712959e98d2f935f2a416287c37e/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Futil%2Fzip%2FZipFile.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Futil%2Fzip%2FZipFile.java?ref=533b750b2d9b712959e98d2f935f2a416287c37e",
      "patch": "@@ -16,10 +16,10 @@\n  */\n package com.googlecode.d2j.util.zip;\n \n-import java.io.IOException;\n-import java.io.InputStream;\n+import java.io.*;\n import java.nio.ByteBuffer;\n import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n import java.nio.charset.StandardCharsets;\n import java.util.ArrayList;\n import java.util.List;\n@@ -68,12 +68,20 @@ public class ZipFile implements AutoCloseable, ZipConstants {\n \n     private String comment;\n     final ByteBuffer raf;\n+    RandomAccessFile file;\n \n     public ZipFile(ByteBuffer in) throws IOException {\n         raf = in.asReadOnlyBuffer().order(ByteOrder.LITTLE_ENDIAN);\n         readCentralDir();\n     }\n \n+    public ZipFile(File fd) throws IOException {\n+        RandomAccessFile randomAccessFile = new RandomAccessFile(fd, \"r\");\n+        file = randomAccessFile;\n+        raf = randomAccessFile.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, fd.length());\n+        readCentralDir();\n+    }\n+\n     public ZipFile(byte[] data) throws IOException {\n         this(ByteBuffer.wrap(data));\n     }\n@@ -115,6 +123,12 @@ private ZipEntry findFirstEntry0(String entryName) {\n         return null;\n     }\n \n+    public long getEntryDataStart(ZipEntry entry) {\n+        int fileNameLength = raf.getShort((int) (entry.localHeaderRelOffset + 26)) & 0xffff;\n+        int extraFieldLength = raf.getShort((int) (entry.localHeaderRelOffset + 28)) & 0xffff;\n+        return entry.localHeaderRelOffset + 30 + fileNameLength + extraFieldLength;\n+    }\n+\n     /**\n      * Returns an input stream on the data of the specified {@code android.ZipEntry}.\n      * \n@@ -127,30 +141,8 @@ private ZipEntry findFirstEntry0(String entryName) {\n      *             if this zip file has been closed.\n      */\n     public InputStream getInputStream(ZipEntry entry) throws IOException {\n-        // We don't know the entry data's start position. All we have is the\n-        // position of the entry's local header.\n-        // http://www.pkware.com/documents/casestudies/APPNOTE.TXT\n-        final ByteBuffer is = (ByteBuffer) raf.duplicate().order(ByteOrder.LITTLE_ENDIAN)\n-                .position((int) entry.localHeaderRelOffset);\n-\n-        skip(is, 6); // skip check localMagic\n-        // final int localMagic = is.getInt();\n-        // if (localMagic != LOCSIG) {\n-        // throwZipException(\"Local File Header\", localMagic);\n-        // }\n-        // skip(is, 2);\n-\n-        // At position 6 we find the General Purpose Bit Flag.\n-        int gpbf = is.getShort() & 0xffff;\n-\n-        // Offset 26 has the file name length, and offset 28 has the extra field length.\n-        // These lengths can differ from the ones in the central header.\n-        skip(is, 18);\n-        int fileNameLength = is.getShort() & 0xffff;\n-        int extraFieldLength = is.getShort() & 0xffff;\n-\n-        // Skip the variable-size file name and extra field data.\n-        skip(is, fileNameLength + extraFieldLength);\n+        long entryDataStart = getEntryDataStart(entry);\n+        ByteBuffer is = (ByteBuffer) raf.duplicate().position((int) entryDataStart);\n \n         if (entry.compressionMethod == ZipEntry.STORED) {\n             final ByteBuffer buf = (ByteBuffer) is.slice().order(ByteOrder.LITTLE_ENDIAN).limit((int) entry.size);\n@@ -276,7 +268,9 @@ static void throwZipException(String msg, int magic) throws ZipException {\n \n     @Override\n     public void close() throws IOException {\n-\n+        if(file!=null){\n+            file.close();\n+        }\n     }\n \n     static class ZipInflaterInputStream extends InflaterInputStream {",
      "parent_sha": "077f1ae9fc684f8e5c5ecbf0b64e2c20a9726741"
    }
  },
  {
    "oid": "259a3493240c75dbde813d01445692847f2af772",
    "message": "fix read bug in StdApk\n\n--HG--\nbranch : 2.x",
    "date": "2014-08-02T17:24:38Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/259a3493240c75dbde813d01445692847f2af772",
    "details": {
      "sha": "bafb9b4691905b647f924d837ae025d65624d148",
      "filename": "dex-tools/src/main/java/com/googlecode/dex2jar/tools/StdApkCmd.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/259a3493240c75dbde813d01445692847f2af772/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FStdApkCmd.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/259a3493240c75dbde813d01445692847f2af772/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FStdApkCmd.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FStdApkCmd.java?ref=259a3493240c75dbde813d01445692847f2af772",
      "patch": "@@ -59,7 +59,7 @@ protected void doCommandLine() throws Exception {\n                 if (!nEntry.isDirectory()) {\n                     try (InputStream is = zipFile.getInputStream(e)) {\n                         while (true) {\n-                            int c = is.read(data);\n+                            int c = is.read(buffer);\n                             if (c < 0) {\n                                 break;\n                             }",
      "parent_sha": "7479653f6f237e52bee05838b36f2f47aa8bfd62"
    }
  },
  {
    "oid": "077f1ae9fc684f8e5c5ecbf0b64e2c20a9726741",
    "message": "treat int as uint in minLine\n\n--HG--\nbranch : 2.x",
    "date": "2015-10-28T17:06:13Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/077f1ae9fc684f8e5c5ecbf0b64e2c20a9726741",
    "details": {
      "sha": "d56f43a87f1ea2d553b72cb21572154eaa5b2462",
      "filename": "dex-writer/src/main/java/com/googlecode/d2j/dex/writer/CodeWriter.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/077f1ae9fc684f8e5c5ecbf0b64e2c20a9726741/dex-writer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2Fwriter%2FCodeWriter.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/077f1ae9fc684f8e5c5ecbf0b64e2c20a9726741/dex-writer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2Fwriter%2FCodeWriter.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-writer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2Fwriter%2FCodeWriter.java?ref=077f1ae9fc684f8e5c5ecbf0b64e2c20a9726741",
      "patch": "@@ -815,7 +815,7 @@ public void visitStartLocal(int reg, DexLabel label, String name, String type, S\n \n             @Override\n             public void visitLineNumber(int line, DexLabel label) {\n-                if (line < miniLine) {\n+                if ((0x00000000FFFFffffL & line) < miniLine) {\n                     miniLine = line;\n                 }\n                 debugInfoItem.debugNodes.add(DebugInfoItem.DNode.line(line, getLabel(label)));",
      "parent_sha": "46bda9e8e73600e3b2e745ec761a4d801cb46f0b"
    }
  },
  {
    "oid": "038e309166db7013a0a584ebf08d6b61e391f1b1",
    "message": "Fixes issue 98\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2012-01-13T03:42:15Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/038e309166db7013a0a584ebf08d6b61e391f1b1",
    "details": {
      "sha": "fa97af71052d96df69eb0167389f03da22ea7a9f",
      "filename": "dex-tools/src/main/java/com/googlecode/dex2jar/tools/Dex2jarCmd.java",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/038e309166db7013a0a584ebf08d6b61e391f1b1/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FDex2jarCmd.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/038e309166db7013a0a584ebf08d6b61e391f1b1/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FDex2jarCmd.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FDex2jarCmd.java?ref=038e309166db7013a0a584ebf08d6b61e391f1b1",
      "patch": "@@ -69,9 +69,11 @@ protected void doCommandLine() throws Exception {\n         } else {\n             for (String fileName : remainingArgs) {\n                 File file = new File(FilenameUtils.getBaseName(fileName) + \"-dex2jar.jar\");\n-                System.err.println(file + \" exists, use --force to overwrite\");\n-                usage();\n-                return;\n+                if (file.exists() && !forceOverwrite) {\n+                    System.err.println(file + \" exists, use --force to overwrite\");\n+                    usage();\n+                    return;\n+                }\n             }\n         }\n ",
      "parent_sha": "d17d99ce990e8fd72a2f733c322fd2c1a02a06a1"
    }
  },
  {
    "oid": "39ae422f4bdf32bb3caac6c42d95061c0a02264e",
    "message": "1.\u5c06OP_INVOKE_SUPER\u8f6c\u6362\u6210INVOKEVIRTUAL\n\n--HG--\nbranch : 0.0.7",
    "date": "2010-08-20T21:07:39Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/39ae422f4bdf32bb3caac6c42d95061c0a02264e",
    "details": {
      "sha": "434ab086feea54af7f958f85182baef80f14ea49",
      "filename": "src/main/java/pxb/android/dex2jar/v3/V3CodeAdapter.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/39ae422f4bdf32bb3caac6c42d95061c0a02264e/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Fv3%2FV3CodeAdapter.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/39ae422f4bdf32bb3caac6c42d95061c0a02264e/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Fv3%2FV3CodeAdapter.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Fv3%2FV3CodeAdapter.java?ref=39ae422f4bdf32bb3caac6c42d95061c0a02264e",
      "patch": "@@ -1037,11 +1037,11 @@ public void visitMethodInsn(int opcode, Method method, int[] args) {\n \t\t\tstack(1 + args.length);\r\n \t\t\tloadArgument(method, args, false);\r\n \t\t\tswitch (opcode) {\r\n-\t\t\tcase OP_INVOKE_DIRECT:\r\n-\t\t\tcase OP_INVOKE_SUPER: {\r\n+\t\t\tcase OP_INVOKE_DIRECT: {\r\n \t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, method.getOwner(), method.getName(), method.getType().getDesc());\r\n \t\t\t}\r\n \t\t\t\tbreak;\r\n+\t\t\tcase OP_INVOKE_SUPER:\r\n \t\t\tcase OP_INVOKE_VIRTUAL: {\r\n \t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, method.getOwner(), method.getName(), method.getType().getDesc());\r\n \t\t\t}\r",
      "parent_sha": "6e7f7032b1f43254c9d69227edb147e9cff2f9a8"
    }
  },
  {
    "oid": "e2bf13f9be655aaed858a8168e24010cac3d5820",
    "message": "hide process mesage\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2013-08-15T07:32:24Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/e2bf13f9be655aaed858a8168e24010cac3d5820",
    "details": {
      "sha": "84a2bf09d408d4240bca6dab9caa8b432c5f4599",
      "filename": "dex-tools/src/main/java/com/googlecode/dex2jar/tools/JarAccessCmd.java",
      "status": "modified",
      "additions": 9,
      "deletions": 3,
      "changes": 12,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/e2bf13f9be655aaed858a8168e24010cac3d5820/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FJarAccessCmd.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/e2bf13f9be655aaed858a8168e24010cac3d5820/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FJarAccessCmd.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FJarAccessCmd.java?ref=e2bf13f9be655aaed858a8168e24010cac3d5820",
      "patch": "@@ -47,6 +47,10 @@ public JarAccessCmd() {\n \n     @Opt(opt = \"f\", longOpt = \"force\", hasArg = false, description = \"force overwrite\")\n     private boolean forceOverwrite = false;\n+\n+    @Opt(opt = \"v\", longOpt = \"verbose\", hasArg = false, description = \"verbose\")\n+    private boolean verbose = false;\n+\n     @Opt(opt = \"o\", longOpt = \"output\", description = \"output dir of .j files, default is $current_dir/[jar-name]-access.jar\", argName = \"out-dir\")\n     private File output;\n \n@@ -160,6 +164,8 @@ protected void doCommandLine() throws Exception {\n             return;\n         }\n \n+        System.err.println(\"jar-access \" + jar + \" -> \" + output);\n+\n         final int rf = ~str2acc(removeFieldAccess);\n         final int rm = ~str2acc(removeMethodAccess);\n         final int rc = ~str2acc(removeClassAccess);\n@@ -192,7 +198,7 @@ public void handle(boolean isDir, String name, StreamOpener current, Object name\n                             public void visit(int version, int access, String name, String signature, String superName,\n                                     String[] interfaces) {\n                                 int na = (access & rc) | ac;\n-                                if (access != na) {\n+                                if (verbose && access != na) {\n                                     System.out.println(\"c \" + name);\n                                 }\n                                 super.visit(version, na, name, signature, superName, interfaces);\n@@ -202,7 +208,7 @@ public void visit(int version, int access, String name, String signature, String\n                             public FieldVisitor visitField(int access, String name, String desc, String signature,\n                                     Object value) {\n                                 int na = (access & rf) | af;\n-                                if (na != access) {\n+                                if (verbose && na != access) {\n                                     System.out.println(\"f \" + r.getClassName() + \".\" + name);\n                                 }\n                                 return super.visitField(na, name, desc, signature, value);\n@@ -212,7 +218,7 @@ public FieldVisitor visitField(int access, String name, String desc, String sign\n                             public MethodVisitor visitMethod(int access, String name, String desc, String signature,\n                                     String[] exceptions) {\n                                 int na = (access & rm) | am;\n-                                if (na != access) {\n+                                if (verbose && na != access) {\n                                     System.out.println(\"m \" + r.getClassName() + \".\" + name + desc);\n                                 }\n                                 return super.visitMethod(na, name, desc, signature, exceptions);",
      "parent_sha": "f2336482d1f02bdbbd8de4d47160a4e5d3696b0b"
    }
  },
  {
    "oid": "2a972dc11ff1db52dc34784bc12b2c2a6f0ca417",
    "message": "Fix when the largest local(type J) index is n and optimize-sync will use n+1\nchange optimize-sync to use n+2\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2012-07-18T11:57:11Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/2a972dc11ff1db52dc34784bc12b2c2a6f0ca417",
    "details": {
      "sha": "9d50f25127a6ad01ac17a17b8a70d4aad64d9f7f",
      "filename": "dex-translator/src/main/java/com/googlecode/dex2jar/v3/IrMethod2AsmMethod.java",
      "status": "modified",
      "additions": 18,
      "deletions": 2,
      "changes": 20,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/2a972dc11ff1db52dc34784bc12b2c2a6f0ca417/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FIrMethod2AsmMethod.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/2a972dc11ff1db52dc34784bc12b2c2a6f0ca417/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FIrMethod2AsmMethod.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FIrMethod2AsmMethod.java?ref=2a972dc11ff1db52dc34784bc12b2c2a6f0ca417",
      "patch": "@@ -382,10 +382,26 @@ private void reBuildInstructions(IrMethod ir, MethodVisitor asm) {\n \r\n                     @Override\r\n                     public int compare(Local o1, Local o2) {\r\n-                        return o1._ls_index - o2._ls_index;\r\n+                        int i = o1._ls_index - o2._ls_index;\r\n+                        if (i != 0) {\r\n+                            return i;\r\n+                        }\r\n+                        Type t1 = LocalType.typeOf(o1);\r\n+                        if (t1 == null) {\r\n+                            return -1;\r\n+                        }\r\n+                        Type t2 = LocalType.typeOf(o2);\r\n+                        if (t2 == null) {\r\n+                            return 1;\r\n+                        }\r\n+                        return t1.getSize() - t2.getSize();\r\n                     }\r\n                 });\r\n-                maxLocalIndex = (maxLoale == null || maxLoale._ls_index < 0) ? 0 : maxLoale._ls_index;\r\n+                if (maxLoale == null || maxLoale._ls_index < 0) {\r\n+                    maxLocalIndex = 0;\r\n+                } else {\r\n+                    maxLocalIndex = maxLoale._ls_index + LocalType.typeOf(maxLoale).getSize() - 1;\r\n+                }\r\n             }\r\n         }\r\n         for (Stmt st : ir.stmts) {\r",
      "parent_sha": "2a58b8efd73ba8d3b05194b1951c25812b67f51e"
    }
  },
  {
    "oid": "48e18f4935132ebe7bf46443d89c9df6816f8fec",
    "message": "\u6539\u5584dump\u5bf9const\u7684\u663e\u793a\u652f\u6301\n\n--HG--\nbranch : 0.0.7",
    "date": "2010-04-08T07:04:53Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/48e18f4935132ebe7bf46443d89c9df6816f8fec",
    "details": {
      "sha": "f473965f7ecc650dffbcad54e60e73c0c9d0d7b8",
      "filename": "src/main/java/pxb/android/dex2jar/dump/DumpDexCodeAdapter.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/48e18f4935132ebe7bf46443d89c9df6816f8fec/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Fdump%2FDumpDexCodeAdapter.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/48e18f4935132ebe7bf46443d89c9df6816f8fec/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Fdump%2FDumpDexCodeAdapter.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/src%2Fmain%2Fjava%2Fpxb%2Fandroid%2Fdex2jar%2Fdump%2FDumpDexCodeAdapter.java?ref=48e18f4935132ebe7bf46443d89c9df6816f8fec",
      "patch": "@@ -140,8 +140,6 @@ public void visitEnd() {\n \t\tsuper.visitEnd();\r\n \t}\r\n \r\n-\r\n-\r\n \t/*\r\n \t * (non-Javadoc)\r\n \t * \r\n@@ -571,6 +569,10 @@ public void visitLdcInsn(int opcode, Object value, int reg) {\n \t\t\tinfo(opcode, \"v%d=\\\"%s\\\"\", reg, value);\r\n \t\telse if (value instanceof Type) {\r\n \t\t\tinfo(opcode, \"v%d=%s.class\", reg, ((Type) value).getClassName());\r\n+\t\t} else if (value instanceof Integer) {\r\n+\t\t\tinfo(opcode, \"v%d=0x%8h  // int:%d   float:%f\", reg, value, value, Float.intBitsToFloat((Integer) value));\r\n+\t\t} else if (value instanceof Long) {\r\n+\t\t\tinfo(opcode, \"v%d=0x%16x  // long:%d   double:%f\", reg, value, value, Double.longBitsToDouble((Long) value));\r\n \t\t} else {\r\n \t\t\tinfo(opcode, \"v%d=%s  //\", reg, value);\r\n \t\t}\r",
      "parent_sha": "b0742b515971e1bf2443b303799e825db10b32d2"
    }
  },
  {
    "oid": "cbe7056c4acf29ae3753e51214c5e73008286ffa",
    "message": "Pop a local if it has no read\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2011-07-31T08:46:20Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/cbe7056c4acf29ae3753e51214c5e73008286ffa",
    "details": {
      "sha": "9e661cd925b9da0fdb45a0de89aaf4a53095a3e6",
      "filename": "dex-translator/src/main/java/com/googlecode/dex2jar/v3/IrMethod2AsmMethod.java",
      "status": "modified",
      "additions": 7,
      "deletions": 2,
      "changes": 9,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/cbe7056c4acf29ae3753e51214c5e73008286ffa/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FIrMethod2AsmMethod.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/cbe7056c4acf29ae3753e51214c5e73008286ffa/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FIrMethod2AsmMethod.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FIrMethod2AsmMethod.java?ref=cbe7056c4acf29ae3753e51214c5e73008286ffa",
      "patch": "@@ -122,9 +122,14 @@ private void reBuildInstructions(IrMethod ir, MethodNode asm) {\n                 switch (v1.vt) {\r\n                 case LOCAL:\r\n                     accept(v2, asm);\r\n-                    int i = ((Local) v1)._ls_index;\r\n+                    Local local = ((Local) v1);\r\n+                    int i = local._ls_index;\r\n                     if (i >= 0) {// skip void type locals\r\n-                        asm.visitVarInsn(LocalType.type(v1).getOpcode(ISTORE), i);\r\n+                        if (local._ls_read_count == 0) {// no read, just pop it\r\n+                            asm.visitInsn(LocalType.type(v1).getSize() == 2 ? POP2 : POP);\r\n+                        } else {\r\n+                            asm.visitVarInsn(LocalType.type(v1).getOpcode(ISTORE), i);\r\n+                        }\r\n                     }\r\n                     break;\r\n                 case FIELD:\r",
      "parent_sha": "216c1a97008adfc2150b2af43ef69819f0719f48"
    }
  },
  {
    "oid": "a30474ca120d3ff1ba1356d8044763915d6da9ef",
    "message": "\u66f4\u6b63DexFileReader.java302\u884c\u5bf9Field\u7684\u53c2\u6570\u987a\u5e8f\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2011-10-24T01:19:29Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/a30474ca120d3ff1ba1356d8044763915d6da9ef",
    "details": {
      "sha": "f6147cd47dd0873e1de60280bcfdd804dd3dc223",
      "filename": "dex-reader/src/main/java/com/googlecode/dex2jar/reader/DexFileReader.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/a30474ca120d3ff1ba1356d8044763915d6da9ef/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexFileReader.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/a30474ca120d3ff1ba1356d8044763915d6da9ef/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexFileReader.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexFileReader.java?ref=a30474ca120d3ff1ba1356d8044763915d6da9ef",
      "patch": "@@ -299,7 +299,7 @@ private void acceptClass(DexFileVisitor dv, DexClassVisitor dcv, String classNam\n             int owner_idx = in.readUShortx();\r\n             int type_idx = in.readUShortx();\r\n             int name_idx = in.readUIntx();\r\n-            return new Field(getType(owner_idx), getType(type_idx), getString(name_idx));\r\n+            return new Field(getType(owner_idx), getString(name_idx), getType(type_idx));\r\n         } finally {\r\n             in.pop();\r\n         }\r",
      "parent_sha": "80d60355ad09a6a543125e5e19b7d30ab5ec4e0a"
    }
  },
  {
    "oid": "2a6eca13ff2432815a2c3b7c386f76fc24925f80",
    "message": "decrypt multi method at once\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2013-07-05T16:13:05Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/2a6eca13ff2432815a2c3b7c386f76fc24925f80",
    "details": {
      "sha": "bcf96f3b1460ba2e42fc1bf5d96fcd1b908b398f",
      "filename": "dex-tools/src/main/java/com/googlecode/dex2jar/tools/DecryptStringCmd.java",
      "status": "modified",
      "additions": 249,
      "deletions": 57,
      "changes": 306,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/2a6eca13ff2432815a2c3b7c386f76fc24925f80/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FDecryptStringCmd.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/2a6eca13ff2432815a2c3b7c386f76fc24925f80/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FDecryptStringCmd.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FDecryptStringCmd.java?ref=2a6eca13ff2432815a2c3b7c386f76fc24925f80",
      "patch": "@@ -23,8 +23,11 @@\n import java.net.URLClassLoader;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n \n+import org.apache.commons.io.FileUtils;\n import org.apache.commons.io.FilenameUtils;\n import org.apache.commons.io.IOUtils;\n import org.objectweb.asm.ClassReader;\n@@ -58,15 +61,99 @@ public static void main(String[] args) {\n     private boolean forceOverwrite = false;\n     @Opt(opt = \"o\", longOpt = \"output\", description = \"output of .jar files, default is $current_dir/[jar-name]-decrypted.jar\", argName = \"out\")\n     private File output;\n-\n-    @Opt(opt = \"mo\", required = true, longOpt = \"decrypt-method-owner\", description = \"the owner of the method which can decrypt the stings, example: java.lang.String\", argName = \"owner\")\n+    @Opt(opt = \"m\", longOpt = \"methods\", description = \"a file contain a list of methods, each line like: La/b;->decrypt(III)Ljava/lang/String;\", argName = \"cfg\")\n+    private File method;\n+    @Opt(opt = \"mo\", longOpt = \"decrypt-method-owner\", description = \"the owner of the method which can decrypt the stings, example: java.lang.String\", argName = \"owner\")\n     private String methodOwner;\n-    @Opt(opt = \"mn\", required = true, longOpt = \"decrypt-method-name\", description = \"the owner of the method which can decrypt the stings, the method's signature must be static (type)Ljava/lang/String;. Please use -t,--arg-type to set the argument type.\", argName = \"name\")\n+    @Opt(opt = \"mn\", longOpt = \"decrypt-method-name\", description = \"the owner of the method which can decrypt the stings, the method's signature must be static (parameter-type)Ljava/lang/String;. Please use -pt,--parameter-type to set the argument descrypt.\", argName = \"name\")\n     private String methodName;\n     @Opt(opt = \"cp\", longOpt = \"classpath\", description = \"add extra lib to classpath\", argName = \"cp\")\n     private String classpath;\n-    @Opt(opt = \"t\", longOpt = \"arg-type\", description = \"the type of the method's argument, int,string. default is string\", argName = \"type\")\n-    private String type = \"string\";\n+    @Opt(opt = \"t\", longOpt = \"arg-type\", description = \"ignored\")\n+    private String type = null;\n+\n+    @Opt(opt = \"pt\", longOpt = \"parameter-type\", description = \"the descript for the method which can decrypt the stings, example1: Ljava/lang/String; example2:III, default is Ljava/lang/String;\", argName = \"type\")\n+    private String parameterType = \"Ljava/lang/String;\";\n+    @Opt(opt = \"d\", longOpt = \"delete\", hasArg = false, description = \"delete the method which can decrypt the stings\")\n+    private boolean deleteMethod = false;\n+\n+    static class MethodConfig {\n+        Method jmethod;\n+        /**\n+         * in java/lang/String format\n+         */\n+        String owner;\n+        String name;\n+        String desc;\n+\n+        @Override\n+        public int hashCode() {\n+            final int prime = 31;\n+            int result = 1;\n+            result = prime * result + ((desc == null) ? 0 : desc.hashCode());\n+            result = prime * result + ((name == null) ? 0 : name.hashCode());\n+            result = prime * result + ((owner == null) ? 0 : owner.hashCode());\n+            return result;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj)\n+                return true;\n+            if (obj == null)\n+                return false;\n+            if (getClass() != obj.getClass())\n+                return false;\n+            MethodConfig other = (MethodConfig) obj;\n+            if (desc == null) {\n+                if (other.desc != null)\n+                    return false;\n+            } else if (!desc.equals(other.desc))\n+                return false;\n+            if (name == null) {\n+                if (other.name != null)\n+                    return false;\n+            } else if (!name.equals(other.name))\n+                return false;\n+            if (owner == null) {\n+                if (other.owner != null)\n+                    return false;\n+            } else if (!owner.equals(other.owner))\n+                return false;\n+            return true;\n+        }\n+    }\n+\n+    MethodConfig build(String line) {\n+        int idx = line.indexOf(\"->\");\n+        if (idx < 0) {\n+            throw new RuntimeException(\"Can't read line:\" + line);\n+        }\n+        String owner = line.substring(0, idx);\n+\n+        if (owner.startsWith(\"L\") && owner.endsWith(\";\")) {\n+            owner = owner.substring(1, owner.length() - 1);\n+        }\n+\n+        int idx2 = line.indexOf('(', idx);\n+        if (idx2 < 0) {\n+            throw new RuntimeException(\"Can't read line:\" + line);\n+        }\n+\n+        String name = line.substring(idx + 2, idx2);\n+\n+        String desc = line.substring(idx2);\n+        if (desc.endsWith(\")\")) {\n+            desc = desc + \"Ljava/lang/String;\";\n+        }\n+\n+        MethodConfig config = new MethodConfig();\n+        config.owner = owner;\n+        config.desc = desc;\n+        config.name = name;\n+        return config;\n+\n+    }\n \n     @Override\n     protected void doCommandLine() throws Exception {\n@@ -96,29 +183,55 @@ protected void doCommandLine() throws Exception {\n \n         System.err.println(jar + \" -> \" + output);\n \n-        List<String> list = new ArrayList<String>();\n-        if (classpath != null) {\n-            list.addAll(Arrays.asList(classpath.split(\";|:\")));\n-        }\n-        list.add(jar.getAbsolutePath());\n-        URL[] urls = new URL[list.size()];\n-        for (int i = 0; i < list.size(); i++) {\n-            urls[i] = new File(list.get(i)).toURI().toURL();\n+        List<MethodConfig> methodConfigs = new ArrayList<MethodConfig>();\n+        if (this.method != null) {\n+            for (String line : FileUtils.readLines(this.method, \"UTF-8\")) {\n+                if (line.length() == 0 || line.startsWith(\"#\")) {\n+                    continue;\n+                }\n+                methodConfigs.add(this.build(line));\n+            }\n+        } else {\n+            if (methodOwner == null || methodName == null) {\n+                System.err.println(\"-mo/--decrypt-method-owner or -mn/decrypt-method-name is null\");\n+                return;\n+            }\n+            methodConfigs.add(this.build(\"L\" + methodOwner.replace('.', '/') + \";->\" + methodName + \"(\"\n+                    + this.parameterType + \")Ljava/lang/String;\"));\n         }\n-        final Method jmethod;\n-        final String targetMethodDesc;\n-        try {\n-            Class<?> argType = \"string\".equals(type) ? String.class : int.class;\n+\n+        final Map<MethodConfig, MethodConfig> map = new HashMap<MethodConfig, MethodConfig>();\n+        {\n+            List<String> list = new ArrayList<String>();\n+            if (classpath != null) {\n+                list.addAll(Arrays.asList(classpath.split(\";|:\")));\n+            }\n+            list.add(jar.getAbsolutePath());\n+            URL[] urls = new URL[list.size()];\n+            for (int i = 0; i < list.size(); i++) {\n+                urls[i] = new File(list.get(i)).toURI().toURL();\n+            }\n+\n             URLClassLoader cl = new URLClassLoader(urls);\n-            jmethod = cl.loadClass(methodOwner).getDeclaredMethod(methodName, argType);\n-            jmethod.setAccessible(true);\n-            targetMethodDesc = Type.getMethodDescriptor(jmethod);\n-        } catch (Exception ex) {\n-            System.err.println(\"can't load method: String \" + methodOwner + \".\" + methodName + \"(\" + type + \")\");\n-            ex.printStackTrace();\n-            return;\n+            for (MethodConfig config : methodConfigs) {\n+                try {\n+                    Class<?> clz = cl.loadClass(config.owner.replace('/', '.'));\n+                    if (clz == null) {\n+                        System.err.println(\"clz is null:\" + config.owner);\n+                    }\n+                    Method jmethod = clz.getDeclaredMethod(config.name,\n+                            this.toJavaType(Type.getArgumentTypes(config.desc)));\n+                    jmethod.setAccessible(true);\n+                    config.jmethod = jmethod;\n+                    map.put(config, config);\n+                } catch (Exception ex) {\n+                    System.err.println(\"can't load method: L\" + config.owner + \";->\" + config.name + config.desc);\n+                    ex.printStackTrace();\n+                    return;\n+                }\n+            }\n         }\n-        final String methodOwnerInternalType = this.methodOwner.replace('.', '/');\n+\n         final OutHandler fo = FileOut.create(output, true);\n         try {\n             new FileWalker().withStreamHandler(new StreamHandler() {\n@@ -130,46 +243,56 @@ public void handle(boolean isDir, String name, StreamOpener current, Object name\n                         fo.write(isDir, name, current == null ? null : current.get(), nameObject);\n                         return;\n                     }\n-\n+                    MethodConfig key = new MethodConfig();\n                     ClassReader cr = new ClassReader(current.get());\n                     ClassNode cn = new ClassNode();\n                     cr.accept(cn, ClassReader.EXPAND_FRAMES);\n \n-                    for (Object m0 : cn.methods) {\n+                    for (Object m0 : new ArrayList(cn.methods)) {\n                         MethodNode m = (MethodNode) m0;\n                         if (m.instructions == null) {\n                             continue;\n                         }\n+                        key.owner = cn.name;\n+                        key.name = m.name;\n+                        key.desc = m.desc;\n+                        if (map.containsKey(key)) {\n+                            if (deleteMethod) {\n+                                cn.methods.remove(m);\n+                            }\n+                            continue;\n+                        }\n                         AbstractInsnNode p = m.instructions.getFirst();\n                         while (p != null) {\n                             if (p.getOpcode() == Opcodes.INVOKESTATIC) {\n                                 MethodInsnNode mn = (MethodInsnNode) p;\n-                                if (mn.name.equals(methodName) && mn.desc.equals(targetMethodDesc)\n-                                        && mn.owner.equals(methodOwnerInternalType)) {\n-                                    AbstractInsnNode q = p.getPrevious();\n-                                    AbstractInsnNode next = p.getNext();\n-                                    if (q.getOpcode() == Opcodes.LDC) {\n-                                        LdcInsnNode ldc = (LdcInsnNode) q;\n-                                        tryReplace(m.instructions, p, q, jmethod, ldc.cst);\n-                                    } else if (q.getType() == AbstractInsnNode.INT_INSN) {\n-                                        IntInsnNode in = (IntInsnNode) q;\n-                                        tryReplace(m.instructions, p, q, jmethod, in.operand);\n-                                    } else {\n-                                        switch (q.getOpcode()) {\n-                                        case Opcodes.ICONST_M1:\n-                                        case Opcodes.ICONST_0:\n-                                        case Opcodes.ICONST_1:\n-                                        case Opcodes.ICONST_2:\n-                                        case Opcodes.ICONST_3:\n-                                        case Opcodes.ICONST_4:\n-                                        case Opcodes.ICONST_5:\n-                                            int x = ((InsnNode) q).getOpcode() - Opcodes.ICONST_0;\n-                                            tryReplace(m.instructions, p, q, jmethod, x);\n-                                            break;\n+                                key.owner = mn.owner;\n+                                key.name = mn.name;\n+                                key.desc = mn.desc;\n+                                MethodConfig config = map.get(key);\n+                                if (config != null) {\n+                                    Method jmethod = config.jmethod;\n+                                    try {\n+                                        AbstractInsnNode q = p;\n+                                        int pSize = jmethod.getParameterTypes().length;\n+                                        Object[] as = new Object[pSize];\n+                                        for (int i = pSize - 1; i >= 0; i--) {\n+                                            q = q.getPrevious();\n+                                            Object object = readCst(q);\n+                                            as[i] = convert(object, jmethod.getParameterTypes()[i]);\n+                                        }\n+                                        String newValue = (String) jmethod.invoke(null, as);\n+                                        LdcInsnNode nLdc = new LdcInsnNode(newValue);\n+                                        m.instructions.insert(p, nLdc);\n+                                        q = p;\n+                                        for (int i = 0; i <= pSize; i++) {\n+                                            AbstractInsnNode z = q.getPrevious();\n+                                            m.instructions.remove(q);\n+                                            q = z;\n                                         }\n+                                        p = nLdc;\n+                                    } catch (Exception ex) {\n                                     }\n-                                    p = next;\n-                                    continue;\n                                 }\n                             }\n                             p = p.getNext();\n@@ -180,21 +303,90 @@ public void handle(boolean isDir, String name, StreamOpener current, Object name\n                     cn.accept(cw);\n                     fo.write(false, cr.getClassName() + \".class\", cw.toByteArray(), null);\n                 }\n+\n+                private Object convert(Object object, Class<?> type) {\n+                    if (int.class.equals(type)) {\n+                        return ((Number) object).intValue();\n+                    }\n+                    if (byte.class.equals(type)) {\n+                        return ((Number) object).byteValue();\n+                    }\n+                    if (short.class.equals(type)) {\n+                        return ((Number) object).shortValue();\n+                    }\n+                    if (char.class.equals(type)) {\n+                        return (char) ((Number) object).intValue();\n+                    }\n+                    return object;\n+                }\n             }).walk(jar);\n         } finally {\n             IOUtils.closeQuietly(fo);\n         }\n     }\n \n+    Object readCst(AbstractInsnNode q) {\n+        if (q.getOpcode() == Opcodes.LDC) {\n+            LdcInsnNode ldc = (LdcInsnNode) q;\n+            return ldc.cst;\n+        } else if (q.getType() == AbstractInsnNode.INT_INSN) {\n+            IntInsnNode in = (IntInsnNode) q;\n+            return in.operand;\n+        } else {\n+            switch (q.getOpcode()) {\n+            case Opcodes.ICONST_M1:\n+            case Opcodes.ICONST_0:\n+            case Opcodes.ICONST_1:\n+            case Opcodes.ICONST_2:\n+            case Opcodes.ICONST_3:\n+            case Opcodes.ICONST_4:\n+            case Opcodes.ICONST_5:\n+                int x = ((InsnNode) q).getOpcode() - Opcodes.ICONST_0;\n+                return x;\n+            }\n+        }\n+        throw new RuntimeException();\n+    }\n+\n+    private Class<?>[] toJavaType(Type[] pt) throws ClassNotFoundException {\n+        Class<?> jt[] = new Class<?>[pt.length];\n+        for (int i = 0; i < pt.length; i++) {\n+            jt[i] = toJavaType(pt[i]);\n+        }\n+        return jt;\n+    }\n+\n+    private Class<?> toJavaType(Type t) throws ClassNotFoundException {\n+        switch (t.getSort()) {\n+        case Type.BOOLEAN:\n+            return boolean.class;\n+        case Type.BYTE:\n+            return byte.class;\n+        case Type.SHORT:\n+            return short.class;\n+        case Type.CHAR:\n+            return char.class;\n+        case Type.INT:\n+            return int.class;\n+        case Type.FLOAT:\n+            return float.class;\n+        case Type.LONG:\n+            return long.class;\n+        case Type.DOUBLE:\n+            return double.class;\n+        case Type.OBJECT:\n+        case Type.ARRAY:\n+            return Class.forName(t.getClassName());\n+        case Type.VOID:\n+            return void.class;\n+        }\n+        throw new RuntimeException();\n+    }\n+\n     public static AbstractInsnNode tryReplace(InsnList instructions, AbstractInsnNode p, AbstractInsnNode q,\n             Method jmethod, Object arg) {\n         try {\n-            String newValue = (String) jmethod.invoke(null, arg);\n-            LdcInsnNode nLdc = new LdcInsnNode(newValue);\n-            instructions.insertBefore(p, nLdc);\n-            instructions.remove(p);\n-            instructions.remove(q);\n-            return nLdc.getNext();\n+\n         } catch (Exception e) {\n             // ignore\n         }",
      "parent_sha": "6ad1e44d599f3e450ada9815acc34f6c9572335f"
    }
  },
  {
    "oid": "121f727d37ee4c18bcce57c6cc1063b35e1d6abb",
    "message": "Fix NPE\n\n(cherry picked from commit 9335d9d945be92a67c41dbe2c449f8c4c0a6f7be)",
    "date": "2021-10-30T18:09:48Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/121f727d37ee4c18bcce57c6cc1063b35e1d6abb",
    "details": {
      "sha": "2d137a94ddba84f9007aa7b506634f9771023772",
      "filename": "dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/UnSSATransformer.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/121f727d37ee4c18bcce57c6cc1063b35e1d6abb/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FUnSSATransformer.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/121f727d37ee4c18bcce57c6cc1063b35e1d6abb/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FUnSSATransformer.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FUnSSATransformer.java?ref=121f727d37ee4c18bcce57c6cc1063b35e1d6abb",
      "patch": "@@ -364,7 +364,7 @@ private void genRegGraph(IrMethod method, LiveA liveA) {\n                 // https://github.com/pxb1988/dex2jar/issues/477\n                 // the exception handler is dead and stmt.frame is null\n                 LabelStmt label = (LabelStmt) stmt;\n-                if (label.phis != null) {\n+                if (label.phis != null && stmt.frame != null) {\n                     for (AssignStmt phiAssignStmt : (List<AssignStmt>) label.phis) {\n                         Local phiLocal = (Local) phiAssignStmt.getOp1();\n                         RegAssign a = (RegAssign) phiLocal.tag;",
      "parent_sha": "4720fb87c94ed9572d1f330fd1af6ba55892f326"
    }
  },
  {
    "oid": "9510b74dcaeef1391382124d8a758f0c22775e2e",
    "message": "Workaround for #25",
    "date": "2023-10-03T11:43:10Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/9510b74dcaeef1391382124d8a758f0c22775e2e",
    "details": {
      "sha": "2da4e8d697301035267f4f75e499a7404526e703",
      "filename": "dex-translator/src/main/java/com/googlecode/d2j/dex/ExDex2Asm.java",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/9510b74dcaeef1391382124d8a758f0c22775e2e/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FExDex2Asm.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/9510b74dcaeef1391382124d8a758f0c22775e2e/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FExDex2Asm.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FExDex2Asm.java?ref=9510b74dcaeef1391382124d8a758f0c22775e2e",
      "patch": "@@ -48,7 +48,13 @@ public void convertCode(DexMethodNode methodNode, MethodVisitor mv, ClzCtx clzCt\n             }\n         }\n         // code convert ok, copy to MethodWriter and check for Size\n-        mn.accept(mv);\n+        try {\n+            mn.accept(mv);\n+        } catch (Exception e) {\n+            System.out.println(\"Cannot convert \" + clzCtx.classDescriptor);\n+            if (exceptionHandler != null)\n+                exceptionHandler.handleMethodTranslateException(methodNode.method, methodNode, mn, e);\n+        }\n         if (mw != null) {\n             try {\n                 AsmBridge.sizeOfMethodWriter(mw);",
      "parent_sha": "cc9861bbd4e350ba0f2705faec527b29f477c18f"
    }
  },
  {
    "oid": "cc9861bbd4e350ba0f2705faec527b29f477c18f",
    "message": "Fix bug Nico found randomly\n\ncherry-pick f90e6bf77f097c6145801c17757f8e7d58d207e4",
    "date": "2023-10-03T11:43:10Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/cc9861bbd4e350ba0f2705faec527b29f477c18f",
    "details": {
      "sha": "307be486c31b2c7063aa68ce572a4f90519e1255",
      "filename": "dex-writer/src/main/java/com/googlecode/d2j/dex/writer/ev/EncodedValue.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/cc9861bbd4e350ba0f2705faec527b29f477c18f/dex-writer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2Fwriter%2Fev%2FEncodedValue.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/cc9861bbd4e350ba0f2705faec527b29f477c18f/dex-writer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2Fwriter%2Fev%2FEncodedValue.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-writer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2Fwriter%2Fev%2FEncodedValue.java?ref=cc9861bbd4e350ba0f2705faec527b29f477c18f",
      "patch": "@@ -415,7 +415,7 @@ public int compareTo(EncodedValue o) {\n             case VALUE_METHOD_HANDLE:\n             case VALUE_METHOD_TYPE:\n                 if (value instanceof Comparable) {\n-                    return ((Comparable) value).compareTo(value);\n+                    return ((Comparable) value).compareTo(o.value);\n                 } else {\n                     throw new RuntimeException();\n                 }",
      "parent_sha": "476e64c6e9d3e4a59f61c890e663558c76b0e626"
    }
  },
  {
    "oid": "e9e05f89365a84930055cf2bc0e64333fa3b9070",
    "message": "Extract Hex class resource logic to a separate method (#20)\n\n* feat: Extract Hex class resource logic to a separate method\r\n\r\nSorry for the weird commit message, I couldn't find a way to word it better. Anyways..\r\n\r\nThis commit extracts the `getResourceAsStream` call to a separate, protected method so it can be overrided, and we can provide the Hex class from a different source.\r\n\r\n* fix: Check if Hex class stream is null",
    "date": "2023-08-31T10:34:46Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/e9e05f89365a84930055cf2bc0e64333fa3b9070",
    "details": {
      "sha": "ea95142f1cd8dc1a728d0dbe82fc8132c0c61b47",
      "filename": "dex-translator/src/main/java/com/googlecode/d2j/dex/Dex2Asm.java",
      "status": "modified",
      "additions": 10,
      "deletions": 1,
      "changes": 11,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/e9e05f89365a84930055cf2bc0e64333fa3b9070/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FDex2Asm.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/e9e05f89365a84930055cf2bc0e64333fa3b9070/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FDex2Asm.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FDex2Asm.java?ref=e9e05f89365a84930055cf2bc0e64333fa3b9070",
      "patch": "@@ -529,8 +529,17 @@ public void convertClass(int dexVersion, DexClassNode classNode, ClassVisitorFac\n     private static final Set<String> HEX_DECODE_METHODS =\n             new HashSet<>(Arrays.asList(\"decode_J\", \"decode_I\", \"decode_S\", \"decode_B\"));\n \n+    protected InputStream getHexClassAsStream() {\n+        return Dex2Asm.class.getResourceAsStream(\"/\" + HEX_CLASS_LOCATION + \".class\");\n+    }\n+\n     private void addHexDecodeMethod(ClassVisitor outCV, String className, String hexDecodeMethodNameBase) {\n-        try (InputStream is = Dex2Asm.class.getResourceAsStream(\"/\" + HEX_CLASS_LOCATION + \".class\")) {\n+        InputStream hexClassStream = getHexClassAsStream();\n+        if (hexClassStream == null) {\n+            return;\n+        }\n+\n+        try (InputStream is = hexClassStream) {\n             ClassReader cr = new ClassReader(is);\n             cr.accept(new ClassVisitor(Opcodes.ASM9) {\n                 @Override",
      "parent_sha": "f3fc040a09cf9d34694946688995086be64095e7"
    }
  },
  {
    "oid": "d9baaa5779c750bb1cc145977069b597da4c6fb7",
    "message": "[decrypt-string] add argument -v,--verbose to control output\n\nhttps://github.com/pxb1988/dex2jar/issues/51",
    "date": "2016-01-20T05:16:58Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/d9baaa5779c750bb1cc145977069b597da4c6fb7",
    "details": {
      "sha": "9fa35e88b7fbeef21f228577c9a9ce629fe11a18",
      "filename": "dex-tools/src/main/java/com/googlecode/dex2jar/tools/DecryptStringCmd.java",
      "status": "modified",
      "additions": 61,
      "deletions": 4,
      "changes": 65,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/d9baaa5779c750bb1cc145977069b597da4c6fb7/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FDecryptStringCmd.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/d9baaa5779c750bb1cc145977069b597da4c6fb7/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FDecryptStringCmd.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FDecryptStringCmd.java?ref=d9baaa5779c750bb1cc145977069b597da4c6fb7",
      "patch": "@@ -34,6 +34,7 @@\n import java.io.File;\n import java.io.IOException;\n import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.net.URL;\n import java.net.URLClassLoader;\n@@ -70,6 +71,8 @@ public static void main(String... args) {\n     private boolean deleteMethod = false;\n     @Opt(opt = \"da\", longOpt = \"deep-analyze\", hasArg = false, description = \"use dex2jar IR to static analyze and find more values like byte[]\")\n     private boolean deepAnalyze = false;\n+    @Opt(opt = \"v\", longOpt = \"verbose\", hasArg = false, description = \"show more on output\")\n+    private boolean verbose = false;\n \n     static class MethodConfig {\n         Method jmethod;\n@@ -235,7 +238,6 @@ private boolean decrypt(ClassNode cn, Map<MethodConfig, MethodConfig> map) {\n     private boolean decryptByIr(ClassNode cn, Map<MethodConfig, MethodConfig> map) {\n         MethodConfig key = this.key;\n         boolean changed = false;\n-        System.err.println(\" >   on \" + cn.name);\n         for (Iterator<MethodNode> it = cn.methods.iterator(); it.hasNext(); ) {\n             MethodNode m = it.next();\n             if (m.instructions == null) {\n@@ -250,6 +252,14 @@ private boolean decryptByIr(ClassNode cn, Map<MethodConfig, MethodConfig> map) {\n                 }\n                 continue;\n             }\n+\n+\n+            if (false && verbose) {\n+                System.out.println();\n+                System.out.println(\"===============\");\n+                System.out.println(\"on method \" + cn.name + \";->\" + m.name + m.desc);\n+            }\n+\n             boolean find = false;\n             // search for the decrypt method\n             for (AbstractInsnNode p = m.instructions.getFirst(); p != null; p = p.getNext()) {\n@@ -292,7 +302,9 @@ private boolean decryptByIr(ClassNode cn, Map<MethodConfig, MethodConfig> map) {\n                     m.localVariables = null;\n                     changed = true;\n                 } catch (Exception ex) {\n-                    ex.printStackTrace();\n+                    if(verbose) {\n+                        ex.printStackTrace();\n+                    }\n                 }\n             }\n         }\n@@ -318,6 +330,13 @@ private boolean decryptByStack(ClassNode cn, Map<MethodConfig, MethodConfig> map\n                 }\n                 continue;\n             }\n+\n+            if (false && verbose) {\n+                System.out.println();\n+                System.out.println(\"===============\");\n+                System.out.println(\"on method \" + cn.name + \";->\" + m.name + m.desc);\n+            }\n+\n             AbstractInsnNode p = m.instructions.getFirst();\n             while (p != null) {\n                 if (p.getOpcode() == Opcodes.INVOKESTATIC) {\n@@ -333,8 +352,14 @@ private boolean decryptByStack(ClassNode cn, Map<MethodConfig, MethodConfig> map\n                             int pSize = jmethod.getParameterTypes().length;\n                             // arguments' list. each parameter's value is retrieved by reading bytecode backwards, starting from the INVOKESTATIC statement\n                             Object[] as = readArgumentValues(mn, jmethod, pSize);\n+                            if (verbose) {\n+                                System.out.println(\" > calling \" + jmethod + \" with arguments \" + v(as));\n+                            }\n                             //decryption routine invocation\n                             String newValue = (String) jmethod.invoke(null, as);\n+                            if (verbose) {\n+                                System.out.println(\"  -> \" + Escape.v(newValue));\n+                            }\n                             //LDC statement generation\n                             LdcInsnNode nLdc = new LdcInsnNode(newValue);\n                             //insertion of the decrypted string's LDC statement, after INVOKESTATIC statement\n@@ -343,8 +368,14 @@ private boolean decryptByStack(ClassNode cn, Map<MethodConfig, MethodConfig> map\n                             removeInsts(m, mn, pSize);\n                             p = nLdc;\n                             changed = true;\n+                        } catch (InvocationTargetException ex){\n+                            if(verbose){\n+                                ex.getTargetException().printStackTrace();\n+                            }\n                         } catch (Exception ex) {\n-                            // ignore\n+                            if (verbose) {\n+                                ex.printStackTrace();\n+                            }\n                         }\n                     }\n                 }\n@@ -403,12 +434,18 @@ public Value travel(Value op) {\n                             if (ie.args.length != jmethod.getParameterTypes().length) {\n                                 throw new RuntimeException();\n                             }\n+\n                             Object args[] = new Object[ie.args.length];\n                             for (int i = 0; i < args.length; i++) {\n                                 args[i] = convertIr2Jobj(ie.getOps()[i], ie.args[i]);\n                             }\n+                            if (verbose) {\n+                                System.out.println(\" > calling \" + jmethod + \" with arguments \" + v(args));\n+                            }\n                             String str = (String) jmethod.invoke(null, args);\n-                            System.err.println(\"   < \" + Escape.v(str));\n+                            if (verbose) {\n+                                System.out.println(\"  -> \" + Escape.v(str));\n+                            }\n                             return Exprs.nString(str);\n                         } catch (Exception e) {\n                             e.printStackTrace();\n@@ -426,6 +463,24 @@ public Value travel(Value op) {\n         T_ir2jRegAssign.transform(irMethod);\n     }\n \n+    public static String v(Object[] vs) {\n+        StringBuilder sb = new StringBuilder(\"[\");\n+        boolean first = true;\n+        for (Object obj : vs) {\n+            if (first) {\n+                first = false;\n+            } else {\n+                sb.append(\",\");\n+            }\n+            if(obj instanceof String) {\n+                sb.append(Escape.v(obj));\n+            }else {\n+                sb.append(obj);\n+            }\n+        }\n+        return sb.append(\"]\").toString();\n+    }\n+\n     private Object convertIr2Jobj(Value value, String type) {\n         if (value instanceof Constant) {\n             if (Constant.Null.equals(((Constant) value).value)) {\n@@ -920,6 +975,8 @@ Object readCst(AbstractInsnNode q) {\n             case Opcodes.DCONST_0:\n             case Opcodes.DCONST_1:\n                 return (double) (q.getOpcode() - Opcodes.DCONST_0);\n+            case Opcodes.ACONST_NULL:\n+                return null;\n         }\n \n         throw new RuntimeException();",
      "parent_sha": "f548b03cdc4d01c74a0a5eeeb6363e728abe9c38"
    }
  },
  {
    "oid": "b006a5c9ca11317513ed7c049f1d0433be2652b1",
    "message": "find test file by resource",
    "date": "2018-06-06T03:12:53Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/b006a5c9ca11317513ed7c049f1d0433be2652b1",
    "details": {
      "sha": "de409ce5c057457c256bde686cb2ccc77c89e937",
      "filename": "dex-translator/src/test/java/com/googlecode/dex2jar/test/TestUtils.java",
      "status": "modified",
      "additions": 2,
      "deletions": 7,
      "changes": 9,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/b006a5c9ca11317513ed7c049f1d0433be2652b1/dex-translator%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftest%2FTestUtils.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/b006a5c9ca11317513ed7c049f1d0433be2652b1/dex-translator%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftest%2FTestUtils.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftest%2FTestUtils.java?ref=b006a5c9ca11317513ed7c049f1d0433be2652b1",
      "patch": "@@ -149,18 +149,13 @@ private static String getShortName(final String name) {\n     public static List<Path> listTestDexFiles() {\n \n         Class<?> testClass = TestUtils.class;\n-        URL url = testClass.getResource(\"/\" + testClass.getName().replace('.', '/') + \".class\");\n+        URL url = testClass.getResource(\"/dexes/i_jetty.dex\");\n         Assert.assertNotNull(url);\n \n         final String fileStr = url.getFile();\n         Assert.assertNotNull(fileStr);\n-        String dirx = fileStr.substring(0, fileStr.length() - testClass.getName().length() - \".class\".length());\n \n-        System.out.println(\"dirx is \" + dirx);\n-\n-        File file = new File(dirx, \"dexes\");\n-\n-        return listPath(file, \".apk\", \".dex\", \".zip\");\n+        return listPath(new File(fileStr).getParentFile(), \".apk\", \".dex\", \".zip\");\n     }\n \n     public static List<Path> listPath(File file, final String... exts) {",
      "parent_sha": "eca2c98278ec30e31c3953e0a030505987a6f8ca"
    }
  },
  {
    "oid": "3967a2bc8a766eae5cc5fb4a3647eaa1deda7e17",
    "message": "\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2012-01-02T11:50:01Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/3967a2bc8a766eae5cc5fb4a3647eaa1deda7e17",
    "details": {
      "sha": "baf5955f87b1827e7fba693be3faf1d988d4ff0a",
      "filename": "dex-tools/src/main/java/com/googlecode/dex2jar/tools/AsmVerify.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/3967a2bc8a766eae5cc5fb4a3647eaa1deda7e17/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FAsmVerify.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/3967a2bc8a766eae5cc5fb4a3647eaa1deda7e17/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FAsmVerify.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FAsmVerify.java?ref=3967a2bc8a766eae5cc5fb4a3647eaa1deda7e17",
      "patch": "@@ -106,9 +106,9 @@ public static void main(String[] args) throws IOException, IllegalArgumentExcept\n                 usage();\r\n                 return;\r\n             }\r\n+            System.out.println(\"Verify jar \" + file);\r\n             for (Enumeration<? extends ZipEntry> e = zip.entries(); e.hasMoreElements();) {\r\n                 ZipEntry zipEntry = e.nextElement();\r\n-                System.out.println(\"Verify jar \" + zipEntry.getName());\r\n                 if (!zipEntry.isDirectory() && zipEntry.getName().endsWith(\".class\")) {\r\n                     InputStream is = zip.getInputStream(zipEntry);\r\n                     ClassReader cr = new ClassReader(is);\r",
      "parent_sha": "dc2d808125af2239ef863d26652bd19f3f3ae259"
    }
  },
  {
    "oid": "30abff6618f27aea2d142ec7022da4e58c51ce16",
    "message": "disable end remove\n\n--HG--\nbranch : 2.x",
    "date": "2015-04-13T06:04:32Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/30abff6618f27aea2d142ec7022da4e58c51ce16",
    "details": {
      "sha": "85e3b83f9e22640331b0aac4275dd939271e4a1d",
      "filename": "dex-translator/src/main/java/com/googlecode/d2j/dex/Dex2jar.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/30abff6618f27aea2d142ec7022da4e58c51ce16/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FDex2jar.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/30abff6618f27aea2d142ec7022da4e58c51ce16/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FDex2jar.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FDex2jar.java?ref=30abff6618f27aea2d142ec7022da4e58c51ce16",
      "patch": "@@ -130,11 +130,11 @@ public void convertCode(DexMethodNode methodNode, MethodVisitor mv) {\n \n             @Override\n             public void optimize(IrMethod irMethod) {\n-                T_endRemove.transform(irMethod);\n                 T_cleanLabel.transform(irMethod);\n                 if (0 != (v3Config & V3.TOPOLOGICAL_SORT)) {\n                     // T_topologicalSort.transform(irMethod);\n                 }\n+                T_deadCode.transform(irMethod);\n                 T_removeLocal.transform(irMethod);\n                 T_removeConst.transform(irMethod);\n                 T_zero.transform(irMethod);",
      "parent_sha": "0ea25e833998283271c84971f60d1edd8e0e140b"
    }
  },
  {
    "oid": "5eebfbc642c77d0c5e2db515f9126ad6b3ffd7b9",
    "message": "fix type descriptor",
    "date": "2017-01-17T09:03:55Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/5eebfbc642c77d0c5e2db515f9126ad6b3ffd7b9",
    "details": {
      "sha": "40d3a58a1e731643a23853476641f0ac1c483d54",
      "filename": "dex-translator/src/main/java/com/googlecode/d2j/converter/J2IRConverter.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/5eebfbc642c77d0c5e2db515f9126ad6b3ffd7b9/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fconverter%2FJ2IRConverter.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/5eebfbc642c77d0c5e2db515f9126ad6b3ffd7b9/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fconverter%2FJ2IRConverter.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fconverter%2FJ2IRConverter.java?ref=5eebfbc642c77d0c5e2db515f9126ad6b3ffd7b9",
      "patch": "@@ -84,7 +84,7 @@ IrMethod convert0(String owner, MethodNode methodNode) throws AnalyzerException\n         if (methodNode.tryCatchBlocks != null) {\n             for (TryCatchBlockNode tcb : methodNode.tryCatchBlocks) {\n                 target.traps.add(new Trap(getLabel(tcb.start), getLabel(tcb.end), new LabelStmt[]{getLabel(tcb.handler)},\n-                        new String[]{tcb.type}));\n+                        new String[]{tcb.type == null ? null : Type.getObjectType(tcb.type).getDescriptor()}));\n                 int handlerIdx = insnList.indexOf(tcb.handler);\n                 handlers.set(handlerIdx);\n ",
      "parent_sha": "d6383b7d1df27d940e4934debad8357b03e76f3f"
    }
  },
  {
    "oid": "2bcafe0cddc50094732af3e9a54823cfaaf32826",
    "message": "more strict to read dex\n\n--HG--\nbranch : 2.x",
    "date": "2015-03-16T15:28:17Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/2bcafe0cddc50094732af3e9a54823cfaaf32826",
    "details": {
      "sha": "cdd867801949aff2457e713e2209c9a11dd555be",
      "filename": "dex-reader/src/main/java/com/googlecode/d2j/reader/DexFileReader.java",
      "status": "modified",
      "additions": 183,
      "deletions": 186,
      "changes": 369,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/2bcafe0cddc50094732af3e9a54823cfaaf32826/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Freader%2FDexFileReader.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/2bcafe0cddc50094732af3e9a54823cfaaf32826/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Freader%2FDexFileReader.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Freader%2FDexFileReader.java?ref=2bcafe0cddc50094732af3e9a54823cfaaf32826",
      "patch": "@@ -1014,176 +1014,213 @@ public final int getClassSize() {\n         return class_defs_size;\r\n     }\r\n \r\n-    private void findLabels(byte[] insns, BitSet nextBit, Map<Integer, DexLabel> labelsMap, Set<Integer> handlers,\r\n+    static class BadOpException extends RuntimeException{\r\n+        public BadOpException(String fmt,Object ...args){\r\n+            super(String.format(fmt,args));\r\n+        }\r\n+    }\r\n+\r\n+    private void findLabels(byte[] insns, BitSet nextBit, BitSet badOps, Map<Integer, DexLabel> labelsMap, Set<Integer> handlers,\r\n             Method method) {\r\n         Queue<Integer> q = new LinkedList<Integer>();\r\n         q.add(0);\r\n         q.addAll(handlers);\r\n         handlers.clear();\r\n-        Op[] values = Op.ops;\r\n         while (!q.isEmpty()) {\r\n             int offset = q.poll();\r\n             if (nextBit.get(offset)) {\r\n                 continue;\r\n             } else {\r\n                 nextBit.set(offset);\r\n             }\r\n-            int u1offset = offset * 2;\r\n-            if (u1offset >= insns.length) {\r\n-                continue;\r\n-            }\r\n-            int opcode = 0xFF & insns[u1offset];\r\n-            Op op = null;\r\n-            if (opcode < values.length) {\r\n-                op = values[opcode];\r\n-            }\r\n-            if (op == null || op.format == null) {\r\n-                WARN(\"GLITCH: zero-width instruction at %s, @0x%04x, op=0x%02x\", method.toString(), u1offset, opcode);\r\n-                continue;\r\n+            try {\r\n+                travelInsn(labelsMap, q, insns, offset);\r\n+            } catch (IndexOutOfBoundsException indexOutOfRange){\r\n+                badOps.set(offset);\r\n+                WARN(\"GLITCH: %04x %s | not enough space for reading instruction\", offset, method.toString());\r\n+            } catch (BadOpException badOp){\r\n+                badOps.set(offset);\r\n+                WARN(\"GLITCH: %04x %s | %s\", offset, method.toString(), badOp.getMessage());\r\n             }\r\n+        }\r\n+    }\r\n \r\n-            int target;\r\n-            boolean canContinue = true;\r\n-            if (op.canBranch()) {\r\n-                switch (op.format) {\r\n-                case kFmt10t:\r\n-                    target = offset + insns[u1offset + 1];\r\n-                    q.add(target);\r\n-                    order(labelsMap, target);\r\n-                    break;\r\n-                case kFmt20t:\r\n-                case kFmt21t:\r\n-                    target = offset + sshort(insns, u1offset + 2);\r\n-                    q.add(target);\r\n-                    order(labelsMap, target);\r\n-                    break;\r\n-                case kFmt22t:\r\n-                    target = offset + sshort(insns, u1offset + 2);\r\n-                    int u = ubyte(insns, u1offset + 1);\r\n-                    boolean cmpSameReg = (u & 0x0F) == ((u >> 4) & 0x0F);\r\n-                    boolean skipTarget = false;\r\n-                    if (cmpSameReg) {\r\n-                        switch (op) {\r\n-                        case IF_EQ:\r\n-                        case IF_GE:\r\n-                        case IF_LE:\r\n-                            // means always jump, equals to goto\r\n-                            canContinue = false;\r\n-                            break;\r\n-                        case IF_NE:\r\n-                        case IF_GT:\r\n-                        case IF_LT:\r\n-                            // means always not jump\r\n-                            skipTarget = true;\r\n-                            break;\r\n-                        default:\r\n-                            break;\r\n-                        }\r\n+    private void travelInsn(Map<Integer, DexLabel> labelsMap, Queue<Integer> q, byte[] insns, int offset) {\r\n+        int u1offset = offset * 2;\r\n+        if (u1offset >= insns.length) {\r\n+            throw new IndexOutOfBoundsException();\r\n+        }\r\n+        int opcode = 0xFF & insns[u1offset];\r\n+        Op op = null;\r\n+        if (opcode < Op.ops.length) {\r\n+            op = Op.ops[opcode];\r\n+        }\r\n+        if (op == null || op.format == null) {\r\n+            throw new BadOpException(\"zero-width instruction op=0x%02x\", opcode);\r\n+        }\r\n+        int target;\r\n+        boolean canContinue = true;\r\n+        if (op.canBranch()) {\r\n+            switch (op.format) {\r\n+            case kFmt10t:\r\n+                target = offset + insns[u1offset + 1];\r\n+                if (target < 0 || target * 2 > insns.length ) {\r\n+                    throw new BadOpException(\"jump out of insns %s -> %04x\", op, target);\r\n+                }\r\n+                q.add(target);\r\n+                order(labelsMap, target);\r\n+                break;\r\n+            case kFmt20t:\r\n+            case kFmt21t:\r\n+                target = offset + sshort(insns, u1offset + 2);\r\n+                if (target < 0 || target * 2 > insns.length ) {\r\n+                    throw new BadOpException(\"jump out of insns %s -> %04x\", op, target);\r\n+                }\r\n+                q.add(target);\r\n+                order(labelsMap, target);\r\n+                break;\r\n+            case kFmt22t:\r\n+                target = offset + sshort(insns, u1offset + 2);\r\n+\r\n+                int u = ubyte(insns, u1offset + 1);\r\n+                boolean cmpSameReg = (u & 0x0F) == ((u >> 4) & 0x0F);\r\n+                boolean skipTarget = false;\r\n+                if (cmpSameReg) {\r\n+                    switch (op) {\r\n+                    case IF_EQ:\r\n+                    case IF_GE:\r\n+                    case IF_LE:\r\n+                        // means always jump, equals to goto\r\n+                        canContinue = false;\r\n+                        break;\r\n+                    case IF_NE:\r\n+                    case IF_GT:\r\n+                    case IF_LT:\r\n+                        // means always not jump\r\n+                        skipTarget = true;\r\n+                        break;\r\n+                    default:\r\n+                        break;\r\n                     }\r\n-                    if (!skipTarget) {\r\n-                        q.add(target);\r\n-                        order(labelsMap, target);\r\n+                }\r\n+                if (!skipTarget) {\r\n+                    if (target < 0 || target * 2 > insns.length ) {\r\n+                        throw new BadOpException(\"jump out of insns %s -> %04x\", op, target);\r\n                     }\r\n-                    break;\r\n-                case kFmt30t:\r\n-                case kFmt31t:\r\n-                    target = offset + sint(insns, u1offset + 2);\r\n                     q.add(target);\r\n                     order(labelsMap, target);\r\n-                    break;\r\n-                default:\r\n-                    break;\r\n                 }\r\n+                break;\r\n+            case kFmt30t:\r\n+            case kFmt31t:\r\n+                target = offset + sint(insns, u1offset + 2);\r\n+                if (target < 0 || target * 2 > insns.length ) {\r\n+                    throw new BadOpException(\"jump out of insns %s -> %04x\", op, target);\r\n+                }\r\n+                q.add(target);\r\n+                order(labelsMap, target);\r\n+                break;\r\n+            default:\r\n+                break;\r\n             }\r\n-            if (op.canSwitch()) {\r\n-                order(labelsMap, offset + op.format.size);// default\r\n-                int u1SwitchData = 2 * (offset + sint(insns, u1offset + 2));\r\n-                if (u1SwitchData < insns.length) {\r\n+        }\r\n+        if (op.canSwitch()) {\r\n+            order(labelsMap, offset + op.format.size);// default\r\n+            int u1SwitchData = 2 * (offset + sint(insns, u1offset + 2));\r\n+            if (u1SwitchData + 2 < insns.length) {\r\n+\r\n                     switch (insns[u1SwitchData + 1]) {\r\n-                    case 0x01: // packed-switch-data\r\n-                    {\r\n-                        int size = ushort(insns, u1SwitchData + 2);\r\n-                        int b = u1SwitchData + 8;// targets\r\n-                        for (int i = 0; i < size; i++) {\r\n-                            target = offset + sint(insns, b + i * 4);\r\n-                            q.add(target);\r\n-                            order(labelsMap, target);\r\n+                        case 0x01: // packed-switch-data\r\n+                        {\r\n+                            int size = ushort(insns, u1SwitchData + 2);\r\n+                            int b = u1SwitchData + 8;// targets\r\n+                            for (int i = 0; i < size; i++) {\r\n+                                target = offset + sint(insns, b + i * 4);\r\n+                                if (target < 0 || target * 2 > insns.length ) {\r\n+                                    throw new BadOpException(\"jump out of insns %s -> %04x\", op, target);\r\n+                                }\r\n+                                q.add(target);\r\n+                                order(labelsMap, target);\r\n+                            }\r\n+                            break;\r\n                         }\r\n-                        break;\r\n-                    }\r\n-                    case 0x02:// sparse-switch-data\r\n-                    {\r\n-                        int size = ushort(insns, u1SwitchData + 2);\r\n-                        int b = u1SwitchData + 4 + 4 * size;// targets\r\n-                        for (int i = 0; i < size; i++) {\r\n-                            target = offset + sint(insns, b + i * 4);\r\n-                            q.add(target);\r\n-                            order(labelsMap, target);\r\n+                        case 0x02:// sparse-switch-data\r\n+                        {\r\n+                            int size = ushort(insns, u1SwitchData + 2);\r\n+                            int b = u1SwitchData + 4 + 4 * size;// targets\r\n+                            for (int i = 0; i < size; i++) {\r\n+                                target = offset + sint(insns, b + i * 4);\r\n+                                if (target < 0 || target * 2 > insns.length ) {\r\n+                                    throw new BadOpException(\"jump out of insns %s -> %04x\", op, target);\r\n+                                }\r\n+                                q.add(target);\r\n+                                order(labelsMap, target);\r\n+                            }\r\n+                            break;\r\n                         }\r\n-                        break;\r\n-                    }\r\n+                        default:\r\n+                            throw new BadOpException(\"bad payload for %s\", op);\r\n                     }\r\n-                } else {\r\n-                    WARN(\"bad offset for switch @%04x\", offset);\r\n+            } else {\r\n+                throw new BadOpException(\"bad payload offset for %s\", op);\r\n+            }\r\n+        }\r\n+\r\n+        if (canContinue) {\r\n+            int idx = Integer.MAX_VALUE;\r\n+            switch (op.indexType) {\r\n+            case kIndexStringRef:\r\n+                if (op.format == InstructionFormat.kFmt31c) {\r\n+                    idx = uint(insns, u1offset + 2);\r\n+                } else {// other\r\n+                    idx = ushort(insns, u1offset + 2);\r\n                 }\r\n+                canContinue = idx >= 0 && idx < string_ids_size;\r\n+                break;\r\n+            case kIndexTypeRef:\r\n+                idx = ushort(insns, u1offset + 2);\r\n+                canContinue = idx < type_ids_size;\r\n+                break;\r\n+            case kIndexMethodRef:\r\n+                idx = ushort(insns, u1offset + 2);\r\n+                canContinue = idx < method_ids_size;\r\n+                break;\r\n+            case kIndexFieldRef:\r\n+                idx = ushort(insns, u1offset + 2);\r\n+                canContinue = idx < field_ids_size;\r\n+                break;\r\n+            default:\r\n             }\r\n+            if (!canContinue) {\r\n+                throw new BadOpException(\"index-out-of-range for %s index: %d\", op, idx);\r\n+            }\r\n+        }\r\n \r\n-            if (canContinue) {\r\n-                int idx;\r\n-                switch (op.indexType) {\r\n-                case kIndexStringRef:\r\n-                    if (op.format == InstructionFormat.kFmt31c) {\r\n-                        idx = uint(insns, u1offset + 2);\r\n-                    } else {// other\r\n-                        idx = ushort(insns, u1offset + 2);\r\n-                    }\r\n-                    canContinue = idx >= 0 && idx < string_ids_size;\r\n+        if (canContinue && op.canContinue()) {\r\n+            if (op == Op.NOP) {\r\n+                switch (insns[u1offset + 1]) {\r\n+                case 0x00:\r\n+                    q.add(offset + op.format.size);\r\n                     break;\r\n-                case kIndexTypeRef:\r\n-                    idx = ushort(insns, u1offset + 2);\r\n-                    canContinue = idx < type_ids_size;\r\n+                case 0x01: {\r\n+                    int size = ushort(insns, u1offset + 2);\r\n+                    q.add(offset + (size * 2) + 4);\r\n                     break;\r\n-                case kIndexMethodRef:\r\n-                    idx = ushort(insns, u1offset + 2);\r\n-                    canContinue = idx < method_ids_size;\r\n+                }\r\n+                case 0x02: {\r\n+                    int size = ushort(insns, u1offset + 2);\r\n+                    q.add(offset + (size * 4) + 2);\r\n                     break;\r\n-                case kIndexFieldRef:\r\n-                    idx = ushort(insns, u1offset + 2);\r\n-                    canContinue = idx < field_ids_size;\r\n+                }\r\n+                case 0x03: {\r\n+                    int element_width = ushort(insns, u1offset + 2);\r\n+                    int size = uint(insns, u1offset + 4);\r\n+                    q.add(offset + (size * element_width + 1) / 2 + 4);\r\n                     break;\r\n-                default:\r\n                 }\r\n-                if (!canContinue) {\r\n-                    WARN(\"GLITCH: index-out-of-range at %s for %s @%04x\", method.toString(), op, offset);\r\n-                }\r\n-            }\r\n-\r\n-            if (canContinue && op.canContinue()) {\r\n-                if (op == Op.NOP) {\r\n-                    switch (insns[u1offset + 1]) {\r\n-                    case 0x00:\r\n-                        q.add(offset + op.format.size);\r\n-                        break;\r\n-                    case 0x01: {\r\n-                        int size = ushort(insns, u1offset + 2);\r\n-                        q.add(offset + (size * 2) + 4);\r\n-                        break;\r\n-                    }\r\n-                    case 0x02: {\r\n-                        int size = ushort(insns, u1offset + 2);\r\n-                        q.add(offset + (size * 4) + 2);\r\n-                        break;\r\n-                    }\r\n-                    case 0x03: {\r\n-                        int element_width = ushort(insns, u1offset + 2);\r\n-                        int size = uint(insns, u1offset + 4);\r\n-                        q.add(offset + (size * element_width + 1) / 2 + 4);\r\n-                        break;\r\n-                    }\r\n-                    }\r\n-                } else {\r\n-                    q.add(offset + op.format.size);\r\n                 }\r\n+            } else {\r\n+                q.add(offset + op.format.size);\r\n             }\r\n         }\r\n     }\r\n@@ -1230,7 +1267,6 @@ private void findTryCatch(ByteBuffer in, DexCodeVisitor dcv, int tries_size, int\n                 labels[listSize] = labelsMap.get(handler);\r\n             }\r\n             dcv.visitTryCatch(labelsMap.get(start_addr), labelsMap.get(end), labels, types);\r\n-\r\n         }\r\n     }\r\n \r\n@@ -1266,13 +1302,14 @@ private void findTryCatch(ByteBuffer in, DexCodeVisitor dcv, int tries_size, int\n             }\r\n         }\r\n \r\n-        findLabels(insnsArray, nextInsn, labelsMap, handlers, method);\r\n-        acceptInsn(insnsArray, dcv, nextInsn, labelsMap);\r\n+        BitSet badOps = new BitSet();\r\n+        findLabels(insnsArray, nextInsn, badOps, labelsMap, handlers, method);\r\n+        acceptInsn(insnsArray, dcv, nextInsn, badOps, labelsMap);\r\n         dcv.visitEnd();\r\n     }\r\n \r\n     // \u5904\u7406\u6307\u4ee4\r\n-    private void acceptInsn(byte[] insns, DexCodeVisitor dcv, BitSet nextInsn, Map<Integer, DexLabel> labelsMap) {\r\n+    private void acceptInsn(byte[] insns, DexCodeVisitor dcv, BitSet nextInsn, BitSet badOps, Map<Integer, DexLabel> labelsMap) {\r\n         Iterator<Integer> labelOffsetIterator = labelsMap.keySet().iterator();\r\n         Integer nextLabelOffset = labelOffsetIterator.hasNext() ? labelOffsetIterator.next() : null;\r\n         Op[] values = Op.ops;\r\n@@ -1288,52 +1325,16 @@ private void acceptInsn(byte[] insns, DexCodeVisitor dcv, BitSet nextInsn, Map<I\n                     break;\r\n                 }\r\n             }\r\n-            int u1offset = offset * 2;\r\n-            if (u1offset >= insns.length) {\r\n-                continue;\r\n-            }\r\n-            int opcode = 0xFF & insns[u1offset];\r\n \r\n-            Op op = null;\r\n-            if (opcode < values.length) {\r\n-                op = values[opcode];\r\n-            }\r\n-            if (op == null || op.format == null) {\r\n+            if(badOps.get(offset)){\r\n                 dcv.visitStmt0R(Op.BAD_OP);\r\n                 continue;\r\n             }\r\n \r\n-            {\r\n-                boolean canContinue = true;\r\n-                int idx;\r\n-                switch (op.indexType) {\r\n-                case kIndexStringRef:\r\n-                    if (op.format == InstructionFormat.kFmt31c) {\r\n-                        idx = uint(insns, u1offset + 2);\r\n-                    } else {// other\r\n-                        idx = ushort(insns, u1offset + 2);\r\n-                    }\r\n-                    canContinue = idx >= 0 && idx < string_ids_size;\r\n-                    break;\r\n-                case kIndexTypeRef:\r\n-                    idx = ushort(insns, u1offset + 2);\r\n-                    canContinue = idx < type_ids_size;\r\n-                    break;\r\n-                case kIndexMethodRef:\r\n-                    idx = ushort(insns, u1offset + 2);\r\n-                    canContinue = idx < method_ids_size;\r\n-                    break;\r\n-                case kIndexFieldRef:\r\n-                    idx = ushort(insns, u1offset + 2);\r\n-                    canContinue = idx < field_ids_size;\r\n-                    break;\r\n-                default:\r\n-                }\r\n-                if (!canContinue) {\r\n-                    dcv.visitStmt0R(Op.BAD_OP);\r\n-                    continue;\r\n-                }\r\n-            }\r\n+            int u1offset = offset * 2;\r\n+            int opcode = 0xFF & insns[u1offset];\r\n+\r\n+            Op op = values[opcode];\r\n \r\n             int a, b, c, target;\r\n             switch (op.format) {\r\n@@ -1399,10 +1400,6 @@ private void acceptInsn(byte[] insns, DexCodeVisitor dcv, BitSet nextInsn, Map<I\n                 target = offset + sint(insns, u1offset + 2);\r\n                 a = ubyte(insns, u1offset + 1);\r\n                 int u1SwitchData = 2 * target;\r\n-                if (u1SwitchData >= insns.length) {\r\n-                    dcv.visitStmt0R(Op.BAD_OP);\r\n-                    break;\r\n-                }\r\n                 if (op == Op.FILL_ARRAY_DATA) {\r\n                     int element_width = ushort(insns, u1SwitchData + 2);\r\n                     int size = uint(insns, u1SwitchData + 4);\r",
      "parent_sha": "2ea2f457414ffbfd4e1035f889d3bb72f2480b99"
    }
  },
  {
    "oid": "31305dbf592c43773b1b87ab18cf57fcd97155b5",
    "message": "maks ZipInputStreamHack for openjdk6\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2013-04-26T02:56:32Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/31305dbf592c43773b1b87ab18cf57fcd97155b5",
    "details": {
      "sha": "7cb0633aa2b2679ef7afeee4564b79badd2c5645",
      "filename": "dex-reader/src/main/java/com/googlecode/dex2jar/reader/ZipInputStreamHack.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/31305dbf592c43773b1b87ab18cf57fcd97155b5/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FZipInputStreamHack.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/31305dbf592c43773b1b87ab18cf57fcd97155b5/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FZipInputStreamHack.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FZipInputStreamHack.java?ref=31305dbf592c43773b1b87ab18cf57fcd97155b5",
      "patch": "@@ -90,7 +90,7 @@ protected ZipEntry createZipEntry(String name) {\n         }\n         if (tmpbufField != null) {// for openjdk6\n             try {\n-                byte[] buffer = (byte[]) flagField.get(this);\n+                byte[] buffer = (byte[]) tmpbufField.get(this);\n                 int flagLow8 = buffer[6];// 6 is for LOCFLG\n                 flagLow8 = (flagLow8 >> 1) << 1;\n                 buffer[6] = (byte) flagLow8;",
      "parent_sha": "363489455b14c36756b0196560e6b7e7e1bc15fd"
    }
  },
  {
    "oid": "264b8c58fffb350ee6dab610e74ef745eb6c5f17",
    "message": "replace getParameterCount with getParameterTypes().length for jdk7\n\n--HG--\nbranch : 2.x",
    "date": "2015-03-22T13:00:54Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/264b8c58fffb350ee6dab610e74ef745eb6c5f17",
    "details": {
      "sha": "198898bb40fa31dee140cc5377e1bf2148d4edad",
      "filename": "dex-tools/src/main/java/com/googlecode/dex2jar/tools/DecryptStringCmd.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/264b8c58fffb350ee6dab610e74ef745eb6c5f17/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FDecryptStringCmd.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/264b8c58fffb350ee6dab610e74ef745eb6c5f17/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FDecryptStringCmd.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FDecryptStringCmd.java?ref=264b8c58fffb350ee6dab610e74ef745eb6c5f17",
      "patch": "@@ -400,7 +400,7 @@ public Value travel(Value op) {\n                     if (c != null) {\n                         try {\n                             Method jmethod = c.jmethod;\n-                            if (ie.args.length != jmethod.getParameterCount()) {\n+                            if (ie.args.length != jmethod.getParameterTypes().length) {\n                                 throw new RuntimeException();\n                             }\n                             Object args[] = new Object[ie.args.length];",
      "parent_sha": "d7cdf0644b18fd32986268b151dea224f8d0dfc9"
    }
  },
  {
    "oid": "1a6bfd92015baf8d14782af8cc5e242bbae385c4",
    "message": "add support to detect dup methods\n\nFixes issue 200\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2013-11-06T06:27:58Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/1a6bfd92015baf8d14782af8cc5e242bbae385c4",
    "details": {
      "sha": "5a5a74885f00cae682258a68969c76586cc184cd",
      "filename": "dex-reader/src/main/java/com/googlecode/dex2jar/reader/DexFileReader.java",
      "status": "modified",
      "additions": 29,
      "deletions": 5,
      "changes": 34,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/1a6bfd92015baf8d14782af8cc5e242bbae385c4/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexFileReader.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/1a6bfd92015baf8d14782af8cc5e242bbae385c4/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexFileReader.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexFileReader.java?ref=1a6bfd92015baf8d14782af8cc5e242bbae385c4",
      "patch": "@@ -102,6 +102,13 @@ public class DexFileReader {\n     * ingore read exception\r\n     */\r\n     public static final int IGNORE_READ_EXCEPTION = 1 << 5;\r\n+\r\n+    /**\r\n+     * read all methods, even if they are glitch\r\n+     */\r\n+    public static final int KEEP_ALL_METHODS = 1 << 6;\r\n+\r\n+\r\n     private final boolean odex;\r\n     private DataIn odex_in;\r\n     private int odex_depsOffset;\r\n@@ -459,15 +466,19 @@ private void acceptClass(DexFileVisitor dv, DexClassVisitor dcv, String classNam\n                     for (int i = 0; i < instance_fields; i++) {\r\n                         lastIndex = acceptField(lastIndex, dcv, fieldAnnotationPositions, null, config);\r\n                     }\r\n+                    boolean firstMethod = true;\r\n                     lastIndex = 0;\r\n                     for (int i = 0; i < direct_methods; i++) {\r\n                         lastIndex = acceptMethod(lastIndex, dcv, methodAnnotationPositions, paramAnnotationPositions,\r\n-                                config);\r\n+                                config, firstMethod);\r\n+                        firstMethod = false;\r\n                     }\r\n+                    firstMethod = true;\r\n                     lastIndex = 0;\r\n                     for (int i = 0; i < virtual_methods; i++) {\r\n                         lastIndex = acceptMethod(lastIndex, dcv, methodAnnotationPositions, paramAnnotationPositions,\r\n-                                config);\r\n+                                config, firstMethod);\r\n+                        firstMethod = false;\r\n                     }\r\n                 }\r\n             } finally {\r\n@@ -645,30 +656,43 @@ public final void setApiLevel(int apiLevel) {\n     /**\r\n      * \u8bbf\u95ee\u65b9\u6cd5\r\n      * \r\n+     *\r\n      * @param lastIndex\r\n      * @param cv\r\n      * @param methodAnnos\r\n      * @param parameterAnnos\r\n+     * @param firstMethod\r\n      * @return\r\n      */\r\n     /* default */int acceptMethod(int lastIndex, DexClassVisitor cv, Map<Integer, Integer> methodAnnos,\r\n-            Map<Integer, Integer> parameterAnnos, int config) {\r\n+                                  Map<Integer, Integer> parameterAnnos, int config, boolean firstMethod) {\r\n         DataIn in = this.in;\r\n         int diff = (int) in.readULeb128();\r\n         int method_access_flags = (int) in.readULeb128();\r\n         int code_off = (int) in.readULeb128();\r\n         int method_id = lastIndex + diff;\r\n         Method method = getMethod(method_id);\r\n \r\n+        // issue 200, methods may have same signature, we only need to keep the first one\r\n+        if (!firstMethod && diff == 0) {  // detect a duplicated method\r\n+            System.out.printf(\"GLITCH: duplicated method %s\\n\", method.toString());\r\n+            if ((config & KEEP_ALL_METHODS) == 0) {\r\n+                System.out.printf(\"WARN: skip method %s\\n\", method.toString());\r\n+                return method_id;\r\n+            }\r\n+        }\r\n+\r\n         // issue 195, a <clinit> or <init> but not marked as ACC_CONSTRUCTOR,\r\n         // skip the method\r\n         if (0 == (method_access_flags & DexOpcodes.ACC_CONSTRUCTOR)\r\n                 && (method.getName().equals(\"<init>\") || method.getName()\r\n                         .equals(\"<clinit>\"))) {\r\n             System.err.println(\"GLITCH: method \" + method.toString()\r\n                     + \" not marked as ACC_CONSTRUCTOR\");\r\n-            System.err.println(\"WARN: skip method \" + method.toString());\r\n-            return method_id;\r\n+            if ((config & KEEP_ALL_METHODS) == 0) {\r\n+                System.out.printf(\"WARN: skip method %s\\n\", method.toString());\r\n+                return method_id;\r\n+            }\r\n         }\r\n \r\n         try {\r",
      "parent_sha": "d3c357493bf6b1377ca1875c1c9e2fe40ed777cb"
    }
  },
  {
    "oid": "922e27a59999c053f4989be9a034bd8992d69ecb",
    "message": "add support for register allocation\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2011-12-05T11:37:23Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/922e27a59999c053f4989be9a034bd8992d69ecb",
    "details": {
      "sha": "33ebf6e4ece4b06a9dabc32c160345dde84e2879",
      "filename": "dex-translator/src/main/java/com/googlecode/dex2jar/v3/IrMethod2AsmMethod.java",
      "status": "modified",
      "additions": 342,
      "deletions": 34,
      "changes": 376,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/922e27a59999c053f4989be9a034bd8992d69ecb/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FIrMethod2AsmMethod.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/922e27a59999c053f4989be9a034bd8992d69ecb/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FIrMethod2AsmMethod.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FIrMethod2AsmMethod.java?ref=922e27a59999c053f4989be9a034bd8992d69ecb",
      "patch": "@@ -1,5 +1,13 @@\n package com.googlecode.dex2jar.v3;\r\n \r\n+import java.util.ArrayList;\r\n+import java.util.BitSet;\r\n+import java.util.Collections;\r\n+import java.util.Comparator;\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Set;\r\n+\r\n import org.objectweb.asm.Label;\r\n import org.objectweb.asm.MethodVisitor;\r\n import org.objectweb.asm.Opcodes;\r\n@@ -29,66 +37,360 @@\n import com.googlecode.dex2jar.ir.stmt.LabelStmt;\r\n import com.googlecode.dex2jar.ir.stmt.LookupSwitchStmt;\r\n import com.googlecode.dex2jar.ir.stmt.Stmt;\r\n+import com.googlecode.dex2jar.ir.stmt.Stmt.E1Stmt;\r\n import com.googlecode.dex2jar.ir.stmt.Stmt.E2Stmt;\r\n+import com.googlecode.dex2jar.ir.stmt.Stmt.EnStmt;\r\n+import com.googlecode.dex2jar.ir.stmt.Stmt.ST;\r\n import com.googlecode.dex2jar.ir.stmt.TableSwitchStmt;\r\n import com.googlecode.dex2jar.ir.stmt.UnopStmt;\r\n import com.googlecode.dex2jar.ir.ts.Cfg;\r\n-import com.googlecode.dex2jar.ir.ts.Cfg.StmtVisitor;\r\n+import com.googlecode.dex2jar.ir.ts.Cfg.FrameVisitor;\r\n import com.googlecode.dex2jar.ir.ts.LocalType;\r\n \r\n public class IrMethod2AsmMethod implements Opcodes {\r\n \r\n+    @SuppressWarnings(\"serial\")\r\n+    static class Phi extends HashSet<Phi> {\r\n+        Phi() {\r\n+            super(3);\r\n+        }\r\n+\r\n+        boolean used;\r\n+        Phi tag;\r\n+        Local local;\r\n+\r\n+        public String toString() {\r\n+            if (tag != null) {\r\n+                return tag.toString();\r\n+            }\r\n+            if (local != null) {\r\n+                return local.toString();\r\n+            }\r\n+            return \"?\";\r\n+        }\r\n+\r\n+        @Override\r\n+        public int hashCode() {\r\n+            return System.identityHashCode(this);\r\n+        }\r\n+\r\n+        @Override\r\n+        public boolean equals(Object obj) {\r\n+            return this == obj;\r\n+        }\r\n+    }\r\n+\r\n+    static Phi trim(Phi phi) {\r\n+        while (phi.tag != null) {\r\n+            phi = phi.tag;\r\n+        }\r\n+        return phi;\r\n+    }\r\n+\r\n     private void reIndexLocal(IrMethod ir) {\r\n         int index = 0;\r\n         if ((ir.access & ACC_STATIC) == 0) {\r\n             index++;\r\n         }\r\n-        final int ids[] = new int[ir.args.length];\r\n+        final int localSize = ir.locals.size();\r\n+        final int parameterIdx[] = new int[ir.args.length];\r\n         for (int i = 0; i < ir.args.length; i++) {\r\n-            ids[i] = index;\r\n+            parameterIdx[i] = index;\r\n             index += ir.args[i].getSize();\r\n         }\r\n+        int[] maps = new int[localSize];\r\n+        index = 0;\r\n         for (Local local : ir.locals) {\r\n-            local._ls_index = -1;\r\n+            local._ls_index = index++;\r\n+            local.name = \"a\" + local._ls_index;\r\n+        }\r\n+        for (int i = 0; i < localSize; i++) {\r\n+            maps[i] = -1;\r\n+        }\r\n+\r\n+        liveLocalAnalyze(localSize, ir, maps, parameterIdx);\r\n+\r\n+        for (Local local : ir.locals) {\r\n+            local._ls_index = maps[local._ls_index];\r\n+            if (local._ls_index >= 0) {\r\n+                local.name = \"a\" + local._ls_index;\r\n+            } else {\r\n+                local.name = \"ignore\";\r\n+            }\r\n         }\r\n+    }\r\n+\r\n+    private void liveLocalAnalyze(final int localSize, IrMethod ir, final int maps[], final int parameterIdx[]) {\r\n+\r\n+        final List<Phi> phis = new ArrayList<Phi>(30);\r\n+\r\n+        Cfg.createCFG(ir);\r\n+        Cfg.Forward(ir, new FrameVisitor<Phi[]>() {\r\n \r\n-        final int[] indexHolder = new int[] { index };\r\n-        Cfg.createCFG(ir);//\r\n-        Cfg.Forward(ir, new StmtVisitor<Object>() {\r\n             @Override\r\n-            public Object exec(Stmt stmt) {\r\n-                switch (stmt.st) {\r\n-                case ASSIGN:\r\n-                case IDENTITY:\r\n-                    if (((AssignStmt) stmt).op1.value.vt == VT.LOCAL) {\r\n+            public Phi[] exec(Stmt stmt) {\r\n+                Phi[] frame = (Phi[]) stmt._ls_forward_frame;\r\n+                if (frame == null) {\r\n+                    frame = new Phi[localSize];\r\n+                    stmt._ls_forward_frame = frame;\r\n+                }\r\n+                Phi[] result = frame;\r\n+                switch (stmt.et) {\r\n+                case E0:\r\n+                    break;\r\n+                case E1:\r\n+                    use(((E1Stmt) stmt).op, result);\r\n+                    break;\r\n+                case E2:\r\n+                    E2Stmt e2 = (E2Stmt) stmt;\r\n+                    if ((e2.st == ST.ASSIGN || e2.st == ST.IDENTITY) && (((AssignStmt) stmt).op1.value.vt == VT.LOCAL)) {\r\n                         Local local = (Local) ((AssignStmt) stmt).op1.value;\r\n-                        if (local._ls_index == -1) {\r\n-                            Type localType = LocalType.typeOf(local);\r\n-                            if (!Type.VOID_TYPE.equals(localType)) {// skip void type\r\n-                                Value ref = (Value) ((AssignStmt) stmt).op2.value;\r\n-                                switch (ref.vt) {\r\n-                                case THIS_REF:\r\n-                                    local._ls_index = 0;\r\n-                                    break;\r\n-                                case PARAMETER_REF:\r\n-                                    local._ls_index = ids[((RefExpr) ref).parameterIndex];\r\n-                                    break;\r\n-                                case EXCEPTION_REF:\r\n-                                    local._ls_index = indexHolder[0]++;\r\n-                                    break;\r\n-                                default:\r\n-                                    local._ls_index = indexHolder[0];\r\n-                                    indexHolder[0] += LocalType.typeOf(ref).getSize();\r\n-                                    break;\r\n-                                }\r\n+                        Type localType = LocalType.typeOf(local);\r\n+                        use(e2.op2, result);\r\n+                        if (!Type.VOID_TYPE.equals(localType)) {\r\n+                            result = new Phi[localSize];\r\n+                            System.arraycopy(frame, 0, result, 0, localSize);\r\n+                            Phi phi = new Phi();\r\n+                            phis.add(phi);\r\n+                            result[local._ls_index] = phi;\r\n+                            Value ref = ((AssignStmt) stmt).op2.value;\r\n+                            switch (ref.vt) {\r\n+                            case THIS_REF:\r\n+                                maps[local._ls_index] = 0;\r\n+                                break;\r\n+                            case PARAMETER_REF:\r\n+                                maps[local._ls_index] = parameterIdx[((RefExpr) ref).parameterIndex];\r\n+                                break;\r\n                             }\r\n                         }\r\n+                    } else {\r\n+                        use(e2.op1, result);\r\n+                        use(e2.op2, result);\r\n+                    }\r\n+                    break;\r\n+                case En:\r\n+                    EnStmt en = (EnStmt) stmt;\r\n+                    for (ValueBox vb : en.ops) {\r\n+                        use(vb, result);\r\n+                    }\r\n+                    break;\r\n+                }\r\n+\r\n+                return result;\r\n+            }\r\n+\r\n+            private void use(ValueBox op, Phi[] frame) {\r\n+                if (op == null) {\r\n+                    return;\r\n+                }\r\n+                Value v = op.value;\r\n+                switch (v.et) {\r\n+                case E0:\r\n+                    if (v.vt == VT.LOCAL) {\r\n+                        Local local = (Local) v;\r\n+                        frame[local._ls_index].used = true;\r\n+                        frame[local._ls_index].local = local;\r\n+                    }\r\n+                    break;\r\n+                case E1:\r\n+                    use(((E1Expr) v).op, frame);\r\n+                    break;\r\n+                case E2:\r\n+                    E2Expr e2 = (E2Expr) v;\r\n+                    use(e2.op1, frame);\r\n+                    use(e2.op2, frame);\r\n+                    break;\r\n+                case En:\r\n+                    EnExpr en = (EnExpr) v;\r\n+                    for (ValueBox vb : en.ops) {\r\n+                        use(vb, frame);\r\n                     }\r\n                     break;\r\n                 }\r\n-                return null;\r\n+            }\r\n+\r\n+            @Override\r\n+            public void merge(Phi[] frame, Stmt dist) {\r\n+                Phi[] distFrame = (Phi[]) dist._ls_forward_frame;\r\n+                if (distFrame == null) {\r\n+                    distFrame = new Phi[localSize];\r\n+                    dist._ls_forward_frame = distFrame;\r\n+                }\r\n+\r\n+                for (int i = 0; i < localSize; i++) {\r\n+                    Phi srcPhi = frame[i];\r\n+                    if (srcPhi != null) {\r\n+                        Phi distPhi = distFrame[i];\r\n+                        if (distPhi == null) {\r\n+                            if (!dist._cfg_visited) {\r\n+                                distPhi = new Phi();\r\n+                                phis.add(distPhi);\r\n+                                distFrame[i] = distPhi;\r\n+                                distPhi.add(srcPhi);\r\n+                            }\r\n+                        } else {\r\n+                            distPhi.add(srcPhi);\r\n+                        }\r\n+                    }\r\n+                }\r\n+            }\r\n+        });\r\n+\r\n+        Set<Phi> used = new HashSet<Phi>(phis.size() / 2);\r\n+        for (Phi reg : phis) {\r\n+            doAddUsed(reg, used);\r\n+        }\r\n+        for (Phi reg : used) {\r\n+            Phi a = trim(reg);\r\n+            if (a != reg && reg.local != null) {\r\n+                a.local = reg.local;\r\n+            }\r\n+            if (reg.size() > 0) {\r\n+                for (Phi r : reg) {\r\n+                    Phi b = trim(r);\r\n+                    if (a != b) {\r\n+                        b.tag = a;\r\n+                        if (b.local != null) {\r\n+                            a.local = b.local;\r\n+                        }\r\n+                    }\r\n+                }\r\n+            }\r\n+        }\r\n+        phis.clear();\r\n+        for (Phi r : used) {\r\n+            if (r.used && r.tag == null) {\r\n+                r.clear();\r\n+                phis.add(r);\r\n+            }\r\n+        }\r\n+        used.clear();\r\n+\r\n+        createGraph(ir, phis.size());\r\n+\r\n+        gradyColoring(phis, maps);\r\n+\r\n+    }\r\n+\r\n+    private int findNextColor(Phi v, int n, int max, int[] maps) {\r\n+        BitSet bs = new BitSet(max);\r\n+        bs.set(0, max);\r\n+        for (Phi one : v) {\r\n+            int x = maps[one.local._ls_index];\r\n+            if (x >= 0) {\r\n+                bs.clear(x);\r\n+                if (sizeOf(one) > 1) {\r\n+                    bs.clear(x + 1);\r\n+                }\r\n+            }\r\n+        }\r\n+        boolean wide = sizeOf(v) > 1;\r\n+        for (int i = bs.nextSetBit(n); i >= 0; i = bs.nextSetBit(i + 1)) {\r\n+            if (wide) {\r\n+                if (i + 1 < bs.length() && bs.get(i + 1)) {\r\n+                    return i;\r\n+                }\r\n+            } else {\r\n+                return i;\r\n+            }\r\n+        }\r\n+        return -1;\r\n+    }\r\n+\r\n+    private void gradyColoring(List<Phi> phis, int[] maps) {\r\n+        if (phis.size() <= 0) {\r\n+            return;\r\n+        }\r\n+        // sort\r\n+        Collections.sort(phis, new Comparator<Phi>() {\r\n+            @Override\r\n+            public int compare(Phi o1, Phi o2) {\r\n+                int r = o2.size() - o1.size();\r\n+                return r == 0 ? sizeOf(o2) - sizeOf(o1) : r;\r\n             }\r\n         });\r\n+        Phi first = phis.get(0);\r\n+        int size = sizeOf(first);\r\n+        for (Phi p : first) {\r\n+            size += sizeOf(p);\r\n+        }\r\n+\r\n+        BitSet toColor = new BitSet(phis.size());\r\n+        for (int i = 0; i < phis.size(); i++) {\r\n+            Phi p = phis.get(i);\r\n+            if (maps[p.local._ls_index] < 0) {\r\n+                toColor.set(i);\r\n+            }\r\n+        }\r\n+\r\n+        while (!doColor(0, toColor, phis, size, maps)) {\r\n+            size += 1;\r\n+        }\r\n+    }\r\n+\r\n+    boolean doColor(int idx, BitSet toColor, List<Phi> phis, int size, int[] maps) {\r\n+        int x = toColor.nextSetBit(idx);\r\n+        if (x < 0) {\r\n+            return true;\r\n+        }\r\n+        Phi phi = phis.get(x);\r\n+        for (int i = findNextColor(phi, 0, size, maps); i >= 0; i = findNextColor(phi, i + 1, size, maps)) {\r\n+            maps[phi.local._ls_index] = i;\r\n+            if (doColor(x + 1, toColor, phis, size, maps)) {\r\n+                return true;\r\n+            }\r\n+            maps[phi.local._ls_index] = -1;\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    static int sizeOf(Phi p) {\r\n+        return LocalType.typeOf(p.local).getSize();\r\n+    }\r\n+\r\n+    private void createGraph(IrMethod ir, int localSize) {\r\n+\r\n+        List<Phi> tmp = new ArrayList<Phi>(localSize);\r\n+        for (Stmt p = ir.stmts.getFirst(); p != null; p = p.getNext()) {\r\n+            tmp.clear();\r\n+            {\r\n+                Phi[] frame = (Phi[]) p._ls_forward_frame;\r\n+                p._ls_forward_frame = null;\r\n+                if (frame != null) {\r\n+                    for (int i = 0; i < frame.length; i++) {\r\n+                        Phi r = frame[i];\r\n+                        if (r != null) {\r\n+                            if (r.used) {\r\n+                                tmp.add(trim(r));\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                }\r\n+            }\r\n+            for (int i = 0; i < tmp.size() - 1; i++) {\r\n+                Phi a = tmp.get(i);\r\n+                for (int j = i + 1; j < tmp.size(); j++) {\r\n+                    Phi b = tmp.get(j);\r\n+                    if (a != b) {\r\n+                        a.add(b);\r\n+                        b.add(a);\r\n+                    }\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    static void doAddUsed(Phi r, Set<Phi> regs) {\r\n+        if (r.used) {\r\n+            if (!regs.contains(r)) {\r\n+                regs.add(r);\r\n+                for (Phi p : r) {\r\n+                    p.used = true;\r\n+                    doAddUsed(p, regs);\r\n+                }\r\n+            }\r\n+        }\r\n     }\r\n \r\n     public void convert(IrMethod ir, MethodVisitor asm) {\r\n@@ -147,8 +449,9 @@ private void reBuildInstructions(IrMethod ir, MethodVisitor asm) {\n                             } else {\r\n                                 asm.visitVarInsn(LocalType.typeOf(v1).getOpcode(ISTORE), i);\r\n                             }\r\n+                        } else if (!LocalType.typeOf(v1).equals(Type.VOID_TYPE)) {\r\n+                            asm.visitInsn(LocalType.typeOf(v1).getSize() == 2 ? POP2 : POP);\r\n                         }\r\n-\r\n                     }\r\n                     break;\r\n                 case FIELD:\r\n@@ -183,7 +486,12 @@ private void reBuildInstructions(IrMethod ir, MethodVisitor asm) {\n             case IDENTITY: {\r\n                 E2Stmt e2 = (E2Stmt) st;\r\n                 if (e2.op2.value.vt == VT.EXCEPTION_REF) {\r\n-                    asm.visitVarInsn(ASTORE, ((Local) e2.op1.value)._ls_index);\r\n+                    int index = ((Local) e2.op1.value)._ls_index;\r\n+                    if (index >= 0) {\r\n+                        asm.visitVarInsn(ASTORE, index);\r\n+                    } else {\r\n+                        asm.visitInsn(POP);\r\n+                    }\r\n                 }\r\n             }\r\n                 break;\r",
      "parent_sha": "a11d516eec5ad9ca3131ce91fa2917d7f700fa84"
    }
  },
  {
    "oid": "fb9361a578e0c5064436d15efe1297a3dd31d971",
    "message": "Fix IllegalFormatConversionException\n\nThis commit fixes a `java.util.IllegalFormatConversionException`,\nwhich would occur when decompiling certain APKs:\n\n```\ncom.googlecode.d2j.DexException: Error process class: [731]Landroid/support/e/a;\n  at com.googlecode.d2j.reader.DexFileReader.accept(DexFileReader.java:604)\n  at com.googlecode.d2j.reader.DexFileReader.accept(DexFileReader.java:565)\n  at com.googlecode.d2j.smali.Baksmali.to(Baksmali.java:99)\n  at com.googlecode.d2j.smali.BaksmaliCmd.doCommandLine(BaksmaliCmd.java:60)\n  at com.googlecode.dex2jar.tools.BaseCmd.doMain(BaseCmd.java:288)\n  at com.googlecode.d2j.smali.BaksmaliCmd.main(BaksmaliCmd.java:24)\nCaused by: java.util.IllegalFormatConversionException: d != java.lang.String\n  at java.base/java.util.Formatter$FormatSpecifier.failConversion(Formatter.java:4421)\n  at java.base/java.util.Formatter$FormatSpecifier.printInteger(Formatter.java:2936)\n  at java.base/java.util.Formatter$FormatSpecifier.print(Formatter.java:2890)\n  at java.base/java.util.Formatter.format(Formatter.java:2671)\n  at java.base/java.util.Formatter.format(Formatter.java:2607)\n  at java.base/java.lang.String.format(String.java:2734)\n  at com.googlecode.d2j.smali.BaksmaliDumpOut.s(BaksmaliDumpOut.java:62)\n  at com.googlecode.d2j.smali.BaksmaliCodeDumper.visitFilledNewArrayStmt(BaksmaliCodeDumper.java:252)\n  at com.googlecode.d2j.node.DexCodeNode$FilledNewArrayStmtNode.accept(DexCodeNode.java:300)\n  at com.googlecode.d2j.node.DexCodeNode.accept(DexCodeNode.java:62)\n  at com.googlecode.d2j.smali.BaksmaliDumper.baksmaliCode(BaksmaliDumper.java:517)\n  at com.googlecode.d2j.smali.BaksmaliDumper.baksmaliMethod(BaksmaliDumper.java:445)\n  at com.googlecode.d2j.smali.BaksmaliDumper.baksmaliClass(BaksmaliDumper.java:397)\n  at com.googlecode.d2j.smali.BaksmaliDexFileVisitor$1.visitEnd(BaksmaliDexFileVisitor.java:60)\n  at com.googlecode.d2j.reader.DexFileReader.accept(DexFileReader.java:601)\n  ... 5 more\n```",
    "date": "2018-09-22T13:04:07Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/fb9361a578e0c5064436d15efe1297a3dd31d971",
    "details": {
      "sha": "0bb5f9ce76107cdc1ec8a1a8da98b87ec2ac2794",
      "filename": "d2j-smali/src/main/java/com/googlecode/d2j/smali/BaksmaliCodeDumper.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/fb9361a578e0c5064436d15efe1297a3dd31d971/d2j-smali%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fsmali%2FBaksmaliCodeDumper.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/fb9361a578e0c5064436d15efe1297a3dd31d971/d2j-smali%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fsmali%2FBaksmaliCodeDumper.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/d2j-smali%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fsmali%2FBaksmaliCodeDumper.java?ref=fb9361a578e0c5064436d15efe1297a3dd31d971",
      "patch": "@@ -245,7 +245,7 @@ public void visitFieldStmt(Op op, int a, int b, Field field) {\n     public void visitFilledNewArrayStmt(Op op, int[] args, String type) {\r\n         if (args.length > 0) {\r\n             if (op.format == InstructionFormat.kFmt3rc) { // invoke-x/range\r\n-                out.s(\"%s { %d .. %d }, %s\", op.displayName, reg(args[0]), reg(args[args.length - 1]),\r\n+                out.s(\"%s { %s .. %s }, %s\", op.displayName, reg(args[0]), reg(args[args.length - 1]),\r\n                         BaksmaliDumper.escapeType(type));\r\n             } else {\r\n                 StringBuilder buff = new StringBuilder();\r",
      "parent_sha": "9cfc8ba805a98b4585bab1831b47b29969aa85e4"
    }
  },
  {
    "oid": "9be99ac0be1c216892402268f525752b5d75cef5",
    "message": "sort smali file by name\n\n--HG--\nbranch : 2.x",
    "date": "2015-01-05T14:23:42Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/9be99ac0be1c216892402268f525752b5d75cef5",
    "details": {
      "sha": "3e5c2bbeb23f2ea057bd51a28b3406368eed110f",
      "filename": "dex-translator/src/test/java/com/googlecode/dex2jar/test/Smali2jTest.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/9be99ac0be1c216892402268f525752b5d75cef5/dex-translator%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftest%2FSmali2jTest.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/9be99ac0be1c216892402268f525752b5d75cef5/dex-translator%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftest%2FSmali2jTest.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Ftest%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftest%2FSmali2jTest.java?ref=9be99ac0be1c216892402268f525752b5d75cef5",
      "patch": "@@ -25,6 +25,8 @@\n import java.nio.file.attribute.BasicFileAttributes;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n \n import org.junit.Assert;\n import org.junit.runner.Description;\n@@ -66,7 +68,7 @@ public void init(final Class<?> testClass) throws InitializationError {\n \n             System.out.println(\"dirx is \" + dirx);\n             final Path basePath = new File(dirx, \"smalis\").toPath();\n-            final List<Path> files = new ArrayList<>();\n+            final Set<Path> files = new TreeSet<>();\n             try {\n                 Files.walkFileTree(basePath, new SimpleFileVisitor<Path>() {\n                     @Override",
      "parent_sha": "e49954870ec2c5a4d7a3cf9311e18a18cc66cd00"
    }
  },
  {
    "oid": "373446a00e5f032833ec9af413641a3efdca5c5e",
    "message": "change to super OnUseCallBack",
    "date": "2018-04-02T02:36:37Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/373446a00e5f032833ec9af413641a3efdca5c5e",
    "details": {
      "sha": "6038f11e5c17923ff804d16d7da701d86d11b474",
      "filename": "dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/Cfg.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/373446a00e5f032833ec9af413641a3efdca5c5e/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FCfg.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/373446a00e5f032833ec9af413641a3efdca5c5e/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FCfg.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FCfg.java?ref=373446a00e5f032833ec9af413641a3efdca5c5e",
      "patch": "@@ -300,7 +300,7 @@ public interface TravelCallBack extends OnUseCallBack, OnAssignCallBack {\n \n     }\n \n-    public static Value travelMod(Value value, TravelCallBack callback) {\n+    public static Value travelMod(Value value, OnUseCallBack callback) {\n         switch (value.et) {\n         case E0:\n             if (value.vt == VT.LOCAL) {",
      "parent_sha": "31924706891ffe25491c976c1dc08178ee155e1a"
    }
  },
  {
    "oid": "5e4c90f7150ffe16d98940448efd2bdb4a83245b",
    "message": "Add workaround for invalid signatures\n\ncherry-pick from\n\nhttps://github.com/ThexXTURBOXx/dex2jar/commit/f1da047322d91427fd176367faa0c45472aa745f",
    "date": "2021-10-30T17:55:07Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/5e4c90f7150ffe16d98940448efd2bdb4a83245b",
    "details": {
      "sha": "9c98f70b444576bd41403892b96ed8f96ee9e077",
      "filename": "dex-translator/src/main/java/com/googlecode/d2j/dex/Dex2Asm.java",
      "status": "modified",
      "additions": 25,
      "deletions": 4,
      "changes": 29,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/5e4c90f7150ffe16d98940448efd2bdb4a83245b/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FDex2Asm.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/5e4c90f7150ffe16d98940448efd2bdb4a83245b/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FDex2Asm.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FDex2Asm.java?ref=5e4c90f7150ffe16d98940448efd2bdb4a83245b",
      "patch": "@@ -275,7 +275,16 @@ private static MethodVisitor collectBasicMethodInfo(DexMethodNode methodNode, Cl\n         // clear ACC_DECLARED_SYNCHRONIZED and ACC_CONSTRUCTOR from method flags\n         final int cleanFlag = ~((DexConstants.ACC_DECLARED_SYNCHRONIZED | DexConstants.ACC_CONSTRUCTOR));\n         access &= cleanFlag;\n-        return cv.visitMethod(access, methodNode.method.getName(), methodNode.method.getDesc(), signature, xthrows);\n+        try {\n+            return cv.visitMethod(access, methodNode.method.getName(), methodNode.method.getDesc(), signature, xthrows);\n+        } catch (StringIndexOutOfBoundsException | IllegalArgumentException e) {\n+            System.err.println(\"Applying workaround to method \"\n+                    + methodNode.method.getOwner() + \"#\" + methodNode.method.getName()\n+                    + \" with original signature \" + signature\n+                    + \" by changing its types to java.lang.Object.\");\n+            return cv.visitMethod(access, methodNode.method.getName(), methodNode.method.getDesc(),\n+                    \"(Ljava/lang/Object;)Ljava/lang/Object;\", xthrows);\n+        }\n     }\n \n     protected static Map<String, Clz> collectClzInfo(DexFileNode fileNode) {\n@@ -523,9 +532,21 @@ public void convertField(DexClassNode classNode, DexFieldNode fieldNode, ClassVi\n             }\n         }\n         Object value = convertConstantValue(fieldNode.cst);\n-        final int FieldCleanFlag = ~DexConstants.ACC_DECLARED_SYNCHRONIZED;\n-        FieldVisitor fv = cv.visitField(fieldNode.access & FieldCleanFlag, fieldNode.field.getName(),\n-                fieldNode.field.getType(), signature, value);\n+\n+        final int fieldCleanFlag = ~((DexConstants.ACC_DECLARED_SYNCHRONIZED | Opcodes.ACC_SYNTHETIC));\n+        FieldVisitor fv;\n+        try {\n+            fv = cv.visitField(fieldNode.access & fieldCleanFlag, fieldNode.field.getName(),\n+                    fieldNode.field.getType(), signature, value);\n+        } catch (StringIndexOutOfBoundsException | IllegalArgumentException e) {\n+            System.err.println(\"Applying workaround to field \"\n+                    + classNode.className + \"#\" + fieldNode.field.getName()\n+                    + \" with original signature \" + signature\n+                    + \" by changing its type to java.lang.Object.\");\n+            fv = cv.visitField(fieldNode.access & fieldCleanFlag, fieldNode.field.getName(),\n+                    fieldNode.field.getType(), \"Ljava/lang/Object;\", value);\n+        }\n+\n         if (fv == null) {\n             return;\n         }",
      "parent_sha": "c577db0da377e2620152d9a944dea7b3c64da5e3"
    }
  },
  {
    "oid": "1d663bba9a53bb25e6122297035a1e1c043c3377",
    "message": "improve FILL_ARRAY_DATA\n\n--HG--\nbranch : 2.x",
    "date": "2015-05-29T03:54:56Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/1d663bba9a53bb25e6122297035a1e1c043c3377",
    "details": {
      "sha": "2933b0f7a108524b3e36edd17e4c8617a7151cb0",
      "filename": "dex-translator/src/main/java/com/googlecode/d2j/converter/IR2JConverter.java",
      "status": "modified",
      "additions": 47,
      "deletions": 65,
      "changes": 112,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/1d663bba9a53bb25e6122297035a1e1c043c3377/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fconverter%2FIR2JConverter.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/1d663bba9a53bb25e6122297035a1e1c043c3377/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fconverter%2FIR2JConverter.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fconverter%2FIR2JConverter.java?ref=1d663bba9a53bb25e6122297035a1e1c043c3377",
      "patch": "@@ -16,40 +16,25 @@\n  */\r\n package com.googlecode.d2j.converter;\r\n \r\n-import java.lang.reflect.Array;\r\n-import java.util.HashMap;\r\n-import java.util.Map;\r\n-\r\n import com.googlecode.d2j.asm.LdcOptimizeAdapter;\r\n-import com.googlecode.dex2jar.ir.stmt.*;\r\n-import org.objectweb.asm.Label;\r\n-import org.objectweb.asm.MethodVisitor;\r\n-import org.objectweb.asm.Opcodes;\r\n-import org.objectweb.asm.Type;\r\n-\r\n import com.googlecode.dex2jar.ir.IrMethod;\r\n import com.googlecode.dex2jar.ir.Trap;\r\n-import com.googlecode.dex2jar.ir.expr.ArrayExpr;\r\n-import com.googlecode.dex2jar.ir.expr.CastExpr;\r\n-import com.googlecode.dex2jar.ir.expr.Constant;\r\n-import com.googlecode.dex2jar.ir.expr.Exprs;\r\n-import com.googlecode.dex2jar.ir.expr.FieldExpr;\r\n-import com.googlecode.dex2jar.ir.expr.FilledArrayExpr;\r\n-import com.googlecode.dex2jar.ir.expr.InvokeExpr;\r\n-import com.googlecode.dex2jar.ir.expr.Local;\r\n-import com.googlecode.dex2jar.ir.expr.NewExpr;\r\n-import com.googlecode.dex2jar.ir.expr.NewMutiArrayExpr;\r\n-import com.googlecode.dex2jar.ir.expr.StaticFieldExpr;\r\n-import com.googlecode.dex2jar.ir.expr.TypeExpr;\r\n-import com.googlecode.dex2jar.ir.expr.Value;\r\n+import com.googlecode.dex2jar.ir.expr.*;\r\n import com.googlecode.dex2jar.ir.expr.Value.E1Expr;\r\n import com.googlecode.dex2jar.ir.expr.Value.E2Expr;\r\n import com.googlecode.dex2jar.ir.expr.Value.EnExpr;\r\n import com.googlecode.dex2jar.ir.expr.Value.VT;\r\n+import com.googlecode.dex2jar.ir.stmt.*;\r\n import com.googlecode.dex2jar.ir.stmt.Stmt.E2Stmt;\r\n import com.googlecode.dex2jar.ir.stmt.Stmt.ST;\r\n-import com.googlecode.dex2jar.ir.ts.Cfg;\r\n-import com.googlecode.dex2jar.ir.ts.Cfg.TravelCallBack;\r\n+import org.objectweb.asm.Label;\r\n+import org.objectweb.asm.MethodVisitor;\r\n+import org.objectweb.asm.Opcodes;\r\n+import org.objectweb.asm.Type;\r\n+\r\n+import java.lang.reflect.Array;\r\n+import java.util.HashMap;\r\n+import java.util.Map;\r\n \r\n @SuppressWarnings(\"incomplete-switch\")\r\n public class IR2JConverter implements Opcodes {\r\n@@ -233,24 +218,45 @@ private void reBuildInstructions(IrMethod ir, MethodVisitor asm) {\n \r\n             case FILL_ARRAY_DATA:{\r\n                 E2Stmt e2 = (E2Stmt) st;\r\n-                Object arrayData = ((Constant) e2.getOp2()).value;\r\n-                int arraySize=Array.getLength(arrayData);\r\n-                String arrayValueType = e2.getOp1().valueType;\r\n-                String elementType;\r\n-                if (arrayValueType.charAt(0) == '[') {\r\n-                    elementType = arrayValueType.substring(1);\r\n+                if (e2.getOp2().vt == VT.CONSTANT) {\r\n+                    Object arrayData = ((Constant) e2.getOp2()).value;\r\n+                    int arraySize = Array.getLength(arrayData);\r\n+                    String arrayValueType = e2.getOp1().valueType;\r\n+                    String elementType;\r\n+                    if (arrayValueType.charAt(0) == '[') {\r\n+                        elementType = arrayValueType.substring(1);\r\n+                    } else {\r\n+                        elementType = \"I\";\r\n+                    }\r\n+                    int iastoreOP = getOpcode(elementType, IASTORE);\r\n+                    accept(e2.getOp1(), asm);\r\n+                    for (int i = 0; i < arraySize; i++) {\r\n+                        asm.visitInsn(DUP);\r\n+                        asm.visitLdcInsn(i);\r\n+                        asm.visitLdcInsn(Array.get(arrayData, i));\r\n+                        asm.visitInsn(iastoreOP);\r\n+                    }\r\n+                    asm.visitInsn(POP);\r\n                 } else {\r\n-                    elementType = \"I\";\r\n-                }\r\n-                int iastoreOP = getOpcode(elementType, IASTORE);\r\n-                accept(e2.getOp1(), asm);\r\n-                for (int i = 0; i < arraySize; i++) {\r\n-                    asm.visitInsn(DUP);\r\n-                    asm.visitLdcInsn(i);\r\n-                    asm.visitLdcInsn(Array.get(arrayData, i));\r\n-                    asm.visitInsn(iastoreOP);\r\n+                    FilledArrayExpr filledArrayExpr = (FilledArrayExpr) e2.getOp2();\r\n+                    int arraySize = filledArrayExpr.ops.length;\r\n+                    String arrayValueType = e2.getOp1().valueType;\r\n+                    String elementType;\r\n+                    if (arrayValueType.charAt(0) == '[') {\r\n+                        elementType = arrayValueType.substring(1);\r\n+                    } else {\r\n+                        elementType = \"I\";\r\n+                    }\r\n+                    int iastoreOP = getOpcode(elementType, IASTORE);\r\n+                    accept(e2.getOp1(), asm);\r\n+                    for (int i = 0; i < arraySize; i++) {\r\n+                        asm.visitInsn(DUP);\r\n+                        asm.visitLdcInsn(i);\r\n+                        accept(filledArrayExpr.ops[i], asm);\r\n+                        asm.visitInsn(iastoreOP);\r\n+                    }\r\n+                    asm.visitInsn(POP);\r\n                 }\r\n-                asm.visitInsn(POP);\r\n             }\r\n             break;\r\n             case GOTO:\r\n@@ -387,30 +393,6 @@ private static boolean isLocalWithIndex(Value v, int i) {\n         return v.vt == VT.LOCAL && ((Local) v)._ls_index == i;\r\n     }\r\n \r\n-    private int[] buildLocalUsage(IrMethod ir) {\r\n-        int maxLocal = 0;\r\n-        for (Local local : ir.locals) {\r\n-            if (local._ls_index > maxLocal) {\r\n-                maxLocal = local._ls_index;\r\n-            }\r\n-        }\r\n-        final int[] localUsages = new int[maxLocal + 1]; // maxIndex+1 to get the size\r\n-        Cfg.travel(ir.stmts, new TravelCallBack() {\r\n-\r\n-            @Override\r\n-            public Value onAssign(Local v, AssignStmt as) {\r\n-                return v;\r\n-            }\r\n-\r\n-            @Override\r\n-            public Value onUse(Local v) {\r\n-                localUsages[v._ls_index]++;\r\n-                return v;\r\n-            }\r\n-        }, true);\r\n-        return localUsages;\r\n-    }\r\n-\r\n     /**\r\n      * insert I2x instruction\r\n      * \r",
      "parent_sha": "7e62a5f28692f7abc99f6367eb69da1b99eb4291"
    }
  },
  {
    "oid": "22afcc68ddf89879a475e7782de3b761773519d1",
    "message": "\u6d4b\u8bd5\u4e0d\u901a\u8fc7\u7684\u95ee\u9898",
    "date": "2010-04-02T05:11:51Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/22afcc68ddf89879a475e7782de3b761773519d1",
    "details": {
      "sha": "4caf535156d208532e4c8b65a30ca7c719f58937",
      "filename": "src/test/java/pxb/android/TestUtils.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/22afcc68ddf89879a475e7782de3b761773519d1/src%2Ftest%2Fjava%2Fpxb%2Fandroid%2FTestUtils.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/22afcc68ddf89879a475e7782de3b761773519d1/src%2Ftest%2Fjava%2Fpxb%2Fandroid%2FTestUtils.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/src%2Ftest%2Fjava%2Fpxb%2Fandroid%2FTestUtils.java?ref=22afcc68ddf89879a475e7782de3b761773519d1",
      "patch": "@@ -28,7 +28,7 @@\n  * @author Panxiaobo\r\n  * \r\n  */\r\n-public class TestUtils {\r\n+public abstract class TestUtils {\r\n \r\n \tpublic static File dex(String file) throws Exception {\r\n \r",
      "parent_sha": "500a83c501470e5af9d07e16d8c5a8f2a6b4df9d"
    }
  },
  {
    "oid": "c3795eb9f87e746364383f5e66a36f46da432d6a",
    "message": "ignore method annotation value and null annotation value\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2013-06-17T05:49:39Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/c3795eb9f87e746364383f5e66a36f46da432d6a",
    "details": {
      "sha": "cd69337085bdeaef665be5c0b697bd536848d859",
      "filename": "dex-translator/src/main/java/com/googlecode/dex2jar/v3/AnnotationNode.java",
      "status": "modified",
      "additions": 7,
      "deletions": 2,
      "changes": 9,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/c3795eb9f87e746364383f5e66a36f46da432d6a/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FAnnotationNode.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/c3795eb9f87e746364383f5e66a36f46da432d6a/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FAnnotationNode.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FAnnotationNode.java?ref=c3795eb9f87e746364383f5e66a36f46da432d6a",
      "patch": "@@ -77,11 +77,16 @@ public static void accept(String name, Object v, AnnotationVisitor av) {\n             // av1.visit(\"name\", method.getName());\r\n             // av1.visit(\"desc\", method.getType().getDesc());\r\n             // av1.visitEnd();\r\n-            av.visit(name, v);\r\n+            // av.visit(name, v);\r\n+            System.err.println(\"WARN: ignored method annotation value\");\r\n         } else if (v instanceof DexType) {\r\n             av.visit(name, ((DexType) v).desc);\r\n         } else {\r\n-            av.visit(name, v);\r\n+            if (v == null) {\r\n+                System.err.println(\"WARN: ignored null annotation value\");\r\n+            } else {\r\n+                av.visit(name, v);\r\n+            }\r\n         }\r\n     }\r\n \r",
      "parent_sha": "5e539960face505565b9703dba2ff32360eba113"
    }
  },
  {
    "oid": "ec284bceca484567b327f57ae598c81e7b2974a2",
    "message": "never reuse this(local 0)\n\nconvert [x + (-1)] to [x - 1] and [x - (-1)] to [x + 1]\n\nFixes issue 93\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2011-12-06T11:45:10Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/ec284bceca484567b327f57ae598c81e7b2974a2",
    "details": {
      "sha": "528c3f9a5052134566aac390fc31885d54f99049",
      "filename": "dex-translator/src/main/java/com/googlecode/dex2jar/v3/IrMethod2AsmMethod.java",
      "status": "modified",
      "additions": 67,
      "deletions": 1,
      "changes": 68,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/ec284bceca484567b327f57ae598c81e7b2974a2/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FIrMethod2AsmMethod.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/ec284bceca484567b327f57ae598c81e7b2974a2/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FIrMethod2AsmMethod.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FIrMethod2AsmMethod.java?ref=ec284bceca484567b327f57ae598c81e7b2974a2",
      "patch": "@@ -104,8 +104,26 @@ private void reIndexLocal(IrMethod ir) {\n             }\r\n         }\r\n \r\n+        Phi _this = null;\r\n+        if ((ir.access & ACC_STATIC) == 0) {\r\n+            for (Phi phi : phis) {\r\n+                if (phi.local._ls_index == 0) {\r\n+                    _this = phi;\r\n+                    break;\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n         // 2.2 assign other index\r\n         createGraph(ir, phis.size());\r\n+        if (_this != null) {// never reuse index 0\r\n+            for (Phi phi : phis) {\r\n+                if (phi != _this) {\r\n+                    phi.add(_this);\r\n+                    _this.add(phi);\r\n+                }\r\n+            }\r\n+        }\r\n         gradyColoring(phis, maps);\r\n \r\n         for (Local local : ir.locals) {\r\n@@ -630,9 +648,57 @@ private static void reBuildE1Expression(E1Expr e1, MethodVisitor asm) {\n     }\r\n \r\n     private static void reBuildE2Expression(E2Expr e2, MethodVisitor asm) {\r\n+        Type type = LocalType.typeOf(e2.op2.value);\r\n         accept(e2.op1.value, asm);\r\n+        if ((e2.vt == VT.ADD || e2.vt == VT.SUB) && e2.op2.value.vt == VT.CONSTANT) {\r\n+            // [x + (-1)] to [x - 1]\r\n+            // [x - (-1)] to [x + 1]\r\n+            Constant constant = (Constant) e2.op2.value;\r\n+            Type t = LocalType.typeOf(constant);\r\n+            switch (t.getSort()) {\r\n+            case Type.SHORT:\r\n+            case Type.BYTE:\r\n+            case Type.INT: {\r\n+                int s = (Integer) constant.value;\r\n+                if (s < 0) {\r\n+                    asm.visitLdcInsn((int) -s);\r\n+                    asm.visitInsn(type.getOpcode(e2.vt == VT.ADD ? ISUB : IADD));\r\n+                    return;\r\n+                }\r\n+            }\r\n+                break;\r\n+            case Type.FLOAT: {\r\n+                float s = (Float) constant.value;\r\n+                if (s < 0) {\r\n+                    asm.visitLdcInsn((float) -s);\r\n+                    asm.visitInsn(type.getOpcode(e2.vt == VT.ADD ? ISUB : IADD));\r\n+                    return;\r\n+                }\r\n+            }\r\n+                break;\r\n+            case Type.LONG: {\r\n+                long s = (Long) constant.value;\r\n+                if (s < 0) {\r\n+                    asm.visitLdcInsn((long) -s);\r\n+                    asm.visitInsn(type.getOpcode(e2.vt == VT.ADD ? ISUB : IADD));\r\n+                    return;\r\n+                }\r\n+            }\r\n+                break;\r\n+            case Type.DOUBLE: {\r\n+                double s = (Double) constant.value;\r\n+                if (s < 0) {\r\n+                    asm.visitLdcInsn((double) -s);\r\n+                    asm.visitInsn(type.getOpcode(e2.vt == VT.ADD ? ISUB : IADD));\r\n+                    return;\r\n+                }\r\n+            }\r\n+                break;\r\n+            }\r\n+        }\r\n+\r\n         accept(e2.op2.value, asm);\r\n-        Type type = LocalType.typeOf(e2.op2.value);\r\n+\r\n         Type tp1 = LocalType.typeOf(e2.op1.value);\r\n         switch (e2.vt) {\r\n         case ARRAY:\r",
      "parent_sha": "8d1727d5efa463b594b3bff66def3a8b8cff3aae"
    }
  },
  {
    "oid": "6f04e7714f26df0cdc17689dbe60949b813d21bb",
    "message": "fix write array of in annotation\n\n--HG--\nbranch : 2.x",
    "date": "2014-08-06T15:00:28Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/6f04e7714f26df0cdc17689dbe60949b813d21bb",
    "details": {
      "sha": "1d4f10056211b14573624e6f9bd1d3cb82b005fa",
      "filename": "dex-writer/src/main/java/com/googlecode/d2j/dex/writer/AnnotationWriter.java",
      "status": "modified",
      "additions": 12,
      "deletions": 2,
      "changes": 14,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/6f04e7714f26df0cdc17689dbe60949b813d21bb/dex-writer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2Fwriter%2FAnnotationWriter.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/6f04e7714f26df0cdc17689dbe60949b813d21bb/dex-writer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2Fwriter%2FAnnotationWriter.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-writer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2Fwriter%2FAnnotationWriter.java?ref=6f04e7714f26df0cdc17689dbe60949b813d21bb",
      "patch": "@@ -44,8 +44,18 @@ AnnotationElement newAnnotationElement(String name) {\n \n     // int,int long\n     public void visit(String name, Object value) {\n-        AnnotationElement ae = newAnnotationElement(name);\n-        ae.value = EncodedValue.wrap(cp.wrapEncodedItem(value));\n+        if (value instanceof Object[]) {\n+            DexAnnotationVisitor s = visitArray(name);\n+            if (s != null) {\n+                for (Object v : (Object[]) value) {\n+                    s.visit(null, v);\n+                }\n+                s.visitEnd();\n+            }\n+        } else {\n+            AnnotationElement ae = newAnnotationElement(name);\n+            ae.value = EncodedValue.wrap(cp.wrapEncodedItem(value));\n+        }\n     }\n \n     @Override",
      "parent_sha": "ca7e8f224cfe2896c6067b80c9e04b67ac63eeba"
    }
  },
  {
    "oid": "94e9fa04e27ea26992d67ddfa40991f97ed8424a",
    "message": "fix throw new Runtime(...) when error\n\n--HG--\nbranch : 2.x",
    "date": "2015-04-29T02:48:38Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/94e9fa04e27ea26992d67ddfa40991f97ed8424a",
    "details": {
      "sha": "195423dfd6b07528f282682b354e83ce962d1cd2",
      "filename": "dex-translator/src/main/java/com/googlecode/d2j/dex/BaseDexExceptionHandler.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/94e9fa04e27ea26992d67ddfa40991f97ed8424a/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FBaseDexExceptionHandler.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/94e9fa04e27ea26992d67ddfa40991f97ed8424a/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FBaseDexExceptionHandler.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2FBaseDexExceptionHandler.java?ref=94e9fa04e27ea26992d67ddfa40991f97ed8424a",
      "patch": "@@ -41,7 +41,7 @@ public void handleMethodTranslateException(Method method, DexMethodNode methodNo\n         mv.visitTypeInsn(Opcodes.NEW, \"java/lang/RuntimeException\");\n         mv.visitInsn(Opcodes.DUP);\n         mv.visitLdcInsn(msg);\n-        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"java/lang/Runtime\", \"<init>\", \"(Ljava/lang/String;)V\");\n+        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"java/lang/RuntimeException\", \"<init>\", \"(Ljava/lang/String;)V\");\n         mv.visitInsn(Opcodes.ATHROW);\n     }\n }",
      "parent_sha": "1fe0c23a1ed3729e90738aa837cb2052e0e2f37f"
    }
  },
  {
    "oid": "482af4a26fd53b0123fd4d89277d31a89c6061d5",
    "message": "typo similar with ffa0574dff776404d4fa4368057c72f610521a5c (#596)",
    "date": "2023-08-31T12:42:39Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/482af4a26fd53b0123fd4d89277d31a89c6061d5",
    "details": {
      "sha": "f23c365921ee609b10c53f82d9607ab20ad4830b",
      "filename": "dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/TypeTransformer.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/482af4a26fd53b0123fd4d89277d31a89c6061d5/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FTypeTransformer.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/482af4a26fd53b0123fd4d89277d31a89c6061d5/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FTypeTransformer.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FTypeTransformer.java?ref=482af4a26fd53b0123fd4d89277d31a89c6061d5",
      "patch": "@@ -478,7 +478,7 @@ private static String mergeTypeEx(String a, String b) {\n                 return b;\n             } else { // as==bs;\n                 String elementTypeA = a.substring(as);\n-                String elementTypeB = a.substring(bs);\n+                String elementTypeB = b.substring(bs);\n                 TypeClass ta = TypeClass.clzOf(elementTypeA);\n                 TypeClass tb = TypeClass.clzOf(elementTypeB);\n                 if (ta.fixed && !tb.fixed) {",
      "parent_sha": "2dd92907c5c109dbf9dc4fda9b9f4d7e57961435"
    }
  },
  {
    "oid": "770a3fcfd19784b034343d3f5de05f4b2f9dad76",
    "message": "Update issue 130\nStatus: Fixed\nif-eq vx, vx, offset\nwe add a trick to skip the if-eq, and direct read from offset\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2012-09-11T13:08:15Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/770a3fcfd19784b034343d3f5de05f4b2f9dad76",
    "details": {
      "sha": "2caa1ef49deaf1f610a817b76a33de299c41fad1",
      "filename": "dex-reader/src/main/java/com/googlecode/dex2jar/reader/DexCodeReader.java",
      "status": "modified",
      "additions": 46,
      "deletions": 3,
      "changes": 49,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/770a3fcfd19784b034343d3f5de05f4b2f9dad76/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexCodeReader.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/770a3fcfd19784b034343d3f5de05f4b2f9dad76/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexCodeReader.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexCodeReader.java?ref=770a3fcfd19784b034343d3f5de05f4b2f9dad76",
      "patch": "@@ -72,7 +72,9 @@\n     }\r\n \r\n     private void findLabels(DataIn in, int instruction_size) {\r\n-        for (int baseOffset = in.getCurrentPosition(), currentOffset = 0; currentOffset < instruction_size; currentOffset = (in\r\n+        int baseOffset = in.getCurrentPosition();\r\n+        fixIssue130(in, instruction_size);\r\n+        for (int currentOffset = (in.getCurrentPosition() - baseOffset) / 2; currentOffset < instruction_size; currentOffset = (in\r\n                 .getCurrentPosition() - baseOffset) / 2) {\r\n             int opcode = in.readUShortx();\r\n             int uOpcodeH = opcode >> 8;\r\n@@ -82,6 +84,7 @@ private void findLabels(DataIn in, int instruction_size) {\n                     opcode = uOpcodeL;\r\n                 }\r\n             }\r\n+\r\n             OpcodeFormat format = OpcodeFormat.get(opcode, dex.apiLevel);\r\n             try {\r\n                 switch (opcode) {\r\n@@ -180,6 +183,41 @@ private void findLabels(DataIn in, int instruction_size) {\n         }\r\n     }\r\n \r\n+    /**\r\n+     * This is a trick to fix issue 130 http://code.google.com/p/dex2jar/issues/detail?id=130\r\n+     * \r\n+     * <pre>\r\n+     * 036280: 3200 0900                              |0000: if-eq v0, v0, 0009 // +0009\r\n+     * 036284: 2600 0300 0000                         |0002: fill-array-data v0, 00000005 // +00000003\r\n+     * 03628a: 0003 0100 0800 0000 7010 ce0b 0000 ... |0005: array-data (8 units)\r\n+     * </pre>\r\n+     * \r\n+     * skip the if-eq, and direct read from 0009\r\n+     * \r\n+     * @param in\r\n+     * @param instruction_size\r\n+     */\r\n+    private void fixIssue130(DataIn in, int instruction_size) {\r\n+        if (instruction_size < 4) {\r\n+            return;\r\n+        }\r\n+        int base = in.getCurrentPosition();\r\n+        int opcode = in.readUShortx();\r\n+        int uOpcodeH = opcode >> 8;\r\n+        {\r\n+            int uOpcodeL = opcode & 0xFF;\r\n+            if (uOpcodeL != 0xFF) {\r\n+                opcode = uOpcodeL;\r\n+            }\r\n+        }\r\n+        if ((opcode == OP_IF_EQ) && ((uOpcodeH & 0xF) == (uOpcodeH >> 4))) {\r\n+            int offset = in.readShortx();\r\n+            in.skip(offset * 2 - 4);\r\n+        } else {\r\n+            in.move(base);\r\n+        }\r\n+    }\r\n+\r\n     private void findTryCatch(DataIn in, DexCodeVisitor dcv, int tries_size) {\r\n         int encoded_catch_handler_list = in.getCurrentPosition() + tries_size * 8;\r\n         for (int i = 0; i < tries_size; i++) {\r\n@@ -293,12 +331,16 @@ public void accept(DexCodeVisitor dcv, int config) {\n         dcv.visitEnd();\r\n     }\r\n \r\n+    // \u5904\u7406\u6307\u4ee4\r\n     private void acceptInsn(DataIn in, int instruction_size, DexOpcodeAdapter n) {\r\n-        // \u5904\u7406\u6307\u4ee4\r\n+\r\n         Iterator<Integer> labelOffsetIterator = this.labels.keySet().iterator();\r\n         Integer nextLabelOffset = labelOffsetIterator.hasNext() ? labelOffsetIterator.next() : null;\r\n-        for (int baseOffset = in.getCurrentPosition(), currentOffset = 0; currentOffset < instruction_size; currentOffset = (in\r\n+        int baseOffset = in.getCurrentPosition();\r\n+        fixIssue130(in, instruction_size);\r\n+        for (int currentOffset = (in.getCurrentPosition() - baseOffset) / 2; currentOffset < instruction_size; currentOffset = (in\r\n                 .getCurrentPosition() - baseOffset) / 2) {\r\n+\r\n             boolean currentOffsetVisited = false;\r\n             while (nextLabelOffset != null) {// issue 65, a label may `inside` an instruction\r\n                 int _intNextLabelOffset = nextLabelOffset;// autobox\r\n@@ -325,6 +367,7 @@ private void acceptInsn(DataIn in, int instruction_size, DexOpcodeAdapter n) {\n                     opcode = uOpcodeL;\r\n                 }\r\n             }\r\n+\r\n             OpcodeFormat format = OpcodeFormat.get(opcode, dex.apiLevel);\r\n \r\n             switch (format) {\r",
      "parent_sha": "48dd9ac560759f4c89760ece0ad0859c1d934553"
    }
  },
  {
    "oid": "d1f14f8d6881730501805cdb1f97db451a49f317",
    "message": "remove NEW if possible\n\n--HG--\nbranch : 2.x",
    "date": "2014-08-06T17:20:56Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/d1f14f8d6881730501805cdb1f97db451a49f317",
    "details": {
      "sha": "1dd4a5bd33939fdf46c72add19f2c15fac11c777",
      "filename": "dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/NewTransformer.java",
      "status": "modified",
      "additions": 78,
      "deletions": 27,
      "changes": 105,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/d1f14f8d6881730501805cdb1f97db451a49f317/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FNewTransformer.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/d1f14f8d6881730501805cdb1f97db451a49f317/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FNewTransformer.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FNewTransformer.java?ref=d1f14f8d6881730501805cdb1f97db451a49f317",
      "patch": "@@ -17,6 +17,7 @@\n package com.googlecode.dex2jar.ir.ts;\r\n \r\n import com.googlecode.dex2jar.ir.IrMethod;\r\n+import com.googlecode.dex2jar.ir.StmtTraveler;\r\n import com.googlecode.dex2jar.ir.expr.*;\r\n import com.googlecode.dex2jar.ir.stmt.AssignStmt;\r\n import com.googlecode.dex2jar.ir.stmt.Stmt;\r\n@@ -46,8 +47,8 @@\n public class NewTransformer implements Transformer {\r\n     @Override\r\n     public void transform(IrMethod method) {\r\n-        Map<Local, NewExpr> nAssign = new HashMap<>();\r\n-        Map<Local, AssignStmt> init = new HashMap<>();\r\n+        final Map<Local, NewExpr> nAssign = new HashMap<>();\r\n+        final Map<Local, AssignStmt> init = new HashMap<>();\r\n         for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext();) {\r\n             Stmt p = it.next();\r\n             if (p.st == ASSIGN && p.getOp1().vt == LOCAL && p.getOp2().vt == NEW) {\r\n@@ -57,6 +58,56 @@ public void transform(IrMethod method) {\n                 init.put(local, (AssignStmt) p);\r\n             }\r\n         }\r\n+        if (nAssign.size() == 0) {\r\n+            return;\r\n+        }\r\n+        int[] reads = Cfg.countLocalReads(method);\r\n+        final Set<Local> oneOrLess = new HashSet<>();\r\n+        final boolean changed[] = { true };\r\n+        while (changed[0]) {\r\n+            changed[0] = false;\r\n+            for (Local local : nAssign.keySet()) {\r\n+                if (reads[local._ls_index] < 2) {\r\n+                    oneOrLess.add(local);\r\n+                    method.stmts.remove(init.remove(local));\r\n+                    method.locals.remove(local);\r\n+                }\r\n+            }\r\n+\r\n+            if (oneOrLess.size() > 0) {\r\n+                new StmtTraveler() {\r\n+                    @Override\r\n+                    public Stmt travel(Stmt stmt) {\r\n+                        Stmt p = super.travel(stmt);\r\n+                        if (p.st == ASSIGN && p.getOp1().vt == LOCAL && p.getOp2().vt == NEW) {\r\n+                            // the stmt is a new assign stmt\r\n+                            Local local = (Local) p.getOp1();\r\n+                            if (!nAssign.containsKey(local)) {\r\n+                                nAssign.put(local, (NewExpr) p.getOp2());\r\n+                                init.put(local, (AssignStmt) p);\r\n+                                changed[0] = true;\r\n+                            }\r\n+                        }\r\n+                        return p;\r\n+                    }\r\n+\r\n+                    @Override\r\n+                    public Value travel(Value op) {\r\n+                        if (op.vt == LOCAL) {\r\n+                            Local local = (Local) op;\r\n+                            if (oneOrLess.contains(local)) {\r\n+                                return nAssign.get(local);\r\n+                            }\r\n+                        }\r\n+                        return super.travel(op);\r\n+                    }\r\n+                }.travel(method.stmts);\r\n+                for (Local local : oneOrLess) {\r\n+                    nAssign.remove(local);\r\n+                }\r\n+                oneOrLess.clear();\r\n+            }\r\n+        }\r\n \r\n         Set<Local> replaced = new HashSet<>();\r\n         for (Iterator<Stmt> it = method.stmts.iterator(); it.hasNext();) {\r\n@@ -74,39 +125,39 @@ public void transform(IrMethod method) {\n \r\n             if (ie != null) {\r\n                 if (\"<init>\".equals(ie.name) && \"V\".equals(ie.ret)) {\r\n-                    Local objToInit = (Local) ie.getOps()[0];\r\n-                    NewExpr newExpr = nAssign.get(objToInit);\r\n-                    if (newExpr != null) {\r\n-                        if (!ie.owner.equals(newExpr.type)) {\r\n-                            throw new RuntimeException(\"\");\r\n+                    Value[] orgOps = ie.getOps();\r\n+                    if (orgOps[0].vt == LOCAL) {\r\n+                        Local objToInit = (Local) ie.getOps()[0];\r\n+                        NewExpr newExpr = nAssign.get(objToInit);\r\n+                        if (newExpr != null) {\r\n+                            if (!ie.owner.equals(newExpr.type)) {\r\n+                                throw new RuntimeException(\"\");\r\n+                            }\r\n+\r\n+                            Value[] nOps = new Value[orgOps.length - 1];\r\n+                            System.arraycopy(orgOps, 1, nOps, 0, nOps.length);\r\n+                            InvokeExpr invokeNew = Exprs.nInvokeNew(nOps, ie.args, ie.owner);\r\n+                            method.stmts.insertBefore(p, Stmts.nAssign(objToInit, invokeNew));\r\n+                            it.remove();\r\n+                            replaced.add(objToInit);\r\n+                        }\r\n+                    } else if (orgOps[0].vt == NEW) {\r\n+                        NewExpr newExpr = (NewExpr) ie.getOps()[0];\r\n+                        if (newExpr != null) {\r\n+                            Value[] nOps = new Value[orgOps.length - 1];\r\n+                            System.arraycopy(orgOps, 1, nOps, 0, nOps.length);\r\n+                            InvokeExpr invokeNew = Exprs.nInvokeNew(nOps, ie.args, ie.owner);\r\n+                            method.stmts.insertBefore(p, Stmts.nVoidInvoke(invokeNew));\r\n+                            it.remove();\r\n                         }\r\n-                        Value[] orgOps = ie.getOps();\r\n-                        Value[] nOps = new Value[orgOps.length - 1];\r\n-                        System.arraycopy(orgOps, 1, nOps, 0, nOps.length);\r\n-                        InvokeExpr invokeNew = Exprs.nInvokeNew(nOps, ie.args, ie.owner);\r\n-                        method.stmts.insertBefore(p, Stmts.nAssign(objToInit, invokeNew));\r\n-                        it.remove();\r\n-                        replaced.add(objToInit);\r\n-                    } else {\r\n-                        // a invoke super in constructor\r\n                     }\r\n+\r\n                 }\r\n             }\r\n         }\r\n         nAssign.clear();\r\n         for (Local x : replaced) {\r\n             method.stmts.remove(init.remove(x));\r\n         }\r\n-        if (init.size() > 0) {\r\n-            int[] reads = Cfg.countLocalReads(method);\r\n-            for (Map.Entry<Local, AssignStmt> e : init.entrySet()) {\r\n-                Local local = e.getKey();\r\n-                AssignStmt as = e.getValue();\r\n-                if (reads[local._ls_index] == 0) {\r\n-                    method.stmts.remove(as);\r\n-                    method.locals.remove(local);\r\n-                }\r\n-            }\r\n-        }\r\n     }\r\n }\r",
      "parent_sha": "6f04e7714f26df0cdc17689dbe60949b813d21bb"
    }
  },
  {
    "oid": "07630cff13d2144851ce718db63a9c54dac42f64",
    "message": "support longOpt as key\n\n--HG--\nbranch : 2.x",
    "date": "2014-09-18T13:47:34Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/07630cff13d2144851ce718db63a9c54dac42f64",
    "details": {
      "sha": "cd25f7610660a3b2ffcb21e42455d1984511eafd",
      "filename": "d2j-base-cmd/src/main/java/com/googlecode/dex2jar/tools/BaseCmd.java",
      "status": "modified",
      "additions": 57,
      "deletions": 15,
      "changes": 72,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/07630cff13d2144851ce718db63a9c54dac42f64/d2j-base-cmd%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FBaseCmd.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/07630cff13d2144851ce718db63a9c54dac42f64/d2j-base-cmd%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FBaseCmd.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/d2j-base-cmd%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FBaseCmd.java?ref=07630cff13d2144851ce718db63a9c54dac42f64",
      "patch": "@@ -36,6 +36,7 @@ public static String getBaseName(String fn) {\n         int x = fn.lastIndexOf('.');\n         return x >= 0 ? fn.substring(0, x) : fn;\n     }\n+\n     public static String getBaseName(Path fn) {\n         return getBaseName(fn.getFileName().toString());\n     }\n@@ -116,13 +117,13 @@ public HelpException(String message) {\n     static public @interface Opt {\n         String argName() default \"\";\n \n-        String description();\n+        String description() default \"\";\n \n         boolean hasArg() default true;\n \n         String longOpt() default \"\";\n \n-        String opt();\n+        String opt() default \"\";\n \n         boolean required() default false;\n     }\n@@ -138,14 +139,41 @@ static protected class Option implements Comparable<Option> {\n \n         @Override\n         public int compareTo(Option o) {\n-            return this.opt.compareTo(o.opt);\n+            int result = s(this.opt, o.opt);\n+            if (result == 0) {\n+                result = s(this.longOpt, o.longOpt);\n+                if (result == 0) {\n+                    result = s(this.argName, o.argName);\n+                    if (result == 0) {\n+                        result = s(this.description, o.description);\n+                    }\n+                }\n+            }\n+            return result;\n+        }\n+\n+        private static int s(String a, String b) {\n+            if (a != null && b != null) {\n+                return a.compareTo(b);\n+            } else if (a != null) {\n+                return 1;\n+            } else if (b != null) {\n+                return -1;\n+            } else {\n+                return 0;\n+            }\n         }\n \n         public String getOptAndLongOpt() {\n             StringBuilder sb = new StringBuilder();\n+            if (opt != null) {\n             sb.append(\"-\").append(opt);\n+            }\n+            if (opt != null && longOpt != null) {\n+                sb.append(\",\");\n+            }\n             if (longOpt != null) {\n-                sb.append(\",--\").append(longOpt);\n+                sb.append(\"--\").append(longOpt);\n             }\n             return sb.toString();\n         }\n@@ -243,7 +271,9 @@ protected Object convert(String value, Class type) {\n         }\n \n         throw new RuntimeException(\"can't convert [\" + value + \"] to type \" + type);\n-    };\n+    }\n+\n+    ;\n \n     protected abstract void doCommandLine() throws Exception;\n \n@@ -309,17 +339,35 @@ protected void initOptionFromClass(Class<?> clz) {\n                 option.description = opt.description();\n                 option.hasArg = opt.hasArg();\n                 option.required = opt.required();\n+                boolean haveLongOpt = false;\n                 if (!\"\".equals(opt.longOpt())) {\n                     option.longOpt = opt.longOpt();\n-                    optMap.put(\"--\" + option.longOpt, option);\n+                    checkConflict(option, \"--\" + option.longOpt);\n+                    haveLongOpt = true;\n                 }\n                 if (!\"\".equals(opt.argName())) {\n                     option.argName = opt.argName();\n                 }\n-                optMap.put(\"-\" + option.opt, option);\n+                if (!\"\".equals(opt.opt())) {\n+                    checkConflict(option, \"-\" + option.opt);\n+                } else {\n+                    if (!haveLongOpt) {\n+                        throw new RuntimeException(\"opt or longOpt is not set in @Opt(...) \" + f);\n             }\n         }\n     }\n+        }\n+    }\n+\n+    private void checkConflict(Option option, String key) {\n+        if (optMap.containsKey(key)) {\n+            Option preOption = optMap.get(key);\n+            throw new RuntimeException(String.format(\"[@Opt(...) %s] conflict with [@Opt(...) %s]\",\n+                    preOption.field.toString(), option.field\n+            ));\n+        }\n+        optMap.put(key, option);\n+    }\n \n     protected void initOptions() {\n         initOptionFromClass(this.getClass());\n@@ -409,10 +457,7 @@ protected void usage() {\n         TreeSet<Option> options = new TreeSet<Option>(this.optMap.values());\n         int palength = -1;\n         for (Option option : options) {\n-            int pa = 5 + option.opt.length();\n-            if (option.longOpt != null) {\n-                pa += 3 + option.longOpt.length();\n-            }\n+            int pa = 4 + option.getOptAndLongOpt().length();\n             if (option.hasArg) {\n                 pa += 3 + option.argName.length();\n             }\n@@ -427,10 +472,7 @@ protected void usage() {\n         StringBuilder sb = new StringBuilder();\n         for (Option option : options) {\n             sb.setLength(0);\n-            sb.append(\" -\").append(option.opt);\n-            if (option.longOpt != null) {\n-                sb.append(\",--\").append(option.longOpt);\n-            }\n+            sb.append(\" \").append(option.getOptAndLongOpt());\n             if (option.hasArg) {\n                 sb.append(\" <\").append(option.argName).append(\">\");\n             }",
      "parent_sha": "2c55aefd4b77fccd2e31d0f3ff90b4b83a98812b"
    }
  },
  {
    "oid": "5d46cee72c0975f4a4faec12ee9023589b1b7b00",
    "message": "Fix a bug in read ics,\n\nFixes issue 110\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2012-02-20T03:03:49Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/5d46cee72c0975f4a4faec12ee9023589b1b7b00",
    "details": {
      "sha": "3fecb411f10538924040a4f9830db15cae7b7d68",
      "filename": "dex-reader/src/main/java/com/googlecode/dex2jar/reader/DexInternalOpcode.java",
      "status": "modified",
      "additions": 52,
      "deletions": 52,
      "changes": 104,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/5d46cee72c0975f4a4faec12ee9023589b1b7b00/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexInternalOpcode.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/5d46cee72c0975f4a4faec12ee9023589b1b7b00/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexInternalOpcode.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexInternalOpcode.java?ref=5d46cee72c0975f4a4faec12ee9023589b1b7b00",
      "patch": "@@ -216,57 +216,57 @@\n     int OP_IPUT_OBJECT_VOLATILE = 0x0000fc;\r\n     int OP_SGET_OBJECT_VOLATILE = 0x0000fd;\r\n     int OP_SPUT_OBJECT_VOLATILE = 0x0000fe;\r\n-    int OP_CONST_CLASS_JUMBO = 0x00ff00;\r\n-    int OP_CHECK_CAST_JUMBO = 0x00ff01;\r\n-    int OP_INSTANCE_OF_JUMBO = 0x00ff02;\r\n-    int OP_NEW_INSTANCE_JUMBO = 0x00ff03;\r\n-    int OP_NEW_ARRAY_JUMBO = 0x00ff04;\r\n-    int OP_FILLED_NEW_ARRAY_JUMBO = 0x00ff05;\r\n-    int OP_IGET_JUMBO = 0x00ff06;\r\n-    int OP_IGET_WIDE_JUMBO = 0x00ff07;\r\n-    int OP_IGET_OBJECT_JUMBO = 0x00ff08;\r\n-    int OP_IGET_BOOLEAN_JUMBO = 0x00ff09;\r\n-    int OP_IGET_BYTE_JUMBO = 0x00ff0a;\r\n-    int OP_IGET_CHAR_JUMBO = 0x00ff0b;\r\n-    int OP_IGET_SHORT_JUMBO = 0x00ff0c;\r\n-    int OP_IPUT_JUMBO = 0x00ff0d;\r\n-    int OP_IPUT_WIDE_JUMBO = 0x00ff0e;\r\n-    int OP_IPUT_OBJECT_JUMBO = 0x00ff0f;\r\n-    int OP_IPUT_BOOLEAN_JUMBO = 0x00ff10;\r\n-    int OP_IPUT_BYTE_JUMBO = 0x00ff11;\r\n-    int OP_IPUT_CHAR_JUMBO = 0x00ff12;\r\n-    int OP_IPUT_SHORT_JUMBO = 0x00ff13;\r\n-    int OP_SGET_JUMBO = 0x00ff14;\r\n-    int OP_SGET_WIDE_JUMBO = 0x00ff15;\r\n-    int OP_SGET_OBJECT_JUMBO = 0x00ff16;\r\n-    int OP_SGET_BOOLEAN_JUMBO = 0x00ff17;\r\n-    int OP_SGET_BYTE_JUMBO = 0x00ff18;\r\n-    int OP_SGET_CHAR_JUMBO = 0x00ff19;\r\n-    int OP_SGET_SHORT_JUMBO = 0x00ff1a;\r\n-    int OP_SPUT_JUMBO = 0x00ff1b;\r\n-    int OP_SPUT_WIDE_JUMBO = 0x00ff1c;\r\n-    int OP_SPUT_OBJECT_JUMBO = 0x00ff1d;\r\n-    int OP_SPUT_BOOLEAN_JUMBO = 0x00ff1e;\r\n-    int OP_SPUT_BYTE_JUMBO = 0x00ff1f;\r\n-    int OP_SPUT_CHAR_JUMBO = 0x00ff20;\r\n-    int OP_SPUT_SHORT_JUMBO = 0x00ff21;\r\n-    int OP_INVOKE_VIRTUAL_JUMBO = 0x00ff22;\r\n-    int OP_INVOKE_SUPER_JUMBO = 0x00ff23;\r\n-    int OP_INVOKE_DIRECT_JUMBO = 0x00ff24;\r\n-    int OP_INVOKE_STATIC_JUMBO = 0x00ff25;\r\n-    int OP_INVOKE_INTERFACE_JUMBO = 0x00ff26;\r\n-    int OP_INVOKE_OBJECT_INIT_JUMBO = 0x00fff2;\r\n-    int OP_IGET_VOLATILE_JUMBO = 0x00fff3;\r\n-    int OP_IGET_WIDE_VOLATILE_JUMBO = 0x00fff4;\r\n-    int OP_IGET_OBJECT_VOLATILE_JUMBO = 0x00fff5;\r\n-    int OP_IPUT_VOLATILE_JUMBO = 0x00fff6;\r\n-    int OP_IPUT_WIDE_VOLATILE_JUMBO = 0x00fff7;\r\n-    int OP_IPUT_OBJECT_VOLATILE_JUMBO = 0x00fff8;\r\n-    int OP_SGET_VOLATILE_JUMBO = 0x00fff9;\r\n-    int OP_SGET_WIDE_VOLATILE_JUMBO = 0x00fffa;\r\n-    int OP_SGET_OBJECT_VOLATILE_JUMBO = 0x00fffb;\r\n-    int OP_SPUT_VOLATILE_JUMBO = 0x00fffc;\r\n-    int OP_SPUT_WIDE_VOLATILE_JUMBO = 0x00fffd;\r\n-    int OP_SPUT_OBJECT_VOLATILE_JUMBO = 0x00fffe;\r\n+    int OP_CONST_CLASS_JUMBO = 0x0000ff;\r\n+    int OP_CHECK_CAST_JUMBO = 0x0001ff;\r\n+    int OP_INSTANCE_OF_JUMBO = 0x0002ff;\r\n+    int OP_NEW_INSTANCE_JUMBO = 0x0003ff;\r\n+    int OP_NEW_ARRAY_JUMBO = 0x0004ff;\r\n+    int OP_FILLED_NEW_ARRAY_JUMBO = 0x0005ff;\r\n+    int OP_IGET_JUMBO = 0x0006ff;\r\n+    int OP_IGET_WIDE_JUMBO = 0x0007ff;\r\n+    int OP_IGET_OBJECT_JUMBO = 0x0008ff;\r\n+    int OP_IGET_BOOLEAN_JUMBO = 0x0009ff;\r\n+    int OP_IGET_BYTE_JUMBO = 0x000aff;\r\n+    int OP_IGET_CHAR_JUMBO = 0x000bff;\r\n+    int OP_IGET_SHORT_JUMBO = 0x000cff;\r\n+    int OP_IPUT_JUMBO = 0x000dff;\r\n+    int OP_IPUT_WIDE_JUMBO = 0x000eff;\r\n+    int OP_IPUT_OBJECT_JUMBO = 0x000fff;\r\n+    int OP_IPUT_BOOLEAN_JUMBO = 0x0010ff;\r\n+    int OP_IPUT_BYTE_JUMBO = 0x0011ff;\r\n+    int OP_IPUT_CHAR_JUMBO = 0x0012ff;\r\n+    int OP_IPUT_SHORT_JUMBO = 0x0013ff;\r\n+    int OP_SGET_JUMBO = 0x0014ff;\r\n+    int OP_SGET_WIDE_JUMBO = 0x0015ff;\r\n+    int OP_SGET_OBJECT_JUMBO = 0x0016ff;\r\n+    int OP_SGET_BOOLEAN_JUMBO = 0x0017ff;\r\n+    int OP_SGET_BYTE_JUMBO = 0x0018ff;\r\n+    int OP_SGET_CHAR_JUMBO = 0x0019ff;\r\n+    int OP_SGET_SHORT_JUMBO = 0x001aff;\r\n+    int OP_SPUT_JUMBO = 0x001bff;\r\n+    int OP_SPUT_WIDE_JUMBO = 0x001cff;\r\n+    int OP_SPUT_OBJECT_JUMBO = 0x001dff;\r\n+    int OP_SPUT_BOOLEAN_JUMBO = 0x001eff;\r\n+    int OP_SPUT_BYTE_JUMBO = 0x001fff;\r\n+    int OP_SPUT_CHAR_JUMBO = 0x0020ff;\r\n+    int OP_SPUT_SHORT_JUMBO = 0x0021ff;\r\n+    int OP_INVOKE_VIRTUAL_JUMBO = 0x0022ff;\r\n+    int OP_INVOKE_SUPER_JUMBO = 0x0023ff;\r\n+    int OP_INVOKE_DIRECT_JUMBO = 0x0024ff;\r\n+    int OP_INVOKE_STATIC_JUMBO = 0x0025ff;\r\n+    int OP_INVOKE_INTERFACE_JUMBO = 0x0026ff;\r\n+    int OP_INVOKE_OBJECT_INIT_JUMBO = 0x00f2ff;\r\n+    int OP_IGET_VOLATILE_JUMBO = 0x00f3ff;\r\n+    int OP_IGET_WIDE_VOLATILE_JUMBO = 0x00f4ff;\r\n+    int OP_IGET_OBJECT_VOLATILE_JUMBO = 0x00f5ff;\r\n+    int OP_IPUT_VOLATILE_JUMBO = 0x00f6ff;\r\n+    int OP_IPUT_WIDE_VOLATILE_JUMBO = 0x00f7ff;\r\n+    int OP_IPUT_OBJECT_VOLATILE_JUMBO = 0x00f8ff;\r\n+    int OP_SGET_VOLATILE_JUMBO = 0x00f9ff;\r\n+    int OP_SGET_WIDE_VOLATILE_JUMBO = 0x00faff;\r\n+    int OP_SGET_OBJECT_VOLATILE_JUMBO = 0x00fbff;\r\n+    int OP_SPUT_VOLATILE_JUMBO = 0x00fcff;\r\n+    int OP_SPUT_WIDE_VOLATILE_JUMBO = 0x00fdff;\r\n+    int OP_SPUT_OBJECT_VOLATILE_JUMBO = 0x00feff;\r\n \r\n }\r",
      "parent_sha": "8ae408b7993cd7acd668a7922f484186ae491e9b"
    }
  },
  {
    "oid": "225007175394caf5388e9841844e10ea211cdbde",
    "message": "print 'all' if the catch type is null\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2012-03-01T03:55:17Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/225007175394caf5388e9841844e10ea211cdbde",
    "details": {
      "sha": "2ecbf7baee9c72bcc55eb7ae6c5bfa4959d7dd34",
      "filename": "dex-tools/src/main/java/com/googlecode/dex2jar/tools/JasminifierClassAdapter.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/225007175394caf5388e9841844e10ea211cdbde/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FJasminifierClassAdapter.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/225007175394caf5388e9841844e10ea211cdbde/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FJasminifierClassAdapter.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-tools%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Ftools%2FJasminifierClassAdapter.java?ref=225007175394caf5388e9841844e10ea211cdbde",
      "patch": "@@ -333,7 +333,7 @@ public void visitEnd() {\n                 for (int j = 0; j < mn.tryCatchBlocks.size(); ++j) {\r\n                     TryCatchBlockNode tcb = (TryCatchBlockNode) mn.tryCatchBlocks.get(j);\r\n                     pw.print(\".catch \");\r\n-                    pw.print(tcb.type);\r\n+                    pw.print(tcb.type == null ? \"all\" : tcb.type);\r\n                     pw.print(\" from \");\r\n                     print(tcb.start);\r\n                     pw.print(\" to \");\r",
      "parent_sha": "0cbcd6ea28a7089e6f4dc28506c61a3637141323"
    }
  },
  {
    "oid": "3ac5eca6cf6a78603af97187979ad8636af6ca31",
    "message": "add tool to update dex checksums\n\n--HG--\nbranch : 2.x",
    "date": "2014-07-22T14:09:29Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/3ac5eca6cf6a78603af97187979ad8636af6ca31",
    "details": {
      "sha": "29fb70675261ef0341004a4eea67628bd8ebf7e8",
      "filename": "dex-writer/src/main/java/com/googlecode/d2j/dex/writer/DexFileWriter.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/3ac5eca6cf6a78603af97187979ad8636af6ca31/dex-writer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2Fwriter%2FDexFileWriter.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/3ac5eca6cf6a78603af97187979ad8636af6ca31/dex-writer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2Fwriter%2FDexFileWriter.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-writer%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Fdex%2Fwriter%2FDexFileWriter.java?ref=3ac5eca6cf6a78603af97187979ad8636af6ca31",
      "patch": "@@ -212,7 +212,7 @@ public byte[] toByteArray() {\n         return buffer.array();\n     }\n \n-    private void updateChecksum(ByteBuffer buffer, int size) {\n+    public static void updateChecksum(ByteBuffer buffer, int size) {\n         byte[] data = buffer.array();\n         MessageDigest digest;\n         try {",
      "parent_sha": "5fb56cd1c76394c195d95b4cba5d4df040565d26"
    }
  },
  {
    "oid": "5341bd145d67d81ae2d230f5428f1319767f7baf",
    "message": "fixed issue 185\n\nhttps://github.com/pxb1988/dex2jar/issues/185\n\nsome zip use a large comment filed which will exceed the zip file content.",
    "date": "2018-06-06T03:14:11Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/5341bd145d67d81ae2d230f5428f1319767f7baf",
    "details": {
      "sha": "f8211f13d91fa9bc95157c522afff67fdddaef26",
      "filename": "dex-reader/src/main/java/com/googlecode/d2j/util/zip/ZipFile.java",
      "status": "modified",
      "additions": 9,
      "deletions": 5,
      "changes": 14,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/5341bd145d67d81ae2d230f5428f1319767f7baf/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Futil%2Fzip%2FZipFile.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/5341bd145d67d81ae2d230f5428f1319767f7baf/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Futil%2Fzip%2FZipFile.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fd2j%2Futil%2Fzip%2FZipFile.java?ref=5341bd145d67d81ae2d230f5428f1319767f7baf",
      "patch": "@@ -235,12 +235,16 @@ private void readCentralDir() throws IOException {\n         boolean skipCommentsAndExtra = true;\n \n         if (commentLength > 0) {\n-            if (skipCommentsAndExtra) {\n-                skip(raf, commentLength);\n+            if (commentLength > raf.remaining()) {\n+                System.err.println(\"WARN: the zip comment exceed the zip content\");\n             } else {\n-                byte[] commentBytes = new byte[commentLength];\n-                raf.get(commentBytes);\n-                comment = new String(commentBytes, 0, commentBytes.length, StandardCharsets.UTF_8);\n+                if (skipCommentsAndExtra) {\n+                    skip(raf, commentLength);\n+                } else {\n+                    byte[] commentBytes = new byte[commentLength];\n+                    raf.get(commentBytes);\n+                    comment = new String(commentBytes, 0, commentBytes.length, StandardCharsets.UTF_8);\n+                }\n             }\n         }\n ",
      "parent_sha": "b006a5c9ca11317513ed7c049f1d0433be2652b1"
    }
  },
  {
    "oid": "08b0670600217254c374fba8f5e3a89d4649e57c",
    "message": "add support NO_INDEX in debug_info_item\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2011-09-25T15:03:59Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/08b0670600217254c374fba8f5e3a89d4649e57c",
    "details": {
      "sha": "fc3177693a399692dad2c389b0fb3074e03d34bf",
      "filename": "dex-reader/src/main/java/com/googlecode/dex2jar/reader/DexDebugInfoReader.java",
      "status": "modified",
      "additions": 7,
      "deletions": 3,
      "changes": 10,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/08b0670600217254c374fba8f5e3a89d4649e57c/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexDebugInfoReader.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/08b0670600217254c374fba8f5e3a89d4649e57c/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexDebugInfoReader.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexDebugInfoReader.java?ref=08b0670600217254c374fba8f5e3a89d4649e57c",
      "patch": "@@ -104,9 +104,13 @@ public void accept(DexCodeVisitor dcv) {\n             int szParams = (int) in.readUnsignedLeb128();\r\n             int offset = szParams == this.args.length ? 0 : 1;\r\n             for (int i = 0; i < szParams; i++) {\r\n-                int string_offset = (int) (in.readUnsignedLeb128() - 1);\r\n-                String psName = dex.getString(string_offset);\r\n-                this.variableList[this.args[i + offset]].name = psName;\r\n+                int string_offset = (int) in.readUnsignedLeb128() - 1;\r\n+                if (string_offset < 0) {// NO_INDEX\r\n+                    this.variableList[this.args[i + offset]] = null;// remove the variable\r\n+                } else {\r\n+                    String psName = dex.getString(string_offset);\r\n+                    this.variableList[this.args[i + offset]].name = psName;\r\n+                }\r\n             }\r\n         }\r\n         int pcOffset = 0;\r",
      "parent_sha": "48d9d44dea9b4bac7d982327a5072386dc13058f"
    }
  },
  {
    "oid": "3465ff04e1338c7f59ef349f01d9c50fade5eca8",
    "message": "fix a eclipse worning in DexFileReader\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2013-02-03T13:57:42Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/3465ff04e1338c7f59ef349f01d9c50fade5eca8",
    "details": {
      "sha": "3a9392a2a53ee817baf1938aa5f2070bbb1278e1",
      "filename": "dex-reader/src/main/java/com/googlecode/dex2jar/reader/DexFileReader.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/3465ff04e1338c7f59ef349f01d9c50fade5eca8/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexFileReader.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/3465ff04e1338c7f59ef349f01d9c50fade5eca8/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexFileReader.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexFileReader.java?ref=3465ff04e1338c7f59ef349f01d9c50fade5eca8",
      "patch": "@@ -126,7 +126,9 @@ public static byte[] readDex(byte[] data) throws IOException {\n                 zis = new ZipInputStream(new ByteArrayInputStream(data));\r\n                 for (ZipEntry entry = zis.getNextEntry(); entry != null; entry = zis.getNextEntry()) {\r\n                     if (entry.getName().equals(\"classes.dex\")) {\r\n-                        return IOUtils.toByteArray(zis);\r\n+                        data = IOUtils.toByteArray(zis);\r\n+                        zis.close();\r\n+                        return data;\r\n                     }\r\n                 }\r\n             } finally {\r",
      "parent_sha": "4335f35c9d76f5be0c285f9277bcf8fd7244b517"
    }
  },
  {
    "oid": "30939851e7dc6de88c7bff192738f070c33a9c43",
    "message": "Fixes issue 179\nFixes issue 180\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2013-06-04T03:22:25Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/30939851e7dc6de88c7bff192738f070c33a9c43",
    "details": {
      "sha": "9810575bbe64a68ff0197dda873b2c2dbf3bedb5",
      "filename": "dex-translator/src/main/java/com/googlecode/dex2jar/v3/AnnotationNode.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/30939851e7dc6de88c7bff192738f070c33a9c43/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FAnnotationNode.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/30939851e7dc6de88c7bff192738f070c33a9c43/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FAnnotationNode.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-translator%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fv3%2FAnnotationNode.java?ref=30939851e7dc6de88c7bff192738f070c33a9c43",
      "patch": "@@ -197,7 +197,7 @@ public void visitEnum(String name, String desc, String value) {\n \r\n         @Override\r\n         public DexAnnotationVisitor visitAnnotation(String name, String desc) {\r\n-            AnnotationNode node = new AnnotationNode();\r\n+            AnnotationNode node = new AnnotationNode(desc, true);\r\n             list.add(node);\r\n             return node;\r\n         }\r",
      "parent_sha": "2de84878c02c11ee4f75c3e6aea4588828b5e1e6"
    }
  },
  {
    "oid": "9ab4d9073a4982ec73cb183ce9b77696b97c0b5c",
    "message": "add support to visit a label inside an instruction (issue 65)\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2011-11-10T12:09:40Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/9ab4d9073a4982ec73cb183ce9b77696b97c0b5c",
    "details": {
      "sha": "c9c4e0cef915e2fbc946af38240ae8f670759061",
      "filename": "dex-reader/src/main/java/com/googlecode/dex2jar/reader/DexCodeReader.java",
      "status": "modified",
      "additions": 32,
      "deletions": 7,
      "changes": 39,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/9ab4d9073a4982ec73cb183ce9b77696b97c0b5c/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexCodeReader.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/9ab4d9073a4982ec73cb183ce9b77696b97c0b5c/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexCodeReader.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-reader%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Freader%2FDexCodeReader.java?ref=9ab4d9073a4982ec73cb183ce9b77696b97c0b5c",
      "patch": "@@ -40,8 +40,9 @@\n import static com.googlecode.dex2jar.reader.OpcodeFormat.F3rc;\r\n import static com.googlecode.dex2jar.reader.OpcodeFormat.F51l;\r\n \r\n-import java.util.HashMap;\r\n+import java.util.Iterator;\r\n import java.util.Map;\r\n+import java.util.TreeMap;\r\n \r\n import com.googlecode.dex2jar.DexException;\r\n import com.googlecode.dex2jar.DexLabel;\r\n@@ -69,7 +70,7 @@\n     /**\r\n      * \u6807\u7b7e\u6620\u5c04,\u6307\u4ee4\u4f4d\u7f6e->\u6307\u4ee4\u7f16\u53f7\r\n      */\r\n-    /* default */Map<Integer, DexLabel> labels = new HashMap<Integer, DexLabel>();\r\n+    /* default */Map<Integer, DexLabel> labels = new TreeMap<Integer, DexLabel>();\r\n \r\n     private boolean isStatic;\r\n \r\n@@ -316,13 +317,30 @@ public void accept(DexCodeVisitor dcv, int config) {\n \r\n     private void acceptInsn(DataIn in, int instruction_size, DexOpcodeAdapter n) {\r\n         // \u5904\u7406\u6307\u4ee4\r\n-        int currentOffset = 0;\r\n-        for (int baseOffset = in.getCurrentPosition(); currentOffset < instruction_size; currentOffset = (in\r\n+        Iterator<Integer> labelOffsetIterator = this.labels.keySet().iterator();\r\n+        Integer nextLabelOffset = labelOffsetIterator.hasNext() ? labelOffsetIterator.next() : null;\r\n+        for (int baseOffset = in.getCurrentPosition(), currentOffset = 0; currentOffset < instruction_size; currentOffset = (in\r\n                 .getCurrentPosition() - baseOffset) / 2) {\r\n+            boolean currentOffsetVisited = false;\r\n+            while (nextLabelOffset != null) {// issue 65, a label may `inside` an instruction\r\n+                int _intNextLabelOffset = nextLabelOffset;// autobox\r\n+                if (_intNextLabelOffset > currentOffset) {\r\n+                    break;\r\n+                } else if (_intNextLabelOffset == currentOffset) {\r\n+                    currentOffsetVisited = true;\r\n+                    n.offset(currentOffset);\r\n+                    nextLabelOffset = labelOffsetIterator.hasNext() ? labelOffsetIterator.next() : null;\r\n+                    break;\r\n+                } else {// _intNextLabelOffset < currentOffset\r\n+                    n.offset(_intNextLabelOffset);\r\n+                    nextLabelOffset = labelOffsetIterator.hasNext() ? labelOffsetIterator.next() : null;\r\n+                }\r\n+            }\r\n+            if (!currentOffsetVisited) {\r\n+                n.offset(currentOffset);\r\n+            }\r\n             int opcode = in.readByte() & 0xff;\r\n \r\n-            n.offset(currentOffset);\r\n-\r\n             int format = DexOpcodeUtil.format(opcode);\r\n \r\n             switch (format) {\r\n@@ -582,7 +600,14 @@ private void acceptInsn(DataIn in, int instruction_size, DexOpcodeAdapter n) {\n                 break;\r\n             }\r\n         }\r\n-        n.offset(currentOffset);\r\n+        while (nextLabelOffset != null) {\r\n+            n.offset(nextLabelOffset);\r\n+            if (labelOffsetIterator.hasNext()) {\r\n+                nextLabelOffset = labelOffsetIterator.next();\r\n+            } else {\r\n+                break;\r\n+            }\r\n+        }\r\n     }\r\n \r\n     /**\r",
      "parent_sha": "60f3e9c85985095c99a11affb0aef481a1c84308"
    }
  },
  {
    "oid": "997cb1c1b716ef2fcd85c8b78245f3157b830dee",
    "message": "Fix NPE in generat Asm Method\n\n--HG--\nbranch : 0.0.9.x",
    "date": "2012-11-22T04:50:21Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/997cb1c1b716ef2fcd85c8b78245f3157b830dee",
    "details": {
      "sha": "fc9de08b71f4d1230b2af112c99edbb90db33492",
      "filename": "dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/TypeAnalyze.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/997cb1c1b716ef2fcd85c8b78245f3157b830dee/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FTypeAnalyze.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/997cb1c1b716ef2fcd85c8b78245f3157b830dee/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FTypeAnalyze.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FTypeAnalyze.java?ref=997cb1c1b716ef2fcd85c8b78245f3157b830dee",
      "patch": "@@ -221,8 +221,9 @@ private void e0expr(E0Expr op) {\n             } else if (value instanceof Type) {\n                 provideAs(cst, Type.getType(Class.class));\n             } else if (value instanceof Number) {\n-                if (value instanceof Integer) {\n-                    int a = ((Integer) value).intValue();\n+                if (value instanceof Integer || value instanceof Byte || value instanceof Short\n+                        || value instanceof Character) {\n+                    int a = ((Number) value).intValue();\n                     if (a >= 0 && a <= 1) {\n                         provideAs(cst, Type.BOOLEAN_TYPE);\n                     } else if (a >= Byte.MIN_VALUE && a <= Byte.MAX_VALUE) {",
      "parent_sha": "223ff6ddeaf4391e9165cc9bf1227fc762b26b44"
    }
  },
  {
    "oid": "8e58b0eb4073ca4a2fb215da0e26d0ff63a59f17",
    "message": "fix bug on MultiArrayTransformer",
    "date": "2016-03-04T12:00:17Z",
    "url": "https://github.com/pxb1988/dex2jar/commit/8e58b0eb4073ca4a2fb215da0e26d0ff63a59f17",
    "details": {
      "sha": "1f13f92bee0159cf86b8a9cc0ad464d1bd77c2e9",
      "filename": "dex-ir/src/main/java/com/googlecode/dex2jar/ir/ts/MultiArrayTransformer.java",
      "status": "modified",
      "additions": 75,
      "deletions": 27,
      "changes": 102,
      "blob_url": "https://github.com/pxb1988/dex2jar/blob/8e58b0eb4073ca4a2fb215da0e26d0ff63a59f17/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FMultiArrayTransformer.java",
      "raw_url": "https://github.com/pxb1988/dex2jar/raw/8e58b0eb4073ca4a2fb215da0e26d0ff63a59f17/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FMultiArrayTransformer.java",
      "contents_url": "https://api.github.com/repos/pxb1988/dex2jar/contents/dex-ir%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgooglecode%2Fdex2jar%2Fir%2Fts%2FMultiArrayTransformer.java?ref=8e58b0eb4073ca4a2fb215da0e26d0ff63a59f17",
      "patch": "@@ -4,8 +4,6 @@\n import com.googlecode.dex2jar.ir.StmtTraveler;\n import com.googlecode.dex2jar.ir.expr.*;\n \n-import java.lang.reflect.Array;\n-\n /**\n  * dex does have the instruction to create a multi-array. the implement is to\n  * using the Array.newInstance().\n@@ -25,7 +23,18 @@ public boolean transformReportChanged(IrMethod method) {\n         new StmtTraveler() {\n             @Override\n             public Value travel(Value op) {\n+                if (op.vt == Value.VT.CHECK_CAST) {\n+                    TypeExpr te = (TypeExpr) op;\n+                    if (te.op.vt == Value.VT.CHECK_CAST) {\n+                        TypeExpr te2 = (TypeExpr) te.op;\n+                        if (te.type.equals(te2.type)) {\n+                            op = te2;\n+                        }\n+                    }\n+                }\n                 op = super.travel(op);\n+\n+\n                 if (op.vt == Value.VT.CHECK_CAST) {\n                     TypeExpr te = (TypeExpr) op;\n                     if (te.type.charAt(0) == '[') {\n@@ -35,36 +44,75 @@ public Value travel(Value op) {\n                             if (invokeExpr.name.equals(\"newInstance\")\n                                     && invokeExpr.owner.equals(\"Ljava/lang/reflect/Array;\")\n                                     && invokeExpr.args.length == 2\n-                                    && invokeExpr.args[0].equals(\"Ljava/lang/Class;\")\n-                                    && invokeExpr.getOps()[0].vt == Value.VT.CONSTANT\n-                                    ) {\n-\n-                                String elementType = ((Constant.Type) ((Constant) invokeExpr.getOps()[0]).value).desc;\n-                                Value dt = invokeExpr.getOps()[1];\n-                                if (invokeExpr.args[1].equals(\"I\")) {\n-                                    if (te.type.equals(\"[\" + elementType)) {\n-                                        int d = 0;\n-                                        while (elementType.charAt(d) == '[') {\n-                                            d++;\n-                                        }\n-                                        changed[0] = true;\n-                                        if (d > 0) {\n-                                            return Exprs.nNewMutiArray(elementType.substring(d), d + 1, new Value[]{dt});\n-                                        } else {\n-                                            return Exprs.nFilledArray(elementType, new Value[]{dt});\n+                                    && invokeExpr.args[0].equals(\"Ljava/lang/Class;\")) {\n+                                Value arg0 = invokeExpr.getOps()[0];\n+                                String elementType = null;\n+                                if (arg0.vt == Value.VT.CONSTANT) {\n+                                    elementType = ((Constant.Type) ((Constant) invokeExpr.getOps()[0]).value).desc;\n+                                } else {\n+                                    if (arg0.vt == Value.VT.STATIC_FIELD) {\n+                                        StaticFieldExpr sfe = (StaticFieldExpr) arg0;\n+                                        if (sfe.owner.startsWith(\"Ljava/lang/\") && sfe.name.equals(\"TYPE\")) {\n+                                            switch (sfe.owner) {\n+                                                case \"Ljava/lang/Boolean;\":\n+                                                    elementType = \"Z\";\n+                                                    break;\n+                                                case \"Ljava/lang/Byte;\":\n+                                                    elementType = \"B\";\n+                                                    break;\n+                                                case \"Ljava/lang/Short;\":\n+                                                    elementType = \"S\";\n+                                                    break;\n+                                                case \"Ljava/lang/Character;\":\n+                                                    elementType = \"C\";\n+                                                    break;\n+                                                case \"Ljava/lang/Integer;\":\n+                                                    elementType = \"I\";\n+                                                    break;\n+                                                case \"Ljava/lang/Long;\":\n+                                                    elementType = \"J\";\n+                                                    break;\n+                                                case \"Ljava/lang/Float;\":\n+                                                    elementType = \"F\";\n+                                                    break;\n+                                                case \"Ljava/lang/Double;\":\n+                                                    elementType = \"D\";\n+                                                    break;\n+                                                case \"Ljava/lang/Void;\":\n+                                                    elementType = \"V\";\n+                                                    break;\n+                                                default:\n+                                            }\n                                         }\n                                     }\n-                                } else {// [I\n-                                    if (dt.vt == Value.VT.FILLED_ARRAY) {\n-                                        FilledArrayExpr filledArrayExpr = (FilledArrayExpr) dt;\n-                                        int d = filledArrayExpr.getOps().length;\n-                                        if (te.type.length() > d && te.type.substring(d).equals(elementType)) {\n-                                            int d1 = 0;\n+                                }\n+                                if (elementType != null) {\n+                                    Value dt = invokeExpr.getOps()[1];\n+                                    if (invokeExpr.args[1].equals(\"I\")) {\n+                                        if (te.type.equals(\"[\" + elementType)) {\n+                                            int d = 0;\n                                             while (elementType.charAt(d) == '[') {\n-                                                d1++;\n+                                                d++;\n                                             }\n                                             changed[0] = true;\n-                                            return Exprs.nNewMutiArray(elementType.substring(d1), d1 + d, filledArrayExpr.getOps());\n+                                            if (d > 0) {\n+                                                return Exprs.nNewMutiArray(elementType.substring(d), d + 1, new Value[]{dt});\n+                                            } else {\n+                                                return Exprs.nNewArray(elementType, dt);\n+                                            }\n+                                        }\n+                                    } else {// [I\n+                                        if (dt.vt == Value.VT.FILLED_ARRAY) {\n+                                            FilledArrayExpr filledArrayExpr = (FilledArrayExpr) dt;\n+                                            int d = filledArrayExpr.getOps().length;\n+                                            if (te.type.length() > d && te.type.substring(d).equals(elementType)) {\n+                                                int d1 = 0;\n+                                                while (elementType.charAt(d1) == '[') {\n+                                                    d1++;\n+                                                }\n+                                                changed[0] = true;\n+                                                return Exprs.nNewMutiArray(elementType.substring(d1), d1 + d, filledArrayExpr.getOps());\n+                                            }\n                                         }\n                                     }\n                                 }",
      "parent_sha": "0d48e4927586dcf7cf8a7a11eb9478f162eaf976"
    }
  }
]