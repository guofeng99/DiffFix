[
  {
    "oid": "3835feb2a12b77720ba5c44ed581bd90afdb33fa",
    "message": "move jersey client cleanup to after unregistration cleanup (which need the apache client)",
    "date": "2015-05-19T18:55:14Z",
    "url": "https://github.com/Netflix/eureka/commit/3835feb2a12b77720ba5c44ed581bd90afdb33fa",
    "details": {
      "sha": "c3c89d9a89239bb436b00b266a8f1c42b4db8b8f",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/Netflix/eureka/blob/3835feb2a12b77720ba5c44ed581bd90afdb33fa/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/3835feb2a12b77720ba5c44ed581bd90afdb33fa/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java?ref=3835feb2a12b77720ba5c44ed581bd90afdb33fa",
      "patch": "@@ -729,14 +729,15 @@ public static List<String> getEurekaServiceUrlsFromConfig(String instanceZone, b\n     public void shutdown() {\n         cancelScheduledTasks();\n \n-        if (discoveryJerseyClient != null) {\n-            discoveryJerseyClient.destroyResources();\n-        }\n         // If APPINFO was registered\n         if (instanceInfo != null && shouldRegister(instanceInfo)) {\n             instanceInfo.setStatus(InstanceStatus.DOWN);\n             unregister();\n         }\n+\n+        if (discoveryJerseyClient != null) {\n+            discoveryJerseyClient.destroyResources();\n+        }\n     }\n \n     /**",
      "parent_sha": "837f78c72b9d74aac2474a42a3b35139256b1e3c"
    }
  },
  {
    "oid": "c46db5d1c8870982d9ccf034dc3f3f6cadfa8427",
    "message": "Fixes the scenario where the deltas  don't work in the case of interactions with a remote region registry.",
    "date": "2013-01-11T01:05:56Z",
    "url": "https://github.com/Netflix/eureka/commit/c46db5d1c8870982d9ccf034dc3f3f6cadfa8427",
    "details": {
      "sha": "ebba31eba256b73b31cc662e72d71132bd8969b0",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/eureka/blob/c46db5d1c8870982d9ccf034dc3f3f6cadfa8427/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FInstanceRegistry.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/c46db5d1c8870982d9ccf034dc3f3f6cadfa8427/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FInstanceRegistry.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FInstanceRegistry.java?ref=c46db5d1c8870982d9ccf034dc3f3f6cadfa8427",
      "patch": "@@ -588,12 +588,14 @@ public Applications getApplicationDeltas() {\n                 }\n                 app.addInstance(decorateInstanceInfo(lease));\n             }\n+            Applications allAppsInLocalRegion = getApplications(false);\n+            \n             for (RemoteRegionRegistry remoteRegistry : this.remoteRegionRegistryList) {\n                 Applications applications = remoteRegistry\n                         .getApplicationDeltas();\n                 for (Application application : applications\n                         .getRegisteredApplications()) {\n-                    Application appInLocalRegistry = apps\n+                    Application appInLocalRegistry = allAppsInLocalRegion\n                             .getRegisteredApplications(application.getName());\n                     if (appInLocalRegistry == null) {\n                         apps.addApplication(application);",
      "parent_sha": "152efc71960399b1133e1f229cb53d48dee1b6b4"
    }
  },
  {
    "oid": "857ac29774aa695d14a4a9048440a8aaec5169e2",
    "message": "Improve the name of the system secure client",
    "date": "2014-10-29T14:54:33Z",
    "url": "https://github.com/Netflix/eureka/commit/857ac29774aa695d14a4a9048440a8aaec5169e2",
    "details": {
      "sha": "8fa52455897eff007fa5715473c34980b9d9bc45",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/eureka/blob/857ac29774aa695d14a4a9048440a8aaec5169e2/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FRemoteRegionRegistry.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/857ac29774aa695d14a4a9048440a8aaec5169e2/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FRemoteRegionRegistry.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FRemoteRegionRegistry.java?ref=857ac29774aa695d14a4a9048440a8aaec5169e2",
      "patch": "@@ -85,7 +85,7 @@ public RemoteRegionRegistry(String regionName, URL remoteRegionURL) {\n                     EUREKA_SERVER_CONFIG.getRemoteRegionTotalConnections(),\n                     EUREKA_SERVER_CONFIG.getRemoteRegionConnectionIdleTimeoutSeconds());\n         } else if (\"true\".equals(System.getProperty(\"com.netflix.eureka.shouldSSLConnectionsUseSystemSocketFactory\"))) {\n-            jerseyClientName = \"Discovery-RemoteRegionSecureClient-\" + regionName;\n+            jerseyClientName = \"Discovery-RemoteRegionSystemSecureClient-\" + regionName;\n             discoveryJerseyClient =\n                     EurekaJerseyClient.createSystemSSLJerseyClient(\n                             jerseyClientName,",
      "parent_sha": "9d077760a8dfce2609ecb8b5602a86cb34f2854f"
    }
  },
  {
    "oid": "a9f39cc5cb5c80fd7fa86a4231037369d28b727a",
    "message": "tuning test timing",
    "date": "2016-02-15T20:40:59Z",
    "url": "https://github.com/Netflix/eureka/commit/a9f39cc5cb5c80fd7fa86a4231037369d28b727a",
    "details": {
      "sha": "07ad15d41c9461ba1921d1c758e7d37d96eb86d8",
      "filename": "eureka-client/src/test/java/com/netflix/discovery/shared/transport/EurekaHttpClientsTest.java",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/Netflix/eureka/blob/a9f39cc5cb5c80fd7fa86a4231037369d28b727a/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2FEurekaHttpClientsTest.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/a9f39cc5cb5c80fd7fa86a4231037369d28b727a/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2FEurekaHttpClientsTest.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2FEurekaHttpClientsTest.java?ref=a9f39cc5cb5c80fd7fa86a4231037369d28b727a",
      "patch": "@@ -160,8 +160,8 @@ public void testCompositeBootstrapResolver() throws Exception {\n \n         when(transportConfig.getWriteClusterVip()).thenReturn(vipAddress);\n         when(transportConfig.getAsyncExecutorThreadPoolSize()).thenReturn(4);\n-        when(transportConfig.getAsyncResolverRefreshIntervalMs()).thenReturn(300);\n-        when(transportConfig.getAsyncResolverWarmUpTimeoutMs()).thenReturn(200);\n+        when(transportConfig.getAsyncResolverRefreshIntervalMs()).thenReturn(400);\n+        when(transportConfig.getAsyncResolverWarmUpTimeoutMs()).thenReturn(400);\n \n         ApplicationsResolver.ApplicationsSource applicationsSource = mock(ApplicationsResolver.ApplicationsSource.class);\n         when(applicationsSource.getApplications(anyInt(), eq(TimeUnit.SECONDS)))\n@@ -191,14 +191,14 @@ public void testCompositeBootstrapResolver() throws Exception {\n             assertThat(endpoints.size(), equalTo(applications.getInstancesByVirtualHostName(vipAddress).size()));\n \n             // wait for the second cycle that hits the app source\n-            verify(applicationsSource, timeout(1000).times(2)).getApplications(anyInt(), eq(TimeUnit.SECONDS));\n+            verify(applicationsSource, timeout(3000).times(2)).getApplications(anyInt(), eq(TimeUnit.SECONDS));\n             endpoints = resolver.getClusterEndpoints();\n             assertThat(endpoints.size(), equalTo(applications.getInstancesByVirtualHostName(vipAddress).size()));\n \n             // wait for the third cycle that triggers the mock http client (which is the third resolver cycle)\n             // for the third cycle we have mocked the application resolver to return null data so should fall back\n             // to calling the remote resolver again (which should return applications2)\n-            verify(mockHttpClient, timeout(1000).times(3)).getVip(anyString());\n+            verify(mockHttpClient, timeout(3000).times(3)).getVip(anyString());\n             endpoints = resolver.getClusterEndpoints();\n             assertThat(endpoints.size(), equalTo(applications2.getInstancesByVirtualHostName(vipAddress).size()));\n         } finally {\n@@ -214,8 +214,8 @@ public void testCanonicalResolver() throws Exception {\n         when(clientConfig.getRegion()).thenReturn(\"region\");\n \n         when(transportConfig.getAsyncExecutorThreadPoolSize()).thenReturn(3);\n-        when(transportConfig.getAsyncResolverRefreshIntervalMs()).thenReturn(300);\n-        when(transportConfig.getAsyncResolverWarmUpTimeoutMs()).thenReturn(200);\n+        when(transportConfig.getAsyncResolverRefreshIntervalMs()).thenReturn(400);\n+        when(transportConfig.getAsyncResolverWarmUpTimeoutMs()).thenReturn(400);\n \n         Applications applications = InstanceInfoGenerator.newBuilder(5, \"eurekaRead\", \"someOther\").build().toApplications();\n         String vipAddress = applications.getRegisteredApplications(\"eurekaRead\").getInstances().get(0).getVIPAddress();\n@@ -252,7 +252,7 @@ public void testCanonicalResolver() throws Exception {\n             verify(localResolver, times(1)).getClusterEndpoints();\n \n             // wait for the second cycle that hits the app source\n-            verify(applicationsSource, timeout(1000).times(2)).getApplications(anyInt(), eq(TimeUnit.SECONDS));\n+            verify(applicationsSource, timeout(3000).times(2)).getApplications(anyInt(), eq(TimeUnit.SECONDS));\n             endpoints = resolver.getClusterEndpoints();\n             assertThat(endpoints.size(), equalTo(applications.getInstancesByVirtualHostName(vipAddress).size()));\n ",
      "parent_sha": "19a898cf056b0a45469bb28f208840154a3585f0"
    }
  },
  {
    "oid": "27c40a465c19783948bd821c97a0a56f857acb95",
    "message": "better named threads",
    "date": "2016-02-15T18:58:32Z",
    "url": "https://github.com/Netflix/eureka/commit/27c40a465c19783948bd821c97a0a56f857acb95",
    "details": {
      "sha": "d1937c264fe47c89e7e6b6ab3733dd9b9269f127",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/shared/resolver/AsyncResolver.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/eureka/blob/27c40a465c19783948bd821c97a0a56f857acb95/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Fresolver%2FAsyncResolver.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/27c40a465c19783948bd821c97a0a56f857acb95/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Fresolver%2FAsyncResolver.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Fresolver%2FAsyncResolver.java?ref=27c40a465c19783948bd821c97a0a56f857acb95",
      "patch": "@@ -109,15 +109,15 @@ public AsyncResolver(String name,\n \n         this.executorService = Executors.newScheduledThreadPool(1,\n                 new ThreadFactoryBuilder()\n-                        .setNameFormat(\"AsyncResolver-%d\")\n+                        .setNameFormat(\"AsyncResolver-\" + name + \"-%d\")\n                         .setDaemon(true)\n                         .build());\n \n         this.threadPoolExecutor = new ThreadPoolExecutor(\n                 1, executorThreadPoolSize, 0, TimeUnit.SECONDS,\n                 new SynchronousQueue<Runnable>(),  // use direct handoff\n                 new ThreadFactoryBuilder()\n-                        .setNameFormat(\"AsyncResolver-executor-%d\")\n+                        .setNameFormat(\"AsyncResolver-\" + name + \"-executor-%d\")\n                         .setDaemon(true)\n                         .build()\n         );",
      "parent_sha": "fc88abe6371c28d5538653687a7800c6f23bee5d"
    }
  },
  {
    "oid": "5148ea874e8343a3993a94cb21362f196bb9b3fc",
    "message": "Reducing test execution time",
    "date": "2015-06-02T06:33:37Z",
    "url": "https://github.com/Netflix/eureka/commit/5148ea874e8343a3993a94cb21362f196bb9b3fc",
    "details": {
      "sha": "267ca2c90c4aed580e729189f52dccfa5fb4c254",
      "filename": "eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegisterUpdateTest.java",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/Netflix/eureka/blob/5148ea874e8343a3993a94cb21362f196bb9b3fc/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClientRegisterUpdateTest.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/5148ea874e8343a3993a94cb21362f196bb9b3fc/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClientRegisterUpdateTest.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClientRegisterUpdateTest.java?ref=5148ea874e8343a3993a94cb21362f196bb9b3fc",
      "patch": "@@ -26,7 +26,7 @@ public void setUp() throws Exception {\n \n         ConfigurationManager.getConfigInstance().setProperty(\"eureka.name\", \"EurekaTestApp-\" + UUID.randomUUID());\n         ConfigurationManager.getConfigInstance().setProperty(\"eureka.registration.enabled\", \"true\");\n-        ConfigurationManager.getConfigInstance().setProperty(\"eureka.appinfo.replicate.interval\", 10);\n+        ConfigurationManager.getConfigInstance().setProperty(\"eureka.appinfo.replicate.interval\", 2);\n         ConfigurationManager.getConfigInstance().setProperty(\"eureka.shouldFetchRegistry\", \"false\");\n         ConfigurationManager.getConfigInstance().setProperty(\"eureka.serviceUrl.default\",\n                 \"http://localhost:\" + mockLocalEurekaServer.getPort() +\n@@ -40,12 +40,12 @@ public void setUp() throws Exception {\n     @Test\n     public void registerUpdateLifecycleTest() throws Exception {\n         applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UP);\n-        Thread.sleep(1000);  // give some execution time\n+        Thread.sleep(400);  // give some execution time\n         applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UNKNOWN);\n-        Thread.sleep(1000);  // give some execution time\n+        Thread.sleep(400);  // give some execution time\n         applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.DOWN);\n \n-        Thread.sleep(10 * 1000);\n+        Thread.sleep(2400);\n \n         Assert.assertEquals(Arrays.asList(\"UP\", \"UNKNOWN\", \"DOWN\"), mockLocalEurekaServer.registrationStatuses);\n         Assert.assertEquals(3, mockLocalEurekaServer.registerCount.get());\n@@ -59,10 +59,10 @@ public void registerUpdateQuickLifecycleTest() throws Exception {\n         applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UP);\n         applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UNKNOWN);\n         applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.DOWN);\n-        Thread.sleep(1 * 1000);\n+        Thread.sleep(400);\n         // this call will be rate limited, but will be transmitted by the automatic update after 10s\n         applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UP);\n-        Thread.sleep(15 * 1000);\n+        Thread.sleep(2400);\n \n         Assert.assertEquals(Arrays.asList(\"DOWN\", \"UP\"), mockLocalEurekaServer.registrationStatuses);\n         Assert.assertEquals(2, mockLocalEurekaServer.registerCount.get());",
      "parent_sha": "d196158cab5f8a05b548392abf0de35bf25f0b6f"
    }
  },
  {
    "oid": "d66bdc01329768bf5c90f657a629e9d82bd5df9d",
    "message": "Fix a typo",
    "date": "2017-11-12T21:18:02Z",
    "url": "https://github.com/Netflix/eureka/commit/d66bdc01329768bf5c90f657a629e9d82bd5df9d",
    "details": {
      "sha": "f8786be9436613e9d6def4037ede3401e711425f",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/util/DeserializerStringCache.java",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/Netflix/eureka/blob/d66bdc01329768bf5c90f657a629e9d82bd5df9d/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Futil%2FDeserializerStringCache.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/d66bdc01329768bf5c90f657a629e9d82bd5df9d/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Futil%2FDeserializerStringCache.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Futil%2FDeserializerStringCache.java?ref=d66bdc01329768bf5c90f657a629e9d82bd5df9d",
      "patch": "@@ -36,7 +36,7 @@ public enum CacheScope {\n     }\n \n     private static final Logger logger = LoggerFactory.getLogger(DeserializerStringCache.class);\n-    private static final boolean logEnabled = logger.isTraceEnabled();\n+    private static final boolean debugLogEnabled = logger.isDebugEnabled();\n     private static final String ATTR_STRING_CACHE = \"deserInternCache\";\n     private static final int LENGTH_LIMIT = 256;\n     private static final int LRU_LIMIT = 1024 * 40;\n@@ -118,11 +118,11 @@ public static void clear(ObjectReader reader) {\n     public static void clear(ObjectReader reader, final CacheScope scope) {\n         withCache(reader, cache -> {\n             if (scope == CacheScope.GLOBAL_SCOPE) {\n-                if (logEnabled)\n+                if (debugLogEnabled)\n                     logger.debug(\"clearing global-level cache with size {}\", cache.globalCache.size());\n                 cache.globalCache.clear();\n             }\n-            if (logEnabled)\n+            if (debugLogEnabled)\n                 logger.debug(\"clearing app-level serialization cache with size {}\", cache.applicationCache.size());\n             cache.applicationCache.clear();\n             return null;\n@@ -148,11 +148,11 @@ public static void clear(DeserializationContext context) {\n     public static void clear(DeserializationContext context, CacheScope scope) {\n         withCache(context, cache -> {\n             if (scope == CacheScope.GLOBAL_SCOPE) {\n-                if (logEnabled)\n+                if (debugLogEnabled)\n                     logger.debug(\"clearing global-level serialization cache with size {}\", cache.globalCache.size());\n                 cache.globalCache.clear();\n             }\n-            if (logEnabled)\n+            if (debugLogEnabled)\n                 logger.debug(\"clearing app-level serialization cache with size {}\", cache.applicationCache.size());\n             cache.applicationCache.clear();\n             return null;",
      "parent_sha": "15e3d1870eebe96a962091bcb2dcfe4e6fdb99eb"
    }
  },
  {
    "oid": "2ddcce4ca22768c602524c09958d7689587d5737",
    "message": "Revert DefaultEurekaClientConfigProvider singleton changes",
    "date": "2015-08-10T17:55:57Z",
    "url": "https://github.com/Netflix/eureka/commit/2ddcce4ca22768c602524c09958d7689587d5737",
    "details": {
      "sha": "bd212d647d6e2fbf8f4e54f5f248b4e978771664",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/providers/DefaultEurekaClientConfigProvider.java",
      "status": "modified",
      "additions": 13,
      "deletions": 3,
      "changes": 16,
      "blob_url": "https://github.com/Netflix/eureka/blob/2ddcce4ca22768c602524c09958d7689587d5737/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fproviders%2FDefaultEurekaClientConfigProvider.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/2ddcce4ca22768c602524c09958d7689587d5737/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fproviders%2FDefaultEurekaClientConfigProvider.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fproviders%2FDefaultEurekaClientConfigProvider.java?ref=2ddcce4ca22768c602524c09958d7689587d5737",
      "patch": "@@ -3,6 +3,7 @@\n import com.google.inject.Inject;\n import com.google.inject.Provider;\n import com.netflix.discovery.DefaultEurekaClientConfig;\n+import com.netflix.discovery.DiscoveryManager;\n import com.netflix.discovery.EurekaClientConfig;\n import com.netflix.discovery.EurekaNamespace;\n \n@@ -16,10 +17,19 @@ public class DefaultEurekaClientConfigProvider implements Provider<EurekaClientC\n     @EurekaNamespace\n     private String namespace;\n \n+    private DefaultEurekaClientConfig config;\n+    \n     @Override\n     public synchronized EurekaClientConfig get() {\n-        return namespace == null\n-                 ? new DefaultEurekaClientConfig()\n-                 : new DefaultEurekaClientConfig(namespace);\n+        if (config == null) {\n+            config = (namespace == null)\n+                    ? new DefaultEurekaClientConfig()\n+                    : new DefaultEurekaClientConfig(namespace);\n+                    \n+            // TODO: Remove this when DiscoveryManager is finally no longer used\n+            DiscoveryManager.getInstance().setEurekaClientConfig(config);\n+        }\n+\n+        return config;\n     }\n }",
      "parent_sha": "d1367d10806aceb0012487540f28e992af5d5378"
    }
  },
  {
    "oid": "142ae10cfe2e2b023793543c6b743a9d1e40de2c",
    "message": "Disabling replication batching by default.",
    "date": "2014-02-06T20:32:05Z",
    "url": "https://github.com/Netflix/eureka/commit/142ae10cfe2e2b023793543c6b743a9d1e40de2c",
    "details": {
      "sha": "e0fc74adc5d58b81fe5046e2e6c69af873b2ee8b",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/eureka/blob/142ae10cfe2e2b023793543c6b743a9d1e40de2c/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FDefaultEurekaServerConfig.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/142ae10cfe2e2b023793543c6b743a9d1e40de2c/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FDefaultEurekaServerConfig.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FDefaultEurekaServerConfig.java?ref=142ae10cfe2e2b023793543c6b743a9d1e40de2c",
      "patch": "@@ -524,6 +524,6 @@ public boolean disableTransparentFallbackToOtherRegion() {\n \n     @Override\n     public boolean shouldBatchReplication() {\n-        return configInstance.getBooleanProperty(namespace + \"shouldBatchReplication\", true).get();\n+        return configInstance.getBooleanProperty(namespace + \"shouldBatchReplication\", false).get();\n     }\n }",
      "parent_sha": "3cc7e8a4a8d345ab4f79113c94763b590ce3a2bb"
    }
  },
  {
    "oid": "3e192528da1a474eb3ecd3c338a6b1fb92420469",
    "message": "Record fetch mismatches and success counts",
    "date": "2020-09-29T00:19:29Z",
    "url": "https://github.com/Netflix/eureka/commit/3e192528da1a474eb3ecd3c338a6b1fb92420469",
    "details": {
      "sha": "6c9cec34d21c11224f4b8ac165db5d89bcf0d62b",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/registry/RemoteRegionRegistry.java",
      "status": "modified",
      "additions": 16,
      "deletions": 1,
      "changes": 17,
      "blob_url": "https://github.com/Netflix/eureka/blob/3e192528da1a474eb3ecd3c338a6b1fb92420469/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fregistry%2FRemoteRegionRegistry.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/3e192528da1a474eb3ecd3c338a6b1fb92420469/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fregistry%2FRemoteRegionRegistry.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fregistry%2FRemoteRegionRegistry.java?ref=3e192528da1a474eb3ecd3c338a6b1fb92420469",
      "patch": "@@ -94,6 +94,8 @@ public class RemoteRegionRegistry implements LookupService<String> {\n     private volatile boolean readyForServingData;\n     private final EurekaHttpClient eurekaHttpClient;\n     private long timeOfLastSuccessfulRemoteFetch = System.currentTimeMillis();\n+    private long deltaSuccesses = 0;\n+    private long deltaMismatches = 0;\n \n     @Inject\n     public RemoteRegionRegistry(EurekaServerConfig serverConfig,\n@@ -283,8 +285,11 @@ private boolean fetchAndStoreDelta() throws Throwable {\n             }\n \n             // There is a diff in number of instances for some reason\n-            if ((!reconcileHashCode.equals(delta.getAppsHashCode()))) {\n+            if (!reconcileHashCode.equals(delta.getAppsHashCode())) {\n+                deltaMismatches++;\n                 return reconcileAndLogDifference(delta, reconcileHashCode);\n+            } else {\n+                deltaSuccesses++;\n             }\n         }\n \n@@ -515,4 +520,14 @@ private boolean shouldUseExperimentalTransport() {\n     public long getTimeOfLastSuccessfulRemoteFetch() {\n         return (System.currentTimeMillis() - timeOfLastSuccessfulRemoteFetch) / 1000;\n     }\n+\n+    @com.netflix.servo.annotations.Monitor(name = METRIC_REGISTRY_PREFIX + \"remoteDeltaSuccesses\", type = DataSourceType.COUNTER)\n+    public long getRemoteFetchSuccesses() {\n+        return deltaSuccesses;\n+    }\n+\n+    @com.netflix.servo.annotations.Monitor(name = METRIC_REGISTRY_PREFIX + \"remoteDeltaMismatches\", type = DataSourceType.COUNTER)\n+    public long getRemoteFetchMismatches() {\n+        return deltaMismatches;\n+    }\n }",
      "parent_sha": "00e827eb3d082ce75e24ac5c7cdd9bef423be7ff"
    }
  },
  {
    "oid": "9218147dbc849e7b5e3003382e91196a16cafb81",
    "message": "Fix naming in InstanceRegistry to be CheckStyles compliant",
    "date": "2014-04-29T12:49:19Z",
    "url": "https://github.com/Netflix/eureka/commit/9218147dbc849e7b5e3003382e91196a16cafb81",
    "details": {
      "sha": "337a804980266e833111f88e560bd1cab2a14513",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java",
      "status": "modified",
      "additions": 42,
      "deletions": 58,
      "changes": 100,
      "blob_url": "https://github.com/Netflix/eureka/blob/9218147dbc849e7b5e3003382e91196a16cafb81/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FInstanceRegistry.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/9218147dbc849e7b5e3003382e91196a16cafb81/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FInstanceRegistry.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FInstanceRegistry.java?ref=9218147dbc849e7b5e3003382e91196a16cafb81",
      "patch": "@@ -87,10 +87,10 @@ public abstract class InstanceRegistry implements LeaseManager<InstanceInfo>,\n \n     private static final Logger logger = LoggerFactory\n             .getLogger(InstanceRegistry.class);\n-    private static final EurekaServerConfig eurekaConfig = EurekaServerConfigurationManager\n+    private static final EurekaServerConfig EUREKA_CONFIG = EurekaServerConfigurationManager\n             .getInstance().getConfiguration();\n     private static final String[] EMPTY_STR_ARRAY = new String[0];\n-    private final ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>> _registry = new ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>>();\n+    private final ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>> registry = new ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>>();\n     private Timer evictionTimer = new Timer(\"Eureka-EvictionTimer\", true);\n     private volatile MeasuredRate renewsLastMin;\n     protected ConcurrentMap<String, InstanceStatus> overriddenInstanceStatusMap = CacheBuilder\n@@ -115,7 +115,7 @@ public abstract class InstanceRegistry implements LeaseManager<InstanceInfo>,\n     protected static final EurekaServerConfig EUREKA_SERVER_CONFIG = EurekaServerConfigurationManager\n             .getInstance().getConfiguration();\n \n-    private static final AtomicReference<EvictionTask> evictionTask = new AtomicReference<EvictionTask>();\n+    private static final AtomicReference<EvictionTask> EVICTION_TASK = new AtomicReference<EvictionTask>();\n \n \n     /**\n@@ -125,8 +125,8 @@ protected InstanceRegistry() {\n         recentCanceledQueue = new CircularQueue<Pair<Long, String>>(1000);\n         recentRegisteredQueue = new CircularQueue<Pair<Long, String>>(1000);\n         deltaRetentionTimer.schedule(getDeltaRetentionTask(),\n-                eurekaConfig.getDeltaRetentionTimerIntervalInMs(),\n-                eurekaConfig.getDeltaRetentionTimerIntervalInMs());\n+                EUREKA_CONFIG.getDeltaRetentionTimerIntervalInMs(),\n+                EUREKA_CONFIG.getDeltaRetentionTimerIntervalInMs());\n     }\n \n     /**\n@@ -137,7 +137,7 @@ public void clearRegistry() {\n         recentCanceledQueue.clear();\n         recentRegisteredQueue.clear();\n         recentlyChangedQueue.clear();\n-        _registry.clear();\n+        registry.clear();\n \n     }\n \n@@ -150,12 +150,12 @@ public void clearRegistry() {\n     public void register(InstanceInfo r, int leaseDuration, boolean isReplication) {\n         try {\n             read.lock();\n-            Map<String, Lease<InstanceInfo>> gMap = _registry.get(r\n+            Map<String, Lease<InstanceInfo>> gMap = registry.get(r\n                     .getAppName());\n             REGISTER.increment(isReplication);\n             if (gMap == null) {\n                 final ConcurrentHashMap<String, Lease<InstanceInfo>> gNewMap = new ConcurrentHashMap<String, Lease<InstanceInfo>>();\n-                gMap = _registry.putIfAbsent(r.getAppName(), gNewMap);\n+                gMap = registry.putIfAbsent(r.getAppName(), gNewMap);\n                 if (gMap == null) {\n                     gMap = gNewMap;\n                 }\n@@ -266,15 +266,13 @@ public boolean cancel(String appName, String id, boolean isReplication) {\n         try {\n             read.lock();\n             CANCEL.increment(isReplication);\n-            Map<String, Lease<InstanceInfo>> gMap = _registry.get(appName);\n+            Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);\n             Lease<InstanceInfo> leaseToCancel = null;\n             if (gMap != null) {\n                 leaseToCancel = gMap.remove(id);\n             }\n             synchronized (recentCanceledQueue) {\n-                recentCanceledQueue.add(new Pair<Long, String>(Long\n-                        .valueOf(System.currentTimeMillis()), appName + \"(\"\n-                                                              + id + \")\"));\n+                recentCanceledQueue.add(new Pair<Long, String>(System.currentTimeMillis(), appName + \"(\" + id + \")\"));\n             }\n             InstanceStatus instanceStatus = overriddenInstanceStatusMap\n                     .remove(id);\n@@ -320,7 +318,7 @@ public boolean cancel(String appName, String id, boolean isReplication) {\n      */\n     public boolean renew(String appName, String id, boolean isReplication) {\n         RENEW.increment(isReplication);\n-        Map<String, Lease<InstanceInfo>> gMap = _registry.get(appName);\n+        Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);\n         Lease<InstanceInfo> leaseToRenew = null;\n         if (gMap != null) {\n             leaseToRenew = gMap.get(id);\n@@ -411,7 +409,7 @@ public boolean statusUpdate(String appName, String id,\n         try {\n             read.lock();\n             STATUS_UPDATE.increment(isReplication);\n-            Map<String, Lease<InstanceInfo>> gMap = _registry.get(appName);\n+            Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);\n             Lease<InstanceInfo> lease = null;\n             if (gMap != null) {\n                 lease = gMap.get(id);\n@@ -466,30 +464,22 @@ public boolean statusUpdate(String appName, String id,\n      * @see com.netflix.eureka.lease.LeaseManager#evict()\n      */\n     public void evict() {\n-\n         if (!isLeaseExpirationEnabled()) {\n             logger.debug(\"DS: lease expiration is currently disabled.\");\n             return;\n         }\n         logger.debug(\"Running the evict task\");\n-        for (Iterator<Entry<String, Map<String, Lease<InstanceInfo>>>> iter = _registry\n-                .entrySet().iterator(); iter.hasNext();) {\n-            Entry<String, Map<String, Lease<InstanceInfo>>> groupEntry = iter\n-                    .next();\n-\n+        for (Entry<String, Map<String, Lease<InstanceInfo>>> groupEntry : registry.entrySet()) {\n             Map<String, Lease<InstanceInfo>> leaseMap = groupEntry.getValue();\n             if (leaseMap != null) {\n-                for (Iterator<Entry<String, Lease<InstanceInfo>>> subIter = leaseMap\n-                        .entrySet().iterator(); subIter.hasNext();) {\n-                    Entry<String, Lease<InstanceInfo>> leaseEntry = subIter\n-                            .next();\n+                for (Entry<String, Lease<InstanceInfo>> leaseEntry : leaseMap.entrySet()) {\n                     Lease<InstanceInfo> lease = leaseEntry.getValue();\n                     if (lease.isExpired() && lease.getHolder() != null) {\n                         String appName = lease.getHolder().getAppName();\n                         String id = lease.getHolder().getId();\n                         EXPIRED.increment();\n                         logger.warn(\"DS: Registry: expired lease for \"\n-                                    + appName + \" - \" + id);\n+                                + appName + \" - \" + id);\n                         cancel(appName, id, false);\n                     }\n                 }\n@@ -509,7 +499,7 @@ public void evict() {\n      * com.netflix.discovery.shared.LookupService#getApplication(java.lang.String )\n      */\n     public Application getApplication(String appName) {\n-        boolean disableTransparentFallback = eurekaConfig.disableTransparentFallbackToOtherRegion();\n+        boolean disableTransparentFallback = EUREKA_CONFIG.disableTransparentFallbackToOtherRegion();\n         return this.getApplication(appName, !disableTransparentFallback);\n     }\n \n@@ -528,7 +518,7 @@ public Application getApplication(String appName) {\n     public Application getApplication(String appName, boolean includeRemoteRegion) {\n         Application app = null;\n \n-        Map<String, Lease<InstanceInfo>> leaseMap = _registry.get(appName);\n+        Map<String, Lease<InstanceInfo>> leaseMap = registry.get(appName);\n \n         if (leaseMap != null && leaseMap.size() > 0) {\n             for (Iterator<Entry<String, Lease<InstanceInfo>>> iter = leaseMap\n@@ -559,7 +549,7 @@ public Application getApplication(String appName, boolean includeRemoteRegion) {\n      * @see com.netflix.discovery.shared.LookupService#getApplications()\n      */\n     public Applications getApplications() {\n-        boolean disableTransparentFallback = eurekaConfig.disableTransparentFallbackToOtherRegion();\n+        boolean disableTransparentFallback = EUREKA_CONFIG.disableTransparentFallbackToOtherRegion();\n         if (disableTransparentFallback) {\n             return getApplicationsFromLocalRegionOnly();\n         } else {\n@@ -614,7 +604,7 @@ public Applications getApplicationsFromMultipleRegions(String[] remoteRegions) {\n         }\n         Applications apps = new Applications();\n         apps.setVersion(1L);\n-        for (Entry<String, Map<String, Lease<InstanceInfo>>> entry : _registry.entrySet()) {\n+        for (Entry<String, Map<String, Lease<InstanceInfo>>> entry : registry.entrySet()) {\n             Application app = null;\n \n             if (entry.getValue() != null) {\n@@ -661,9 +651,9 @@ public Applications getApplicationsFromMultipleRegions(String[] remoteRegions) {\n     }\n \n     private boolean shouldFetchFromRemoteRegistry(String appName, String remoteRegion) {\n-        Set<String> whiteList = eurekaConfig.getRemoteRegionAppWhitelist(remoteRegion);\n+        Set<String> whiteList = EUREKA_CONFIG.getRemoteRegionAppWhitelist(remoteRegion);\n         if (null == whiteList) {\n-            whiteList = eurekaConfig.getRemoteRegionAppWhitelist(null); // see global whitelist.\n+            whiteList = EUREKA_CONFIG.getRemoteRegionAppWhitelist(null); // see global whitelist.\n         }\n         return null == whiteList || whiteList.contains(appName);\n     }\n@@ -686,17 +676,13 @@ public Applications getApplications(boolean includeRemoteRegion) {\n         GET_ALL_CACHE_MISS.increment();\n         Applications apps = new Applications();\n         apps.setVersion(1L);\n-        for (Iterator<Entry<String, Map<String, Lease<InstanceInfo>>>> iter = _registry\n-                .entrySet().iterator(); iter.hasNext();) {\n-            Entry<String, Map<String, Lease<InstanceInfo>>> entry = iter.next();\n-\n+        for (Entry<String, Map<String, Lease<InstanceInfo>>> entry : registry.entrySet()) {\n             Application app = null;\n \n             if (entry.getValue() != null) {\n-                for (Iterator<Entry<String, Lease<InstanceInfo>>> subIter = entry\n-                        .getValue().entrySet().iterator(); subIter.hasNext();) {\n+                for (Entry<String, Lease<InstanceInfo>> stringLeaseEntry : entry.getValue().entrySet()) {\n \n-                    Lease<InstanceInfo> lease = subIter.next().getValue();\n+                    Lease<InstanceInfo> lease = stringLeaseEntry.getValue();\n \n                     if (app == null) {\n                         app = new Application(lease.getHolder().getAppName());\n@@ -768,7 +754,7 @@ public Applications getApplicationDeltas() {\n                 app.addInstance(decorateInstanceInfo(lease));\n             }\n \n-            boolean disableTransparentFallback = eurekaConfig.disableTransparentFallbackToOtherRegion();\n+            boolean disableTransparentFallback = EUREKA_CONFIG.disableTransparentFallbackToOtherRegion();\n \n             if (!disableTransparentFallback) {\n                 Applications allAppsInLocalRegion = getApplications(false);\n@@ -911,7 +897,7 @@ public InstanceInfo getInstanceByAppAndId(String appName, String id) {\n      */\n     public InstanceInfo getInstanceByAppAndId(String appName, String id,\n                                               boolean includeRemoteRegions) {\n-        Map<String, Lease<InstanceInfo>> leaseMap = _registry.get(appName);\n+        Map<String, Lease<InstanceInfo>> leaseMap = registry.get(appName);\n         Lease<InstanceInfo> lease = null;\n         if (leaseMap != null) {\n             lease = leaseMap.get(id);\n@@ -953,7 +939,7 @@ public List<InstanceInfo> getInstancesById(String id,\n                                                boolean includeRemoteRegions) {\n         List<InstanceInfo> list = new ArrayList<InstanceInfo>();\n \n-        for (Iterator<Entry<String, Map<String, Lease<InstanceInfo>>>> iter = _registry\n+        for (Iterator<Entry<String, Map<String, Lease<InstanceInfo>>>> iter = registry\n                 .entrySet().iterator(); iter.hasNext();) {\n \n             Map<String, Lease<InstanceInfo>> leaseMap = iter.next().getValue();\n@@ -1096,13 +1082,13 @@ public Lease<InstanceInfo> getLeaseInfo() {\n \n     protected void postInit() {\n         renewsLastMin = new MeasuredRate(1000 * 60 * 1);\n-        if (evictionTask.get() != null) {\n-            evictionTask.get().cancel();\n+        if (EVICTION_TASK.get() != null) {\n+            EVICTION_TASK.get().cancel();\n         }\n-        evictionTask.set(new EvictionTask());\n-        evictionTimer.schedule(evictionTask.get(),\n-                eurekaConfig.getEvictionIntervalTimerInMs(),\n-                eurekaConfig.getEvictionIntervalTimerInMs());\n+        EVICTION_TASK.set(new EvictionTask());\n+        evictionTimer.schedule(EVICTION_TASK.get(),\n+                EUREKA_CONFIG.getEvictionIntervalTimerInMs(),\n+                EUREKA_CONFIG.getEvictionIntervalTimerInMs());\n     }\n \n     @com.netflix.servo.annotations.Monitor(name = \"numOfElementsinInstanceCache\", description = \"Number of elements in the instance Cache\", type = DataSourceType.GAUGE)\n@@ -1133,19 +1119,19 @@ public CircularQueue(int size) {\n \n         @Override\n         public boolean add(E e) {\n-            this.makeSpaceIfnotAvailable();\n+            this.makeSpaceIfNotAvailable();\n             return super.add(e);\n \n         }\n \n-        private void makeSpaceIfnotAvailable() {\n+        private void makeSpaceIfNotAvailable() {\n             if (this.size() == size) {\n                 this.remove();\n             }\n         }\n \n         public boolean offer(E e) {\n-            this.makeSpaceIfnotAvailable();\n+            this.makeSpaceIfNotAvailable();\n             return super.offer(e);\n         }\n     }\n@@ -1203,8 +1189,8 @@ private InstanceStatus getOverriddenInstanceStatus(InstanceInfo r,\n             // Allow server to have its way when the status is UP or\n             // OUT_OF_SERVICE\n             if ((existingStatus != null)\n-                && (InstanceStatus.OUT_OF_SERVICE.equals(existingStatus) || InstanceStatus.UP\n-                                                                                          .equals(existingStatus))) {\n+                && (InstanceStatus.OUT_OF_SERVICE.equals(existingStatus)\n+                    || InstanceStatus.UP.equals(existingStatus))) {\n                 logger.debug(\n                         \"There is already an existing lease with status {}  for instance {}\",\n                         existingLease.getHolder().getStatus().name(),\n@@ -1223,12 +1209,10 @@ private TimerTask getDeltaRetentionTask() {\n \n             @Override\n             public void run() {\n-                Iterator<RecentlyChangedItem> it = recentlyChangedQueue\n-                        .iterator();\n+                Iterator<RecentlyChangedItem> it = recentlyChangedQueue.iterator();\n                 while (it.hasNext()) {\n-                    if (it.next().getLastUpdateTime() < System\n-                                                                .currentTimeMillis()\n-                                                        - eurekaConfig.getRetentionTimeInMSInDeltaQueue()) {\n+                    if (it.next().getLastUpdateTime() <\n+                            System.currentTimeMillis() - EUREKA_CONFIG.getRetentionTimeInMSInDeltaQueue()) {\n                         it.remove();\n                     } else {\n                         break;\n@@ -1240,7 +1224,7 @@ public void run() {\n     }\n \n     protected void initRemoteRegionRegistry() throws MalformedURLException {\n-        Map<String, String> remoteRegionUrlsWithName = eurekaConfig.getRemoteRegionUrlsWithName();\n+        Map<String, String> remoteRegionUrlsWithName = EUREKA_CONFIG.getRemoteRegionUrlsWithName();\n         if (remoteRegionUrlsWithName != null) {\n             allKnownRemoteRegions = new String[remoteRegionUrlsWithName.size()];\n             int remoteRegionArrayIndex = 0;",
      "parent_sha": "abc327a3df654371ac72319f8dc6e0003d91c1a7"
    }
  },
  {
    "oid": "c99698da2a38f218e183488a72a4f5d28c19ea46",
    "message": "EurekaNameSpace not used in eureka.region",
    "date": "2015-09-02T09:40:44Z",
    "url": "https://github.com/Netflix/eureka/commit/c99698da2a38f218e183488a72a4f5d28c19ea46",
    "details": {
      "sha": "d3b4cd11ff248830a3423834a3010218aa2b48a7",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/eureka/blob/c99698da2a38f218e183488a72a4f5d28c19ea46/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDefaultEurekaClientConfig.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/c99698da2a38f218e183488a72a4f5d28c19ea46/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDefaultEurekaClientConfig.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDefaultEurekaClientConfig.java?ref=c99698da2a38f218e183488a72a4f5d28c19ea46",
      "patch": "@@ -359,7 +359,7 @@ public String fetchRegistryForRemoteRegions() {\n      */\n     @Override\n     public String getRegion() {\n-        return configInstance.getStringProperty(\"eureka.region\", \"us-east-1\")\n+        return configInstance.getStringProperty(namespace + \"region\", \"us-east-1\")\n                 .get();\n     }\n ",
      "parent_sha": "329d104ceab914d186a54f3a8e61c23246cc5f2a"
    }
  },
  {
    "oid": "3115ee45145e8469889740263a030996110a037b",
    "message": "Simplify code",
    "date": "2018-11-14T18:30:35Z",
    "url": "https://github.com/Netflix/eureka/commit/3115ee45145e8469889740263a030996110a037b",
    "details": {
      "sha": "b3add5984517ab08b5a603d0438a61041feb7e52",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java",
      "status": "modified",
      "additions": 8,
      "deletions": 10,
      "changes": 18,
      "blob_url": "https://github.com/Netflix/eureka/blob/3115ee45145e8469889740263a030996110a037b/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/3115ee45145e8469889740263a030996110a037b/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java?ref=3115ee45145e8469889740263a030996110a037b",
      "patch": "@@ -1677,11 +1677,10 @@ public long getLastSuccessfulRegistryFetchTimePeriod() {\n     @com.netflix.servo.annotations.Monitor(name = METRIC_REGISTRATION_PREFIX + \"lastSuccessfulHeartbeatTimePeriod\",\n             description = \"How much time has passed from last successful heartbeat\", type = DataSourceType.GAUGE)\n     private long getLastSuccessfulHeartbeatTimePeriodInternal() {\n-        if (!clientConfig.shouldRegisterWithEureka() || isShutdown.get()) {\n-            heartbeatStalenessMonitor.update(0);\n-            return 0;\n-        }\n-        long delay = getLastSuccessfulHeartbeatTimePeriod();\n+        final long delay = (!clientConfig.shouldRegisterWithEureka() || isShutdown.get())\n+            ? 0\n+            : getLastSuccessfulHeartbeatTimePeriod();\n+\n         heartbeatStalenessMonitor.update(computeStalenessMonitorDelay(delay));\n         return delay;\n     }\n@@ -1690,11 +1689,10 @@ private long getLastSuccessfulHeartbeatTimePeriodInternal() {\n     @com.netflix.servo.annotations.Monitor(name = METRIC_REGISTRY_PREFIX + \"lastSuccessfulRegistryFetchTimePeriod\",\n             description = \"How much time has passed from last successful local registry update\", type = DataSourceType.GAUGE)\n     private long getLastSuccessfulRegistryFetchTimePeriodInternal() {\n-        if (!clientConfig.shouldFetchRegistry() || isShutdown.get()) {\n-            registryStalenessMonitor.update(0);\n-            return 0;\n-        }\n-        long delay = getLastSuccessfulRegistryFetchTimePeriod();\n+        final long delay = (!clientConfig.shouldFetchRegistry() || isShutdown.get())\n+            ? 0\n+            : getLastSuccessfulRegistryFetchTimePeriod();\n+\n         registryStalenessMonitor.update(computeStalenessMonitorDelay(delay));\n         return delay;\n     }",
      "parent_sha": "5ecbbf21f13f2d456fb486b320c9030c2eed0ee2"
    }
  },
  {
    "oid": "23927052febf3a3a3277f8be30a5a897e6524807",
    "message": "sanitize metadata map for empty values",
    "date": "2019-01-11T00:13:33Z",
    "url": "https://github.com/Netflix/eureka/commit/23927052febf3a3a3277f8be30a5a897e6524807",
    "details": {
      "sha": "b017f2942043c1cdd739a035676da5c06a43a67c",
      "filename": "eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/Netflix/eureka/blob/23927052febf3a3a3277f8be30a5a897e6524807/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2Fproviders%2FEurekaConfigBasedInstanceInfoProvider.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/23927052febf3a3a3277f8be30a5a897e6524807/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2Fproviders%2FEurekaConfigBasedInstanceInfoProvider.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2Fproviders%2FEurekaConfigBasedInstanceInfoProvider.java?ref=23927052febf3a3a3277f8be30a5a897e6524807",
      "patch": "@@ -116,7 +116,10 @@ public synchronized InstanceInfo get() {\n             for (Map.Entry<String, String> mapEntry : config.getMetadataMap().entrySet()) {\n                 String key = mapEntry.getKey();\n                 String value = mapEntry.getValue();\n-                builder.add(key, value);\n+                // only add the metadata if the value is present\n+                if (value != null && !value.isEmpty()) {\n+                    builder.add(key, value);\n+    \t\t\t}\n             }\n \n             instanceInfo = builder.build();",
      "parent_sha": "1b60b4979c6d5522cdd211bde58de00f82c5bd80"
    }
  },
  {
    "oid": "37d2a3d03cd19a8886c089f8a6b719bf226d34c3",
    "message": "Minor refactors and bug fixes.",
    "date": "2013-11-19T18:46:01Z",
    "url": "https://github.com/Netflix/eureka/commit/37d2a3d03cd19a8886c089f8a6b719bf226d34c3",
    "details": {
      "sha": "9db9a277570578da2ea5b60f6fa94bed426bc6e2",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java",
      "status": "modified",
      "additions": 9,
      "deletions": 7,
      "changes": 16,
      "blob_url": "https://github.com/Netflix/eureka/blob/37d2a3d03cd19a8886c089f8a6b719bf226d34c3/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fcluster%2FPeerEurekaNode.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/37d2a3d03cd19a8886c089f8a6b719bf226d34c3/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fcluster%2FPeerEurekaNode.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fcluster%2FPeerEurekaNode.java?ref=37d2a3d03cd19a8886c089f8a6b719bf226d34c3",
      "patch": "@@ -877,7 +877,7 @@ private boolean executeBatch(List<ReplicationTask> tasks) {\n                         .accept(MediaType.APPLICATION_JSON_TYPE)\n                         .type(MediaType.APPLICATION_JSON_TYPE)\n                         .post(ClientResponse.class, list);\n-                        if (!isSuccess(response)) {\n+                        if (!isSuccess(response.getStatus())) {\n                             return false;\n                         }\n                         DynamicCounter.increment(\"Batch_\"\n@@ -892,7 +892,7 @@ private boolean executeBatch(List<ReplicationTask> tasks) {\n                                 .getResponseList()) {\n                             int statusCode = singleResponse\n                             .getStatusCode();\n-                            if ((!isSuccess(response))\n+                            if ((!isSuccess(statusCode))\n                                     || (singleResponse\n                                     .getResponseEntity() != null)) {\n                                 if (singleResponse.getResponseEntity() != null) {\n@@ -931,10 +931,6 @@ private boolean executeBatch(List<ReplicationTask> tasks) {\n                 return success;\n             }\n \n-            private boolean isSuccess(ClientResponse response) {\n-                return response.getStatus() < 200\n-                        || response.getStatus() >= 300;\n-            }\n \n             private void executeSingle(List<ReplicationTask> tasks) {\n                 for (ReplicationTask task : tasks) {\n@@ -964,7 +960,7 @@ private void executeSingle(List<ReplicationTask> tasks) {\n                                     + \"_tries\");\n \n                             int statusCode = task.execute();\n-                            if (statusCode < 200 && statusCode > 299) {\n+                            if (!isSuccess(statusCode)) {\n                                 task.handleFailure(statusCode);\n                             }\n                             DynamicCounter.increment(\"Single_\"\n@@ -998,5 +994,11 @@ private void executeSingle(List<ReplicationTask> tasks) {\n             }\n         });\n     }\n+    \n+\n+    private boolean isSuccess(int statusCode) {\n+        return statusCode >= 200\n+                &&  statusCode < 300;\n+    }\n \n }",
      "parent_sha": "48a79b71064d03d5ca151167cbc1333ffd04c04c"
    }
  },
  {
    "oid": "e17d488c284aa6a32c296d4ae2b512952f352410",
    "message": "Reuse sts authentication tokens",
    "date": "2015-05-29T11:59:24Z",
    "url": "https://github.com/Netflix/eureka/commit/e17d488c284aa6a32c296d4ae2b512952f352410",
    "details": {
      "sha": "ebf7ea67be665ec439f8fa809394d7e702101ab7",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java",
      "status": "modified",
      "additions": 29,
      "deletions": 15,
      "changes": 44,
      "blob_url": "https://github.com/Netflix/eureka/blob/e17d488c284aa6a32c296d4ae2b512952f352410/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2FAwsAsgUtil.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/e17d488c284aa6a32c296d4ae2b512952f352410/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2FAwsAsgUtil.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2FAwsAsgUtil.java?ref=e17d488c284aa6a32c296d4ae2b512952f352410",
      "patch": "@@ -16,19 +16,15 @@\n \n package com.netflix.eureka.util;\n \n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.*;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.TimeUnit;\n \n import com.amazonaws.auth.AWSCredentials;\n import com.amazonaws.services.securitytoken.AWSSecurityTokenService;\n import com.amazonaws.services.securitytoken.AWSSecurityTokenServiceClient;\n import com.amazonaws.services.securitytoken.model.AssumeRoleResult;\n+import com.amazonaws.services.securitytoken.model.Credentials;\n import com.google.common.base.Strings;\n import com.netflix.appinfo.AmazonInfo;\n import com.netflix.appinfo.AmazonInfo.MetaDataKey;\n@@ -75,6 +71,9 @@ public class AwsAsgUtil {\n     private static final EurekaServerConfig eurekaConfig = EurekaServerConfigurationManager\n             .getInstance().getConfiguration();\n     private static final AmazonAutoScaling client = getAmazonAutoScalingClient();\n+\n+    private Map<String, Credentials> stsCredentials = new HashMap<String, Credentials>();\n+\n     private static final String accountId = getAccountId();\n     // Cache for the AWS ASG information\n     private final LoadingCache<String, Boolean> asgCache = CacheBuilder\n@@ -212,10 +211,8 @@ private AutoScalingGroup retrieveAutoScalingGroup(String asgName) {\n         }\n     }\n \n-    private AutoScalingGroup retrieveAutoScalingGroupCrossAccount(String asgAccount, String asgName) {\n-        logger.debug(\"Getting cross account ASG for asgName: \" + asgName + \", asgAccount: \" + asgAccount);\n-\n-        final AWSSecurityTokenService sts = new AWSSecurityTokenServiceClient(new InstanceProfileCredentialsProvider());\n+    private Credentials initializeStsSession(String asgAccount) {\n+        AWSSecurityTokenService sts = new AWSSecurityTokenServiceClient(new InstanceProfileCredentialsProvider());\n         String region = DiscoveryManager.getInstance().getEurekaClientConfig()\n                 .getRegion();\n         if (!region.equals(\"us-east-1\")) {\n@@ -224,23 +221,40 @@ private AutoScalingGroup retrieveAutoScalingGroupCrossAccount(String asgAccount,\n \n         String roleArn = \"arn:aws:iam::\" + asgAccount + \":role/ListAutoScalingGroups\";\n \n-        final AssumeRoleResult assumeRoleResult = sts.assumeRole(new AssumeRoleRequest()\n+        AssumeRoleResult assumeRoleResult = sts.assumeRole(new AssumeRoleRequest()\n                         .withRoleArn(roleArn)\n-                        .withRoleSessionName(\"session-name-here\")\n+                        .withRoleSessionName(\"sts-session-\" + asgAccount)\n         );\n \n+        return assumeRoleResult.getCredentials();\n+    }\n+\n+    private AutoScalingGroup retrieveAutoScalingGroupCrossAccount(String asgAccount, String asgName) {\n+        logger.debug(\"Getting cross account ASG for asgName: \" + asgName + \", asgAccount: \" + asgAccount);\n+\n+        Credentials credentials = stsCredentials.get(asgAccount);\n+\n+        if (credentials == null || credentials.getExpiration().getTime() < System.currentTimeMillis() + 1000) {\n+            stsCredentials.put(asgAccount, initializeStsSession(asgAccount));\n+        }\n+\n         ClientConfiguration clientConfiguration = new ClientConfiguration()\n                 .withConnectionTimeout(eurekaConfig.getASGQueryTimeoutMs());\n \n         AmazonAutoScaling autoScalingClient = new AmazonAutoScalingClient(\n                 new BasicSessionCredentials(\n-                        assumeRoleResult.getCredentials().getAccessKeyId(),\n-                        assumeRoleResult.getCredentials().getSecretAccessKey(),\n-                        assumeRoleResult.getCredentials().getSessionToken()\n+                        credentials.getAccessKeyId(),\n+                        credentials.getSecretAccessKey(),\n+                        credentials.getSessionToken()\n                 ),\n                 clientConfiguration\n         );\n \n+        String region = DiscoveryManager.getInstance().getEurekaClientConfig().getRegion();\n+        if (!region.equals(\"us-east-1\")) {\n+            autoScalingClient.setEndpoint(\"autoscaling.\" + region + \".amazonaws.com\");\n+        }\n+\n         DescribeAutoScalingGroupsRequest request = new DescribeAutoScalingGroupsRequest()\n                 .withAutoScalingGroupNames(asgName);\n         DescribeAutoScalingGroupsResult result = autoScalingClient",
      "parent_sha": "c377616f4d90793bf0ec08aa815edeb66ead6b25"
    }
  },
  {
    "oid": "463aa48a9449910e231fc1357efadb7f77dd3670",
    "message": "Make the renewal last update timestamp volatile so that the expiration task does not have a race condition.",
    "date": "2012-09-20T22:59:36Z",
    "url": "https://github.com/Netflix/eureka/commit/463aa48a9449910e231fc1357efadb7f77dd3670",
    "details": {
      "sha": "114e2b47bf5d260851a59969ee6ef53571820e8c",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/lease/Lease.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/Netflix/eureka/blob/463aa48a9449910e231fc1357efadb7f77dd3670/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Flease%2FLease.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/463aa48a9449910e231fc1357efadb7f77dd3670/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Flease%2FLease.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Flease%2FLease.java?ref=463aa48a9449910e231fc1357efadb7f77dd3670",
      "patch": "@@ -42,7 +42,8 @@ enum Action {\n     private T holder;\n     private long evictionTimestamp;\n     private long registrationTimestamp;\n-    private long lastUpdateTimestamp;\n+    // Make it volatile so that the expiration task would see this quicker\n+    private volatile long lastUpdateTimestamp;\n     private long duration;\n \n     public Lease(T r, int durationInSecs) {",
      "parent_sha": "efbc4d738e278ea3fec6632e2135e6ec7e4d5000"
    }
  },
  {
    "oid": "f184cf457c525cef818692f4086ff98f9b78c4a0",
    "message": "Make DiscoveryClient constructor public so it can be created by a provider",
    "date": "2014-04-25T20:43:57Z",
    "url": "https://github.com/Netflix/eureka/commit/f184cf457c525cef818692f4086ff98f9b78c4a0",
    "details": {
      "sha": "d86d3efd2e31895fe0f08db98e4355cb9a106e1f",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/eureka/blob/f184cf457c525cef818692f4086ff98f9b78c4a0/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/f184cf457c525cef818692f4086ff98f9b78c4a0/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java?ref=f184cf457c525cef818692f4086ff98f9b78c4a0",
      "patch": "@@ -161,7 +161,7 @@ private enum Action {\n     @Inject(optional=true)\n     private EventBus eventBus;\n     \n-    DiscoveryClient(InstanceInfo myInfo, EurekaClientConfig config, EventBus eventBus) {\n+    public DiscoveryClient(InstanceInfo myInfo, EurekaClientConfig config, EventBus eventBus) {\n         this(myInfo, config);\n         this.eventBus = eventBus;\n     }",
      "parent_sha": "6b8030f22a505360fc1ea1bc2dee963b29fb486d"
    }
  },
  {
    "oid": "130d093a92921eeb66dd308bee849fcee1f119fd",
    "message": "update the comment\n\nupdate the comment of  getRegisteredApplications(String appName)",
    "date": "2019-01-13T15:42:20Z",
    "url": "https://github.com/Netflix/eureka/commit/130d093a92921eeb66dd308bee849fcee1f119fd",
    "details": {
      "sha": "06380d2f107f9a18b57d547f2b9b9984980da141",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/eureka/blob/130d093a92921eeb66dd308bee849fcee1f119fd/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2FApplications.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/130d093a92921eeb66dd308bee849fcee1f119fd/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2FApplications.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2FApplications.java?ref=130d093a92921eeb66dd308bee849fcee1f119fd",
      "patch": "@@ -138,12 +138,12 @@ public List<Application> getRegisteredApplications() {\n     }\n \n     /**\n-     * Gets the list of all registered <em>applications</em> for the given\n+     * Gets the registered <em>application</em> for the given\n      * application name.\n      *\n      * @param appName\n      *            the application name for which the result need to be fetched.\n-     * @return the list of registered applications for the given application\n+     * @return the registered application for the given application\n      *         name.\n      */\n     public Application getRegisteredApplications(String appName) {",
      "parent_sha": "48446d956be09df6650a3c00b7ebd7e2d1e1544f"
    }
  },
  {
    "oid": "67568f7d1096c049ff72d73249633323c54e0368",
    "message": "EurekaNameSpace not used in eureka.region",
    "date": "2015-09-12T17:20:36Z",
    "url": "https://github.com/Netflix/eureka/commit/67568f7d1096c049ff72d73249633323c54e0368",
    "details": {
      "sha": "372dcb2f6cbce57006bd8605cf871d7bf46e70b3",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/eureka/blob/67568f7d1096c049ff72d73249633323c54e0368/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDefaultEurekaClientConfig.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/67568f7d1096c049ff72d73249633323c54e0368/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDefaultEurekaClientConfig.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDefaultEurekaClientConfig.java?ref=67568f7d1096c049ff72d73249633323c54e0368",
      "patch": "@@ -359,8 +359,8 @@ public String fetchRegistryForRemoteRegions() {\n      */\n     @Override\n     public String getRegion() {\n-        return configInstance.getStringProperty(namespace + \"region\", \"us-east-1\")\n-                .get();\n+        DynamicStringProperty defaultEurekaRegion = configInstance.getStringProperty(\"eureka.region\", \"us-east-1\");\n+        return configInstance.getStringProperty(namespace + \"region\", defaultEurekaRegion.get()).get();\n     }\n \n     /*",
      "parent_sha": "c99698da2a38f218e183488a72a4f5d28c19ea46"
    }
  },
  {
    "oid": "ad81a1140f351ec19165cb94d5aa668cfc08a932",
    "message": "Utilize parameterized logging\n\nAs suggested in the SLF4J FAQ:\nhttps://www.slf4j.org/faq.html#logging_performance\n.. parameterized logging can improve the efficiency of logger calls when\nlogging at the specified level is disabled.\n\nAccording to the Constant Expressions section of the JLS, enum variants\nare unfortunately not constant, and thus this is actually a string\nconcatenation.\n\nThis change was suggested by SLF4J Helper for NetBeans IDE:\nhttp://plugins.netbeans.org/plugin/72557/",
    "date": "2017-11-06T17:15:58Z",
    "url": "https://github.com/Netflix/eureka/commit/ad81a1140f351ec19165cb94d5aa668cfc08a932",
    "details": {
      "sha": "315da28177d6f26195fdc26a253a528b05c0b692",
      "filename": "eureka-client/src/main/java/com/netflix/appinfo/RefreshableAmazonInfoProvider.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/eureka/blob/ad81a1140f351ec19165cb94d5aa668cfc08a932/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FRefreshableAmazonInfoProvider.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/ad81a1140f351ec19165cb94d5aa668cfc08a932/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FRefreshableAmazonInfoProvider.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FRefreshableAmazonInfoProvider.java?ref=ad81a1140f351ec19165cb94d5aa668cfc08a932",
      "patch": "@@ -45,7 +45,7 @@ private static AmazonInfo init(AmazonInfoConfig amazonInfoConfig, FallbackAddres\n                     .newBuilder()\n                     .withAmazonInfoConfig(amazonInfoConfig)\n                     .autoBuild(amazonInfoConfig.getNamespace());\n-            logger.info(\"Datacenter is: \" + DataCenterInfo.Name.Amazon);\n+            logger.info(\"Datacenter is: {}\", DataCenterInfo.Name.Amazon);\n         } catch (Throwable e) {\n             logger.error(\"Cannot initialize amazon info :\", e);\n             throw new RuntimeException(e);",
      "parent_sha": "d3f490cf809dbde6146586745d6853691eb8c4e1"
    }
  },
  {
    "oid": "ae6381bacfce234b84761be27c70bb21a6acd983",
    "message": "Fixing flakiness of the tests because of improper property cleanup.",
    "date": "2013-07-31T21:19:15Z",
    "url": "https://github.com/Netflix/eureka/commit/ae6381bacfce234b84761be27c70bb21a6acd983",
    "details": {
      "sha": "5903d0ad18d618336b8e8a8054f2ecf78d88b48b",
      "filename": "eureka-core/src/test/java/com/netflix/eureka/InstanceRegistryTest.java",
      "status": "modified",
      "additions": 7,
      "deletions": 4,
      "changes": 11,
      "blob_url": "https://github.com/Netflix/eureka/blob/ae6381bacfce234b84761be27c70bb21a6acd983/eureka-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Feureka%2FInstanceRegistryTest.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/ae6381bacfce234b84761be27c70bb21a6acd983/eureka-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Feureka%2FInstanceRegistryTest.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Feureka%2FInstanceRegistryTest.java?ref=ae6381bacfce234b84761be27c70bb21a6acd983",
      "patch": "@@ -25,6 +25,7 @@\n public class InstanceRegistryTest {\n \n     public static final int REMOTE_REGION_PORT = 7777;\n+    public static final String REMOTE_REGION_NAME = \"myregion\";\n     private final Map<String, Application> remoteRegionApps = new HashMap<String, Application>();\n     private final Map<String, Application> remoteRegionAppsDelta = new HashMap<String, Application>();\n \n@@ -40,15 +41,17 @@ public class InstanceRegistryTest {\n \n     @Before\n     public void setUp() throws Exception {\n-        ConfigurationManager.getConfigInstance().setProperty(\"eureka.deltaRetentionTimerIntervalInMs\",\n-                                                             \"600000\");\n+        ConfigurationManager.getConfigInstance().clearProperty(\"eureka.remoteRegion.global.appWhiteList\");\n+        ConfigurationManager.getConfigInstance().clearProperty(\"eureka.remoteRegion.\" + REMOTE_REGION_NAME + \".appWhiteList\");\n+        ConfigurationManager.getConfigInstance().setProperty(\"eureka.deltaRetentionTimerIntervalInMs\", \"600000\");\n         ConfigurationManager.getConfigInstance().setProperty(\"eureka.remoteRegion.registryFetchIntervalInSeconds\",\n                                                              \"5\");\n         ConfigurationManager.getConfigInstance().setProperty(\"eureka.remoteRegionUrlsWithName\",\n-                                                             \"myregion;http://localhost:\" + REMOTE_REGION_PORT + \"/\" +\n+                                                             REMOTE_REGION_NAME + \";http://localhost:\" + REMOTE_REGION_PORT + \"/\" +\n                                                              MockRemoteEurekaServer.EUREKA_API_BASE_PATH);\n         populateRemoteRegistryAtStartup();\n-        mockRemoteEurekaServer = new MockRemoteEurekaServer(REMOTE_REGION_PORT, remoteRegionApps, remoteRegionAppsDelta);\n+        mockRemoteEurekaServer = new MockRemoteEurekaServer(REMOTE_REGION_PORT, remoteRegionApps,\n+                                                            remoteRegionAppsDelta);\n         mockRemoteEurekaServer.start();\n \n         EurekaServerConfig serverConfig = new DefaultEurekaServerConfig();",
      "parent_sha": "afb9a2458cc118d4b330f39e826ba62531dc6c26"
    }
  },
  {
    "oid": "c23b17931e4ffcc95bf491d9cdee01650eb0ffb3",
    "message": "Fixes for clean connection close in AmazonInfo when reading from the AWS\nmetadata url.",
    "date": "2015-01-15T21:55:58Z",
    "url": "https://github.com/Netflix/eureka/commit/c23b17931e4ffcc95bf491d9cdee01650eb0ffb3",
    "details": {
      "sha": "66adb2894efbbe284035b3901f99fc9e78241463",
      "filename": "eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java",
      "status": "modified",
      "additions": 30,
      "deletions": 7,
      "changes": 37,
      "blob_url": "https://github.com/Netflix/eureka/blob/c23b17931e4ffcc95bf491d9cdee01650eb0ffb3/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FAmazonInfo.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/c23b17931e4ffcc95bf491d9cdee01650eb0ffb3/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FAmazonInfo.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FAmazonInfo.java?ref=c23b17931e4ffcc95bf491d9cdee01650eb0ffb3",
      "patch": "@@ -85,17 +85,20 @@ public URL getURL(String prepend, String append) throws MalformedURLException {\n             protected String read(InputStream inputStream) throws IOException {\n                 BufferedReader br = new BufferedReader(new InputStreamReader(inputStream));\n                 try {\n+                    String toReturn = null;\n                     String inputLine;\n                     while ((inputLine = br.readLine()) != null) {\n                         Matcher matcher = pattern.matcher(inputLine);\n-                        if (matcher.find()) {\n-                            return matcher.group(1);\n+                        if (toReturn == null && matcher.find()) {\n+                            toReturn = matcher.group(1);\n+                            // don't break here as we want to read the full buffer for a clean connection close\n                         }\n                     }\n+\n+                    return toReturn;\n                 } finally {\n                     br.close();\n                 }\n-                return null;\n             }\n         };\n \n@@ -122,8 +125,16 @@ public URL getURL(String prepend, String append) throws MalformedURLException {\n \n         protected String read(InputStream inputStream) throws IOException {\n             BufferedReader br = new BufferedReader(new InputStreamReader(inputStream));\n+            String toReturn;\n             try {\n-                return br.readLine();\n+                String line = br.readLine();\n+                toReturn = line;\n+\n+                while(line != null) {  // need to read all the buffer for a clean connection close\n+                    line = br.readLine();\n+                }\n+\n+                return toReturn;\n             } finally {\n                 br.close();\n             }\n@@ -182,10 +193,22 @@ public AmazonInfo autoBuild(String namespace) {\n                         uc.setConnectTimeout(awsMetaDataConnectTimeout.get());\n                         uc.setReadTimeout(awsMetaDataReadTimeout.get());\n \n-                        String value = key.read(uc.getInputStream());\n-                        if (value != null) {\n-                            result.metadata.put(key.getName(), value);\n+                        if (uc.getResponseCode() != HttpURLConnection.HTTP_OK ) {  // need to read the error for clean connection close\n+                            BufferedReader br = new BufferedReader(new InputStreamReader(uc.getErrorStream()));\n+                            try {\n+                                while(br.readLine() != null) {\n+                                    // do nothing but keep reading the line\n+                                }\n+                            } finally {\n+                                br.close();\n+                            }\n+                        } else {\n+                            String value = key.read(uc.getInputStream());\n+                            if (value != null) {\n+                                result.metadata.put(key.getName(), value);\n+                            }\n                         }\n+\n                         break;\n                     } catch (Throwable e) {\n                         if (shouldLogAWSMetadataError.get()) {",
      "parent_sha": "0d44b9c8b0b978ec7b39c40a02643b65fce69ca2"
    }
  },
  {
    "oid": "6c12040f58977d70df3f870fc499be9fda7d7caf",
    "message": "Use Status replace magic number",
    "date": "2018-07-10T08:21:41Z",
    "url": "https://github.com/Netflix/eureka/commit/6c12040f58977d70df3f870fc499be9fda7d7caf",
    "details": {
      "sha": "10f2bf7b32c0dd4736f715d329c31a4f414570f8",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/Netflix/eureka/blob/6c12040f58977d70df3f870fc499be9fda7d7caf/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/6c12040f58977d70df3f870fc499be9fda7d7caf/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java?ref=6c12040f58977d70df3f870fc499be9fda7d7caf",
      "patch": "@@ -808,7 +808,7 @@ public Applications getApplications(String serviceUrl) {\n             EurekaHttpResponse<Applications> response = clientConfig.getRegistryRefreshSingleVipAddress() == null\n                     ? eurekaTransport.queryClient.getApplications()\n                     : eurekaTransport.queryClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress());\n-            if (response.getStatusCode() == 200) {\n+            if (response.getStatusCode() == Status.OK.getStatusCode()) {\n                 logger.debug(PREFIX + \"{} -  refresh status: {}\", appPathIdentifier, response.getStatusCode());\n                 return response.getEntity();\n             }\n@@ -834,7 +834,7 @@ boolean register() throws Throwable {\n         if (logger.isInfoEnabled()) {\n             logger.info(PREFIX + \"{} - registration status: {}\", appPathIdentifier, httpResponse.getStatusCode());\n         }\n-        return httpResponse.getStatusCode() == 204;\n+        return httpResponse.getStatusCode() == Status.NO_CONTENT.getStatusCode();\n     }\n \n     /**\n@@ -845,7 +845,7 @@ boolean renew() {\n         try {\n             httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, null);\n             logger.debug(PREFIX + \"{} - Heartbeat status: {}\", appPathIdentifier, httpResponse.getStatusCode());\n-            if (httpResponse.getStatusCode() == 404) {\n+            if (httpResponse.getStatusCode() == Status.NOT_FOUND.getStatusCode()) {\n                 REREGISTER_COUNTER.increment();\n                 logger.info(PREFIX + \"{} - Re-registering apps/{}\", appPathIdentifier, instanceInfo.getAppName());\n                 long timestamp = instanceInfo.setIsDirtyWithTime();\n@@ -855,7 +855,7 @@ boolean renew() {\n                 }\n                 return success;\n             }\n-            return httpResponse.getStatusCode() == 200;\n+            return httpResponse.getStatusCode() == Status.OK.getStatusCode();\n         } catch (Throwable e) {\n             logger.error(PREFIX + \"{} - was unable to send heartbeat!\", appPathIdentifier, e);\n             return false;",
      "parent_sha": "ac6bd9b028887176e6622fb008e096857825d9f6"
    }
  },
  {
    "oid": "fde5e6b789e2205d83fe65e7fbe3c44649e0da51",
    "message": "set instance status using applicationInfoManager instead of directly",
    "date": "2016-02-26T23:53:08Z",
    "url": "https://github.com/Netflix/eureka/commit/fde5e6b789e2205d83fe65e7fbe3c44649e0da51",
    "details": {
      "sha": "540187477226daacd5df14cbd0155095e3e039f7",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/Netflix/eureka/blob/fde5e6b789e2205d83fe65e7fbe3c44649e0da51/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/fde5e6b789e2205d83fe65e7fbe3c44649e0da51/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java?ref=fde5e6b789e2205d83fe65e7fbe3c44649e0da51",
      "patch": "@@ -860,8 +860,8 @@ public void shutdown() {\n             cancelScheduledTasks();\n \n             // If APPINFO was registered\n-            if (instanceInfo != null && clientConfig.shouldRegisterWithEureka()) {\n-                instanceInfo.setStatus(InstanceStatus.DOWN);\n+            if (applicationInfoManager != null && clientConfig.shouldRegisterWithEureka()) {\n+                applicationInfoManager.setInstanceStatus(InstanceStatus.DOWN);\n                 unregister();\n             }\n \n@@ -1362,7 +1362,7 @@ void refreshInstanceInfo() {\n         }\n \n         if (null != status) {\n-            instanceInfo.setStatus(status);\n+            applicationInfoManager.setInstanceStatus(status);\n         }\n     }\n ",
      "parent_sha": "4faa3d9a2cf54fd8f83f74ff0e2cc04057d46074"
    }
  },
  {
    "oid": "ca329b540f267f30aedef4f86fc96e49e4000179",
    "message": "Java doc formatting changes.",
    "date": "2012-09-03T21:37:39Z",
    "url": "https://github.com/Netflix/eureka/commit/ca329b540f267f30aedef4f86fc96e49e4000179",
    "details": {
      "sha": "1d17b0ac7f3a07f90227ed48a7cde419ffe9af61",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java",
      "status": "modified",
      "additions": 6,
      "deletions": 9,
      "changes": 15,
      "blob_url": "https://github.com/Netflix/eureka/blob/ca329b540f267f30aedef4f86fc96e49e4000179/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/ca329b540f267f30aedef4f86fc96e49e4000179/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java?ref=ca329b540f267f30aedef4f86fc96e49e4000179",
      "patch": "@@ -65,15 +65,12 @@\n  * The class that is instrumental for interactions with <tt>Eureka Server</tt>.\n  * \n  * <p>\n- * <tt>Eureka Client</tt> is responsible for a) <em>Registering</em> the\n- * instance with <tt>Eureka Server</tt> b) <em>Renewal</em> of the lease with\n- * <tt>Eureka Server</tt> c) <em>Cancellation</em> of the lease from\n- * <tt>Eureka Server</tt> during shutdown\n- * <p>\n- * d) <em>Querying</em> the list of services/instances registered with\n- * <tt>Eureka Server</tt>\n- * <p>\n- * \n+ * <tt>Eureka Client</tt> is responsible for \n+ * a) <em>Registering</em> the instance with <tt>Eureka Server</tt> \n+ * b) <em>Renewal</em> of the lease with  <tt>Eureka Server</tt> \n+ * c) <em>Cancellation</em> of the lease from <tt>Eureka Server</tt> during shutdown\n+ * d) <em>Querying</em> the list of services/instances registered with <tt>Eureka Server</tt>\n+ * </p>\n  * <p>\n  * <tt>Eureka Client</tt> needs a configured list of <tt>Eureka Server</tt>\n  * {@link URL}s to talk to.These {@link URL}s are typically amazon elastic eips",
      "parent_sha": "582edbcf9c7f83f33a02bef3d9896e31d11d8b38"
    }
  },
  {
    "oid": "adbd377529aa59c171a4b3847969d39081f37360",
    "message": "Fix for issue https://github.com/Netflix/eureka/issues/711",
    "date": "2015-11-19T18:34:23Z",
    "url": "https://github.com/Netflix/eureka/commit/adbd377529aa59c171a4b3847969d39081f37360",
    "details": {
      "sha": "46fbb6891ee54f40427218024e8eacec24117aaa",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/cluster/DynamicGZIPContentEncodingFilter.java",
      "status": "modified",
      "additions": 34,
      "deletions": 24,
      "changes": 58,
      "blob_url": "https://github.com/Netflix/eureka/blob/adbd377529aa59c171a4b3847969d39081f37360/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fcluster%2FDynamicGZIPContentEncodingFilter.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/adbd377529aa59c171a4b3847969d39081f37360/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fcluster%2FDynamicGZIPContentEncodingFilter.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fcluster%2FDynamicGZIPContentEncodingFilter.java?ref=adbd377529aa59c171a4b3847969d39081f37360",
      "patch": "@@ -2,6 +2,7 @@\n \n import javax.ws.rs.core.HttpHeaders;\n import java.io.IOException;\n+import java.io.InputStream;\n import java.io.OutputStream;\n import java.util.zip.GZIPInputStream;\n import java.util.zip.GZIPOutputStream;\n@@ -15,61 +16,70 @@\n import com.sun.jersey.api.client.filter.ClientFilter;\n \n /**\n- * This is a modified version of the standard jersey {@link com.sun.jersey.api.client.filter.GZIPContentEncodingFilter},\n- * that supports dynamic configuration of request entity compression.\n+ * Eureka specific GZIP content filter handler.\n  */\n public class DynamicGZIPContentEncodingFilter extends ClientFilter {\n \n+    private static final String GZIP_ENCODING = \"gzip\";\n+\n     private final EurekaServerConfig config;\n \n     public DynamicGZIPContentEncodingFilter(EurekaServerConfig config) {\n         this.config = config;\n     }\n \n     @Override\n-    public ClientResponse handle(ClientRequest request) throws ClientHandlerException {\n+    public ClientResponse handle(ClientRequest request) {\n+        // If 'Accept-Encoding' is not set, assume gzip as a default\n         if (!request.getHeaders().containsKey(HttpHeaders.ACCEPT_ENCODING)) {\n-            request.getHeaders().add(HttpHeaders.ACCEPT_ENCODING, \"gzip\");\n+            request.getHeaders().add(HttpHeaders.ACCEPT_ENCODING, GZIP_ENCODING);\n         }\n \n         if (request.getEntity() != null) {\n-            Object o = request.getHeaders().getFirst(HttpHeaders.CONTENT_ENCODING);\n-            if (o != null && o.equals(\"gzip\")) {\n-                request.setAdapter(new Adapter(request.getAdapter()));\n+            Object requestEncoding = request.getHeaders().getFirst(HttpHeaders.CONTENT_ENCODING);\n+            if (GZIP_ENCODING.equals(requestEncoding)) {\n+                request.setAdapter(new GzipAdapter(request.getAdapter()));\n             } else if (isCompressionEnabled()) {\n-                request.getHeaders().add(HttpHeaders.CONTENT_ENCODING, \"gzip\");\n-                request.setAdapter(new Adapter(request.getAdapter()));\n+                request.getHeaders().add(HttpHeaders.CONTENT_ENCODING, GZIP_ENCODING);\n+                request.setAdapter(new GzipAdapter(request.getAdapter()));\n             }\n         }\n \n         ClientResponse response = getNext().handle(request);\n \n-        if (response.hasEntity() &&\n-                response.getHeaders().containsKey(HttpHeaders.CONTENT_ENCODING)) {\n-            String encodings = response.getHeaders().getFirst(HttpHeaders.CONTENT_ENCODING);\n-\n-            if (encodings.equals(\"gzip\")) {\n-                response.getHeaders().remove(HttpHeaders.CONTENT_ENCODING);\n-                try {\n-                    response.setEntityInputStream(new GZIPInputStream(response.getEntityInputStream()));\n-                } catch (IOException ex) {\n-                    throw new ClientHandlerException(ex);\n-                }\n-            }\n+        String responseEncoding = response.getHeaders().getFirst(HttpHeaders.CONTENT_ENCODING);\n+        if (response.hasEntity() && GZIP_ENCODING.equals(responseEncoding)) {\n+            response.getHeaders().remove(HttpHeaders.CONTENT_ENCODING);\n+            decompressResponse(response);\n         }\n-\n         return response;\n     }\n \n     private boolean isCompressionEnabled() {\n         return config.shouldEnableReplicatedRequestCompression();\n     }\n \n-    private static final class Adapter extends AbstractClientRequestAdapter {\n-        Adapter(ClientRequestAdapter cra) {\n+    private static void decompressResponse(ClientResponse response) {\n+        InputStream entityInputStream = response.getEntityInputStream();\n+        GZIPInputStream uncompressedIS;\n+        try {\n+            uncompressedIS = new GZIPInputStream(entityInputStream);\n+        } catch (IOException ex) {\n+            try {\n+                entityInputStream.close();\n+            } catch (IOException ignored) {\n+            }\n+            throw new ClientHandlerException(ex);\n+        }\n+        response.setEntityInputStream(uncompressedIS);\n+    }\n+\n+    private static final class GzipAdapter extends AbstractClientRequestAdapter {\n+        GzipAdapter(ClientRequestAdapter cra) {\n             super(cra);\n         }\n \n+        @Override\n         public OutputStream adapt(ClientRequest request, OutputStream out) throws IOException {\n             return new GZIPOutputStream(getAdapter().adapt(request, out));\n         }",
      "parent_sha": "b6b93f67c2060f40b8e9b57be74ae44f52bc4fbd"
    }
  },
  {
    "oid": "93b0b970a779da3e40f26cb1fe9d469675efff1b",
    "message": "Check if transport is null in DiscoveryClient#unregister",
    "date": "2016-04-07T21:25:40Z",
    "url": "https://github.com/Netflix/eureka/commit/93b0b970a779da3e40f26cb1fe9d469675efff1b",
    "details": {
      "sha": "bd58ad8c0f07e4b902a3da66d6ec3d7d1e00b2c9",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java",
      "status": "modified",
      "additions": 8,
      "deletions": 5,
      "changes": 13,
      "blob_url": "https://github.com/Netflix/eureka/blob/93b0b970a779da3e40f26cb1fe9d469675efff1b/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/93b0b970a779da3e40f26cb1fe9d469675efff1b/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java?ref=93b0b970a779da3e40f26cb1fe9d469675efff1b",
      "patch": "@@ -886,11 +886,14 @@ public void shutdown() {\n      * unregister w/ the eureka service.\n      */\n     void unregister() {\n-        try {\n-            EurekaHttpResponse<Void> httpResponse = eurekaTransport.registrationClient.cancel(instanceInfo.getAppName(), instanceInfo.getId());\n-            logger.info(PREFIX + appPathIdentifier + \" - deregister  status: \" + httpResponse.getStatusCode());\n-        } catch (Exception e) {\n-            logger.error(PREFIX + appPathIdentifier + \" - de-registration failed\" + e.getMessage(), e);\n+        // It can be null if shouldRegisterWithEureka == false\n+        if(eurekaTransport != null) {\n+            try {\n+                EurekaHttpResponse<Void> httpResponse = eurekaTransport.registrationClient.cancel(instanceInfo.getAppName(), instanceInfo.getId());\n+                logger.info(PREFIX + appPathIdentifier + \" - deregister  status: \" + httpResponse.getStatusCode());\n+            } catch (Exception e) {\n+                logger.error(PREFIX + appPathIdentifier + \" - de-registration failed\" + e.getMessage(), e);\n+            }\n         }\n     }\n ",
      "parent_sha": "bee851e469d0b0d7964743eb24d4ae52d23f0984"
    }
  },
  {
    "oid": "dbd10524053b1c6c3b647670d30edbce2cb525f4",
    "message": "clean up",
    "date": "2016-05-19T18:48:24Z",
    "url": "https://github.com/Netflix/eureka/commit/dbd10524053b1c6c3b647670d30edbce2cb525f4",
    "details": {
      "sha": "c8dc9d524c6dabd47ef6e92ec18df7f0ec0861a4",
      "filename": "eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/Netflix/eureka/blob/dbd10524053b1c6c3b647670d30edbce2cb525f4/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FAmazonInfo.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/dbd10524053b1c6c3b647670d30edbce2cb525f4/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FAmazonInfo.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FAmazonInfo.java?ref=dbd10524053b1c6c3b647670d30edbce2cb525f4",
      "patch": "@@ -61,16 +61,16 @@ public class AmazonInfo implements DataCenterInfo, UniqueIdentifier {\n     private static DynamicIntProperty awsMetaDataRetries;\n \n     /**\n-     * A fail fast mechanism exist for autoBuilding AmazonInfo based on the below configurations.\n+     * When creating an AmazonInfo via {@link com.netflix.appinfo.AmazonInfo.Builder#autoBuild(String)},\n+     * a fail fast mechanism exist based on the below configuration.\n      * If enabled (default to true), the {@link com.netflix.appinfo.AmazonInfo.Builder#autoBuild(String)}\n      * method will exit early after failing to load the value for the first metadata key (instanceId),\n      * after the expected number of retries as defined by {@link #awsMetaDataRetries}.\n      */\n     private static DynamicBooleanProperty awsMetaDataFailFastOnFirstLoad;\n \n     private static final String AWS_API_VERSION = \"latest\";\n-    private static final String AWS_METADATA_URL = \"http://169.254.169.254/\"\n-            + AWS_API_VERSION + \"/meta-data/\";\n+    private static final String AWS_METADATA_URL = \"http://169.254.169.254/\" + AWS_API_VERSION + \"/meta-data/\";\n \n     public enum MetaDataKey {\n         instanceId(\"instance-id\"),  // always have this first as we use it as a fail fast mechanism\n@@ -163,8 +163,7 @@ public String toString() {\n \n \n     public static final class Builder {\n-        private static final Logger logger = LoggerFactory\n-                .getLogger(Builder.class);\n+        private static final Logger logger = LoggerFactory.getLogger(Builder.class);\n         private static final int SLEEP_TIME_MS = 100;\n \n         @XStreamOmitField",
      "parent_sha": "b1ac90bb7596b01ab2c71bd213ba1575659d8580"
    }
  },
  {
    "oid": "503176cd464a90ba45abf61ad872618acc3e62f1",
    "message": "Fix InstanceInfo.Builder.setLeaseInfo\n\nInstanceInfo.Builder.setLeaseInfo did not return the Builder instance,\ntherefore breaking the Builder pattern. This commit fixes it to return\n'this'.",
    "date": "2015-02-08T12:41:43Z",
    "url": "https://github.com/Netflix/eureka/commit/503176cd464a90ba45abf61ad872618acc3e62f1",
    "details": {
      "sha": "b62a7d81aade87021564059110017f39427b67d9",
      "filename": "eureka-client/src/main/java/com/netflix/appinfo/InstanceInfo.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/Netflix/eureka/blob/503176cd464a90ba45abf61ad872618acc3e62f1/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FInstanceInfo.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/503176cd464a90ba45abf61ad872618acc3e62f1/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FInstanceInfo.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FInstanceInfo.java?ref=503176cd464a90ba45abf61ad872618acc3e62f1",
      "patch": "@@ -568,8 +568,9 @@ public Builder setDataCenterInfo(DataCenterInfo datacenter) {\n          * @param info\n          *            the lease information for this instance.\n          */\n-        public void setLeaseInfo(LeaseInfo info) {\n+        public Builder setLeaseInfo(LeaseInfo info) {\n             result.leaseInfo = info;\n+            return this;\n         }\n \n         /**",
      "parent_sha": "0274bf93040b521dfc5802459f8ce4692ef74024"
    }
  },
  {
    "oid": "c687b9a1cf1e2da1f4526074b1ccd6d7385b5493",
    "message": "log StatusChangeEvent at warn level is DOWN was involved",
    "date": "2015-10-26T05:11:56Z",
    "url": "https://github.com/Netflix/eureka/commit/c687b9a1cf1e2da1f4526074b1ccd6d7385b5493",
    "details": {
      "sha": "a100248121bb24c2023b4a95256033b682ae02dd",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/Netflix/eureka/blob/c687b9a1cf1e2da1f4526074b1ccd6d7385b5493/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/c687b9a1cf1e2da1f4526074b1ccd6d7385b5493/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java?ref=c687b9a1cf1e2da1f4526074b1ccd6d7385b5493",
      "patch": "@@ -1649,7 +1649,13 @@ public String getId() {\n \n                 @Override\n                 public void notify(StatusChangeEvent statusChangeEvent) {\n-                    logger.info(\"Saw local status change event {}\", statusChangeEvent);\n+                    if (InstanceStatus.DOWN == statusChangeEvent.getStatus() ||\n+                            InstanceStatus.DOWN == statusChangeEvent.getPreviousStatus()) {\n+                        // log at warn level if DOWN was involved\n+                        logger.warn(\"Saw local status change event {}\", statusChangeEvent);\n+                    } else {\n+                        logger.info(\"Saw local status change event {}\", statusChangeEvent);\n+                    }\n                     instanceInfoReplicator.onDemandUpdate();\n                 }\n             };",
      "parent_sha": "73b98447ef5873d6c2368231d7bd6cd22bfcaa4f"
    }
  },
  {
    "oid": "e38a56a69b60460a592fdf594d23fe164d6d0493",
    "message": "Enabling registration for non-amazon datacenters on server startup.\n\n`PeerAwareInstanceRegistry` disregards any non-amazon instances got from a peer on initial startup. This change enabled the registration.\n\nChanges were discussed as part of pull request: https://github.com/Netflix/eureka/pull/134",
    "date": "2014-07-22T22:57:23Z",
    "url": "https://github.com/Netflix/eureka/commit/e38a56a69b60460a592fdf594d23fe164d6d0493",
    "details": {
      "sha": "82bf8e72f9168652c2610ebeddb29dafebc53e78",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/eureka/blob/e38a56a69b60460a592fdf594d23fe164d6d0493/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FPeerAwareInstanceRegistry.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/e38a56a69b60460a592fdf594d23fe164d6d0493/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FPeerAwareInstanceRegistry.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FPeerAwareInstanceRegistry.java?ref=e38a56a69b60460a592fdf594d23fe164d6d0493",
      "patch": "@@ -707,7 +707,7 @@ public boolean isRegisterable(InstanceInfo instanceInfo) {\n                 return true;\n             }\n         }\n-        return false;\n+        return true; // Everything non-amazon is registrable.\n     }\n \n     /**",
      "parent_sha": "619e57d887160b69919399130d9b619c3d2f8b69"
    }
  },
  {
    "oid": "7d0271cbad7899058fd1679f8c597edb80f068d9",
    "message": "Fix an incorrect SLF4J logger call\n\nThis issue was found by SLF4J Helper for NetBeans IDE:\nhttp://plugins.netbeans.org/plugin/72557/",
    "date": "2017-11-06T17:15:59Z",
    "url": "https://github.com/Netflix/eureka/commit/7d0271cbad7899058fd1679f8c597edb80f068d9",
    "details": {
      "sha": "b0407b30fac418300c36d3f7ab1966f981feaecf",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/eureka/blob/7d0271cbad7899058fd1679f8c597edb80f068d9/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/7d0271cbad7899058fd1679f8c597edb80f068d9/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java?ref=7d0271cbad7899058fd1679f8c597edb80f068d9",
      "patch": "@@ -426,7 +426,7 @@ public synchronized BackupRegistry get() {\n                     throw new IllegalStateException(\"Registration error at startup. Invalid server response.\");\n                 }\n             } catch (Throwable th) {\n-                logger.error(\"Registration error at startup.\", th.getMessage());\n+                logger.error(\"Registration error at startup: {}\", th.getMessage());\n                 throw new IllegalStateException(th);\n             }\n         }",
      "parent_sha": "f6b924cd221644ffa67c1bec5ec5f5ea590a1cce"
    }
  },
  {
    "oid": "08e041283fef3ebf4e471a0e2d586f40a5193885",
    "message": "Bug fix in ApplicationsResource.\n\nThe condition to look for \"isRemoteRegionRequested\" wasn't appropriate.",
    "date": "2013-07-19T17:16:29Z",
    "url": "https://github.com/Netflix/eureka/commit/08e041283fef3ebf4e471a0e2d586f40a5193885",
    "details": {
      "sha": "b9833010c88881fe70cbe671067d7b9379b0bd5c",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationsResource.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/Netflix/eureka/blob/08e041283fef3ebf4e471a0e2d586f40a5193885/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fresources%2FApplicationsResource.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/08e041283fef3ebf4e471a0e2d586f40a5193885/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fresources%2FApplicationsResource.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fresources%2FApplicationsResource.java?ref=08e041283fef3ebf4e471a0e2d586f40a5193885",
      "patch": "@@ -107,10 +107,10 @@ public Response getContainers(@PathParam(\"version\") String version,\n             @HeaderParam(HEADER_ACCEPT_ENCODING) String acceptEncoding,\n             @Context UriInfo uriInfo, @Nullable @QueryParam(\"regions\") String regionsStr) {\n \n-        boolean isRemoteRegionRequested = null == regionsStr || regionsStr.isEmpty();\n+        boolean isRemoteRegionRequested = null != regionsStr && !regionsStr.isEmpty();\n         String[] regions;\n         String normalizedRegionStr = null;\n-        if (isRemoteRegionRequested) {\n+        if (!isRemoteRegionRequested) {\n             EurekaMonitors.GET_ALL.increment();\n         } else {\n             regions = regionsStr.toLowerCase().split(\",\");\n@@ -195,10 +195,10 @@ public Response getContainerDifferential(\n             return Response.status(Status.FORBIDDEN).build();\n         }\n \n-        boolean isRemoteRegionRequested = null == regionsStr || regionsStr.isEmpty();\n+        boolean isRemoteRegionRequested = null != regionsStr && !regionsStr.isEmpty();\n         String[] regions;\n         String normalizedRegionStr = null;\n-        if (isRemoteRegionRequested) {\n+        if (!isRemoteRegionRequested) {\n             EurekaMonitors.GET_ALL_DELTA.increment();\n         } else {\n             regions = regionsStr.toLowerCase().split(\",\");",
      "parent_sha": "827138b1d41c15c1391d14e496814af0c7f26eb9"
    }
  },
  {
    "oid": "821beb4b2e0204544c70017e1e883fcf4aa02c9e",
    "message": "Fix #1336 resource needs to be closed (#1350)",
    "date": "2020-10-09T22:42:00Z",
    "url": "https://github.com/Netflix/eureka/commit/821beb4b2e0204544c70017e1e883fcf4aa02c9e",
    "details": {
      "sha": "2820bcb1d7599e2d75e1858302750ab3f300ab94",
      "filename": "eureka-client-jersey2/src/main/java/com/netflix/discovery/shared/transport/jersey2/Jersey2ApplicationClientFactory.java",
      "status": "modified",
      "additions": 11,
      "deletions": 1,
      "changes": 12,
      "blob_url": "https://github.com/Netflix/eureka/blob/821beb4b2e0204544c70017e1e883fcf4aa02c9e/eureka-client-jersey2%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2Fjersey2%2FJersey2ApplicationClientFactory.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/821beb4b2e0204544c70017e1e883fcf4aa02c9e/eureka-client-jersey2%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2Fjersey2%2FJersey2ApplicationClientFactory.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client-jersey2%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2Fjersey2%2FJersey2ApplicationClientFactory.java?ref=821beb4b2e0204544c70017e1e883fcf4aa02c9e",
      "patch": "@@ -27,6 +27,7 @@\n import javax.ws.rs.core.MultivaluedHashMap;\n import javax.ws.rs.core.MultivaluedMap;\n import java.io.FileInputStream;\n+import java.io.IOException;\n import java.security.KeyStore;\n import java.util.ArrayList;\n import java.util.Collection;\n@@ -192,12 +193,13 @@ public void filter(ClientRequestContext requestContext) {\n         }\n \n         private void addSSLConfiguration(ClientBuilder clientBuilder) {\n+            FileInputStream fin = null;\n             try {\n                 if (systemSSL) {\n                     clientBuilder.sslContext(SSLContext.getDefault());\n                 } else if (trustStoreFileName != null) {\n                     KeyStore trustStore = KeyStore.getInstance(KEY_STORE_TYPE);\n-                    FileInputStream fin = new FileInputStream(trustStoreFileName);\n+                    fin = new FileInputStream(trustStoreFileName);\n                     trustStore.load(fin, trustStorePassword.toCharArray());\n                     clientBuilder.trustStore(trustStore);\n                 } else if (sslContext != null) {\n@@ -206,6 +208,14 @@ private void addSSLConfiguration(ClientBuilder clientBuilder) {\n             } catch (Exception ex) {\n                 throw new IllegalArgumentException(\"Cannot setup SSL for Jersey2 client\", ex);\n             }\n+            finally {\n+                if (fin != null) {\n+                    try {\n+                        fin.close();\n+                    } catch (IOException ignore) {\n+                    }\n+                }\n+            }\n         }\n \n         private void addProxyConfiguration(ClientConfig clientConfig) {",
      "parent_sha": "2607f30aaaba8e65246f4f632377d096899d1bae"
    }
  },
  {
    "oid": "05d7ba5d2ff24517ed5b6a3834134e61879abc62",
    "message": "storeOverrides should not check for remote region",
    "date": "2015-07-24T22:53:30Z",
    "url": "https://github.com/Netflix/eureka/commit/05d7ba5d2ff24517ed5b6a3834134e61879abc62",
    "details": {
      "sha": "e1eff09785d776892699f536a48453353fc8d1bb",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/AbstractInstanceRegistry.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/Netflix/eureka/blob/05d7ba5d2ff24517ed5b6a3834134e61879abc62/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FAbstractInstanceRegistry.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/05d7ba5d2ff24517ed5b6a3834134e61879abc62/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FAbstractInstanceRegistry.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FAbstractInstanceRegistry.java?ref=05d7ba5d2ff24517ed5b6a3834134e61879abc62",
      "patch": "@@ -344,7 +344,8 @@ public boolean renew(String appName, String id, boolean isReplication) {\n     }\n \n     /**\n-     * @deprecated this is expensive, try not to use.\n+     * @deprecated this is expensive, try not to use. See if you can use\n+     * {@link #storeOverriddenStatusIfRequired(String, String, InstanceStatus)} instead.\n      *\n      * Stores overridden status if it is not already there. This happens during\n      * a reconciliation process during renewal requests.\n@@ -396,7 +397,7 @@ public void storeOverriddenStatusIfRequired(String appName, String id, InstanceS\n             logger.info(\"Adding overridden status for instance id {} and the value is {}\",\n                     id, overriddenStatus.name());\n             overriddenInstanceStatusMap.put(id, overriddenStatus);\n-            InstanceInfo instanceInfo = this.getInstanceByAppAndId(appName, id);\n+            InstanceInfo instanceInfo = this.getInstanceByAppAndId(appName, id, false);\n             instanceInfo.setOverriddenStatus(overriddenStatus);\n              logger.info(\"Set the overridden status for instance (appname:{}, id:{}} and the value is {} \",\n                     appName, id, overriddenStatus.name());\n@@ -984,8 +985,7 @@ public InstanceInfo getInstanceByAppAndId(String appName, String id) {\n      *            otherwise\n      * @return the information about the instance.\n      */\n-    public InstanceInfo getInstanceByAppAndId(String appName, String id,\n-                                              boolean includeRemoteRegions) {\n+    public InstanceInfo getInstanceByAppAndId(String appName, String id, boolean includeRemoteRegions) {\n         Map<String, Lease<InstanceInfo>> leaseMap = registry.get(appName);\n         Lease<InstanceInfo> lease = null;\n         if (leaseMap != null) {",
      "parent_sha": "e43eb656bb8d5d0f72b73d0f219fe5410533324b"
    }
  },
  {
    "oid": "0c7f8ef4c2e5c6f168b4e8dfa923f9c86f5a72dc",
    "message": "no idea how these worked before",
    "date": "2023-11-08T17:26:26Z",
    "url": "https://github.com/Netflix/eureka/commit/0c7f8ef4c2e5c6f168b4e8dfa923f9c86f5a72dc",
    "details": {
      "sha": "07bacc4e23ea141898a84e4a8d8550cb5b5cef3c",
      "filename": "eureka-test-utils/src/main/java/com/netflix/discovery/shared/transport/ClusterSampleData.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/eureka/blob/0c7f8ef4c2e5c6f168b4e8dfa923f9c86f5a72dc/eureka-test-utils%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2FClusterSampleData.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/0c7f8ef4c2e5c6f168b4e8dfa923f9c86f5a72dc/eureka-test-utils%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2FClusterSampleData.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-test-utils%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2FClusterSampleData.java?ref=0c7f8ef4c2e5c6f168b4e8dfa923f9c86f5a72dc",
      "patch": "@@ -99,8 +99,8 @@ public static ReplicationInstance newReplicationInstanceOf(Action action, Instan\n                         instance.getAppName(),\n                         instance.getId(),\n                         System.currentTimeMillis(),\n-                        InstanceStatus.OUT_OF_SERVICE.name(),\n                         null,\n+                        InstanceStatus.OUT_OF_SERVICE.name(),\n                         null,\n                         action\n                 );\n@@ -110,7 +110,7 @@ public static ReplicationInstance newReplicationInstanceOf(Action action, Instan\n                         instance.getId(),\n                         System.currentTimeMillis(),\n                         InstanceStatus.OUT_OF_SERVICE.name(),\n-                        null,\n+                        InstanceStatus.UP.name(),\n                         null,\n                         action\n                 );",
      "parent_sha": "470ff15c90b71f2b4fcc07f53b0f9d1d947d5976"
    }
  },
  {
    "oid": "10b34a2e746cd8c3059e5646919ec3d1f3a7e2a6",
    "message": "Convert for loops to foreach loops in InstanceRegistry",
    "date": "2014-04-29T12:49:19Z",
    "url": "https://github.com/Netflix/eureka/commit/10b34a2e746cd8c3059e5646919ec3d1f3a7e2a6",
    "details": {
      "sha": "7437482cb0f9d2037c59d6105a923de60e620aaf",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java",
      "status": "modified",
      "additions": 8,
      "deletions": 13,
      "changes": 21,
      "blob_url": "https://github.com/Netflix/eureka/blob/10b34a2e746cd8c3059e5646919ec3d1f3a7e2a6/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FInstanceRegistry.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/10b34a2e746cd8c3059e5646919ec3d1f3a7e2a6/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FInstanceRegistry.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FInstanceRegistry.java?ref=10b34a2e746cd8c3059e5646919ec3d1f3a7e2a6",
      "patch": "@@ -154,7 +154,8 @@ public void register(InstanceInfo r, int leaseDuration, boolean isReplication) {\n                     .getAppName());\n             REGISTER.increment(isReplication);\n             if (gMap == null) {\n-                final ConcurrentHashMap<String, Lease<InstanceInfo>> gNewMap = new ConcurrentHashMap<String, Lease<InstanceInfo>>();\n+                final ConcurrentHashMap<String, Lease<InstanceInfo>> gNewMap =\n+                        new ConcurrentHashMap<String, Lease<InstanceInfo>>();\n                 gMap = registry.putIfAbsent(r.getAppName(), gNewMap);\n                 if (gMap == null) {\n                     gMap = gNewMap;\n@@ -195,8 +196,7 @@ public void register(InstanceInfo r, int leaseDuration, boolean isReplication) {\n             }\n             gMap.put(r.getId(), lease);\n             synchronized (recentRegisteredQueue) {\n-                recentRegisteredQueue.add(new Pair<Long, String>(Long\n-                        .valueOf(System.currentTimeMillis()), r.getAppName()\n+                recentRegisteredQueue.add(new Pair<Long, String>(System.currentTimeMillis(), r.getAppName()\n                                                               + \"(\" + r.getId() + \")\"));\n             }\n             // This is where the initial state transfer of overridden status\n@@ -521,10 +521,7 @@ public Application getApplication(String appName, boolean includeRemoteRegion) {\n         Map<String, Lease<InstanceInfo>> leaseMap = registry.get(appName);\n \n         if (leaseMap != null && leaseMap.size() > 0) {\n-            for (Iterator<Entry<String, Lease<InstanceInfo>>> iter = leaseMap\n-                    .entrySet().iterator(); iter.hasNext();) {\n-                Entry<String, Lease<InstanceInfo>> entry = iter.next();\n-\n+            for (Entry<String, Lease<InstanceInfo>> entry : leaseMap.entrySet()) {\n                 if (app == null) {\n                     app = new Application(appName);\n                 }\n@@ -1031,9 +1028,8 @@ public List<Pair<Long, String>> getLastNRegisteredInstances() {\n         List<Pair<Long, String>> list = new ArrayList<Pair<Long, String>>();\n \n         synchronized (recentRegisteredQueue) {\n-            for (Iterator<Pair<Long, String>> iter = recentRegisteredQueue\n-                    .iterator(); iter.hasNext();) {\n-                list.add(iter.next());\n+            for (Pair<Long, String> aRecentRegisteredQueue : recentRegisteredQueue) {\n+                list.add(aRecentRegisteredQueue);\n             }\n         }\n         Collections.reverse(list);\n@@ -1048,9 +1044,8 @@ public List<Pair<Long, String>> getLastNRegisteredInstances() {\n     public List<Pair<Long, String>> getLastNCanceledInstances() {\n         List<Pair<Long, String>> list = new ArrayList<Pair<Long, String>>();\n         synchronized (recentCanceledQueue) {\n-            for (Iterator<Pair<Long, String>> iter = recentCanceledQueue\n-                    .iterator(); iter.hasNext();) {\n-                list.add(iter.next());\n+            for (Pair<Long, String> aRecentCanceledQueue : recentCanceledQueue) {\n+                list.add(aRecentCanceledQueue);\n             }\n         }\n         Collections.reverse(list);",
      "parent_sha": "945df1b266674a202b1b3404f15b55e296569831"
    }
  },
  {
    "oid": "abad04864a379843a9fe66128c34a47bec0940a9",
    "message": "- log info instead of throwing exception when unbind eip for instance without eip bound",
    "date": "2016-04-09T00:18:52Z",
    "url": "https://github.com/Netflix/eureka/commit/abad04864a379843a9fe66128c34a47bec0940a9",
    "details": {
      "sha": "056bb042ab718715dfd7dcfd95be17e92416aa77",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/aws/EIPManager.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/Netflix/eureka/blob/abad04864a379843a9fe66128c34a47bec0940a9/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Faws%2FEIPManager.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/abad04864a379843a9fe66128c34a47bec0940a9/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Faws%2FEIPManager.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Faws%2FEIPManager.java?ref=abad04864a379843a9fe66128c34a47bec0940a9",
      "patch": "@@ -260,7 +260,8 @@ public void unbindEIP() throws Exception {\n             myPublicIP = ((AmazonInfo) myInfo.getDataCenterInfo())\n                     .get(MetaDataKey.publicIpv4);\n             if (myPublicIP == null) {\n-                throw new RuntimeException(\"Cannot dissociate eip from this instance since instance does not have one\");\n+                logger.info(\"Instance is not associated with an EIP. Will not try to unbind\");\n+                return;\n             }\n \n             try {",
      "parent_sha": "53364d409beb536e1524741679256228797fd1d4"
    }
  },
  {
    "oid": "e597d9efd98732ed4c68e94f6d6783214ec4a8c6",
    "message": "Don't use String.toUpperCase()\n\nInstanceInfo uses String.toUpperCase() without passing a Locale. This\nis very dangerous as it relies on the default locale which might not\nmatch the server's Locale. It is one of the APIs that are discouraged\nfor use, and it is better if it always passes a Locale.ROOT.",
    "date": "2015-02-08T13:26:40Z",
    "url": "https://github.com/Netflix/eureka/commit/e597d9efd98732ed4c68e94f6d6783214ec4a8c6",
    "details": {
      "sha": "11a70645c3b521347d64cfb31c3233c53e4684c0",
      "filename": "eureka-client/src/main/java/com/netflix/appinfo/InstanceInfo.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/Netflix/eureka/blob/e597d9efd98732ed4c68e94f6d6783214ec4a8c6/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FInstanceInfo.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/e597d9efd98732ed4c68e94f6d6783214ec4a8c6/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FInstanceInfo.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FInstanceInfo.java?ref=e597d9efd98732ed4c68e94f6d6783214ec4a8c6",
      "patch": "@@ -16,6 +16,7 @@\n package com.netflix.appinfo;\n \n import java.util.LinkedHashSet;\n+import java.util.Locale;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n@@ -266,7 +267,7 @@ public static Builder newBuilder() {\n          */\n         public Builder setAppName(String appName) {\n             if (appName != null) {\n-                result.appName = appName.toUpperCase();\n+                result.appName = appName.toUpperCase(Locale.ROOT);\n             } else {\n                 result.appName = null;\n             }\n@@ -275,7 +276,7 @@ public Builder setAppName(String appName) {\n \n         public Builder setAppGroupName(String appGroupName) {\n             if (appGroupName != null) {\n-                result.appGroupName = appGroupName.toUpperCase();\n+                result.appGroupName = appGroupName.toUpperCase(Locale.ROOT);\n             } else {\n                 result.appGroupName = null;\n             }",
      "parent_sha": "ad48663077e009bc09f3d6cc9bd5a05fd6d40dda"
    }
  },
  {
    "oid": "e1e40e7c1057dcd8deae50c1e84ef5edec8107db",
    "message": "Reuse the EIP if the lease has expired.",
    "date": "2012-11-10T00:18:42Z",
    "url": "https://github.com/Netflix/eureka/commit/e1e40e7c1057dcd8deae50c1e84ef5edec8107db",
    "details": {
      "sha": "5b720352eb29063c68a2b495457133bb55e2512b",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/Netflix/eureka/blob/e1e40e7c1057dcd8deae50c1e84ef5edec8107db/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2FEIPManager.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/e1e40e7c1057dcd8deae50c1e84ef5edec8107db/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2FEIPManager.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2FEIPManager.java?ref=e1e40e7c1057dcd8deae50c1e84ef5edec8107db",
      "patch": "@@ -34,6 +34,7 @@\n import com.netflix.appinfo.ApplicationInfoManager;\n import com.netflix.appinfo.DataCenterInfo.Name;\n import com.netflix.appinfo.InstanceInfo;\n+import com.netflix.appinfo.LeaseInfo;\n import com.netflix.discovery.DiscoveryManager;\n import com.netflix.discovery.shared.Application;\n import com.netflix.eureka.EurekaServerConfig;\n@@ -220,7 +221,13 @@ public String getCandidateEIP(String myInstanceId, String myZone,\n                 for (Iterator<String> it = availableEIPList.iterator(); it.hasNext(); ) {\n                     String eip = it.next();\n                     // if there is already an EIP association, remove it from the list\n-                    if (eip.trim().equals(publicIP)) {\n+                    if ((eip.trim().equals(publicIP))) {\n+                        LeaseInfo leaseInfo = i.getLeaseInfo();\n+                        if ((leaseInfo != null) && (System.currentTimeMillis() > (leaseInfo\n+                                .getRenewalTimestamp() + (leaseInfo\n+                                .getDurationInSecs() * 1000)))) {\n+                            continue;\n+                        }\n                         logger.info(\"Removing the EIP {} as it is already used by instance {}\", eip, instanceId);\n                         it.remove();\n                     }",
      "parent_sha": "f186ee8df7e2fbaaf03fca408fcba4e17af51706"
    }
  },
  {
    "oid": "171eb5529436a07c9e3dee37e5ed69829eb30a90",
    "message": "Fix log level for serviceUrls\n\nCurrently Eureka will log.info serviceUrls everytime it reads them.\nIt should only log.info serviceUrls if they have changed. Logging\neverytime it reads should be at the debug level.",
    "date": "2014-05-06T19:23:11Z",
    "url": "https://github.com/Netflix/eureka/commit/171eb5529436a07c9e3dee37e5ed69829eb30a90",
    "details": {
      "sha": "d9e2ba599ca1797ae4e9817d529b420c6e2638ed",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/eureka/blob/171eb5529436a07c9e3dee37e5ed69829eb30a90/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/171eb5529436a07c9e3dee37e5ed69829eb30a90/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java?ref=171eb5529436a07c9e3dee37e5ed69829eb30a90",
      "patch": "@@ -1148,7 +1148,7 @@ public List<String> getServiceUrlsFromDNS(String instanceZone,\n         arrangeListBasedonHostname(serviceUrls);\n         serviceUrls.add(0, primaryServiceUrl);\n \n-        logger.info(\n+        logger.debug(\n                 \"This client will talk to the following serviceUrls in order : {} \",\n                 Arrays.toString(serviceUrls.toArray()));\n         t.stop();\n@@ -1639,7 +1639,7 @@ public void run() {\n                         return;\n                     }\n                     if (!serviceUrlList.equals(eurekaServiceUrls.get())) {\n-                        logger.debug(\n+                        logger.info(\n                                 \"Updating the serviceUrls as they seem to have changed from {} to {} \",\n                                 Arrays.toString(eurekaServiceUrls.get()\n                                         .toArray()), Arrays",
      "parent_sha": "71402560d6f7f0d3709f5739ef45618fccda943b"
    }
  },
  {
    "oid": "45ba5bca59948626086d60b61f8ba3687d2fea56",
    "message": "Verify is scheduler is active before submit\n\nFixes gh-1025.",
    "date": "2018-01-22T12:08:31Z",
    "url": "https://github.com/Netflix/eureka/commit/45ba5bca59948626086d60b61f8ba3687d2fea56",
    "details": {
      "sha": "7772cb2d33075eac31f57845beaf1cdeb01ab5ae",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/InstanceInfoReplicator.java",
      "status": "modified",
      "additions": 19,
      "deletions": 14,
      "changes": 33,
      "blob_url": "https://github.com/Netflix/eureka/blob/45ba5bca59948626086d60b61f8ba3687d2fea56/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FInstanceInfoReplicator.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/45ba5bca59948626086d60b61f8ba3687d2fea56/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FInstanceInfoReplicator.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FInstanceInfoReplicator.java?ref=45ba5bca59948626086d60b61f8ba3687d2fea56",
      "patch": "@@ -74,21 +74,26 @@ public void stop() {\n \n     public boolean onDemandUpdate() {\n         if (rateLimiter.acquire(burstSize, allowedRatePerMinute)) {\n-            scheduler.submit(new Runnable() {\n-                @Override\n-                public void run() {\n-                    logger.debug(\"Executing on-demand update of local InstanceInfo\");\n-\n-                    Future latestPeriodic = scheduledPeriodicRef.get();\n-                    if (latestPeriodic != null && !latestPeriodic.isDone()) {\n-                        logger.debug(\"Canceling the latest scheduled update, it will be rescheduled at the end of on demand update\");\n-                        latestPeriodic.cancel(false);\n+            if (!scheduler.isShutdown()) {\n+                scheduler.submit(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        logger.debug(\"Executing on-demand update of local InstanceInfo\");\n+    \n+                        Future latestPeriodic = scheduledPeriodicRef.get();\n+                        if (latestPeriodic != null && !latestPeriodic.isDone()) {\n+                            logger.debug(\"Canceling the latest scheduled update, it will be rescheduled at the end of on demand update\");\n+                            latestPeriodic.cancel(false);\n+                        }\n+    \n+                        InstanceInfoReplicator.this.run();\n                     }\n-\n-                    InstanceInfoReplicator.this.run();\n-                }\n-            });\n-            return true;\n+                });\n+                return true;\n+            } else {\n+                logger.warn(\"Ignoring onDemand update due to stopped scheduler\");\n+                return false;\n+            }\n         } else {\n             logger.warn(\"Ignoring onDemand update due to rate limiter\");\n             return false;",
      "parent_sha": "64e5e2ee97c6036d9a2f447bada79d643c985fb6"
    }
  },
  {
    "oid": "8b759c57c72a94989c199d7931aa48f702e5bc3a",
    "message": "Objects of different types compared with equals method.",
    "date": "2015-02-11T12:00:42Z",
    "url": "https://github.com/Netflix/eureka/commit/8b759c57c72a94989c199d7931aa48f702e5bc3a",
    "details": {
      "sha": "684129b4eae2c1b046cdfbd47a036e91f7827e92",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/eureka/blob/8b759c57c72a94989c199d7931aa48f702e5bc3a/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/8b759c57c72a94989c199d7931aa48f702e5bc3a/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java?ref=8b759c57c72a94989c199d7931aa48f702e5bc3a",
      "patch": "@@ -591,7 +591,7 @@ private boolean shouldRegister(InstanceInfo myInfo) {\n         if (!clientConfig.shouldRegisterWithEureka()) {\n             return false;\n         } else if ((myInfo != null)\n-                && (myInfo.getDataCenterInfo()\n+                && (myInfo.getDataCenterInfo().getName()\n                         .equals(DataCenterInfo.Name.Amazon))) {\n             return true;\n         }\n@@ -1630,7 +1630,7 @@ public void run() {\n                 // Pass in the appinfo again since\n                 if ((discoveryServer != null)\n                         && (Name.Amazon.equals(discoveryServer\n-                                .getDataCenterInfo()))) {\n+                                .getDataCenterInfo().getName()))) {\n                     String amiId = ((AmazonInfo) discoveryServer\n                             .getDataCenterInfo()).get(MetaDataKey.amiId);\n                     if (discoveryServerAMIId == null) {",
      "parent_sha": "251bac0a23f6925c4ba618749f9a2f5efed226c7"
    }
  },
  {
    "oid": "f6212a7e474f812f31ddbce6d4f7a7a0d498b751",
    "message": "Create protected methods for statusChanged and cacheRefreshed events.\nSubclasses may override these methods if they need custom behavior.\nMove the code sending events to the eventBus inside these methods.\nCapture 'CacheRefreshed' events",
    "date": "2015-06-15T09:55:45Z",
    "url": "https://github.com/Netflix/eureka/commit/f6212a7e474f812f31ddbce6d4f7a7a0d498b751",
    "details": {
      "sha": "b4b1ea96c0751e541db359e96da8cd40f411ad1c",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java",
      "status": "modified",
      "additions": 32,
      "deletions": 9,
      "changes": 41,
      "blob_url": "https://github.com/Netflix/eureka/blob/f6212a7e474f812f31ddbce6d4f7a7a0d498b751/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/f6212a7e474f812f31ddbce6d4f7a7a0d498b751/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java?ref=f6212a7e474f812f31ddbce6d4f7a7a0d498b751",
      "patch": "@@ -845,6 +845,10 @@ private boolean fetchRegistry(boolean forceFullRegistryFetch) {\n             logger.debug(PREFIX + appPathIdentifier + \" -  refresh status: \"\n                     + response.getStatus());\n \n+            // Notify about cache refreshed before updating the instance remote status\n+            onCacheRefreshed();\n+            \n+            // Update remote status based on refreshed data held in the cache\n             updateInstanceRemoteStatus();\n \n         } catch (Throwable e) {\n@@ -880,15 +884,8 @@ private synchronized void updateInstanceRemoteStatus() {\n \n         // Notify if status changed\n         if (lastRemoteInstanceStatus != currentRemoteInstanceStatus) {\n-            try {\n-                if (eventBus != null) {\n-                    StatusChangeEvent event = new StatusChangeEvent(lastRemoteInstanceStatus,\n-                            currentRemoteInstanceStatus);\n-                    eventBus.publish(event);\n-                }\n-            } finally {\n-                lastRemoteInstanceStatus = currentRemoteInstanceStatus;\n-            }\n+        \tonRemoteStatusChanged(lastRemoteInstanceStatus, currentRemoteInstanceStatus);\n+        \tlastRemoteInstanceStatus = currentRemoteInstanceStatus;\n         }\n     }\n \n@@ -2004,4 +2001,30 @@ private void arrangeListBasedonHostname(List<String> list) {\n         }\n     }\n \n+    \n+    /**\n+     * Invoked when the remote status of this client has changed.\n+     * Subclasses may override this method to implement custom behavior if needed.\n+     * \n+     * @param oldStatus the previous remote {@link InstanceStatus}\n+     * @param newStatus the new remote {@link InstanceStatus} \n+     */\n+    protected void onRemoteStatusChanged(InstanceInfo.InstanceStatus oldStatus, InstanceInfo.InstanceStatus newStatus) {\n+    \t// Publish event if an EventBus is available\n+        if (eventBus != null) {\n+            StatusChangeEvent event = new StatusChangeEvent(oldStatus, newStatus);\n+            eventBus.publish(event);\n+        }\n+    }\n+    \n+    /**\n+     * Invoked every time the local registry cache is refreshed (whether changes have \n+     * been detected or not).\n+     * \n+     * Subclasses may override this method to implement custom behavior if needed.\n+     */\n+    protected void onCacheRefreshed() {\n+    \t// NOOP\n+    }\n+\n }",
      "parent_sha": "756bcd9fd308647c7b388543da9a3a6e034ee3f5"
    }
  },
  {
    "oid": "201cfc628ce0bef6bcecc99961791454e6a9b907",
    "message": "Add timeouts to unit test verify",
    "date": "2015-10-02T21:00:16Z",
    "url": "https://github.com/Netflix/eureka/commit/201cfc628ce0bef6bcecc99961791454e6a9b907",
    "details": {
      "sha": "aa2a60022c760aab63900369f3e7e36181f3f588",
      "filename": "eureka-core/src/test/java/com/netflix/eureka/util/batcher/TaskExecutorsTest.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/Netflix/eureka/blob/201cfc628ce0bef6bcecc99961791454e6a9b907/eureka-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2Fbatcher%2FTaskExecutorsTest.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/201cfc628ce0bef6bcecc99961791454e6a9b907/eureka-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2Fbatcher%2FTaskExecutorsTest.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2Fbatcher%2FTaskExecutorsTest.java?ref=201cfc628ce0bef6bcecc99961791454e6a9b907",
      "patch": "@@ -31,6 +31,7 @@\n import static java.util.Arrays.asList;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.timeout;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n@@ -82,7 +83,7 @@ public void testSingleItemProcessingWithTransientError() throws Exception {\n \n         // Verify that transient task is be re-scheduled\n         processor.expectTransientErrors(1);\n-        verify(acceptorExecutor, times(1)).reprocess(taskHolder, ProcessingResult.TransientError);\n+        verify(acceptorExecutor, timeout(500).times(1)).reprocess(taskHolder, ProcessingResult.TransientError);\n     }\n \n     @Test\n@@ -94,7 +95,7 @@ public void testBatchProcessingWithTransientError() throws Exception {\n \n         // Verify that transient task is be re-scheduled\n         processor.expectTransientErrors(2);\n-        verify(acceptorExecutor, times(1)).reprocess(taskHolderBatch, ProcessingResult.TransientError);\n+        verify(acceptorExecutor, timeout(500).times(1)).reprocess(taskHolderBatch, ProcessingResult.TransientError);\n     }\n \n     @Test",
      "parent_sha": "42e0f61646cfbe0cc792b4e1e8eb6b970ba6dbed"
    }
  },
  {
    "oid": "58a6d49d64e928f6aad85300d82af40b1381bc07",
    "message": "fix incorrect default in test",
    "date": "2015-09-23T03:56:01Z",
    "url": "https://github.com/Netflix/eureka/commit/58a6d49d64e928f6aad85300d82af40b1381bc07",
    "details": {
      "sha": "2c3d2d4bbb8275ec164a2e8c177bb0ecb87c33bd",
      "filename": "eureka-client/src/test/java/com/netflix/appinfo/InstanceInfoTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/eureka/blob/58a6d49d64e928f6aad85300d82af40b1381bc07/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FInstanceInfoTest.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/58a6d49d64e928f6aad85300d82af40b1381bc07/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FInstanceInfoTest.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FInstanceInfoTest.java?ref=58a6d49d64e928f6aad85300d82af40b1381bc07",
      "patch": "@@ -124,7 +124,7 @@ public void testGetIdWithSIDUsed() {\n     // test case for compatiblity\n     @Test\n     public void testGetIdWithSIDNotUsed() {\n-        String sidDefaultVal = \"unknown\";\n+        String sidDefaultVal = \"na\";\n         InstanceInfo baseline = InstanceInfoGenerator.takeOne();\n         InstanceInfo instanceInfo1 = new InstanceInfo.Builder(baseline).setSID(sidDefaultVal).build();\n         String dataCenterInfoId = ((UniqueIdentifier) baseline.getDataCenterInfo()).getId();",
      "parent_sha": "f4ac8fce6b0724c27fe3cc6e6a9e8ee1d4ff5a89"
    }
  },
  {
    "oid": "efbc4d738e278ea3fec6632e2135e6ec7e4d5000",
    "message": "Only replicate to replica if the status is UP.",
    "date": "2012-09-20T20:07:54Z",
    "url": "https://github.com/Netflix/eureka/commit/efbc4d738e278ea3fec6632e2135e6ec7e4d5000",
    "details": {
      "sha": "3d037348d46b3972a66b982dd8ec6e8d01035fd8",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java",
      "status": "modified",
      "additions": 38,
      "deletions": 34,
      "changes": 72,
      "blob_url": "https://github.com/Netflix/eureka/blob/efbc4d738e278ea3fec6632e2135e6ec7e4d5000/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FPeerAwareInstanceRegistry.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/efbc4d738e278ea3fec6632e2135e6ec7e4d5000/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FPeerAwareInstanceRegistry.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FPeerAwareInstanceRegistry.java?ref=efbc4d738e278ea3fec6632e2135e6ec7e4d5000",
      "patch": "@@ -93,10 +93,10 @@\n  */\n public class PeerAwareInstanceRegistry extends InstanceRegistry {\n     private static final Logger logger = LoggerFactory\n-            .getLogger(PeerAwareInstanceRegistry.class);\n+    .getLogger(PeerAwareInstanceRegistry.class);\n \n     private static final EurekaServerConfig eurekaServerConfig = EurekaServerConfigurationManager\n-            .getInstance().getConfiguration();\n+    .getInstance().getConfiguration();\n     private static final String DICOVERY_FAILED_REPLICATION_AFTER_RETRY = \"FailedReplicationAfterRetry\";\n \n     private static final int REPL_RETRY_SLEEP_TIME_IN_MS = 40;\n@@ -137,12 +137,12 @@ public int compare(Application l, Application r) {\n     private Timer timer = new Timer(\n             \"ReplicaAwareInstanceRegistry - RenewalThresholdUpdater\", true);\n     private static final LoadingCache<String, Boolean> peerEurekaStatusCache = CacheBuilder\n-            .newBuilder()\n-            .initialCapacity(10)\n-            .expireAfterWrite(\n-                    eurekaServerConfig\n-                            .getPeerEurekaStatusRefreshTimeIntervalMs(),\n-                    TimeUnit.MILLISECONDS)\n+    .newBuilder()\n+    .initialCapacity(10)\n+    .expireAfterWrite(\n+            eurekaServerConfig\n+            .getPeerEurekaStatusRefreshTimeIntervalMs(),\n+            TimeUnit.MILLISECONDS)\n             .<String, Boolean> build(new CacheLoader<String, Boolean>() {\n                 public Boolean load(String serviceUrl) {\n                     try {\n@@ -172,7 +172,7 @@ public Boolean get(Object key) {\n     private static final PeerAwareInstanceRegistry instance = new PeerAwareInstanceRegistry();\n \n     private Counter failedReplicationAfterRetry = Monitors\n-            .newCounter(DICOVERY_FAILED_REPLICATION_AFTER_RETRY);\n+    .newCounter(DICOVERY_FAILED_REPLICATION_AFTER_RETRY);\n \n     PeerAwareInstanceRegistry() {\n         // Make it an atomic reference since this could be updated in the\n@@ -187,16 +187,16 @@ public Boolean get(Object key) {\n                     e);\n         }\n         ThreadFactory threadFactory = new ThreadFactoryBuilder()\n-                .setDaemon(false).setNameFormat(\"Eureka-Replication-Thread\")\n-                .build();\n+        .setDaemon(false).setNameFormat(\"Eureka-Replication-Thread\")\n+        .build();\n         // Thread pool used for replication\n         replicationExecutorPool = new ThreadPoolExecutor(eurekaServerConfig\n                 .getMinThreadsForReplication(), eurekaServerConfig\n                 .getMaxThreadsForReplication(), eurekaServerConfig\n                 .getMaxIdleThreadAgeInMinutesForReplication(),\n                 TimeUnit.MINUTES, new ArrayBlockingQueue<Runnable>(\n                         eurekaServerConfig.getMaxElementsInReplicationPool()),\n-                threadFactory) {\n+                        threadFactory) {\n         };\n         init();\n     }\n@@ -231,7 +231,7 @@ public void run() {\n             }\n \n         }, eurekaServerConfig.getRenewalThresholdUpdateIntervalMs(),\n-                eurekaServerConfig.getRenewalThresholdUpdateIntervalMs());\n+        eurekaServerConfig.getRenewalThresholdUpdateIntervalMs());\n     }\n \n     /**\n@@ -254,7 +254,7 @@ public void run() {\n \n                 }\n             }, eurekaServerConfig.getPeerEurekaNodesUpdateIntervalMs(),\n-                    eurekaServerConfig.getPeerEurekaNodesUpdateIntervalMs());\n+            eurekaServerConfig.getPeerEurekaNodesUpdateIntervalMs());\n \n         } catch (Exception e) {\n             throw new IllegalStateException(e);\n@@ -267,8 +267,8 @@ public void run() {\n     private void updatePeerEurekaNodes() {\n         InstanceInfo myInfo = ApplicationInfoManager.getInstance().getInfo();\n         List<String> replicaUrls = DiscoveryManager.getInstance()\n-                .getDiscoveryClient()\n-                .getDiscoveryServiceUrls(DiscoveryClient.getZone(myInfo));\n+        .getDiscoveryClient()\n+        .getDiscoveryServiceUrls(DiscoveryClient.getZone(myInfo));\n         List<PeerEurekaNode> replicaNodes = new ArrayList<PeerEurekaNode>();\n         for (String replicaUrl : replicaUrls) {\n             if (!isThisMe(replicaUrl)) {\n@@ -304,7 +304,7 @@ private void updatePeerEurekaNodes() {\n     public void syncUp() {\n         // Copy entire entry from neighboring DS node\n         LookupService lookupService = DiscoveryManager.getInstance()\n-                .getLookupService();\n+        .getLookupService();\n \n         Applications apps = lookupService.getApplications();\n         int count = 0;\n@@ -422,10 +422,13 @@ public boolean renew(final String appName, final String id,\n         }\n         return false;\n     }\n-     \n+\n     /*\n      * (non-Javadoc)\n-     * @see com.netflix.eureka.InstanceRegistry#statusUpdate(java.lang.String, java.lang.String, com.netflix.appinfo.InstanceInfo.InstanceStatus, java.lang.String, boolean)\n+     * \n+     * @see com.netflix.eureka.InstanceRegistry#statusUpdate(java.lang.String,\n+     * java.lang.String, com.netflix.appinfo.InstanceInfo.InstanceStatus,\n+     * java.lang.String, boolean)\n      */\n     public boolean statusUpdate(final String appName, final String id,\n             final InstanceStatus newStatus, String lastDirtyTimestamp,\n@@ -547,7 +550,8 @@ void shutdown() {\n     }\n \n     @Override\n-    public InstanceInfo getNextServerFromEureka(String virtualHostname, boolean secure) {\n+    public InstanceInfo getNextServerFromEureka(String virtualHostname,\n+            boolean secure) {\n         // TODO Auto-generated method stub\n         return null;\n     }\n@@ -561,7 +565,7 @@ public InstanceInfo getNextServerFromEureka(String virtualHostname, boolean secu\n     private void updateRenewalThreshold() {\n         try {\n             LookupService lookupService = DiscoveryManager.getInstance()\n-                    .getLookupService();\n+            .getLookupService();\n             Applications apps = lookupService.getApplications();\n             int count = 0;\n             for (Application app : apps.getRegisteredApplications()) {\n@@ -717,7 +721,7 @@ private void replicateToPeers(final Action action, final String appName,\n                     replicationExecutorPool.execute(new Runnable() {\n                         public void run() {\n                             int retryCounter = eurekaServerConfig\n-                                    .getNumberOfReplicationRetries();\n+                            .getNumberOfReplicationRetries();\n                             // If the url represents this host, do not replicate\n                             // to yourself.\n                             if (isThisMe(node.getServiceUrl())) {\n@@ -779,25 +783,25 @@ private void replicateInstanceActionsToPeers(final Action action,\n                 break;\n             case Heartbeat:\n                 InstanceStatus overriddenStatus = overriddenInstanceStatusMap\n-                        .get(id);\n+                .get(id);\n                 InstanceInfo infoFromRegistry = getInstanceByAppAndId(appName,\n                         id);\n                 if (!node.heartbeat(appName, id, infoFromRegistry,\n                         overriddenStatus)) {\n                     logger.warn(\n                             \"Cannot find instance id {} and hence replicating the instance with status {}\",\n                             infoFromRegistry.getId(), infoFromRegistry\n-                                    .getStatus().toString());\n+                            .getStatus().toString());\n                     if (infoFromRegistry != null) {\n                         node.register(infoFromRegistry);\n-                    }                 }\n+                    }\n+                }\n                 break;\n             case Register:\n                 node.register(info);\n                 break;\n             case StatusUpdate:\n-                infoFromRegistry = getInstanceByAppAndId(appName,\n-                        id);\n+                infoFromRegistry = getInstanceByAppAndId(appName, id);\n                 node.statusUpdate(appName, id, newStatus, infoFromRegistry);\n                 break;\n             }\n@@ -816,15 +820,14 @@ private void replicateInstanceActionsToPeers(final Action action,\n                         newStatus, node, retryCounter);\n             } else {\n                 failedReplicationAfterRetry = Monitors\n-                        .newCounter(DICOVERY_FAILED_REPLICATION_AFTER_RETRY);\n+                .newCounter(DICOVERY_FAILED_REPLICATION_AFTER_RETRY);\n                 failedReplicationAfterRetry.increment();\n                 Object[] args_1 = { action.name(), serviceUrl, id };\n                 logger.error(\n                         \"ReplicaAwareInstanceRegistry: Failed replicating action {} for the server {} and instance id {}. No more retries left.\",\n                         args_1);\n-\n+                logger.error(\"Replication failed :\", t);\n             }\n-\n         }\n     }\n \n@@ -891,16 +894,17 @@ private boolean isPeerAlive(String serviceUrl) {\n      * @throws URISyntaxException\n      */\n     private static boolean isPeerAliveInMyRegistery(String serviceUrl)\n-            throws URISyntaxException {\n+    throws URISyntaxException {\n         String myName = ApplicationInfoManager.getInstance().getInfo()\n-                .getAppName();\n+        .getAppName();\n         URI uri = new URI(serviceUrl);\n         Application app = PeerAwareInstanceRegistry.getInstance()\n-                .getApplication(myName);\n+        .getApplication(myName);\n         List<InstanceInfo> instanceInfoList = app.getInstances();\n         for (InstanceInfo instanceInfo : instanceInfoList) {\n             if (((AmazonInfo) instanceInfo.getDataCenterInfo()).get(\n-                    MetaDataKey.publicHostname).equalsIgnoreCase(uri.getHost())) {\n+                    MetaDataKey.publicHostname).equalsIgnoreCase(uri.getHost())\n+                    && (InstanceStatus.UP.equals(instanceInfo.getStatus()))) {\n                 return true;\n             }\n         }",
      "parent_sha": "b4231b0d8a940d5c8aa52be4f7e3b879537bb2ef"
    }
  },
  {
    "oid": "14c5103538be949e6cfce77d8be0170599006429",
    "message": "avoid array allocation in ResponseCacheImpl",
    "date": "2023-01-22T22:53:21Z",
    "url": "https://github.com/Netflix/eureka/commit/14c5103538be949e6cfce77d8be0170599006429",
    "details": {
      "sha": "863e6bea42aa21d121036c0824d6a66d22e11a82",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/registry/ResponseCacheImpl.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/Netflix/eureka/blob/14c5103538be949e6cfce77d8be0170599006429/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fregistry%2FResponseCacheImpl.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/14c5103538be949e6cfce77d8be0170599006429/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fregistry%2FResponseCacheImpl.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fregistry%2FResponseCacheImpl.java?ref=14c5103538be949e6cfce77d8be0170599006429",
      "patch": "@@ -74,6 +74,8 @@\n  * @author Karthik Ranganathan, Greg Kim\n  */\n public class ResponseCacheImpl implements ResponseCache {\n+    private static final Key.KeyType[] KEY_TYPE_VALUES = Key.KeyType.values();\n+    private static final Version[] VERSION_VALUES = Version.values();\n \n     private static final Logger logger = LoggerFactory.getLogger(ResponseCacheImpl.class);\n \n@@ -249,8 +251,8 @@ public void stop() {\n      */\n     @Override\n     public void invalidate(String appName, @Nullable String vipAddress, @Nullable String secureVipAddress) {\n-        for (Key.KeyType type : Key.KeyType.values()) {\n-            for (Version v : Version.values()) {\n+        for (Key.KeyType type : KEY_TYPE_VALUES) {\n+            for (Version v : VERSION_VALUES) {\n                 invalidate(\n                         new Key(Key.EntityType.Application, appName, type, v, EurekaAccept.full),\n                         new Key(Key.EntityType.Application, appName, type, v, EurekaAccept.compact),",
      "parent_sha": "191cc407cac86afe6633ddf44de3c37166fd318f"
    }
  },
  {
    "oid": "032c5eec6883bac9049312204c0b41339af7c5c7",
    "message": "Use domain of elastic IP to determine vpc or ec2-classic",
    "date": "2014-07-26T01:38:46Z",
    "url": "https://github.com/Netflix/eureka/commit/032c5eec6883bac9049312204c0b41339af7c5c7",
    "details": {
      "sha": "3a4d4f48e3a0fc55597caeaa022056a80de6e831",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java",
      "status": "modified",
      "additions": 7,
      "deletions": 6,
      "changes": 13,
      "blob_url": "https://github.com/Netflix/eureka/blob/032c5eec6883bac9049312204c0b41339af7c5c7/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2FEIPManager.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/032c5eec6883bac9049312204c0b41339af7c5c7/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2FEIPManager.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2FEIPManager.java?ref=032c5eec6883bac9049312204c0b41339af7c5c7",
      "patch": "@@ -195,9 +195,9 @@ public void bindEIP() {\n             AssociateAddressRequest associateAddressRequest = new AssociateAddressRequest()\n             .withInstanceId(myInstanceId);\n \n-            String allocationId = selectedEIP.getAllocationId();\n-            if (null != allocationId) {\n-                associateAddressRequest.setAllocationId(allocationId);\n+            String domain = selectedEIP.getDomain();\n+            if (\"vpc\".equals(domain)) {\n+                associateAddressRequest.setAllocationId(selectedEIP.getAllocationId());\n             } else {\n                 associateAddressRequest.setPublicIp(publicIp);\n             }\n@@ -233,12 +233,13 @@ public void unbindEIP() {\n                         && (!result.getAddresses().isEmpty())) {\n                     Address eipAddress = result.getAddresses().get(0);\n                     DisassociateAddressRequest dissociateRequest = new DisassociateAddressRequest();\n-                    String associationId = eipAddress.getAssociationId();\n-                    if (null != associationId) {\n-                        dissociateRequest.setAssociationId(associationId);\n+                    String domain = eipAddress.getDomain();\n+                    if (\"vpc\".equals(domain)) {\n+                        dissociateRequest.setAssociationId(eipAddress.getAssociationId());\n                     } else {\n                         dissociateRequest.setPublicIp(eipAddress.getPublicIp());\n                     }\n+\n                     ec2Service.disassociateAddress(dissociateRequest);\n                     logger.info(\"Dissociated the EIP {} from this instance\",\n                             myPublicIP);",
      "parent_sha": "774e391da9f18ef39ea334677db083f23b5c02c6"
    }
  },
  {
    "oid": "c53342dc8f0b0a9bf919df0390c9a2b6ec41dab5",
    "message": "modify comment",
    "date": "2018-07-11T07:17:00Z",
    "url": "https://github.com/Netflix/eureka/commit/c53342dc8f0b0a9bf919df0390c9a2b6ec41dab5",
    "details": {
      "sha": "a3120e8ab4bca577252e2004979537e32edd0d9f",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/eureka/blob/c53342dc8f0b0a9bf919df0390c9a2b6ec41dab5/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/c53342dc8f0b0a9bf919df0390c9a2b6ec41dab5/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java?ref=c53342dc8f0b0a9bf919df0390c9a2b6ec41dab5",
      "patch": "@@ -1222,8 +1222,8 @@ private void updateDelta(Applications delta) {\n                         logger.debug(\"Deleted instance {} to the existing apps \", instance.getId());\n                         existingApp.removeInstance(instance);\n                         /*\n-                         *We find all instance list from application(Instance status are not only the status is UP but also other status)\n-                         *if instance list is empty, we remove the application.\n+                         * We find all instance list from application(The status of instance status is not only the status is UP but also other status)\n+                         * if instance list is empty, we remove the application.\n                          */\n                         if (existingApp.getInstancesAsIsFromEureka().isEmpty()) {\n                             applications.removeApplication(existingApp);",
      "parent_sha": "15ddfe684707328354797205c9cc207560b0587e"
    }
  },
  {
    "oid": "f4b1fa2405f610d696b0b27867f15fc333fba4c7",
    "message": "adjust clustersampledata",
    "date": "2023-11-09T23:51:04Z",
    "url": "https://github.com/Netflix/eureka/commit/f4b1fa2405f610d696b0b27867f15fc333fba4c7",
    "details": {
      "sha": "a03fcb9d3fd71aaafb75a3c18e37f04b97ff33a0",
      "filename": "eureka-test-utils/src/main/java/com/netflix/discovery/shared/transport/ClusterSampleData.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/eureka/blob/f4b1fa2405f610d696b0b27867f15fc333fba4c7/eureka-test-utils%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2FClusterSampleData.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/f4b1fa2405f610d696b0b27867f15fc333fba4c7/eureka-test-utils%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2FClusterSampleData.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-test-utils%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2FClusterSampleData.java?ref=f4b1fa2405f610d696b0b27867f15fc333fba4c7",
      "patch": "@@ -109,7 +109,7 @@ public static ReplicationInstance newReplicationInstanceOf(Action action, Instan\n                         instance.getAppName(),\n                         instance.getId(),\n                         System.currentTimeMillis(),\n-                        InstanceStatus.OUT_OF_SERVICE.name(),\n+                        null,\n                         InstanceStatus.UP.name(),\n                         null,\n                         action",
      "parent_sha": "0c7f8ef4c2e5c6f168b4e8dfa923f9c86f5a72dc"
    }
  },
  {
    "oid": "5ba6438284b88f0727e38d16446f9056c6429614",
    "message": "Added testcase for app group.",
    "date": "2014-04-15T19:07:28Z",
    "url": "https://github.com/Netflix/eureka/commit/5ba6438284b88f0727e38d16446f9056c6429614",
    "details": {
      "sha": "73c15cbf5c38c4950db00df59267c9a10f0a89ff",
      "filename": "eureka-client/src/test/java/com/netflix/appinfo/InstanceInfoTest.java",
      "status": "modified",
      "additions": 28,
      "deletions": 4,
      "changes": 32,
      "blob_url": "https://github.com/Netflix/eureka/blob/5ba6438284b88f0727e38d16446f9056c6429614/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FInstanceInfoTest.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/5ba6438284b88f0727e38d16446f9056c6429614/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FInstanceInfoTest.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FInstanceInfoTest.java?ref=5ba6438284b88f0727e38d16446f9056c6429614",
      "patch": "@@ -1,12 +1,22 @@\n package com.netflix.appinfo;\n \n+import com.netflix.config.ConcurrentCompositeConfiguration;\n+import com.netflix.config.ConfigurationManager;\n+import org.junit.After;\n import org.junit.Assert;\n import org.junit.Test;\n \n+import static org.junit.Assert.assertNotSame;\n+\n /**\n  * Created by jzarfoss on 2/12/14.\n  */\n public class InstanceInfoTest {\n+    @After\n+    public void tearDown() throws Exception {\n+        ((ConcurrentCompositeConfiguration) ConfigurationManager.getConfigInstance()).clearOverrideProperty(\"NETFLIX_APP_GROUP\");\n+        ((ConcurrentCompositeConfiguration) ConfigurationManager.getConfigInstance()).clearOverrideProperty(\"eureka.appGroup\");\n+    }\n \n     // contrived test to check copy constructor and verify behavior of builder for InstanceInfo\n \n@@ -23,7 +33,7 @@ public void testCopyConstructor(){\n         InstanceInfo smallII1 = InstanceInfo.Builder.newBuilder().setAppName(\"test\").setDataCenterInfo(myDCI).build();\n         InstanceInfo smallII2 = new InstanceInfo(smallII1);\n \n-        Assert.assertFalse(smallII1 == smallII2);\n+        assertNotSame(smallII1, smallII2);\n         Assert.assertEquals(smallII1, smallII2);\n \n \n@@ -43,11 +53,25 @@ public void testCopyConstructor(){\n \n         InstanceInfo fullII2 = new InstanceInfo(fullII1);\n \n-        Assert.assertFalse(fullII1 == fullII2);\n+        assertNotSame(fullII1, fullII2);\n         Assert.assertEquals(fullII1, fullII2);\n     }\n \n+    @Test\n+    public void testAppGroupNameSystemProp() throws Exception {\n+        String appGroup = \"testAppGroupSystemProp\";\n+        ((ConcurrentCompositeConfiguration) ConfigurationManager.getConfigInstance()).setOverrideProperty(\"NETFLIX_APP_GROUP\",\n+                                                                                                          appGroup);\n+        MyDataCenterInstanceConfig config = new MyDataCenterInstanceConfig();\n+        Assert.assertEquals(\"Unexpected app group name\" , appGroup, config.getAppGroupName());\n+    }\n \n-\n-\n+    @Test\n+    public void testAppGroupName() throws Exception {\n+        String appGroup = \"testAppGroup\";\n+        ((ConcurrentCompositeConfiguration) ConfigurationManager.getConfigInstance()).setOverrideProperty(\"eureka.appGroup\",\n+                                                                                                          appGroup);\n+        MyDataCenterInstanceConfig config = new MyDataCenterInstanceConfig();\n+        Assert.assertEquals(\"Unexpected app group name\" , appGroup, config.getAppGroupName());\n+    }\n }",
      "parent_sha": "5c9da77e88c1bc3ffbc9411ccae9c2cf048cf88e"
    }
  },
  {
    "oid": "6d7a1e126a9a4e329584235a56be8b2246e07e36",
    "message": "Resolve spinlock issue in AcceptorExecutor thread (#1303)",
    "date": "2020-06-10T18:55:29Z",
    "url": "https://github.com/Netflix/eureka/commit/6d7a1e126a9a4e329584235a56be8b2246e07e36",
    "details": {
      "sha": "42fadd872d6f0e0c81eb53885d37a73b5af9f16f",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/util/batcher/AcceptorExecutor.java",
      "status": "modified",
      "additions": 8,
      "deletions": 7,
      "changes": 15,
      "blob_url": "https://github.com/Netflix/eureka/blob/6d7a1e126a9a4e329584235a56be8b2246e07e36/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2Fbatcher%2FAcceptorExecutor.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/6d7a1e126a9a4e329584235a56be8b2246e07e36/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2Fbatcher%2FAcceptorExecutor.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2Fbatcher%2FAcceptorExecutor.java?ref=6d7a1e126a9a4e329584235a56be8b2246e07e36",
      "patch": "@@ -222,13 +222,14 @@ private void drainInputQueues() throws InterruptedException {\n                 drainReprocessQueue();\n                 drainAcceptorQueue();\n \n-                if (!isShutdown.get()) {\n-                    // If all queues are empty, block for a while on the acceptor queue\n-                    if (reprocessQueue.isEmpty() && acceptorQueue.isEmpty() && pendingTasks.isEmpty()) {\n-                        TaskHolder<ID, T> taskHolder = acceptorQueue.poll(10, TimeUnit.MILLISECONDS);\n-                        if (taskHolder != null) {\n-                            appendTaskHolder(taskHolder);\n-                        }\n+                if (isShutdown.get()) {\n+                    break;\n+                }\n+                // If all queues are empty, block for a while on the acceptor queue\n+                if (reprocessQueue.isEmpty() && acceptorQueue.isEmpty() && pendingTasks.isEmpty()) {\n+                    TaskHolder<ID, T> taskHolder = acceptorQueue.poll(10, TimeUnit.MILLISECONDS);\n+                    if (taskHolder != null) {\n+                        appendTaskHolder(taskHolder);\n                     }\n                 }\n             } while (!reprocessQueue.isEmpty() || !acceptorQueue.isEmpty() || pendingTasks.isEmpty());",
      "parent_sha": "f67ee5fcb0016bce968311a1ce63ef21a148e3c2"
    }
  },
  {
    "oid": "af015742403d42ef4c2c58d90271a6a3ef0ad534",
    "message": "method was renamed by test was not.",
    "date": "2016-08-31T07:58:42Z",
    "url": "https://github.com/Netflix/eureka/commit/af015742403d42ef4c2c58d90271a6a3ef0ad534",
    "details": {
      "sha": "0dc8aa6b99e130e5e8fa3055a42a6a4e778013f2",
      "filename": "eureka-client-archaius2/src/test/java/com/netflix/discovery/guice/EC2EurekaClientModuleTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/Netflix/eureka/blob/af015742403d42ef4c2c58d90271a6a3ef0ad534/eureka-client-archaius2%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fguice%2FEC2EurekaClientModuleTest.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/af015742403d42ef4c2c58d90271a6a3ef0ad534/eureka-client-archaius2%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fguice%2FEC2EurekaClientModuleTest.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client-archaius2%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fguice%2FEC2EurekaClientModuleTest.java?ref=af015742403d42ef4c2c58d90271a6a3ef0ad534",
      "patch": "@@ -53,7 +53,8 @@ protected void configureArchaius() {\n                         new EurekaClientModule() {\n                             @Override\n                             protected void configureEureka() {\n-                                bindEurekaConfigNamespace().toInstance(\"eureka.new\");\n+                                bindEurekaInstanceConfigNamespace().toInstance(\"eureka.new\");\n+                                bindEurekaClientConfigNamespace().toInstance(\"eureka.new\");\n                             }\n                         }\n                 )",
      "parent_sha": "c4eea826ea95b11793a50fb48459e8a224bef909"
    }
  },
  {
    "oid": "80bf99f3c6bf3218647349a86f3467144aed6f9b",
    "message": "Check for existence of ConfigurationManager (#1288)\n\nThis is useful if a project has excluded Archaius 1 such as spring-cloud-netflix. This is a simple workaround.",
    "date": "2020-04-30T22:19:05Z",
    "url": "https://github.com/Netflix/eureka/commit/80bf99f3c6bf3218647349a86f3467144aed6f9b",
    "details": {
      "sha": "44f2e14a174275fdcd7268d94c6ec973d7751ab2",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/util/StatusInfo.java",
      "status": "modified",
      "additions": 15,
      "deletions": 3,
      "changes": 18,
      "blob_url": "https://github.com/Netflix/eureka/blob/80bf99f3c6bf3218647349a86f3467144aed6f9b/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2FStatusInfo.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/80bf99f3c6bf3218647349a86f3467144aed6f9b/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2FStatusInfo.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2FStatusInfo.java?ref=80bf99f3c6bf3218647349a86f3467144aed6f9b",
      "patch": "@@ -7,7 +7,6 @@\n import java.util.HashMap;\n import java.util.Map;\n \n-import com.netflix.appinfo.ApplicationInfoManager;\n import com.netflix.appinfo.InstanceInfo;\n import com.netflix.config.ConfigurationManager;\n import com.netflix.discovery.provider.Serializer;\n@@ -23,6 +22,7 @@\n @XStreamAlias(\"status\")\n public class StatusInfo {\n     private static final String DATE_FORMAT = \"yyyy-MM-dd'T'HH:mm:ss Z\";\n+    private static final boolean ARCHAIUS_EXISTS = classExists(\"com.netflix.config.ConfigurationManager\");\n \n     public static final class Builder {\n \n@@ -68,8 +68,10 @@ public StatusInfo build() {\n             }\n \n             result.generalStats.put(\"server-uptime\", getUpTime());\n-            result.generalStats.put(\"environment\", ConfigurationManager\n-                    .getDeploymentContext().getDeploymentEnvironment());\n+            if (ARCHAIUS_EXISTS) {\n+                result.generalStats.put(\"environment\", ConfigurationManager\n+                        .getDeploymentContext().getDeploymentEnvironment());\n+            }\n \n             Runtime runtime = Runtime.getRuntime();\n             int totalMem = (int) (runtime.totalMemory() / 1048576);\n@@ -143,4 +145,14 @@ public static String getCurrentTimeAsString() {\n         SimpleDateFormat format = new SimpleDateFormat(DATE_FORMAT);\n         return format.format(new Date());\n     }\n+\n+    private static boolean classExists(String className) {\n+        try  {\n+            Class.forName(className);\n+            return true;\n+        }  catch (ClassNotFoundException e) {\n+            return false;\n+        }\n+    }\n+\n }",
      "parent_sha": "bf424b7732ff6dfcb31d55e81b3f16f797ce1eb0"
    }
  },
  {
    "oid": "eb2cd162f20f8f2a7edb60583a437e5e009580f7",
    "message": "fix some timing issues in test",
    "date": "2016-02-12T01:31:23Z",
    "url": "https://github.com/Netflix/eureka/commit/eb2cd162f20f8f2a7edb60583a437e5e009580f7",
    "details": {
      "sha": "99edacb22ccc4ae87723f766e5ebdba88f8f1771",
      "filename": "eureka-client/src/test/java/com/netflix/discovery/shared/transport/EurekaHttpClientsTest.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/Netflix/eureka/blob/eb2cd162f20f8f2a7edb60583a437e5e009580f7/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2FEurekaHttpClientsTest.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/eb2cd162f20f8f2a7edb60583a437e5e009580f7/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2FEurekaHttpClientsTest.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2FEurekaHttpClientsTest.java?ref=eb2cd162f20f8f2a7edb60583a437e5e009580f7",
      "patch": "@@ -159,7 +159,7 @@ public void testCompositeBootstrapResolver() throws Exception {\n         when(clientConfig.getRegion()).thenReturn(\"us-east-1\");\n \n         when(transportConfig.getWriteClusterVip()).thenReturn(vipAddress);\n-        when(transportConfig.getAsyncExecutorThreadPoolSize()).thenReturn(3);\n+        when(transportConfig.getAsyncExecutorThreadPoolSize()).thenReturn(4);\n         when(transportConfig.getAsyncResolverRefreshIntervalMs()).thenReturn(300);\n         when(transportConfig.getAsyncResolverWarmUpTimeoutMs()).thenReturn(200);\n \n@@ -195,10 +195,10 @@ public void testCompositeBootstrapResolver() throws Exception {\n             endpoints = resolver.getClusterEndpoints();\n             assertThat(endpoints.size(), equalTo(applications.getInstancesByVirtualHostName(vipAddress).size()));\n \n-            // wait for the third cycle that hits the app source\n+            // wait for the third cycle that triggers the mock http client (which is the third resolver cycle)\n             // for the third cycle we have mocked the application resolver to return null data so should fall back\n             // to calling the remote resolver again (which should return applications2)\n-            verify(applicationsSource, timeout(1000).times(3)).getApplications(anyInt(), eq(TimeUnit.SECONDS));\n+            verify(mockHttpClient, timeout(1000).times(3)).getVip(anyString());\n             endpoints = resolver.getClusterEndpoints();\n             assertThat(endpoints.size(), equalTo(applications2.getInstancesByVirtualHostName(vipAddress).size()));\n         } finally {",
      "parent_sha": "bd7b02e5860557d358920c94152b4a1b18ce9449"
    }
  },
  {
    "oid": "19a898cf056b0a45469bb28f208840154a3585f0",
    "message": "update deprecation message",
    "date": "2016-02-15T20:33:10Z",
    "url": "https://github.com/Netflix/eureka/commit/19a898cf056b0a45469bb28f208840154a3585f0",
    "details": {
      "sha": "5dc1a6f07191eb2e4054cb75b1f8e41b6ec8e0c0",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/shared/resolver/LegacyClusterResolver.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/Netflix/eureka/blob/19a898cf056b0a45469bb28f208840154a3585f0/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Fresolver%2FLegacyClusterResolver.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/19a898cf056b0a45469bb28f208840154a3585f0/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Fresolver%2FLegacyClusterResolver.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Fresolver%2FLegacyClusterResolver.java?ref=19a898cf056b0a45469bb28f208840154a3585f0",
      "patch": "@@ -30,7 +30,8 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * @deprecated as of 2016-02-11. Will be deleted in an upcoming release\n+ * @deprecated as of 2016-02-11. Will be deleted in an upcoming release.\n+ * See {@link com.netflix.discovery.shared.resolver.aws.ConfigClusterResolver} for replacement.\n  *\n  * Server resolver that mimics the behavior of the original implementation. Either DNS or server\n  * list resolvers are instantiated, and they can be swapped in runtime because of the dynamic configuration",
      "parent_sha": "fbcd7c6d47d3b70a211c4ff1498d537c13c94ed9"
    }
  },
  {
    "oid": "c97dcdd63c8f6d14f88aa542eb85196e642815b6",
    "message": "fix sessionClient's randomized sessions to be dynamic",
    "date": "2015-10-26T04:56:59Z",
    "url": "https://github.com/Netflix/eureka/commit/c97dcdd63c8f6d14f88aa542eb85196e642815b6",
    "details": {
      "sha": "b0da93d04f78e63c4ea5b7c94e2509f4821ecbfa",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/shared/transport/decorator/SessionedEurekaHttpClient.java",
      "status": "modified",
      "additions": 5,
      "deletions": 2,
      "changes": 7,
      "blob_url": "https://github.com/Netflix/eureka/blob/c97dcdd63c8f6d14f88aa542eb85196e642815b6/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2Fdecorator%2FSessionedEurekaHttpClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/c97dcdd63c8f6d14f88aa542eb85196e642815b6/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2Fdecorator%2FSessionedEurekaHttpClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2Fdecorator%2FSessionedEurekaHttpClient.java?ref=c97dcdd63c8f6d14f88aa542eb85196e642815b6",
      "patch": "@@ -46,24 +46,27 @@ public class SessionedEurekaHttpClient extends EurekaHttpClientDecorator {\n     private final String name;\n     private final EurekaHttpClientFactory clientFactory;\n     private final long sessionDurationMs;\n+    private volatile long currentSessionDurationMs;\n \n     private volatile long lastReconnectTimeStamp = -1;\n     private final AtomicReference<EurekaHttpClient> eurekaHttpClientRef = new AtomicReference<>();\n \n     public SessionedEurekaHttpClient(String name, EurekaHttpClientFactory clientFactory, long sessionDurationMs) {\n         this.name = name;\n         this.clientFactory = clientFactory;\n-        this.sessionDurationMs = randomizeSessionDuration(sessionDurationMs);\n+        this.sessionDurationMs = sessionDurationMs;\n+        this.currentSessionDurationMs = randomizeSessionDuration(sessionDurationMs);\n         Monitors.registerObject(name, this);\n     }\n \n     @Override\n     protected <R> EurekaHttpResponse<R> execute(RequestExecutor<R> requestExecutor) {\n         long now = System.currentTimeMillis();\n         long delay = now - lastReconnectTimeStamp;\n-        if (delay >= sessionDurationMs) {\n+        if (delay >= currentSessionDurationMs) {\n             logger.debug(\"Ending a session and starting anew\");\n             lastReconnectTimeStamp = now;\n+            currentSessionDurationMs = randomizeSessionDuration(sessionDurationMs);\n             TransportUtils.shutdown(eurekaHttpClientRef.getAndSet(null));\n         }\n ",
      "parent_sha": "0a43b889d65080f154795b641985efd34276e711"
    }
  },
  {
    "oid": "c316bcd547e3a851423578888242eaf1fafbac81",
    "message": "explicit imports",
    "date": "2023-11-08T17:15:35Z",
    "url": "https://github.com/Netflix/eureka/commit/c316bcd547e3a851423578888242eaf1fafbac81",
    "details": {
      "sha": "d8431730ce917260f653af0cc76d97b9ef925fcf",
      "filename": "eureka-client/src/test/java/com/netflix/appinfo/AmazonInfoTest.java",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/Netflix/eureka/blob/c316bcd547e3a851423578888242eaf1fafbac81/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FAmazonInfoTest.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/c316bcd547e3a851423578888242eaf1fafbac81/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FAmazonInfoTest.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FAmazonInfoTest.java?ref=c316bcd547e3a851423578888242eaf1fafbac81",
      "patch": "@@ -11,9 +11,13 @@\n \n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.anyInt;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.mockStatic;\n \n import static org.junit.Assert.assertEquals;\n-import static org.mockito.Mockito.*;\n+\n \n /**\n  * @author David Liu",
      "parent_sha": "4e35eb01207c51c0be3b9efb3b93b6d085c99934"
    }
  },
  {
    "oid": "f275b3c0d9346beaf4ee6e3bdeca2eed17c2f720",
    "message": "fix typo",
    "date": "2018-01-12T09:18:59Z",
    "url": "https://github.com/Netflix/eureka/commit/f275b3c0d9346beaf4ee6e3bdeca2eed17c2f720",
    "details": {
      "sha": "05d35a6c34b88f6b26826d7ea7ad2ddea6ec622d",
      "filename": "eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/eureka/blob/f275b3c0d9346beaf4ee6e3bdeca2eed17c2f720/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FPropertiesInstanceConfig.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/f275b3c0d9346beaf4ee6e3bdeca2eed17c2f720/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FPropertiesInstanceConfig.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FPropertiesInstanceConfig.java?ref=f275b3c0d9346beaf4ee6e3bdeca2eed17c2f720",
      "patch": "@@ -108,7 +108,7 @@ public int getNonSecurePort() {\n      */\n     @Override\n     public int getSecurePort() {\n-        return configInstance.getIntProperty(namespace + SECURE_PORT_KEY, super.getSecurePort()) .get();\n+        return configInstance.getIntProperty(namespace + SECURE_PORT_KEY, super.getSecurePort()).get();\n     }\n \n     /*",
      "parent_sha": "5e259c5a467f4b3bc9f872ee85a4090e9e5ded4d"
    }
  },
  {
    "oid": "ef87b44d6466cc3710ff3902d3f808fa9d32191e",
    "message": "Unbreak EurekaClientConfig interface compat (#1317)\n\nEurekaClientConfig is treated as stable backward-compat API as of couple of years ago, update it to preserve backward-compat. This un-does breaking contract change introduced by 6438fba.",
    "date": "2020-06-29T23:28:27Z",
    "url": "https://github.com/Netflix/eureka/commit/ef87b44d6466cc3710ff3902d3f808fa9d32191e",
    "details": {
      "sha": "a93d36dbbeb170f818bf59ba8a2dd9ece43cc096",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java",
      "status": "modified",
      "additions": 9,
      "deletions": 6,
      "changes": 15,
      "blob_url": "https://github.com/Netflix/eureka/blob/ef87b44d6466cc3710ff3902d3f808fa9d32191e/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FEurekaClientConfig.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/ef87b44d6466cc3710ff3902d3f808fa9d32191e/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FEurekaClientConfig.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FEurekaClientConfig.java?ref=ef87b44d6466cc3710ff3902d3f808fa9d32191e",
      "patch": "@@ -16,9 +16,10 @@\n \n package com.netflix.discovery;\n \n-import javax.annotation.Nullable;\n import java.util.List;\n \n+import javax.annotation.Nullable;\n+\n import com.google.inject.ImplementedBy;\n import com.netflix.discovery.shared.transport.EurekaTransportConfig;\n \n@@ -286,7 +287,7 @@ public interface EurekaClientConfig {\n     /**\n      * Indicates whether the client should explicitly unregister itself from the remote server\n      * on client shutdown.\n-     * \n+     *\n      * @return true if this instance should unregister with eureka on client shutdown, false otherwise\n      */\n     default boolean shouldUnregisterOnShutdown() {\n@@ -457,13 +458,15 @@ default boolean shouldUnregisterOnShutdown() {\n \n     /**\n      * If set to true, the {@link EurekaClient} initialization should throw an exception at constructor time\n-     * if an initial fetch of eureka registry information from the remote servers is unsuccessful.\n+     * if the initial fetch of eureka registry information from the remote servers is unsuccessful.\n      *\n-     * Note that if {@link #shouldFetchRegistry()} is set to false, then this config is a no-op\n+     * Note that if {@link #shouldFetchRegistry()} is set to false, then this config is a no-op.\n      *\n-     * @return true or false for whether the client initialization should enforce an initial fetch\n+     * @return true or false for whether the client initialization should enforce an initial fetch.\n      */\n-    boolean shouldEnforceFetchRegistryAtInit();\n+    default boolean shouldEnforceFetchRegistryAtInit() {\n+        return false;\n+    }\n \n     /**\n      * Indicates whether the client is only interested in the registry information for a single VIP.",
      "parent_sha": "5e266be6b22b776f90d4f7bf68ef47d94669a7d2"
    }
  },
  {
    "oid": "cf0f7520afba9bcd6073b0547a2b68a606eeaca1",
    "message": "Check for the existence of instance info before inititalizing.",
    "date": "2012-12-07T20:02:26Z",
    "url": "https://github.com/Netflix/eureka/commit/cf0f7520afba9bcd6073b0547a2b68a606eeaca1",
    "details": {
      "sha": "a07634603fa98e0e70e877bd4063102f4df8f868",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/DiscoveryManager.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/Netflix/eureka/blob/cf0f7520afba9bcd6073b0547a2b68a606eeaca1/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryManager.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/cf0f7520afba9bcd6073b0547a2b68a606eeaca1/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryManager.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryManager.java?ref=cf0f7520afba9bcd6073b0547a2b68a606eeaca1",
      "patch": "@@ -65,8 +65,10 @@ public void initComponent(EurekaInstanceConfig config,\n             EurekaClientConfig eurekaConfig) {\n         this.eurekaInstanceConfig = config;\n         this.eurekaClientConfig = eurekaConfig;\n-        // Initialize application info\n-        ApplicationInfoManager.getInstance().initComponent(config);\n+        if (ApplicationInfoManager.getInstance().getInfo() == null) {\n+            // Initialize application info\n+            ApplicationInfoManager.getInstance().initComponent(config);\n+        }\n         InstanceInfo info = ApplicationInfoManager.getInstance().getInfo();\n         discoveryClient = new DiscoveryClient(info, eurekaConfig);\n     }",
      "parent_sha": "11f45191cc0be9888941b77ade13ec5300650e2a"
    }
  },
  {
    "oid": "76ed462adfb1c4f51bd3a99f6c0cc3334d7d47d4",
    "message": "Some more javadoc changes.\nSome more javadoc changes.\nSome more javadoc changes.\nSome more javadoc changes.\nSome more javadoc changes.\nSome more javadoc changes.\nSome more javadoc changes.\nSome more javadoc changes.\nSome more javadoc changes.",
    "date": "2012-08-27T07:48:23Z",
    "url": "https://github.com/Netflix/eureka/commit/76ed462adfb1c4f51bd3a99f6c0cc3334d7d47d4",
    "details": {
      "sha": "0113b5b18d919c1b514229013bd4757a771a5045",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java",
      "status": "modified",
      "additions": 37,
      "deletions": 2,
      "changes": 39,
      "blob_url": "https://github.com/Netflix/eureka/blob/76ed462adfb1c4f51bd3a99f6c0cc3334d7d47d4/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FEurekaServerConfig.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/76ed462adfb1c4f51bd3a99f6c0cc3334d7d47d4/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FEurekaServerConfig.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FEurekaServerConfig.java?ref=76ed462adfb1c4f51bd3a99f6c0cc3334d7d47d4",
      "patch": "@@ -56,6 +56,10 @@ public interface EurekaServerConfig {\n      * Gets the number of times the server should try to bind to the candidate\n      * EIP.\n      * \n+     * <p>\n+     * <em>The changes are effective at runtime.</em>\n+     * </p>\n+     * \n      * @return the number of times the server should try to bind to the\n      *         candidate EIP.\n      */\n@@ -64,6 +68,9 @@ public interface EurekaServerConfig {\n     /**\n      * Gets the interval with which the server should check if the EIP is bound\n      * and should try to bind in the case if it is already not bound.\n+     * <p>\n+     * <em>The changes are effective at runtime.</em>\n+     * </p>\n      * \n      * @return the time in milliseconds.\n      */\n@@ -79,17 +86,24 @@ public interface EurekaServerConfig {\n      * {@link #getRenewalPercentThreshold()}, the server turns off expirations\n      * to avert danger.This will help the server in maintaining the registry\n      * information in case of network problems between client and the server.\n+     * <p>\n+     * <em>The changes are effective at runtime.</em>\n+     * </p>\n      * \n      * @return true to enable self preservation, false otherwise.\n      */\n     boolean shouldEnableSelfPreservation();\n \n     /**\n      * The minimum percentage of renewals that is expected from the clients in\n-     * the period specified by {@link #getRenewalThresholdUpdateIntervalMs()}. If\n-     * the renewals drop below the threshold, the expirations are disabled if\n+     * the period specified by {@link #getRenewalThresholdUpdateIntervalMs()}.\n+     * If the renewals drop below the threshold, the expirations are disabled if\n      * the {@link #shouldEnableSelfPreservation()} is enabled.\n      * \n+     * <p>\n+     * <em>The changes are effective at runtime.</em>\n+     * </p>\n+     * \n      * @return value between 0 and 1 indicating the percentage. For example,\n      *         <code>85%</code> will be specified as <code>0.85</code>.\n      */\n@@ -108,6 +122,9 @@ public interface EurekaServerConfig {\n      * nodes is updated. The user can use the DNS mechanism or dynamic\n      * configuration provided by {@link https://github.com/Netflix/archaius} to\n      * change the information dynamically.\n+     * <p>\n+     * <em>The changes are effective at runtime.</em>\n+     * </p>\n      * \n      * @return timer in milliseconds indicating the interval.\n      */\n@@ -116,6 +133,9 @@ public interface EurekaServerConfig {\n     /**\n      * Get the number of times the replication events should be retried with\n      * peers.\n+     * <p>\n+     * <em>The changes are effective at runtime.</em>\n+     * </p>\n      * \n      * @return the number of retries.\n      */\n@@ -132,6 +152,9 @@ public interface EurekaServerConfig {\n      * file descriptors in an AWS environment because of the way the AWS\n      * firewall works.\n      * </p>\n+     * <p>\n+     * <em>The changes are effective at runtime.</em>\n+     * </p>\n      * \n      * @return true to replicate if the peer node's status is\n      *         {@link InstanceStatus#UP}, false otherwise.\n@@ -141,6 +164,9 @@ public interface EurekaServerConfig {\n     /**\n      * Gets the interval with which the status information about peer nodes is\n      * updated.\n+     * <p>\n+     * <em>The changes are effective at runtime.</em>\n+     * </p>\n      * \n      * @return time in milliseconds indicating the interval.\n      */\n@@ -209,6 +235,9 @@ public interface EurekaServerConfig {\n      * This is specially important if the status is updated by the external\n      * process.\n      * </p>\n+     * <p>\n+     * <em>The changes are effective at runtime.</em>\n+     * </p>\n      * \n      * @return true, to retry indefinitely, false otherwise.\n      */\n@@ -272,6 +301,9 @@ public interface EurekaServerConfig {\n \n     /**\n      * Checks to see if the delta information can be served to client or not.\n+     * <p>\n+     * <em>The changes are effective at runtime.</em>\n+     * </p>\n      * \n      * @return true if the delta information is allowed to be served, false\n      *         otherwise.\n@@ -350,6 +382,9 @@ public interface EurekaServerConfig {\n \n     /**\n      * Checks whether to synchronize instances when timestamp differs.\n+     * <p>\n+     * <em>The changes are effective at runtime.</em>\n+     * </p>\n      * \n      * @return true, to synchronize, false otherwise.\n      */",
      "parent_sha": "002410dceff1d066a08e0f1819540dc2cb74f683"
    }
  },
  {
    "oid": "edc94a78f904fc51c59b9261e988617657479c21",
    "message": "Sleep during syncUp only if necessary\n\nFixes #753",
    "date": "2016-02-24T23:21:09Z",
    "url": "https://github.com/Netflix/eureka/commit/edc94a78f904fc51c59b9261e988617657479c21",
    "details": {
      "sha": "90340529d4560ce4707ff198bde9ab7e5639d36f",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/registry/PeerAwareInstanceRegistryImpl.java",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/Netflix/eureka/blob/edc94a78f904fc51c59b9261e988617657479c21/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fregistry%2FPeerAwareInstanceRegistryImpl.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/edc94a78f904fc51c59b9261e988617657479c21/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fregistry%2FPeerAwareInstanceRegistryImpl.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fregistry%2FPeerAwareInstanceRegistryImpl.java?ref=edc94a78f904fc51c59b9261e988617657479c21",
      "patch": "@@ -188,6 +188,14 @@ public int syncUp() {\n         int count = 0;\n \n         for (int i = 0; ((i < serverConfig.getRegistrySyncRetries()) && (count == 0)); i++) {\n+            if (i > 0) {\n+                try {\n+                    Thread.sleep(serverConfig.getRegistrySyncRetryWaitMs());\n+                } catch (InterruptedException e) {\n+                    logger.warn(\"Interrupted during registry transfer..\");\n+                    break;\n+                }\n+            }\n             Applications apps = eurekaClient.getApplications();\n             for (Application app : apps.getRegisteredApplications()) {\n                 for (InstanceInfo instance : app.getInstances()) {\n@@ -201,14 +209,6 @@ public int syncUp() {\n                     }\n                 }\n             }\n-            if (count == 0) {\n-                try {\n-                    Thread.sleep(serverConfig.getRegistrySyncRetryWaitMs());\n-                } catch (InterruptedException e) {\n-                    logger.warn(\"Interrupted during registry transfer..\");\n-                    break;\n-                }\n-            }\n         }\n         return count;\n     }",
      "parent_sha": "46968f2c0b89b7c7c9d8659514ff071b498dfab4"
    }
  },
  {
    "oid": "88b101b9dfe075a8d1a52c644677277eaaf66511",
    "message": "Comment update to Lease class",
    "date": "2015-06-05T21:23:12Z",
    "url": "https://github.com/Netflix/eureka/commit/88b101b9dfe075a8d1a52c644677277eaaf66511",
    "details": {
      "sha": "191eb30471a4b9d2e138f378db188e65da083ef8",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/lease/Lease.java",
      "status": "modified",
      "additions": 7,
      "deletions": 3,
      "changes": 10,
      "blob_url": "https://github.com/Netflix/eureka/blob/88b101b9dfe075a8d1a52c644677277eaaf66511/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Flease%2FLease.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/88b101b9dfe075a8d1a52c644677277eaaf66511/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Flease%2FLease.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Flease%2FLease.java?ref=88b101b9dfe075a8d1a52c644677277eaaf66511",
      "patch": "@@ -32,9 +32,7 @@ public class Lease<T> {\n \n     enum Action {\n         Register, Cancel, Renew\n-    }\n-\n-    ;\n+    };\n \n     public static final int DEFAULT_DURATION_IN_SECS = 90;\n \n@@ -92,6 +90,11 @@ public void setServiceUpTimestamp(long serviceUpTimestamp) {\n \n     /**\n      * Checks if the lease of a given {@link com.netflix.appinfo.InstanceInfo} has expired or not.\n+     *\n+     * Note that due to renew() doing the 'wrong\" thing and setting lastUpdateTimestamp to +duration more than\n+     * what it should be, the expiry will actually be 2 * duration. This is a minor bug and should only affect\n+     * instances that ungracefully shutdown. Due to possible wide ranging impact to existing usage, this will\n+     * not be fixed.\n      */\n     public boolean isExpired() {\n         return (evictionTimestamp > 0 || System.currentTimeMillis() > (lastUpdateTimestamp + duration));\n@@ -108,6 +111,7 @@ public long getRegistrationTimestamp() {\n \n     /**\n      * Gets the milliseconds since epoch when the lease was last renewed.\n+     * Note that the value returned here is actually not the last lease renewal time but the renewal + duration.\n      *\n      * @return the milliseconds since epoch when the lease was last renewed.\n      */",
      "parent_sha": "82f216c09e3f73410faba3b2f9d7c4cf64cea644"
    }
  },
  {
    "oid": "d6d1086098e7344c5974aa8e05bba3de7780b144",
    "message": "Fix formatting and CheckStyles naming in EurekaBootStrap",
    "date": "2014-04-29T12:49:20Z",
    "url": "https://github.com/Netflix/eureka/commit/d6d1086098e7344c5974aa8e05bba3de7780b144",
    "details": {
      "sha": "69cdd4bc5c226b9921cb7b33d155ecd5ad356058",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java",
      "status": "modified",
      "additions": 6,
      "deletions": 9,
      "changes": 15,
      "blob_url": "https://github.com/Netflix/eureka/blob/d6d1086098e7344c5974aa8e05bba3de7780b144/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FEurekaBootStrap.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/d6d1086098e7344c5974aa8e05bba3de7780b144/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FEurekaBootStrap.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FEurekaBootStrap.java?ref=d6d1086098e7344c5974aa8e05bba3de7780b144",
      "patch": "@@ -72,8 +72,7 @@ public class EurekaBootStrap implements ServletContextListener {\n \n     private static final String EUREKA_DATACENTER = \"eureka.datacenter\";\n \n-    private static final Logger logger = LoggerFactory\n-    .getLogger(EurekaBootStrap.class);\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaBootStrap.class);\n \n     private static final int EIP_BIND_SLEEP_TIME_MS = 1000;\n     private static final Timer timer = new Timer(\"Eureka-EIPBinder\", true);\n@@ -97,16 +96,15 @@ public void contextInitialized(ServletContextEvent event) {\n                     XStream.PRIORITY_VERY_HIGH);\n             InstanceInfo info = ApplicationInfoManager.getInstance().getInfo();\n \n-            PeerAwareInstanceRegistry registry = PeerAwareInstanceRegistry\n-            .getInstance();\n+            PeerAwareInstanceRegistry registry = PeerAwareInstanceRegistry.getInstance();\n \n             // Copy registry from neighboring eureka node\n             int registryCount = registry.syncUp();\n             registry.openForTraffic(registryCount);\n \n             // Only in AWS, enable the binding functionality\n             if (Name.Amazon.equals(info.getDataCenterInfo().getName())) {\n-                handleEIPbinding(registry);\n+                handleEIPBinding(registry);\n             }\n             // Initialize available remote registry\n             PeerAwareInstanceRegistry.getInstance().initRemoteRegionRegistry();\n@@ -143,8 +141,7 @@ protected void initEurekaEnvironment() {\n             ConfigurationManager.getConfigInstance().setProperty(\n                     ARCHAIUS_DEPLOYMENT_DATACENTER, dataCenter);\n         }\n-        String environment = ConfigurationManager.getConfigInstance()\n-        .getString(EUREKA_ENVIRONMENT);\n+        String environment = ConfigurationManager.getConfigInstance().getString(EUREKA_ENVIRONMENT);\n         if (environment == null) {\n             ConfigurationManager.getConfigInstance().setProperty(\n                     ARCHAIUS_DEPLOYMENT_ENVIRONMENT, TEST);\n@@ -176,7 +173,7 @@ public void contextDestroyed(ServletContextEvent event) {\n             // Unregister all MBeans associated w/ DSCounters\n             EurekaMonitors.shutdown();\n             for (int i = 0; i < EurekaServerConfigurationManager.getInstance()\n-            .getConfiguration().getEIPBindRebindRetries(); i++) {\n+                    .getConfiguration().getEIPBindRebindRetries(); i++) {\n                 try {\n                     if (Name.Amazon.equals(info.getDataCenterInfo().getName())) {\n                         EIPManager.getInstance().unbindEIP();\n@@ -210,7 +207,7 @@ protected void destroyEurekaEnvironment() {\n      *\n      * @throws InterruptedException\n      */\n-    private void handleEIPbinding(PeerAwareInstanceRegistry registry)\n+    private void handleEIPBinding(PeerAwareInstanceRegistry registry)\n     throws InterruptedException {\n         EurekaServerConfig eurekaServerConfig = EurekaServerConfigurationManager.getInstance().getConfiguration();\n         int retries = eurekaServerConfig.getEIPBindRebindRetries();",
      "parent_sha": "5dd41e913ce7688168e4b16bf25f1dbdba06af6b"
    }
  },
  {
    "oid": "e7da2a28b282549095442fa57885bca96934c58d",
    "message": "Some more fixes to allow non-AWS applications to deploy eureka.",
    "date": "2012-10-18T21:55:11Z",
    "url": "https://github.com/Netflix/eureka/commit/e7da2a28b282549095442fa57885bca96934c58d",
    "details": {
      "sha": "68f54e3e375e5f8e2bfd6f735af447e7d0fba0a3",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/Netflix/eureka/blob/e7da2a28b282549095442fa57885bca96934c58d/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FPeerAwareInstanceRegistry.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/e7da2a28b282549095442fa57885bca96934c58d/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FPeerAwareInstanceRegistry.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FPeerAwareInstanceRegistry.java?ref=e7da2a28b282549095442fa57885bca96934c58d",
      "patch": "@@ -345,7 +345,7 @@ public void openForTraffic(int count) {\n                 .getRenewalPercentThreshold());\n         logger.info(\"Got \"\n                 + count\n-                + \" instances from neighboring DS node.  Changing status to UP.\");\n+                + \" instances from neighboring DS node\");\n         logger.info(\"Renew threshold is: \" + numberOfRenewsPerMinThreshold);\n         this.startupTime = System.currentTimeMillis();\n         if (count > 0) {\n@@ -357,6 +357,10 @@ public void openForTraffic(int count) {\n             logger.info(\"Priming AWS connections for all replicas..\");\n             primeAwsReplicas();\n         }\n+        logger.info(\"Changing status to UP\");\n+        ApplicationInfoManager.getInstance().setInstanceStatus(\n+                InstanceStatus.UP);\n+        super.postInit();\n     }\n  \n     /**\n@@ -423,9 +427,6 @@ private void primeAwsReplicas() {\n                 }\n             }\n         }\n-        ApplicationInfoManager.getInstance().setInstanceStatus(\n-                InstanceStatus.UP);\n-        super.postInit();\n     }\n \n     /**\n@@ -995,8 +996,7 @@ private static boolean isPeerAliveInMyRegistery(String serviceUrl)\n                 .getApplication(myName);\n         List<InstanceInfo> instanceInfoList = app.getInstances();\n         for (InstanceInfo instanceInfo : instanceInfoList) {\n-            if (((AmazonInfo) instanceInfo.getDataCenterInfo()).get(\n-                    MetaDataKey.publicHostname).equalsIgnoreCase(uri.getHost())\n+            if (instanceInfo.getHostName().equalsIgnoreCase(uri.getHost())\n                     && (InstanceStatus.UP.equals(instanceInfo.getStatus()))) {\n                 return true;\n             }",
      "parent_sha": "ebb0c9258c1590771bd7abd2e1c2032716584760"
    }
  },
  {
    "oid": "2a91a1603907cc6de1ce2dc60199865f9b1e66b4",
    "message": "Backup registry configured via property is overridden with void implementation",
    "date": "2015-11-04T23:38:40Z",
    "url": "https://github.com/Netflix/eureka/commit/2a91a1603907cc6de1ce2dc60199865f9b1e66b4",
    "details": {
      "sha": "1e306a6cb90db41f82200768aafeee218e1185aa",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java",
      "status": "modified",
      "additions": 5,
      "deletions": 2,
      "changes": 7,
      "blob_url": "https://github.com/Netflix/eureka/blob/2a91a1603907cc6de1ce2dc60199865f9b1e66b4/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/2a91a1603907cc6de1ce2dc60199865f9b1e66b4/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java?ref=2a91a1603907cc6de1ce2dc60199865f9b1e66b4",
      "patch": "@@ -336,6 +336,7 @@ public synchronized BackupRegistry get() {\n                     if (null != backupRegistryClassName) {\n                         try {\n                             backupRegistryInstance = (BackupRegistry) Class.forName(backupRegistryClassName).newInstance();\n+                            logger.info(\"Enabled backup registry of type \" + backupRegistryInstance.getClass());\n                         } catch (InstantiationException e) {\n                             logger.error(\"Error instantiating BackupRegistry.\", e);\n                         } catch (IllegalAccessException e) {\n@@ -345,8 +346,10 @@ public synchronized BackupRegistry get() {\n                         }\n                     }\n \n-                    logger.warn(\"Using default backup registry implementation which does not do anything.\");\n-                    backupRegistryInstance = new NotImplementedRegistryImpl();\n+                    if(backupRegistryInstance == null) {\n+                        logger.warn(\"Using default backup registry implementation which does not do anything.\");\n+                        backupRegistryInstance = new NotImplementedRegistryImpl();\n+                    }\n                 }\n \n                 return backupRegistryInstance;",
      "parent_sha": "259ebbdae15ad26c2ceaa08db781cf4cc3f13d3e"
    }
  },
  {
    "oid": "e3c377b08c051ea2eba878b7a61e7dceb1a19436",
    "message": "Fix typo in EurekaInstanceConfig",
    "date": "2016-08-02T04:18:07Z",
    "url": "https://github.com/Netflix/eureka/commit/e3c377b08c051ea2eba878b7a61e7dceb1a19436",
    "details": {
      "sha": "2331f0ab15c61ad841ba4066d7ff50a601e74cb2",
      "filename": "eureka-client/src/main/java/com/netflix/appinfo/EurekaInstanceConfig.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/eureka/blob/e3c377b08c051ea2eba878b7a61e7dceb1a19436/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FEurekaInstanceConfig.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/e3c377b08c051ea2eba878b7a61e7dceb1a19436/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FEurekaInstanceConfig.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FEurekaInstanceConfig.java?ref=e3c377b08c051ea2eba878b7a61e7dceb1a19436",
      "patch": "@@ -84,7 +84,7 @@ public interface EurekaInstanceConfig {\n      * Get the <code>Secure port</code> on which the instance should receive\n      * traffic.\n      *\n-     * @return the non-secure port on which the instance should receive traffic.\n+     * @return the secure port on which the instance should receive traffic.\n      */\n     int getSecurePort();\n ",
      "parent_sha": "3331f413fe3efe7e83b544014cc5261c1c830d09"
    }
  },
  {
    "oid": "7ef6aaf79e9c56bc021393b2b77af53115acbd0d",
    "message": "Move TimedSupervisorTask logs to debug level as they are already\nmeasured by metrics.",
    "date": "2017-10-04T20:29:10Z",
    "url": "https://github.com/Netflix/eureka/commit/7ef6aaf79e9c56bc021393b2b77af53115acbd0d",
    "details": {
      "sha": "300e2eade1861a4f74c88e31ce75324ca398024b",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/TimedSupervisorTask.java",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/Netflix/eureka/blob/7ef6aaf79e9c56bc021393b2b77af53115acbd0d/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FTimedSupervisorTask.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/7ef6aaf79e9c56bc021393b2b77af53115acbd0d/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FTimedSupervisorTask.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FTimedSupervisorTask.java?ref=7ef6aaf79e9c56bc021393b2b77af53115acbd0d",
      "patch": "@@ -65,7 +65,7 @@ public void run() {\n             delay.set(timeoutMillis);\n             threadPoolLevelGauge.set((long) executor.getActiveCount());\n         } catch (TimeoutException e) {\n-            logger.error(\"task supervisor timed out\", e);\n+            logger.debug(\"task supervisor timed out\", e);\n             timeoutCounter.increment();\n \n             long currentDelay = delay.get();\n@@ -74,17 +74,17 @@ public void run() {\n \n         } catch (RejectedExecutionException e) {\n             if (executor.isShutdown() || scheduler.isShutdown()) {\n-                logger.warn(\"task supervisor shutting down, reject the task\", e);\n+                logger.debug(\"task supervisor shutting down, reject the task\", e);\n             } else {\n-                logger.error(\"task supervisor rejected the task\", e);\n+                logger.debug(\"task supervisor rejected the task\", e);\n             }\n \n             rejectedCounter.increment();\n         } catch (Throwable e) {\n             if (executor.isShutdown() || scheduler.isShutdown()) {\n-                logger.warn(\"task supervisor shutting down, can't accept the task\");\n+                logger.debug(\"task supervisor shutting down, can't accept the task\");\n             } else {\n-                logger.error(\"task supervisor threw an exception\", e);\n+                logger.debug(\"task supervisor threw an exception\", e);\n             }\n \n             throwableCounter.increment();",
      "parent_sha": "d2dbee8a79b3c6dd9b553eb3f702f7721797bcd6"
    }
  },
  {
    "oid": "f67ee5fcb0016bce968311a1ce63ef21a148e3c2",
    "message": "Improve map iteration in JerseyApplicationClient.java (resubmitted) (#1301)",
    "date": "2020-06-02T20:01:53Z",
    "url": "https://github.com/Netflix/eureka/commit/f67ee5fcb0016bce968311a1ce63ef21a148e3c2",
    "details": {
      "sha": "fe3b1e92fb194a31016383dae9b1a1fc9cd14cef",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/JerseyApplicationClient.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/eureka/blob/f67ee5fcb0016bce968311a1ce63ef21a148e3c2/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2Fjersey%2FJerseyApplicationClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/f67ee5fcb0016bce968311a1ce63ef21a148e3c2/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2Fjersey%2FJerseyApplicationClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2Fjersey%2FJerseyApplicationClient.java?ref=f67ee5fcb0016bce968311a1ce63ef21a148e3c2",
      "patch": "@@ -39,8 +39,8 @@ public JerseyApplicationClient(Client jerseyClient, String serviceUrl, Map<Strin\n     @Override\n     protected void addExtraHeaders(Builder webResource) {\n         if (additionalHeaders != null) {\n-            for (String key : additionalHeaders.keySet()) {\n-                webResource.header(key, additionalHeaders.get(key));\n+            for (Map.Entry<String, String> entry : additionalHeaders.entrySet()) {\n+                webResource.header(entry.getKey(), entry.getValue());\n             }\n         }\n     }",
      "parent_sha": "3410a72e74e8d97aa8c65d75b05026f295ad0fe0"
    }
  },
  {
    "oid": "8b3ee29df22b080f1aa141d70db22f624dde7b97",
    "message": "Fix a run-away loop.",
    "date": "2012-12-24T17:33:46Z",
    "url": "https://github.com/Netflix/eureka/commit/8b3ee29df22b080f1aa141d70db22f624dde7b97",
    "details": {
      "sha": "81bf2719428731d51534f32acc589d374ab2e2a2",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/eureka/blob/8b3ee29df22b080f1aa141d70db22f624dde7b97/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fcluster%2FPeerEurekaNode.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/8b3ee29df22b080f1aa141d70db22f624dde7b97/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fcluster%2FPeerEurekaNode.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fcluster%2FPeerEurekaNode.java?ref=8b3ee29df22b080f1aa141d70db22f624dde7b97",
      "patch": "@@ -570,7 +570,8 @@ public void process(List<ReplicationTask> tasks) {\n                 for (ReplicationTask task : tasks) {\n                     boolean done = true;\n                     do {\n-                        try {\n+                       done = true;\n+                       try {\n                             Object[] args = {\n                                     task.getAppName(),\n                                     task.getId(),\n@@ -583,6 +584,7 @@ public void process(List<ReplicationTask> tasks) {\n                                 logger.warn(\n                                         \"Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}\",\n                                         args);\n+                                \n                                 continue;\n                             }\n                             task.execute();",
      "parent_sha": "c9db99201fff0f6b22cc92bff18b36f52efe083f"
    }
  },
  {
    "oid": "4ac445cf224dc829440b1e29597c6968d4865e53",
    "message": "Minor tweaks to formatting.",
    "date": "2012-09-04T00:54:14Z",
    "url": "https://github.com/Netflix/eureka/commit/4ac445cf224dc829440b1e29597c6968d4865e53",
    "details": {
      "sha": "13973b799af07640ac4a6ddb72540a2cb9311fbf",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java",
      "status": "modified",
      "additions": 19,
      "deletions": 23,
      "changes": 42,
      "blob_url": "https://github.com/Netflix/eureka/blob/4ac445cf224dc829440b1e29597c6968d4865e53/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fcluster%2FPeerEurekaNode.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/4ac445cf224dc829440b1e29597c6968d4865e53/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fcluster%2FPeerEurekaNode.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fcluster%2FPeerEurekaNode.java?ref=4ac445cf224dc829440b1e29597c6968d4865e53",
      "patch": "@@ -248,48 +248,44 @@ public boolean heartbeat(String appName, String id, InstanceInfo info,\n     }\n \n     /**\n-     * Synchronize {@link InstanceInfo} information if the timestamp between this node and the peer eureka nodes vary.\n+     * Synchronize {@link InstanceInfo} information if the timestamp between\n+     * this node and the peer eureka nodes vary.\n      */\n     private void syncInstancesIfTimestampDiffers(String id, InstanceInfo info,\n             ClientResponse response) {\n         try {\n-            if (config.shouldSyncWhenTimestampDiffers()\n-                    && response.hasEntity()) {\n+            if (config.shouldSyncWhenTimestampDiffers() && response.hasEntity()) {\n                 InstanceInfo infoFromPeer = response\n                 .getEntity(InstanceInfo.class);\n                 if (infoFromPeer != null) {\n-                    Object[] args = {\n-                            id,\n-                            new Date(info.getLastDirtyTimestamp()),\n-                            new Date(\n-                                    infoFromPeer\n-                                    .getLastDirtyTimestamp()) };\n+                    Object[] args = { id, info.getLastDirtyTimestamp(),\n+\n+                            infoFromPeer.getLastDirtyTimestamp() };\n \n                     logger.warn(\n                             \"Peer wants us to take the instance information from it, since the timestamp differs,Id : {} My Timestamp : {}, Peer's timestamp: {}\",\n                             args);\n-                    Object[] args1 = { id, info.getOverriddenStatus(),\n-                            infoFromPeer.getOverriddenStatus() };\n-                    logger.warn(\n-                            \"Overridden Status info -id {}, mine {}, peer's {}\",\n-                            args1);\n-                    if ((infoFromPeer.getStatus() != null)\n-                            && !(InstanceStatus.UNKNOWN\n-                                    .equals(infoFromPeer.getStatus())))\n+                    if ((infoFromPeer.getOverriddenStatus() != null)\n+                            && !(InstanceStatus.UNKNOWN.equals(infoFromPeer\n+                                    .getOverriddenStatus()))) {\n+                        Object[] args1 = { id, info.getOverriddenStatus(),\n+                                infoFromPeer.getOverriddenStatus() };\n+                        logger.warn(\n+                                \"Overridden Status info -id {}, mine {}, peer's {}\",\n+                                args1);\n+\n                         PeerAwareInstanceRegistry.getInstance()\n-                        .storeOverriddenStatusIfRequired(\n-                                id,\n-                                infoFromPeer\n-                                .getOverriddenStatus());\n+                        .storeOverriddenStatusIfRequired(id,\n+                                infoFromPeer.getOverriddenStatus());\n+                    }\n                     PeerAwareInstanceRegistry.getInstance().register(\n                             infoFromPeer, true);\n \n                 }\n \n             }\n         } catch (Throwable e) {\n-            logger.warn(\n-                    \"Exception when trying to get information from peer :\",\n+            logger.warn(\"Exception when trying to get information from peer :\",\n                     e);\n         }\n     }",
      "parent_sha": "ca329b540f267f30aedef4f86fc96e49e4000179"
    }
  },
  {
    "oid": "950a7232acbed558ba29246f84fed4bdb3735f36",
    "message": "Tone down logging from info to debug",
    "date": "2015-05-30T01:42:49Z",
    "url": "https://github.com/Netflix/eureka/commit/950a7232acbed558ba29246f84fed4bdb3735f36",
    "details": {
      "sha": "8edda673702f2a5bae4882550c5ccd04c34d78c7",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java",
      "status": "modified",
      "additions": 6,
      "deletions": 3,
      "changes": 9,
      "blob_url": "https://github.com/Netflix/eureka/blob/950a7232acbed558ba29246f84fed4bdb3735f36/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FInstanceRegistry.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/950a7232acbed558ba29246f84fed4bdb3735f36/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FInstanceRegistry.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FInstanceRegistry.java?ref=950a7232acbed558ba29246f84fed4bdb3735f36",
      "patch": "@@ -673,6 +673,9 @@ public Applications getApplicationsFromMultipleRegions(String[] remoteRegions) {\n                     Applications remoteApps = remoteRegistry.getApplications();\n                     for (Application application : remoteApps.getRegisteredApplications()) {\n                         if (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) {\n+                            logger.info(\"Application {}  fetched from the remote region {}\",\n+                                    application.getName(), remoteRegion);\n+\n                             Application appInstanceTillNow = apps.getRegisteredApplications(application.getName());\n                             if (appInstanceTillNow == null) {\n                                 appInstanceTillNow = new Application(application.getName());\n@@ -682,9 +685,9 @@ public Applications getApplicationsFromMultipleRegions(String[] remoteRegions) {\n                                 appInstanceTillNow.addInstance(instanceInfo);\n                             }\n                         } else {\n-                            logger.info(\"Application {} not fetched from the remote region {} as there exists a \"\n-                                            + \"whitelist and this app is not in the whitelist.\", application.getName(),\n-                                    remoteRegion);\n+                            logger.debug(\"Application {} not fetched from the remote region {} as there exists a \"\n+                                            + \"whitelist and this app is not in the whitelist.\",\n+                                    application.getName(), remoteRegion);\n                         }\n                     }\n                 } else {",
      "parent_sha": "00a016c8446bad8323c3a7f9a4c5a536623e79b8"
    }
  },
  {
    "oid": "cce7548071dcb5ac90b1cacf605e1b43001203f5",
    "message": "ISSUE-218 Makes converter replacement char configurable thru config. Setup config in advance.",
    "date": "2014-11-27T07:19:21Z",
    "url": "https://github.com/Netflix/eureka/commit/cce7548071dcb5ac90b1cacf605e1b43001203f5",
    "details": {
      "sha": "0a3779f03b777c6cddfde2ac84a15dd0d7a98d49",
      "filename": "eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/Netflix/eureka/blob/cce7548071dcb5ac90b1cacf605e1b43001203f5/eureka-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Feureka%2FAbstractTester.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/cce7548071dcb5ac90b1cacf605e1b43001203f5/eureka-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Feureka%2FAbstractTester.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Feureka%2FAbstractTester.java?ref=cce7548071dcb5ac90b1cacf605e1b43001203f5",
      "patch": "@@ -10,6 +10,7 @@\n import com.netflix.config.ConfigurationManager;\n import com.netflix.discovery.DefaultEurekaClientConfig;\n import com.netflix.discovery.DiscoveryClient;\n+import com.netflix.discovery.DiscoveryManager;\n import com.netflix.discovery.shared.Application;\n import com.netflix.discovery.shared.Pair;\n import com.netflix.eureka.mock.MockRemoteEurekaServer;\n@@ -81,7 +82,10 @@ public Name getName() {\n                                                              \"http://localhost:\" + mockRemoteEurekaServer.getPort() +\n                                                              MockRemoteEurekaServer.EUREKA_API_BASE_PATH);\n \n-        client = new DiscoveryClient(builder.build(), new DefaultEurekaClientConfig());\n+        DefaultEurekaClientConfig config = new DefaultEurekaClientConfig();\n+        // setup config in advance, used in initialize converter\n+        DiscoveryManager.getInstance().setEurekaClientConfig(config);\n+        client = new DiscoveryClient(builder.build(), config);\n         ApplicationInfoManager.getInstance().initComponent(new MyDataCenterInstanceConfig());\n         registry = new PeerAwareInstanceRegistry() {\n ",
      "parent_sha": "aa26d7c227b64551aad47b5bdb90fd97b5714514"
    }
  },
  {
    "oid": "0a97f831e398a575dbab80f9ff69a1d8be907631",
    "message": "Fix typos in per-host config keys.",
    "date": "2015-05-11T00:47:45Z",
    "url": "https://github.com/Netflix/eureka/commit/0a97f831e398a575dbab80f9ff69a1d8be907631",
    "details": {
      "sha": "5aa42daf9a11d9f00257a2e3f01c177b78d0b84d",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/Netflix/eureka/blob/0a97f831e398a575dbab80f9ff69a1d8be907631/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FDefaultEurekaServerConfig.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/0a97f831e398a575dbab80f9ff69a1d8be907631/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FDefaultEurekaServerConfig.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FDefaultEurekaServerConfig.java?ref=0a97f831e398a575dbab80f9ff69a1d8be907631",
      "patch": "@@ -249,7 +249,7 @@ public int getPeerNodeTotalConnections() {\n     @Override\n     public int getPeerNodeTotalConnectionsPerHost() {\n         return configInstance.getIntProperty(\n-                namespace + \"peerNodeTotalConnections\", 500).get();\n+                namespace + \"peerNodeTotalConnectionsPerHost\", 500).get();\n     }\n \n     @Override\n@@ -312,8 +312,7 @@ public boolean shouldDisableDelta() {\n     public long getMaxIdleThreadInMinutesAgeForStatusReplication() {\n         return configInstance\n         .getLongProperty(\n-                namespace\n-                        + \"maxIdleThreadAgeInMinutesForStatusReplication\",\n+                namespace + \"maxIdleThreadAgeInMinutesForStatusReplication\",\n                 10).get();\n     }\n \n@@ -412,7 +411,7 @@ public int getRemoteRegionTotalConnections() {\n     @Override\n     public int getRemoteRegionTotalConnectionsPerHost() {\n         return configInstance.getIntProperty(\n-                namespace + \"remoteRegionTotalConnections\", 500).get();\n+                namespace + \"remoteRegionTotalConnectionsPerHost\", 500).get();\n     }\n \n     @Override",
      "parent_sha": "5e29810ca0d6ec848f7af742f375c7b15757a39d"
    }
  },
  {
    "oid": "5f57e111f27bcab9720532971985a8ee18b0a1d5",
    "message": "Fixing a flaky unit test",
    "date": "2015-06-17T23:16:09Z",
    "url": "https://github.com/Netflix/eureka/commit/5f57e111f27bcab9720532971985a8ee18b0a1d5",
    "details": {
      "sha": "c0c909cc786f809f46f7ca3afda0af281db007d9",
      "filename": "eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegisterUpdateTest.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/Netflix/eureka/blob/5f57e111f27bcab9720532971985a8ee18b0a1d5/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClientRegisterUpdateTest.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/5f57e111f27bcab9720532971985a8ee18b0a1d5/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClientRegisterUpdateTest.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClientRegisterUpdateTest.java?ref=5f57e111f27bcab9720532971985a8ee18b0a1d5",
      "patch": "@@ -49,10 +49,11 @@ public void tearDown() throws Exception {\n \n     @Test\n     public void registerUpdateLifecycleTest() throws Exception {\n+        Thread.sleep(1200);  // give some execution time (the allowed on-demand interval is 60/min)\n         applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UP);\n-        Thread.sleep(400);  // give some execution time\n+        Thread.sleep(1200);  // give some execution time\n         applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UNKNOWN);\n-        Thread.sleep(400);  // give some execution time\n+        Thread.sleep(1200);  // give some execution time\n         applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.DOWN);\n \n         Thread.sleep(2400);",
      "parent_sha": "6333151d6dbc1ae4e7c0eecc6b36163bb6a50d40"
    }
  },
  {
    "oid": "9c375edbfcc06789fd1d1432a53737e49f2269d2",
    "message": "correct counter for read time out",
    "date": "2018-02-10T02:48:06Z",
    "url": "https://github.com/Netflix/eureka/commit/9c375edbfcc06789fd1d1432a53737e49f2269d2",
    "details": {
      "sha": "ca077d7dae307d2626d1076405c69e9b908909de",
      "filename": "eureka-core/src/test/java/com/netflix/eureka/cluster/TestableHttpReplicationClient.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/eureka/blob/9c375edbfcc06789fd1d1432a53737e49f2269d2/eureka-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fcluster%2FTestableHttpReplicationClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/9c375edbfcc06789fd1d1432a53737e49f2269d2/eureka-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fcluster%2FTestableHttpReplicationClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fcluster%2FTestableHttpReplicationClient.java?ref=9c375edbfcc06789fd1d1432a53737e49f2269d2",
      "patch": "@@ -151,7 +151,7 @@ public EurekaHttpResponse<InstanceInfo> getInstance(String appName, String id) {\n     public EurekaHttpResponse<ReplicationListResponse> submitBatchUpdates(ReplicationList replicationList) {\n     \t\n         if (readTimeOutCounter.get() < readtimeOutRepeatCount) {\n-            networkFailureCounter.incrementAndGet();\n+            readTimeOutCounter.incrementAndGet();\n             throw new RuntimeException(new SocketTimeoutException(\"Read timed out\"));\n         }\n     \t",
      "parent_sha": "82a9e04d7d58ba981734fdd5a1138751c54b1018"
    }
  },
  {
    "oid": "2b52704cc67c90ce08b48090d67f47acddcb3f87",
    "message": "When priming connections, check for eureka peer renewal expiration before trying to indefinitely prime the instance.",
    "date": "2012-10-02T18:14:07Z",
    "url": "https://github.com/Netflix/eureka/commit/2b52704cc67c90ce08b48090d67f47acddcb3f87",
    "details": {
      "sha": "ade4901a9392f8dae958757b5b444b257a607bf7",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java",
      "status": "modified",
      "additions": 51,
      "deletions": 34,
      "changes": 85,
      "blob_url": "https://github.com/Netflix/eureka/blob/2b52704cc67c90ce08b48090d67f47acddcb3f87/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FPeerAwareInstanceRegistry.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/2b52704cc67c90ce08b48090d67f47acddcb3f87/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FPeerAwareInstanceRegistry.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FPeerAwareInstanceRegistry.java?ref=2b52704cc67c90ce08b48090d67f47acddcb3f87",
      "patch": "@@ -47,6 +47,7 @@\n import com.netflix.appinfo.ApplicationInfoManager;\n import com.netflix.appinfo.InstanceInfo;\n import com.netflix.appinfo.InstanceInfo.InstanceStatus;\n+import com.netflix.appinfo.LeaseInfo;\n import com.netflix.discovery.DiscoveryClient;\n import com.netflix.discovery.DiscoveryManager;\n import com.netflix.discovery.shared.Application;\n@@ -97,10 +98,10 @@ public class PeerAwareInstanceRegistry extends InstanceRegistry {\n     private static final int REGISTRY_SYNC_RETRY_MS = 30000;\n \n     private static final Logger logger = LoggerFactory\n-    .getLogger(PeerAwareInstanceRegistry.class);\n+            .getLogger(PeerAwareInstanceRegistry.class);\n \n     private static final EurekaServerConfig eurekaServerConfig = EurekaServerConfigurationManager\n-    .getInstance().getConfiguration();\n+            .getInstance().getConfiguration();\n     private static final String DICOVERY_FAILED_REPLICATION_AFTER_RETRY = \"FailedReplicationAfterRetry\";\n \n     private static final int REPL_RETRY_SLEEP_TIME_IN_MS = 40;\n@@ -141,12 +142,12 @@ public int compare(Application l, Application r) {\n     private Timer timer = new Timer(\n             \"ReplicaAwareInstanceRegistry - RenewalThresholdUpdater\", true);\n     private static final LoadingCache<String, Boolean> peerEurekaStatusCache = CacheBuilder\n-    .newBuilder()\n-    .initialCapacity(10)\n-    .expireAfterWrite(\n-            eurekaServerConfig\n-            .getPeerEurekaStatusRefreshTimeIntervalMs(),\n-            TimeUnit.MILLISECONDS)\n+            .newBuilder()\n+            .initialCapacity(10)\n+            .expireAfterWrite(\n+                    eurekaServerConfig\n+                            .getPeerEurekaStatusRefreshTimeIntervalMs(),\n+                    TimeUnit.MILLISECONDS)\n             .<String, Boolean> build(new CacheLoader<String, Boolean>() {\n                 public Boolean load(String serviceUrl) {\n                     try {\n@@ -176,7 +177,7 @@ public Boolean get(Object key) {\n     private static final PeerAwareInstanceRegistry instance = new PeerAwareInstanceRegistry();\n \n     private Counter failedReplicationAfterRetry = Monitors\n-    .newCounter(DICOVERY_FAILED_REPLICATION_AFTER_RETRY);\n+            .newCounter(DICOVERY_FAILED_REPLICATION_AFTER_RETRY);\n \n     PeerAwareInstanceRegistry() {\n         // Make it an atomic reference since this could be updated in the\n@@ -191,16 +192,16 @@ public Boolean get(Object key) {\n                     e);\n         }\n         ThreadFactory threadFactory = new ThreadFactoryBuilder()\n-        .setDaemon(false).setNameFormat(\"Eureka-Replication-Thread\")\n-        .build();\n+                .setDaemon(false).setNameFormat(\"Eureka-Replication-Thread\")\n+                .build();\n         // Thread pool used for replication\n         replicationExecutorPool = new ThreadPoolExecutor(eurekaServerConfig\n                 .getMinThreadsForReplication(), eurekaServerConfig\n                 .getMaxThreadsForReplication(), eurekaServerConfig\n                 .getMaxIdleThreadAgeInMinutesForReplication(),\n                 TimeUnit.MINUTES, new ArrayBlockingQueue<Runnable>(\n                         eurekaServerConfig.getMaxElementsInReplicationPool()),\n-                        threadFactory) {\n+                threadFactory) {\n         };\n         init();\n     }\n@@ -235,7 +236,7 @@ public void run() {\n             }\n \n         }, eurekaServerConfig.getRenewalThresholdUpdateIntervalMs(),\n-        eurekaServerConfig.getRenewalThresholdUpdateIntervalMs());\n+                eurekaServerConfig.getRenewalThresholdUpdateIntervalMs());\n     }\n \n     /**\n@@ -258,7 +259,7 @@ public void run() {\n \n                 }\n             }, eurekaServerConfig.getPeerEurekaNodesUpdateIntervalMs(),\n-            eurekaServerConfig.getPeerEurekaNodesUpdateIntervalMs());\n+                    eurekaServerConfig.getPeerEurekaNodesUpdateIntervalMs());\n \n         } catch (Exception e) {\n             throw new IllegalStateException(e);\n@@ -271,8 +272,8 @@ public void run() {\n     private void updatePeerEurekaNodes() {\n         InstanceInfo myInfo = ApplicationInfoManager.getInstance().getInfo();\n         List<String> replicaUrls = DiscoveryManager.getInstance()\n-        .getDiscoveryClient()\n-        .getDiscoveryServiceUrls(DiscoveryClient.getZone(myInfo));\n+                .getDiscoveryClient()\n+                .getDiscoveryServiceUrls(DiscoveryClient.getZone(myInfo));\n         List<PeerEurekaNode> replicaNodes = new ArrayList<PeerEurekaNode>();\n         for (String replicaUrl : replicaUrls) {\n             if (!isThisMe(replicaUrl)) {\n@@ -308,15 +309,16 @@ private void updatePeerEurekaNodes() {\n     public int syncUp() {\n         // Copy entire entry from neighboring DS node\n         LookupService lookupService = DiscoveryManager.getInstance()\n-        .getLookupService();\n+                .getLookupService();\n         int count = 0;\n \n         for (int i = 0; ((i < eurekaServerConfig.getRegistrySyncRetries()) && (count == 0)); i++) {\n             Applications apps = lookupService.getApplications();\n             for (Application app : apps.getRegisteredApplications()) {\n                 for (InstanceInfo instance : app.getInstances()) {\n                     try {\n-                        register(instance, instance.getLeaseInfo().getDurationInSecs(), true);\n+                        register(instance, instance.getLeaseInfo()\n+                                .getDurationInSecs(), true);\n                         count++;\n                     } catch (Throwable t) {\n                         logger.error(\"During DS init copy\", t);\n@@ -334,9 +336,9 @@ public int syncUp() {\n         }\n         return count;\n     }\n-    \n+\n     public void openForTraffic(int count) {\n-     // Renewals happen every 30 seconds and for a minute it should be a\n+        // Renewals happen every 30 seconds and for a minute it should be a\n         // factor of 2.\n         numberOfRenewsPerMinThreshold = (int) ((count * 2) * eurekaServerConfig\n                 .getRenewalPercentThreshold());\n@@ -348,12 +350,17 @@ public void openForTraffic(int count) {\n         if (count > 0) {\n             this.peerInstancesTransferEmptyOnStartup = false;\n         }\n-        // Sometimes when the eureka servers comes up, AWS firewall may not allow the network connections immediately.\n-        // This will cause the outbound connections to fail, but the inbound connections continue to work.\n-        // What this means is the clients would have switched to this node (after EIP binding) and so the other eureka\n-        // nodes will expire all instances that have been switched because of the lack of outgoing heartbeats from this instance.\n-        \n-        // The best protection in this scenario is to block and wait until we are able to ping all eureka nodes successfully atleast once.\n+        // Sometimes when the eureka servers comes up, AWS firewall may not\n+        // allow the network connections immediately.\n+        // This will cause the outbound connections to fail, but the inbound\n+        // connections continue to work.\n+        // What this means is the clients would have switched to this node\n+        // (after EIP binding) and so the other eureka\n+        // nodes will expire all instances that have been switched because of\n+        // the lack of outgoing heartbeats from this instance.\n+\n+        // The best protection in this scenario is to block and wait until we\n+        // are able to ping all eureka nodes successfully atleast once.\n         // Until then we won't open up the traffic.\n         boolean areAllPeerNodesPrimed = false;\n         while (!areAllPeerNodesPrimed) {\n@@ -365,7 +372,17 @@ public void openForTraffic(int count) {\n                 for (PeerEurekaNode node : peerEurekaNodes.get()) {\n                     for (InstanceInfo peerInstanceInfo : eurekaApps\n                             .getInstances()) {\n+                        LeaseInfo leaseInfo = peerInstanceInfo.getLeaseInfo();\n+                        // If the lease is expired - do not worry about priming\n+                        if (System.currentTimeMillis() > (leaseInfo\n+                                .getRenewalTimestamp() + (leaseInfo\n+                                .getDurationInSecs() * 1000))) {\n+                            continue;\n+                        }\n                         peerHostName = peerInstanceInfo.getHostName();\n+                        logger.info(\n+                                \"Trying to send heartbeat for the eureka server at {} to make sure the network channels are open\",\n+                                peerHostName);\n                         // Only try to contact the eureka nodes that are in this\n                         // instance's registry - because\n                         // the other instances may be legitimately down\n@@ -623,7 +640,7 @@ public InstanceInfo getNextServerFromEureka(String virtualHostname,\n     private void updateRenewalThreshold() {\n         try {\n             LookupService lookupService = DiscoveryManager.getInstance()\n-            .getLookupService();\n+                    .getLookupService();\n             Applications apps = lookupService.getApplications();\n             int count = 0;\n             for (Application app : apps.getRegisteredApplications()) {\n@@ -779,7 +796,7 @@ private void replicateToPeers(final Action action, final String appName,\n                     replicationExecutorPool.execute(new Runnable() {\n                         public void run() {\n                             int retryCounter = eurekaServerConfig\n-                            .getNumberOfReplicationRetries();\n+                                    .getNumberOfReplicationRetries();\n                             // If the url represents this host, do not replicate\n                             // to yourself.\n                             if (isThisMe(node.getServiceUrl())) {\n@@ -841,15 +858,15 @@ private void replicateInstanceActionsToPeers(final Action action,\n                 break;\n             case Heartbeat:\n                 InstanceStatus overriddenStatus = overriddenInstanceStatusMap\n-                .get(id);\n+                        .get(id);\n                 InstanceInfo infoFromRegistry = getInstanceByAppAndId(appName,\n                         id);\n                 if (!node.heartbeat(appName, id, infoFromRegistry,\n                         overriddenStatus)) {\n                     logger.warn(\n                             \"Cannot find instance id {} and hence replicating the instance with status {}\",\n                             infoFromRegistry.getId(), infoFromRegistry\n-                            .getStatus().toString());\n+                                    .getStatus().toString());\n                     if (infoFromRegistry != null) {\n                         node.register(infoFromRegistry);\n                     }\n@@ -878,7 +895,7 @@ private void replicateInstanceActionsToPeers(final Action action,\n                         newStatus, node, retryCounter);\n             } else {\n                 failedReplicationAfterRetry = Monitors\n-                .newCounter(DICOVERY_FAILED_REPLICATION_AFTER_RETRY);\n+                        .newCounter(DICOVERY_FAILED_REPLICATION_AFTER_RETRY);\n                 failedReplicationAfterRetry.increment();\n                 Object[] args_1 = { action.name(), serviceUrl, id };\n                 logger.error(\n@@ -952,12 +969,12 @@ private boolean isPeerAlive(String serviceUrl) {\n      * @throws URISyntaxException\n      */\n     private static boolean isPeerAliveInMyRegistery(String serviceUrl)\n-    throws URISyntaxException {\n+            throws URISyntaxException {\n         String myName = ApplicationInfoManager.getInstance().getInfo()\n-        .getAppName();\n+                .getAppName();\n         URI uri = new URI(serviceUrl);\n         Application app = PeerAwareInstanceRegistry.getInstance()\n-        .getApplication(myName);\n+                .getApplication(myName);\n         List<InstanceInfo> instanceInfoList = app.getInstances();\n         for (InstanceInfo instanceInfo : instanceInfoList) {\n             if (((AmazonInfo) instanceInfo.getDataCenterInfo()).get(",
      "parent_sha": "9393019e4a149d27c44a2b9380038d6c2dbb8c9b"
    }
  },
  {
    "oid": "59c6c059d8206888bcb5e040626a1ac3b984d676",
    "message": "Addressing some more comments",
    "date": "2013-02-27T00:32:35Z",
    "url": "https://github.com/Netflix/eureka/commit/59c6c059d8206888bcb5e040626a1ac3b984d676",
    "details": {
      "sha": "0550ac2183253dd0126a6f736ac4b661bfdf3b3c",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/resources/ResponseCache.java",
      "status": "modified",
      "additions": 22,
      "deletions": 8,
      "changes": 30,
      "blob_url": "https://github.com/Netflix/eureka/blob/59c6c059d8206888bcb5e040626a1ac3b984d676/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fresources%2FResponseCache.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/59c6c059d8206888bcb5e040626a1ac3b984d676/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fresources%2FResponseCache.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fresources%2FResponseCache.java?ref=59c6c059d8206888bcb5e040626a1ac3b984d676",
      "patch": "@@ -18,6 +18,7 @@\n \n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n+import java.util.Arrays;\n import java.util.Timer;\n import java.util.TimerTask;\n import java.util.concurrent.ConcurrentHashMap;\n@@ -179,8 +180,9 @@ public String get(final Key key) {\n      */\n     public byte[] getGZIP(Key key) {\n         Value payload = getValue(key);\n-        if (payload == null)\n+        if (payload == null) {\n             return null;\n+        }\n         return payload.getGzipped();\n     }\n \n@@ -351,31 +353,43 @@ private Value generatePayload(Key key) {\n     }\n \n     private Applications getApplicationsForVip(Key key, InstanceRegistry registry) {\n+        Object[] args = { key.getEntityType(), key.getName(), key.getVersion(), key.getType() };\n+        logger.debug(\n+                \"Retrieving applications from registry for key : {} {} {} {}\",\n+                args);\n         Applications toReturn = new Applications();\n         Applications applications = registry.getApplications();\n         for (Application application : applications.getRegisteredApplications()) {\n             Application appToAdd = null;\n             for (InstanceInfo instanceInfo : application.getInstances()) {\n                 String vipAddress;\n-                if (key.getEntityType() == Key.EntityType.VIP) {\n+                if (Key.EntityType.VIP.equals(key.getEntityType())) {\n                     vipAddress = instanceInfo.getVIPAddress();\n-                } else if (key.getEntityType() == Key.EntityType.SVIP) {\n+                } else if (Key.EntityType.SVIP.equals(key.getEntityType())) {\n                     vipAddress = instanceInfo.getSecureVipAddress();\n                 } else {\n                     // should not happen, but just in case.\n                     continue;\n                 }\n \n-                if (null != vipAddress && vipAddress.contains(key.getName())) { // Vip address can be comma-separated thats why we do contains.\n-                    if (null == appToAdd) {\n-                        appToAdd = new Application(application.getName());\n-                        toReturn.addApplication(appToAdd);\n+                if (null != vipAddress) {\n+                    String[] vipAddresses = vipAddress.split(\",\");\n+                    Arrays.sort(vipAddresses);\n+                    if (Arrays.binarySearch(vipAddresses, key.getName()) > 0) {\n+                        if (null == appToAdd) {\n+                            appToAdd = new Application(application.getName());\n+                            toReturn.addApplication(appToAdd);\n+                        }\n+                        appToAdd.addInstance(instanceInfo);\n                     }\n-                    appToAdd.addInstance(instanceInfo);\n                 }\n             }\n         }\n         toReturn.setAppsHashCode(toReturn.getReconcileHashCode());\n+        args = new Object[]{ key.getEntityType(), key.getName(), key.getVersion(), key.getType(), toReturn.getReconcileHashCode() };\n+        logger.debug(\n+                \"Retrieved applications from registry for key : {} {} {} {}, reconcile hashcode: {}\",\n+                args);\n         return toReturn;\n     }\n ",
      "parent_sha": "e2ab6f5aaab66c759a2cf5b28bc41a1db528b58d"
    }
  },
  {
    "oid": "6baa691fe7e1cdf3abe368e9f3d98dbabe2a1640",
    "message": "Fix a typo (#1308)",
    "date": "2020-06-22T20:09:51Z",
    "url": "https://github.com/Netflix/eureka/commit/6baa691fe7e1cdf3abe368e9f3d98dbabe2a1640",
    "details": {
      "sha": "b6715a52482ce5bb84aa945441f1868c94c5d8f4",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/StatusFilter.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/eureka/blob/6baa691fe7e1cdf3abe368e9f3d98dbabe2a1640/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FStatusFilter.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/6baa691fe7e1cdf3abe368e9f3d98dbabe2a1640/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FStatusFilter.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FStatusFilter.java?ref=6baa691fe7e1cdf3abe368e9f3d98dbabe2a1640",
      "patch": "@@ -60,8 +60,8 @@ public void doFilter(ServletRequest request, ServletResponse response,\n         InstanceInfo myInfo = ApplicationInfoManager.getInstance().getInfo();\n         InstanceStatus status = myInfo.getStatus();\n         if (status != InstanceStatus.UP && response instanceof HttpServletResponse) {\n-            HttpServletResponse httpRespone = (HttpServletResponse) response;\n-            httpRespone.sendError(SC_TEMPORARY_REDIRECT,\n+            HttpServletResponse httpResponse = (HttpServletResponse) response;\n+            httpResponse.sendError(SC_TEMPORARY_REDIRECT,\n                     \"Current node is currently not ready to serve requests -- current status: \"\n                             + status + \" - try another DS node: \");\n         }",
      "parent_sha": "6438fba6a42a6d2a1dd2e4cb48eab66c34bd0a21"
    }
  },
  {
    "oid": "4ebc94a25d81d4453ee26c3661e15b57347d5d9f",
    "message": "Increase client version number.",
    "date": "2015-04-07T05:30:05Z",
    "url": "https://github.com/Netflix/eureka/commit/4ebc94a25d81d4453ee26c3661e15b57347d5d9f",
    "details": {
      "sha": "19b901037e2d736eb05ec2488312bc6b55833d21",
      "filename": "eureka-client/src/main/java/com/netflix/appinfo/EurekaClientIdentity.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/eureka/blob/4ebc94a25d81d4453ee26c3661e15b57347d5d9f/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FEurekaClientIdentity.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/4ebc94a25d81d4453ee26c3661e15b57347d5d9f/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FEurekaClientIdentity.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FEurekaClientIdentity.java?ref=4ebc94a25d81d4453ee26c3661e15b57347d5d9f",
      "patch": "@@ -6,7 +6,7 @@\n public class EurekaClientIdentity extends AbstractEurekaIdentity {\n     public static final String DEFAULT_CLIENT_NAME = \"DefaultClient\";\n \n-    private final String clientVersion = \"1.0\";\n+    private final String clientVersion = \"1.1\";\n     private final String id;\n \n     public EurekaClientIdentity(String id) {",
      "parent_sha": "42498777a946b1ed4358bfa25aa2877e7402dedb"
    }
  },
  {
    "oid": "6b6a9201b8d08e397bbeecdee6a48afc1332e28c",
    "message": "Move the concatenation of constant variable PREFIX into the format string\n\nThe result is still a constant expression per section 15.28 of the JLS,\nso a runtime string concatenation is avoided.",
    "date": "2017-11-06T17:19:45Z",
    "url": "https://github.com/Netflix/eureka/commit/6b6a9201b8d08e397bbeecdee6a48afc1332e28c",
    "details": {
      "sha": "34656a974b1b364c1031ee4a9c29cc75cc53e947",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/eureka/blob/6b6a9201b8d08e397bbeecdee6a48afc1332e28c/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/6b6a9201b8d08e397bbeecdee6a48afc1332e28c/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java?ref=6b6a9201b8d08e397bbeecdee6a48afc1332e28c",
      "patch": "@@ -845,7 +845,7 @@ boolean renew() {\n             logger.debug(PREFIX + \"{} - Heartbeat status: {}\", appPathIdentifier, httpResponse.getStatusCode());\n             if (httpResponse.getStatusCode() == 404) {\n                 REREGISTER_COUNTER.increment();\n-                logger.info(\"{} - Re-registering apps/{}\", PREFIX + appPathIdentifier, instanceInfo.getAppName());\n+                logger.info(PREFIX + \"{} - Re-registering apps/{}\", appPathIdentifier, instanceInfo.getAppName());\n                 long timestamp = instanceInfo.setIsDirtyWithTime();\n                 boolean success = register();\n                 if (success) {",
      "parent_sha": "7d0271cbad7899058fd1679f8c597edb80f068d9"
    }
  },
  {
    "oid": "586a119624adc09f22e985a64d491f6342e099c6",
    "message": "Allow EIP binding if the current IP of the instance is null.\n\nIt's possible for myPublicIP to be null when eureka is restarted\nbecause unbinding an EIP on Amazon results in a null IP for the\ninstance for a few minutes. In that case, it's ok to rebind the\nnew EIP.",
    "date": "2013-08-29T17:22:20Z",
    "url": "https://github.com/Netflix/eureka/commit/586a119624adc09f22e985a64d491f6342e099c6",
    "details": {
      "sha": "63edc5310f223d0c4f63c88d19917ef280701a43",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/Netflix/eureka/blob/586a119624adc09f22e985a64d491f6342e099c6/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2FEIPManager.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/586a119624adc09f22e985a64d491f6342e099c6/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2FEIPManager.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2FEIPManager.java?ref=586a119624adc09f22e985a64d491f6342e099c6",
      "patch": "@@ -193,7 +193,12 @@ public String getCandidateEIP(String myInstanceId, String myZone, String myPubli\n         List<String> availableEIPList = new ArrayList<String>();\n         for (String eip : eipCandidates) {\n             String eipTrimmed = eip.trim();\n-            if (myPublicIP.equals(eipTrimmed)) {\n+            /* It's possible for myPublicIP to be null when eureka is restarted\n+             * because unbinding an EIP on Amazon results in a null IP for the\n+             * instance for a few minutes. In that case, it's ok to rebind the\n+             * new EIP.\n+             */\n+            if (myPublicIP != null && myPublicIP.equals(eipTrimmed)) {\n                 // Already associated to an EIP?\n                 logger.debug(\"Already bound to an EIP : \" + eip);\n                 return null;",
      "parent_sha": "a3aa590e9f77fc74d90ba662b2adc2ad7b3515be"
    }
  },
  {
    "oid": "b9009c0dfb46de0da6545b26dc928489d248e599",
    "message": "Refactored periodic registry update locking to:\n- use a better name for the generational counter\n- added additional fine grained locking around the getDelta code path\n  to ensure more correct synchronisation",
    "date": "2014-06-30T19:54:31Z",
    "url": "https://github.com/Netflix/eureka/commit/b9009c0dfb46de0da6545b26dc928489d248e599",
    "details": {
      "sha": "b5486640e4575bb835ae8494ebfb93781a7ae3b4",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java",
      "status": "modified",
      "additions": 61,
      "deletions": 28,
      "changes": 89,
      "blob_url": "https://github.com/Netflix/eureka/blob/b9009c0dfb46de0da6545b26dc928489d248e599/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/b9009c0dfb46de0da6545b26dc928489d248e599/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java?ref=b9009c0dfb46de0da6545b26dc928489d248e599",
      "patch": "@@ -146,6 +146,8 @@ public class DiscoveryClient implements LookupService {\n     private volatile AtomicReference<Applications> localRegionApps = new AtomicReference<Applications>();\n     private volatile Map<String, Applications> remoteRegionVsApps = new ConcurrentHashMap<String, Applications>();\n     private final Lock fetchRegistryUpdateLock = new ReentrantLock();\n+    // monotonically increasing generation counter to ensure stale threads do not reset registry to an older version\n+    private volatile AtomicLong fetchRegistryGeneration;\n \n     private InstanceInfo instanceInfo;\n     private String appPathIdentifier;\n@@ -207,6 +209,8 @@ public DiscoveryClient(InstanceInfo myInfo, EurekaClientConfig config, Discovery\n                     1, clientConfig.getCacheRefreshExecutorThreadPoolSize(), 0, TimeUnit.SECONDS,\n                     new SynchronousQueue<Runnable>());  // use direct handoff\n \n+            fetchRegistryGeneration = new AtomicLong(0);\n+\n             if (myInfo != null) {\n                 instanceInfo = myInfo;\n                 appPathIdentifier = instanceInfo.getAppName() + \"/\"\n@@ -743,14 +747,19 @@ private String getReconcileHashCode(Applications applications) {\n     }\n \n     /**\n-     * Gets the full registry information from the eureka server and stores it\n-     * locally.\n+     * Gets the full registry information from the eureka server and stores it locally.\n+     * When applying the full registry, the following flow is observed:\n+     *\n+     * if (update generation have not advanced (due to another thread))\n+     *   atomically set the registry to the new registry\n+     * fi\n      *\n      * @return the full registry information.\n      * @throws Throwable\n      *             on error.\n      */\n     private ClientResponse getAndStoreFullRegistry() throws Throwable {\n+        long currentUpdateGeneration = fetchRegistryGeneration.get();\n         ClientResponse response = makeRemoteCall(Action.Refresh);\n         logger.info(\"Getting all instance registry info from the eureka server\");\n \n@@ -761,12 +770,8 @@ private ClientResponse getAndStoreFullRegistry() throws Throwable {\n \n         if (apps == null) {\n             logger.error(\"The application is null for some reason. Not storing this information\");\n-        } else if (fetchRegistryUpdateLock.tryLock()) {\n-            try {\n-                localRegionApps.set(this.filterAndShuffle(apps));\n-            } finally {\n-                fetchRegistryUpdateLock.unlock();\n-            }\n+        } else if (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + 1)) {\n+            localRegionApps.set(this.filterAndShuffle(apps));\n         } else {\n             logger.warn(\"Not updating applications as another thread is updating it already\");\n         }\n@@ -775,12 +780,20 @@ private ClientResponse getAndStoreFullRegistry() throws Throwable {\n     }\n \n     /**\n-     * Get the delta registry information from the eureka server and update it locally\n+     * Get the delta registry information from the eureka server and update it locally.\n+     * When applying the delta, the following flow is observed:\n+     *\n+     * if (update generation have not advanced (due to another thread))\n+     *   atomically try to: update application with the delta and get reconcileHashCode\n+     *   abort entire processing otherwise\n+     *   do reconciliation if reconcileHashCode clash\n+     * fi\n      *\n      * @return the client response\n      * @throws Throwable on error\n      */\n     private ClientResponse getAndUpdateDelta(Applications applications) throws Throwable {\n+        long currentUpdateGeneration = fetchRegistryGeneration.get();\n         ClientResponse response = makeRemoteCall(Action.Refresh_Delta);\n \n         Applications delta = null;\n@@ -792,18 +805,23 @@ private ClientResponse getAndUpdateDelta(Applications applications) throws Throw\n                     + \"Hence got the full registry.\");\n             this.closeResponse(response);\n             response = getAndStoreFullRegistry();\n-        } else if (fetchRegistryUpdateLock.tryLock()) {\n-            try {\n-                updateDelta(delta);\n-                String reconcileHashCode = getReconcileHashCode(applications);\n-                // There is a diff in number of instances for some reason\n-                if ((!reconcileHashCode.equals(delta.getAppsHashCode()))\n-                        || clientConfig.shouldLogDeltaDiff()) {\n-                    response = reconcileAndLogDifference(response, delta,\n-                            reconcileHashCode);\n+        } else if (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + 1)) {\n+            String reconcileHashCode = \"\";\n+            if (fetchRegistryUpdateLock.tryLock()) {\n+                try {\n+                    updateDelta(delta);\n+                    reconcileHashCode = getReconcileHashCode(applications);\n+                } finally {\n+                    fetchRegistryUpdateLock.unlock();\n                 }\n-            } finally {\n-                fetchRegistryUpdateLock.unlock();\n+            } else {\n+                logger.warn(\"Cannot acquire update lock, aborting getAndUpdateDelta\");\n+                return response;\n+            }\n+            // There is a diff in number of instances for some reason\n+            if ((!reconcileHashCode.equals(delta.getAppsHashCode()))\n+                    || clientConfig.shouldLogDeltaDiff()) {\n+                response = reconcileAndLogDifference(response, delta, reconcileHashCode);  // this makes a remoteCall\n             }\n         } else {\n             logger.warn(\"Not updating application delta as another thread is updating it already\");\n@@ -824,8 +842,14 @@ private void logTotalInstances() {\n     }\n \n     /**\n-     * Reconcile the eureka server and client registry information and logs the\n-     * differences if any.\n+     * Reconcile the eureka server and client registry information and logs the differences if any.\n+     * When reconciling, the following flow is observed:\n+     *\n+     * make a remote call to the server for the full registry\n+     * calculate and log differences\n+     * if (update generation have not advanced (due to another thread))\n+     *   atomically set the registry to the new registry\n+     * fi\n      *\n      * @param response\n      *            the HTTP response after getting the full registry.\n@@ -845,8 +869,11 @@ private ClientResponse reconcileAndLogDifference(ClientResponse response,\n                 reconcileHashCode, delta.getAppsHashCode());\n \n         this.closeResponse(response);\n+\n+        long currentUpdateGeneration = fetchRegistryGeneration.get();\n         response = makeRemoteCall(Action.Refresh);\n         Applications serverApps = response.getEntity(Applications.class);\n+\n         try {\n             Map<String, List<String>> reconcileDiffMap = getApplications().getReconcileMapDiff(serverApps);\n             String reconcileString = \"\";\n@@ -861,12 +888,18 @@ private ClientResponse reconcileAndLogDifference(ClientResponse response,\n         } catch (Throwable e) {\n             logger.error(\"Could not calculate reconcile string \", e);\n         }\n-        localRegionApps.set(this.filterAndShuffle(serverApps));\n-        getApplications().setVersion(delta.getVersion());\n-        logger.warn(\n-                \"The Reconcile hashcodes after complete sync up, client : {}, server : {}.\",\n-                getApplications().getReconcileHashCode(),\n-                delta.getAppsHashCode());\n+\n+        if (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + 1)) {\n+            localRegionApps.set(this.filterAndShuffle(serverApps));\n+            getApplications().setVersion(delta.getVersion());\n+            logger.warn(\n+                    \"The Reconcile hashcodes after complete sync up, client : {}, server : {}.\",\n+                    getApplications().getReconcileHashCode(),\n+                    delta.getAppsHashCode());\n+        } else {\n+            logger.warn(\"Not setting the applications map as another thread has advanced the update generation\");\n+        }\n+\n         return response;\n     }\n ",
      "parent_sha": "be8cfd70a87484ca427aa665956f07fccab5b7cf"
    }
  },
  {
    "oid": "9c91374a546c8aede441b9871e51caaa64d4909a",
    "message": "Fixed a bug with missing \"break\" statement.",
    "date": "2012-12-24T20:14:01Z",
    "url": "https://github.com/Netflix/eureka/commit/9c91374a546c8aede441b9871e51caaa64d4909a",
    "details": {
      "sha": "fe20d3ef25e662885d66063094ea275b0217764d",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java",
      "status": "modified",
      "additions": 21,
      "deletions": 21,
      "changes": 42,
      "blob_url": "https://github.com/Netflix/eureka/blob/9c91374a546c8aede441b9871e51caaa64d4909a/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FPeerAwareInstanceRegistry.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/9c91374a546c8aede441b9871e51caaa64d4909a/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FPeerAwareInstanceRegistry.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FPeerAwareInstanceRegistry.java?ref=9c91374a546c8aede441b9871e51caaa64d4909a",
      "patch": "@@ -82,10 +82,10 @@ public class PeerAwareInstanceRegistry extends InstanceRegistry {\n     private static final int REGISTRY_SYNC_RETRY_MS = 30000;\n \n     private static final Logger logger = LoggerFactory\n-            .getLogger(PeerAwareInstanceRegistry.class);\n+    .getLogger(PeerAwareInstanceRegistry.class);\n \n     private static final EurekaServerConfig eurekaServerConfig = EurekaServerConfigurationManager\n-            .getInstance().getConfiguration();\n+    .getInstance().getConfiguration();\n     private static final String DICOVERY_FAILED_REPLICATION_AFTER_RETRY = \"FailedReplicationAfterRetry\";\n     private long startupTime = 0;\n \n@@ -168,7 +168,7 @@ public void run() {\n             }\n \n         }, eurekaServerConfig.getRenewalThresholdUpdateIntervalMs(),\n-                eurekaServerConfig.getRenewalThresholdUpdateIntervalMs());\n+        eurekaServerConfig.getRenewalThresholdUpdateIntervalMs());\n     }\n \n     /**\n@@ -191,7 +191,7 @@ public void run() {\n \n                 }\n             }, eurekaServerConfig.getPeerEurekaNodesUpdateIntervalMs(),\n-                    eurekaServerConfig.getPeerEurekaNodesUpdateIntervalMs());\n+            eurekaServerConfig.getPeerEurekaNodesUpdateIntervalMs());\n \n         } catch (Exception e) {\n             throw new IllegalStateException(e);\n@@ -204,8 +204,8 @@ public void run() {\n     private void updatePeerEurekaNodes() {\n         InstanceInfo myInfo = ApplicationInfoManager.getInstance().getInfo();\n         List<String> replicaUrls = DiscoveryManager.getInstance()\n-                .getDiscoveryClient()\n-                .getDiscoveryServiceUrls(DiscoveryClient.getZone(myInfo));\n+        .getDiscoveryClient()\n+        .getDiscoveryServiceUrls(DiscoveryClient.getZone(myInfo));\n         List<PeerEurekaNode> replicaNodes = new ArrayList<PeerEurekaNode>();\n         for (String replicaUrl : replicaUrls) {\n             if (!isThisMe(replicaUrl)) {\n@@ -249,7 +249,7 @@ private void updatePeerEurekaNodes() {\n     public int syncUp() {\n         // Copy entire entry from neighboring DS node\n         LookupService lookupService = DiscoveryManager.getInstance()\n-                .getLookupService();\n+        .getLookupService();\n         int count = 0;\n \n         for (int i = 0; ((i < eurekaServerConfig.getRegistrySyncRetries()) && (count == 0)); i++) {\n@@ -323,8 +323,8 @@ private void primeAwsReplicas() {\n             String peerHostName = null;\n             try {\n                 Application eurekaApps = this\n-                        .getApplication(ApplicationInfoManager.getInstance()\n-                                .getInfo().getAppName());\n+                .getApplication(ApplicationInfoManager.getInstance()\n+                        .getInfo().getAppName());\n                 if (eurekaApps == null) {\n                     areAllPeerNodesPrimed = true;\n                 }\n@@ -335,7 +335,7 @@ private void primeAwsReplicas() {\n                         // If the lease is expired - do not worry about priming\n                         if (System.currentTimeMillis() > (leaseInfo\n                                 .getRenewalTimestamp() + (leaseInfo\n-                                .getDurationInSecs() * 1000))) {\n+                                        .getDurationInSecs() * 1000))) {\n                             continue;\n                         }\n                         peerHostName = peerInstanceInfo.getHostName();\n@@ -581,7 +581,7 @@ public InstanceInfo getNextServerFromEureka(String virtualHostname,\n     private void updateRenewalThreshold() {\n         try {\n             LookupService lookupService = DiscoveryManager.getInstance()\n-                    .getLookupService();\n+            .getLookupService();\n             Applications apps = lookupService.getApplications();\n             int count = 0;\n             for (Application app : apps.getRegisteredApplications()) {\n@@ -690,10 +690,9 @@ private boolean isThisMe(String url) {\n      * traffic to this node.\n      * \n      */\n-    private void replicateToPeers(final Action action, final String appName,\n-            final String id, final InstanceInfo info /* optional */,\n-            final InstanceStatus newStatus /* optional */,\n-            final boolean isReplication) {\n+    private void replicateToPeers(Action action, String appName, String id,\n+            InstanceInfo info /* optional */,\n+            InstanceStatus newStatus /* optional */, boolean isReplication) {\n         Stopwatch tracer = action.getTimer().start();\n         try {\n \n@@ -725,9 +724,9 @@ private void replicateToPeers(final Action action, final String appName,\n      * replication traffic to this node.\n      * \n      */\n-    private void replicateInstanceActionsToPeers(final Action action,\n-            final String appName, final String id, final InstanceInfo info,\n-            final InstanceStatus newStatus, final PeerEurekaNode node) {\n+    private void replicateInstanceActionsToPeers(Action action, String appName,\n+            String id, InstanceInfo info, InstanceStatus newStatus,\n+            PeerEurekaNode node) {\n         try {\n             InstanceInfo infoFromRegistry = null;\n             CurrentRequestVersion.set(Version.V2);\n@@ -737,10 +736,11 @@ private void replicateInstanceActionsToPeers(final Action action,\n                 break;\n             case Heartbeat:\n                 InstanceStatus overriddenStatus = overriddenInstanceStatusMap\n-                        .get(id);\n+                .get(id);\n                 infoFromRegistry = getInstanceByAppAndId(appName, id);\n                 node.heartbeat(appName, id, infoFromRegistry, overriddenStatus,\n                         false);\n+                break;\n             case Register:\n                 node.register(info);\n                 break;\n@@ -753,7 +753,7 @@ private void replicateInstanceActionsToPeers(final Action action,\n         } catch (Throwable t) {\n             logger.error(\n                     \"Cannot replicate information to \" + node.getServiceUrl()\n-                            + \" for action \" + action.name(), t);\n+                    + \" for action \" + action.name(), t);\n         }\n     }\n \n@@ -771,7 +771,7 @@ private void replicateASGInfoToReplicaNodes(final String asgName,\n         } catch (Throwable e) {\n             logger.error(\n                     \"Cannot replicate ASG status information to \"\n-                            + node.getServiceUrl(), e);\n+                    + node.getServiceUrl(), e);\n         }\n \n     }",
      "parent_sha": "da7c75209e0a02e9713f54406e993205b814d748"
    }
  },
  {
    "oid": "bd7b02e5860557d358920c94152b4a1b18ce9449",
    "message": "do proper clean up for test",
    "date": "2016-02-12T01:16:56Z",
    "url": "https://github.com/Netflix/eureka/commit/bd7b02e5860557d358920c94152b4a1b18ce9449",
    "details": {
      "sha": "eedca1a45b84f0527e96f637dc160728319df881",
      "filename": "eureka-client/src/test/java/com/netflix/discovery/shared/transport/EurekaHttpClientsTest.java",
      "status": "modified",
      "additions": 62,
      "deletions": 44,
      "changes": 106,
      "blob_url": "https://github.com/Netflix/eureka/blob/bd7b02e5860557d358920c94152b4a1b18ce9449/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2FEurekaHttpClientsTest.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/bd7b02e5860557d358920c94152b4a1b18ce9449/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2FEurekaHttpClientsTest.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2FEurekaHttpClientsTest.java?ref=bd7b02e5860557d358920c94152b4a1b18ce9449",
      "patch": "@@ -71,14 +71,15 @@\n public class EurekaHttpClientsTest {\n \n     private static final InstanceInfo MY_INSTANCE = InstanceInfoGenerator.newBuilder(1, \"myApp\").build().first();\n-    private final EurekaClientConfig clientConfig = mock(EurekaClientConfig.class);\n-    private final EurekaTransportConfig transportConfig = mock(EurekaTransportConfig.class);\n     private final EurekaInstanceConfig instanceConfig = mock(EurekaInstanceConfig.class);\n     private final ApplicationInfoManager applicationInfoManager = new ApplicationInfoManager(instanceConfig, MY_INSTANCE);\n \n     private final EurekaHttpClient writeRequestHandler = mock(EurekaHttpClient.class);\n     private final EurekaHttpClient readRequestHandler = mock(EurekaHttpClient.class);\n \n+    private EurekaClientConfig clientConfig;\n+    private EurekaTransportConfig transportConfig;\n+\n     private SimpleEurekaHttpServer writeServer;\n     private SimpleEurekaHttpServer readServer;\n \n@@ -91,6 +92,9 @@ public class EurekaHttpClientsTest {\n \n     @Before\n     public void setUp() throws IOException {\n+        clientConfig = mock(EurekaClientConfig.class);\n+        transportConfig = mock(EurekaTransportConfig.class);\n+\n         when(clientConfig.getEurekaServerTotalConnectionsPerHost()).thenReturn(10);\n         when(clientConfig.getEurekaServerTotalConnections()).thenReturn(10);\n         when(transportConfig.getSessionedClientReconnectIntervalSeconds()).thenReturn(10);\n@@ -173,28 +177,35 @@ public void testCompositeBootstrapResolver() throws Exception {\n         TransportClientFactory transportClientFactory = mock(TransportClientFactory.class);\n         when(transportClientFactory.newClient(any(EurekaEndpoint.class))).thenReturn(mockHttpClient);\n \n-        ClosableResolver<AwsEndpoint> resolver = EurekaHttpClients.compositeBootstrapResolver(\n-                clientConfig,\n-                transportConfig,\n-                transportClientFactory,\n-                applicationInfoManager.getInfo(),\n-                applicationsSource\n-        );\n-\n-        List endpoints = resolver.getClusterEndpoints();\n-        assertThat(endpoints.size(), equalTo(applications.getInstancesByVirtualHostName(vipAddress).size()));\n-\n-        // wait for the second cycle that hits the app source\n-        verify(applicationsSource, timeout(1000).times(2)).getApplications(anyInt(), eq(TimeUnit.SECONDS));\n-        endpoints = resolver.getClusterEndpoints();\n-        assertThat(endpoints.size(), equalTo(applications.getInstancesByVirtualHostName(vipAddress).size()));\n-\n-        // wait for the third cycle that hits the app source\n-        // for the third cycle we have mocked the application resolver to return null data so should fall back\n-        // to calling the remote resolver again (which should return applications2)\n-        verify(applicationsSource, timeout(1000).times(3)).getApplications(anyInt(), eq(TimeUnit.SECONDS));\n-        endpoints = resolver.getClusterEndpoints();\n-        assertThat(endpoints.size(), equalTo(applications2.getInstancesByVirtualHostName(vipAddress).size()));\n+        ClosableResolver<AwsEndpoint> resolver = null;\n+        try {\n+            resolver = EurekaHttpClients.compositeBootstrapResolver(\n+                    clientConfig,\n+                    transportConfig,\n+                    transportClientFactory,\n+                    applicationInfoManager.getInfo(),\n+                    applicationsSource\n+            );\n+\n+            List endpoints = resolver.getClusterEndpoints();\n+            assertThat(endpoints.size(), equalTo(applications.getInstancesByVirtualHostName(vipAddress).size()));\n+\n+            // wait for the second cycle that hits the app source\n+            verify(applicationsSource, timeout(1000).times(2)).getApplications(anyInt(), eq(TimeUnit.SECONDS));\n+            endpoints = resolver.getClusterEndpoints();\n+            assertThat(endpoints.size(), equalTo(applications.getInstancesByVirtualHostName(vipAddress).size()));\n+\n+            // wait for the third cycle that hits the app source\n+            // for the third cycle we have mocked the application resolver to return null data so should fall back\n+            // to calling the remote resolver again (which should return applications2)\n+            verify(applicationsSource, timeout(1000).times(3)).getApplications(anyInt(), eq(TimeUnit.SECONDS));\n+            endpoints = resolver.getClusterEndpoints();\n+            assertThat(endpoints.size(), equalTo(applications2.getInstancesByVirtualHostName(vipAddress).size()));\n+        } finally {\n+            if (resolver != null) {\n+                resolver.shutdown();\n+            }\n+        }\n     }\n \n     @Test\n@@ -225,26 +236,33 @@ public void testCanonicalResolver() throws Exception {\n         ApplicationsResolver localResolver = spy(new ApplicationsResolver(\n                 clientConfig, transportConfig, applicationsSource, transportConfig.getReadClusterVip()));\n \n-        ClosableResolver resolver = EurekaHttpClients.compositeQueryResolver(\n-                remoteResolver,\n-                localResolver,\n-                clientConfig,\n-                transportConfig,\n-                applicationInfoManager.getInfo()\n-        );\n-\n-        List endpoints = resolver.getClusterEndpoints();\n-        assertThat(endpoints.size(), equalTo(applications.getInstancesByVirtualHostName(vipAddress).size()));\n-        verify(remoteResolver, times(1)).getClusterEndpoints();\n-        verify(localResolver, times(1)).getClusterEndpoints();\n-\n-        // wait for the second cycle that hits the app source\n-        verify(applicationsSource, timeout(1000).times(2)).getApplications(anyInt(), eq(TimeUnit.SECONDS));\n-        endpoints = resolver.getClusterEndpoints();\n-        assertThat(endpoints.size(), equalTo(applications.getInstancesByVirtualHostName(vipAddress).size()));\n-\n-        verify(remoteResolver, times(1)).getClusterEndpoints();\n-        verify(localResolver, times(2)).getClusterEndpoints();\n+        ClosableResolver resolver = null;\n+        try {\n+            resolver = EurekaHttpClients.compositeQueryResolver(\n+                    remoteResolver,\n+                    localResolver,\n+                    clientConfig,\n+                    transportConfig,\n+                    applicationInfoManager.getInfo()\n+            );\n+\n+            List endpoints = resolver.getClusterEndpoints();\n+            assertThat(endpoints.size(), equalTo(applications.getInstancesByVirtualHostName(vipAddress).size()));\n+            verify(remoteResolver, times(1)).getClusterEndpoints();\n+            verify(localResolver, times(1)).getClusterEndpoints();\n+\n+            // wait for the second cycle that hits the app source\n+            verify(applicationsSource, timeout(1000).times(2)).getApplications(anyInt(), eq(TimeUnit.SECONDS));\n+            endpoints = resolver.getClusterEndpoints();\n+            assertThat(endpoints.size(), equalTo(applications.getInstancesByVirtualHostName(vipAddress).size()));\n+\n+            verify(remoteResolver, times(1)).getClusterEndpoints();\n+            verify(localResolver, times(2)).getClusterEndpoints();\n+        } finally {\n+            if (resolver != null) {\n+                resolver.shutdown();\n+            }\n+        }\n     }\n \n     @Test",
      "parent_sha": "32eed8091937e7afaaf33ddc687aedbea62ec3c9"
    }
  },
  {
    "oid": "32eed8091937e7afaaf33ddc687aedbea62ec3c9",
    "message": "comment update",
    "date": "2016-02-12T00:26:38Z",
    "url": "https://github.com/Netflix/eureka/commit/32eed8091937e7afaaf33ddc687aedbea62ec3c9",
    "details": {
      "sha": "0816984c46a5f9a740542cc120a15c7ca682e3d9",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/shared/transport/EurekaHttpClients.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/Netflix/eureka/blob/32eed8091937e7afaaf33ddc687aedbea62ec3c9/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2FEurekaHttpClients.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/32eed8091937e7afaaf33ddc687aedbea62ec3c9/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2FEurekaHttpClients.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2Ftransport%2FEurekaHttpClients.java?ref=32eed8091937e7afaaf33ddc687aedbea62ec3c9",
      "patch": "@@ -153,8 +153,8 @@ static ClosableResolver<AwsEndpoint> defaultBootstrapResolver(final EurekaClient\n     }\n \n     /**\n-     * @return a bootstrap resolver that resolves eureka server endpoints based on either DNS or static config,\n-     *         depending on configuration for one or the other. This resolver will warm up at the start.\n+     * @return a bootstrap resolver that resolves eureka server endpoints via a remote call to a \"vip source\"\n+     *         the local registry, where the source is found from a rootResolver (dns or config)\n      */\n     static ClosableResolver<AwsEndpoint> compositeBootstrapResolver(\n             final EurekaClientConfig clientConfig,",
      "parent_sha": "dde3e5a2c92c8a45a4af2b9e1c8d7bcc213c505b"
    }
  },
  {
    "oid": "ee2e003cff781a87f1ca855eb5a38bec79218263",
    "message": "Changes to EIPManager to get the eip list from the discovery client instead of its own registry.",
    "date": "2012-08-27T22:00:24Z",
    "url": "https://github.com/Netflix/eureka/commit/ee2e003cff781a87f1ca855eb5a38bec79218263",
    "details": {
      "sha": "4c4839fb5d932da0918334f93a2849069503996f",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/eureka/blob/ee2e003cff781a87f1ca855eb5a38bec79218263/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2FEIPManager.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/ee2e003cff781a87f1ca855eb5a38bec79218263/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2FEIPManager.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2FEIPManager.java?ref=ee2e003cff781a87f1ca855eb5a38bec79218263",
      "patch": "@@ -200,7 +200,7 @@ public String getCandidateEIP(String myInstanceId, String myZone,\n         // Look for unused EIPs\n         InstanceInfo instanceInfo = ApplicationInfoManager.getInstance()\n         .getInfo();\n-        Application app = PeerAwareInstanceRegistry.getInstance()\n+        Application app = DiscoveryManager.getInstance().getDiscoveryClient()\n         .getApplication(instanceInfo.getAppName());\n \n         if (app != null) {",
      "parent_sha": "76ed462adfb1c4f51bd3a99f6c0cc3334d7d47d4"
    }
  },
  {
    "oid": "fc88abe6371c28d5538653687a7800c6f23bee5d",
    "message": "log msg fix",
    "date": "2016-02-12T03:47:45Z",
    "url": "https://github.com/Netflix/eureka/commit/fc88abe6371c28d5538653687a7800c6f23bee5d",
    "details": {
      "sha": "fe5599ead032bd88313e88e23ed5763da3161d6f",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/eureka/blob/fc88abe6371c28d5538653687a7800c6f23bee5d/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2FApplications.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/fc88abe6371c28d5538653687a7800c6f23bee5d/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2FApplications.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2FApplications.java?ref=fc88abe6371c28d5538653687a7800c6f23bee5d",
      "patch": "@@ -299,7 +299,7 @@ public Map<String, List<String>> getReconcileMapDiff(Applications apps) {\n         for (Application otherApp : apps.getRegisteredApplications()) {\n             Application thisApp = this.getRegisteredApplications(otherApp.getName());\n             if (thisApp == null) {\n-                logger.warn(\"The application %s is not found in local cache :\", otherApp.getName());\n+                logger.warn(\"Application not found in local cache : {}\", otherApp.getName());\n                 continue;\n             }\n             for (InstanceInfo instanceInfo : thisApp.getInstancesAsIsFromEureka()) {",
      "parent_sha": "af1b15e35c775071ceac0240430eee83e741e75b"
    }
  },
  {
    "oid": "4ecb8bcaae7f84df2ab776447b4f5596c5b4a917",
    "message": "Forgot to use ProxyCustomApacheHttpClientConfig to provide the client\nconfiguration in EurekaJerseyClient.createProxyJerseyClient when I\ninitially refactored this.",
    "date": "2014-10-30T17:06:08Z",
    "url": "https://github.com/Netflix/eureka/commit/4ecb8bcaae7f84df2ab776447b4f5596c5b4a917",
    "details": {
      "sha": "a8ec8ef82ab12ed0535cbe0cee69254e0f520853",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java",
      "status": "modified",
      "additions": 21,
      "deletions": 19,
      "changes": 40,
      "blob_url": "https://github.com/Netflix/eureka/blob/4ecb8bcaae7f84df2ab776447b4f5596c5b4a917/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2FEurekaJerseyClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/4ecb8bcaae7f84df2ab776447b4f5596c5b4a917/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2FEurekaJerseyClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2Fshared%2FEurekaJerseyClient.java?ref=4ecb8bcaae7f84df2ab776447b4f5596c5b4a917",
      "patch": "@@ -119,26 +119,15 @@ public static JerseyClient createJerseyClient(String clientName, int connectionT\n      * @return - The jersey client object encapsulating the connection\n      */\n     public static JerseyClient createProxyJerseyClient(String clientName, int connectionTimeout,\n-      int readTimeout, int maxConnectionsPerHost, int maxTotalConnections, int connectionIdleTimeout, \n-      String proxyHost, String proxyPort, String proxyUserName, String proxyPassword) {\n+            int readTimeout, int maxConnectionsPerHost, int maxTotalConnections, int connectionIdleTimeout, \n+            String proxyHost, String proxyPort, String proxyUserName, String proxyPassword) {\n       Preconditions.checkNotNull(clientName, \"Client name can not be null.\");\n       try {\n-          ClientConfig jerseyClientConfig = new CustomApacheHttpClientConfig(clientName, maxConnectionsPerHost,\n-            maxTotalConnections);\n-          if (proxyUserName != null && proxyPassword != null) {\n-            jerseyClientConfig.getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_USERNAME, proxyUserName);\n-            jerseyClientConfig.getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_PASSWORD, proxyPassword);\n-          } else {\n-            // Due to bug in apache client, user name/password must always be set.\n-            // Otherwise proxy configuration is ignored.\n-            jerseyClientConfig.getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_USERNAME, \"guest\");\n-            jerseyClientConfig.getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_PASSWORD, \"guest\");\n-          }\n-          jerseyClientConfig.getProperties().put(\n-                  DefaultApacheHttpClient4Config.PROPERTY_PROXY_URI,\n-                  \"http://\" + proxyHost + \":\" + proxyPort);\n-          return new JerseyClient(connectionTimeout, readTimeout,\n-            connectionIdleTimeout, jerseyClientConfig);\n+          ClientConfig jerseyClientConfig = new ProxyCustomApacheHttpClientConfig(clientName, maxConnectionsPerHost,\n+                  maxTotalConnections, proxyHost, proxyPort, proxyUserName, proxyPassword);\n+          \n+          return new JerseyClient(connectionTimeout, readTimeout, \n+                                  connectionIdleTimeout, jerseyClientConfig);\n       } catch (Throwable e) {\n           throw new RuntimeException(\"Cannot create Jersey client \", e);\n       }\n@@ -235,12 +224,25 @@ public CustomApacheHttpClientConfig(String clientName, int maxConnectionsPerHost\n     private static class ProxyCustomApacheHttpClientConfig extends DefaultApacheHttpClient4Config {\n       \n       public ProxyCustomApacheHttpClientConfig(String clientName, int maxConnectionsPerHost, int maxTotalConnections,\n-              String proxyHost, String proxyPort, String proxyUsername, String proxyPassword)\n+              String proxyHost, String proxyPort, String proxyUserName, String proxyPassword)\n           throws Throwable {\n         MonitoredConnectionManager cm = new MonitoredConnectionManager(clientName);\n         cm.setDefaultMaxPerRoute(maxConnectionsPerHost);\n         cm.setMaxTotal(maxTotalConnections);\n         getProperties().put(ApacheHttpClient4Config.PROPERTY_CONNECTION_MANAGER, cm);\n+        \n+        if (proxyUserName != null && proxyPassword != null) {\n+          getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_USERNAME, proxyUserName);\n+          getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_PASSWORD, proxyPassword);\n+        } else {\n+          // Due to bug in apache client, user name/password must always be set.\n+          // Otherwise proxy configuration is ignored.\n+          getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_USERNAME, \"guest\");\n+          getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_PASSWORD, \"guest\");\n+        }\n+        getProperties().put(\n+                DefaultApacheHttpClient4Config.PROPERTY_PROXY_URI,\n+                \"http://\" + proxyHost + \":\" + proxyPort);\n       }\n     }\n     ",
      "parent_sha": "f779716acd9639b3829ce8d7797d249f6a504792"
    }
  },
  {
    "oid": "3767d56efbabc8cf5e26fc442c7b008c841bbf19",
    "message": "https://github.com/Netflix/eureka/issues/59: Fix for the following issues\n\n1) Eureka client tries to talk to a server in the same zone and fails over to the next server predictably for all clients in that zone. This could put a lot of pressure on the server that all these clients are failing over. These clients should distribute the load to other servers in the case of failover. This can be achieved by choosing a different failover server depending on the client.\n\n2) Currently when there are 2 servers in the same zone, the eureka client always chooses the same server every time. The second server is not utilized until failover. This restricts the ability to loadbalance requests across multiple servers in the same zone.",
    "date": "2013-10-16T18:40:48Z",
    "url": "https://github.com/Netflix/eureka/commit/3767d56efbabc8cf5e26fc442c7b008c841bbf19",
    "details": {
      "sha": "33cfc4127aed74c4a6ec70b449cf0e187c1c4501",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java",
      "status": "modified",
      "additions": 62,
      "deletions": 16,
      "changes": 78,
      "blob_url": "https://github.com/Netflix/eureka/blob/3767d56efbabc8cf5e26fc442c7b008c841bbf19/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/3767d56efbabc8cf5e26fc442c7b008c841bbf19/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java?ref=3767d56efbabc8cf5e26fc442c7b008c841bbf19",
      "patch": "@@ -21,7 +21,6 @@\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashSet;\n-import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n@@ -38,7 +37,6 @@\n import javax.ws.rs.core.MediaType;\n import javax.ws.rs.core.Response.Status;\n \n-import com.google.common.collect.Sets;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -1011,7 +1009,9 @@ private void initScheduledTasks() {\n \n     /**\n      * Get the list of all eureka service urls from DNS for the eureka client to\n-     * talk to.\n+     * talk to. The client picks up the service url from its zone and then fails over to\n+     * other zones randomly. If there are multiple servers in the same zone, the client once\n+     * again picks one randomly. This way the traffic will be distributed in the case of failures.\n      * \n      * @param instanceZone\n      *            - The zone in which the client resides.\n@@ -1029,7 +1029,10 @@ public List<String> getServiceUrlsFromDNS(String instanceZone,\n         // list of available zones\n         Map<String, List<String>> zoneDnsNamesMap = getZoneBasedDiscoveryUrlsFromRegion(region);\n         Set<String> availableZones = zoneDnsNamesMap.keySet();\n-        List<String> zones = new LinkedList<String>(availableZones);\n+        List<String> zones = new ArrayList<String>(availableZones);\n+        if (zones.isEmpty()) {\n+            throw new RuntimeException(\"No available zones configured for the instanceZone \" + instanceZone);\n+        }\n         int zoneIndex = 0;\n         boolean zoneFound = false;\n         for (String zone : zones) {\n@@ -1054,33 +1057,54 @@ public List<String> getServiceUrlsFromDNS(String instanceZone,\n             }\n             zoneIndex++;\n         }\n-        // Swap the entries so that you get the instance zone first and then\n-        // followed by the list of other zones\n-        // in a circular order\n-        for (int i = 0; i < zoneIndex; i++) {\n-            String zone = zones.remove(0);\n-            zones.add(zone);\n-        }\n+        if (zoneIndex >= zones.size()) {\n+            logger.warn(\n+                    \"No match for the zone {} in the list of available zones {}\",\n+                    instanceZone, Arrays.toString(zones.toArray()));\n+        } else {\n+            // Rearrange the zones with the instance zone first \n+            for (int i=0; i <zoneIndex; i ++) {\n+                String zone = zones.remove(0);\n+                zones.add(zone);\n+            }\n+         }\n+\n         // Now get the eureka urls for all the zones in the order and return it\n         List<String> serviceUrls = new ArrayList<String>();\n         for (String zone : zones) {\n             for (String zoneCname : zoneDnsNamesMap.get(zone)) {\n-                for (String ec2Url : getEC2DiscoveryUrlsFromZone(zoneCname,\n-                        DiscoveryUrlType.CNAME)) {\n+                List<String> ec2Urls = new ArrayList<String>(\n+                        getEC2DiscoveryUrlsFromZone(zoneCname,\n+                                DiscoveryUrlType.CNAME));\n+                // Rearrange the list to distribute the load in case of\n+                // multiple servers\n+                if (ec2Urls.size() > 1) {\n+                    this.arrangeListBasedonHostname(ec2Urls);\n+                }\n+                 for (String ec2Url : ec2Urls) {\n                     String serviceUrl = \"http://\" + ec2Url + \":\"\n-                            + clientConfig.getEurekaServerPort()\n+                    + clientConfig.getEurekaServerPort()\n \n-                            + \"/\" + clientConfig.getEurekaServerURLContext()\n-                            + \"/\";\n+                    + \"/\" + clientConfig.getEurekaServerURLContext()\n+                    + \"/\";\n                     logger.debug(\"The EC2 url is {}\", serviceUrl);\n                     serviceUrls.add(serviceUrl);\n                 }\n             }\n         }\n+        // Rearrange the fail over server list to distribute the load\n+        String primaryServiceUrl = serviceUrls.remove(0);\n+        arrangeListBasedonHostname(serviceUrls);\n+        serviceUrls.add(0, primaryServiceUrl);\n+ \n+        logger.info(\n+                \"This client will talk to the following serviceUrls in order : {} \",\n+                Arrays.toString(serviceUrls.toArray()));\n         t.stop();\n         return serviceUrls;\n     }\n \n+\n     public List<String> getDiscoveryServiceUrls(String zone) {\n         boolean shouldUseDns = clientConfig.shouldUseDnsForFetchingServiceUrls();\n         if (shouldUseDns) {\n@@ -1630,5 +1654,27 @@ private Applications filterAndShuffle(Applications apps) {\n     private boolean isFetchingRemoteRegionRegistries() {\n         return null != remoteRegionsToFetch.get();\n     }\n+    \n+\n+    private void arrangeListBasedonHostname(List<String> list) {\n+        int listSize = 0;\n+        if (list != null) {\n+            listSize = list.size();\n+        }\n+        if ((this.instanceInfo == null) || (listSize == 0)) {\n+            return;\n+        }\n+        // Find the hashcode of the instance hostname and use it to find an entry\n+        // and then arrange the rest of the entries after this entry.\n+        int instanceHashcode = this.instanceInfo.getHostName().hashCode();\n+        if (instanceHashcode < 0) {\n+            instanceHashcode = instanceHashcode * -1;\n+        }\n+        int backupInstance = instanceHashcode % listSize;\n+        for (int i=0; i < backupInstance; i ++) {\n+            String zone = list.remove(0);\n+            list.add(zone);\n+        }\n+    }\n \n }",
      "parent_sha": "48a5242728c0a1504676a733c6fe5d98a3178d37"
    }
  },
  {
    "oid": "5dd41e913ce7688168e4b16bf25f1dbdba06af6b",
    "message": "Remove redundant checks for null in InstanceRegistry",
    "date": "2014-04-29T12:49:19Z",
    "url": "https://github.com/Netflix/eureka/commit/5dd41e913ce7688168e4b16bf25f1dbdba06af6b",
    "details": {
      "sha": "0b2fb45fc4abcb4a9ecedeed9908a0077a04f9be",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java",
      "status": "modified",
      "additions": 9,
      "deletions": 16,
      "changes": 25,
      "blob_url": "https://github.com/Netflix/eureka/blob/5dd41e913ce7688168e4b16bf25f1dbdba06af6b/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FInstanceRegistry.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/5dd41e913ce7688168e4b16bf25f1dbdba06af6b/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FInstanceRegistry.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2FInstanceRegistry.java?ref=5dd41e913ce7688168e4b16bf25f1dbdba06af6b",
      "patch": "@@ -229,11 +229,9 @@ public void register(InstanceInfo r, int leaseDuration, boolean isReplication) {\n             if (InstanceStatus.UP.equals(r.getStatus())) {\n                 lease.serviceUp();\n             }\n-            if (r != null) {\n-                r.setActionType(ActionType.ADDED);\n-                recentlyChangedQueue.add(new RecentlyChangedItem(lease));\n-                r.setLastUpdatedTimestamp();\n-            }\n+            r.setActionType(ActionType.ADDED);\n+            recentlyChangedQueue.add(new RecentlyChangedItem(lease));\n+            r.setLastUpdatedTimestamp();\n             invalidateCache(r.getAppName(), r.getVIPAddress(), r.getSecureVipAddress());\n             logger.info(\"Registered instance id {} with status {}\", r.getId(),\n                     r.getStatus().toString());\n@@ -443,12 +441,10 @@ public boolean statusUpdate(String appName, String id,\n                     } else {\n                         info.setStatus(newStatus);\n                     }\n-                    if (info != null) {\n-                        info.setActionType(ActionType.MODIFIED);\n-                        recentlyChangedQueue\n-                                .add(new RecentlyChangedItem(lease));\n-                        info.setLastUpdatedTimestamp();\n-                    }\n+                    info.setActionType(ActionType.MODIFIED);\n+                    recentlyChangedQueue\n+                            .add(new RecentlyChangedItem(lease));\n+                    info.setLastUpdatedTimestamp();\n                     invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());\n                 }\n                 return true;\n@@ -948,13 +944,10 @@ public List<InstanceInfo> getInstancesById(String id,\n                     continue;\n                 }\n \n-                if (lease != null && list == Collections.EMPTY_LIST) {\n+                if (list == Collections.EMPTY_LIST) {\n                     list = new ArrayList<InstanceInfo>();\n                 }\n-\n-                if (lease != null) {\n-                    list.add(decorateInstanceInfo(lease));\n-                }\n+                list.add(decorateInstanceInfo(lease));\n             }\n         }\n         if (list.isEmpty() && includeRemoteRegions) {",
      "parent_sha": "10b34a2e746cd8c3059e5646919ec3d1f3a7e2a6"
    }
  },
  {
    "oid": "f7d01cbf70d553a449583ef6cf6f3d1ae591ed39",
    "message": "Correct an SLF4J logger call\n\nAdd one missing '{}'.",
    "date": "2017-11-06T16:11:35Z",
    "url": "https://github.com/Netflix/eureka/commit/f7d01cbf70d553a449583ef6cf6f3d1ae591ed39",
    "details": {
      "sha": "f8893426ada8b5284c7ec313b81f831ca95a3a85",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/aws/ElasticNetworkInterfaceBinder.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/eureka/blob/f7d01cbf70d553a449583ef6cf6f3d1ae591ed39/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Faws%2FElasticNetworkInterfaceBinder.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/f7d01cbf70d553a449583ef6cf6f3d1ae591ed39/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Faws%2FElasticNetworkInterfaceBinder.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Faws%2FElasticNetworkInterfaceBinder.java?ref=f7d01cbf70d553a449583ef6cf6f3d1ae591ed39",
      "patch": "@@ -168,7 +168,7 @@ public Integer apply(NetworkInterface networkInterface) {\n                 );\n \n         if (result.getNetworkInterfaces().isEmpty()) {\n-            logger.info(\"No ip is free to be associated with this instance. Candidate ips are: {} for zone: \", ips, myZone);\n+            logger.info(\"No ip is free to be associated with this instance. Candidate ips are: {} for zone: {}\", ips, myZone);\n         } else {\n             NetworkInterface selected = ipsOrder.min(result.getNetworkInterfaces());\n             ec2Service.attachNetworkInterface(",
      "parent_sha": "7561954d0e23b7c474ad835e11e0441a9757b394"
    }
  },
  {
    "oid": "b7d6273161f1e1391da5a0453f28e88280e21beb",
    "message": "catch potential exceptions around EurekaEventListener notify.",
    "date": "2017-11-07T23:39:17Z",
    "url": "https://github.com/Netflix/eureka/commit/b7d6273161f1e1391da5a0453f28e88280e21beb",
    "details": {
      "sha": "119a1a84729128269d06c817c020a3b4744f5e31",
      "filename": "eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/Netflix/eureka/blob/b7d6273161f1e1391da5a0453f28e88280e21beb/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/b7d6273161f1e1391da5a0453f28e88280e21beb/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fdiscovery%2FDiscoveryClient.java?ref=b7d6273161f1e1391da5a0453f28e88280e21beb",
      "patch": "@@ -1605,7 +1605,11 @@ protected void onCacheRefreshed() {\n      */\n     protected void fireEvent(final EurekaEvent event) {\n         for (EurekaEventListener listener : eventListeners) {\n-            listener.onEvent(event);\n+            try {\n+                listener.onEvent(event);\n+            } catch (Exception e) {\n+                logger.info(\"Event {} throw an exception\", event, e.getMessage());\n+            }\n         }\n     }\n ",
      "parent_sha": "dfbee33ca78e09b90bd0f8b028800fc2fd285970"
    }
  },
  {
    "oid": "96a189e5045d46810301113abfe86a4ef8224f0f",
    "message": "fix a flaky test",
    "date": "2015-09-14T21:56:58Z",
    "url": "https://github.com/Netflix/eureka/commit/96a189e5045d46810301113abfe86a4ef8224f0f",
    "details": {
      "sha": "8a39ee145be169ef55a822eef0c99567282dab16",
      "filename": "eureka-core/src/test/java/com/netflix/eureka/cluster/PeerEurekaNodeTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/Netflix/eureka/blob/96a189e5045d46810301113abfe86a4ef8224f0f/eureka-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fcluster%2FPeerEurekaNodeTest.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/96a189e5045d46810301113abfe86a4ef8224f0f/eureka-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fcluster%2FPeerEurekaNodeTest.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Ftest%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fcluster%2FPeerEurekaNodeTest.java?ref=96a189e5045d46810301113abfe86a4ef8224f0f",
      "patch": "@@ -27,6 +27,7 @@\n import static org.hamcrest.CoreMatchers.nullValue;\n import static org.junit.Assert.assertThat;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.timeout;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n \n@@ -142,7 +143,7 @@ public void testHeartbeatWithInstanceInfoFromPeer() throws Throwable {\n         expectRequestType(RequestType.Heartbeat);\n \n         // Check that registry has instanceInfo from peer\n-        verify(registry, times(1)).register(instanceInfoFromPeer, true);\n+        verify(registry, timeout(1000).times(1)).register(instanceInfoFromPeer, true);\n     }\n \n     @Test",
      "parent_sha": "131b9841fecc56042e1971cbe54c902ae634198e"
    }
  },
  {
    "oid": "1b7603580bfab0d5b59a9c0e7578f8b019b2cd4a",
    "message": "comment update",
    "date": "2015-06-08T08:02:28Z",
    "url": "https://github.com/Netflix/eureka/commit/1b7603580bfab0d5b59a9c0e7578f8b019b2cd4a",
    "details": {
      "sha": "38bf7c9f80ed135fb43a5479cb08ddab0f421a34",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/Netflix/eureka/blob/1b7603580bfab0d5b59a9c0e7578f8b019b2cd4a/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2FAwsAsgUtil.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/1b7603580bfab0d5b59a9c0e7578f8b019b2cd4a/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2FAwsAsgUtil.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Futil%2FAwsAsgUtil.java?ref=1b7603580bfab0d5b59a9c0e7578f8b019b2cd4a",
      "patch": "@@ -410,7 +410,7 @@ private String getASGAccount(String asgName) {\n             }\n         }\n \n-        logger.error(\"Couldn't get the ASG account for \" + asgName);\n+        logger.warn(\"Couldn't get the ASG account for {}, using the default accountId instead\", asgName);\n         return accountId;\n     }\n ",
      "parent_sha": "3d01ee774e4dde8715a51e48b72b7eaa8da941ef"
    }
  },
  {
    "oid": "8d689631ce3fef2a9d9a902cab10b571c3a0632a",
    "message": "fix javadoc on copy constructor",
    "date": "2014-02-13T02:38:05Z",
    "url": "https://github.com/Netflix/eureka/commit/8d689631ce3fef2a9d9a902cab10b571c3a0632a",
    "details": {
      "sha": "bf88b8027254d4482bdd44df975945202764b290",
      "filename": "eureka-client/src/main/java/com/netflix/appinfo/InstanceInfo.java",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/Netflix/eureka/blob/8d689631ce3fef2a9d9a902cab10b571c3a0632a/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FInstanceInfo.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/8d689631ce3fef2a9d9a902cab10b571c3a0632a/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FInstanceInfo.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-client%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Fappinfo%2FInstanceInfo.java?ref=8d689631ce3fef2a9d9a902cab10b571c3a0632a",
      "patch": "@@ -119,8 +119,12 @@ public class InstanceInfo {\n     private InstanceInfo() {\n     }\n \n-    // shallow copy constructor so we can make our own InstanceInfo to play with\n-    // without corrupting global eureka client concept of the InstanceInfo object\n+    /**\n+     *\n+     * shallow copy constructor\n+     *\n+     * @param ii The object to copy\n+     */\n     public InstanceInfo(InstanceInfo ii) {\n         this.appName = ii.appName;\n         this.ipAddr = ii.ipAddr;",
      "parent_sha": "8b5c33ee017e4592cceea040f749a976e00741da"
    }
  },
  {
    "oid": "9173d4400870195f6dd7db4e645ee719748f81e2",
    "message": "Use a more elegant way to judge\n\nUse `list.isEmpty ()` instead of `list.size>0` to make it more elegant.",
    "date": "2017-12-01T10:19:29Z",
    "url": "https://github.com/Netflix/eureka/commit/9173d4400870195f6dd7db4e645ee719748f81e2",
    "details": {
      "sha": "ff5f937d4e10d01f320fcefd35a4d1c09dd3e7e5",
      "filename": "eureka-core/src/main/java/com/netflix/eureka/resources/InstancesResource.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/Netflix/eureka/blob/9173d4400870195f6dd7db4e645ee719748f81e2/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fresources%2FInstancesResource.java",
      "raw_url": "https://github.com/Netflix/eureka/raw/9173d4400870195f6dd7db4e645ee719748f81e2/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fresources%2FInstancesResource.java",
      "contents_url": "https://api.github.com/repos/Netflix/eureka/contents/eureka-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fnetflix%2Feureka%2Fresources%2FInstancesResource.java?ref=9173d4400870195f6dd7db4e645ee719748f81e2",
      "patch": "@@ -37,6 +37,7 @@\n  * A <em>jersey</em> resource that gets information about a particular instance.\n  *\n  * @author Karthik Ranganathan, Greg Kim\n+ * @author Gang Li\n  *\n  */\n @Produces({\"application/xml\", \"application/json\"})\n@@ -62,7 +63,7 @@ public Response getById(@PathParam(\"version\") String version,\n                             @PathParam(\"id\") String id) {\n         CurrentRequestVersion.set(Version.toEnum(version));\n         List<InstanceInfo> list = registry.getInstancesById(id);\n-        if (list != null && list.size() > 0) {\n+        if (list != null && !list.isEmpty()) {\n             return Response.ok(list.get(0)).build();\n         } else {\n             logger.info(\"Not Found: {}\", id);",
      "parent_sha": "dbb98abe14eb8c984df75bb413c69411e1afb6e3"
    }
  }
]