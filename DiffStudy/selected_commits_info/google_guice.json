[
  {
    "oid": "28fac2a58134cfa36b39bd7a4d6210c1f28820b4",
    "message": "Restoring a missing .withSource() (as discovered by Ben Yu)\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@647 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2008-10-21T16:25:35Z",
    "url": "https://github.com/google/guice/commit/28fac2a58134cfa36b39bd7a4d6210c1f28820b4",
    "details": {
      "sha": "659e4d0dd21c6969bfe0ac790a8b4e385b4e1de2",
      "filename": "src/com/google/inject/internal/ProviderMethod.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/google/guice/blob/28fac2a58134cfa36b39bd7a4d6210c1f28820b4/src%2Fcom%2Fgoogle%2Finject%2Finternal%2FProviderMethod.java",
      "raw_url": "https://github.com/google/guice/raw/28fac2a58134cfa36b39bd7a4d6210c1f28820b4/src%2Fcom%2Fgoogle%2Finject%2Finternal%2FProviderMethod.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/src%2Fcom%2Fgoogle%2Finject%2Finternal%2FProviderMethod.java?ref=28fac2a58134cfa36b39bd7a4d6210c1f28820b4",
      "patch": "@@ -62,9 +62,9 @@ public Method getMethod() {\n \n   public void configure(Binder binder) {\n     if (scopeAnnotation != null) {\n-      binder.bind(key).toProvider(this).in(scopeAnnotation);\n+      binder.withSource(method).bind(key).toProvider(this).in(scopeAnnotation);\n     } else {\n-      binder.bind(key).toProvider(this);\n+      binder.withSource(method).bind(key).toProvider(this);\n     }\n   }\n ",
      "parent_sha": "b8db6a95791244d49583aba0905ef24ceb7f2398"
    }
  },
  {
    "oid": "35caaec1b4af0f20ab8b3fae8a1fc98afc0fd13e",
    "message": "Ignore IllegalStateExceptions when loading classes for retrieving line numbers.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=197761929",
    "date": "2018-05-25T17:36:37Z",
    "url": "https://github.com/google/guice/commit/35caaec1b4af0f20ab8b3fae8a1fc98afc0fd13e",
    "details": {
      "sha": "eb9aeb383ec84f08f19e5fb2cba8d7f9772669fd",
      "filename": "core/src/com/google/inject/internal/util/LineNumbers.java",
      "status": "modified",
      "additions": 6,
      "deletions": 3,
      "changes": 9,
      "blob_url": "https://github.com/google/guice/blob/35caaec1b4af0f20ab8b3fae8a1fc98afc0fd13e/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2Futil%2FLineNumbers.java",
      "raw_url": "https://github.com/google/guice/raw/35caaec1b4af0f20ab8b3fae8a1fc98afc0fd13e/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2Futil%2FLineNumbers.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2Futil%2FLineNumbers.java?ref=35caaec1b4af0f20ab8b3fae8a1fc98afc0fd13e",
      "patch": "@@ -51,14 +51,17 @@ final class LineNumbers {\n    * Reads line number information from the given class, if available.\n    *\n    * @param type the class to read line number information from\n-   * @throws IllegalArgumentException if the bytecode for the class cannot be found\n-   * @throws java.io.IOException if an error occurs while reading bytecode\n    */\n   public LineNumbers(Class type) throws IOException {\n     this.type = type;\n \n     if (!type.isArray()) {\n-      InputStream in = type.getResourceAsStream(\"/\" + type.getName().replace('.', '/') + \".class\");\n+      InputStream in = null;\n+      try {\n+        in = type.getResourceAsStream(\"/\" + type.getName().replace('.', '/') + \".class\");\n+      } catch (IllegalStateException ignored) {\n+        // Some classloaders throw IllegalStateException when they can't load a resource.\n+      }\n       if (in != null) {\n         try {\n           new ClassReader(in).accept(new LineNumberReader(), ClassReader.SKIP_FRAMES);",
      "parent_sha": "0451111076c353f0a4cb5e2c149af828a06a2b2d"
    }
  },
  {
    "oid": "615fd2bc2397e2966d682759aae2aad7e8a3db1e",
    "message": "Make SpiUtils tests more accurate by multiplying the expected results instead\nof dividing the actual results. Before, some bindings weren't being checked\nand this was overlooked by the tests due to rounding down the number of\nleftover bindings.\n\nTested:\nAll existing tests pass.\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=79167431",
    "date": "2014-11-07T18:18:19Z",
    "url": "https://github.com/google/guice/commit/615fd2bc2397e2966d682759aae2aad7e8a3db1e",
    "details": {
      "sha": "95ac12deac1f7d51230f91202b88463d6e56bedf",
      "filename": "extensions/multibindings/test/com/google/inject/multibindings/SpiUtils.java",
      "status": "modified",
      "additions": 22,
      "deletions": 7,
      "changes": 29,
      "blob_url": "https://github.com/google/guice/blob/615fd2bc2397e2966d682759aae2aad7e8a3db1e/extensions%2Fmultibindings%2Ftest%2Fcom%2Fgoogle%2Finject%2Fmultibindings%2FSpiUtils.java",
      "raw_url": "https://github.com/google/guice/raw/615fd2bc2397e2966d682759aae2aad7e8a3db1e/extensions%2Fmultibindings%2Ftest%2Fcom%2Fgoogle%2Finject%2Fmultibindings%2FSpiUtils.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fmultibindings%2Ftest%2Fcom%2Fgoogle%2Finject%2Fmultibindings%2FSpiUtils.java?ref=615fd2bc2397e2966d682759aae2aad7e8a3db1e",
      "patch": "@@ -169,11 +169,14 @@ private static <T> void mapInjectorTest(Key<T> mapKey, TypeLiteral<?> keyType,\n     Key<?> mapOfSetOfProvider = mapKey.ofType(mapOfSetOfProviderOf(keyType, valueType));\n     Key<?> mapOfSet = mapKey.ofType(mapOf(keyType, setOf(valueType)));\n     Key<?> setOfEntry = mapKey.ofType(setOf(entryOfProviderOf(keyType, valueType)));\n+    Key<?> collectionOfProvidersOfEntryOfProvider =\n+        mapKey.ofType(collectionOfProvidersOf(entryOfProviderOf(keyType, valueType)));\n     boolean entrySetMatch = false;\n     boolean mapJavaxProviderMatch = false;\n     boolean mapProviderMatch = false;\n     boolean mapSetMatch = false; \n     boolean mapSetProviderMatch = false;\n+    boolean collectionOfProvidersOfEntryOfProviderMatch = false;\n     List<Object> otherMapBindings = Lists.newArrayList();\n     List<Binding> otherMatches = Lists.newArrayList();\n     Multimap<Object, IndexedBinding> indexedEntries =\n@@ -206,6 +209,9 @@ private static <T> void mapInjectorTest(Key<T> mapKey, TypeLiteral<?> keyType,\n         entrySetMatch = true;\n         // Validate that this binding is also a MultibinderBinding.\n         assertTrue(b.acceptTargetVisitor(visitor) instanceof MultibinderBinding);\n+      } else if(b.getKey().equals(collectionOfProvidersOfEntryOfProvider)) {\n+        assertTrue(contains);\n+        collectionOfProvidersOfEntryOfProviderMatch = true;\n       } else if (contains) {\n         if (b instanceof ProviderInstanceBinding) {\n           ProviderInstanceBinding<?> pib = (ProviderInstanceBinding<?>)b;\n@@ -228,12 +234,13 @@ private static <T> void mapInjectorTest(Key<T> mapKey, TypeLiteral<?> keyType,\n     if(allowDuplicates) {\n       sizeOfOther--; // account for 1 duplicate binding\n     }\n-    sizeOfOther = sizeOfOther / 2; // account for 1 value & 1 Map.Entry of each expected binding.\n-    assertEquals(\"Incorrect other matches: \" + otherMatches,\n-        mapResults.size() + duplicates, sizeOfOther);\n+    // Multiply by two because each has a value and Map.Entry.\n+    int expectedSize = 2 * (mapResults.size() + duplicates);\n+    assertEquals(\"Incorrect other matches: \" + otherMatches, expectedSize, sizeOfOther);\n     assertTrue(entrySetMatch);\n     assertTrue(mapProviderMatch);\n     assertTrue(mapJavaxProviderMatch);\n+    assertTrue(collectionOfProvidersOfEntryOfProviderMatch);\n     assertEquals(allowDuplicates, mapSetMatch);\n     assertEquals(allowDuplicates, mapSetProviderMatch);\n     assertEquals(\"other MapBindings found: \" + otherMapBindings, expectedMapBindings,\n@@ -264,6 +271,7 @@ private static <T> void mapModuleTest(Key<T> mapKey, TypeLiteral<?> keyType,\n     List<MapResult> mapResults = Lists.newArrayList(results);\n     \n     Key<?> mapOfProvider = mapKey.ofType(mapOfProviderOf(keyType, valueType));\n+    Key<?> mapOfJavaxProvider = mapKey.ofType(mapOfJavaxProviderOf(keyType, valueType));\n     Key<?> mapOfSetOfProvider = mapKey.ofType(mapOfSetOfProviderOf(keyType, valueType));\n     Key<?> mapOfSet = mapKey.ofType(mapOf(keyType, setOf(valueType)));\n     Key<?> setOfEntry = mapKey.ofType(setOf(entryOfProviderOf(keyType, valueType)));    \n@@ -272,7 +280,8 @@ private static <T> void mapModuleTest(Key<T> mapKey, TypeLiteral<?> keyType,\n     boolean entrySetMatch = false;\n     boolean entryProviderCollectionMatch = false;\n     boolean mapProviderMatch = false;\n-    boolean mapSetMatch = false; \n+    boolean mapJavaxProviderMatch = false;\n+    boolean mapSetMatch = false;\n     boolean mapSetProviderMatch = false;\n     List<Object> otherMapBindings = Lists.newArrayList();\n     List<Element> otherMatches = Lists.newArrayList();\n@@ -324,6 +333,10 @@ private static <T> void mapModuleTest(Key<T> mapKey, TypeLiteral<?> keyType,\n           matched = true;\n           assertTrue(contains);\n           mapProviderMatch = true;\n+        } else if(key.equals(mapOfJavaxProvider)) {\n+          matched = true;\n+          assertTrue(contains);\n+          mapJavaxProviderMatch = true;\n         } else if(key.equals(mapOfSet)) {\n           matched = true;\n           assertTrue(contains);\n@@ -356,13 +369,15 @@ private static <T> void mapModuleTest(Key<T> mapKey, TypeLiteral<?> keyType,\n     if (allowDuplicates) {\n       otherMatchesSize--; // allow for 1 duplicate binding\n     }\n-    otherMatchesSize = otherMatchesSize / 3; // value, ProviderLookup per value, Map.Entry per value\n-    assertEquals(\"incorrect number of contains, leftover matches: \" + otherMatches, mapResults\n-        .size() + duplicates, otherMatchesSize);\n+    // Multiply by 3 because each has a value, ProviderLookup, and Map.Entry\n+    int expectedSize = (mapResults.size() + duplicates) * 3;\n+    assertEquals(\"incorrect number of contains, leftover matches: \" + otherMatches,\n+        expectedSize, otherMatchesSize);\n \n     assertTrue(entrySetMatch);\n     assertTrue(entryProviderCollectionMatch);\n     assertTrue(mapProviderMatch);\n+    assertTrue(mapJavaxProviderMatch);\n     assertEquals(allowDuplicates, mapSetMatch);\n     assertEquals(allowDuplicates, mapSetProviderMatch);\n     assertEquals(\"other MapBindings found: \" + otherMapBindings, expectedMapBindings,",
      "parent_sha": "f6189601d44b1ff8143e26337d0704f35f8dc645"
    }
  },
  {
    "oid": "8d7338e181e8467fd7b91f30d3ffc48711c86e2d",
    "message": "Current build targets Java5 but String.isEmpty() is Java6 only, so change this check to use String.length() instead\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@1301 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2010-10-21T21:22:23Z",
    "url": "https://github.com/google/guice/commit/8d7338e181e8467fd7b91f30d3ffc48711c86e2d",
    "details": {
      "sha": "ded36429a750798ac4fad5b053c07a3c4584766d",
      "filename": "extensions/persist/src/com/google/inject/persist/jpa/JpaPersistModule.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/8d7338e181e8467fd7b91f30d3ffc48711c86e2d/extensions%2Fpersist%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fpersist%2Fjpa%2FJpaPersistModule.java",
      "raw_url": "https://github.com/google/guice/raw/8d7338e181e8467fd7b91f30d3ffc48711c86e2d/extensions%2Fpersist%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fpersist%2Fjpa%2FJpaPersistModule.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fpersist%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fpersist%2Fjpa%2FJpaPersistModule.java?ref=8d7338e181e8467fd7b91f30d3ffc48711c86e2d",
      "patch": "@@ -46,7 +46,7 @@ public final class JpaPersistModule extends PersistModule {\n   private final String jpaUnit;\n \n   public JpaPersistModule(String jpaUnit) {\n-    Preconditions.checkArgument(null != jpaUnit && !jpaUnit.isEmpty(),\n+    Preconditions.checkArgument(null != jpaUnit && jpaUnit.length() > 0,\n         \"JPA unit name must be a non-empty string.\");\n     this.jpaUnit = jpaUnit;\n   }",
      "parent_sha": "74d714c1e72bb60706ed9df4d1982971c88c10aa"
    }
  },
  {
    "oid": "c7b2e2f74f77e165d68d51f240dd2273c2efe09c",
    "message": "Linking referenced methods in Toolable annotation doc.\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@1181 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2010-07-03T15:12:19Z",
    "url": "https://github.com/google/guice/commit/c7b2e2f74f77e165d68d51f240dd2273c2efe09c",
    "details": {
      "sha": "6f8b91ef4788d05427bde5e872533ca23e56c627",
      "filename": "src/com/google/inject/spi/Toolable.java",
      "status": "modified",
      "additions": 7,
      "deletions": 6,
      "changes": 13,
      "blob_url": "https://github.com/google/guice/blob/c7b2e2f74f77e165d68d51f240dd2273c2efe09c/src%2Fcom%2Fgoogle%2Finject%2Fspi%2FToolable.java",
      "raw_url": "https://github.com/google/guice/raw/c7b2e2f74f77e165d68d51f240dd2273c2efe09c/src%2Fcom%2Fgoogle%2Finject%2Fspi%2FToolable.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/src%2Fcom%2Fgoogle%2Finject%2Fspi%2FToolable.java?ref=c7b2e2f74f77e165d68d51f240dd2273c2efe09c",
      "patch": "@@ -13,12 +13,13 @@\n \r\n \r\n /**\r\n- * Instructs an {@link Injector} running in {@link Stage#TOOL} that\r\n- * a method should be injected.  This is typically useful for for\r\n- * extensions to Guice that perform additional validation in an \r\n- * {@literal @}{@link Inject}ed method.  This only applies to objects\r\n- * that are already constructed when bindings are created (ie., \r\n- * something bound using toProvider, toInstance, or requestInjection).\r\n+ * Instructs an {@link Injector} running in {@link Stage#TOOL} that a method should be injected.\r\n+ * This is typically useful for for extensions to Guice that perform additional validation in an\r\n+ * injected method or field.  This only applies to objects that are already constructed when\r\n+ * bindings are created (ie., something bound using {@link\r\n+ * com.google.inject.binder.LinkedBindingBuilder#toProvider toProvider}, {@link\r\n+ * com.google.inject.binder.LinkedBindingBuilder#toInstance toInstance}, or {@link\r\n+ * com.google.inject.Binder#requestInjection requestInjection}.\r\n  * \r\n  * @author sberlin@gmail.com (Sam Berlin)\r\n  */\r",
      "parent_sha": "1555f115f2c2fca2ec2e5457ea96e9d4e555a7a8"
    }
  },
  {
    "oid": "deb5a1b3f006b495385df5f8cb3d065b80797add",
    "message": "Add an option to control whether AOP is enabled or not.\n\nAlso remove some unnecessary methods by inlining the calls.\n\nPiperOrigin-RevId: 335917232",
    "date": "2020-10-07T18:47:10Z",
    "url": "https://github.com/google/guice/commit/deb5a1b3f006b495385df5f8cb3d065b80797add",
    "details": {
      "sha": "3446e20c66a9155c6870e0246009063f052b8e01",
      "filename": "core/src/com/google/inject/internal/InternalFlags.java",
      "status": "modified",
      "additions": 46,
      "deletions": 26,
      "changes": 72,
      "blob_url": "https://github.com/google/guice/blob/deb5a1b3f006b495385df5f8cb3d065b80797add/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInternalFlags.java",
      "raw_url": "https://github.com/google/guice/raw/deb5a1b3f006b495385df5f8cb3d065b80797add/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInternalFlags.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInternalFlags.java?ref=deb5a1b3f006b495385df5f8cb3d065b80797add",
      "patch": "@@ -26,16 +26,25 @@\n public class InternalFlags {\n   private static final Logger logger = Logger.getLogger(InternalFlags.class.getName());\n \n-  private static final IncludeStackTraceOption INCLUDE_STACK_TRACES\n-      = parseIncludeStackTraceOption();\n+  private static final IncludeStackTraceOption INCLUDE_STACK_TRACES =\n+      getSystemOption(\n+          \"guice_include_stack_traces\",\n+          IncludeStackTraceOption.ONLY_FOR_DECLARING_SOURCE);\n \n-  private static final CustomClassLoadingOption CUSTOM_CLASS_LOADING\n-      = parseCustomClassLoadingOption();\n+  private static final CustomClassLoadingOption CUSTOM_CLASS_LOADING =\n+      getSystemOption(\n+          \"guice_custom_class_loading\",\n+          CustomClassLoadingOption.BRIDGE,\n+          CustomClassLoadingOption.OFF);\n \n-  private static final NullableProvidesOption NULLABLE_PROVIDES\n-      = parseNullableProvidesOption(NullableProvidesOption.ERROR);\n+  private static final NullableProvidesOption NULLABLE_PROVIDES =\n+      getSystemOption(\"guice_check_nullable_provides_params\", NullableProvidesOption.ERROR);\n \n-  private static final ColorizeOption COLORIZE_OPTION = parseColorizeOption();\n+  private static final AopOption AOP_OPTION =\n+      getSystemOption(\"guice_aop_option\", AopOption.ENABLED);\n+\n+  private static final ColorizeOption COLORIZE_OPTION =\n+      getSystemOption(\"guice_colorize_error_messages\", ColorizeOption.OFF);\n \n   /** The options for Guice stack trace collection. */\n   public enum IncludeStackTraceOption {\n@@ -87,6 +96,32 @@ public enum NullableProvidesOption {\n     ERROR\n   }\n \n+  /**\n+   * Options for controlling whether Guice supports AOP (Aspect-oriented programming). When AOP is\n+   * enabled, the following features will be enabled in Guice:\n+   *\n+   * <ul>\n+   *   <li>Runtime bytecode generation (instead of reflection) will be used when Guice need to\n+   *       invoke application code.\n+   *   <li>Method interception.\n+   *   <li>Additional debug information like line numbers and source file in error messages.\n+   * </ul>\n+   *\n+   * <p>Bytecode generation is generally faster than using reflection when invoking application\n+   * code, however, it can use more memory and slower in certain cases due to the time spent in\n+   * generating the classes. If you prefer to use reflection over bytecode generation then set\n+   * {@link AopOption} to {@code DISABLED}.\n+   */\n+  public enum AopOption {\n+    /**\n+     * AOP is disabled and using features that require bytecode generation such as method\n+     * interception will throw errors at run time.\n+     */\n+    DISABLED,\n+    /** AOP is enabled. */\n+    ENABLED,\n+  }\n+\n   /** Options for enable or disable the new experimental error messages. */\n   public enum ExperimentalErrorMessagesOption {\n     DISABLED,\n@@ -129,6 +164,10 @@ public static NullableProvidesOption getNullableProvidesOption() {\n     return NULLABLE_PROVIDES;\n   }\n \n+  public static boolean isAopEnabled() {\n+    return AOP_OPTION == AopOption.ENABLED;\n+  }\n+\n   public static boolean enableExperimentalErrorMessages() {\n     return false;\n   }\n@@ -137,25 +176,6 @@ public static boolean enableColorizeErrorMessages() {\n     return COLORIZE_OPTION.enabled();\n   }\n \n-  private static IncludeStackTraceOption parseIncludeStackTraceOption() {\n-    return getSystemOption(\"guice_include_stack_traces\",\n-        IncludeStackTraceOption.ONLY_FOR_DECLARING_SOURCE);\n-  }\n-\n-  private static CustomClassLoadingOption parseCustomClassLoadingOption() {\n-    return getSystemOption(\"guice_custom_class_loading\",\n-        CustomClassLoadingOption.BRIDGE, CustomClassLoadingOption.OFF);\n-  }\n-\n-  private static NullableProvidesOption parseNullableProvidesOption(\n-      NullableProvidesOption defaultValue) {\n-    return getSystemOption(\"guice_check_nullable_provides_params\", defaultValue);\n-  }\n-\n-  private static ColorizeOption parseColorizeOption() {\n-    return getSystemOption(\"guice_colorize_error_messages\", ColorizeOption.OFF);\n-  }\n-\n   /**\n    * Gets the system option indicated by the specified key; runs as a privileged action.\n    * ",
      "parent_sha": "3bc61ccec213779b0d5164081825744d1da3dced"
    }
  },
  {
    "oid": "6a2b57138e2a717474295cafad8d6d4559d36510",
    "message": "Fix typo\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=247217813",
    "date": "2019-05-15T17:04:32Z",
    "url": "https://github.com/google/guice/commit/6a2b57138e2a717474295cafad8d6d4559d36510",
    "details": {
      "sha": "d7926f09b9b4622470fde7f61d444396a799ea1a",
      "filename": "extensions/dagger-adapter/src/com/google/inject/daggeradapter/DaggerAdapter.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/6a2b57138e2a717474295cafad8d6d4559d36510/extensions%2Fdagger-adapter%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fdaggeradapter%2FDaggerAdapter.java",
      "raw_url": "https://github.com/google/guice/raw/6a2b57138e2a717474295cafad8d6d4559d36510/extensions%2Fdagger-adapter%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fdaggeradapter%2FDaggerAdapter.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fdagger-adapter%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fdaggeradapter%2FDaggerAdapter.java?ref=6a2b57138e2a717474295cafad8d6d4559d36510",
      "patch": "@@ -114,7 +114,7 @@ private static void checkUnsupportedDaggerAnnotations(Object module, Binder bind\n           if (annotation.annotationType().getName().startsWith(\"dagger.\")) {\n             if (!SUPPORTED_METHOD_ANNOTATIONS.contains(annotation.annotationType())) {\n               binder.addError(\n-                  \"%s is annotated with @%s which is not supported by DaggerAdapater\",\n+                  \"%s is annotated with @%s which is not supported by DaggerAdapter\",\n                   method, annotation.annotationType().getCanonicalName());\n             }\n           }",
      "parent_sha": "553a475a2c64cf1058619db32739ae0370aec30b"
    }
  },
  {
    "oid": "c0f89a0a59c466aaaa86581ec0329d21b023ed8a",
    "message": "Add support for extensions into the proto SPI & convert them.\n\nThis converts the BindingProto to use oneofs instead of a type enum in order to let it grow more easily for extensions.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=194102075",
    "date": "2018-04-24T17:57:35Z",
    "url": "https://github.com/google/guice/commit/c0f89a0a59c466aaaa86581ec0329d21b023ed8a",
    "details": {
      "sha": "57f1035acae87532df5d3479ebfd88f00dae0bec",
      "filename": "extensions/assistedinject/src/com/google/inject/assistedinject/FactoryModuleBuilder.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/c0f89a0a59c466aaaa86581ec0329d21b023ed8a/extensions%2Fassistedinject%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fassistedinject%2FFactoryModuleBuilder.java",
      "raw_url": "https://github.com/google/guice/raw/c0f89a0a59c466aaaa86581ec0329d21b023ed8a/extensions%2Fassistedinject%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fassistedinject%2FFactoryModuleBuilder.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fassistedinject%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fassistedinject%2FFactoryModuleBuilder.java?ref=c0f89a0a59c466aaaa86581ec0329d21b023ed8a",
      "patch": "@@ -314,7 +314,7 @@ public <F> Module build(final Key<F> factoryInterface) {\n       @Override\n       protected void configure() {\n         Provider<F> provider = new FactoryProvider2<>(factoryInterface, bindings);\n-        bind(factoryInterface).toProvider(provider);\n+        binder().skipSources(this.getClass()).bind(factoryInterface).toProvider(provider);\n       }\n     };\n   }",
      "parent_sha": "48b3f62aa1a2ad2833949dc1bd9b56709cc0a7c7"
    }
  },
  {
    "oid": "88154da6eb36f1f10d791956c0705d73e24810d4",
    "message": "Document the behavior of ignoring duplicate installations of the same module instance.\nNit: invert an if statement.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=308673499",
    "date": "2020-04-28T15:00:33Z",
    "url": "https://github.com/google/guice/commit/88154da6eb36f1f10d791956c0705d73e24810d4",
    "details": {
      "sha": "830772401473e901eab54c462a84ba74e884a509",
      "filename": "core/src/com/google/inject/spi/Elements.java",
      "status": "modified",
      "additions": 43,
      "deletions": 41,
      "changes": 84,
      "blob_url": "https://github.com/google/guice/blob/88154da6eb36f1f10d791956c0705d73e24810d4/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fspi%2FElements.java",
      "raw_url": "https://github.com/google/guice/raw/88154da6eb36f1f10d791956c0705d73e24810d4/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fspi%2FElements.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fspi%2FElements.java?ref=88154da6eb36f1f10d791956c0705d73e24810d4",
      "patch": "@@ -314,51 +314,53 @@ void scanForAnnotatedMethods() {\n \n     @Override\n     public void install(Module module) {\n-      if (!modules.containsKey(module)) {\n-        RecordingBinder binder = this;\n-        boolean unwrapModuleSource = false;\n-        // Update the module source for the new module\n-        if (module instanceof ProviderMethodsModule) {\n-          // There are two reason's we'd want to get the module source in a ProviderMethodsModule.\n-          // ModuleAnnotatedMethodScanner lets users scan their own modules for @Provides-like\n-          // bindings.  If they install the module at a top-level, then moduleSource can be null.\n-          // Also, if they pass something other than 'this' to it, we'd have the wrong source.\n-          Class<?> delegateClass = ((ProviderMethodsModule) module).getDelegateModuleClass();\n-          if (moduleSource == null\n-              || !moduleSource.getModuleClassName().equals(delegateClass.getName())) {\n-            moduleSource = getModuleSource(delegateClass);\n-            unwrapModuleSource = true;\n-          }\n-        } else {\n-          moduleSource = getModuleSource(module.getClass());\n+      // Ignore duplicate installations of the same module instance.\n+      if (modules.containsKey(module)) {\n+        return;\n+      }\n+      RecordingBinder binder = this;\n+      boolean unwrapModuleSource = false;\n+      // Update the module source for the new module\n+      if (module instanceof ProviderMethodsModule) {\n+        // There are two reason's we'd want to get the module source in a ProviderMethodsModule.\n+        // ModuleAnnotatedMethodScanner lets users scan their own modules for @Provides-like\n+        // bindings.  If they install the module at a top-level, then moduleSource can be null.\n+        // Also, if they pass something other than 'this' to it, we'd have the wrong source.\n+        Class<?> delegateClass = ((ProviderMethodsModule) module).getDelegateModuleClass();\n+        if (moduleSource == null\n+            || !moduleSource.getModuleClassName().equals(delegateClass.getName())) {\n+          moduleSource = getModuleSource(delegateClass);\n           unwrapModuleSource = true;\n         }\n-        boolean skipScanning = false;\n-        if (module instanceof PrivateModule) {\n-          binder = (RecordingBinder) binder.newPrivateBinder();\n-          // Store the module in the private binder too so we scan for it.\n-          binder.modules.put(module, new ModuleInfo(binder, moduleSource, false));\n-          skipScanning = true; // don't scan this module in the parent's module set.\n-        }\n-        // Always store this in the parent binder (even if it was a private module)\n-        // so that we know not to process it again, and so that scanners inherit down.\n-        modules.put(module, new ModuleInfo(binder, moduleSource, skipScanning));\n-        try {\n-          module.configure(binder);\n-        } catch (RuntimeException e) {\n-          Collection<Message> messages = Errors.getMessagesFromThrowable(e);\n-          if (!messages.isEmpty()) {\n-            elements.addAll(messages);\n-          } else {\n-            addError(e);\n-          }\n-        }\n-        binder.install(ProviderMethodsModule.forModule(module));\n-        // We are done with this module, so undo module source change\n-        if (unwrapModuleSource) {\n-          moduleSource = moduleSource.getParent();\n+      } else {\n+        moduleSource = getModuleSource(module.getClass());\n+        unwrapModuleSource = true;\n+      }\n+      boolean skipScanning = false;\n+      if (module instanceof PrivateModule) {\n+        binder = (RecordingBinder) binder.newPrivateBinder();\n+        // Store the module in the private binder too so we scan for it.\n+        binder.modules.put(module, new ModuleInfo(binder, moduleSource, false));\n+        skipScanning = true; // don't scan this module in the parent's module set.\n+      }\n+      // Always store this in the parent binder (even if it was a private module)\n+      // so that we know not to process it again, and so that scanners inherit down.\n+      modules.put(module, new ModuleInfo(binder, moduleSource, skipScanning));\n+      try {\n+        module.configure(binder);\n+      } catch (RuntimeException e) {\n+        Collection<Message> messages = Errors.getMessagesFromThrowable(e);\n+        if (!messages.isEmpty()) {\n+          elements.addAll(messages);\n+        } else {\n+          addError(e);\n         }\n       }\n+      binder.install(ProviderMethodsModule.forModule(module));\n+      // We are done with this module, so undo module source change\n+      if (unwrapModuleSource) {\n+        moduleSource = moduleSource.getParent();\n+      }\n     }\n \n     @Override",
      "parent_sha": "1174710c292303432540e172d75e70b02093ffcc"
    }
  },
  {
    "oid": "97d4c3621853e7c9c618db0e4e1a84c8ef3a88ca",
    "message": "Introduce named inner classes for RequestScope and SessionScope to make stack traces more useful\n\ne.g.\nhttps://groups.google.com[]d/msg/guice-dev/BFTFkgJKXGY/M4TTXyto3bMJ\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=95563919",
    "date": "2015-10-28T17:33:07Z",
    "url": "https://github.com/google/guice/commit/97d4c3621853e7c9c618db0e4e1a84c8ef3a88ca",
    "details": {
      "sha": "ced5288eae21656649a12d755280ab4b588a71ad",
      "filename": "extensions/servlet/src/com/google/inject/servlet/ServletScopes.java",
      "status": "modified",
      "additions": 12,
      "deletions": 4,
      "changes": 16,
      "blob_url": "https://github.com/google/guice/blob/97d4c3621853e7c9c618db0e4e1a84c8ef3a88ca/extensions%2Fservlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletScopes.java",
      "raw_url": "https://github.com/google/guice/raw/97d4c3621853e7c9c618db0e4e1a84c8ef3a88ca/extensions%2Fservlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletScopes.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fservlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletScopes.java?ref=97d4c3621853e7c9c618db0e4e1a84c8ef3a88ca",
      "patch": "@@ -58,7 +58,10 @@ enum NullObject { INSTANCE }\n   /**\n    * HTTP servlet request scope.\n    */\n-  public static final Scope REQUEST = new Scope() {\n+  public static final Scope REQUEST = new RequestScope();\n+\n+  private static final class RequestScope implements Scope {\n+    @Override\n     public <T> Provider<T> scope(final Key<T> key, final Provider<T> creator) {\n       return new Provider<T>() {\n \n@@ -68,6 +71,7 @@ public <T> Provider<T> scope(final Key<T> key, final Provider<T> creator) {\n                 Key.get(HttpServletResponse.class),\n                 new Key<Map<String, String[]>>(RequestParameters.class) {});\n \n+        @Override\n         public T get() {\n           // Check if the alternate request scope should be used, if no HTTP\n           // request is in progress.\n@@ -139,15 +143,19 @@ public String toString() {\n     public String toString() {\n       return \"ServletScopes.REQUEST\";\n     }\n-  };\n+  }\n \n   /**\n    * HTTP session scope.\n    */\n-  public static final Scope SESSION = new Scope() {\n+  public static final Scope SESSION = new SessionScope();\n+\n+  private static final class SessionScope implements Scope {\n+    @Override\n     public <T> Provider<T> scope(final Key<T> key, final Provider<T> creator) {\n       final String name = key.toString();\n       return new Provider<T>() {\n+        @Override\n         public T get() {\n           HttpSession session = GuiceFilter.getRequest(key).getSession();\n           synchronized (session) {\n@@ -177,7 +185,7 @@ public String toString() {\n     public String toString() {\n       return \"ServletScopes.SESSION\";\n     }\n-  };\n+  }\n \n   /**\n    * Wraps the given callable in a contextual callable that \"continues\" the",
      "parent_sha": "e16b64947d28bdd29ea212474db18f6dde8e5a8d"
    }
  },
  {
    "oid": "0781568a6cc7b3ccf59fa6851e96ab1636e745c2",
    "message": "Fix test when bytecode generation is disabled.\n\nPiperOrigin-RevId: 336311235",
    "date": "2020-10-09T16:51:37Z",
    "url": "https://github.com/google/guice/commit/0781568a6cc7b3ccf59fa6851e96ab1636e745c2",
    "details": {
      "sha": "6d533e7f35ef0584e77546ffe5a09c39f188b431",
      "filename": "core/test/com/google/inject/IntegrationTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/0781568a6cc7b3ccf59fa6851e96ab1636e745c2/core%2Ftest%2Fcom%2Fgoogle%2Finject%2FIntegrationTest.java",
      "raw_url": "https://github.com/google/guice/raw/0781568a6cc7b3ccf59fa6851e96ab1636e745c2/core%2Ftest%2Fcom%2Fgoogle%2Finject%2FIntegrationTest.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Ftest%2Fcom%2Fgoogle%2Finject%2FIntegrationTest.java?ref=0781568a6cc7b3ccf59fa6851e96ab1636e745c2",
      "patch": "@@ -62,7 +62,7 @@ protected void configure() {\n           assertThrows(CreationException.class, () -> Guice.createInjector(module));\n       assertThat(exception)\n           .hasMessageThat()\n-          .contains(\"Binding interceptor is not supported when AOP is disabled.\");\n+          .contains(\"Binding interceptor is not supported when bytecode generation is disabled.\");\n     }\n   }\n ",
      "parent_sha": "dd873be40013bffbe07552367326bd2b60eaa807"
    }
  },
  {
    "oid": "e9e07b82e5b4dbf637cdaabde83bc12569533ba3",
    "message": "Remove legacy code.\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=124153531",
    "date": "2016-06-13T21:14:07Z",
    "url": "https://github.com/google/guice/commit/e9e07b82e5b4dbf637cdaabde83bc12569533ba3",
    "details": {
      "sha": "2b6a82610eeb89d48904ae1dff08bd77c88afeb3",
      "filename": "core/src/com/google/inject/internal/Errors.java",
      "status": "modified",
      "additions": 17,
      "deletions": 18,
      "changes": 35,
      "blob_url": "https://github.com/google/guice/blob/e9e07b82e5b4dbf637cdaabde83bc12569533ba3/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FErrors.java",
      "raw_url": "https://github.com/google/guice/raw/e9e07b82e5b4dbf637cdaabde83bc12569533ba3/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FErrors.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FErrors.java?ref=e9e07b82e5b4dbf637cdaabde83bc12569533ba3",
      "patch": "@@ -82,11 +82,10 @@\n public final class Errors implements Serializable {\n \n   private static final Logger logger = Logger.getLogger(Guice.class.getName());\n-\n+  \n   private static final Set<Dependency<?>> warnedDependencies =\n       Collections.newSetFromMap(new ConcurrentHashMap<Dependency<?>, Boolean>());\n \n-\n   /**\n    * The root errors object. Used to access the list of error messages.\n    */\n@@ -150,7 +149,7 @@ public Errors withSource(Object source) {\n   public Errors missingImplementation(Key key) {\n     return addMessage(\"No implementation for %s was bound.\", key);\n   }\n-\n+  \n   public Errors jitDisabled(Key key) {\n     return addMessage(\"Explicit bindings are required and %s is not explicitly bound.\", key);\n   }\n@@ -296,7 +295,7 @@ public Errors duplicateBindingAnnotations(Member member,\n     return addMessage(\"%s has more than one annotation annotated with @BindingAnnotation: \"\n         + \"%s and %s\", member, a, b);\n   }\n-\n+  \n   public Errors staticInjectionOnInterface(Class<?> clazz) {\n     return addMessage(\"%s is an interface, but interfaces have no static injection points.\", clazz);\n   }\n@@ -329,7 +328,7 @@ public Errors recursiveBinding() {\n   public Errors bindingAlreadySet(Key<?> key, Object source) {\n     return addMessage(\"A binding to %s was already configured at %s.\", key, convert(source));\n   }\n-\n+  \n   public Errors jitBindingAlreadySet(Key<?> key) {\n     return addMessage(\"A just-in-time binding to %s was already configured on a parent injector.\", key);\n   }\n@@ -354,7 +353,7 @@ public Errors childBindingAlreadySet(Key<?> key, Set<Object> sources) {\n \n   public Errors errorCheckingDuplicateBinding(Key<?> key, Object source, Throwable t) {\n     return addMessage(\n-        \"A binding to %s was already configured at %s and an error was thrown \"\n+        \"A binding to %s was already configured at %s and an error was thrown \" \n       + \"while checking duplicate bindings.  Error: %s\",\n         key, convert(source), t);\n   }\n@@ -395,11 +394,11 @@ public Errors errorNotifyingInjectionListener(\n   public Errors exposedButNotBound(Key<?> key) {\n     return addMessage(\"Could not expose() %s, it must be explicitly bound.\", key);\n   }\n-\n+  \n   public Errors keyNotFullySpecified(TypeLiteral<?> typeLiteral) {\n     return addMessage(\"%s cannot be used as a key; It is not fully specified.\", typeLiteral);\n   }\n-\n+  \n   public Errors errorEnhancingClass(Class<?> clazz, Throwable cause) {\n     return errorInUserCode(cause, \"Unable to method intercept: %s\", clazz);\n   }\n@@ -425,7 +424,7 @@ public Errors errorInUserCode(Throwable cause, String messageFormat, Object... a\n       return addMessage(cause, messageFormat, arguments);\n     }\n   }\n-\n+  \n   private Throwable unwrap(Throwable runtimeException) {\n    if(runtimeException instanceof Exceptions.UnhandledCheckedUserException) {\n      return runtimeException.getCause();\n@@ -621,7 +620,7 @@ public static String format(String heading, Collection<Message> errorMessages) {\n    */\n   public <T> T checkForNull(T value, Object source, Dependency<?> dependency)\n       throws ErrorsException {\n-    if (value != null || dependency.isNullable() ) {\n+    if (value != null || dependency.isNullable()) {\n       return value;\n     }\n \n@@ -674,7 +673,7 @@ public static Throwable getOnlyCause(Collection<Message> messages) {\n         continue;\n       }\n \n-      if (onlyCause != null\n+      if (onlyCause != null \n           && !ThrowableEquivalence.INSTANCE.equivalent(onlyCause, messageCause)) {\n         return null;\n       }\n@@ -734,11 +733,11 @@ public static Object convert(Object o) {\n     ElementSource source = null;\n     if (o instanceof ElementSource) {\n       source = (ElementSource)o;\n-      o = source.getDeclaringSource();\n+      o = source.getDeclaringSource(); \n     }\n     return convert(o, source);\n   }\n-\n+  \n   public static Object convert(Object o, ElementSource source) {\n     for (Converter<?> converter : converters) {\n       if (converter.appliesTo(o)) {\n@@ -747,7 +746,7 @@ public static Object convert(Object o, ElementSource source) {\n     }\n     return appendModules(o, source);\n   }\n-\n+  \n   private static Object appendModules(Object source, ElementSource elementSource) {\n     String modules = moduleSourceString(elementSource);\n     if (modules.length() == 0) {\n@@ -756,7 +755,7 @@ private static Object appendModules(Object source, ElementSource elementSource)\n       return source + modules;\n     }\n   }\n-\n+  \n   private static String moduleSourceString(ElementSource elementSource) {\n     // if we only have one module (or don't know what they are), then don't bother\n     // reporting it, because the source already is going to report exactly that module.\n@@ -772,7 +771,7 @@ private static String moduleSourceString(ElementSource elementSource) {\n     if (modules.size() <= 1) {\n       return \"\";\n     }\n-\n+    \n     // Ideally we'd do:\n     //    return Joiner.on(\" -> \")\n     //        .appendTo(new StringBuilder(\" (via modules: \"), Lists.reverse(modules))\n@@ -783,7 +782,7 @@ private static String moduleSourceString(ElementSource elementSource) {\n       builder.append(modules.get(i));\n       if (i != 0) {\n         builder.append(\" -> \");\n-      }\n+      }      \n     }\n     builder.append(\")\");\n     return builder.toString();\n@@ -797,7 +796,7 @@ public static void formatSource(Formatter formatter, Object source) {\n     }\n     formatSource(formatter, source, elementSource);\n   }\n-\n+  \n   public static void formatSource(Formatter formatter, Object source, ElementSource elementSource) {\n     String modules = moduleSourceString(elementSource);\n     if (source instanceof Dependency) {",
      "parent_sha": "1a2c47caa558518644e42bd812516e65475dbd28"
    }
  },
  {
    "oid": "4d5804923d55353b214b8e2a45a6416a75665a4d",
    "message": "Fix random bitwise | to be a real ||.\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=50288042",
    "date": "2013-08-09T18:31:21Z",
    "url": "https://github.com/google/guice/commit/4d5804923d55353b214b8e2a45a6416a75665a4d",
    "details": {
      "sha": "36c10be048a1c5f0491f36117422ec3a805354f5",
      "filename": "core/src/com/google/inject/spi/InjectionPoint.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/4d5804923d55353b214b8e2a45a6416a75665a4d/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fspi%2FInjectionPoint.java",
      "raw_url": "https://github.com/google/guice/raw/4d5804923d55353b214b8e2a45a6416a75665a4d/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fspi%2FInjectionPoint.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fspi%2FInjectionPoint.java?ref=4d5804923d55353b214b8e2a45a6416a75665a4d",
      "patch": "@@ -678,7 +678,7 @@ private static Set<InjectionPoint> getInjectionPoints(final TypeLiteral<?> type,\n             InjectableMethod injectableMethod = new InjectableMethod(\n                 current, method, atInject);\n             if (checkForMisplacedBindingAnnotations(method, errors)\n-                | !isValidMethod(injectableMethod, errors)) {\n+                || !isValidMethod(injectableMethod, errors)) {\n               if (overrideIndex != null) {\n                 boolean removed = overrideIndex.removeIfOverriddenBy(method, false, injectableMethod);\n                 if(removed) {",
      "parent_sha": "51829aa27bf05c2c84b6ca90225c61c55c675056"
    }
  },
  {
    "oid": "013039198244a5cd106de0a6e20e66839117ef49",
    "message": "Doing a cleanup before we can make having @javax.inject.Inject on an abstract method a compile error. I am suppressing the error for the test case that intentionally tests this error.\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=50571932",
    "date": "2013-08-09T18:31:59Z",
    "url": "https://github.com/google/guice/commit/013039198244a5cd106de0a6e20e66839117ef49",
    "details": {
      "sha": "57cd6e09a9b81e4dfef9006f0834ce9444a16560",
      "filename": "core/test/com/googlecode/guice/Jsr330Test.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/google/guice/blob/013039198244a5cd106de0a6e20e66839117ef49/core%2Ftest%2Fcom%2Fgooglecode%2Fguice%2FJsr330Test.java",
      "raw_url": "https://github.com/google/guice/raw/013039198244a5cd106de0a6e20e66839117ef49/core%2Ftest%2Fcom%2Fgooglecode%2Fguice%2FJsr330Test.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Ftest%2Fcom%2Fgooglecode%2Fguice%2FJsr330Test.java?ref=013039198244a5cd106de0a6e20e66839117ef49",
      "patch": "@@ -448,7 +448,9 @@ static class L {\n   }\n \n   static abstract class AbstractM {\n-    @Inject abstract void setB(B b);\n+    @SuppressWarnings(\"InjectJavaxInjectOnAbstractMethod\")\n+    @Inject\n+    abstract void setB(B b);\n   }\n \n   static class M extends AbstractM {",
      "parent_sha": "4352fa034ab6dd0c7ce117a07620426ddb00a50d"
    }
  },
  {
    "oid": "02d991800cbd1467256b45e81a1b1f6c278a3a54",
    "message": "Applying dtm's suggestions for r723.\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@730 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2008-12-10T03:47:57Z",
    "url": "https://github.com/google/guice/commit/02d991800cbd1467256b45e81a1b1f6c278a3a54",
    "details": {
      "sha": "4bae0e331fa59943f397ee53f91734391ae2f1fe",
      "filename": "extensions/assistedinject/test/com/google/inject/assistedinject/FactoryProvider2Test.java",
      "status": "modified",
      "additions": 51,
      "deletions": 3,
      "changes": 54,
      "blob_url": "https://github.com/google/guice/blob/02d991800cbd1467256b45e81a1b1f6c278a3a54/extensions%2Fassistedinject%2Ftest%2Fcom%2Fgoogle%2Finject%2Fassistedinject%2FFactoryProvider2Test.java",
      "raw_url": "https://github.com/google/guice/raw/02d991800cbd1467256b45e81a1b1f6c278a3a54/extensions%2Fassistedinject%2Ftest%2Fcom%2Fgoogle%2Finject%2Fassistedinject%2FFactoryProvider2Test.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fassistedinject%2Ftest%2Fcom%2Fgoogle%2Finject%2Fassistedinject%2FFactoryProvider2Test.java?ref=02d991800cbd1467256b45e81a1b1f6c278a3a54",
      "patch": "@@ -19,6 +19,7 @@\n import com.google.inject.AbstractModule;\n import static com.google.inject.Asserts.assertContains;\n import static com.google.inject.Asserts.assertEqualsBothWays;\n+import com.google.inject.ConfigurationException;\n import com.google.inject.CreationException;\n import com.google.inject.Guice;\n import com.google.inject.Inject;\n@@ -319,7 +320,8 @@ protected void configure() {\n             FactoryProvider.newFactory(ColoredCarFactory.class, Prius.class));\n       }\n     });\n-    Car car = injector.getInstance(ColoredCarFactory.class).create(Color.ORANGE);\n+    Prius prius = (Prius) injector.getInstance(ColoredCarFactory.class).create(Color.ORANGE);\n+    assertEquals(prius.color, Color.ORANGE);\n   }\n \n   public static class ExplodingCar implements Car {\n@@ -634,8 +636,54 @@ protected void configure() {\n     assertEquals(1, invocationCount.get());\n   }\n \n+  /**\n+   * Our factories aren't reusable across injectors. Although this behaviour isn't something we\n+   * like, I have a test case to make sure the error message is pretty.\n+   */\n+  public void testFactoryReuseErrorMessageIsPretty() {\n+    final Provider<ColoredCarFactory> factoryProvider\n+        = FactoryProvider.newFactory(ColoredCarFactory.class, Mustang.class);\n+\n+    Guice.createInjector(new AbstractModule() {\n+      @Override protected void configure() {\n+        bind(Double.class).toInstance(5.0d);\n+        bind(ColoredCarFactory.class).toProvider(factoryProvider);\n+      }\n+    });\n+\n+    try {\n+      Guice.createInjector(new AbstractModule() {\n+        @Override protected void configure() {\n+          bind(Double.class).toInstance(5.0d);\n+          bind(ColoredCarFactory.class).toProvider(factoryProvider);\n+        }\n+      });\n+      fail();\n+    } catch(CreationException expected) {\n+      assertContains(expected.getMessage(),\n+          \"Factories.create() factories may only be used in one Injector!\");\n+    }\n+  }\n+\n+  public void testNonAssistedFactoryMethodParameter() {\n+    try {\n+      FactoryProvider.newFactory(NamedParameterFactory.class, Mustang.class);\n+      fail();\n+    } catch(ConfigurationException expected) {\n+      assertContains(expected.getMessage(),\n+          \"Only @Assisted is allowed for factory parameters, but found @\" + Named.class.getName());\n+    }\n+  }\n+\n+  interface NamedParameterFactory {\n+    Car create(@Named(\"seats\") int seats, double engineSize);\n+  }\n+\n+\n   public void testDefaultAssistedAnnotation() throws NoSuchFieldException {\n-    assertEqualsBothWays(FactoryProvider2.DEFAULT_ANNOTATION,\n-        Subaru.class.getDeclaredField(\"colorProvider\").getAnnotation(Assisted.class));\n+    Assisted plainAssisted\n+        = Subaru.class.getDeclaredField(\"colorProvider\").getAnnotation(Assisted.class);\n+    assertEqualsBothWays(FactoryProvider2.DEFAULT_ANNOTATION, plainAssisted);\n+    assertEquals(FactoryProvider2.DEFAULT_ANNOTATION.toString(), plainAssisted.toString());\n   }\n }",
      "parent_sha": "79dc99b410c726328662205365c5f70c0088bfab"
    }
  },
  {
    "oid": "5cc91437f7a1fc3c4fdcc4b3014ea008ada60570",
    "message": "Fixing a bug where CGLib + multiple classes with the same FQN = pain\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@481 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2008-05-14T18:58:41Z",
    "url": "https://github.com/google/guice/commit/5cc91437f7a1fc3c4fdcc4b3014ea008ada60570",
    "details": {
      "sha": "548178e7e2c0edfc6fb7664b0c4283b2b8773036",
      "filename": "src/com/google/inject/ProxyFactory.java",
      "status": "modified",
      "additions": 6,
      "deletions": 3,
      "changes": 9,
      "blob_url": "https://github.com/google/guice/blob/5cc91437f7a1fc3c4fdcc4b3014ea008ada60570/src%2Fcom%2Fgoogle%2Finject%2FProxyFactory.java",
      "raw_url": "https://github.com/google/guice/raw/5cc91437f7a1fc3c4fdcc4b3014ea008ada60570/src%2Fcom%2Fgoogle%2Finject%2FProxyFactory.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/src%2Fcom%2Fgoogle%2Finject%2FProxyFactory.java?ref=5cc91437f7a1fc3c4fdcc4b3014ea008ada60570",
      "patch": "@@ -16,7 +16,10 @@\n \n package com.google.inject;\n \n-import com.google.inject.internal.*;\n+import com.google.inject.internal.ErrorHandler;\n+import com.google.inject.internal.GuiceFastClass;\n+import com.google.inject.internal.GuiceNamingPolicy;\n+import com.google.inject.internal.ReferenceCache;\n import net.sf.cglib.proxy.Callback;\n import net.sf.cglib.proxy.CallbackFilter;\n import net.sf.cglib.proxy.Enhancer;\n@@ -27,8 +30,8 @@\n \n import java.lang.reflect.Constructor;\n import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.List;\n@@ -177,7 +180,7 @@ public T newInstance(Object... arguments)\n       }\n \n       public List<Parameter<?>> getParameters() {\n-        return Parameter.forConstructor(errorHandler, fastConstructor.getJavaConstructor());\n+        return Parameter.forConstructor(errorHandler, standardConstructor);\n       }\n \n       public Member getMember() {",
      "parent_sha": "7e6659ce3641a8747059ad871780490a79d1b020"
    }
  },
  {
    "oid": "d492cd8e9aa71c423ac036e83d9b37a33c273158",
    "message": "Temporarily remove `@InlineMe` from `Modules.combine(Module)`.\n\nPiperOrigin-RevId: 635570248",
    "date": "2024-05-20T21:26:04Z",
    "url": "https://github.com/google/guice/commit/d492cd8e9aa71c423ac036e83d9b37a33c273158",
    "details": {
      "sha": "1d369f34bd606a1b04dc76b7e4f0fe4855c57ccc",
      "filename": "core/src/com/google/inject/util/Modules.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/google/guice/blob/d492cd8e9aa71c423ac036e83d9b37a33c273158/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Futil%2FModules.java",
      "raw_url": "https://github.com/google/guice/raw/d492cd8e9aa71c423ac036e83d9b37a33c273158/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Futil%2FModules.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Futil%2FModules.java?ref=d492cd8e9aa71c423ac036e83d9b37a33c273158",
      "patch": "@@ -23,7 +23,6 @@\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.errorprone.annotations.CheckReturnValue;\n-import com.google.errorprone.annotations.InlineMe;\n import com.google.inject.AbstractModule;\n import com.google.inject.Binder;\n import com.google.inject.Binding;\n@@ -126,7 +125,7 @@ public static Module combine(Module... modules) {\n   /**\n    * @deprecated there's no need to \"combine\" one module; just install it directly.\n    */\n-  @InlineMe(replacement = \"module\")\n+  // TODO(b/341757497): re-enable this inlining: @InlineMe(replacement = \"module\")\n   @Deprecated\n   public static Module combine(Module module) {\n     return module;",
      "parent_sha": "2b37f020862e45be58f246a63c2f97fdaff0d433"
    }
  },
  {
    "oid": "60fddb2c28514396af3ca740027a844c820d92a8",
    "message": "Provide a non-empty name for the test cookie.\n\nPiperOrigin-RevId: 410290707",
    "date": "2021-11-16T18:32:16Z",
    "url": "https://github.com/google/guice/commit/60fddb2c28514396af3ca740027a844c820d92a8",
    "details": {
      "sha": "526dbd88b6a2ef3752211f9b214516734e2d7f4a",
      "filename": "extensions/servlet/test/com/google/inject/servlet/ContinuingHttpServletRequestTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/60fddb2c28514396af3ca740027a844c820d92a8/extensions%2Fservlet%2Ftest%2Fcom%2Fgoogle%2Finject%2Fservlet%2FContinuingHttpServletRequestTest.java",
      "raw_url": "https://github.com/google/guice/raw/60fddb2c28514396af3ca740027a844c820d92a8/extensions%2Fservlet%2Ftest%2Fcom%2Fgoogle%2Finject%2Fservlet%2FContinuingHttpServletRequestTest.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fservlet%2Ftest%2Fcom%2Fgoogle%2Finject%2Fservlet%2FContinuingHttpServletRequestTest.java?ref=60fddb2c28514396af3ca740027a844c820d92a8",
      "patch": "@@ -29,7 +29,7 @@ public class ContinuingHttpServletRequestTest extends TestCase {\n \n   private static final String TEST_VALUE_1 = \"testValue1\";\n   private static final String TEST_VALUE_2 = \"testValue2\";\n-  private static final int DEFAULT_MAX_AGE = new Cookie(\"\", \"\").getMaxAge();\n+  private static final int DEFAULT_MAX_AGE = new Cookie(\"dummy\", \"\").getMaxAge();\n \n   public void testReturnNullCookiesIfDelegateHasNoNull() {\n     HttpServletRequest delegate = createMock(HttpServletRequest.class);",
      "parent_sha": "0ce94279a16de97c46ae2914382dc7638de62e90"
    }
  },
  {
    "oid": "1152193259ca156d31890014bb96e3ae2484a661",
    "message": "Use `@Keep` to hint to static analysis that a field is used reflectively\n\nPiperOrigin-RevId: 714976142",
    "date": "2025-01-13T16:25:38Z",
    "url": "https://github.com/google/guice/commit/1152193259ca156d31890014bb96e3ae2484a661",
    "details": {
      "sha": "0517994626feb9a92252ccf6c284998e64d6bb81",
      "filename": "core/src/com/google/inject/internal/InternalContext.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/google/guice/blob/1152193259ca156d31890014bb96e3ae2484a661/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInternalContext.java",
      "raw_url": "https://github.com/google/guice/raw/1152193259ca156d31890014bb96e3ae2484a661/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInternalContext.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInternalContext.java?ref=1152193259ca156d31890014bb96e3ae2484a661",
      "patch": "@@ -17,6 +17,7 @@\n package com.google.inject.internal;\n \n import com.google.common.annotations.VisibleForTesting;\n+import com.google.errorprone.annotations.Keep;\n import com.google.inject.spi.Dependency;\n import java.lang.invoke.MethodHandles;\n import java.lang.invoke.VarHandle;\n@@ -47,8 +48,7 @@ static final class CircularFactoryIdFactory {\n     // The first factory id is 1 so that we never produce a circular factory id of 0.\n     // The tables below use 0 to represent an empty slot which is convenient since arrays are always\n     // zero initialized.\n-    @SuppressWarnings({\"FieldCanBeFinal\", \"unused\"})\n-    private int id = 1;\n+    @Keep private int id = 1;\n \n     /** Returns the next circular factory id. */\n     int next() {",
      "parent_sha": "c5e7d93796cb703e3d156f7385dcc6ee5c3482f5"
    }
  },
  {
    "oid": "e7a727cba43dac01dee474d05bb76e9baf633abd",
    "message": "Optimized InjectionPoint.\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@1100 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2009-09-29T07:52:01Z",
    "url": "https://github.com/google/guice/commit/e7a727cba43dac01dee474d05bb76e9baf633abd",
    "details": {
      "sha": "b25c915bcefe3e51a3b4150294be0dd985f044c9",
      "filename": "src/com/google/inject/spi/InjectionPoint.java",
      "status": "modified",
      "additions": 201,
      "deletions": 98,
      "changes": 299,
      "blob_url": "https://github.com/google/guice/blob/e7a727cba43dac01dee474d05bb76e9baf633abd/src%2Fcom%2Fgoogle%2Finject%2Fspi%2FInjectionPoint.java",
      "raw_url": "https://github.com/google/guice/raw/e7a727cba43dac01dee474d05bb76e9baf633abd/src%2Fcom%2Fgoogle%2Finject%2Fspi%2FInjectionPoint.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/src%2Fcom%2Fgoogle%2Finject%2Fspi%2FInjectionPoint.java?ref=e7a727cba43dac01dee474d05bb76e9baf633abd",
      "patch": "@@ -39,11 +39,11 @@\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.Iterator;\n-import java.util.LinkedHashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n+import java.util.HashMap;\n \n /**\n  * A constructor, field or method that can receive injections. Typically this is a member with the\n@@ -356,6 +356,9 @@ public static Set<InjectionPoint> forInstanceMethodsAndFields(Class<?> type) {\n     return forInstanceMethodsAndFields(TypeLiteral.get(type));\n   }\n \n+  /**\n+   * Returns true if the binding annotation is in the wrong place.\n+   */\n   private static boolean checkForMisplacedBindingAnnotations(Member member, Errors errors) {\n     Annotation misplacedBindingAnnotation = Annotations.findBindingAnnotation(\n         errors, member, ((AnnotatedElement) member).getAnnotations());\n@@ -380,135 +383,230 @@ private static boolean checkForMisplacedBindingAnnotations(Member member, Errors\n \n   static abstract class InjectableMember {\n     final TypeLiteral<?> declaringType;\n-    final boolean injectable;\n     final boolean optional;\n     final boolean jsr330;\n+    InjectableMember previous;\n+    InjectableMember next;\n \n-    InjectableMember(TypeLiteral<?> declaringType, AnnotatedElement member) {\n+    InjectableMember(TypeLiteral<?> declaringType, Annotation atInject) {\n       this.declaringType = declaringType;\n \n-      javax.inject.Inject jsr330Inject = member.getAnnotation(javax.inject.Inject.class);\n-      if (jsr330Inject != null) {\n-        injectable = true;\n+      if (atInject.annotationType() == javax.inject.Inject.class) {\n         optional = false;\n         jsr330 = true;\n         return;\n       }\n \n       jsr330 = false;\n-\n-      Inject inject = member.getAnnotation(Inject.class);\n-      if (inject != null) {\n-        injectable = true;\n-        optional = inject.optional();\n-        return;\n-      }\n-\n-      injectable = false;\n-      optional = false;\n+      optional = ((Inject) atInject).optional();\n     }\n \n-    abstract InjectionPoint toInjectionPoint(Errors errors);\n+    abstract InjectionPoint toInjectionPoint();\n   }\n \n   static class InjectableField extends InjectableMember {\n     final Field field;\n-    InjectableField(TypeLiteral<?> declaringType, Field field) {\n-      super(declaringType, field);\n+    InjectableField(TypeLiteral<?> declaringType, Field field,\n+        Annotation atInject) {\n+      super(declaringType, atInject);\n       this.field = field;\n     }\n \n-    InjectionPoint toInjectionPoint(Errors errors) {\n+    InjectionPoint toInjectionPoint() {\n       return new InjectionPoint(declaringType, field, optional);\n     }\n   }\n \n   static class InjectableMethod extends InjectableMember {\n     final Method method;\n-    InjectableMethod(TypeLiteral<?> declaringType, Method method) {\n-      super(declaringType, method);\n+    InjectableMethod(TypeLiteral<?> declaringType, Method method,\n+        Annotation atInject) {\n+      super(declaringType, atInject);\n       this.method = method;\n     }\n \n-    InjectionPoint toInjectionPoint(Errors errors) {\n-      checkForMisplacedBindingAnnotations(method, errors);\n+    InjectionPoint toInjectionPoint() {\n       return new InjectionPoint(declaringType, method, optional);\n     }\n+\n+    public boolean isFinal() {\n+      return Modifier.isFinal(method.getModifiers());\n+    }\n+  }\n+\n+  static Annotation getAtInject(AnnotatedElement member) {\n+    Annotation a = member.getAnnotation(javax.inject.Inject.class);\n+    return a == null ? member.getAnnotation(Inject.class) : a;\n+  }\n+\n+  /**\n+   * Linked list of injectable members.\n+   */\n+  static class InjectableMembers {\n+    InjectableMember head;\n+    InjectableMember tail;\n+\n+    void add(InjectableMember member) {\n+      if (head == null) {\n+        head = tail = member;\n+      } else {\n+        member.previous = tail;\n+        tail.next = member;\n+        tail = member;\n+      }\n+    }\n+\n+    void remove(InjectableMember member) {\n+      if (member.previous != null) {\n+        member.previous.next = member.next;\n+      }\n+      if (member.next != null) {\n+        member.next.previous = member.previous;\n+      }\n+      if (head == member) {\n+        head = member.next;\n+      }\n+      if (tail == member) {\n+        tail = member.previous;\n+      }\n+    }\n+\n+    boolean isEmpty() {\n+      return head == null;\n+    }\n+  }\n+\n+  /** Position in type hierarchy. */\n+  enum Position {\n+    TOP, // No need to check for overridden methods\n+    MIDDLE,\n+    BOTTOM // Methods won't be overridden\n+  }\n+\n+  static class OverrideIndex {\n+    final InjectableMembers injectableMembers;\n+    Map<Signature, List<InjectableMethod>> bySignature;\n+    Position position = Position.TOP;\n+    boolean hasMethods = false;\n+\n+    OverrideIndex(InjectableMembers injectableMembers) {\n+      this.injectableMembers = injectableMembers;\n+    }\n+\n+    /* Caches the signature for the last method. */\n+    Method lastMethod;\n+    Signature lastSignature;\n+\n+    void removeIfOverriddenBy(Method method) {\n+      if (!hasMethods || position == Position.TOP) {\n+        // There's nothing to remove.\n+        return;\n+      }\n+\n+      if (bySignature == null) {\n+        // We encountered a method in a subclass. Time to index the\n+        // methods in the parent class.\n+        bySignature = new HashMap<Signature, List<InjectableMethod>>();\n+        for (InjectableMember member = injectableMembers.head; member != null;\n+            member = member.next) {\n+          if (!(member instanceof InjectableMethod)) continue;\n+          InjectableMethod im = (InjectableMethod) member;\n+          if (im.isFinal()) continue;\n+          List<InjectableMethod> methods = new ArrayList<InjectableMethod>();\n+          methods.add(im);\n+          bySignature.put(new Signature(im.method), methods);\n+        }\n+      }\n+\n+      lastMethod = method;\n+      Signature signature = lastSignature = new Signature(method);\n+      List<InjectableMethod> methods = bySignature.get(signature);\n+      if (methods != null) {\n+        for (Iterator<InjectableMethod> iterator = methods.iterator();\n+            iterator.hasNext();) {\n+          InjectableMethod possiblyOverridden = iterator.next();\n+          if (overrides(method, possiblyOverridden.method)) {\n+            iterator.remove();\n+            injectableMembers.remove(possiblyOverridden);\n+          }\n+        }\n+      }\n+    }\n+\n+    void add(InjectableMethod injectableMethod) {\n+      hasMethods = true;\n+      injectableMembers.add(injectableMethod);\n+      if (position == Position.BOTTOM\n+          || injectableMethod.isFinal()) {\n+        // This method can't be overridden, so there's no need to index it.\n+        return;\n+      }\n+      if (bySignature != null) {\n+        // Try to reuse the signature we created during removal\n+        Signature signature = injectableMethod.method == lastMethod\n+            ? lastSignature : new Signature(injectableMethod.method);\n+        List<InjectableMethod> methods = bySignature.get(signature);\n+        if (methods == null) {\n+          methods = new ArrayList<InjectableMethod>();\n+          bySignature.put(signature, methods);\n+        }\n+        methods.add(injectableMethod);\n+      }\n+    }\n   }\n \n   private static Set<InjectionPoint> getInjectionPoints(final TypeLiteral<?> type,\n       boolean statics, Errors errors) {\n-    // TODO: Turn InjectableMember into an identity wrapper. Use it as the key in\n-    // injectableMembers and the values in bySignature. This will be a lot faster than\n-    // hashing the Method objects.\n-    LinkedHashMap<Member, InjectableMember> injectableMembers\n-        = new LinkedHashMap<Member, InjectableMember>();\n-    HashMap<Signature, List<Method>> bySignature = null;\n-\n-    for (TypeLiteral<?> current : hierarchyFor(type)) {\n+    InjectableMembers injectableMembers = new InjectableMembers();\n+    OverrideIndex overrideIndex = null;\n+\n+    List<TypeLiteral<?>> hierarchy = hierarchyFor(type);\n+    int topIndex = hierarchy.size() - 1;\n+    for (int i = topIndex; i >= 0; i--) {\n+      if (overrideIndex != null && i < topIndex) {\n+        // Knowing the position within the hierarchy helps us make optimizations.\n+        if (i == 0) {\n+          overrideIndex.position = Position.BOTTOM;\n+        } else {\n+          overrideIndex.position = Position.MIDDLE;\n+        }\n+      }\n+\n+      TypeLiteral<?> current = hierarchy.get(i);\n+\n       for (Field field : current.getRawType().getDeclaredFields()) {\n         if (Modifier.isStatic(field.getModifiers()) == statics) {\n-          InjectableField injectableField = new InjectableField(current, field);\n-          if (injectableField.injectable) {\n+          Annotation atInject = getAtInject(field);\n+          if (atInject != null) {\n+            InjectableField injectableField = new InjectableField(current, field, atInject);\n             if (injectableField.jsr330 && Modifier.isFinal(field.getModifiers())) {\n               errors.cannotInjectFinalField(field);\n-              continue;\n             }\n-            injectableMembers.put(field, injectableField);\n+            injectableMembers.add(injectableField);\n           }\n         }\n       }\n \n       for (Method method : current.getRawType().getDeclaredMethods()) {\n-        boolean isStatic = Modifier.isStatic(method.getModifiers());\n-        if (isStatic == statics) {\n-          InjectableMethod injectableMethod = new InjectableMethod(current, method);\n-\n-          if (injectableMethod.injectable) {\n-            boolean result = true;\n-            if (injectableMethod.jsr330) {\n-              if (Modifier.isAbstract(method.getModifiers())) {\n-                errors.cannotInjectAbstractMethod(method);\n-                result = false;\n-              }\n-              if (method.getTypeParameters().length > 0) {\n-                errors.cannotInjectMethodWithTypeParameters(method);\n-                result = false;\n-              }\n-            }\n-            if (!result) {\n+        if (Modifier.isStatic(method.getModifiers()) == statics) {\n+          if (overrideIndex != null) {\n+            overrideIndex.removeIfOverriddenBy(method);\n+          }\n+          Annotation atInject = getAtInject(method);\n+          if (atInject != null) {\n+            InjectableMethod injectableMethod = new InjectableMethod(\n+                current, method, atInject);\n+            if (checkForMisplacedBindingAnnotations(method, errors)\n+                | !isValidMethod(injectableMethod, errors)) {\n               continue;\n             }\n-            if (isStatic && statics) {\n-              injectableMembers.put(method, injectableMethod);\n-            }\n-          }\n-\n-          if (!isStatic) {\n-            // Remove overridden method if present.\n-            List<Method> possibleOverrides = null;\n-            Signature signature = new Signature(method);\n-            if (bySignature == null) {\n-              // Lazily initialize the bySignature map.\n-              bySignature = new HashMap<Signature, List<Method>>();\n+            if (statics) {\n+              injectableMembers.add(injectableMethod);\n             } else {\n-              possibleOverrides = bySignature.get(signature);\n-              if (possibleOverrides != null) {\n-                Method overridden = removeOverriddenMethod(method, possibleOverrides);\n-                if (overridden != null) {\n-                  injectableMembers.remove(overridden);\n-                }\n+              if (overrideIndex == null) {\n+                overrideIndex = new OverrideIndex(injectableMembers);\n               }\n-            }\n-\n-            if (injectableMethod.injectable) {\n-              // Keep track of this method in case it gets overridden.\n-              if (possibleOverrides == null) {\n-                possibleOverrides = new ArrayList<Method>();\n-                bySignature.put(signature, possibleOverrides);\n-              }\n-              possibleOverrides.add(method);\n-              injectableMembers.put(method, injectableMethod);\n+              overrideIndex.add(injectableMethod);\n             }\n           }\n         }\n@@ -520,41 +618,46 @@ private static Set<InjectionPoint> getInjectionPoints(final TypeLiteral<?> type,\n     }\n \n     ImmutableSet.Builder<InjectionPoint> builder = ImmutableSet.builder();\n-    for (InjectableMember injectableMember : injectableMembers.values()) {\n+    for (InjectableMember im = injectableMembers.head; im != null;\n+        im = im.next) {\n       try {\n-        builder.add(injectableMember.toInjectionPoint(errors));\n+        builder.add(im.toInjectionPoint());\n       } catch (ConfigurationException ignorable) {\n-        if (!injectableMember.optional) {\n+        if (!im.optional) {\n           errors.merge(ignorable.getErrorMessages());\n         }\n       }\n     }\n     return builder.build();\n   }\n \n+  private static boolean isValidMethod(InjectableMethod injectableMethod,\n+      Errors errors) {\n+    boolean result = true;\n+    if (injectableMethod.jsr330) {\n+      Method method = injectableMethod.method;\n+      if (Modifier.isAbstract(method.getModifiers())) {\n+        errors.cannotInjectAbstractMethod(method);\n+        result = false;\n+      }\n+      if (method.getTypeParameters().length > 0) {\n+        errors.cannotInjectMethodWithTypeParameters(method);\n+        result = false;\n+      }\n+    }\n+    return result;\n+  }\n+\n   private static List<TypeLiteral<?>> hierarchyFor(TypeLiteral<?> type) {\n-    // Construct type hierarchy from Object.class down.\n     List<TypeLiteral<?>> hierarchy = new ArrayList<TypeLiteral<?>>();\n     TypeLiteral<?> current = type;\n     while (current.getRawType() != Object.class) {\n       hierarchy.add(current);\n       current = current.getSupertype(current.getRawType().getSuperclass());\n     }\n-    Collections.reverse(hierarchy);\n     return hierarchy;\n   }\n \n-  private static Method removeOverriddenMethod(Method method, List<Method> possibleOverrides) {\n-    for (Iterator<Method> iterator = possibleOverrides.iterator(); iterator.hasNext();) {\n-      Method possibleOverride = iterator.next();\n-      if (overrides(method, possibleOverride)) {\n-        iterator.remove();\n-        return possibleOverride;\n-      }\n-    }\n-    return null;\n-  }\n-\n   /**\n    * Returns true if a overrides b. Assumes signatures of a and b are the same and a's declaring\n    * class is a subclass of b's declaring class.",
      "parent_sha": "446532747d3648f257f9c47d23e04ac7ad759a72"
    }
  },
  {
    "oid": "b32439cc99492c694148c59f901edafe5b05638b",
    "message": "no visible change\n\nPiperOrigin-RevId: 435193059",
    "date": "2022-03-16T23:38:54Z",
    "url": "https://github.com/google/guice/commit/b32439cc99492c694148c59f901edafe5b05638b",
    "details": {
      "sha": "be510dc8445913401b8d1f0517434e9012ebee1e",
      "filename": "core/src/com/google/inject/internal/KotlinSupport.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/b32439cc99492c694148c59f901edafe5b05638b/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FKotlinSupport.java",
      "raw_url": "https://github.com/google/guice/raw/b32439cc99492c694148c59f901edafe5b05638b/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FKotlinSupport.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FKotlinSupport.java?ref=b32439cc99492c694148c59f901edafe5b05638b",
      "patch": "@@ -8,7 +8,7 @@\n \n /**\n  * Class to conditionally load support for Kotlin features. These features are enabled based on\n- * whether {@code com.google.inject.kotlin.KotlinSupportImpl} is in the class path.\n+ * whether {@code com.google.inject.KotlinSupportImpl} is in the class path.\n  */\n public final class KotlinSupport {\n ",
      "parent_sha": "7eddc637b64a8a3322655496617a2786b2683927"
    }
  },
  {
    "oid": "36e6d8dcbe30e0cd8abc59ee418005df8c10371e",
    "message": "Javadoc fix, servlet scopes as singleton.\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@845 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2009-02-14T00:34:42Z",
    "url": "https://github.com/google/guice/commit/36e6d8dcbe30e0cd8abc59ee418005df8c10371e",
    "details": {
      "sha": "23ef91d535eb4e74836de197fcac9529124ac45e",
      "filename": "servlet/src/com/google/inject/servlet/ServletModule.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/google/guice/blob/36e6d8dcbe30e0cd8abc59ee418005df8c10371e/servlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletModule.java",
      "raw_url": "https://github.com/google/guice/raw/36e6d8dcbe30e0cd8abc59ee418005df8c10371e/servlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletModule.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/servlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletModule.java?ref=36e6d8dcbe30e0cd8abc59ee418005df8c10371e",
      "patch": "@@ -73,8 +73,9 @@ protected final void configure() {\n    *       <b>serve(\"/my/*\").with(MyServlet.class)</b>\n    * </pre>\n    *\n-   * Every servlet is required to be a singleton and will implicitly be bound as one if it isn't\n-   * already. Mapping a servlet that is bound under any other scope is an error.\n+   * Every servlet (or filter) is required to be a singleton. If you cannot annotate the class\n+   * directly, you should add a separate {@code bind(..).in(Singleton.class)} rule elsewhere in\n+   * your module. Mapping a servlet that is bound under any other scope is an error.\n    *\n    * <p>\n    * <h4>Dispatch Order</h4>",
      "parent_sha": "4957f9a2eb591d1d7b4fe0262aa02901fa0062ac"
    }
  },
  {
    "oid": "56a879c866f7039321331d1f4305619adba527cb",
    "message": "fix issue 624.\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@1588 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2011-10-16T16:26:00Z",
    "url": "https://github.com/google/guice/commit/56a879c866f7039321331d1f4305619adba527cb",
    "details": {
      "sha": "703187f8514a09c999a53b1b82b94011774a75c0",
      "filename": "core/src/com/google/inject/Guice.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/google/guice/blob/56a879c866f7039321331d1f4305619adba527cb/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2FGuice.java",
      "raw_url": "https://github.com/google/guice/raw/56a879c866f7039321331d1f4305619adba527cb/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2FGuice.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2FGuice.java?ref=56a879c866f7039321331d1f4305619adba527cb",
      "patch": "@@ -52,7 +52,8 @@ public final class Guice {\n   private Guice() {}\n \n   /**\n-   * Creates an injector for the given set of modules.\n+   * Creates an injector for the given set of modules. This is equivalent to\n+   * calling {@link #createInjector(Stage, Module...)} with Stage.DEVELOPMENT.\n    *\n    * @throws CreationException if one or more errors occur during injector\n    *     construction\n@@ -62,7 +63,8 @@ public static Injector createInjector(Module... modules) {\n   }\n \n   /**\n-   * Creates an injector for the given set of modules.\n+   * Creates an injector for the given set of modules. This is equivalent to\n+   * calling {@link #createInjector(Stage, Iterable)} with Stage.DEVELOPMENT.\n    *\n    * @throws CreationException if one or more errors occur during injector\n    *     creation",
      "parent_sha": "fb66c4219616e45fd19a8ccb5e93130d77ef96a3"
    }
  },
  {
    "oid": "10925e44f80f335423f128b107ec176b7436a20b",
    "message": "sberlin review for the previous CL.\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@1232 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2010-09-14T19:16:37Z",
    "url": "https://github.com/google/guice/commit/10925e44f80f335423f128b107ec176b7436a20b",
    "details": {
      "sha": "4b2de40a3bdfa8309244247fca4aebb9ee32f02b",
      "filename": "extensions/servlet/test/com/google/inject/servlet/ContinuingRequestIntegrationTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/google/guice/blob/10925e44f80f335423f128b107ec176b7436a20b/extensions%2Fservlet%2Ftest%2Fcom%2Fgoogle%2Finject%2Fservlet%2FContinuingRequestIntegrationTest.java",
      "raw_url": "https://github.com/google/guice/raw/10925e44f80f335423f128b107ec176b7436a20b/extensions%2Fservlet%2Ftest%2Fcom%2Fgoogle%2Finject%2Fservlet%2FContinuingRequestIntegrationTest.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fservlet%2Ftest%2Fcom%2Fgoogle%2Finject%2Fservlet%2FContinuingRequestIntegrationTest.java?ref=10925e44f80f335423f128b107ec176b7436a20b",
      "patch": "@@ -43,6 +43,7 @@\n import static org.easymock.EasyMock.eq;\n import static org.easymock.EasyMock.expect;\n import static org.easymock.EasyMock.replay;\n+import static org.easymock.EasyMock.verify;\n \n /**\n  * Tests continuation of requests\n@@ -107,7 +108,6 @@ public final void testRequestContinuesInOtherThread()\n \n     HttpServletRequest request = createMock(HttpServletRequest.class);\n \n-    expect(request.getRequestURI()).andReturn(\"/\");\n     expect(request.getServletPath()).andReturn(\"/\");\n     expect(request.getMethod()).andReturn(\"GET\");\n \n@@ -124,6 +124,7 @@ public final void testRequestContinuesInOtherThread()\n     executor.awaitTermination(10, TimeUnit.SECONDS);\n \n     assertEquals(PARAM_VALUE, injector.getInstance(OffRequestCallable.class).value);\n+    verify(request, filterConfig, filterChain);\n   }\n \n   public final void testRequestContinuesInSameThread()\n@@ -155,7 +156,6 @@ public final void testRequestContinuesInSameThread()\n     request.setAttribute(eq(\"Key[type=javax.servlet.http.HttpServletRequest, annotation=[none]]\"),\n         anyObject());\n \n-    expect(request.getRequestURI()).andReturn(\"/\");\n     expect(request.getServletPath()).andReturn(\"/\");\n     expect(request.getMethod()).andReturn(\"GET\");\n \n@@ -172,6 +172,8 @@ public final void testRequestContinuesInSameThread()\n     executor.awaitTermination(10, TimeUnit.SECONDS);\n \n     assertEquals(PARAM_VALUE, injector.getInstance(OffRequestCallable.class).value);\n+\n+    verify(request, filterConfig, filterChain);\n   }\n \n   @Singleton",
      "parent_sha": "7ebe5f6510e887a3f7d5569dd42874266ede1333"
    }
  },
  {
    "oid": "c1c95304b30913d7aeecc549acb677c5925fc8a4",
    "message": "Fixing tests for InjectionPoint and Dependency serialization\n\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@962 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2009-05-19T01:04:27Z",
    "url": "https://github.com/google/guice/commit/c1c95304b30913d7aeecc549acb677c5925fc8a4",
    "details": {
      "sha": "6e9c9e104e605a386a128ee1b4258469c7197f67",
      "filename": "test/com/google/inject/spi/InjectionPointTest.java",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/google/guice/blob/c1c95304b30913d7aeecc549acb677c5925fc8a4/test%2Fcom%2Fgoogle%2Finject%2Fspi%2FInjectionPointTest.java",
      "raw_url": "https://github.com/google/guice/raw/c1c95304b30913d7aeecc549acb677c5925fc8a4/test%2Fcom%2Fgoogle%2Finject%2Fspi%2FInjectionPointTest.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/test%2Fcom%2Fgoogle%2Finject%2Fspi%2FInjectionPointTest.java?ref=c1c95304b30913d7aeecc549acb677c5925fc8a4",
      "patch": "@@ -17,7 +17,7 @@\n package com.google.inject.spi;\n \n import static com.google.inject.Asserts.assertEqualsBothWays;\n-import static com.google.inject.Asserts.assertSimilarWhenReserialized;\n+import static com.google.inject.Asserts.assertNotSerializable;\n import com.google.inject.Inject;\n import com.google.inject.Key;\n import com.google.inject.TypeLiteral;\n@@ -56,7 +56,7 @@ public void testFieldInjectionPoint() throws NoSuchFieldException, IOException,\n     assertFalse(injectionPoint.isOptional());\n     assertEquals(getClass().getName() + \".foo\", injectionPoint.toString());\n     assertEqualsBothWays(injectionPoint, new InjectionPoint(typeLiteral, fooField));\n-    assertSimilarWhenReserialized(injectionPoint);\n+    assertNotSerializable(injectionPoint);\n \n     Dependency<?> dependency = getOnlyElement(injectionPoint.getDependencies());\n     assertEquals(\"Key[type=java.lang.String, annotation=@com.google.inject.name.Named(value=a)]@\"\n@@ -65,7 +65,7 @@ public void testFieldInjectionPoint() throws NoSuchFieldException, IOException,\n     assertEquals(-1, dependency.getParameterIndex());\n     Assert.assertEquals(Key.get(String.class, named(\"a\")), dependency.getKey());\n     assertEquals(false, dependency.isNullable());\n-    assertSimilarWhenReserialized(dependency);\n+    assertNotSerializable(dependency);\n     assertEqualsBothWays(dependency,\n         getOnlyElement(new InjectionPoint(typeLiteral, fooField).getDependencies()));\n   }\n@@ -79,7 +79,7 @@ public void testMethodInjectionPoint() throws Exception {\n     assertFalse(injectionPoint.isOptional());\n     assertEquals(getClass().getName() + \".bar()\", injectionPoint.toString());\n     assertEqualsBothWays(injectionPoint, new InjectionPoint(typeLiteral, barMethod));\n-    assertSimilarWhenReserialized(injectionPoint);\n+    assertNotSerializable(injectionPoint);\n \n     Dependency<?> dependency = getOnlyElement(injectionPoint.getDependencies());\n     assertEquals(\"Key[type=java.lang.String, annotation=@com.google.inject.name.Named(value=b)]@\"\n@@ -88,7 +88,7 @@ public void testMethodInjectionPoint() throws Exception {\n     assertEquals(0, dependency.getParameterIndex());\n     assertEquals(Key.get(String.class, named(\"b\")), dependency.getKey());\n     assertEquals(false, dependency.isNullable());\n-    assertSimilarWhenReserialized(dependency);\n+    assertNotSerializable(dependency);\n     assertEqualsBothWays(dependency,\n         getOnlyElement(new InjectionPoint(typeLiteral, barMethod).getDependencies()));\n   }\n@@ -103,7 +103,7 @@ public void testConstructorInjectionPoint() throws NoSuchMethodException, IOExce\n     assertFalse(injectionPoint.isOptional());\n     assertEquals(Constructable.class.getName() + \".<init>()\", injectionPoint.toString());\n     assertEqualsBothWays(injectionPoint, new InjectionPoint(typeLiteral, constructor));\n-    assertSimilarWhenReserialized(injectionPoint);\n+    assertNotSerializable(injectionPoint);\n \n     Dependency<?> dependency = getOnlyElement(injectionPoint.getDependencies());\n     assertEquals(\"Key[type=java.lang.String, annotation=@com.google.inject.name.Named(value=c)]@\"\n@@ -112,7 +112,7 @@ public void testConstructorInjectionPoint() throws NoSuchMethodException, IOExce\n     assertEquals(0, dependency.getParameterIndex());\n     assertEquals(Key.get(String.class, named(\"c\")), dependency.getKey());\n     assertEquals(false, dependency.isNullable());\n-    assertSimilarWhenReserialized(dependency);\n+    assertNotSerializable(dependency);\n     assertEqualsBothWays(dependency,\n         getOnlyElement(new InjectionPoint(typeLiteral, constructor).getDependencies()));\n   }\n@@ -125,7 +125,7 @@ public void testUnattachedDependency() throws IOException {\n     assertEquals(-1, dependency.getParameterIndex());\n     assertEquals(Key.get(String.class, named(\"d\")), dependency.getKey());\n     assertEquals(true, dependency.isNullable());\n-    assertSimilarWhenReserialized(dependency);\n+    assertNotSerializable(dependency);\n     assertEqualsBothWays(dependency, Dependency.get(Key.get(String.class, named(\"d\"))));\n   }\n   ",
      "parent_sha": "e05f254deb2c8d6d1a2ce1a8a63488ccab8dde1a"
    }
  },
  {
    "oid": "fddb6868070d832607d8cd3d461a18371f81f51e",
    "message": "Renamed put() to scope().\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@103 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2007-02-08T21:11:10Z",
    "url": "https://github.com/google/guice/commit/fddb6868070d832607d8cd3d461a18371f81f51e",
    "details": {
      "sha": "d9b612fed95c12aa5208992c28bbd5b94344a4bd",
      "filename": "src/com/google/inject/AbstractModule.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/fddb6868070d832607d8cd3d461a18371f81f51e/src%2Fcom%2Fgoogle%2Finject%2FAbstractModule.java",
      "raw_url": "https://github.com/google/guice/raw/fddb6868070d832607d8cd3d461a18371f81f51e/src%2Fcom%2Fgoogle%2Finject%2FAbstractModule.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/src%2Fcom%2Fgoogle%2Finject%2FAbstractModule.java?ref=fddb6868070d832607d8cd3d461a18371f81f51e",
      "patch": "@@ -73,7 +73,7 @@ protected ContainerBuilder builder() {\n   /**\n    * @see ContainerBuilder#scope(String, Scope)\n    */\n-  protected void put(String name, Scope scope) {\n+  protected void scope(String name, Scope scope) {\n     builder.scope(name, scope);\n   }\n ",
      "parent_sha": "11a889b3d9644c6d701df881784deb612c6b0a4e"
    }
  },
  {
    "oid": "a5c13e219224f7c2cbede4b1c787bbd95e62e276",
    "message": "simplify servlet SPI test.\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@1371 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2010-11-13T14:28:44Z",
    "url": "https://github.com/google/guice/commit/a5c13e219224f7c2cbede4b1c787bbd95e62e276",
    "details": {
      "sha": "0a2ec59b089123cb4e467df13dd1044cc9250e8e",
      "filename": "extensions/servlet/test/com/google/inject/servlet/ServletSpiVisitor.java",
      "status": "modified",
      "additions": 13,
      "deletions": 6,
      "changes": 19,
      "blob_url": "https://github.com/google/guice/blob/a5c13e219224f7c2cbede4b1c787bbd95e62e276/extensions%2Fservlet%2Ftest%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletSpiVisitor.java",
      "raw_url": "https://github.com/google/guice/raw/a5c13e219224f7c2cbede4b1c787bbd95e62e276/extensions%2Fservlet%2Ftest%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletSpiVisitor.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fservlet%2Ftest%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletSpiVisitor.java?ref=a5c13e219224f7c2cbede4b1c787bbd95e62e276",
      "patch": "@@ -72,22 +72,22 @@ class ServletSpiVisitor\n   }\r\n   \r\n   public Integer visit(InstanceFilterBinding binding) {\r\n-    actual.add(new Params(binding.getPattern(), binding.getFilterInstance(), binding.getInitParams(), binding.getUriPatternType()));\r\n+    actual.add(new Params(binding, binding.getFilterInstance()));\r\n     return currentCount++;\r\n   }\r\n   \r\n   public Integer visit(InstanceServletBinding binding) {\r\n-    actual.add(new Params(binding.getPattern(), binding.getServletInstance(), binding.getInitParams(), binding.getUriPatternType()));\r\n+    actual.add(new Params(binding, binding.getServletInstance()));\r\n     return currentCount++;\r\n   }\r\n   \r\n   public Integer visit(LinkedFilterBinding binding) {\r\n-    actual.add(new Params(binding.getPattern(), binding.getLinkedKey(), binding.getInitParams(), binding.getUriPatternType()));\r\n+    actual.add(new Params(binding, binding.getLinkedKey()));\r\n     return currentCount++;\r\n   }\r\n   \r\n   public Integer visit(LinkedServletBinding binding) {\r\n-    actual.add(new Params(binding.getPattern(), binding.getLinkedKey(), binding.getInitParams(), binding.getUriPatternType()));\r\n+    actual.add(new Params(binding, binding.getLinkedKey()));\r\n     return currentCount++;\r\n   }\r\n \r\n@@ -104,7 +104,14 @@ static class Params {\n     private final String pattern;\r\n     private final Object keyOrInstance;\r\n     private final Map<String, String> params;\r\n-    private UriPatternType patternType;\r\n+    private final UriPatternType patternType;\r\n+    \r\n+    Params(ServletModuleBinding binding, Object keyOrInstance) {\r\n+      this.pattern = binding.getPattern();\r\n+      this.keyOrInstance = keyOrInstance;\r\n+      this.params = binding.getInitParams();\r\n+      this.patternType = binding.getUriPatternType();\r\n+    }\r\n     \r\n     Params(String pattern, Object keyOrInstance, Map params, UriPatternType patternType) {\r\n       this.pattern = pattern;\r\n@@ -125,7 +132,7 @@ public boolean equals(Object obj) {\n         return false;\r\n       }\r\n     }\r\n-    \r\n+\r\n     @Override\r\n     public int hashCode() {\r\n       return Objects.hashCode(pattern, keyOrInstance, params, patternType);\r",
      "parent_sha": "71fe73ed4c6bcccbc6b71be1061435300b195c2f"
    }
  },
  {
    "oid": "159cd8647b9b9d662aaf8c1a21a8fe40a70e99b5",
    "message": "validate that issue 432 is not a problem anymore.\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@1499 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2011-02-20T00:50:36Z",
    "url": "https://github.com/google/guice/commit/159cd8647b9b9d662aaf8c1a21a8fe40a70e99b5",
    "details": {
      "sha": "e5262d1fd3f9a77f3f8449d8ef777b7e9ad7639c",
      "filename": "core/test/com/google/inject/TypeListenerTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/google/guice/blob/159cd8647b9b9d662aaf8c1a21a8fe40a70e99b5/core%2Ftest%2Fcom%2Fgoogle%2Finject%2FTypeListenerTest.java",
      "raw_url": "https://github.com/google/guice/raw/159cd8647b9b9d662aaf8c1a21a8fe40a70e99b5/core%2Ftest%2Fcom%2Fgoogle%2Finject%2FTypeListenerTest.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Ftest%2Fcom%2Fgoogle%2Finject%2FTypeListenerTest.java?ref=159cd8647b9b9d662aaf8c1a21a8fe40a70e99b5",
      "patch": "@@ -598,17 +598,20 @@ public <I> void hear(TypeLiteral<I> type, TypeEncounter<I> encounter) {\n               encounter.addError(\"There was an error on %s\", type);\n               encounter.addError(new IllegalArgumentException(\"whoops!\"));\n               encounter.addError(new Message(\"And another problem\"));\n+              encounter.addError(new IllegalStateException());\n             }\n           });\n         }\n       });\n       fail();\n     } catch (CreationException expected) {\n+      expected.printStackTrace();\n       assertContains(expected.getMessage(),\n           \"1) There was an error on com.google.inject.Stage\",\n           \"2) An exception was caught and reported. Message: whoops!\",\n           \"3) And another problem\",\n-          \"3 errors\");\n+          \"4) An exception was caught and reported. Message: null\",\n+          \"4 errors\");\n     }\n   }\n ",
      "parent_sha": "45ca7f66156b947c7b9c45a71ad48be9a0bcda08"
    }
  },
  {
    "oid": "f39b8fdfc5b8d2c1502ac4bfc9601b633284ee07",
    "message": "Review comments",
    "date": "2014-05-21T20:30:59Z",
    "url": "https://github.com/google/guice/commit/f39b8fdfc5b8d2c1502ac4bfc9601b633284ee07",
    "details": {
      "sha": "778c9ad0168cc35155004ac6da85aa060b6c64ea",
      "filename": "extensions/servlet/test/com/google/inject/servlet/ContinuingHttpServletRequestTest.java",
      "status": "modified",
      "additions": 12,
      "deletions": 5,
      "changes": 17,
      "blob_url": "https://github.com/google/guice/blob/f39b8fdfc5b8d2c1502ac4bfc9601b633284ee07/extensions%2Fservlet%2Ftest%2Fcom%2Fgoogle%2Finject%2Fservlet%2FContinuingHttpServletRequestTest.java",
      "raw_url": "https://github.com/google/guice/raw/f39b8fdfc5b8d2c1502ac4bfc9601b633284ee07/extensions%2Fservlet%2Ftest%2Fcom%2Fgoogle%2Finject%2Fservlet%2FContinuingHttpServletRequestTest.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fservlet%2Ftest%2Fcom%2Fgoogle%2Finject%2Fservlet%2FContinuingHttpServletRequestTest.java?ref=f39b8fdfc5b8d2c1502ac4bfc9601b633284ee07",
      "patch": "@@ -23,13 +23,15 @@\n \n import junit.framework.TestCase;\n \n-import java.util.Arrays;\n-\n import javax.servlet.http.Cookie;\n import javax.servlet.http.HttpServletRequest;\n \n public class ContinuingHttpServletRequestTest extends TestCase {\n \n+  private static final String TEST_VALUE_1 = \"testValue1\";\n+  private static final String TEST_VALUE_2 = \"testValue2\";\n+  private static final int DEFAULT_MAX_AGE = new Cookie(\"\", \"\").getMaxAge();\n+\n   public void testReturnNullCookiesIfDelegateHasNoNull() {\n     HttpServletRequest delegate = createMock(HttpServletRequest.class);\n     expect(delegate.getCookies()).andStubReturn(null);\n@@ -43,7 +45,7 @@ public void testReturnNullCookiesIfDelegateHasNoNull() {\n   \n   public void testReturnDelegateCookies() {\n     Cookie[] cookies = new Cookie[]{\n-        new Cookie(\"testName1\", \"testValue1\"),\n+        new Cookie(\"testName1\", TEST_VALUE_1),\n         new Cookie(\"testName2\", \"testValue2\")\n     };\n     HttpServletRequest delegate = createMock(HttpServletRequest.class);\n@@ -68,6 +70,11 @@ public void testReturnDelegateCookies() {\n       // Expected.\n     }\n \n+    // Verify that they remain equal to the original values.\n+    assertEquals(TEST_VALUE_1, continuingRequest.getCookies()[0].getValue());\n+    assertEquals(TEST_VALUE_2, continuingRequest.getCookies()[1].getValue());\n+    assertEquals(DEFAULT_MAX_AGE, continuingRequest.getCookies()[1].getMaxAge());\n+\n     // Perform a snapshot of the snapshot.\n     ContinuingHttpServletRequest furtherContinuingRequest = new ContinuingHttpServletRequest(\n         continuingRequest);\n@@ -82,11 +89,11 @@ private static void assertCookieArraysEqual(Cookie[] one, Cookie[] two) {\n     assertEquals(one.length, two.length);\n     for (int i = 0; i < one.length; i++) {\n       Cookie cookie = one[i];\n-      assertCookiequality(cookie, two[i]);\n+      assertCookieEquality(cookie, two[i]);\n     }\n   }\n \n-  private static void assertCookiequality(Cookie one, Cookie two) {\n+  private static void assertCookieEquality(Cookie one, Cookie two) {\n     assertEquals(one.getName(), two.getName());\n     assertEquals(one.getComment(), two.getComment());\n     assertEquals(one.getDomain(), two.getDomain());",
      "parent_sha": "3b02622e856e845f9bc5353a494b5ccc75dec40c"
    }
  },
  {
    "oid": "6552e594fd5aa2d541ab7b12972b9132c8b038c7",
    "message": "Stop shadowing <T> in ofType().\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=313271258",
    "date": "2020-05-27T18:26:03Z",
    "url": "https://github.com/google/guice/commit/6552e594fd5aa2d541ab7b12972b9132c8b038c7",
    "details": {
      "sha": "dd8cc22ad0790ebb611ea1127aab0521b4a8d6a9",
      "filename": "core/src/com/google/inject/Key.java",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/google/guice/blob/6552e594fd5aa2d541ab7b12972b9132c8b038c7/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2FKey.java",
      "raw_url": "https://github.com/google/guice/raw/6552e594fd5aa2d541ab7b12972b9132c8b038c7/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2FKey.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2FKey.java?ref=6552e594fd5aa2d541ab7b12972b9132c8b038c7",
      "patch": "@@ -234,17 +234,17 @@ public static <T> Key<T> get(Class<T> type, Annotation annotation) {\n \n   /** Gets a key for an injection type. */\n   public static Key<?> get(Type type) {\n-    return new Key<Object>(type, NullAnnotationStrategy.INSTANCE);\n+    return new Key<>(type, NullAnnotationStrategy.INSTANCE);\n   }\n \n   /** Gets a key for an injection type and an annotation type. */\n   public static Key<?> get(Type type, Class<? extends Annotation> annotationType) {\n-    return new Key<Object>(type, strategyFor(annotationType));\n+    return new Key<>(type, strategyFor(annotationType));\n   }\n \n   /** Gets a key for an injection type and an annotation. */\n   public static Key<?> get(Type type, Annotation annotation) {\n-    return new Key<Object>(type, strategyFor(annotation));\n+    return new Key<>(type, strategyFor(annotation));\n   }\n \n   /** Gets a key for an injection type. */\n@@ -268,8 +268,8 @@ public static <T> Key<T> get(TypeLiteral<T> typeLiteral, Annotation annotation)\n    *\n    * @since 3.0\n    */\n-  public <T> Key<T> ofType(Class<T> type) {\n-    return new Key<T>(type, annotationStrategy);\n+  public <U> Key<U> ofType(Class<U> type) {\n+    return new Key<>(type, annotationStrategy);\n   }\n \n   /**\n@@ -278,16 +278,16 @@ public <T> Key<T> ofType(Class<T> type) {\n    * @since 3.0\n    */\n   public Key<?> ofType(Type type) {\n-    return new Key<Object>(type, annotationStrategy);\n+    return new Key<>(type, annotationStrategy);\n   }\n \n   /**\n    * Returns a new key of the specified type with the same annotation as this key.\n    *\n    * @since 3.0\n    */\n-  public <T> Key<T> ofType(TypeLiteral<T> type) {\n-    return new Key<T>(type, annotationStrategy);\n+  public <U> Key<U> ofType(TypeLiteral<U> type) {\n+    return new Key<U>(type, annotationStrategy);\n   }\n \n   /**",
      "parent_sha": "d071802d48a50dffd89b0cfc61eff251251e637a"
    }
  },
  {
    "oid": "2d454682438a7ed743365daca07e93e7226d4a55",
    "message": "Fix Inject documentation, as method injection happens after field injection.\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=50901673",
    "date": "2013-09-18T22:26:38Z",
    "url": "https://github.com/google/guice/commit/2d454682438a7ed743365daca07e93e7226d4a55",
    "details": {
      "sha": "e3bbd2750e593add9c225c3840586ed175c30ece",
      "filename": "core/src/com/google/inject/Inject.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/2d454682438a7ed743365daca07e93e7226d4a55/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2FInject.java",
      "raw_url": "https://github.com/google/guice/raw/2d454682438a7ed743365daca07e93e7226d4a55/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2FInject.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2FInject.java?ref=2d454682438a7ed743365daca07e93e7226d4a55",
      "patch": "@@ -34,7 +34,7 @@\n  * <li>Every instance it constructs. The class being constructed must have\n  * exactly one of its constructors marked with {@code @Inject} or must have a\n  * constructor taking no parameters. The Injector then proceeds to perform\n- * method and field injections.\n+ * field and method injections.\n  * \n  * <li>Pre-constructed instances passed to {@link Injector#injectMembers},\n  * {@link com.google.inject.binder.LinkedBindingBuilder#toInstance(Object)} and",
      "parent_sha": "2bb4771a1835b8a145c857b63bb41ae56e5e6767"
    }
  },
  {
    "oid": "8ad64685f06ad4697d317f3c2eeb7e348cc3f23f",
    "message": "warn when a subclass overrides a method marked with @Inject but does not itself add @Inject (or invalidates the injectability), thus causing guice to stop injecting the method.\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@1160 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2010-05-12T17:10:39Z",
    "url": "https://github.com/google/guice/commit/8ad64685f06ad4697d317f3c2eeb7e348cc3f23f",
    "details": {
      "sha": "17d0a215fc28491a54c179c50db1f3949be3bc57",
      "filename": "src/com/google/inject/spi/InjectionPoint.java",
      "status": "modified",
      "additions": 25,
      "deletions": 4,
      "changes": 29,
      "blob_url": "https://github.com/google/guice/blob/8ad64685f06ad4697d317f3c2eeb7e348cc3f23f/src%2Fcom%2Fgoogle%2Finject%2Fspi%2FInjectionPoint.java",
      "raw_url": "https://github.com/google/guice/raw/8ad64685f06ad4697d317f3c2eeb7e348cc3f23f/src%2Fcom%2Fgoogle%2Finject%2Fspi%2FInjectionPoint.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/src%2Fcom%2Fgoogle%2Finject%2Fspi%2FInjectionPoint.java?ref=8ad64685f06ad4697d317f3c2eeb7e348cc3f23f",
      "patch": "@@ -19,7 +19,6 @@\n import com.google.inject.ConfigurationException;\n import com.google.inject.Inject;\n import com.google.inject.Key;\n-import com.google.inject.Stage;\n import com.google.inject.TypeLiteral;\n import com.google.inject.internal.Annotations;\n import com.google.inject.internal.Errors;\n@@ -45,6 +44,8 @@\n import java.util.Map;\n import java.util.Set;\n import java.util.HashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n \n /**\n  * A constructor, field or method that can receive injections. Typically this is a member with the\n@@ -55,6 +56,8 @@\n  * @since 2.0\n  */\n public final class InjectionPoint {\n+  \n+  private static final Logger logger = Logger.getLogger(InjectionPoint.class.getName());\n \n   private final boolean optional;\n   private final Member member;\n@@ -514,10 +517,10 @@ static class OverrideIndex {\n     /**\n      * Removes a method overridden by the given method, if present.\n      */\n-    void removeIfOverriddenBy(Method method) {\n+    boolean removeIfOverriddenBy(Method method) {\n       if (position == Position.TOP) {\n         // If we're at the top of the hierarchy, there's nothing to override.\n-        return;\n+        return false;\n       }\n \n       if (bySignature == null) {\n@@ -538,16 +541,19 @@ void removeIfOverriddenBy(Method method) {\n       lastMethod = method;\n       Signature signature = lastSignature = new Signature(method);\n       List<InjectableMethod> methods = bySignature.get(signature);\n+      boolean removed = false;\n       if (methods != null) {\n         for (Iterator<InjectableMethod> iterator = methods.iterator();\n             iterator.hasNext();) {\n           InjectableMethod possiblyOverridden = iterator.next();\n           if (overrides(method, possiblyOverridden.method)) {\n+            removed = true;\n             iterator.remove();\n             injectableMembers.remove(possiblyOverridden);\n           }\n         }\n       }\n+      return removed;\n     }\n \n     /**\n@@ -617,15 +623,23 @@ private static Set<InjectionPoint> getInjectionPoints(final TypeLiteral<?> type,\n \n       for (Method method : current.getRawType().getDeclaredMethods()) {\n         if (Modifier.isStatic(method.getModifiers()) == statics) {\n+          boolean removed = false;\n           if (overrideIndex != null) {\n-            overrideIndex.removeIfOverriddenBy(method);\n+            removed = overrideIndex.removeIfOverriddenBy(method);\n           }\n           Annotation atInject = getAtInject(method);\n           if (atInject != null) {\n             InjectableMethod injectableMethod = new InjectableMethod(\n                 current, method, atInject);\n             if (checkForMisplacedBindingAnnotations(method, errors)\n                 | !isValidMethod(injectableMethod, errors)) {\n+              if(removed) {\n+                logger.log(Level.WARNING, \"Method: {0} is not a valid injectable method (\"\n+                    + \"because it either has misplaced binding annotations \"\n+                    + \"or specifies type parameters) but is overriding a method that is valid. \"\n+                    + \"Because it is not valid, the method will not be injected. \"\n+                    + \"To fix this, make the method a valid injectable method.\", method);\n+              }\n               continue;\n             }\n             if (statics) {\n@@ -642,6 +656,13 @@ private static Set<InjectionPoint> getInjectionPoints(final TypeLiteral<?> type,\n               }\n               overrideIndex.add(injectableMethod);\n             }\n+          } else {\n+            if(removed) {\n+              logger.log(Level.WARNING, \"Method: {0} is not annotated with @Inject but \"\n+                  + \"is overriding a method that is annotated with @Inject.  Because \"\n+                  + \"it is not annotated with @Inject, the method will not be injected. \"\n+                  + \"To fix this, annotate the method with @Inject.\", method);\n+            }\n           }\n         }\n       }",
      "parent_sha": "af9a4df94a042856eacd99e9ce4dcdf4cd6eb5dd"
    }
  },
  {
    "oid": "5fd16c90c1226df1a56c79d3a6f7c3ac58dc9c0d",
    "message": "Only display learn more link for documented error id.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=326734989",
    "date": "2020-08-17T15:30:36Z",
    "url": "https://github.com/google/guice/commit/5fd16c90c1226df1a56c79d3a6f7c3ac58dc9c0d",
    "details": {
      "sha": "4d66c16d42b32cfc35e17e47305b6ee9b926bb9e",
      "filename": "core/src/com/google/inject/internal/InternalErrorDetail.java",
      "status": "modified",
      "additions": 26,
      "deletions": 1,
      "changes": 27,
      "blob_url": "https://github.com/google/guice/blob/5fd16c90c1226df1a56c79d3a6f7c3ac58dc9c0d/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInternalErrorDetail.java",
      "raw_url": "https://github.com/google/guice/raw/5fd16c90c1226df1a56c79d3a6f7c3ac58dc9c0d/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInternalErrorDetail.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInternalErrorDetail.java?ref=5fd16c90c1226df1a56c79d3a6f7c3ac58dc9c0d",
      "patch": "@@ -1,6 +1,7 @@\n package com.google.inject.internal;\n \n import com.google.common.base.CaseFormat;\n+import com.google.common.collect.ImmutableSet;\n import com.google.inject.spi.ErrorDetail;\n import java.util.List;\n import java.util.Optional;\n@@ -10,6 +11,27 @@\n  * application code.\n  */\n abstract class InternalErrorDetail<T extends ErrorDetail<T>> extends ErrorDetail<T> {\n+  // A list of errors that have help documentation.\n+  private static final ImmutableSet<ErrorId> DOCUMENTED_ERRORS =\n+      ImmutableSet.<ErrorId>builder()\n+          .add(ErrorId.BINDING_ALREADY_SET)\n+          .add(ErrorId.CAN_NOT_PROXY_CLASS)\n+          .add(ErrorId.CIRCULAR_PROXY_DISABLED)\n+          .add(ErrorId.DUPLICATE_BINDING_ANNOTATIONS)\n+          .add(ErrorId.DUPLICATE_ELEMENT)\n+          .add(ErrorId.DUPLICATE_SCOPES)\n+          .add(ErrorId.ERROR_INJECTING_CONSTRUCTOR)\n+          .add(ErrorId.ERROR_INJECTING_METHOD)\n+          .add(ErrorId.ERROR_IN_CUSTOM_PROVIDER)\n+          .add(ErrorId.INJECT_INNER_CLASS)\n+          .add(ErrorId.MISSING_CONSTRUCTOR)\n+          .add(ErrorId.MISSING_IMPLEMENTATION)\n+          .add(ErrorId.NULL_INJECTED_INTO_NON_NULLABLE)\n+          .add(ErrorId.NULL_VALUE_IN_MAP)\n+          .add(ErrorId.SCOPE_NOT_FOUND)\n+          .add(ErrorId.TOO_MANY_CONSTRUCTORS)\n+          .build();\n+\n   private static final String DOC_BASE_URL = \"https://github.com/googel/guice/wiki\";\n \n   protected final ErrorId errorId;\n@@ -27,6 +49,9 @@ protected InternalErrorDetail(\n \n   @Override\n   protected final Optional<String> getLearnMoreLink() {\n-    return Optional.of(String.format(\"%s/%s\", DOC_BASE_URL, errorId.name()));\n+    if (DOCUMENTED_ERRORS.contains(errorId)) {\n+      return Optional.of(String.format(\"%s/%s\", DOC_BASE_URL, errorId.name()));\n+    }\n+    return Optional.empty();\n   }\n }",
      "parent_sha": "67a5327dc0c74da36711df64a42f1c0652bb1d7a"
    }
  },
  {
    "oid": "79dc99b410c726328662205365c5f70c0088bfab",
    "message": "Implementing dtm's clever suggestions for optimizing getJustInTimeBinding for child injectors. \n\nThe new code first attempts to find an existing binding at any level first, then it tries to create the injector, parent-first.\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@729 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2008-12-09T19:02:12Z",
    "url": "https://github.com/google/guice/commit/79dc99b410c726328662205365c5f70c0088bfab",
    "details": {
      "sha": "0ef6f24de3213bda3668eeafa42d8dbb730d684d",
      "filename": "src/com/google/inject/InjectorImpl.java",
      "status": "modified",
      "additions": 36,
      "deletions": 26,
      "changes": 62,
      "blob_url": "https://github.com/google/guice/blob/79dc99b410c726328662205365c5f70c0088bfab/src%2Fcom%2Fgoogle%2Finject%2FInjectorImpl.java",
      "raw_url": "https://github.com/google/guice/raw/79dc99b410c726328662205365c5f70c0088bfab/src%2Fcom%2Fgoogle%2Finject%2FInjectorImpl.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/src%2Fcom%2Fgoogle%2Finject%2FInjectorImpl.java?ref=79dc99b410c726328662205365c5f70c0088bfab",
      "patch": "@@ -64,6 +64,9 @@ class InjectorImpl implements Injector {\n   final Initializer initializer;\n   ConstructionProxyFactory constructionProxyFactory;\n \n+  /** Just-in-time binding cache. Guarded by state.lock() */\n+  final Map<Key<?>, BindingImpl<?>> jitBindings = Maps.newHashMap();\n+\n   InjectorImpl(@Nullable InjectorImpl parent, State state, Initializer initializer) {\n     this.parent = parent;\n     this.state = state;\n@@ -147,42 +150,25 @@ public Injector createChildInjector(Module... modules) {\n   /**\n    * Returns a just-in-time binding for {@code key}, creating it if necessary.\n    *\n-   * @throws com.google.inject.internal.ErrorsException if the binding could not be created.\n+   * @throws ErrorsException if the binding could not be created.\n    */\n-  @SuppressWarnings(\"unchecked\")\n   private <T> BindingImpl<T> getJustInTimeBinding(Key<T> key, Errors errors)\n       throws ErrorsException {\n-\n-    // TODO: synch should span parent and child\n-\n     synchronized (state.lock()) {\n-      // try to get the JIT binding from the parent injector\n-      if (parent != null) {\n-        try {\n-          return parent.getJustInTimeBinding(key, new Errors());\n-        } catch (ErrorsException ignored) {\n-        }\n-      }\n+      // first try to find a JIT binding that we've already created\n+      for (InjectorImpl injector = this; injector != null; injector = injector.parent) {\n+        @SuppressWarnings(\"unchecked\") // we only store bindings that match their key\n+        BindingImpl<T> binding = (BindingImpl<T>) injector.jitBindings.get(key);\n \n-      // Support null values.\n-      if (jitBindings.containsKey(key)) {\n-        return (BindingImpl<T>) jitBindings.get(key);\n-      }\n-\n-      if (state.isBlacklisted(key)) {\n-        throw errors.childBindingAlreadySet(key).toException();\n+        if (binding != null) {\n+          return binding;\n+        }\n       }\n \n-      BindingImpl<T> binding = createJustInTimeBinding(key, errors);\n-      state.parent().blacklist(key);\n-      jitBindings.put(key, binding);\n-      return binding;\n+      return createJustInTimeBindingRecursive(key, errors);\n     }\n   }\n \n-  /** Just-in-time binding cache. */\n-  final Map<Key<?>, BindingImpl<?>> jitBindings = Maps.newHashMap();\n-\n   /* Returns true if the key type is Provider<?> (but not a subclass of Provider<?>). */\n   static boolean isProvider(Key<?> key) {\n     return key.getTypeLiteral().getRawType().equals(Provider.class);\n@@ -551,6 +537,30 @@ public T get(Errors errors, InternalContext context, Dependency<?> dependency)\n         loadStrategy);\n   }\n \n+  /**\n+   * Attempts to create a just-in-time binding for {@code key} in the root injector, falling back to\n+   * other ancestor injectors until this injector is tried.\n+   */\n+  private <T> BindingImpl<T> createJustInTimeBindingRecursive(Key<T> key, Errors errors)\n+      throws ErrorsException {\n+    // ask the parent to create the JIT binding\n+    if (parent != null) {\n+      try {\n+        return parent.createJustInTimeBindingRecursive(key, new Errors());\n+      } catch (ErrorsException ignored) {\n+      }\n+    }\n+\n+    if (state.isBlacklisted(key)) {\n+      throw errors.childBindingAlreadySet(key).toException();\n+    }\n+\n+    BindingImpl<T> binding = createJustInTimeBinding(key, errors);\n+    state.parent().blacklist(key);\n+    jitBindings.put(key, binding);\n+    return binding;\n+  }\n+\n   /**\n    * Returns a new just-in-time binding created by resolving {@code key}. The strategies used to\n    * create just-in-time bindings are:",
      "parent_sha": "f9e26582d812805fdb56e775e11b6fd1dec8dc2c"
    }
  },
  {
    "oid": "e6ec2a4a9433d64e763093a826eecf49f005aa5d",
    "message": "Rework the way we bind the Set<? extends T> multibound object so that we can avoid the linked binding. This removes one unnecessary dependency from the graph, making graph visualizations more straight forward.\n\nPiperOrigin-RevId: 366250039",
    "date": "2021-04-01T14:51:04Z",
    "url": "https://github.com/google/guice/commit/e6ec2a4a9433d64e763093a826eecf49f005aa5d",
    "details": {
      "sha": "9ca8007b98eb37b37699a8b65326bd8e23098a5d",
      "filename": "core/src/com/google/inject/internal/RealMultibinder.java",
      "status": "modified",
      "additions": 127,
      "deletions": 82,
      "changes": 209,
      "blob_url": "https://github.com/google/guice/blob/e6ec2a4a9433d64e763093a826eecf49f005aa5d/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FRealMultibinder.java",
      "raw_url": "https://github.com/google/guice/raw/e6ec2a4a9433d64e763093a826eecf49f005aa5d/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FRealMultibinder.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FRealMultibinder.java?ref=e6ec2a4a9433d64e763093a826eecf49f005aa5d",
      "patch": "@@ -31,6 +31,7 @@\n import java.util.Collection;\n import java.util.List;\n import java.util.Set;\n+import java.util.function.Function;\n \n /**\n  * The actual multibinder plays several roles:\n@@ -99,15 +100,22 @@ static <T> TypeLiteral<Set<? extends T>> setOfExtendsOf(TypeLiteral<T> elementTy\n   @Override\n   public void configure(Binder binder) {\n     checkConfiguration(!bindingSelection.isInitialized(), \"Multibinder was already initialized\");\n+\n+    RealMultibinderProvider<T> setProvider = new RealMultibinderProvider<T>(bindingSelection);\n+    // Bind the setKey to the provider wrapped w/ extension support.\n     binder\n         .bind(bindingSelection.getSetKey())\n-        .toProvider(new RealMultibinderProvider<T>(bindingSelection));\n+        .toProvider(new ExtensionRealMultibinderProvider<>(setProvider));\n+    // Bind the <? extends T> to the provider w/o extension support.\n+    // It's important the exactly one binding implement the extension support and show\n+    // the other keys as aliases, to adhere to the extension contract.\n+    binder.bind(bindingSelection.getSetOfExtendsKey()).toProvider(setProvider);\n+\n     Provider<Collection<Provider<T>>> collectionOfProvidersProvider =\n         new RealMultibinderCollectionOfProvidersProvider<T>(bindingSelection);\n     binder\n         .bind(bindingSelection.getCollectionOfProvidersKey())\n         .toProvider(collectionOfProvidersProvider);\n-    binder.bind(bindingSelection.getSetOfExtendsKey()).to(bindingSelection.getSetKey());\n \n     // The collection this exposes is internally an ImmutableList, so it's OK to massage\n     // the guice Provider to javax Provider in the value (since the guice Provider implements\n@@ -156,39 +164,78 @@ boolean containsElement(com.google.inject.spi.Element element) {\n     return bindingSelection.containsElement(element);\n   }\n \n-  private static final class RealMultibinderProvider<T>\n-      extends InternalProviderInstanceBindingImpl.Factory<Set<T>>\n-      implements ProviderWithExtensionVisitor<Set<T>>, MultibinderBinding<Set<T>> {\n-    private final BindingSelection<T> bindingSelection;\n-    private List<Binding<T>> bindings;\n-    private SingleParameterInjector<T>[] injectors;\n-    private boolean permitDuplicates;\n-\n-    RealMultibinderProvider(BindingSelection<T> bindingSelection) {\n+  /**\n+   * Base implement of {@link InternalProviderInstanceBindingImpl.Factory} that works based on a\n+   * {@link BindingSelection}, allowing provider instances for various bindings to be implemented\n+   * with less duplication.\n+   */\n+  private abstract static class BaseFactory<ValueT, ProvidedT>\n+      extends InternalProviderInstanceBindingImpl.Factory<ProvidedT> {\n+    final Function<BindingSelection<ValueT>, ImmutableSet<Dependency<?>>> dependenciesFn;\n+    final BindingSelection<ValueT> bindingSelection;\n+\n+    BaseFactory(\n+        BindingSelection<ValueT> bindingSelection,\n+        Function<BindingSelection<ValueT>, ImmutableSet<Dependency<?>>> dependenciesFn) {\n       // While Multibinders only depend on bindings created in modules so we could theoretically\n       // initialize eagerly, they also depend on\n       // 1. findBindingsByType returning results\n       // 2. being able to call BindingImpl.acceptTargetVisitor\n       // neither of those is available during eager initialization, so we use DELAYED\n       super(InitializationTiming.DELAYED);\n       this.bindingSelection = bindingSelection;\n+      this.dependenciesFn = dependenciesFn;\n     }\n \n+    @Override\n+    void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {\n+      bindingSelection.initialize(injector, errors);\n+      doInitialize();\n+    }\n+\n+    abstract void doInitialize();\n+\n     @Override\n     public Set<Dependency<?>> getDependencies() {\n-      return bindingSelection.getDependencies();\n+      return dependenciesFn.apply(bindingSelection);\n     }\n \n     @Override\n-    void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {\n-      bindingSelection.initialize(injector, errors);\n-      this.bindings = bindingSelection.getBindings();\n-      this.injectors = bindingSelection.getParameterInjectors();\n-      this.permitDuplicates = bindingSelection.permitsDuplicates();\n+    public boolean equals(Object obj) {\n+      return getClass().isInstance(obj)\n+          && bindingSelection.equals(((BaseFactory<?, ?>) obj).bindingSelection);\n     }\n \n     @Override\n-    protected Set<T> doProvision(InternalContext context, Dependency<?> dependency)\n+    public int hashCode() {\n+      return bindingSelection.hashCode();\n+    }\n+  }\n+\n+  /**\n+   * Provider instance implementation that provides the actual set of values. This is parameterized\n+   * so it can be used to supply a Set<T> and Set<? extends T>, the latter being useful for Kotlin\n+   * support.\n+   */\n+  private static final class RealMultibinderProvider<T> extends BaseFactory<T, Set<T>> {\n+    List<Binding<T>> bindings;\n+    SingleParameterInjector<T>[] injectors;\n+    boolean permitDuplicates;\n+\n+    RealMultibinderProvider(BindingSelection<T> bindingSelection) {\n+      // Note: method reference doesn't work for the 2nd arg for some reason when compiling on java8\n+      super(bindingSelection, bs -> bs.getDependencies());\n+    }\n+\n+    @Override\n+    protected void doInitialize() {\n+      bindings = bindingSelection.getBindings();\n+      injectors = bindingSelection.getParameterInjectors();\n+      permitDuplicates = bindingSelection.permitsDuplicates();\n+    }\n+\n+    @Override\n+    protected ImmutableSet<T> doProvision(InternalContext context, Dependency<?> dependency)\n         throws InternalProvisionException {\n       SingleParameterInjector<T>[] localInjectors = injectors;\n       if (localInjectors == null) {\n@@ -224,36 +271,51 @@ private InternalProvisionException newNullEntryException(int i) {\n           bindings.get(i).getSource());\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <B, V> V acceptExtensionVisitor(\n-        BindingTargetVisitor<B, V> visitor, ProviderInstanceBinding<? extends B> binding) {\n-      if (visitor instanceof MultibindingsTargetVisitor) {\n-        return ((MultibindingsTargetVisitor<Set<T>, V>) visitor).visit(this);\n-      } else {\n-        return visitor.visit(binding);\n-      }\n-    }\n-\n     private InternalProvisionException newDuplicateValuesException(T[] values) {\n       Message message =\n           new Message(\n               GuiceInternal.GUICE_INTERNAL,\n               ErrorId.DUPLICATE_ELEMENT,\n               new DuplicateElementError<T>(\n-                  getSetKey(), bindings, values, ImmutableList.of(getSource())));\n-        return new InternalProvisionException(message);\n+                  bindingSelection.getSetKey(), bindings, values, ImmutableList.of(getSource())));\n+      return new InternalProvisionException(message);\n+    }\n+  }\n+\n+  /**\n+   * Implementation of BaseFactory that exposes details about the multibinder through the extension\n+   * SPI.\n+   */\n+  private static final class ExtensionRealMultibinderProvider<T> extends BaseFactory<T, Set<T>>\n+      implements ProviderWithExtensionVisitor<Set<T>>, MultibinderBinding<Set<T>> {\n+    final RealMultibinderProvider<T> delegate;\n+\n+    ExtensionRealMultibinderProvider(RealMultibinderProvider<T> delegate) {\n+      // Note: method reference doesn't work for the 2nd arg for some reason when compiling on java8\n+      super(delegate.bindingSelection, bs -> bs.getDependencies());\n+      this.delegate = delegate;\n     }\n \n     @Override\n-    public boolean equals(Object obj) {\n-      return obj instanceof RealMultibinderProvider\n-          && bindingSelection.equals(((RealMultibinderProvider<?>) obj).bindingSelection);\n+    protected void doInitialize() {\n+      delegate.doInitialize();\n     }\n \n     @Override\n-    public int hashCode() {\n-      return bindingSelection.hashCode();\n+    protected ImmutableSet<T> doProvision(InternalContext context, Dependency<?> dependency)\n+        throws InternalProvisionException {\n+      return delegate.doProvision(context, dependency);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <B, V> V acceptExtensionVisitor(\n+        BindingTargetVisitor<B, V> visitor, ProviderInstanceBinding<? extends B> binding) {\n+      if (visitor instanceof MultibindingsTargetVisitor) {\n+        return ((MultibindingsTargetVisitor<Set<T>, V>) visitor).visit(this);\n+      } else {\n+        return visitor.visit(binding);\n+      }\n     }\n \n     @Override\n@@ -262,7 +324,7 @@ public Key<Set<T>> getSetKey() {\n     }\n \n     @Override\n-    public Set<Key<?>> getAlternateSetKeys() {\n+    public ImmutableSet<Key<?>> getAlternateSetKeys() {\n       return ImmutableSet.of(\n           (Key<?>) bindingSelection.getCollectionOfProvidersKey(),\n           (Key<?>) bindingSelection.getCollectionOfJavaxProvidersKey(),\n@@ -290,6 +352,34 @@ public boolean containsElement(com.google.inject.spi.Element element) {\n     }\n   }\n \n+  /**\n+   * Implementation of BaseFactory that exposes a collection of providers of the values in the set.\n+   */\n+  private static final class RealMultibinderCollectionOfProvidersProvider<T>\n+      extends BaseFactory<T, Collection<Provider<T>>> {\n+    ImmutableList<Provider<T>> providers;\n+\n+    RealMultibinderCollectionOfProvidersProvider(BindingSelection<T> bindingSelection) {\n+      // Note: method reference doesn't work for the 2nd arg for some reason when compiling on java8\n+      super(bindingSelection, bs -> bs.getProviderDependencies());\n+    }\n+\n+    @Override\n+    protected void doInitialize() {\n+      ImmutableList.Builder<Provider<T>> providers = ImmutableList.builder();\n+      for (Binding<T> binding : bindingSelection.getBindings()) {\n+        providers.add(binding.getProvider());\n+      }\n+      this.providers = providers.build();\n+    }\n+\n+    @Override\n+    protected ImmutableList<Provider<T>> doProvision(\n+        InternalContext context, Dependency<?> dependency) {\n+      return providers;\n+    }\n+  }\n+\n   private static final class BindingSelection<T> {\n     // prior to initialization we declare just a dependency on the injector, but as soon as we are\n     // initialized we swap to dependencies on the elements.\n@@ -522,51 +612,6 @@ public int hashCode() {\n     return bindingSelection.hashCode();\n   }\n \n-  private static final class RealMultibinderCollectionOfProvidersProvider<T>\n-      extends InternalProviderInstanceBindingImpl.Factory<Collection<Provider<T>>> {\n-\n-    private final BindingSelection<T> bindingSelection;\n-    private ImmutableList<Provider<T>> collectionOfProviders;\n-\n-    RealMultibinderCollectionOfProvidersProvider(BindingSelection<T> bindingSelection) {\n-      super(InitializationTiming.DELAYED); // See comment in RealMultibinderProvider\n-      this.bindingSelection = bindingSelection;\n-    }\n-\n-    @Override\n-    void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {\n-      bindingSelection.initialize(injector, errors);\n-      ImmutableList.Builder<Provider<T>> providers = ImmutableList.builder();\n-      for (Binding<T> binding : bindingSelection.getBindings()) {\n-        providers.add(binding.getProvider());\n-      }\n-      this.collectionOfProviders = providers.build();\n-    }\n-\n-    @Override\n-    protected Collection<Provider<T>> doProvision(\n-        InternalContext context, Dependency<?> dependency) {\n-      return collectionOfProviders;\n-    }\n-\n-    @Override\n-    public Set<Dependency<?>> getDependencies() {\n-      return bindingSelection.getProviderDependencies();\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-      return obj instanceof RealMultibinderCollectionOfProvidersProvider\n-          && bindingSelection.equals(\n-              ((RealMultibinderCollectionOfProvidersProvider<?>) obj).bindingSelection);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      return bindingSelection.hashCode();\n-    }\n-  }\n-\n   /**\n    * We install the permit duplicates configuration as its own binding, all by itself. This way, if\n    * only one of a multibinder's users remember to call permitDuplicates(), they're still permitted.",
      "parent_sha": "dc7f4858f9cbb1babe50e962ed5e145536844ad8"
    }
  },
  {
    "oid": "ca16de968d423a2a12f18304db22e078cefac622",
    "message": "Removes unnecessary and invalid align=\"left\" attributes from grapher's\nGraphvizRenderer generator. Fixes bug 331.\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@847 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2009-02-15T03:40:39Z",
    "url": "https://github.com/google/guice/commit/ca16de968d423a2a12f18304db22e078cefac622",
    "details": {
      "sha": "e360f457b5048d55c36098bebf597b42b1a30409",
      "filename": "extensions/grapher/src/com/google/inject/grapher/graphviz/GraphvizRenderer.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/ca16de968d423a2a12f18304db22e078cefac622/extensions%2Fgrapher%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fgrapher%2Fgraphviz%2FGraphvizRenderer.java",
      "raw_url": "https://github.com/google/guice/raw/ca16de968d423a2a12f18304db22e078cefac622/extensions%2Fgrapher%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fgrapher%2Fgraphviz%2FGraphvizRenderer.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fgrapher%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fgrapher%2Fgraphviz%2FGraphvizRenderer.java?ref=ca16de968d423a2a12f18304db22e078cefac622",
      "patch": "@@ -143,7 +143,7 @@ protected String getNodeLabel(GraphvizNode node) {\n     \n     String subtitle = Join.join(\"<br align=\\\"left\\\"/>\", node.getSubtitles());\n     if (subtitle.length() != 0) {\n-      html.append(\"<font align=\\\"left\\\" color=\\\"\").append(node.getHeaderTextColor());\n+      html.append(\"<font color=\\\"\").append(node.getHeaderTextColor());\n       html.append(\"\\\" point-size=\\\"10\\\">\");\n       html.append(subtitle).append(\"<br align=\\\"left\\\"/>\").append(\"</font>\");\n     }",
      "parent_sha": "387abc0bdcacfa59436f0c0829d882ecefaea370"
    }
  },
  {
    "oid": "883fe035ae3be076486f2d16b8b8216266f1ad6c",
    "message": "Make ServletScopes#scopeRequest slightly more efficient for larger seed maps.\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=61542674",
    "date": "2014-03-10T17:49:25Z",
    "url": "https://github.com/google/guice/commit/883fe035ae3be076486f2d16b8b8216266f1ad6c",
    "details": {
      "sha": "cd593bf788867fcd47965f07bb447c99c5213534",
      "filename": "extensions/servlet/src/com/google/inject/servlet/ServletScopes.java",
      "status": "modified",
      "additions": 8,
      "deletions": 4,
      "changes": 12,
      "blob_url": "https://github.com/google/guice/blob/883fe035ae3be076486f2d16b8b8216266f1ad6c/extensions%2Fservlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletScopes.java",
      "raw_url": "https://github.com/google/guice/raw/883fe035ae3be076486f2d16b8b8216266f1ad6c/extensions%2Fservlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletScopes.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fservlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletScopes.java?ref=883fe035ae3be076486f2d16b8b8216266f1ad6c",
      "patch": "@@ -19,6 +19,7 @@\n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Maps.EntryTransformer;\n import com.google.inject.Binding;\n import com.google.inject.Injector;\n import com.google.inject.Key;\n@@ -326,10 +327,13 @@ public static <T> Callable<T> scopeRequest(final Callable<T> callable,\n \n     // Copy the seed values into our local scope map.\n     final Context context = new Context();\n-    for (Map.Entry<Key<?>, Object> entry : seedMap.entrySet()) {\n-      Object value = validateAndCanonicalizeValue(entry.getKey(), entry.getValue());\n-      context.map.put(entry.getKey(), value);\n-    }\n+    Map<Key<?>, Object> validatedAndCanonicalizedMap =\n+        Maps.transformEntries(seedMap, new EntryTransformer<Key<?>, Object, Object>() {\n+          @Override public Object transformEntry(Key<?> key, Object value) {\n+            return validateAndCanonicalizeValue(key, value);\n+          }\n+        });\n+    context.map.putAll(validatedAndCanonicalizedMap);\n \n     return new Callable<T>() {\n       public T call() throws Exception {",
      "parent_sha": "41c1c297756b6e2b5f6ab32924daa232c2dee6d4"
    }
  },
  {
    "oid": "2c23a622f259469f10f6c4c44a88b7a1259b8d3d",
    "message": "AssertionError(string, throwable) was added in java7 :-/\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=131618952",
    "date": "2016-08-29T20:42:31Z",
    "url": "https://github.com/google/guice/commit/2c23a622f259469f10f6c4c44a88b7a1259b8d3d",
    "details": {
      "sha": "e4a1acb5d08af122887c2b30ab748f00ed0179e5",
      "filename": "extensions/testlib/src/com/google/inject/testing/throwingproviders/CheckedProviderSubject.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/2c23a622f259469f10f6c4c44a88b7a1259b8d3d/extensions%2Ftestlib%2Fsrc%2Fcom%2Fgoogle%2Finject%2Ftesting%2Fthrowingproviders%2FCheckedProviderSubject.java",
      "raw_url": "https://github.com/google/guice/raw/2c23a622f259469f10f6c4c44a88b7a1259b8d3d/extensions%2Ftestlib%2Fsrc%2Fcom%2Fgoogle%2Finject%2Ftesting%2Fthrowingproviders%2FCheckedProviderSubject.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Ftestlib%2Fsrc%2Fcom%2Fgoogle%2Finject%2Ftesting%2Fthrowingproviders%2FCheckedProviderSubject.java?ref=2c23a622f259469f10f6c4c44a88b7a1259b8d3d",
      "patch": "@@ -61,7 +61,7 @@ public Subject<?, Object> providedValue() {\n       got = provider.get();\n     } catch (Exception e) {\n       failureStrategy.fail(String.format(\"checked provider <%s> threw an exception\", provider), e);\n-      throw new AssertionError(\"Impossible, I hope...\", e);\n+      throw new AssertionError(e);\n     }\n     return assert_().withFailureMessage(\"value provided by <%s>\", provider).that(got);\n   }",
      "parent_sha": "7f315f97dd07211267af4cc8ba07abb96384bf2f"
    }
  },
  {
    "oid": "cadabc1aa1cbe30c48a7b730c2907c82abff6336",
    "message": "Switch InternalContext to store dependency/source pairs more compactly.\n\nFirst, use an ArrayList instead of LinkedList, since it has only 4-8\nbytes overhead per entry (depending on resize phase).  Second, remove\nthe overhead of the DependencyAndSource object, which saves 8 bytes per\nobject, and materialize only when getDependencyChain() is called.\n\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=47284141",
    "date": "2013-06-27T00:45:17Z",
    "url": "https://github.com/google/guice/commit/cadabc1aa1cbe30c48a7b730c2907c82abff6336",
    "details": {
      "sha": "71d953c51e5708d126ece4e9b083d27daf7824d3",
      "filename": "core/src/com/google/inject/internal/InternalContext.java",
      "status": "modified",
      "additions": 29,
      "deletions": 12,
      "changes": 41,
      "blob_url": "https://github.com/google/guice/blob/cadabc1aa1cbe30c48a7b730c2907c82abff6336/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInternalContext.java",
      "raw_url": "https://github.com/google/guice/raw/cadabc1aa1cbe30c48a7b730c2907c82abff6336/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInternalContext.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInternalContext.java?ref=cadabc1aa1cbe30c48a7b730c2907c82abff6336",
      "patch": "@@ -17,12 +17,13 @@\n package com.google.inject.internal;\n \n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.inject.Key;\n import com.google.inject.spi.Dependency;\n import com.google.inject.spi.DependencyAndSource;\n \n-import java.util.LinkedList;\n+import java.util.ArrayList;\n import java.util.List;\n import java.util.Map;\n \n@@ -35,10 +36,18 @@\n final class InternalContext {\n \n   private Map<Object, ConstructionContext<?>> constructionContexts = Maps.newHashMap();\n+\n   /** Keeps track of the type that is currently being requested for injection. */\n-  private Dependency dependency;\n-  /** Keeps track of the hierarchy of types needed during injection. */\n-  private LinkedList<DependencyAndSource> state = new LinkedList<DependencyAndSource>();\n+  private Dependency<?> dependency;\n+\n+  /**\n+   * Keeps track of the hierarchy of types needed during injection.\n+   *\n+   * <p>This is a pairwise combination of dependencies and sources, with dependencies on even\n+   * indices, and sources on odd indices. This structure is to avoid the memory overhead of\n+   * DependencyAndSource objects, which can add to several tens of megabytes in large applications.\n+   */\n+  private final List<Object> state = Lists.newArrayList();\n \n   @SuppressWarnings(\"unchecked\")\n   public <T> ConstructionContext<T> getConstructionContext(Object key) {\n@@ -51,36 +60,44 @@ public <T> ConstructionContext<T> getConstructionContext(Object key) {\n     return constructionContext;\n   }\n \n-  public Dependency getDependency() {\n+  public Dependency<?> getDependency() {\n     return dependency;\n   }\n \n   /** Sets the new current dependency & adds it to the state. */\n-  public Dependency pushDependency(Dependency dependency, Object source) {\n-    Dependency previous = this.dependency;\n+  public Dependency<?> pushDependency(Dependency<?> dependency, Object source) {\n+    Dependency<?> previous = this.dependency;\n     this.dependency = dependency;\n-    state.addLast(new DependencyAndSource(dependency, source));\n+    state.add(dependency);\n+    state.add(source);\n     return previous;\n   }\n   \n   /** Pops the current state & sets the new dependency. */\n-  public void popStateAndSetDependency(Dependency newDependency) {\n+  public void popStateAndSetDependency(Dependency<?> newDependency) {\n     popState();\n     this.dependency = newDependency;\n   }\n   \n   /** Adds to the state without setting the dependency. */\n   public void pushState(Key<?> key, Object source) {\n-    state.addLast(new DependencyAndSource(key == null ? null : Dependency.get(key), source));\n+    state.add(key == null ? null : Dependency.get(key));\n+    state.add(source);\n   }\n   \n   /** Pops from the state without setting a dependency. */\n   public void popState() {\n-    state.removeLast();\n+    state.remove(state.size() - 1);\n+    state.remove(state.size() - 1);\n   }\n   \n   /** Returns the current dependency chain (all the state). */\n   public List<DependencyAndSource> getDependencyChain() {\n-    return ImmutableList.copyOf(state);\n+    ImmutableList.Builder<DependencyAndSource> builder = ImmutableList.builder();\n+    for (int i = 0; i < state.size(); i += 2) {\n+      builder.add(new DependencyAndSource(\n+          (Dependency<?>) state.get(i), state.get(i + 1)));\n+    }\n+    return builder.build();\n   }\n }",
      "parent_sha": "d9e05457644c7600746f8614f1285d5f1aa49e17"
    }
  },
  {
    "oid": "36ff122d2582cf9831e755510f76a67f30832388",
    "message": "Rewrite jakarta singleton -> c.g.i Singleton for the SPI too.\n\nPiperOrigin-RevId: 528546653",
    "date": "2023-05-01T19:41:34Z",
    "url": "https://github.com/google/guice/commit/36ff122d2582cf9831e755510f76a67f30832388",
    "details": {
      "sha": "12ea703a647771ee7bf77d2a5a3c968da0a2a2c0",
      "filename": "core/src/com/google/inject/internal/Scoping.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/google/guice/blob/36ff122d2582cf9831e755510f76a67f30832388/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FScoping.java",
      "raw_url": "https://github.com/google/guice/raw/36ff122d2582cf9831e755510f76a67f30832388/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FScoping.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FScoping.java?ref=36ff122d2582cf9831e755510f76a67f30832388",
      "patch": "@@ -160,7 +160,9 @@ public void applyTo(ScopedBindingBuilder scopedBindingBuilder) {\n       };\n \n   public static Scoping forAnnotation(final Class<? extends Annotation> scopingAnnotation) {\n-    if (scopingAnnotation == Singleton.class || scopingAnnotation == javax.inject.Singleton.class) {\n+    if (scopingAnnotation == Singleton.class\n+        || scopingAnnotation == javax.inject.Singleton.class\n+        || scopingAnnotation == jakarta.inject.Singleton.class) {\n       return SINGLETON_ANNOTATION;\n     }\n ",
      "parent_sha": "99d0e1129426580ee1086bea3959c25119e64988"
    }
  },
  {
    "oid": "f6189601d44b1ff8143e26337d0704f35f8dc645",
    "message": "Simplifies MapBinder by moving Key generation to RealMapBinder's constructor.\n\nTested:\nAll existing tests pass.\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=79160583",
    "date": "2014-11-07T18:18:19Z",
    "url": "https://github.com/google/guice/commit/f6189601d44b1ff8143e26337d0704f35f8dc645",
    "details": {
      "sha": "f8fd4a3e641592a45003cff9eadd3b39c69dad11",
      "filename": "extensions/multibindings/src/com/google/inject/multibindings/MapBinder.java",
      "status": "modified",
      "additions": 9,
      "deletions": 24,
      "changes": 33,
      "blob_url": "https://github.com/google/guice/blob/f6189601d44b1ff8143e26337d0704f35f8dc645/extensions%2Fmultibindings%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fmultibindings%2FMapBinder.java",
      "raw_url": "https://github.com/google/guice/raw/f6189601d44b1ff8143e26337d0704f35f8dc645/extensions%2Fmultibindings%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fmultibindings%2FMapBinder.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fmultibindings%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fmultibindings%2FMapBinder.java?ref=f6189601d44b1ff8143e26337d0704f35f8dc645",
      "patch": "@@ -143,11 +143,7 @@ private MapBinder() {}\n   public static <K, V> MapBinder<K, V> newMapBinder(Binder binder,\n       TypeLiteral<K> keyType, TypeLiteral<V> valueType) {\n     binder = binder.skipSources(MapBinder.class, RealMapBinder.class);\n-    return newMapBinder(binder, keyType, valueType,\n-        Key.get(mapOf(keyType, valueType)),\n-        Key.get(mapOfProviderOf(keyType, valueType)),\n-        Key.get(mapOf(keyType, setOf(valueType))),\n-        Key.get(mapOfSetOfProviderOf(keyType, valueType)),\n+    return newMapBinder(binder, keyType, valueType, Key.get(mapOf(keyType, valueType)),\n         Multibinder.newSetBinder(binder, entryOfProviderOf(keyType, valueType)));\n   }\n \n@@ -169,9 +165,6 @@ public static <K, V> MapBinder<K, V> newMapBinder(Binder binder,\n     binder = binder.skipSources(MapBinder.class, RealMapBinder.class);\n     return newMapBinder(binder, keyType, valueType,\n         Key.get(mapOf(keyType, valueType), annotation),\n-        Key.get(mapOfProviderOf(keyType, valueType), annotation),\n-        Key.get(mapOf(keyType, setOf(valueType)), annotation),\n-        Key.get(mapOfSetOfProviderOf(keyType, valueType), annotation),\n         Multibinder.newSetBinder(binder, entryOfProviderOf(keyType, valueType), annotation));\n   }\n \n@@ -193,9 +186,6 @@ public static <K, V> MapBinder<K, V> newMapBinder(Binder binder, TypeLiteral<K>\n     binder = binder.skipSources(MapBinder.class, RealMapBinder.class);\n     return newMapBinder(binder, keyType, valueType,\n         Key.get(mapOf(keyType, valueType), annotationType),\n-        Key.get(mapOfProviderOf(keyType, valueType), annotationType),\n-        Key.get(mapOf(keyType, setOf(valueType)), annotationType),\n-        Key.get(mapOfSetOfProviderOf(keyType, valueType), annotationType),\n         Multibinder.newSetBinder(binder, entryOfProviderOf(keyType, valueType), annotationType));\n   }\n \n@@ -247,13 +237,10 @@ static <K, V> TypeLiteral<Map.Entry<K, Provider<V>>> entryOfProviderOf(\n   }\n \n   private static <K, V> MapBinder<K, V> newMapBinder(Binder binder,\n-      TypeLiteral<K> keyType, TypeLiteral<V> valueType,\n-      Key<Map<K, V>> mapKey, Key<Map<K, Provider<V>>> providerMapKey,\n-      Key<Map<K, Set<V>>> multimapKey, Key<Map<K, Set<Provider<V>>>> providerMultimapKey,\n+      TypeLiteral<K> keyType, TypeLiteral<V> valueType, Key<Map<K, V>> mapKey,\n       Multibinder<Entry<K, Provider<V>>> entrySetBinder) {\n-    RealMapBinder<K, V> mapBinder = new RealMapBinder<K, V>(\n-        binder, keyType, valueType, mapKey, providerMapKey, multimapKey,\n-        providerMultimapKey, entrySetBinder);\n+    RealMapBinder<K, V> mapBinder =\n+        new RealMapBinder<K, V>(binder, keyType, valueType, mapKey, entrySetBinder);\n     binder.install(mapBinder);\n     return mapBinder;\n   }\n@@ -330,16 +317,14 @@ static final class RealMapBinder<K, V> extends MapBinder<K, V> implements Module\n     private ImmutableList<Map.Entry<K, Binding<V>>> mapBindings;\n \n     private RealMapBinder(Binder binder, TypeLiteral<K> keyType, TypeLiteral<V> valueType,\n-        Key<Map<K, V>> mapKey, Key<Map<K, Provider<V>>> providerMapKey,\n-        Key<Map<K, Set<V>>> multimapKey, Key<Map<K, Set<Provider<V>>>> providerMultimapKey,\n-        Multibinder<Map.Entry<K, Provider<V>>> entrySetBinder) {\n+        Key<Map<K, V>> mapKey, Multibinder<Map.Entry<K, Provider<V>>> entrySetBinder) {\n       this.keyType = keyType;\n       this.valueType = valueType;\n       this.mapKey = mapKey;\n-      this.providerMapKey = providerMapKey;\n-      this.javaxProviderMapKey = providerMapKey.ofType(mapOfJavaxProviderOf(keyType, valueType));\n-      this.multimapKey = multimapKey;\n-      this.providerMultimapKey = providerMultimapKey;\n+      this.providerMapKey = mapKey.ofType(mapOfProviderOf(keyType, valueType));\n+      this.javaxProviderMapKey = mapKey.ofType(mapOfJavaxProviderOf(keyType, valueType));\n+      this.multimapKey = mapKey.ofType(mapOf(keyType, setOf(valueType)));\n+      this.providerMultimapKey = mapKey.ofType(mapOfSetOfProviderOf(keyType, valueType));\n       this.entrySetBinder = (RealMultibinder<Entry<K, Provider<V>>>) entrySetBinder;\n       this.binder = binder;\n       this.duplicateKeyErrorMessages = Maps.newHashMap();",
      "parent_sha": "9c8b61815fa15ee3457b9c816afe24a6fdaf7014"
    }
  },
  {
    "oid": "e7fb8058f3e24e6add860573c5d4657d057b9423",
    "message": "More Javadoc fixes...\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@661 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2008-11-04T19:17:11Z",
    "url": "https://github.com/google/guice/commit/e7fb8058f3e24e6add860573c5d4657d057b9423",
    "details": {
      "sha": "00394bdedeea9588c828d53ecd680364bd7e88b4",
      "filename": "extensions/privatemodules/src/com/google/inject/privatemodules/PrivateModule.java",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/google/guice/blob/e7fb8058f3e24e6add860573c5d4657d057b9423/extensions%2Fprivatemodules%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fprivatemodules%2FPrivateModule.java",
      "raw_url": "https://github.com/google/guice/raw/e7fb8058f3e24e6add860573c5d4657d057b9423/extensions%2Fprivatemodules%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fprivatemodules%2FPrivateModule.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fprivatemodules%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fprivatemodules%2FPrivateModule.java?ref=e7fb8058f3e24e6add860573c5d4657d057b9423",
      "patch": "@@ -88,9 +88,10 @@\n  * <p>Private modules are implemented using {@link Injector#createChildInjector(Module[]) parent\n  * injectors}. When it can satisfy their dependencies, just-in-time bindings will be created in the\n  * root environment. Such bindings are shared among all environments in the tree.\n- *\n- * <p>The scope of a shared binding is also shared among all environments in the tree. For example,\n- * if {@code FooImpl} is a shared singleton, all other modules will get the same instance.\n+ * \n+ * <p>The scope of a binding is constrained to its environment. A singleton bound in a private\n+ * module will be unique to its environment. But a binding for the same type in a different private\n+ * module will yield a different instance.\n  *\n  * <p>A shared binding that injects the {@code Injector} gets the root injector, which only has\n  * access to bindings in the root environment. An explicit binding that injects the {@code Injector}",
      "parent_sha": "8ba97884d8759890f6b32b65325c1c189061c09e"
    }
  },
  {
    "oid": "cd92207136395ec3c0543d43f70716436592a9fa",
    "message": "Add missing imports to make Java8LanguageFeatureBindingTest actually compile.\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=78110917",
    "date": "2014-10-20T20:30:10Z",
    "url": "https://github.com/google/guice/commit/cd92207136395ec3c0543d43f70716436592a9fa",
    "details": {
      "sha": "39a7498dd1b277e0a5d5e9f1494bff8e7334127f",
      "filename": "jdk8-tests/test/com/google/inject/jdk8/Java8LanguageFeatureBindingTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/google/guice/blob/cd92207136395ec3c0543d43f70716436592a9fa/jdk8-tests%2Ftest%2Fcom%2Fgoogle%2Finject%2Fjdk8%2FJava8LanguageFeatureBindingTest.java",
      "raw_url": "https://github.com/google/guice/raw/cd92207136395ec3c0543d43f70716436592a9fa/jdk8-tests%2Ftest%2Fcom%2Fgoogle%2Finject%2Fjdk8%2FJava8LanguageFeatureBindingTest.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/jdk8-tests%2Ftest%2Fcom%2Fgoogle%2Finject%2Fjdk8%2FJava8LanguageFeatureBindingTest.java?ref=cd92207136395ec3c0543d43f70716436592a9fa",
      "patch": "@@ -19,6 +19,7 @@\n import com.google.inject.AbstractModule;\n import com.google.inject.CreationException;\n import com.google.inject.Guice;\n+import com.google.inject.Inject;\n import com.google.inject.Injector;\n import com.google.inject.Key;\n import com.google.inject.Provider;\n@@ -28,6 +29,8 @@\n \n import junit.framework.TestCase;\n \n+import java.util.Collections;\n+import java.util.UUID;\n import java.util.concurrent.Callable;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.function.Predicate;\n@@ -38,7 +41,7 @@\n  * @author cgdecker@google.com (Colin Decker)\n  */\n public class Java8LanguageFeatureBindingTest extends TestCase {\n-  \n+\n   // Some of these tests are kind of weird.\n   // See https://github.com/google/guice/issues/757 for more on why they exist.\n ",
      "parent_sha": "35c2b3170b5225260da99690e226c58c6095e91a"
    }
  },
  {
    "oid": "a985135a59f7491364ab9ee16462179c34930c50",
    "message": "Remove the binder from ModuleInfo, it's used in one place and it's always == this.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=313773053",
    "date": "2020-06-01T16:42:50Z",
    "url": "https://github.com/google/guice/commit/a985135a59f7491364ab9ee16462179c34930c50",
    "details": {
      "sha": "4035c88104ff5dccd6f5b8d3f23fa26f1ee5d958",
      "filename": "core/src/com/google/inject/spi/Elements.java",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/google/guice/blob/a985135a59f7491364ab9ee16462179c34930c50/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fspi%2FElements.java",
      "raw_url": "https://github.com/google/guice/raw/a985135a59f7491364ab9ee16462179c34930c50/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fspi%2FElements.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fspi%2FElements.java?ref=a985135a59f7491364ab9ee16462179c34930c50",
      "patch": "@@ -139,12 +139,10 @@ static <T> BindingTargetVisitor<T, T> getInstanceVisitor() {\n   }\n \n   private static class ModuleInfo {\n-    private final Binder binder;\n     private final ModuleSource moduleSource;\n     private final boolean skipScanning;\n \n-    private ModuleInfo(Binder binder, ModuleSource moduleSource, boolean skipScanning) {\n-      this.binder = binder;\n+    private ModuleInfo(ModuleSource moduleSource, boolean skipScanning) {\n       this.moduleSource = moduleSource;\n       this.skipScanning = skipScanning;\n     }\n@@ -304,7 +302,7 @@ void scanForAnnotatedMethods() {\n           }\n           moduleSource = entry.getValue().moduleSource;\n           try {\n-            info.binder.install(ProviderMethodsModule.forModule(module, scanner));\n+            install(ProviderMethodsModule.forModule(module, scanner));\n           } catch (RuntimeException e) {\n             Collection<Message> messages = Errors.getMessagesFromThrowable(e);\n             if (!messages.isEmpty()) {\n@@ -348,12 +346,12 @@ public void install(Module module) {\n       if (module instanceof PrivateModule) {\n         binder = (RecordingBinder) binder.newPrivateBinder();\n         // Store the module in the private binder too so we scan for it.\n-        binder.modules.put(module, new ModuleInfo(binder, moduleSource, false));\n+        binder.modules.put(module, new ModuleInfo(moduleSource, false));\n         skipScanning = true; // don't scan this module in the parent's module set.\n       }\n       // Always store this in the parent binder (even if it was a private module)\n       // so that we know not to process it again, and so that scanners inherit down.\n-      modules.put(module, new ModuleInfo(binder, moduleSource, skipScanning));\n+      modules.put(module, new ModuleInfo(moduleSource, skipScanning));\n       try {\n         module.configure(binder);\n       } catch (RuntimeException e) {",
      "parent_sha": "6552e594fd5aa2d541ab7b12972b9132c8b038c7"
    }
  },
  {
    "oid": "48d8d82ea5b811900d41758c4142a8af00a9fe20",
    "message": "Changes from Isaac Shum that change the bindings for ServletRequest and ServletResponse to be chained to their HTTP counterparts rather than to be both bound directly to the same provider.\n\nAlso changing those bindings to be scoped appropriately.\n\nAnd finally, changing much of servlet module to leverage provider methods. This cleanup is cosmetic.\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@995 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2009-06-04T16:05:55Z",
    "url": "https://github.com/google/guice/commit/48d8d82ea5b811900d41758c4142a8af00a9fe20",
    "details": {
      "sha": "c58ca99d19a0d2835a0a719d9af013a1483acdf5",
      "filename": "servlet/src/com/google/inject/servlet/InternalServletModule.java",
      "status": "modified",
      "additions": 28,
      "deletions": 71,
      "changes": 99,
      "blob_url": "https://github.com/google/guice/blob/48d8d82ea5b811900d41758c4142a8af00a9fe20/servlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FInternalServletModule.java",
      "raw_url": "https://github.com/google/guice/raw/48d8d82ea5b811900d41758c4142a8af00a9fe20/servlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FInternalServletModule.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/servlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FInternalServletModule.java?ref=48d8d82ea5b811900d41758c4142a8af00a9fe20",
      "patch": "@@ -1,17 +1,16 @@\n package com.google.inject.servlet;\n \n import com.google.inject.AbstractModule;\n-import com.google.inject.Provider;\n-import com.google.inject.TypeLiteral;\n+import com.google.inject.Provides;\n import static com.google.inject.servlet.ServletScopes.REQUEST;\n import static com.google.inject.servlet.ServletScopes.SESSION;\n+import java.util.Map;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n import javax.servlet.http.HttpServletRequest;\n import javax.servlet.http.HttpServletResponse;\n import javax.servlet.http.HttpSession;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.ServletContext;\n-import java.util.Map;\n \n /**\n  * This is a left-factoring of all ServletModules installed in the system.\n@@ -24,73 +23,10 @@ final class InternalServletModule extends AbstractModule {\n \n   @Override\n   protected void configure() {\n-    // Scopes.\n     bindScope(RequestScoped.class, REQUEST);\n     bindScope(SessionScoped.class, SESSION);\n-\n-    // Bind request.\n-    Provider<HttpServletRequest> requestProvider =\n-        new Provider<HttpServletRequest>() {\n-          public HttpServletRequest get() {\n-            return GuiceFilter.getRequest();\n-          }\n-\n-          public String toString() {\n-            return \"RequestProvider\";\n-          }\n-        };\n-    bind(HttpServletRequest.class).toProvider(requestProvider);\n-    bind(ServletRequest.class).toProvider(requestProvider);\n-\n-    // Bind response.\n-    Provider<HttpServletResponse> responseProvider =\n-        new Provider<HttpServletResponse>() {\n-          public HttpServletResponse get() {\n-            return GuiceFilter.getResponse();\n-          }\n-\n-          public String toString() {\n-            return \"ResponseProvider\";\n-          }\n-        };\n-    bind(HttpServletResponse.class).toProvider(responseProvider);\n-    bind(ServletResponse.class).toProvider(responseProvider);\n-\n-    // Bind session.\n-    bind(HttpSession.class).toProvider(new Provider<HttpSession>() {\n-      public HttpSession get() {\n-        return GuiceFilter.getRequest().getSession();\n-      }\n-\n-      public String toString() {\n-        return \"SessionProvider\";\n-      }\n-    });\n-\n-    // Bind servlet context.\n-    bind(ServletContext.class).toProvider(new Provider<ServletContext>() {\n-      public ServletContext get() {\n-        return GuiceFilter.getServletContext();\n-      }\n-\n-      public String toString() {\n-        return \"ServletContextProvider\";\n-      }\n-    });\n-\n-    // Bind request parameters.\n-    bind(new TypeLiteral<Map<String, String[]>>() {})\n-        .annotatedWith(RequestParameters.class)\n-        .toProvider(new Provider<Map<String, String[]>>() {\n-              @SuppressWarnings({\"unchecked\"})\n-              public Map<String, String[]> get() {\n-                return GuiceFilter.getRequest().getParameterMap();\n-              }\n-\n-              public String toString() {\n-                return \"RequestParametersProvider\";\n-              }\n-            });\n+    bind(ServletRequest.class).to(HttpServletRequest.class);\n+    bind(ServletResponse.class).to(HttpServletResponse.class);\n \n     // inject the pipeline into GuiceFilter so it can route requests correctly\n     // Unfortunate staticness... =(\n@@ -100,6 +36,27 @@ public String toString() {\n     bind(FilterPipeline.class).to(ManagedFilterPipeline.class).asEagerSingleton();\n   }\n \n+  @Provides @RequestScoped HttpServletRequest provideHttpServletRequest() {\n+    return GuiceFilter.getRequest();\n+  }\n+\n+  @Provides @RequestScoped HttpServletResponse provideHttpServletResponse() {\n+    return GuiceFilter.getResponse();\n+  }\n+\n+  @Provides HttpSession provideHttpSession() {\n+    return GuiceFilter.getRequest().getSession();\n+  }\n+\n+  @Provides ServletContext provideServletContext() {\n+    return GuiceFilter.getServletContext();\n+  }\n+\n+  @SuppressWarnings({\"unchecked\"})\n+  @Provides @RequestScoped @RequestParameters Map<String, String[]> provideRequestParameters() {\n+    return GuiceFilter.getRequest().getParameterMap();\n+  }\n+\n   @Override\n   public boolean equals(Object o) {\n     // Is only ever installed internally, so we don't need to check state.",
      "parent_sha": "b92f5400bc2e9c23010c72cf15f8e5305fd9bf53"
    }
  },
  {
    "oid": "9678847695b64c8a9728fd84d312754fc00da3d6",
    "message": "Remove references to Google Docs and instead point to the wiki when possible. Fixes #1556\n\nPiperOrigin-RevId: 525231598",
    "date": "2023-04-18T20:14:49Z",
    "url": "https://github.com/google/guice/commit/9678847695b64c8a9728fd84d312754fc00da3d6",
    "details": {
      "sha": "f3d33034d6d0b63ddad310987a4956a2064e0817",
      "filename": "core/src/com/google/inject/package-info.java",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/google/guice/blob/9678847695b64c8a9728fd84d312754fc00da3d6/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fpackage-info.java",
      "raw_url": "https://github.com/google/guice/raw/9678847695b64c8a9728fd84d312754fc00da3d6/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fpackage-info.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fpackage-info.java?ref=9678847695b64c8a9728fd84d312754fc00da3d6",
      "patch": "@@ -16,24 +16,24 @@\n \n /**\n  * <i>Google Guice</i> (pronounced \"juice\") is an ultra-lightweight dependency injection framework.\n- * Please refer to the Guice <a href=\"http://docs.google.com/Doc?id=dd2fhx4z_5df5hw8\">User's\n+ * Please refer to the Guice <a href=\"https://github.com/google/guice/wiki/Motivation\">User's\n  * Guide</a> for a gentle introduction.\n  *\n  * <p>The principal public APIs in this package are:\n  *\n  * <dl>\n- * <dt>{@link com.google.inject.Inject}\n- * <dd>The annotation you will use in your implementation classes to tell Guice where and how it\n- *     should send in (\"inject\") the objects you depend on (your \"dependencies\").\n- * <dt>{@link com.google.inject.Module}\n- * <dd>The interface you will implement in order to specify \"bindings\" -- instructions for how Guice\n- *     should handle injection -- for a particular set of interfaces.\n- * <dt>{@link com.google.inject.Binder}\n- * <dd>The object that Guice passes into your {@link com.google.inject.Module} to collect these\n- *     bindings.\n- * <dt>{@link com.google.inject.Provider}\n- * <dd>The interface you will implement when you need to customize exactly how Guice creates\n- *     instances for a particular binding.\n+ *   <dt>{@link com.google.inject.Inject}\n+ *   <dd>The annotation you will use in your implementation classes to tell Guice where and how it\n+ *       should send in (\"inject\") the objects you depend on (your \"dependencies\").\n+ *   <dt>{@link com.google.inject.Module}\n+ *   <dd>The interface you will implement in order to specify \"bindings\" -- instructions for how\n+ *       Guice should handle injection -- for a particular set of interfaces.\n+ *   <dt>{@link com.google.inject.Binder}\n+ *   <dd>The object that Guice passes into your {@link com.google.inject.Module} to collect these\n+ *       bindings.\n+ *   <dt>{@link com.google.inject.Provider}\n+ *   <dd>The interface you will implement when you need to customize exactly how Guice creates\n+ *       instances for a particular binding.\n  * </dl>\n  */\n package com.google.inject;",
      "parent_sha": "c3d8f51da635361ae16911e1b5168dce6de21f8f"
    }
  },
  {
    "oid": "df10bedd5952d01f04a1c39cb0495bd62f5cdc9c",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 659586774",
    "date": "2024-08-05T16:56:06Z",
    "url": "https://github.com/google/guice/commit/df10bedd5952d01f04a1c39cb0495bd62f5cdc9c",
    "details": {
      "sha": "217fc4b96118822f07c5c70ab1f34d997adabeef",
      "filename": "extensions/testlib/test/com/google/inject/testing/fieldbinder/BoundFieldModuleTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/df10bedd5952d01f04a1c39cb0495bd62f5cdc9c/extensions%2Ftestlib%2Ftest%2Fcom%2Fgoogle%2Finject%2Ftesting%2Ffieldbinder%2FBoundFieldModuleTest.java",
      "raw_url": "https://github.com/google/guice/raw/df10bedd5952d01f04a1c39cb0495bd62f5cdc9c/extensions%2Ftestlib%2Ftest%2Fcom%2Fgoogle%2Finject%2Ftesting%2Ffieldbinder%2FBoundFieldModuleTest.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Ftestlib%2Ftest%2Fcom%2Fgoogle%2Finject%2Ftesting%2Ffieldbinder%2FBoundFieldModuleTest.java?ref=df10bedd5952d01f04a1c39cb0495bd62f5cdc9c",
      "patch": "@@ -668,7 +668,7 @@ public Object get() {\n     assertEquals(testValue, injector.getInstance(Integer.class));\n   }\n \n-  @SuppressWarnings(\"rawtypes\") // Testing rawtypes\n+  @SuppressWarnings({\"rawtypes\", \"JUnitIncompatibleType\"}) // Testing rawtypes\n   public void testRawProviderCanBindToIncorrectType() {\n     final Integer testValue = 1024;\n     Object instance =",
      "parent_sha": "e35efe7d72104e986ecd515d2194290e0789baf4"
    }
  },
  {
    "oid": "4c68d34ae70f9bcf09c77a3e6a66bf566664cf4c",
    "message": "Added more servlet unit tests.\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@107 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2007-02-09T00:59:58Z",
    "url": "https://github.com/google/guice/commit/4c68d34ae70f9bcf09c77a3e6a66bf566664cf4c",
    "details": {
      "sha": "f06c4f76b94e7c524046444e02dea029fd22e1a3",
      "filename": "test/com/google/inject/servlet/ServletTest.java",
      "status": "modified",
      "additions": 113,
      "deletions": 8,
      "changes": 121,
      "blob_url": "https://github.com/google/guice/blob/4c68d34ae70f9bcf09c77a3e6a66bf566664cf4c/test%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletTest.java",
      "raw_url": "https://github.com/google/guice/raw/4c68d34ae70f9bcf09c77a3e6a66bf566664cf4c/test%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletTest.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/test%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletTest.java?ref=4c68d34ae70f9bcf09c77a3e6a66bf566664cf4c",
      "patch": "@@ -32,6 +32,7 @@\n import javax.servlet.ServletRequest;\n import javax.servlet.ServletResponse;\n import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpSession;\n \n /**\n  * @author crazybob@google.com (Bob Lee)\n@@ -40,19 +41,15 @@ public class ServletTest extends TestCase {\n \n   public void testNewRequestObject()\n       throws ContainerCreationException, IOException, ServletException {\n-    ContainerBuilder builder = new ContainerBuilder();\n-    builder.install(new ServletModule());\n-    builder.bind(InSession.class);\n-    builder.bind(InRequest.class);\n-    final Container container = builder.create(false);\n+    final Container container = createContainer();\n \n     GuiceFilter filter = new GuiceFilter();\n \n     final HttpServletRequest request = createMock(HttpServletRequest.class);\n \n-    String requestName = Key.get(InRequest.class).toString();\n-    expect(request.getAttribute(requestName)).andReturn(null);\n-    request.setAttribute(eq(requestName), isA(InRequest.class));\n+    String name = Key.get(InRequest.class).toString();\n+    expect(request.getAttribute(name)).andReturn(null);\n+    request.setAttribute(eq(name), isA(InRequest.class));\n \n     final boolean[] invoked = new boolean[1];\n     FilterChain filterChain = new FilterChain() {\n@@ -72,6 +69,114 @@ public void doFilter(ServletRequest servletRequest,\n     assertTrue(invoked[0]);\n   }\n \n+  public void testExistingRequestObject()\n+      throws ContainerCreationException, IOException, ServletException {\n+    final Container container = createContainer();\n+\n+    GuiceFilter filter = new GuiceFilter();\n+\n+    final HttpServletRequest request = createMock(HttpServletRequest.class);\n+\n+    final InRequest inRequest = new InRequest();\n+    String name = Key.get(InRequest.class).toString();\n+    expect(request.getAttribute(name)).andReturn(inRequest).times(2);\n+\n+    final boolean[] invoked = new boolean[1];\n+    FilterChain filterChain = new FilterChain() {\n+      public void doFilter(ServletRequest servletRequest,\n+          ServletResponse servletResponse) {\n+        invoked[0] = true;\n+        assertSame(request, servletRequest);\n+        assertSame(inRequest, container.getInstance(InRequest.class));\n+        assertSame(inRequest, container.getInstance(InRequest.class));\n+      }\n+    };\n+\n+    replay(request);\n+\n+    filter.doFilter(request, null, filterChain);\n+\n+    verify(request);\n+    assertTrue(invoked[0]);\n+  }\n+\n+  public void testNewSessionObject()\n+      throws ContainerCreationException, IOException, ServletException {\n+    final Container container = createContainer();\n+\n+    GuiceFilter filter = new GuiceFilter();\n+\n+    final HttpServletRequest request = createMock(HttpServletRequest.class);\n+    final HttpSession session = createMock(HttpSession.class);\n+\n+    String name = Key.get(InSession.class).toString();\n+\n+    expect(request.getSession()).andReturn(session);\n+    expect(session.getAttribute(name)).andReturn(null);\n+    session.setAttribute(eq(name), isA(InSession.class));\n+\n+    final boolean[] invoked = new boolean[1];\n+    FilterChain filterChain = new FilterChain() {\n+      public void doFilter(ServletRequest servletRequest,\n+          ServletResponse servletResponse) {\n+        invoked[0] = true;\n+        assertSame(request, servletRequest);\n+        assertTrue(container.getInstance(InSession.class) instanceof InSession);\n+      }\n+    };\n+\n+    replay(request, session);\n+\n+    filter.doFilter(request, null, filterChain);\n+\n+    verify(request, session);\n+    assertTrue(invoked[0]);\n+  }\n+\n+  public void testExistingSessionObject()\n+      throws ContainerCreationException, IOException, ServletException {\n+    final Container container = createContainer();\n+\n+    GuiceFilter filter = new GuiceFilter();\n+\n+    final HttpServletRequest request = createMock(HttpServletRequest.class);\n+    final HttpSession session = createMock(HttpSession.class);\n+\n+    String name = Key.get(InSession.class).toString();\n+\n+    final InSession inSession = new InSession();\n+    expect(request.getSession()).andReturn(session).times(2);\n+    expect(session.getAttribute(name)).andReturn(inSession).times(2);\n+\n+    final boolean[] invoked = new boolean[1];\n+    FilterChain filterChain = new FilterChain() {\n+      public void doFilter(ServletRequest servletRequest,\n+          ServletResponse servletResponse) {\n+        invoked[0] = true;\n+        assertSame(request, servletRequest);\n+\n+        assertSame(inSession, container.getInstance(InSession.class));\n+        assertSame(inSession, container.getInstance(InSession.class));\n+      }\n+    };\n+\n+    replay(request, session);\n+\n+    filter.doFilter(request, null, filterChain);\n+\n+    verify(request, session);\n+    assertTrue(invoked[0]);\n+  }\n+\n+  private Container createContainer() throws ContainerCreationException {\n+    ContainerBuilder builder = new ContainerBuilder();\n+    builder.install(new ServletModule());\n+    builder.bind(InSession.class);\n+    builder.bind(InRequest.class);\n+    final Container container = builder.create(false);\n+    return container;\n+  }\n+\n   @SessionScoped\n   static class InSession {}\n ",
      "parent_sha": "2c09fe29b6e686850ad07733c517aa8467adc078"
    }
  },
  {
    "oid": "2b12d5cc63506f1a88d7f0a82519c89bdbcc5cdc",
    "message": "Changed suppress warnings message to suppress Guice annotation processor error that is caused by multiple constructors annotated with @Inject to make it more clear/specific.\n\n\"inject-constructors\" -> \"InjectMultipleAtInjectConstructors\"\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=130007929",
    "date": "2016-08-29T20:41:31Z",
    "url": "https://github.com/google/guice/commit/2b12d5cc63506f1a88d7f0a82519c89bdbcc5cdc",
    "details": {
      "sha": "670b97ecf31097206d9bc58490e9882fde70e636",
      "filename": "core/test/com/google/inject/BindingTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/2b12d5cc63506f1a88d7f0a82519c89bdbcc5cdc/core%2Ftest%2Fcom%2Fgoogle%2Finject%2FBindingTest.java",
      "raw_url": "https://github.com/google/guice/raw/2b12d5cc63506f1a88d7f0a82519c89bdbcc5cdc/core%2Ftest%2Fcom%2Fgoogle%2Finject%2FBindingTest.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Ftest%2Fcom%2Fgoogle%2Finject%2FBindingTest.java?ref=2b12d5cc63506f1a88d7f0a82519c89bdbcc5cdc",
      "patch": "@@ -221,7 +221,7 @@ public void testTooManyConstructors() {\n     }\n   }\n \n-  @SuppressWarnings(\"inject-constructors\")\n+  @SuppressWarnings(\"InjectMultipleAtInjectConstructors\")\n   static class TooManyConstructors {\n     @Inject\n     TooManyConstructors(Injector i) {}",
      "parent_sha": "ff3384c101bcfd686eb0b2e9892d8e6d758d1ea7"
    }
  },
  {
    "oid": "33996155208bb1fa4a6a41578f114a99be618ad9",
    "message": "Use Lookup.class as the base when retrieving trusted lookup because we know that's where the field is declared.\n\nFixes #1673\nFixes #1672\n\nPiperOrigin-RevId: 524835342",
    "date": "2023-04-17T13:59:10Z",
    "url": "https://github.com/google/guice/commit/33996155208bb1fa4a6a41578f114a99be618ad9",
    "details": {
      "sha": "af36f7be0c0fecf78ad378705b481420c386b2ed",
      "filename": "core/src/com/google/inject/internal/aop/HiddenClassDefiner.java",
      "status": "modified",
      "additions": 1,
      "deletions": 4,
      "changes": 5,
      "blob_url": "https://github.com/google/guice/blob/33996155208bb1fa4a6a41578f114a99be618ad9/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2Faop%2FHiddenClassDefiner.java",
      "raw_url": "https://github.com/google/guice/raw/33996155208bb1fa4a6a41578f114a99be618ad9/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2Faop%2FHiddenClassDefiner.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2Faop%2FHiddenClassDefiner.java?ref=33996155208bb1fa4a6a41578f114a99be618ad9",
      "patch": "@@ -29,7 +29,6 @@\n final class HiddenClassDefiner implements ClassDefiner {\n \n   private static final Object THE_UNSAFE;\n-  private static final Object TRUSTED_LOOKUP_BASE;\n   private static final Object TRUSTED_LOOKUP_OFFSET;\n   private static final Method GET_OBJECT_METHOD;\n   private static final Object HIDDEN_CLASS_OPTIONS;\n@@ -42,8 +41,6 @@ final class HiddenClassDefiner implements ClassDefiner {\n       theUnsafeField.setAccessible(true);\n       THE_UNSAFE = theUnsafeField.get(null);\n       Field trustedLookupField = Lookup.class.getDeclaredField(\"IMPL_LOOKUP\");\n-      Method baseMethod = unsafeType.getMethod(\"staticFieldBase\", Field.class);\n-      TRUSTED_LOOKUP_BASE = baseMethod.invoke(THE_UNSAFE, trustedLookupField);\n       Method offsetMethod = unsafeType.getMethod(\"staticFieldOffset\", Field.class);\n       TRUSTED_LOOKUP_OFFSET = offsetMethod.invoke(THE_UNSAFE, trustedLookupField);\n       GET_OBJECT_METHOD = unsafeType.getMethod(\"getObject\", Object.class, long.class);\n@@ -59,7 +56,7 @@ final class HiddenClassDefiner implements ClassDefiner {\n   @Override\n   public Class<?> define(Class<?> hostClass, byte[] bytecode) throws Exception {\n     Lookup trustedLookup =\n-        (Lookup) GET_OBJECT_METHOD.invoke(THE_UNSAFE, TRUSTED_LOOKUP_BASE, TRUSTED_LOOKUP_OFFSET);\n+        (Lookup) GET_OBJECT_METHOD.invoke(THE_UNSAFE, Lookup.class, TRUSTED_LOOKUP_OFFSET);\n     Lookup definedLookup =\n         (Lookup)\n             HIDDEN_DEFINE_METHOD.invoke(",
      "parent_sha": "5c37cd96625eb94199bee48a4706545d528a25e9"
    }
  },
  {
    "oid": "6f717b8384fd360d7cd31cc9e68172701c3c509c",
    "message": "Rename createProviderBinding -> createSyntheticProviderBinding and ProviderBindingImpl -> SyntheticProviderBindingImpl, so that it's clear these are only used for synthetic provider bindings.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=300886086",
    "date": "2020-03-16T14:26:57Z",
    "url": "https://github.com/google/guice/commit/6f717b8384fd360d7cd31cc9e68172701c3c509c",
    "details": {
      "sha": "c1eedce869524253d5e126497ec0644dac89b04d",
      "filename": "core/src/com/google/inject/internal/InjectorImpl.java",
      "status": "modified",
      "additions": 13,
      "deletions": 11,
      "changes": 24,
      "blob_url": "https://github.com/google/guice/blob/6f717b8384fd360d7cd31cc9e68172701c3c509c/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInjectorImpl.java",
      "raw_url": "https://github.com/google/guice/raw/6f717b8384fd360d7cd31cc9e68172701c3c509c/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInjectorImpl.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInjectorImpl.java?ref=6f717b8384fd360d7cd31cc9e68172701c3c509c",
      "patch": "@@ -358,21 +358,23 @@ private <T> BindingImpl<MembersInjector<T>> createMembersInjectorBinding(\n   }\n \n   /**\n-   * Creates a synthetic binding to {@code Provider<T>}, i.e. a binding to the provider from {@code\n-   * Binding<T>}.\n+   * Creates a synthetic binding to {@code Provider<T>}, i.e. a framework-created JIT binding to the\n+   * provider from {@code Binding<T>}.\n    */\n-  private <T> BindingImpl<Provider<T>> createProviderBinding(Key<Provider<T>> key, Errors errors)\n-      throws ErrorsException {\n+  private <T> BindingImpl<Provider<T>> createSyntheticProviderBinding(\n+      Key<Provider<T>> key, Errors errors) throws ErrorsException {\n     Key<T> providedKey = getProvidedKey(key, errors);\n     BindingImpl<T> delegate = getBindingOrThrow(providedKey, errors, JitLimitation.NO_JIT);\n-    return new ProviderBindingImpl<T>(this, key, delegate);\n+    return new SyntheticProviderBindingImpl<T>(this, key, delegate);\n   }\n \n-  private static class ProviderBindingImpl<T> extends BindingImpl<Provider<T>>\n+  /** A framework-created JIT Provider<T> binding. */\n+  private static class SyntheticProviderBindingImpl<T> extends BindingImpl<Provider<T>>\n       implements ProviderBinding<Provider<T>>, HasDependencies {\n     final BindingImpl<T> providedBinding;\n \n-    ProviderBindingImpl(InjectorImpl injector, Key<Provider<T>> key, Binding<T> providedBinding) {\n+    SyntheticProviderBindingImpl(\n+        InjectorImpl injector, Key<Provider<T>> key, Binding<T> providedBinding) {\n       super(\n           injector,\n           key,\n@@ -422,8 +424,8 @@ public Set<Dependency<?>> getDependencies() {\n \n     @Override\n     public boolean equals(Object obj) {\n-      if (obj instanceof ProviderBindingImpl) {\n-        ProviderBindingImpl<?> o = (ProviderBindingImpl<?>) obj;\n+      if (obj instanceof SyntheticProviderBindingImpl) {\n+        SyntheticProviderBindingImpl<?> o = (SyntheticProviderBindingImpl<?>) obj;\n         return getKey().equals(o.getKey())\n             && getScoping().equals(o.getScoping())\n             && Objects.equal(providedBinding, o.providedBinding);\n@@ -895,9 +897,9 @@ private <T> BindingImpl<T> createJustInTimeBinding(\n     // Handle cases where T is a Provider<?>.\n     if (isProvider(key)) {\n       // These casts are safe. We know T extends Provider<X> and that given Key<Provider<X>>,\n-      // createProviderBinding() will return BindingImpl<Provider<X>>.\n+      // createSyntheticProviderBinding() will return BindingImpl<Provider<X>>.\n       @SuppressWarnings({\"unchecked\", \"cast\"})\n-      BindingImpl<T> binding = (BindingImpl<T>) createProviderBinding((Key) key, errors);\n+      BindingImpl<T> binding = (BindingImpl<T>) createSyntheticProviderBinding((Key) key, errors);\n       return binding;\n     }\n ",
      "parent_sha": "febf8a0de5a187a8523e3bbdb63fbe5a19f90eab"
    }
  },
  {
    "oid": "fbbb52dcc92e964b95f389684e87b363f6499173",
    "message": "\nfix issue 636, GuiceFilter should keep a strong ref to its logger.\n\nRevision created by MOE tool push_codebase.\nMOE_MIGRATION=3478\n\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@1594 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2011-10-16T23:33:52Z",
    "url": "https://github.com/google/guice/commit/fbbb52dcc92e964b95f389684e87b363f6499173",
    "details": {
      "sha": "d069c96a1a1a05350a9590c6d36ab48db109a98a",
      "filename": "extensions/servlet/src/com/google/inject/servlet/GuiceFilter.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/google/guice/blob/fbbb52dcc92e964b95f389684e87b363f6499173/extensions%2Fservlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FGuiceFilter.java",
      "raw_url": "https://github.com/google/guice/raw/fbbb52dcc92e964b95f389684e87b363f6499173/extensions%2Fservlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FGuiceFilter.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fservlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FGuiceFilter.java?ref=fbbb52dcc92e964b95f389684e87b363f6499173",
      "patch": "@@ -77,6 +77,8 @@ public class GuiceFilter implements Filter {\n       + \"in your web application. If this is deliberate, you may safely \"\n       + \"ignore this message. If this is NOT deliberate however, \"\n       + \"your application may not work as expected.\";\n+  \n+  private static final Logger LOGGER = Logger.getLogger(GuiceFilter.class.getName());\n \n   public GuiceFilter() {\n     // Use the static FilterPipeline\n@@ -94,7 +96,7 @@ static void setPipeline(FilterPipeline pipeline) {\n     // This can happen if you create many injectors and they all have their own\n     // servlet module. This is legal, caveat a small warning.\n     if (GuiceFilter.pipeline instanceof ManagedFilterPipeline) {\n-        Logger.getLogger(GuiceFilter.class.getName()).warning(MULTIPLE_INJECTORS_WARNING);\n+      LOGGER.warning(MULTIPLE_INJECTORS_WARNING);\n     }\n \n     // We overwrite the default pipeline",
      "parent_sha": "6b7e7187bd074d3f2df9b04e17fa01e7592f295c"
    }
  },
  {
    "oid": "7d7f94fed82cb21e8a477996fcdc1575a9091033",
    "message": "Change throwingprovider tests to not depend on testlib.  Otherwise we have a cyclic dependency in maven.  ([] can handle different deps for compile/test and separate out the cycle, but maven can't.)\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=131623667",
    "date": "2016-08-29T20:42:36Z",
    "url": "https://github.com/google/guice/commit/7d7f94fed82cb21e8a477996fcdc1575a9091033",
    "details": {
      "sha": "be1878ec66c07ea3bd4a4dd51afa2dfcf5d8ddf8",
      "filename": "extensions/throwingproviders/test/com/google/inject/throwingproviders/CheckedProvidersTest.java",
      "status": "modified",
      "additions": 16,
      "deletions": 17,
      "changes": 33,
      "blob_url": "https://github.com/google/guice/blob/7d7f94fed82cb21e8a477996fcdc1575a9091033/extensions%2Fthrowingproviders%2Ftest%2Fcom%2Fgoogle%2Finject%2Fthrowingproviders%2FCheckedProvidersTest.java",
      "raw_url": "https://github.com/google/guice/raw/7d7f94fed82cb21e8a477996fcdc1575a9091033/extensions%2Fthrowingproviders%2Ftest%2Fcom%2Fgoogle%2Finject%2Fthrowingproviders%2FCheckedProvidersTest.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fthrowingproviders%2Ftest%2Fcom%2Fgoogle%2Finject%2Fthrowingproviders%2FCheckedProvidersTest.java?ref=7d7f94fed82cb21e8a477996fcdc1575a9091033",
      "patch": "@@ -2,7 +2,6 @@\n \n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth.assert_;\n-import static com.google.inject.testing.throwingproviders.CheckedProviderSubject.assertThat;\n import static org.junit.Assert.fail;\n \n import com.google.inject.TypeLiteral;\n@@ -17,34 +16,30 @@\n public final class CheckedProvidersTest extends TestCase {\n   private static interface StringCheckedProvider extends CheckedProvider<String> {}\n \n-  public void testCheckedProviderClass_get_returnsValidString() {\n+  public void testCheckedProviderClass_get_returnsValidString() throws Exception {\n     String expected = \"rick\";\n \n     StringCheckedProvider provider = CheckedProviders.of(StringCheckedProvider.class, expected);\n-\n-    assertThat(provider).providedValue().isEqualTo(expected);\n+    assertThat(provider.get()).isEqualTo(expected);\n   }\n \n-  public void testCheckedProviderTypeLiteral_get_returnsValidString() {\n+  public void testCheckedProviderTypeLiteral_get_returnsValidString() throws Exception {\n     String expected = \"morty\";\n \n     StringCheckedProvider provider =\n         CheckedProviders.of(TypeLiteral.get(StringCheckedProvider.class), expected);\n-\n-    assertThat(provider).providedValue().isEqualTo(expected);\n+    assertThat(provider.get()).isEqualTo(expected);\n   }\n \n-  public void testCheckedProviderClassNull_get_returnsNull() {\n+  public void testCheckedProviderClassNull_get_returnsNull() throws Exception {\n     StringCheckedProvider provider = CheckedProviders.of(StringCheckedProvider.class, null);\n-\n-    assertThat(provider).providedValue().isNull();\n+    assertThat(provider.get()).isNull();\n   }\n \n-  public void testCheckedProviderTypeLiteralNull_get_returnsNull() {\n+  public void testCheckedProviderTypeLiteralNull_get_returnsNull() throws Exception {\n     StringCheckedProvider provider =\n         CheckedProviders.of(TypeLiteral.get(StringCheckedProvider.class), null);\n-\n-    assertThat(provider).providedValue().isNull();\n+    assertThat(provider.get()).isNull();\n   }\n \n   private static final class FooException extends Exception {}\n@@ -57,15 +52,19 @@ private interface FooCheckedProvider extends CheckedProvider<Object> {\n   public void testThrowingCheckedProviderClass_get_throwsException() {\n     FooCheckedProvider provider =\n         CheckedProviders.throwing(FooCheckedProvider.class, FooException.class);\n-\n-    assertThat(provider).thrownException().isInstanceOf(FooException.class);\n+    try {\n+      provider.get();\n+      fail();\n+    } catch (FooException expected) {}\n   }\n \n   public void testThrowingCheckedProviderTypeLiteral_get_throwsException() {\n     FooCheckedProvider provider =\n         CheckedProviders.throwing(TypeLiteral.get(FooCheckedProvider.class), FooException.class);\n-\n-    assertThat(provider).thrownException().isInstanceOf(FooException.class);\n+    try {\n+      provider.get();\n+      fail();\n+    } catch (FooException expected) {}\n   }\n \n   private interface MoreMethodsCheckedProvider<T> extends CheckedProvider<T> {",
      "parent_sha": "9b042f4f167fc2bd30390e3ced11a95d075ace23"
    }
  },
  {
    "oid": "315ee3fe103b7a414d4783812aaaa79fd524e7d3",
    "message": "Make ServletContext available even a bit earlier than it already was.\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@911 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2009-03-27T00:39:55Z",
    "url": "https://github.com/google/guice/commit/315ee3fe103b7a414d4783812aaaa79fd524e7d3",
    "details": {
      "sha": "70810ca66ce2e30a88dfcc2d92316140c7cddafa",
      "filename": "servlet/src/com/google/inject/servlet/GuiceServletContextListener.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/315ee3fe103b7a414d4783812aaaa79fd524e7d3/servlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FGuiceServletContextListener.java",
      "raw_url": "https://github.com/google/guice/raw/315ee3fe103b7a414d4783812aaaa79fd524e7d3/servlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FGuiceServletContextListener.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/servlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FGuiceServletContextListener.java?ref=315ee3fe103b7a414d4783812aaaa79fd524e7d3",
      "patch": "@@ -37,10 +37,10 @@ public abstract class GuiceServletContextListener\n \n   public void contextInitialized(ServletContextEvent servletContextEvent) {\n     ServletContext servletContext = servletContextEvent.getServletContext();\n-    servletContext.setAttribute(INJECTOR_NAME, getInjector());\n \n     // Set the Servletcontext early for those people who are using this class.\n     GuiceFilter.servletContext = new WeakReference<ServletContext>(servletContext);\n+    servletContext.setAttribute(INJECTOR_NAME, getInjector());\n   }\n \n   public void contextDestroyed(ServletContextEvent servletContextEvent) {",
      "parent_sha": "516e2ab11feba3634edf380c65df98fadc56a231"
    }
  },
  {
    "oid": "96d2164784328d48ff2e4e4f3026a516f99d0c35",
    "message": "Added tests for a few cases where we could detect a misplaced annotation (but we don't currently)\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@563 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2008-07-18T23:49:43Z",
    "url": "https://github.com/google/guice/commit/96d2164784328d48ff2e4e4f3026a516f99d0c35",
    "details": {
      "sha": "87ed3f325222d3f2981c9157d9a7f56bd4e92160",
      "filename": "test/com/google/inject/ScopesTest.java",
      "status": "modified",
      "additions": 38,
      "deletions": 2,
      "changes": 40,
      "blob_url": "https://github.com/google/guice/blob/96d2164784328d48ff2e4e4f3026a516f99d0c35/test%2Fcom%2Fgoogle%2Finject%2FScopesTest.java",
      "raw_url": "https://github.com/google/guice/raw/96d2164784328d48ff2e4e4f3026a516f99d0c35/test%2Fcom%2Fgoogle%2Finject%2FScopesTest.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/test%2Fcom%2Fgoogle%2Finject%2FScopesTest.java?ref=96d2164784328d48ff2e4e4f3026a516f99d0c35",
      "patch": "@@ -107,7 +107,7 @@ protected void configure() {\n         injector.getInstance(AnnotatedSingleton.class));\n   }\n \n-  public void testScopingAnnotationsOnAbstractTypes() {\n+  public void testScopingAnnotationsOnAbstractTypeViaBind() {\n     try {\n       Guice.createInjector(new AbstractModule() {\n         protected void configure() {\n@@ -126,7 +126,43 @@ protected void configure() {\n   @Singleton\n   interface A {}\n   static class AImpl implements A {}\n-  \n+\n+  public void testScopingAnnotationsOnAbstractTypeViaImplementedBy() {\n+    try {\n+      Guice.createInjector().getInstance(D.class);\n+      fail();\n+    } catch (ProvisionException expected) {\n+      assertContains(expected.getMessage(),\n+          \"Error at \" + D.class.getName() + \".class(ScopesTest.java:\",\n+          D.class.getName() + \" is annotated with \" + Singleton.class.getName(),\n+          \"but scope annotations are not supported for abstract types.\");\n+    }\n+  }\n+\n+  @Singleton @ImplementedBy(DImpl.class)\n+  interface D {}\n+  static class DImpl implements D {}\n+\n+  public void testScopingAnnotationsOnAbstractTypeViaProvidedBy() {\n+    try {\n+      Guice.createInjector().getInstance(E.class);\n+      fail();\n+    } catch (ProvisionException expected) {\n+      assertContains(expected.getMessage(),\n+          \"Error at \" + E.class.getName() + \".class(ScopesTest.java:\",\n+          E.class.getName() + \" is annotated with \" + Singleton.class.getName(),\n+          \"but scope annotations are not supported for abstract types.\");\n+    }\n+  }\n+\n+  @Singleton @ProvidedBy(EProvider.class)\n+  interface E {}\n+  static class EProvider implements Provider<E> {\n+    public E get() {\n+      return null;\n+    }\n+  }\n+\n   public void testScopeUsedButNotBound() {\n     try {\n       Guice.createInjector(new AbstractModule() {",
      "parent_sha": "f3429aefc145e81cd8c0961396603690bace9217"
    }
  },
  {
    "oid": "e16b64947d28bdd29ea212474db18f6dde8e5a8d",
    "message": "Migrate users from com.google.common.collect.Sets.newSetFromMap(Map) to java.util.Collections.newSetFromMap(Map), which was added to JDK 1.6.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=94570774",
    "date": "2015-10-28T17:32:58Z",
    "url": "https://github.com/google/guice/commit/e16b64947d28bdd29ea212474db18f6dde8e5a8d",
    "details": {
      "sha": "8c61559da27d97afc4527ec57c5e9fd0fe67f915",
      "filename": "core/src/com/google/inject/internal/Errors.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/google/guice/blob/e16b64947d28bdd29ea212474db18f6dde8e5a8d/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FErrors.java",
      "raw_url": "https://github.com/google/guice/raw/e16b64947d28bdd29ea212474db18f6dde8e5a8d/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FErrors.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FErrors.java?ref=e16b64947d28bdd29ea212474db18f6dde8e5a8d",
      "patch": "@@ -24,7 +24,6 @@\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Ordering;\n-import com.google.common.collect.Sets;\n import com.google.inject.ConfigurationException;\n import com.google.inject.CreationException;\n import com.google.inject.Guice;\n@@ -56,6 +55,7 @@\n import java.lang.reflect.Type;\n import java.util.Arrays;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.Formatter;\n import java.util.List;\n import java.util.Map;\n@@ -84,7 +84,7 @@ public final class Errors implements Serializable {\n   private static final Logger logger = Logger.getLogger(Guice.class.getName());\n \n   private static final Set<Dependency<?>> warnedDependencies =\n-      Sets.newSetFromMap(new ConcurrentHashMap<Dependency<?>, Boolean>());\n+      Collections.newSetFromMap(new ConcurrentHashMap<Dependency<?>, Boolean>());\n \n \n   /**",
      "parent_sha": "abc78c361d9018da211690b673accb580a52abf2"
    }
  },
  {
    "oid": "c6c118f787a790ee0f29a23d52c1f5a56297bc05",
    "message": "Add closing parens to FactoryModuleBuilder javadoc samples\n\nFixes issue 826.",
    "date": "2014-07-25T01:39:28Z",
    "url": "https://github.com/google/guice/commit/c6c118f787a790ee0f29a23d52c1f5a56297bc05",
    "details": {
      "sha": "0ae096eea2d50420ec2ebfa89d3edd4f3862a9d1",
      "filename": "extensions/assistedinject/src/com/google/inject/assistedinject/FactoryModuleBuilder.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/google/guice/blob/c6c118f787a790ee0f29a23d52c1f5a56297bc05/extensions%2Fassistedinject%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fassistedinject%2FFactoryModuleBuilder.java",
      "raw_url": "https://github.com/google/guice/raw/c6c118f787a790ee0f29a23d52c1f5a56297bc05/extensions%2Fassistedinject%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fassistedinject%2FFactoryModuleBuilder.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fassistedinject%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fassistedinject%2FFactoryModuleBuilder.java?ref=c6c118f787a790ee0f29a23d52c1f5a56297bc05",
      "patch": "@@ -93,7 +93,7 @@\n  *\n  * <pre>install(new FactoryModuleBuilder()\n  *     .implement(Payment.class, RealPayment.class)\n- *     .build(PaymentFactory.class);</pre>\n+ *     .build(PaymentFactory.class));</pre>\n  *\n  * As a side-effect of this binding, Guice will inject the factory to initialize it for use. The\n  * factory cannot be used until the injector has been initialized.\n@@ -115,7 +115,7 @@\n  *     // excluding .implement for Shipment means the implementation class\n  *     // will be 'Shipment' itself, which is legal if it's not an interface.\n  *     .implement(Receipt.class, RealReceipt.class)\n- *     .build(OrderFactory.class);</pre>\n+ *     .build(OrderFactory.class));</pre>\n  * </pre>\n  *\n  * <h3>Using the factory</h3>",
      "parent_sha": "173d733b3becc0f24751cd387a1b97d09732b41e"
    }
  },
  {
    "oid": "2bbf0a39956ef237061f9ee3197300d9876ae238",
    "message": "This CL adds @SuppressWarnings(\"inject-constructors\") to classes that have multiple injectable constructors.\n\nReasoning:\nI am rolling out an Annotation Processor check that fails at compile-time if you have multiple injectable constructors for a single class as this is not supported by Guice.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=128986989",
    "date": "2016-08-29T20:39:55Z",
    "url": "https://github.com/google/guice/commit/2bbf0a39956ef237061f9ee3197300d9876ae238",
    "details": {
      "sha": "83c242874bfcf16ce581ea43cdc9d3ef45572297",
      "filename": "core/test/com/google/inject/BindingTest.java",
      "status": "modified",
      "additions": 6,
      "deletions": 3,
      "changes": 9,
      "blob_url": "https://github.com/google/guice/blob/2bbf0a39956ef237061f9ee3197300d9876ae238/core%2Ftest%2Fcom%2Fgoogle%2Finject%2FBindingTest.java",
      "raw_url": "https://github.com/google/guice/raw/2bbf0a39956ef237061f9ee3197300d9876ae238/core%2Ftest%2Fcom%2Fgoogle%2Finject%2FBindingTest.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Ftest%2Fcom%2Fgoogle%2Finject%2FBindingTest.java?ref=2bbf0a39956ef237061f9ee3197300d9876ae238",
      "patch": "@@ -19,7 +19,6 @@\n import static com.google.inject.Asserts.assertContains;\n import static com.google.inject.name.Names.named;\n \n-import com.google.common.base.Throwables;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Sets;\n import com.google.common.util.concurrent.Runnables;\n@@ -222,9 +221,13 @@ public void testTooManyConstructors() {\n     }\n   }\n \n+  @SuppressWarnings(\"inject-constructors\")\n   static class TooManyConstructors {\n-    @Inject TooManyConstructors(Injector i) {}\n-    @Inject TooManyConstructors() {}\n+    @Inject\n+    TooManyConstructors(Injector i) {}\n+\n+    @Inject\n+    TooManyConstructors() {}\n   }\n \n   public void testToConstructorBinding() throws NoSuchMethodException {",
      "parent_sha": "113684b9d9442677317dd0396d2e1b3aa7ac0e4d"
    }
  },
  {
    "oid": "3b4bd86c621668cf5c73cd811176c69cd216308c",
    "message": "Added a testcase that shows issue 125 is fixed.\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@536 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2008-06-25T07:10:53Z",
    "url": "https://github.com/google/guice/commit/3b4bd86c621668cf5c73cd811176c69cd216308c",
    "details": {
      "sha": "e1c73e7b02278627b170650a340a4fb128becfb2",
      "filename": "test/com/google/inject/KeyTest.java",
      "status": "modified",
      "additions": 15,
      "deletions": 5,
      "changes": 20,
      "blob_url": "https://github.com/google/guice/blob/3b4bd86c621668cf5c73cd811176c69cd216308c/test%2Fcom%2Fgoogle%2Finject%2FKeyTest.java",
      "raw_url": "https://github.com/google/guice/raw/3b4bd86c621668cf5c73cd811176c69cd216308c/test%2Fcom%2Fgoogle%2Finject%2FKeyTest.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/test%2Fcom%2Fgoogle%2Finject%2FKeyTest.java?ref=3b4bd86c621668cf5c73cd811176c69cd216308c",
      "patch": "@@ -20,15 +20,16 @@\n import static com.google.inject.Asserts.assertEqualsBothWays;\n import com.google.inject.name.Named;\n import com.google.inject.name.Names;\n-import junit.framework.TestCase;\n-\n import java.io.IOException;\n+import java.lang.annotation.ElementType;\n import java.lang.annotation.Retention;\n import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n import java.util.List;\n import java.util.Map;\n+import junit.framework.TestCase;\n \n /**\n  * @author crazybob@google.com (Bob Lee)\n@@ -37,9 +38,7 @@ public class KeyTest extends TestCase {\n \n   public void foo(List<String> a, List<String> b) {}\n   public void bar(Provider<List<String>> a) {}\n-\n-  @Retention(RUNTIME)\n-  @BindingAnnotation @interface Foo {}\n+  @Foo String baz;\n \n   public void testOfType() {\n     Key<Object> k = Key.get(Object.class, Foo.class);\n@@ -130,5 +129,16 @@ public void testSerialization() throws IOException {\n     assertEqualWhenReserialized(new Key<List<B[]>>() {});\n   }\n \n+  public void testEqualityOfAnnotationTypesAndInstances() throws NoSuchFieldException {\n+    Foo instance = getClass().getDeclaredField(\"baz\").getAnnotation(Foo.class);\n+    Key<String> keyWithInstance = Key.get(String.class, instance);\n+    Key<String> keyWithLiteral = Key.get(String.class, Foo.class);\n+    assertEqualsBothWays(keyWithInstance, keyWithLiteral);\n+  }\n+\n   interface B {}\n+\n+  @Retention(RUNTIME)\n+  @Target({ ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD })\n+  @BindingAnnotation @interface Foo {}\n }",
      "parent_sha": "2e1c91bbb9c045010c91bbfe88a9e5dce0a44313"
    }
  },
  {
    "oid": "73462e771b986fff86987d98918172327dba992f",
    "message": "update @since 5.0 -> @since 4.1",
    "date": "2016-06-17T17:43:51Z",
    "url": "https://github.com/google/guice/commit/73462e771b986fff86987d98918172327dba992f",
    "details": {
      "sha": "d378f7a854df250315af9c58c22a1bd9a8d48e35",
      "filename": "extensions/servlet/src/com/google/inject/servlet/ServletModule.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/google/guice/blob/73462e771b986fff86987d98918172327dba992f/extensions%2Fservlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletModule.java",
      "raw_url": "https://github.com/google/guice/raw/73462e771b986fff86987d98918172327dba992f/extensions%2Fservlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletModule.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fservlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletModule.java?ref=73462e771b986fff86987d98918172327dba992f",
      "patch": "@@ -256,7 +256,7 @@ protected final FilterKeyBindingBuilder filter(String urlPattern, String... more\n \n   /**\n    * @param urlPatterns Any Servlet-style patterns. examples: /*, /html/*, *.html, etc.\n-   * @since 5.0\n+   * @since 4.1\n    */\n   protected final FilterKeyBindingBuilder filter(Iterable<String> urlPatterns) {\n     return getFiltersModuleBuilder().filter(ImmutableList.copyOf(urlPatterns));\n@@ -273,7 +273,7 @@ protected final FilterKeyBindingBuilder filterRegex(String regex, String... rege\n \n   /**\n    * @param regexes Any Java-style regular expressions.\n-   * @since 5.0\n+   * @since 4.1\n    */\n   protected final FilterKeyBindingBuilder filterRegex(Iterable<String> regexes) {\n     return getFiltersModuleBuilder().filterRegex(ImmutableList.copyOf(regexes));\n@@ -290,7 +290,7 @@ protected final ServletKeyBindingBuilder serve(String urlPattern, String... more\n \n   /**\n    * @param urlPatterns Any Servlet-style patterns. examples: /*, /html/*, *.html, etc.\n-   * @since 5.0\n+   * @since 4.1\n    */\n   protected final ServletKeyBindingBuilder serve(Iterable<String> urlPatterns) {\n     return getServletModuleBuilder().serve(ImmutableList.copyOf(urlPatterns));\n@@ -307,7 +307,7 @@ protected final ServletKeyBindingBuilder serveRegex(String regex, String... rege\n \n   /**\n    * @param regexes Any Java-style regular expressions.\n-   * @since 5.0\n+   * @since 4.1\n    */\n   protected final ServletKeyBindingBuilder serveRegex(Iterable<String> regexes) {\n     return getServletModuleBuilder().serveRegex(ImmutableList.copyOf(regexes));",
      "parent_sha": "01e417a6e11047ac1d86c9907184c2ad8a1f198f"
    }
  },
  {
    "oid": "9b55062ddd3cc9d81517e24bbcd8db5d514cae37",
    "message": "Fixed - TODO(cgruber): Use com.google.common.testing.GcFinalization and a countdown latch to un-flake.",
    "date": "2016-01-17T00:06:40Z",
    "url": "https://github.com/google/guice/commit/9b55062ddd3cc9d81517e24bbcd8db5d514cae37",
    "details": {
      "sha": "316a48454eb50c1a6153784987a299c10085e58f",
      "filename": "core/test/com/googlecode/guice/BytecodeGenTest.java",
      "status": "modified",
      "additions": 7,
      "deletions": 21,
      "changes": 28,
      "blob_url": "https://github.com/google/guice/blob/9b55062ddd3cc9d81517e24bbcd8db5d514cae37/core%2Ftest%2Fcom%2Fgooglecode%2Fguice%2FBytecodeGenTest.java",
      "raw_url": "https://github.com/google/guice/raw/9b55062ddd3cc9d81517e24bbcd8db5d514cae37/core%2Ftest%2Fcom%2Fgooglecode%2Fguice%2FBytecodeGenTest.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Ftest%2Fcom%2Fgooglecode%2Fguice%2FBytecodeGenTest.java?ref=9b55062ddd3cc9d81517e24bbcd8db5d514cae37",
      "patch": "@@ -18,6 +18,7 @@\n \n import static com.google.inject.matcher.Matchers.any;\n \n+import com.google.common.testing.GcFinalization;\n import com.google.inject.AbstractModule;\n import com.google.inject.Binder;\n import com.google.inject.Guice;\n@@ -218,39 +219,24 @@ public void configure(Binder binder) {\n     }\n   }\n \n-  public void testProxyClassUnloading() {\n+  private WeakReference<Class<?>> getWeakReference() {\n     Object testObject = Guice.createInjector(interceptorModule, testModule)\n         .getInstance(proxyTestClass);\n     assertNotNull(testObject.getClass().getClassLoader());\n     assertNotSame(testObject.getClass().getClassLoader(), systemClassLoader);\n \n     // take a weak reference to the generated proxy class\n-    Reference<Class<?>> clazzRef = new WeakReference<Class<?>>(testObject.getClass());\n+    WeakReference<Class<?>> clazzRef = new WeakReference<Class<?>>(testObject.getClass());\n \n     assertNotNull(clazzRef.get());\n \n     // null the proxy\n     testObject = null;\n+    return clazzRef;\n+  }\n \n-    /*\n-     * this should be enough to queue the weak reference\n-     * unless something is holding onto it accidentally.\n-     */\n-    final int MAX_COUNT = 100;\n-    String[] buf;\n-    System.gc();\n-    //TODO(cgruber): Use com.google.common.testing.GcFinalization and a countdown latch to un-flake.\n-    for (int count = 0 ; clazzRef.get() != null ; count++) {\n-      buf = new String[8 * 1024 * 1024];\n-      buf = null;\n-      System.gc();\n-      assertTrue(\"Timeout waiting for class to be unloaded.  This may be a flaky result.\",\n-          count <= MAX_COUNT);\n-    }\n-\n-    // This test could be somewhat flaky when the GC isn't working.\n-    // If it fails, run the test again to make sure it's failing reliably.\n-    assertNull(\"Proxy class was not unloaded.\", clazzRef.get());\n+  public void testProxyClassUnloading() {\n+    GcFinalization.awaitClear(getWeakReference());\n   }\n \n   public void testProxyingPackagePrivateMethods() {",
      "parent_sha": "2e620fa57440c97815ede15da244631b006c5446"
    }
  },
  {
    "oid": "9be698db4a8fa560cfae23795d629b018ad009cf",
    "message": "Minor optimizations to InternalContext\n* use ArrayList.removeRange to pop the context, this allows us to elide range\nchecks.\n* Don't eagerly allocate a Dependency object for the pushState(Key<?>,Object)\nmethod, instead allocate one when constructing the DependencyChain.\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=85562648",
    "date": "2015-02-24T23:27:58Z",
    "url": "https://github.com/google/guice/commit/9be698db4a8fa560cfae23795d629b018ad009cf",
    "details": {
      "sha": "6a6f7efcaabec94235077fe00f2c7f5244e6e959",
      "filename": "core/src/com/google/inject/internal/InternalContext.java",
      "status": "modified",
      "additions": 21,
      "deletions": 9,
      "changes": 30,
      "blob_url": "https://github.com/google/guice/blob/9be698db4a8fa560cfae23795d629b018ad009cf/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInternalContext.java",
      "raw_url": "https://github.com/google/guice/raw/9be698db4a8fa560cfae23795d629b018ad009cf/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInternalContext.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInternalContext.java?ref=9be698db4a8fa560cfae23795d629b018ad009cf",
      "patch": "@@ -43,11 +43,11 @@ final class InternalContext {\n   /**\n    * Keeps track of the hierarchy of types needed during injection.\n    *\n-   * <p>This is a pairwise combination of dependencies and sources, with dependencies on even\n-   * indices, and sources on odd indices. This structure is to avoid the memory overhead of\n+   * <p>This is a pairwise combination of dependencies and sources, with dependencies or keys on\n+   * even indices, and sources on odd indices. This structure is to avoid the memory overhead of\n    * DependencyAndSource objects, which can add to several tens of megabytes in large applications.\n    */\n-  private final List<Object> state = Lists.newArrayList();\n+  private final DependencyStack state = new DependencyStack();\n \n   @SuppressWarnings(\"unchecked\")\n   public <T> ConstructionContext<T> getConstructionContext(Object key) {\n@@ -75,29 +75,41 @@ public Dependency<?> pushDependency(Dependency<?> dependency, Object source) {\n   \n   /** Pops the current state & sets the new dependency. */\n   public void popStateAndSetDependency(Dependency<?> newDependency) {\n-    popState();\n+    state.pop();\n     this.dependency = newDependency;\n   }\n   \n   /** Adds to the state without setting the dependency. */\n   public void pushState(Key<?> key, Object source) {\n-    state.add(key == null ? null : Dependency.get(key));\n+    state.add(key);\n     state.add(source);\n   }\n   \n   /** Pops from the state without setting a dependency. */\n   public void popState() {\n-    state.remove(state.size() - 1);\n-    state.remove(state.size() - 1);\n+    state.pop();\n   }\n   \n   /** Returns the current dependency chain (all the state). */\n   public List<DependencyAndSource> getDependencyChain() {\n     ImmutableList.Builder<DependencyAndSource> builder = ImmutableList.builder();\n     for (int i = 0; i < state.size(); i += 2) {\n-      builder.add(new DependencyAndSource(\n-          (Dependency<?>) state.get(i), state.get(i + 1)));\n+      Object evenEntry = state.get(i);\n+      Dependency<?> dependency;\n+      if (evenEntry instanceof Key) {\n+        dependency = Dependency.get((Key<?>) evenEntry);\n+      } else {\n+        dependency = (Dependency<?>) evenEntry;\n+      }\n+      builder.add(new DependencyAndSource(dependency, state.get(i + 1)));\n     }\n     return builder.build();\n   }\n+\n+  private static final class DependencyStack extends ArrayList<Object> {\n+    void pop() {\n+      int sz = size();\n+      removeRange(sz - 2, sz);\n+    }\n+  }\n }",
      "parent_sha": "7ddc816ddc30f328690193be6e70a476a71899e7"
    }
  },
  {
    "oid": "b19efe8aeb94b07f79064d3978109f712da9d6c7",
    "message": "Replace constants (static final CONSTANT_CASE) declaration type which use the general collection interface (e.g. List) with an immutable type (e.g. ImmutableList).\n\nFor constant field declarations, you should use the immutable type (such as ImmutableList) instead of the general collection interface type (such as List). This communicates to your callers important semantic guarantees.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=149657771",
    "date": "2017-03-21T19:30:11Z",
    "url": "https://github.com/google/guice/commit/b19efe8aeb94b07f79064d3978109f712da9d6c7",
    "details": {
      "sha": "0e000dd9daf831ab929d3742b75f6ceba7d1d78e",
      "filename": "core/src/com/google/inject/internal/ProvisionListenerCallbackStore.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/google/guice/blob/b19efe8aeb94b07f79064d3978109f712da9d6c7/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FProvisionListenerCallbackStore.java",
      "raw_url": "https://github.com/google/guice/raw/b19efe8aeb94b07f79064d3978109f712da9d6c7/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FProvisionListenerCallbackStore.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FProvisionListenerCallbackStore.java?ref=b19efe8aeb94b07f79064d3978109f712da9d6c7",
      "patch": "@@ -29,7 +29,6 @@\n import com.google.inject.spi.ProvisionListener;\n import com.google.inject.spi.ProvisionListenerBinding;\n import java.util.List;\n-import java.util.Set;\n import java.util.logging.Logger;\n \n /**\n@@ -41,7 +40,7 @@ final class ProvisionListenerCallbackStore {\n \n   // TODO(sameb): Consider exposing this in the API somehow?  Maybe?\n   // Lots of code often want to skip over the internal stuffs.\n-  private static final Set<Key<?>> INTERNAL_BINDINGS =\n+  private static final ImmutableSet<Key<?>> INTERNAL_BINDINGS =\n       ImmutableSet.of(Key.get(Injector.class), Key.get(Stage.class), Key.get(Logger.class));\n \n   private final ImmutableList<ProvisionListenerBinding> listenerBindings;",
      "parent_sha": "bf08e9a957cc4997824cd33cb2ca5f9e33ac6d32"
    }
  },
  {
    "oid": "845fc0e940e320cd177ed4a4f3543c58d6b19283",
    "message": "fix @since version.\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@1369 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2010-11-11T13:15:15Z",
    "url": "https://github.com/google/guice/commit/845fc0e940e320cd177ed4a4f3543c58d6b19283",
    "details": {
      "sha": "057e0e97e816d2093333f117dcf3c8448bd65cb0",
      "filename": "extensions/servlet/src/com/google/inject/servlet/ServletModule.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/845fc0e940e320cd177ed4a4f3543c58d6b19283/extensions%2Fservlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletModule.java",
      "raw_url": "https://github.com/google/guice/raw/845fc0e940e320cd177ed4a4f3543c58d6b19283/extensions%2Fservlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletModule.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fservlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletModule.java?ref=845fc0e940e320cd177ed4a4f3543c58d6b19283",
      "patch": "@@ -269,7 +269,7 @@ protected final ServletKeyBindingBuilder serveRegex(String regex, String... rege\n    * This method only works if you are using the {@linkplain GuiceServletContextListener} to\n    * create your injector. Otherwise, it returns null.\n    * @return The current servlet context.\n-   * @since 2.1\n+   * @since 3.0\n    */\n   protected final ServletContext getServletContext() {\n     return GuiceFilter.getServletContext();",
      "parent_sha": "a102c17638ec586de3d6930c8ef794c751d157d6"
    }
  },
  {
    "oid": "953aa44a5584db1296d1dcace9a7bc9388b40557",
    "message": "Make it possible to inject constant instances\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@6 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2006-11-22T23:59:40Z",
    "url": "https://github.com/google/guice/commit/953aa44a5584db1296d1dcace9a7bc9388b40557",
    "details": {
      "sha": "5aca1555b4578eeb6dbc9095113ff0bade141b6c",
      "filename": "src/com/google/inject/ContainerBuilder.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/953aa44a5584db1296d1dcace9a7bc9388b40557/src%2Fcom%2Fgoogle%2Finject%2FContainerBuilder.java",
      "raw_url": "https://github.com/google/guice/raw/953aa44a5584db1296d1dcace9a7bc9388b40557/src%2Fcom%2Fgoogle%2Finject%2FContainerBuilder.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/src%2Fcom%2Fgoogle%2Finject%2FContainerBuilder.java?ref=953aa44a5584db1296d1dcace9a7bc9388b40557",
      "patch": "@@ -443,7 +443,7 @@ public <E extends Enum<E>> ContainerBuilder constant(String name, E value) {\n   /**\n    * Maps a constant value to the given type and name.\n    */\n-  private <T> ContainerBuilder constant(final Class<T> type, final String name,\n+  public <T> ContainerBuilder constant(final Class<T> type, final String name,\n       final T value) {\n     InternalFactory<T> factory = new ConstantFactory<T>(value);\n     return factory(Key.newInstance(type, name), factory, Scope.DEFAULT);",
      "parent_sha": "07e4182e4099498b1c4735c26c332342e3480e49"
    }
  },
  {
    "oid": "5058704d372b3a5bd68c2a8c80ad870a9e282c62",
    "message": "Stop using reflection to access MethodHandle MethodHandles.Lookups.  Continue using reflection to access the private constructor for MethodHandles.Lookups.  See https://github.com/google/guice/issues/904 for more information on why we need that particular bit of reflection.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=238113953",
    "date": "2019-04-08T13:59:12Z",
    "url": "https://github.com/google/guice/commit/5058704d372b3a5bd68c2a8c80ad870a9e282c62",
    "details": {
      "sha": "4022507b8bd434c69d4ac6dbd42a37e891d98887",
      "filename": "extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java",
      "status": "modified",
      "additions": 35,
      "deletions": 79,
      "changes": 114,
      "blob_url": "https://github.com/google/guice/blob/5058704d372b3a5bd68c2a8c80ad870a9e282c62/extensions%2Fassistedinject%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fassistedinject%2FFactoryProvider2.java",
      "raw_url": "https://github.com/google/guice/raw/5058704d372b3a5bd68c2a8c80ad870a9e282c62/extensions%2Fassistedinject%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fassistedinject%2FFactoryProvider2.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fassistedinject%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fassistedinject%2FFactoryProvider2.java?ref=5058704d372b3a5bd68c2a8c80ad870a9e282c62",
      "patch": "@@ -57,9 +57,10 @@\n import com.google.inject.spi.Toolable;\n import com.google.inject.util.Providers;\n import java.lang.annotation.Annotation;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.InvocationHandler;\n-import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n import java.lang.reflect.Proxy;\n@@ -209,7 +210,7 @@ public TypeLiteral<?> getImplementationType() {\n   private final ImmutableMap<Method, AssistData> assistDataByMethod;\n \n   /** Mapping from method to method handle, for generated default methods. */\n-  private final ImmutableMap<Method, MethodHandleWrapper> methodHandleByMethod;\n+  private final ImmutableMap<Method, MethodHandle> methodHandleByMethod;\n \n   /** the hosting injector, or null if we haven't been initialized yet */\n   private Injector injector;\n@@ -362,11 +363,10 @@ public TypeLiteral<?> getImplementationType() {\n       // work.  If that doesn't work, fallback to trying to find compatible method\n       // signatures.\n       Map<Method, AssistData> dataSoFar = assistDataBuilder.build();\n-      ImmutableMap.Builder<Method, MethodHandleWrapper> methodHandleBuilder =\n-          ImmutableMap.builder();\n+      ImmutableMap.Builder<Method, MethodHandle> methodHandleBuilder = ImmutableMap.builder();\n       for (Map.Entry<String, Method> entry : defaultMethods.entries()) {\n         Method defaultMethod = entry.getValue();\n-        MethodHandleWrapper handle = MethodHandleWrapper.create(defaultMethod, factory);\n+        MethodHandle handle = createMethodHandle(defaultMethod, factory);\n         if (handle != null) {\n           methodHandleBuilder.put(defaultMethod, handle);\n         } else {\n@@ -392,7 +392,8 @@ public TypeLiteral<?> getImplementationType() {\n         }\n       }\n \n-      // If we generated any errors (from finding matching constructors, for instance), throw an exception.\n+      // If we generated any errors (from finding matching constructors, for instance), throw an\n+      // exception.\n       if (errors.hasErrors()) {\n         throw errors.toException();\n       }\n@@ -765,7 +766,8 @@ protected void configure() {\n             int p = 0;\n             if (!data.optimized) {\n               for (Key<?> paramKey : data.paramTypes) {\n-                // Wrap in a Provider to cover null, and to prevent Guice from injecting the parameter\n+                // Wrap in a Provider to cover null, and to prevent Guice from injecting the\n+                // parameter\n                 binder.bind((Key) paramKey).toProvider(Providers.of(args[p++]));\n               }\n             } else {\n@@ -895,82 +897,36 @@ protected Object initialValue() {\n     }\n   }\n \n-  /** Wrapper around MethodHandles/MethodHandle, so we can compile+run on java6. */\n-  private static class MethodHandleWrapper {\n-    static final int ALL_MODES =\n-        Modifier.PRIVATE | Modifier.STATIC /* package */ | Modifier.PUBLIC | Modifier.PROTECTED;\n-\n-    static final Method unreflectSpecial;\n-    static final Method bindTo;\n-    static final Method invokeWithArguments;\n-    static final Constructor<?> lookupCxtor;\n-    static final boolean valid;\n-\n-    static {\n-      Method unreflectSpecialTmp = null;\n-      Method bindToTmp = null;\n-      Method invokeWithArgumentsTmp = null;\n-      boolean validTmp = false;\n-      Constructor<?> lookupCxtorTmp = null;\n-      try {\n-        Class<?> lookupClass = Class.forName(\"java.lang.invoke.MethodHandles$Lookup\");\n-        unreflectSpecialTmp = lookupClass.getMethod(\"unreflectSpecial\", Method.class, Class.class);\n-        Class<?> methodHandleClass = Class.forName(\"java.lang.invoke.MethodHandle\");\n-        bindToTmp = methodHandleClass.getMethod(\"bindTo\", Object.class);\n-        invokeWithArgumentsTmp = methodHandleClass.getMethod(\"invokeWithArguments\", Object[].class);\n-        lookupCxtorTmp = lookupClass.getDeclaredConstructor(Class.class, int.class);\n-        lookupCxtorTmp.setAccessible(true);\n-        validTmp = true;\n-      } catch (Exception invalid) {\n-        // Ignore the exception, store the values & exit early in create(..) if invalid.\n-      }\n-\n-      // Store refs to later.\n-      valid = validTmp;\n-      unreflectSpecial = unreflectSpecialTmp;\n-      bindTo = bindToTmp;\n-      invokeWithArguments = invokeWithArgumentsTmp;\n-      lookupCxtor = lookupCxtorTmp;\n-    }\n+  // Note: this isn't a public API, but we need to use it in order to call default methods on (or\n+  // with) non-public types.  If it doesn't exist, the code falls back to a less precise check.\n+  private static final Constructor<MethodHandles.Lookup> methodHandlesLookupCxtor =\n+      findMethodHandlesLookupCxtor();\n \n-    static MethodHandleWrapper create(Method method, Object proxy) {\n-      if (!valid) {\n-        return null;\n-      }\n-      try {\n-        Class<?> declaringClass = method.getDeclaringClass();\n-        // Note: this isn't a public API, but we need to use it in order to call default methods.\n-        Object lookup = lookupCxtor.newInstance(declaringClass, ALL_MODES);\n-        method.setAccessible(true);\n-        // These are part of the public API, but we use reflection since we run on java6\n-        // and they were introduced in java7.\n-        lookup = unreflectSpecial.invoke(lookup, method, declaringClass);\n-        Object handle = bindTo.invoke(lookup, proxy);\n-        return new MethodHandleWrapper(handle);\n-      } catch (InvocationTargetException ite) {\n-        return null;\n-      } catch (IllegalAccessException iae) {\n-        return null;\n-      } catch (InstantiationException ie) {\n-        return null;\n-      }\n-    }\n-\n-    final Object handle;\n-\n-    MethodHandleWrapper(Object handle) {\n-      this.handle = handle;\n+  private static Constructor<MethodHandles.Lookup> findMethodHandlesLookupCxtor() {\n+    try {\n+      Constructor<MethodHandles.Lookup> cxtor =\n+          MethodHandles.Lookup.class.getDeclaredConstructor(Class.class, int.class);\n+      cxtor.setAccessible(true);\n+      return cxtor;\n+    } catch (ReflectiveOperationException ignored) {\n+      // Ignore, the code falls back to a less-precise check if we can't create method handles.\n+      return null;\n     }\n+  }\n \n-    Object invokeWithArguments(Object[] args) throws Exception {\n-      // We must cast the args to an object so the Object[] is the first param,\n-      // as opposed to each individual varargs param.\n-      return invokeWithArguments.invoke(handle, (Object) args);\n+  private static MethodHandle createMethodHandle(Method method, Object proxy) {\n+    if (methodHandlesLookupCxtor == null) {\n+      return null;\n     }\n-\n-    @Override\n-    public String toString() {\n-      return handle.toString();\n+    Class<?> declaringClass = method.getDeclaringClass();\n+    int allModes =\n+        Modifier.PRIVATE | Modifier.STATIC /* package */ | Modifier.PUBLIC | Modifier.PROTECTED;\n+    try {\n+      MethodHandles.Lookup lookup = methodHandlesLookupCxtor.newInstance(declaringClass, allModes);\n+      method.setAccessible(true);\n+      return lookup.unreflectSpecial(method, declaringClass).bindTo(proxy);\n+    } catch (ReflectiveOperationException roe) {\n+      throw new RuntimeException(\"Unable to access method: \" + method, roe);\n     }\n   }\n }",
      "parent_sha": "e27d4c0e08b9f427085a2f00df9af9494288192d"
    }
  },
  {
    "oid": "39634cf94fed60c5dc1180724357fe8408c95fee",
    "message": "Adding the METHOD target to the @ScopeAnnotation meta-annotation\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@1012 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2009-06-11T06:48:54Z",
    "url": "https://github.com/google/guice/commit/39634cf94fed60c5dc1180724357fe8408c95fee",
    "details": {
      "sha": "6a3084bd9bfb43ed70041af7983f3023dca0b05b",
      "filename": "src/com/google/inject/ScopeAnnotation.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/39634cf94fed60c5dc1180724357fe8408c95fee/src%2Fcom%2Fgoogle%2Finject%2FScopeAnnotation.java",
      "raw_url": "https://github.com/google/guice/raw/39634cf94fed60c5dc1180724357fe8408c95fee/src%2Fcom%2Fgoogle%2Finject%2FScopeAnnotation.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/src%2Fcom%2Fgoogle%2Finject%2FScopeAnnotation.java?ref=39634cf94fed60c5dc1180724357fe8408c95fee",
      "patch": "@@ -28,7 +28,7 @@\n  *\n  * <pre>\n  *   {@code @}Retention(RUNTIME)\n- *   {@code @}Target(TYPE)\n+ *   {@code @}Target(TYPE, METHOD)\n  *   {@code @}ScopeAnnotation\n  *   public {@code @}interface SessionScoped {}\n  * </pre>",
      "parent_sha": "7eb1d45e7b4af4c3e27a0c3a3dc9eddbfe818b1c"
    }
  },
  {
    "oid": "e2fbca7c9334cba209b5d4f94a4bddbf02a266e3",
    "message": "Adjust inappropriate suppression before turning on JavaxInjectOnAbstractMethod\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=133760795",
    "date": "2016-10-20T16:43:22Z",
    "url": "https://github.com/google/guice/commit/e2fbca7c9334cba209b5d4f94a4bddbf02a266e3",
    "details": {
      "sha": "1610b05fa566f1cbe11451ff4fefff152bf67f1c",
      "filename": "core/test/com/googlecode/guice/Jsr330Test.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/e2fbca7c9334cba209b5d4f94a4bddbf02a266e3/core%2Ftest%2Fcom%2Fgooglecode%2Fguice%2FJsr330Test.java",
      "raw_url": "https://github.com/google/guice/raw/e2fbca7c9334cba209b5d4f94a4bddbf02a266e3/core%2Ftest%2Fcom%2Fgooglecode%2Fguice%2FJsr330Test.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Ftest%2Fcom%2Fgooglecode%2Fguice%2FJsr330Test.java?ref=e2fbca7c9334cba209b5d4f94a4bddbf02a266e3",
      "patch": "@@ -508,7 +508,7 @@ static class L {\n   }\n \n   abstract static class AbstractM {\n-    @SuppressWarnings(\"InjectJavaxInjectOnAbstractMethod\")\n+    @SuppressWarnings(\"JavaxInjectOnAbstractMethod\")\n     @Inject\n     abstract void setB(B b);\n   }",
      "parent_sha": "78a2063bbf401e033fff3a6a4fabc34cdfb3b151"
    }
  },
  {
    "oid": "6c052959343d41856f1597949058bff48ba3e2f7",
    "message": "Fixing NullableInjectionPointTest by changing the expected behaviours of the tests. We now forbid bind(...).toInstance(null) but allow Injector.getInstance() to return null.\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@437 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2008-04-21T00:36:18Z",
    "url": "https://github.com/google/guice/commit/6c052959343d41856f1597949058bff48ba3e2f7",
    "details": {
      "sha": "fb0bd61d7f19a7cbc9bce6db81566f69e1701ff0",
      "filename": "test/com/google/inject/NullableInjectionPointTest.java",
      "status": "modified",
      "additions": 13,
      "deletions": 20,
      "changes": 33,
      "blob_url": "https://github.com/google/guice/blob/6c052959343d41856f1597949058bff48ba3e2f7/test%2Fcom%2Fgoogle%2Finject%2FNullableInjectionPointTest.java",
      "raw_url": "https://github.com/google/guice/raw/6c052959343d41856f1597949058bff48ba3e2f7/test%2Fcom%2Fgoogle%2Finject%2FNullableInjectionPointTest.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/test%2Fcom%2Fgoogle%2Finject%2FNullableInjectionPointTest.java?ref=6c052959343d41856f1597949058bff48ba3e2f7",
      "patch": "@@ -47,18 +47,11 @@ public void testInjectNullIntoNotNullableField() {\n   }\n \n   /**\n-   * We haven't decided on what the desired behaviour of this test should be...\n+   * Provider.getInstance() is allowed to return null via direct calls to\n+   * getInstance().\n    */\n   public void testGetInstanceOfNull() {\n-    try {\n-      createInjector().getInstance(Foo.class);\n-      fail(\"Getting an instance of null should fail with an error\");\n-    }\n-    catch (ProvisionException expected) {\n-      NullPointerException cause = (NullPointerException)expected.getCause();\n-      assertContains(cause.getMessage(), \"null returned by binding \"\n-          + \"at com.google.inject.NullableInjectionPointTest\");\n-    }\n+    assertNull(createInjector().getInstance(Foo.class));\n   }\n \n   public void testInjectNullIntoNullableConstructor() {\n@@ -96,20 +89,20 @@ public Foo get() {\n    * We haven't decided on what the desired behaviour of this test should be...\n    */\n   public void testBindNullToInstance() {\n-    Injector injector = Guice.createInjector(new AbstractModule() {\n+    Guice.createInjector(new AbstractModule() {\n       protected void configure() {\n-        bind(Foo.class).toInstance(null);\n+        try {\n+          bind(Foo.class).toInstance(null);\n+          fail();\n+        }\n+        catch(NullPointerException expected) {\n+          assertEquals(\"Binding to null instances is not allowed. \"\n+              + \"Use toProvider(Providers.of(null)) if this is your intended behaviour.\", \n+              expected.getMessage());\n+        }\n       }\n     });\n-    assertNull(injector.getInstance(NullableFooField.class).foo);\n \n-    try {\n-      injector.getInstance(FooField.class);\n-    }\n-    catch(ProvisionException expected) {\n-      NullPointerException cause = (NullPointerException)expected.getCause();\n-      assertContains(cause.getMessage(), \"null returned by binding at\");\n-    }\n   }\n \n   public void testBindNullToProvider() {",
      "parent_sha": "5828a2260b77236f0e6d4531609defd04676de23"
    }
  },
  {
    "oid": "fe2c25e66c5163c671759dc0c3629fec005a34af",
    "message": "Adding ElementType.METHOD to play nice with ProviderMethods\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@560 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2008-07-15T01:58:04Z",
    "url": "https://github.com/google/guice/commit/fe2c25e66c5163c671759dc0c3629fec005a34af",
    "details": {
      "sha": "d18a8e8e7190fc1c445c75d8b76e25a41f1b3129",
      "filename": "servlet/src/com/google/inject/servlet/RequestParameters.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/fe2c25e66c5163c671759dc0c3629fec005a34af/servlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FRequestParameters.java",
      "raw_url": "https://github.com/google/guice/raw/fe2c25e66c5163c671759dc0c3629fec005a34af/servlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FRequestParameters.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/servlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FRequestParameters.java?ref=fe2c25e66c5163c671759dc0c3629fec005a34af",
      "patch": "@@ -29,6 +29,6 @@\n  * @author crazybob@google.com (Bob Lee)\n  */\n @Retention(RUNTIME)\n-@Target({ ElementType.FIELD, ElementType.PARAMETER })\n+@Target({ ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD })\n @BindingAnnotation\n public @interface RequestParameters {}",
      "parent_sha": "7bf3e3c905c73fac24613b495b2d42dd84eb837f"
    }
  },
  {
    "oid": "2642dc4f0e01cb45550f8d47cf8ef16b48efb755",
    "message": "Clarify behavior of setBinding().\n\nPrevious comment is ambiguous. It's unclear if OptionalBinder installs bindings or not:\n<p>If setDefault or setBinding are linked to Providers, the Provider may return {@code null}. If it does, the Optional bindings will be absent.\n\nIn fact, bindings are installed (Optional<T> -> Optional.empty()).\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=194848832",
    "date": "2018-05-01T15:53:40Z",
    "url": "https://github.com/google/guice/commit/2642dc4f0e01cb45550f8d47cf8ef16b48efb755",
    "details": {
      "sha": "94b0a1776fcc08685ac0ee099eb427fac94af72b",
      "filename": "core/src/com/google/inject/multibindings/OptionalBinder.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/google/guice/blob/2642dc4f0e01cb45550f8d47cf8ef16b48efb755/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fmultibindings%2FOptionalBinder.java",
      "raw_url": "https://github.com/google/guice/raw/2642dc4f0e01cb45550f8d47cf8ef16b48efb755/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fmultibindings%2FOptionalBinder.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fmultibindings%2FOptionalBinder.java?ref=2642dc4f0e01cb45550f8d47cf8ef16b48efb755",
      "patch": "@@ -30,8 +30,8 @@\n  * roles:\n  *\n  * <ol>\n- * <li>It allows a framework to define an injection point that may or may not be bound by users.\n- * <li>It allows a framework to supply a default value that can be changed by users.\n+ *   <li>It allows a framework to define an injection point that may or may not be bound by users.\n+ *   <li>It allows a framework to supply a default value that can be changed by users.\n  * </ol>\n  *\n  * <p>When an OptionalBinder is added, it will always supply the bindings: {@code Optional<T>} and\n@@ -44,8 +44,8 @@\n  * instantiated in {@code Stage.PRODUCTION}.</b>\n  *\n  * <p>If setDefault or setBinding are linked to Providers, the Provider may return {@code null}. If\n- * it does, the Optional bindings will be absent. Binding setBinding to a Provider that returns null\n- * will not cause OptionalBinder to fall back to the setDefault binding.\n+ * it does, {@code Optional<T>} will be bound to an absent Optional. Binding setBinding to a\n+ * Provider that returns null will not cause OptionalBinder to fall back to the setDefault binding.\n  *\n  * <p>If neither setDefault nor setBinding are called, it will try to link to a user-supplied\n  * binding of the same type. If no binding exists, the optionals will be absent. Otherwise, if a",
      "parent_sha": "c0f89a0a59c466aaaa86581ec0329d21b023ed8a"
    }
  },
  {
    "oid": "cd875c4b918126271252446cf6a852f80526d499",
    "message": "Use ServiceLoader, not ServiceRegistry. In Java 9, ServiceRegistry is restricted to ImageIO SPI types.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=170756352",
    "date": "2018-01-25T16:12:58Z",
    "url": "https://github.com/google/guice/commit/cd875c4b918126271252446cf6a852f80526d499",
    "details": {
      "sha": "5191cdb3b89607c075a45fec8779ccf9c62f0b0d",
      "filename": "core/test/com/googlecode/guice/OSGiContainerTest.java",
      "status": "modified",
      "additions": 3,
      "deletions": 5,
      "changes": 8,
      "blob_url": "https://github.com/google/guice/blob/cd875c4b918126271252446cf6a852f80526d499/core%2Ftest%2Fcom%2Fgooglecode%2Fguice%2FOSGiContainerTest.java",
      "raw_url": "https://github.com/google/guice/raw/cd875c4b918126271252446cf6a852f80526d499/core%2Ftest%2Fcom%2Fgooglecode%2Fguice%2FOSGiContainerTest.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Ftest%2Fcom%2Fgooglecode%2Fguice%2FOSGiContainerTest.java?ref=cd875c4b918126271252446cf6a852f80526d499",
      "patch": "@@ -23,9 +23,8 @@\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.OutputStream;\n-import java.util.Iterator;\n import java.util.Properties;\n-import javax.imageio.spi.ServiceRegistry;\n+import java.util.ServiceLoader;\n import junit.framework.TestCase;\n import org.osgi.framework.BundleContext;\n import org.osgi.framework.launch.Framework;\n@@ -136,9 +135,8 @@ public void testGuiceWorksInOSGiContainer() throws Throwable {\n     properties.setProperty(\"org.osgi.framework.storage.clean\", \"onFirstInit\");\n \n     // test each available OSGi framework in turn\n-    Iterator<FrameworkFactory> f = ServiceRegistry.lookupProviders(FrameworkFactory.class);\n-    while (f.hasNext()) {\n-      Framework framework = f.next().newFramework(properties);\n+    for (FrameworkFactory frameworkFactory : ServiceLoader.load(FrameworkFactory.class)) {\n+      Framework framework = frameworkFactory.newFramework(properties);\n \n       framework.start();\n       BundleContext systemContext = framework.getBundleContext();",
      "parent_sha": "13ca52bc3bfe45522c9dbceccaf9c205ec29733e"
    }
  },
  {
    "oid": "7e5464ef25b98ea8f1988040d3623b93129ff1f4",
    "message": "fix issue 616, thanks for the patch!\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@1590 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2011-10-16T16:38:42Z",
    "url": "https://github.com/google/guice/commit/7e5464ef25b98ea8f1988040d3623b93129ff1f4",
    "details": {
      "sha": "97db6402233c06bc429e7797e7210bc3541bbf1d",
      "filename": "core/src/com/google/inject/spi/ConvertedConstantBinding.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/7e5464ef25b98ea8f1988040d3623b93129ff1f4/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fspi%2FConvertedConstantBinding.java",
      "raw_url": "https://github.com/google/guice/raw/7e5464ef25b98ea8f1988040d3623b93129ff1f4/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fspi%2FConvertedConstantBinding.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fspi%2FConvertedConstantBinding.java?ref=7e5464ef25b98ea8f1988040d3623b93129ff1f4",
      "patch": "@@ -43,7 +43,7 @@ public interface ConvertedConstantBinding<T> extends Binding<T>, HasDependencies\n   TypeConverterBinding getTypeConverterBinding();\n \n   /**\n-   * Returns the key for the source binding. That binding can e retrieved from an injector using\n+   * Returns the key for the source binding. That binding can be retrieved from an injector using\n    * {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.\n    */\n   Key<String> getSourceKey();",
      "parent_sha": "d77a85ab9ec33d45bfaecc08daffcc015a2c1c8b"
    }
  },
  {
    "oid": "136dd75b214b44ee605b08bdd70111d9f3cb41fa",
    "message": "Fixin' a doc typo\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@1035 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2009-06-24T01:31:31Z",
    "url": "https://github.com/google/guice/commit/136dd75b214b44ee605b08bdd70111d9f3cb41fa",
    "details": {
      "sha": "4f4a8ef583bb50d8cab2ba62b116e5e72110eaa2",
      "filename": "extensions/multibindings/src/com/google/inject/multibindings/Multibinder.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/136dd75b214b44ee605b08bdd70111d9f3cb41fa/extensions%2Fmultibindings%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fmultibindings%2FMultibinder.java",
      "raw_url": "https://github.com/google/guice/raw/136dd75b214b44ee605b08bdd70111d9f3cb41fa/extensions%2Fmultibindings%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fmultibindings%2FMultibinder.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fmultibindings%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fmultibindings%2FMultibinder.java?ref=136dd75b214b44ee605b08bdd70111d9f3cb41fa",
      "patch": "@@ -331,7 +331,7 @@ public Set<Dependency<?>> getDependencies() {\n \n   /**\n    * We install the permit duplicates configuration as its own binding, all by itself. This way,\n-   * if only half of a multibinder user's remember to call permitDuplicates(), they're still\n+   * if only one of a multibinder's users remember to call permitDuplicates(), they're still\n    * permitted.\n    */\n   private static class PermitDuplicatesModule extends AbstractModule {",
      "parent_sha": "398017ae4ed96750fa54dc9ce59dc2f974dcf541"
    }
  },
  {
    "oid": "73475a4e89fa60588649da9900ac540e0b8f48d4",
    "message": "A new test that shows the deficiencies of FutureInjector. Now that commands are better integrated, we might be able to solve this more transparently...\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@551 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2008-07-07T08:17:48Z",
    "url": "https://github.com/google/guice/commit/73475a4e89fa60588649da9900ac540e0b8f48d4",
    "details": {
      "sha": "16d92731b32b765e4395bbb7a81313010a68dcd9",
      "filename": "test/com/google/inject/commands/CommandRewriteTest.java",
      "status": "modified",
      "additions": 44,
      "deletions": 3,
      "changes": 47,
      "blob_url": "https://github.com/google/guice/blob/73475a4e89fa60588649da9900ac540e0b8f48d4/test%2Fcom%2Fgoogle%2Finject%2Fcommands%2FCommandRewriteTest.java",
      "raw_url": "https://github.com/google/guice/raw/73475a4e89fa60588649da9900ac540e0b8f48d4/test%2Fcom%2Fgoogle%2Finject%2Fcommands%2FCommandRewriteTest.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/test%2Fcom%2Fgoogle%2Finject%2Fcommands%2FCommandRewriteTest.java?ref=73475a4e89fa60588649da9900ac540e0b8f48d4",
      "patch": "@@ -16,10 +16,17 @@\n \n package com.google.inject.commands;\n \n-import com.google.inject.*;\n-import junit.framework.TestCase;\n-\n+import com.google.inject.AbstractModule;\n+import com.google.inject.Binder;\n+import com.google.inject.Guice;\n+import com.google.inject.Inject;\n+import com.google.inject.Injector;\n+import com.google.inject.Key;\n+import com.google.inject.Module;\n+import com.google.inject.Provider;\n+import com.google.inject.name.Names;\n import java.util.List;\n+import junit.framework.TestCase;\n \n \n /**\n@@ -59,4 +66,38 @@ protected void configure() {\n     assertEquals(\"Pizza\", injector.getInstance(String.class));\n     assertEquals(\"Beer\", injector.getInstance(CharSequence.class));\n   }\n+\n+  public void testGetProviderAvailableAtInjectMembersTime() {\n+    Module module = new AbstractModule() {\n+      public void configure() {\n+        final Provider<String> stringProvider = getProvider(String.class);\n+\n+        bind(String.class).annotatedWith(Names.named(\"2\")).toProvider(new Provider<String>() {\n+          private String value;\n+\n+          @Inject void initialize() {\n+            value = stringProvider.get();\n+          }\n+\n+          public String get() {\n+            return value;\n+          }\n+        });\n+\n+        bind(String.class).toInstance(\"A\");\n+      }\n+    };\n+\n+    // the module works fine normally\n+    Injector injector = Guice.createInjector(module);\n+    assertEquals(\"A\", injector.getInstance(Key.get(String.class, Names.named(\"2\"))));\n+\n+    // and it should also work fine if we rewrite it\n+    FutureInjector futureInjector = new FutureInjector();\n+    List<Command> commands = new CommandRecorder(futureInjector).recordCommands(module);\n+    Module replayed = new CommandReplayer().createModule(commands);\n+    Injector replayedInjector = Guice.createInjector(replayed);\n+    futureInjector.initialize(replayedInjector);\n+    assertEquals(\"A\", replayedInjector.getInstance(Key.get(String.class, Names.named(\"2\"))));\n+  }\n }",
      "parent_sha": "46db36a3269b4f46528470cf70a8d6a04bcc24e4"
    }
  },
  {
    "oid": "4e46009fd32913e4de875a69c5d6725c872f391e",
    "message": "Switch multibinder to use an ImmutableSet instead of a LinkedHashSet\n\nThe prior implementation was based on the theory that presizing the set was\nmore important than the particular implementation.  This of course, is not\ntrue!  LinkedHashSet internally uses a LinkedHashMap so every insertion\nallocates Map.Entry objects even though they are never needed via the Set\ninterface.  ImmutableSet avoids this altogether and also allows us to avoid\nneeding the unmodifiable wrapper.  Overall this saves one allocation per\nmultibinder element and in addition to some fixed overhead.\n\nThe major complication to this design is detecting duplicates.\n\nhttps://caliper.[].com/runs/f43ca9c8-2e69-44ef-af21-513062416fe6,9368e5ae-9401-4581-9b42-d3d0bf7664d4#r:scenario.benchmarkSpec.methodName,run.label\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=133777950",
    "date": "2016-10-20T16:43:22Z",
    "url": "https://github.com/google/guice/commit/4e46009fd32913e4de875a69c5d6725c872f391e",
    "details": {
      "sha": "6ca6819178bfe62ef743568b6ef23bb757764d0f",
      "filename": "core/src/com/google/inject/internal/RealMultibinder.java",
      "status": "modified",
      "additions": 41,
      "deletions": 32,
      "changes": 73,
      "blob_url": "https://github.com/google/guice/blob/4e46009fd32913e4de875a69c5d6725c872f391e/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FRealMultibinder.java",
      "raw_url": "https://github.com/google/guice/raw/4e46009fd32913e4de875a69c5d6725c872f391e/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FRealMultibinder.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FRealMultibinder.java?ref=4e46009fd32913e4de875a69c5d6725c872f391e",
      "patch": "@@ -29,9 +29,6 @@\n import com.google.inject.util.Types;\n import java.lang.reflect.Type;\n import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n \n@@ -190,23 +187,32 @@ protected Set<T> doProvision(Errors errors, InternalContext context, Dependency<\n         // if localInjectors == null, then we have no bindings so return the empty set.\n         return ImmutableSet.of();\n       }\n-      boolean localPermitsDuplicates = permitDuplicates;\n-      int size = localInjectors.length;\n-      LinkedHashSet<T> result = Sets.newLinkedHashSetWithExpectedSize(size);\n-      for (int i = 0; i < size; i++) {\n+      // Ideally we would just add to an ImmutableSet.Builder, but if we did that and there were\n+      // duplicates we wouldn't be able to tell which one was the duplicate.  So to manage this we\n+      // first put everything into an array and then construct the set.  This way if something gets\n+      // dropped we can figure out what it is.\n+      @SuppressWarnings(\"unchecked\")\n+      T[] values = (T[]) new Object[localInjectors.length];\n+      for (int i = 0; i < localInjectors.length; i++) {\n         SingleParameterInjector<T> parameterInjector = localInjectors[i];\n         T newValue = parameterInjector.inject(errors, context);\n         if (newValue == null) {\n-          errors.addMessage(\n-              \"Set injection failed due to null element bound at: %s\", bindings.get(i).getSource());\n-          throw errors.toException();\n-        }\n-        boolean uniqueValue = result.add(newValue);\n-        if (!uniqueValue && !localPermitsDuplicates) {\n-          throw newDuplicateValuesException(bindings, result, bindings.get(i), newValue, errors);\n+          throw newNullEntryException(i, errors);\n         }\n+        values[i] = newValue;\n+      }\n+      ImmutableSet<T> set = ImmutableSet.copyOf(values);\n+      // There are fewer items in the set than the array.  Figure out which one got dropped.\n+      if (!permitDuplicates && set.size() < values.length) {\n+        throw newDuplicateValuesException(set, values, errors);\n       }\n-      return Collections.unmodifiableSet(result);\n+      return set;\n+    }\n+\n+    private ErrorsException newNullEntryException(int i, Errors errors) {\n+      errors.addMessage(\n+          \"Set injection failed due to null element bound at: %s\", bindings.get(i).getSource());\n+      return errors.toException();\n     }\n \n     @SuppressWarnings(\"unchecked\")\n@@ -220,27 +226,30 @@ public <B, V> V acceptExtensionVisitor(\n       }\n     }\n \n-    private static <T> ErrorsException newDuplicateValuesException(\n-        List<Binding<T>> bindings,\n-        LinkedHashSet<T> results,\n-        Binding<T> newBinding,\n-        T newValue,\n-        Errors errors) {\n+    private ErrorsException newDuplicateValuesException(\n+        ImmutableSet<T> set, T[] values, Errors errors) {\n+      // TODO(lukes): consider reporting all duplicate values, the easiest way would be to rebuild\n+      // a new set and detect dupes as we go\n       // Find the duplicate binding\n-      // To do this we take advantage of the fact that results has the same order as bindings,\n-      // so that once we find a matching value in the result set, we know the binding\n-      // for it will have the same index.\n-      Iterator<T> itr = results.iterator();\n-      Binding<T> duplicateBinding = null;\n-      T oldValue = null;\n-      for (int i = 0; itr.hasNext(); i++) {\n-        T current = itr.next();\n-        if (current.equals(newValue)) {\n-          oldValue = current;\n-          duplicateBinding = bindings.get(i);\n+      // To do this we take advantage of the fact that set, values and bindings all have the same\n+      // ordering for a non-empty prefix of the set.\n+      // First we scan for the first item dropped from the set.\n+      int newBindingIndex = 0;\n+      for (T item : set) {\n+        if (item != values[newBindingIndex]) {\n           break;\n         }\n+        newBindingIndex++;\n       }\n+      // once we exit the loop newBindingIndex will point at the first item in values that was\n+      // dropped.\n+\n+      Binding<T> newBinding = bindings.get(newBindingIndex);\n+      T newValue = values[newBindingIndex];\n+      // Now we scan again to find the index of the value, we are guaranteed to find it.\n+      int oldBindingIndex = set.asList().indexOf(newValue);\n+      T oldValue = values[oldBindingIndex];\n+      Binding<T> duplicateBinding = bindings.get(oldBindingIndex);\n       String oldString = oldValue.toString();\n       String newString = newValue.toString();\n       if (Objects.equal(oldString, newString)) {",
      "parent_sha": "e2fbca7c9334cba209b5d4f94a4bddbf02a266e3"
    }
  },
  {
    "oid": "c463a625f0f6313196072a5faf62522722b39943",
    "message": "only assign JAVA_OPTIONAL_CLASS if all java.util.Optional reflection succeeded\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=130701512",
    "date": "2016-08-29T20:42:16Z",
    "url": "https://github.com/google/guice/commit/c463a625f0f6313196072a5faf62522722b39943",
    "details": {
      "sha": "4d4828215094a99b38581c2eb0f51bac29b89e4c",
      "filename": "core/src/com/google/inject/internal/RealOptionalBinder.java",
      "status": "modified",
      "additions": 6,
      "deletions": 3,
      "changes": 9,
      "blob_url": "https://github.com/google/guice/blob/c463a625f0f6313196072a5faf62522722b39943/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FRealOptionalBinder.java",
      "raw_url": "https://github.com/google/guice/raw/c463a625f0f6313196072a5faf62522722b39943/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FRealOptionalBinder.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FRealOptionalBinder.java?ref=c463a625f0f6313196072a5faf62522722b39943",
      "patch": "@@ -73,19 +73,22 @@ public static <T> RealOptionalBinder<T> newRealOptionalBinder(Binder binder, Key\n     Class<?> optional = null;\n     Object emptyObject = null;\n     Method of = null;\n+    boolean useJavaOptional = false;\n     try {\n       optional = Class.forName(\"java.util.Optional\");\n       emptyObject = optional.getDeclaredMethod(\"empty\").invoke(null);\n       of = optional.getDeclaredMethod(\"of\", Object.class);\n+      // only use optional support if all our reflection succeeded\n+      useJavaOptional = true;\n     } catch (ClassNotFoundException ignored) {\n     } catch (NoSuchMethodException ignored) {\n     } catch (SecurityException ignored) {\n     } catch (IllegalAccessException ignored) {\n     } catch (InvocationTargetException ignored) {\n     }\n-    JAVA_OPTIONAL_CLASS = optional;\n-    JAVA_OPTIONAL_EMPTY = emptyObject;\n-    JAVA_OPTIONAL_OF_METHOD = of;\n+    JAVA_OPTIONAL_CLASS = useJavaOptional ? optional : null;\n+    JAVA_OPTIONAL_EMPTY = useJavaOptional ? emptyObject : null;\n+    JAVA_OPTIONAL_OF_METHOD = useJavaOptional ? of : null;\n   }\n \n   /**",
      "parent_sha": "592dcb251bfff6b2244d487a0db401a1b7562f6b"
    }
  },
  {
    "oid": "33a1b4e7c0b78a3c133d67b4d7754587a9907a1c",
    "message": "Make LinkedBindingImpl constructors package-private to prevent original element source spoofing.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=311781105",
    "date": "2020-05-17T04:10:41Z",
    "url": "https://github.com/google/guice/commit/33a1b4e7c0b78a3c133d67b4d7754587a9907a1c",
    "details": {
      "sha": "1d9573812ee2172067dec4c693e9d237433bf9b1",
      "filename": "core/src/com/google/inject/internal/LinkedBindingImpl.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/google/guice/blob/33a1b4e7c0b78a3c133d67b4d7754587a9907a1c/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FLinkedBindingImpl.java",
      "raw_url": "https://github.com/google/guice/raw/33a1b4e7c0b78a3c133d67b4d7754587a9907a1c/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FLinkedBindingImpl.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FLinkedBindingImpl.java?ref=33a1b4e7c0b78a3c133d67b4d7754587a9907a1c",
      "patch": "@@ -32,7 +32,7 @@ public final class LinkedBindingImpl<T> extends BindingImpl<T>\n \n   final Key<? extends T> targetKey;\n \n-  public LinkedBindingImpl(\n+  LinkedBindingImpl(\n       InjectorImpl injector,\n       Key<T> key,\n       Object source,\n@@ -43,7 +43,7 @@ public LinkedBindingImpl(\n     this.targetKey = targetKey;\n   }\n \n-  public LinkedBindingImpl(Object source, Key<T> key, Scoping scoping, Key<? extends T> targetKey) {\n+  LinkedBindingImpl(Object source, Key<T> key, Scoping scoping, Key<? extends T> targetKey) {\n     super(source, key, scoping);\n     this.targetKey = targetKey;\n   }",
      "parent_sha": "09637a7a491e43a663db5965eba75721a6e9d44b"
    }
  },
  {
    "oid": "c3d8f51da635361ae16911e1b5168dce6de21f8f",
    "message": "Make PrivateModule#binder() non-final to allow binder customization in subclasses. Fixes #1569 & fixes #1525. (The primary use-case for this is to override binder() to always call skipSources, like many AbstractModule impls.)\n\nPiperOrigin-RevId: 525231256",
    "date": "2023-04-18T20:12:34Z",
    "url": "https://github.com/google/guice/commit/c3d8f51da635361ae16911e1b5168dce6de21f8f",
    "details": {
      "sha": "dda674b2cc37bbcd4150df454fa35ed6c7a2d0a5",
      "filename": "core/src/com/google/inject/PrivateModule.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/c3d8f51da635361ae16911e1b5168dce6de21f8f/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2FPrivateModule.java",
      "raw_url": "https://github.com/google/guice/raw/c3d8f51da635361ae16911e1b5168dce6de21f8f/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2FPrivateModule.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2FPrivateModule.java?ref=c3d8f51da635361ae16911e1b5168dce6de21f8f",
      "patch": "@@ -137,7 +137,7 @@ protected final AnnotatedElementBuilder expose(TypeLiteral<?> type) {\n   // everything below is copied from AbstractModule\n \n   /** Returns the current binder. */\n-  protected final PrivateBinder binder() {\n+  protected PrivateBinder binder() {\n     checkState(binder != null, \"The binder can only be used inside configure()\");\n     return binder;\n   }",
      "parent_sha": "22dca18c8ceadf32d3d5ab4994f7cf3776442da3"
    }
  },
  {
    "oid": "64f7e002a59b431b82746241b1bcc214f27ea835",
    "message": "Added missing synchronized.\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@374 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2007-09-11T18:04:26Z",
    "url": "https://github.com/google/guice/commit/64f7e002a59b431b82746241b1bcc214f27ea835",
    "details": {
      "sha": "8aa5bdd675af1e1f5a5ffcf1dd19f22a33e8bc94",
      "filename": "src/com/google/inject/internal/AbstractReferenceCache.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/64f7e002a59b431b82746241b1bcc214f27ea835/src%2Fcom%2Fgoogle%2Finject%2Finternal%2FAbstractReferenceCache.java",
      "raw_url": "https://github.com/google/guice/raw/64f7e002a59b431b82746241b1bcc214f27ea835/src%2Fcom%2Fgoogle%2Finject%2Finternal%2FAbstractReferenceCache.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/src%2Fcom%2Fgoogle%2Finject%2Finternal%2FAbstractReferenceCache.java?ref=64f7e002a59b431b82746241b1bcc214f27ea835",
      "patch": "@@ -144,7 +144,7 @@ Thread winningThread() {\n       return winningThread;\n     }\n \n-    V get() {\n+    synchronized V get() {\n       if (!set) {\n         boolean interrupted = waitUntilSet();\n ",
      "parent_sha": "ddd538da327a9bf8554b9fb04fde840efb5667db"
    }
  },
  {
    "oid": "1a2adcb262c3f031341965bf48e7b43a26385ab9",
    "message": "remove additional API for overriding a PrivateModule and instead fold the functionality into the existing methods.\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@1201 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2010-08-02T00:58:02Z",
    "url": "https://github.com/google/guice/commit/1a2adcb262c3f031341965bf48e7b43a26385ab9",
    "details": {
      "sha": "b6e52cbe6d21a7665ee2783534df274c3386d2c3",
      "filename": "src/com/google/inject/util/Modules.java",
      "status": "modified",
      "additions": 33,
      "deletions": 74,
      "changes": 107,
      "blob_url": "https://github.com/google/guice/blob/1a2adcb262c3f031341965bf48e7b43a26385ab9/src%2Fcom%2Fgoogle%2Finject%2Futil%2FModules.java",
      "raw_url": "https://github.com/google/guice/raw/1a2adcb262c3f031341965bf48e7b43a26385ab9/src%2Fcom%2Fgoogle%2Finject%2Futil%2FModules.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/src%2Fcom%2Fgoogle%2Finject%2Futil%2FModules.java?ref=1a2adcb262c3f031341965bf48e7b43a26385ab9",
      "patch": "@@ -54,30 +54,14 @@ private Modules() {}\n   public static final Module EMPTY_MODULE = new Module() {\n     public void configure(Binder binder) {}\n   };\n-  \n-  /**\n-   * Returns a builder that creates a module that overlays override modules over the given\n-   * PrivateModule. This allows private elements in the module to be overridden.  No new keys\n-   * may be exposed.  If a key is bound in both sets of modules, only the binding from the override modules\n-   * is kept. This can be used to replace the bindings of a production module with test bindings:\n-   * <pre>\n-   * Module functionalTestModule\n-   *     = Modules.override(new PrivateProductionModule()).with(getTestModules());\n-   * </pre>\n-   *\n-   * <p>Prefer to write smaller modules that can be reused and tested without overrides.\n-   *\n-   * @param modules the modules whose bindings are open to be overridden\n-   * @since 3.0\n-   */\n-  public static PrivateOverriddenModuleBuilder override(PrivateModule privateModule) {\n-    return new RealPrivateOverriddenModuleBuilder(privateModule);\n-  }\n \n   /**\n    * Returns a builder that creates a module that overlays override modules over the given\n    * modules. If a key is bound in both sets of modules, only the binding from the override modules\n-   * is kept. This can be used to replace the bindings of a production module with test bindings:\n+   * is kept. If a single {@link PrivateModule} is supplied or all elements are from\n+   * a single {@link PrivateBinder}, then this will overwrite the private bindings.\n+   * Otherwise, private bindings will not be overwritten unless they are exposed. \n+   * This can be used to replace the bindings of a production module with test bindings:\n    * <pre>\n    * Module functionalTestModule\n    *     = Modules.override(new ProductionModule()).with(new TestModule());\n@@ -94,7 +78,10 @@ public static OverriddenModuleBuilder override(Module... modules) {\n   /**\n    * Returns a builder that creates a module that overlays override modules over the given\n    * modules. If a key is bound in both sets of modules, only the binding from the override modules\n-   * is kept. This can be used to replace the bindings of a production module with test bindings:\n+   * is kept. If a single {@link PrivateModule} is supplied or all elements are from\n+   * a single {@link PrivateBinder}, then this will overwrite the private bindings.\n+   * Otherwise, private bindings will not be overwritten unless they are exposed. \n+   * This can be used to replace the bindings of a production module with test bindings:\n    * <pre>\n    * Module functionalTestModule\n    *     = Modules.override(getProductionModules()).with(getTestModules());\n@@ -145,54 +132,7 @@ public interface OverriddenModuleBuilder {\n      */\n     Module with(Iterable<? extends Module> overrides);\n   }\n-  \n-  /**\n-   * See the EDSL example at {@link Modules#override(PrivateModule) override()}.\n-   * @since 3.0\n-   */\n-  public interface PrivateOverriddenModuleBuilder {\n-\n-    /**\n-     * See the EDSL example at {@link Modules#override(PrivateModule) override()}.\n-     */\n-    PrivateModule with(Module... overrides);\n-\n-    /**\n-     * See the EDSL example at {@link Modules#override(PrivateModule) override()}.\n-     */\n-    PrivateModule with(Iterable<? extends Module> overrides);\n-  }  \n \n-  /**\n-   * An override builder specifically for private modules.\n-   * This allows elements within a PrivateModule to be overridden.\n-   */\n-  private static final class RealPrivateOverriddenModuleBuilder implements PrivateOverriddenModuleBuilder {\n-    private final PrivateModule baseModule;\n-\n-    private RealPrivateOverriddenModuleBuilder(PrivateModule privateModule) {\n-      this.baseModule = privateModule;\n-    }\n-\n-    public PrivateModule with(Module... overrides) {\n-      return with(Arrays.asList(overrides));\n-    }\n-\n-    public PrivateModule with(final Iterable<? extends Module> overrides) {\n-      return new PrivateModule() {\n-        @Override\n-        public void configure() {\n-          PrivateElements privateElements = (PrivateElements)Iterables.getOnlyElement(Elements.getElements(baseModule));\n-          PrivateBinder binder = binder().withSource(privateElements.getSource());\n-          override(Elements.getModule(privateElements.getElements())).with(overrides).configure(binder);\n-          for(Key exposed : privateElements.getExposedKeys()) {\n-            binder.withSource(privateElements.getExposedSource(exposed)).expose(exposed);\n-          }\n-        }\n-      };\n-    }\n-  }\n-  \n   private static final class RealOverriddenModuleBuilder implements OverriddenModuleBuilder {\n     private final ImmutableSet<Module> baseModules;\n \n@@ -208,15 +148,34 @@ public Module with(final Iterable<? extends Module> overrides) {\n       return new AbstractModule() {\n         @Override\n         public void configure() {\n-          final LinkedHashSet<Element> elements =\n-            new LinkedHashSet<Element>(Elements.getElements(baseModules));\n+          Binder baseBinder = binder();\n+          List<Element> baseElements = Elements.getElements(baseModules);\n+\n+          // If the sole element was a PrivateElements, we want to override\n+          // the private elements within that -- so refocus our elements\n+          // and binder.\n+          if(baseElements.size() == 1) {\n+            Element element = Iterables.getOnlyElement(baseElements);\n+            if(element instanceof PrivateElements) {\n+              PrivateElements privateElements = (PrivateElements)element;\n+              PrivateBinder privateBinder = baseBinder.newPrivateBinder().withSource(privateElements.getSource());\n+              for(Key exposed : privateElements.getExposedKeys()) {\n+                privateBinder.withSource(privateElements.getExposedSource(exposed)).expose(exposed);\n+              }\n+              baseBinder = privateBinder;\n+              baseElements = privateElements.getElements();\n+            }\n+          }\n+          \n+          final Binder binder = baseBinder;\n+          final LinkedHashSet<Element> elements = new LinkedHashSet<Element>(baseElements);\n           final List<Element> overrideElements = Elements.getElements(overrides);\n \n           final Set<Key<?>> overriddenKeys = Sets.newHashSet();\n           final Set<Class<? extends Annotation>> overridesScopeAnnotations = Sets.newHashSet();\n \n           // execute the overrides module, keeping track of which keys and scopes are bound\n-          new ModuleWriter(binder()) {\n+          new ModuleWriter(binder) {\n             @Override public <T> Void visit(Binding<T> binding) {\n               overriddenKeys.add(binding.getKey());\n               return super.visit(binding);\n@@ -238,7 +197,7 @@ public void configure() {\n           // multiple times.\n           final Map<Scope, Object> scopeInstancesInUse = Maps.newHashMap();\n           final List<ScopeBinding> scopeBindings = Lists.newArrayList();\n-          new ModuleWriter(binder()) {\n+          new ModuleWriter(binder) {\n             @Override public <T> Void visit(Binding<T> binding) {\n               if (!overriddenKeys.remove(binding.getKey())) {\n                 super.visit(binding);\n@@ -293,14 +252,14 @@ void rewrite(Binder binder, PrivateElements privateElements, Set<Key<?>> keysToS\n \n           // execute the scope bindings, skipping scopes that have been overridden. Any scope that\n           // is overridden and in active use will prompt an error\n-          new ModuleWriter(binder()) {\n+          new ModuleWriter(binder) {\n             @Override public Void visit(ScopeBinding scopeBinding) {\n               if (!overridesScopeAnnotations.remove(scopeBinding.getAnnotationType())) {\n                 super.visit(scopeBinding);\n               } else {\n                 Object source = scopeInstancesInUse.get(scopeBinding.getScope());\n                 if (source != null) {\n-                  binder().withSource(source).addError(\n+                  binder.withSource(source).addError(\n                       \"The scope for @%s is bound directly and cannot be overridden.\",\n                       scopeBinding.getAnnotationType().getSimpleName());\n                 }",
      "parent_sha": "b085238b6af971694d8fc67b874dbb82ca5b5270"
    }
  },
  {
    "oid": "f734770aa6938cb8dec7d11f9719875177d020fe",
    "message": "Migrated from Subject.failWithRawMessage to Subject.failWithoutActual\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=205720194",
    "date": "2018-09-17T19:15:15Z",
    "url": "https://github.com/google/guice/commit/f734770aa6938cb8dec7d11f9719875177d020fe",
    "details": {
      "sha": "e1c91e8f072f67119a56675b0433e6a53c5a478c",
      "filename": "extensions/testlib/src/com/google/inject/testing/throwingproviders/CheckedProviderSubject.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/google/guice/blob/f734770aa6938cb8dec7d11f9719875177d020fe/extensions%2Ftestlib%2Fsrc%2Fcom%2Fgoogle%2Finject%2Ftesting%2Fthrowingproviders%2FCheckedProviderSubject.java",
      "raw_url": "https://github.com/google/guice/raw/f734770aa6938cb8dec7d11f9719875177d020fe/extensions%2Ftestlib%2Fsrc%2Fcom%2Fgoogle%2Finject%2Ftesting%2Fthrowingproviders%2FCheckedProviderSubject.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Ftestlib%2Fsrc%2Fcom%2Fgoogle%2Finject%2Ftesting%2Fthrowingproviders%2FCheckedProviderSubject.java?ref=f734770aa6938cb8dec7d11f9719875177d020fe",
      "patch": "@@ -1,5 +1,7 @@\n package com.google.inject.testing.throwingproviders;\n \n+import static com.google.common.base.Strings.lenientFormat;\n+import static com.google.common.truth.Fact.simpleFact;\n import static com.google.common.truth.Truth.assertAbout;\n \n import com.google.common.truth.FailureMetadata;\n@@ -106,7 +108,7 @@ private static final class UnexpectedFailureSubject\n     }\n \n     void doFail(String format, Object... args) {\n-      failWithRawMessage(format, args);\n+      failWithoutActual(simpleFact(lenientFormat(format, args)));\n     }\n   }\n }",
      "parent_sha": "2c8b56156677b11f4e4114784f31c4469ba3eabe"
    }
  },
  {
    "oid": "2de23113188495ce1583acf0f1bef774987c8d35",
    "message": "Update `FactoryProvider2` to support Java 15.\n\nThe private constructor used in looking up method handles has changed to take an extra parameter. This change update the code to look for both constructor signatures.\n\nPiperOrigin-RevId: 339124988",
    "date": "2020-10-26T22:00:30Z",
    "url": "https://github.com/google/guice/commit/2de23113188495ce1583acf0f1bef774987c8d35",
    "details": {
      "sha": "6bdafbd037482ddbb8ea88a1bf1ed107820f9e6c",
      "filename": "extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java",
      "status": "modified",
      "additions": 25,
      "deletions": 7,
      "changes": 32,
      "blob_url": "https://github.com/google/guice/blob/2de23113188495ce1583acf0f1bef774987c8d35/extensions%2Fassistedinject%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fassistedinject%2FFactoryProvider2.java",
      "raw_url": "https://github.com/google/guice/raw/2de23113188495ce1583acf0f1bef774987c8d35/extensions%2Fassistedinject%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fassistedinject%2FFactoryProvider2.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fassistedinject%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fassistedinject%2FFactoryProvider2.java?ref=2de23113188495ce1583acf0f1bef774987c8d35",
      "patch": "@@ -900,13 +900,26 @@ protected Object initialValue() {\n       findMethodHandlesLookupCxtor();\n \n   private static Constructor<MethodHandles.Lookup> findMethodHandlesLookupCxtor() {\n-    try {\n-      Constructor<MethodHandles.Lookup> cxtor =\n-          MethodHandles.Lookup.class.getDeclaredConstructor(Class.class, int.class);\n+    // Different JDK implementations have different constructors so look for a constructor that\n+    // takes a class and an int first (openjdk-8, openjdk-11) and fallback to a constructor that\n+    // takes two classes and an int (openjdk-15).\n+    // TODO(b/171738889): Figure out a better way to handle this.\n+    Constructor<MethodHandles.Lookup> cxtor = findMethodHandlesLookupCxtor(Class.class, int.class);\n+    if (cxtor == null) {\n+      cxtor = findMethodHandlesLookupCxtor(Class.class, Class.class, int.class);\n+    }\n+    if (cxtor != null) {\n       cxtor.setAccessible(true);\n-      return cxtor;\n-    } catch (ReflectiveOperationException ignored) {\n-      // Ignore, the code falls back to a less-precise check if we can't create method handles.\n+    }\n+    return cxtor;\n+  }\n+\n+  private static Constructor<MethodHandles.Lookup> findMethodHandlesLookupCxtor(\n+      Class<?>... parameterTypes) {\n+    try {\n+      return MethodHandles.Lookup.class.getDeclaredConstructor(parameterTypes);\n+    } catch (NoSuchMethodException e) {\n+      // Ignored if the constructor doesn't exist.\n       return null;\n     }\n   }\n@@ -919,7 +932,12 @@ private static MethodHandle createMethodHandle(Method method, Object proxy) {\n     int allModes =\n         Modifier.PRIVATE | Modifier.STATIC /* package */ | Modifier.PUBLIC | Modifier.PROTECTED;\n     try {\n-      MethodHandles.Lookup lookup = methodHandlesLookupCxtor.newInstance(declaringClass, allModes);\n+      MethodHandles.Lookup lookup;\n+      if (methodHandlesLookupCxtor.getParameterCount() == 2) {\n+        lookup = methodHandlesLookupCxtor.newInstance(declaringClass, allModes);\n+      } else {\n+        lookup = methodHandlesLookupCxtor.newInstance(declaringClass, null, allModes);\n+      }\n       method.setAccessible(true);\n       return lookup.unreflectSpecial(method, declaringClass).bindTo(proxy);\n     } catch (ReflectiveOperationException roe) {",
      "parent_sha": "8b2a048a713a3d2f06ceb39b90649257791dc090"
    }
  },
  {
    "oid": "d4d4df3b02323a75aa3929db608dc54d9fc94760",
    "message": "log timing info at \"fine\" level\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@270 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2007-03-08T21:22:37Z",
    "url": "https://github.com/google/guice/commit/d4d4df3b02323a75aa3929db608dc54d9fc94760",
    "details": {
      "sha": "5963ccc2a98264ea22ac0d493fb1957eedca882e",
      "filename": "src/com/google/inject/util/Stopwatch.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/google/guice/blob/d4d4df3b02323a75aa3929db608dc54d9fc94760/src%2Fcom%2Fgoogle%2Finject%2Futil%2FStopwatch.java",
      "raw_url": "https://github.com/google/guice/raw/d4d4df3b02323a75aa3929db608dc54d9fc94760/src%2Fcom%2Fgoogle%2Finject%2Futil%2FStopwatch.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/src%2Fcom%2Fgoogle%2Finject%2Futil%2FStopwatch.java?ref=d4d4df3b02323a75aa3929db608dc54d9fc94760",
      "patch": "@@ -28,7 +28,7 @@ public class Stopwatch {\n   long start = System.currentTimeMillis();\n \n   /**\n-   * Resets and returns ellapsed time.\n+   * Resets and returns elapsed time in milliseconds.\n    */\n   public long reset() {\n     long now = System.currentTimeMillis();\n@@ -40,9 +40,9 @@ public long reset() {\n   }\n \n   /**\n-   * Resets and logs ellapsed time.\n+   * Resets and logs elapsed time in milliseconds.\n    */\n   public void resetAndLog(Logger logger, String label) {\n-    logger.info(label + \": \" + reset() + \"ms\");\n+    logger.fine(label + \": \" + reset() + \"ms\");\n   }\n }",
      "parent_sha": "cd38685e40e1228450a1a5785c37f4bc1310bc0e"
    }
  },
  {
    "oid": "4fd9a4f49ff38ab59a4c0f514607806794351528",
    "message": "Minor documentation edit.\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=119328467",
    "date": "2016-06-13T21:09:29Z",
    "url": "https://github.com/google/guice/commit/4fd9a4f49ff38ab59a4c0f514607806794351528",
    "details": {
      "sha": "ee467baf489fc2577bda583dc81021461d1f45a1",
      "filename": "extensions/testlib/src/com/google/inject/testing/fieldbinder/BoundFieldModule.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/google/guice/blob/4fd9a4f49ff38ab59a4c0f514607806794351528/extensions%2Ftestlib%2Fsrc%2Fcom%2Fgoogle%2Finject%2Ftesting%2Ffieldbinder%2FBoundFieldModule.java",
      "raw_url": "https://github.com/google/guice/raw/4fd9a4f49ff38ab59a4c0f514607806794351528/extensions%2Ftestlib%2Fsrc%2Fcom%2Fgoogle%2Finject%2Ftesting%2Ffieldbinder%2FBoundFieldModule.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Ftestlib%2Fsrc%2Fcom%2Fgoogle%2Finject%2Ftesting%2Ffieldbinder%2FBoundFieldModule.java?ref=4fd9a4f49ff38ab59a4c0f514607806794351528",
      "patch": "@@ -71,14 +71,14 @@\n  * public class TestFoo {\n  *   // bind(new TypeLiteral{@code <List<Object>>}() {}).toInstance(listOfObjects);\n  *   {@literal @}Bind private List{@code <Object>} listOfObjects = Lists.of();\n- *   \n+ *\n  *   // bind(String.class).toProvider(new Provider() { public String get() { return userName; }});\n  *   {@literal @}Bind(lazy = true) private String userName;\n  *\n  *   // bind(SuperClass.class).toInstance(aSubClass);\n  *   {@literal @}Bind(to = SuperClass.class) private SubClass aSubClass = new SubClass();\n  *\n- *   // bind(Object.class).annotatedWith(MyBindingAnnotation.class).toInstance(object2);\n+ *   // bind(String.class).annotatedWith(MyBindingAnnotation.class).toInstance(myString);\n  *   {@literal @}Bind\n  *   {@literal @}MyBindingAnnotation\n  *   private String myString = \"hello\";",
      "parent_sha": "46e146db975181c3de2e0ebec8e25d9fa610c08d"
    }
  },
  {
    "oid": "1e5fc1daab8364f1d16614e9013135a115e66e2c",
    "message": "fix typo, make test not loop forever.\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@1510 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2011-02-28T17:49:54Z",
    "url": "https://github.com/google/guice/commit/1e5fc1daab8364f1d16614e9013135a115e66e2c",
    "details": {
      "sha": "1ce6966ed02794b11d900aac8b4ae69662fc8d4b",
      "filename": "core/test/com/google/inject/MethodInterceptionTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/1e5fc1daab8364f1d16614e9013135a115e66e2c/core%2Ftest%2Fcom%2Fgoogle%2Finject%2FMethodInterceptionTest.java",
      "raw_url": "https://github.com/google/guice/raw/1e5fc1daab8364f1d16614e9013135a115e66e2c/core%2Ftest%2Fcom%2Fgoogle%2Finject%2FMethodInterceptionTest.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Ftest%2Fcom%2Fgoogle%2Finject%2FMethodInterceptionTest.java?ref=1e5fc1daab8364f1d16614e9013135a115e66e2c",
      "patch": "@@ -172,7 +172,7 @@ protected void configure() {\n       fail();\n     } catch (Exception e) {\n       // validate all causes.\n-      for (Throwable t = e; t != null; t = e.getCause()) {\n+      for (Throwable t = e; t != null; t = t.getCause()) {\n         StackTraceElement[] stackTraceElement = t.getStackTrace();\n         assertEquals(\"explode\", stackTraceElement[0].getMethodName());\n         assertEquals(\"invoke\", stackTraceElement[1].getMethodName());",
      "parent_sha": "6e4e4973a87dfbfbba0b3c03b299eacb9b8696bd"
    }
  },
  {
    "oid": "15c52304906ff5f39b8908b6fdaf0982e8abde17",
    "message": "Internal refactor\n\nRELNOTES=n/a\nPiperOrigin-RevId: 407145553",
    "date": "2021-11-02T19:11:58Z",
    "url": "https://github.com/google/guice/commit/15c52304906ff5f39b8908b6fdaf0982e8abde17",
    "details": {
      "sha": "57607de0e181bc8669d50a68e8355e3350975636",
      "filename": "extensions/dagger-adapter/src/com/google/inject/daggeradapter/DaggerMethodScanner.java",
      "status": "modified",
      "additions": 1,
      "deletions": 7,
      "changes": 8,
      "blob_url": "https://github.com/google/guice/blob/15c52304906ff5f39b8908b6fdaf0982e8abde17/extensions%2Fdagger-adapter%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fdaggeradapter%2FDaggerMethodScanner.java",
      "raw_url": "https://github.com/google/guice/raw/15c52304906ff5f39b8908b6fdaf0982e8abde17/extensions%2Fdagger-adapter%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fdaggeradapter%2FDaggerMethodScanner.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fdagger-adapter%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fdaggeradapter%2FDaggerMethodScanner.java?ref=15c52304906ff5f39b8908b6fdaf0982e8abde17",
      "patch": "@@ -79,7 +79,7 @@ public <T> Key<T> prepareMethod(\n     }\n     Class<? extends Annotation> annotationType = annotation.annotationType();\n     if (annotationType.equals(Provides.class)) {\n-      return prepareProvidesKey(binder, method, key);\n+      return processMultibindingAnnotations(binder, method, key);\n     } else if (annotationType.equals(Binds.class)) {\n       configureBindsKey(binder, method, key);\n       return null;\n@@ -94,12 +94,6 @@ public <T> Key<T> prepareMethod(\n     throw new UnsupportedOperationException(annotation.toString());\n   }\n \n-  private <T> Key<T> prepareProvidesKey(Binder binder, Method method, Key<T> key) {\n-    key = processMultibindingAnnotations(binder, method, key);\n-\n-    return key;\n-  }\n-\n   private <T> void configureBindsKey(Binder binder, Method method, Key<T> key) {\n     // the Dagger processor already validates the assignability of these two keys. parameterKey()\n     // has no way to infer the correct type parameter, so we use rawtypes instead.",
      "parent_sha": "9d12b481ddd60f8a9cb1be5413a26b76bd9807cf"
    }
  },
  {
    "oid": "301251b924cdee3fd3f0d05b76c8ff78c8f0d410",
    "message": "Close the resource stream after reading.\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=111951691",
    "date": "2016-01-12T16:40:42Z",
    "url": "https://github.com/google/guice/commit/301251b924cdee3fd3f0d05b76c8ff78c8f0d410",
    "details": {
      "sha": "aa03abe26b4ba1da3fc1fc39951963e1874cf05c",
      "filename": "core/src/com/google/inject/internal/util/LineNumbers.java",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/google/guice/blob/301251b924cdee3fd3f0d05b76c8ff78c8f0d410/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2Futil%2FLineNumbers.java",
      "raw_url": "https://github.com/google/guice/raw/301251b924cdee3fd3f0d05b76c8ff78c8f0d410/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2Futil%2FLineNumbers.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2Futil%2FLineNumbers.java?ref=301251b924cdee3fd3f0d05b76c8ff78c8f0d410",
      "patch": "@@ -62,7 +62,13 @@ public LineNumbers(Class type) throws IOException {\n     if (!type.isArray()) {\n       InputStream in = type.getResourceAsStream(\"/\" + type.getName().replace('.', '/') + \".class\");\n       if (in != null) {\n-        new ClassReader(in).accept(new LineNumberReader(), ClassReader.SKIP_FRAMES);\n+        try {\n+          new ClassReader(in).accept(new LineNumberReader(), ClassReader.SKIP_FRAMES);\n+        } finally {\n+          try {\n+            in.close();\n+          } catch (IOException ignored) {}\n+        }\n       }\n     }\n   }",
      "parent_sha": "a65d72b61d2b841ce69058fe630446adb9ad0f00"
    }
  },
  {
    "oid": "9e7afde6564ef59a707df2c7c3bb38930ab16b07",
    "message": "Documentation nit: update text to match variable name.\n\nPiperOrigin-RevId: 339493357",
    "date": "2020-10-28T17:55:31Z",
    "url": "https://github.com/google/guice/commit/9e7afde6564ef59a707df2c7c3bb38930ab16b07",
    "details": {
      "sha": "ab93a2fd7ebaf14d75a6a0ed6e874727fede2b24",
      "filename": "core/src/com/google/inject/spi/ElementSource.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/9e7afde6564ef59a707df2c7c3bb38930ab16b07/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fspi%2FElementSource.java",
      "raw_url": "https://github.com/google/guice/raw/9e7afde6564ef59a707df2c7c3bb38930ab16b07/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fspi%2FElementSource.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fspi%2FElementSource.java?ref=9e7afde6564ef59a707df2c7c3bb38930ab16b07",
      "patch": "@@ -91,7 +91,7 @@ public final class ElementSource {\n   /**\n    * Creates a new {@ElementSource} from the given parameters.\n    *\n-   * @param originalElementSource The source of element that this element created from (if there is\n+   * @param originalSource The source of element that this element was created from (if there is\n    *     any), otherwise {@code null}.\n    * @param declaringSource the source (in)directly declared the element.\n    * @param moduleSource the moduleSource when the element is bound",
      "parent_sha": "f3f8fc0c7cc2bf5ea1596f7adee7f514d6cf01e8"
    }
  },
  {
    "oid": "78b2b769a34e53cd3ccc69b575f026be2fb30615",
    "message": "Added FactoryTest. Removed GeneratorTesy.\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@178 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2007-02-20T02:09:12Z",
    "url": "https://github.com/google/guice/commit/78b2b769a34e53cd3ccc69b575f026be2fb30615",
    "details": {
      "sha": "26c92f4a1bb5c730a27b2346c396ff8c2b8fa0a2",
      "filename": "test/com/google/inject/FactoryTest.java",
      "status": "renamed",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/google/guice/blob/78b2b769a34e53cd3ccc69b575f026be2fb30615/test%2Fcom%2Fgoogle%2Finject%2FFactoryTest.java",
      "raw_url": "https://github.com/google/guice/raw/78b2b769a34e53cd3ccc69b575f026be2fb30615/test%2Fcom%2Fgoogle%2Finject%2FFactoryTest.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/test%2Fcom%2Fgoogle%2Finject%2FFactoryTest.java?ref=78b2b769a34e53cd3ccc69b575f026be2fb30615",
      "patch": "@@ -29,33 +29,33 @@\n  */\n public class FactoryTest extends TestCase {\n \n-  public void testParameterIndex() throws ContainerCreationException {\n+  public void testParameterIndex() throws CreationException {\n     ContainerBuilder cb = new ContainerBuilder();\n \n-    cb.bind(Zero.class).to(new Generator<Zero>() {\n-      public Zero generate(Context context) {\n+    cb.bind(Zero.class).to(new Factory<Zero>() {\n+      public Zero get(Context context) {\n         assertEquals(0, context.getParameterIndex());\n         return new Zero();\n       }\n     });\n \n-    cb.bind(One.class).to(new Generator<One>() {\n-      public One generate(Context context) {\n+    cb.bind(One.class).to(new Factory<One>() {\n+      public One get(Context context) {\n         assertEquals(1, context.getParameterIndex());\n         return new One();\n       }\n     });\n \n-    cb.bind(NegativeOne.class).to(new Generator<NegativeOne>() {\n-      public NegativeOne generate(Context context) {\n+    cb.bind(NegativeOne.class).to(new Factory<NegativeOne>() {\n+      public NegativeOne get(Context context) {\n         assertEquals(-1, context.getParameterIndex());\n         return new NegativeOne();\n       }\n     });\n \n     Container c = cb.create();\n \n-    A a = c.getFactory(A.class).get();\n+    A a = c.getLocator(A.class).get();\n \n     assertNotNull(a.negativeOne);\n     assertTrue(a.initCalled);\n@@ -130,7 +130,7 @@ public void testInjection() throws Exception {\n \n     Container c = cb.create();\n \n-    Foo foo = c.getFactory(Key.get(Foo.class, FooAnnotation.class)).get();\n+    Foo foo = c.getLocator(Key.get(Foo.class, FooAnnotation.class)).get();\n \n     assertNotNull(foo.bar);\n     assertNotNull(foo.bar.tee1);\n@@ -141,14 +141,14 @@ public void testInjection() throws Exception {\n     assertNotNull(foo.bar.tee2.bob2);\n   }\n \n-  <T> Generator<T> createFactory(\n+  <T> Factory<T> createFactory(\n       final Class<T> type, final Class<? extends Annotation> annotationType,\n       final Member expectedMember) {\n-    return new Generator<T>() {\n-      public T generate(Context context) {\n+    return new Factory<T>() {\n+      public T get(Context context) {\n         assertEquals(expectedMember, context.getMember());\n         assertEquals(type, context.getKey().getType().getType());\n-        return context.getContainer().getFactory(type).get();\n+        return context.getContainer().getLocator(type).get();\n       }\n     };\n   }",
      "previous_filename": "test/com/google/inject/GeneratorTesy.java",
      "parent_sha": "32af4a6695f98e732d92d31943d98c8671679316"
    }
  },
  {
    "oid": "98be10254cabb06f74973eecbadfc7a8942f85d8",
    "message": "Sync EnsureJpaCanTakeObjectsInPropertiesTest",
    "date": "2014-10-20T17:09:12Z",
    "url": "https://github.com/google/guice/commit/98be10254cabb06f74973eecbadfc7a8942f85d8",
    "details": {
      "sha": "6dcd6bde6b2cd7338204fd605f834dc48ee8ccb1",
      "filename": "extensions/persist/test/com/google/inject/persist/jpa/EnsureJpaCanTakeObjectsInPropertiesTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/google/guice/blob/98be10254cabb06f74973eecbadfc7a8942f85d8/extensions%2Fpersist%2Ftest%2Fcom%2Fgoogle%2Finject%2Fpersist%2Fjpa%2FEnsureJpaCanTakeObjectsInPropertiesTest.java",
      "raw_url": "https://github.com/google/guice/raw/98be10254cabb06f74973eecbadfc7a8942f85d8/extensions%2Fpersist%2Ftest%2Fcom%2Fgoogle%2Finject%2Fpersist%2Fjpa%2FEnsureJpaCanTakeObjectsInPropertiesTest.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fpersist%2Ftest%2Fcom%2Fgoogle%2Finject%2Fpersist%2Fjpa%2FEnsureJpaCanTakeObjectsInPropertiesTest.java?ref=98be10254cabb06f74973eecbadfc7a8942f85d8",
      "patch": "@@ -77,7 +77,7 @@ public final void tearDown() {\n     injector.getInstance(EntityManagerFactory.class).close();\n   }\n \n-  private static JDBCDataSource getDataSource() {\n+  private static DataSource getDataSource() {\n     final JDBCDataSource dataSource = new JDBCDataSource();\n     dataSource.setDatabase(\"jdbc:hsqldb:mem:persistence\");\n     dataSource.setUser(\"sa\");\n@@ -86,14 +86,13 @@ private static JDBCDataSource getDataSource() {\n   }\n \n   private void startPersistService(boolean passDataSource) {\n-    final JDBCDataSource dataSource = getDataSource();\n+    final DataSource dataSource = getDataSource();\n \n     injector = Guice.createInjector(new DBModule(dataSource, passDataSource));\n \n     //startup persistence\n     injector.getInstance(PersistService.class).start();\n   }\n-\n   public void testWorksIfPassDataSource() {\n     startPersistService(true);\n   }",
      "parent_sha": "0daf9e74a5a65a12f7d3299f9a80112ea7a111fb"
    }
  },
  {
    "oid": "8e2796cded713090341e97000d0db9fa20e385d0",
    "message": "Prevent external Google code from implementing the Binder interface.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=321642018",
    "date": "2020-07-17T15:24:25Z",
    "url": "https://github.com/google/guice/commit/8e2796cded713090341e97000d0db9fa20e385d0",
    "details": {
      "sha": "8161aa04d0c79500e3927ccf170481b78fc6f12a",
      "filename": "core/src/com/google/inject/Binder.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/google/guice/blob/8e2796cded713090341e97000d0db9fa20e385d0/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2FBinder.java",
      "raw_url": "https://github.com/google/guice/raw/8e2796cded713090341e97000d0db9fa20e385d0/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2FBinder.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2FBinder.java?ref=8e2796cded713090341e97000d0db9fa20e385d0",
      "patch": "@@ -189,9 +189,9 @@ public interface Binder {\n    * eligible for interception if:\n    *\n    * <ul>\n-   * <li>Guice created the instance the method is on\n-   * <li>Neither the enclosing type nor the method is final\n-   * <li>And the method is package-private, protected, or public\n+   *   <li>Guice created the instance the method is on\n+   *   <li>Neither the enclosing type nor the method is final\n+   *   <li>And the method is package-private, protected, or public\n    * </ul>\n    *\n    * @param classMatcher matches classes the interceptor should apply to. For example: {@code",
      "parent_sha": "f1ed57d0455054d9e72d29099bc5b236cfcded4a"
    }
  },
  {
    "oid": "f26a731e3d1cbeca0cf2aa9e6fc607846170b099",
    "message": "Fix typo in jdoc.\n\nPiperOrigin-RevId: 516590803",
    "date": "2023-03-14T18:54:26Z",
    "url": "https://github.com/google/guice/commit/f26a731e3d1cbeca0cf2aa9e6fc607846170b099",
    "details": {
      "sha": "f795e3ba9a64fcbcaa6def3a6882174291115c32",
      "filename": "core/src/com/google/inject/multibindings/ProvidesIntoSet.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/f26a731e3d1cbeca0cf2aa9e6fc607846170b099/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fmultibindings%2FProvidesIntoSet.java",
      "raw_url": "https://github.com/google/guice/raw/f26a731e3d1cbeca0cf2aa9e6fc607846170b099/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fmultibindings%2FProvidesIntoSet.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fmultibindings%2FProvidesIntoSet.java?ref=f26a731e3d1cbeca0cf2aa9e6fc607846170b099",
      "patch": "@@ -32,7 +32,7 @@\n  * <pre>\n  * {@literal @}ProvidesIntoSet\n  * {@literal @}Named(\"urls\")\n- * String provideFooUrl(FooManager fm) { returm fm.getUrl(); }\n+ * String provideFooUrl(FooManager fm) { return fm.getUrl(); }\n  *\n  * {@literal @}ProvidesIntoSet\n  * {@literal @}Named(\"urls\")",
      "parent_sha": "4a8965a8990b27bcb842158da0cceb54df397141"
    }
  },
  {
    "oid": "84fb9551ea00afbced71d6e197b246874672db38",
    "message": "Fix typo\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=311171512",
    "date": "2020-05-13T14:20:36Z",
    "url": "https://github.com/google/guice/commit/84fb9551ea00afbced71d6e197b246874672db38",
    "details": {
      "sha": "ea0c00878a2812642a6c201db8a4650540926222",
      "filename": "core/src/com/google/inject/spi/InjectionPoint.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/google/guice/blob/84fb9551ea00afbced71d6e197b246874672db38/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fspi%2FInjectionPoint.java",
      "raw_url": "https://github.com/google/guice/raw/84fb9551ea00afbced71d6e197b246874672db38/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fspi%2FInjectionPoint.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fspi%2FInjectionPoint.java?ref=84fb9551ea00afbced71d6e197b246874672db38",
      "patch": "@@ -104,15 +104,15 @@ public final class InjectionPoint {\n   }\n \n   private ImmutableList<Dependency<?>> forMember(\n-      Member member, TypeLiteral<?> type, Annotation[][] paramterAnnotations) {\n+      Member member, TypeLiteral<?> type, Annotation[][] parameterAnnotationsPerParameter) {\n     Errors errors = new Errors(member);\n \n     List<Dependency<?>> dependencies = Lists.newArrayList();\n     int index = 0;\n \n     for (TypeLiteral<?> parameterType : type.getParameterTypes(member)) {\n       try {\n-        Annotation[] parameterAnnotations = paramterAnnotations[index];\n+        Annotation[] parameterAnnotations = parameterAnnotationsPerParameter[index];\n         Key<?> key = Annotations.getKey(parameterType, member, parameterAnnotations, errors);\n         dependencies.add(newDependency(key, Nullability.allowsNull(parameterAnnotations), index));\n         index++;",
      "parent_sha": "35c8645dc57b0ef269a354d8e9d52097cd724319"
    }
  },
  {
    "oid": "97adab5a1c13e595fb833f3364c60ef972e3fe0d",
    "message": "Tentative fix for string index out of bounds exception in issue #560\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@1299 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2010-10-21T12:35:46Z",
    "url": "https://github.com/google/guice/commit/97adab5a1c13e595fb833f3364c60ef972e3fe0d",
    "details": {
      "sha": "184ce362ac9c0b4909c8d1416d86f393f71f44c0",
      "filename": "extensions/servlet/src/com/google/inject/servlet/ServletDefinition.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/google/guice/blob/97adab5a1c13e595fb833f3364c60ef972e3fe0d/extensions%2Fservlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletDefinition.java",
      "raw_url": "https://github.com/google/guice/raw/97adab5a1c13e595fb833f3364c60ef972e3fe0d/extensions%2Fservlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletDefinition.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fservlet%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fservlet%2FServletDefinition.java?ref=97adab5a1c13e595fb833f3364c60ef972e3fe0d",
      "patch": "@@ -202,9 +202,9 @@ void doService(final ServletRequest servletRequest, ServletResponse servletRespo\n       @Override\n       public String getPathInfo() {\n         if (!isPathInfoComputed()) {\n-          final int servletPathLength = getServletPath().length();\n-          pathInfo = getRequestURI().substring(getContextPath().length()).replaceAll(\"[/]{2,}\", \"/\")\n-              .substring(servletPathLength);\n+          int servletPathLength = getServletPath().length();\n+          pathInfo = getRequestURI().substring(getContextPath().length()).replaceAll(\"[/]{2,}\", \"/\");\n+          pathInfo = pathInfo.length() > servletPathLength ? pathInfo.substring(servletPathLength) : null;\n \n           // Corner case: when servlet path and request path match exactly (without trailing '/'),\n           // then pathinfo is null",
      "parent_sha": "3cd00c844e86af5ad55308b4d9662f1c4addd655"
    }
  },
  {
    "oid": "78a2063bbf401e033fff3a6a4fabc34cdfb3b151",
    "message": "Remove horribly wrong doc.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=133746890",
    "date": "2016-10-20T16:43:22Z",
    "url": "https://github.com/google/guice/commit/78a2063bbf401e033fff3a6a4fabc34cdfb3b151",
    "details": {
      "sha": "4ce1e31501527578d7316da75f3f1d70116c0f3c",
      "filename": "core/src/com/google/inject/Provider.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/78a2063bbf401e033fff3a6a4fabc34cdfb3b151/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2FProvider.java",
      "raw_url": "https://github.com/google/guice/raw/78a2063bbf401e033fff3a6a4fabc34cdfb3b151/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2FProvider.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2FProvider.java?ref=78a2063bbf401e033fff3a6a4fabc34cdfb3b151",
      "patch": "@@ -41,7 +41,7 @@\n public interface Provider<T> extends javax.inject.Provider<T> {\n \n   /**\n-   * Provides an instance of {@code T}. Must never return {@code null}.\n+   * Provides an instance of {@code T}.\n    *\n    * @throws OutOfScopeException when an attempt is made to access a scoped object while the scope\n    *     in question is not currently active",
      "parent_sha": "aa6489766f027dbb0e0ea00eb2f19aa8eb8c03de"
    }
  },
  {
    "oid": "f3429aefc145e81cd8c0961396603690bace9217",
    "message": "Removing a redundant synchronized statement, on the advice of Stuart McCulls who was studying this code (in order to close issue 89).\n\ngit-svn-id: https://google-guice.googlecode.com/svn/trunk@562 d779f126-a31b-0410-b53b-1d3aecad763e",
    "date": "2008-07-16T15:42:05Z",
    "url": "https://github.com/google/guice/commit/f3429aefc145e81cd8c0961396603690bace9217",
    "details": {
      "sha": "77d5ed410832dc043272e542e799be8ed82bb9ba",
      "filename": "src/com/google/inject/internal/AbstractReferenceCache.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/f3429aefc145e81cd8c0961396603690bace9217/src%2Fcom%2Fgoogle%2Finject%2Finternal%2FAbstractReferenceCache.java",
      "raw_url": "https://github.com/google/guice/raw/f3429aefc145e81cd8c0961396603690bace9217/src%2Fcom%2Fgoogle%2Finject%2Finternal%2FAbstractReferenceCache.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/src%2Fcom%2Fgoogle%2Finject%2Finternal%2FAbstractReferenceCache.java?ref=f3429aefc145e81cd8c0961396603690bace9217",
      "patch": "@@ -164,7 +164,7 @@ synchronized V get() {\n      *\n      * @return {@code true} if the thread was interrupted while waiting\n      */\n-    private synchronized boolean waitUntilSet() {\n+    private boolean waitUntilSet() {\n       boolean interrupted = false;\n       while (!set) {\n         try {",
      "parent_sha": "fe2c25e66c5163c671759dc0c3629fec005a34af"
    }
  },
  {
    "oid": "6b79ff852485291e7a534e12448288328e2d6c61",
    "message": "Change initial DependencyStack size from 10 to 16",
    "date": "2015-04-05T18:33:47Z",
    "url": "https://github.com/google/guice/commit/6b79ff852485291e7a534e12448288328e2d6c61",
    "details": {
      "sha": "1493c37d124f463ceb25a4e0a487425f09eb9147",
      "filename": "core/src/com/google/inject/internal/InternalContext.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/google/guice/blob/6b79ff852485291e7a534e12448288328e2d6c61/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInternalContext.java",
      "raw_url": "https://github.com/google/guice/raw/6b79ff852485291e7a534e12448288328e2d6c61/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInternalContext.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInternalContext.java?ref=6b79ff852485291e7a534e12448288328e2d6c61",
      "patch": "@@ -106,7 +106,7 @@ public List<DependencyAndSource> getDependencyChain() {\n    * DependencyAndSource objects, which can add to several tens of megabytes in large applications.\n    */\n   private static final class DependencyStack {\n-    private Object[] elements = new Object[10];\n+    private Object[] elements = new Object[16];\n     private int size = 0;\n \n     public void add(Object dependencyOrKey, Object source) {",
      "parent_sha": "af6a1df6a2f9005e1cbb55f2c1deb92a1abc1924"
    }
  },
  {
    "oid": "015ed75b5c4a5b04d1adc36ad836cbf8df57cd35",
    "message": "Restore the default method log message to WARNING level.\n\nThe test failures due to unexpected log messages are now resolved.\n\nPiperOrigin-RevId: 355880552",
    "date": "2021-02-05T18:39:38Z",
    "url": "https://github.com/google/guice/commit/015ed75b5c4a5b04d1adc36ad836cbf8df57cd35",
    "details": {
      "sha": "f01c0ebd4c25386ad05c25d362a484885cc58120",
      "filename": "extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/google/guice/blob/015ed75b5c4a5b04d1adc36ad836cbf8df57cd35/extensions%2Fassistedinject%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fassistedinject%2FFactoryProvider2.java",
      "raw_url": "https://github.com/google/guice/raw/015ed75b5c4a5b04d1adc36ad836cbf8df57cd35/extensions%2Fassistedinject%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fassistedinject%2FFactoryProvider2.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/extensions%2Fassistedinject%2Fsrc%2Fcom%2Fgoogle%2Finject%2Fassistedinject%2FFactoryProvider2.java?ref=015ed75b5c4a5b04d1adc36ad836cbf8df57cd35",
      "patch": "@@ -377,9 +377,8 @@ public TypeLiteral<?> getImplementationType() {\n             && userLookups == null\n             && !Modifier.isPublic(factory.getClass().getModifiers())) {\n           warnedAboutUserLookups = true;\n-          // TODO(b/179303203): Upgrade this back to WARNING level\n           logger.log(\n-              Level.INFO,\n+              Level.WARNING,\n               \"AssistedInject factory {0} is non-public and has javac-generated default methods. \"\n                   + \" Please pass a `MethodHandles.lookups()` with\"\n                   + \" FactoryModuleBuilder.withLookups when using this factory so that Guice can\"",
      "parent_sha": "f78f7cfb3b7cb336e8bc8ad7fe421b24805720e9"
    }
  },
  {
    "oid": "702c07ea7868ea9aa2e1e09cb85f336fc59510d2",
    "message": "Replace BindingsMultimap with an actual Multimap\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=154863870",
    "date": "2017-05-05T18:04:50Z",
    "url": "https://github.com/google/guice/commit/702c07ea7868ea9aa2e1e09cb85f336fc59510d2",
    "details": {
      "sha": "324751946b01d7f4f081c27d263081037ab0317c",
      "filename": "core/src/com/google/inject/internal/InjectorImpl.java",
      "status": "modified",
      "additions": 7,
      "deletions": 29,
      "changes": 36,
      "blob_url": "https://github.com/google/guice/blob/702c07ea7868ea9aa2e1e09cb85f336fc59510d2/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInjectorImpl.java",
      "raw_url": "https://github.com/google/guice/raw/702c07ea7868ea9aa2e1e09cb85f336fc59510d2/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInjectorImpl.java",
      "contents_url": "https://api.github.com/repos/google/guice/contents/core%2Fsrc%2Fcom%2Fgoogle%2Finject%2Finternal%2FInjectorImpl.java?ref=702c07ea7868ea9aa2e1e09cb85f336fc59510d2",
      "patch": "@@ -18,10 +18,11 @@\n \n import com.google.common.base.MoreObjects;\n import com.google.common.base.Objects;\n+import com.google.common.collect.ArrayListMultimap;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Lists;\n+import com.google.common.collect.ListMultimap;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.inject.Binder;\n@@ -112,7 +113,7 @@ enum JitLimitation {\n \n   final State state;\n   final InjectorImpl parent;\n-  final BindingsMultimap bindingsMultimap = new BindingsMultimap();\n+  final ListMultimap<TypeLiteral<?>, Binding<?>> bindingsMultimap = ArrayListMultimap.create();\n   final InjectorOptions options;\n \n   /** Just-in-time binding cache. Guarded by state.lock() */\n@@ -143,17 +144,15 @@ enum JitLimitation {\n   /** Indexes bindings by type. */\n   void index() {\n     for (Binding<?> binding : state.getExplicitBindingsThisLevel().values()) {\n-      index(binding);\n+      bindingsMultimap.put(binding.getKey().getTypeLiteral(), binding);\n     }\n   }\n \n-  <T> void index(Binding<T> binding) {\n-    bindingsMultimap.put(binding.getKey().getTypeLiteral(), binding);\n-  }\n-\n   @Override\n   public <T> List<Binding<T>> findBindingsByType(TypeLiteral<T> type) {\n-    return bindingsMultimap.getAll(type);\n+    @SuppressWarnings(\"unchecked\") // safe because we only put matching entries into the map\n+    List<Binding<T>> list = (List<Binding<T>>) (List) bindingsMultimap.get(type);\n+    return Collections.unmodifiableList(list);\n   }\n \n   /** Returns the binding for {@code key} */\n@@ -966,27 +965,6 @@ public Set<TypeConverterBinding> getTypeConverterBindings() {\n     return ImmutableSet.copyOf(state.getConvertersThisLevel());\n   }\n \n-  private static class BindingsMultimap {\n-    final Map<TypeLiteral<?>, List<Binding<?>>> multimap = Maps.newHashMap();\n-\n-    <T> void put(TypeLiteral<T> type, Binding<T> binding) {\n-      List<Binding<?>> bindingsForType = multimap.get(type);\n-      if (bindingsForType == null) {\n-        bindingsForType = Lists.newArrayList();\n-        multimap.put(type, bindingsForType);\n-      }\n-      bindingsForType.add(binding);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\") // safe because we only put matching entries into the map\n-    <T> List<Binding<T>> getAll(TypeLiteral<T> type) {\n-      List<Binding<?>> bindings = multimap.get(type);\n-      return bindings != null\n-          ? Collections.<Binding<T>>unmodifiableList((List) multimap.get(type))\n-          : ImmutableList.<Binding<T>>of();\n-    }\n-  }\n-\n   /** Returns parameter injectors, or {@code null} if there are no parameters. */\n   SingleParameterInjector<?>[] getParametersInjectors(List<Dependency<?>> parameters, Errors errors)\n       throws ErrorsException {",
      "parent_sha": "d2f039541811ebc6d0ab3ba94df302eb70d34037"
    }
  }
]